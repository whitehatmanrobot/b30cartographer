           }
            else
                {
                /* The printer won't tell us it page size; we'll have to settle
                for the printable area. */
                vsepNormal.xaMac = ZaFromMm(GetDeviceCaps(vhDCPrinter,
                  HORZSIZE));
                vsepNormal.yaMac = ZaFromMm(GetDeviceCaps(vhDCPrinter,
                  VERTSIZE));
                }

            /* The page size cannot be smaller than the printable area. */
            if (vsepNormal.xaMac < dxaPrPage)
                {
                vsepNormal.xaMac = dxaPrPage;
                }
            if (vsepNormal.yaMac < dyaPrPage)
                {
                vsepNormal.yaMac = dyaPrPage;
                }

            /* Determine the offset of the printable area on the page. */
            if (Escape(vhDCPrinter, GETPRINTINGOFFSET, 0, (LPSTR)NULL,
              (LPSTR)&pt))
                {
                dxaPrOffset = MultDiv(pt.x, dxaPrPage, dxpPrPage);
                dyaPrOffset = MultDiv(pt.y, dyaPrPage, dypPrPage);
                }
            else
                {
                /* The printer won't tell us what the offset is; assume the
                printable area is centered on the page. */
                dxaPrOffset = (vsepNormal.xaMac - dxaPrPage) >> 1;
                dyaPrOffset = (vsepNormal.yaMac - dyaPrPage) >> 1;
                }

            /* Determine the minimum margins. */
            dxaRightMin = imax(0, vsepNormal.xaMac - dxaPrOffset - dxaPrPage);
            dyaBottomMin = imax(0, vsepNormal.yaMac - dyaPrOffset - dyaPrPage);
            }
        else
            {
            /* We have no printer; so, the page is 8-1/2" by 11" for now. */
            vsepNormal.xaMac = 8 * czaInch + czaInch / 2;
            vsepNormal.yaMac = 11 * czaInch;

            /* Assume the entire page can be printed. */
            dxaPrOffset = dyaPrOffset = dxaRightMin = dyaBottomMin = 0;
            }

        /* Ensure that the "normal" margins are larger than the minimum. */
        vsepNormal.xaLeft = umax(cxaInch * 1 + cxaInch / 4, dxaPrOffset);
        vsepNormal.dxaText = vsepNormal.xaMac - vsepNormal.xaLeft - umax(cxaInch
          * 1 + cxaInch / 4, dxaRightMin);
        vsepNormal.yaTop = umax(cyaInch * 1, dyaPrOffset);
        vsepNormal.dyaText = vsepNormal.yaMac - vsepNormal.yaTop - umax(cyaInch
          * 1, dyaBottomMin);

        /* Position the running-heads and the page numbers. */
        vsepNormal.yaRH1 = umax(cyaInch * 3 / 4, dyaPrOffset);
        vsepNormal.yaRH2 = vsepNormal.yaMac - umax(cyaInch * 3 / 4,
          dyaBottomMin);
        vsepNormal.xaPgn = vsepNormal.xaMac - umax(cxaInch * 1 + cxaInch / 4,
          dxaRightMin);
        vsepNormal.yaPgn = umax(cyaInch * 3 / 4, dyaPrOffset);
#endif /* not FIXED_PAGE */

        vsepNormal.pgnStart = pgnNil;
        /* vsepNormal.fAutoPgn = false; */
        /* vsepNormal.fEndFtns = false; */
        vsepNormal.cColumns = 1;
        vsepNormal.dxaColumns = cxaInch / 2;
        /* vsepNormal.dxaGutter = 0; */

        vdxaPaper = vsepNormal.xaMac;
        vdyaPaper = vsepNormal.yaMac;

        vfli.doc = docNil;      /* Invalidate vfli */
        ichpMacFormat = ichpMacInitFormat;
        vhgchpFormat = (struct CHP (**)[])HAllocate(ichpMacInitFormat * cwCHP);
        if (FNoHeap(vhgchpFormat))
            {
            return FALSE;
            }
        return TRUE;
}
/* end of  F I n i t P r o p s  */





STATIC int NEAR FInitFiles()
{
        extern WORD vwDosVersion;

        int fn;
        int cchT;
        struct FKP *pfkp;
        struct FCB *pfcb;
        int osfnExtra;
        CHAR sz [cchMaxFile];

        rfnMac = rfnMacEdit;

        /* Set DOS version we're running under */

        vwDosVersion = WDosVersion();

        InitBps();

#ifdef CKSM
#ifdef DEBUG
        {
        extern int ibpMax, ibpCksmMax;
        extern unsigned (**hpibpcksm) [];

        hpibpcksm = (unsigned (**) [])HAllocate( ibpMax );
        if (FNoHeap( hpibpcksm ))
            return FALSE;
        ibpCksmMax = ibpMax;
        }
#endif
#endif

            /* sz <-- name of new, unique file which will be fnScratch */
        sz[ 0 ] = '\0';     /* Create it in the root on a temp drive */
        if ((fn=FnCreateSz( sz, cpNil, dtyNetwork )) == fnNil )
                /* Couldn't create scratch file: fail */
            return FALSE;

        Assert(fn == fnScratch); /* fnScratch hardwired to 0 for efficiency */
        FreezeHp();
        pfcb = &(**hpfnfcb)[fnScratch];
        pfcb->fFormatted = true; /* Sort of a formatted file */
        pfcb->fDelete = true; /* Kill this file when we quit */
        MeltHp();
        vfkpdParaIns.brun = vfkpdCharIns.brun = 0;
        vfkpdParaIns.bchFprop = vfkpdCharIns.bchFprop = cbFkp;
        vfkpdParaIns.pn = PnAlloc(fnScratch);
        ((struct FKP *) PchGetPn(fnScratch, vfkpdParaIns.pn, &cchT, true))->fcFirst =
            fc0;
        vfkpdCharIns.pn = PnAlloc(fnScratch);
        ((struct FKP *) PchGetPn(fnScratch, vfkpdCharIns.pn, &cchT, true))->fcFirst =
            fc0;

        /* The following can really be allocated 0 words, but why push our luck? */
        vfkpdParaIns.hgbte = (struct BTE (**)[]) HAllocate(cwBTE);
        vfkpdCharIns.hgbte = (struct BTE (**)[]) HAllocate(cwBTE);
        vfkpdParaIns.ibteMac = vfkpdCharIns.ibteMac = 0;
        if (FNoHeap(vfkpdParaIns.hgbte) || FNoHeap(vfkpdCharIns.hgbte))
                return FALSE;

        blt(&vchpNormal, &vchpInsert, cwCHP);
        blt(&vchpNormal, &vchpSel, cwCHP);
        blt(vppapNormal, &vpapPrevIns, cwPAPBase + cwTBD);
        return TRUE;
}
/* end of   F I n i t F i l e s  */




InitBps()
{
/* called from initfiles to set up the tables */
        int ibp, iibp;
        int rfn;
        int fn;

/* In order impliment a LRU page swap strategy, a time stamp(TS) scheme is */
/* used. Associated with each buffer slot is a time stamp.  The least */
/* recently used slot is found by locating the slot with the smallest time */
/* stamp. Every time a new page is brought into the buffer, it TS is set  */
/* equal to the value of a incrimented global TS counter (tsMru...). */
/* Initially, the time stamps are set so that they increase as we move */
/* toward the end of the table.  Thus, even though the entire buffer pool */
/* is initially empty, slots at the beginning of the table will be */
/* allocated first.  */

        {
        register struct ERFN *perfn = &dnrfn [0];

        for (rfn = 0; rfn < rfnMac; rfn++, perfn++)
                {
                perfn->fn = fnNil;
                perfn->ts = rfn;
                }
        tsMruRfn = rfnMac /* + ? */;
        }

        for (iibp = 0; iibp < iibpHashMax; iibp++)
                rgibpHash[iibp] = ibpNil;
        {
        register struct BPS *pbps=&mpibpbps [0];

        for (ibp = 0; ibp < ibpMax; ++ibp, pbps++)
                {
                pbps->fn = fnNil;
                pbps->fDirty = false;
                pbps->ts = ibp;
                pbps->ibpHashNext = ibpNil;
                }
        tsMruBps = ibpMax + cbpMustKeep;
        }
        /* In IbpEnsureValid (file.c) we may not want to use the least */
        /* recently used slot for certain reasons.  But, we do want to */
        /* be assured that we do not clobber the 'cbpMustKeep' most */
        /* recently used slots.  Our check consists of making sure */
        /* (tsMruBps - ts_in_question) < cbpMustKeep.  By the above */
        /* statement, we are assured that non of the empty slots satisfy */
        /* this condition. */

        /* Allocate initial checksum array */



}
/* end of  I n i t B p s  */



#ifdef OURHEAP
FCreateRgbp()
{
    rgbp = (CHAR (*)[cbSector])memory;
    memory = (int *)((unsigned)memory + (unsigned)(ibpMax)
             * cbSector);
    memory = (int *)(((unsigned) memory + 1) & ~1); /* word boundary */
    rgibpHash = (CHAR *)memory;
    memory = (int *)((unsigned)memory +
             (unsigned)(iibpHashMax * sizeof(CHAR)));
    memory = (int *)(((unsigned) memory + 1) & ~1); /* word boundary */
    mpibpbps = (struct BPS *)memory;
    memory = (int *)((unsigned)memory +
             (unsigned)(ibpMax * sizeof(struct BPS)));
    memory = (int *)(((unsigned) memory + 1) & ~1);
    return (memory <= pmemMax);
}
/* end of  F C r e a t e R g b p  */
#else /* use windows' memory manager */
FCreateRgbp()
{
extern int vfLargeSys;

long lcbFree;
unsigned cb;

    ibpMax = ibpMaxSmall;
    lcbFree = GlobalCompact((DWORD)0);
    if (lcbFree > 0x00030D40 /* 200K */)
        {
        /* we can start with a bigger page buffer */
        ibpMax = ibpMaxBig;
        vfLargeSys = TRUE;
        }

    iibpHashMax = ibpMax * 2 + 1;

    cb = ((ibpMax * cbSector * sizeof(CHAR) + 1) & ~1) /* rgbp */
         + ((iibpHashMax * sizeof(CHAR) + 1) & ~1) /* rgibpHash */
         + ((ibpMax * sizeof(struct BPS) + 1) & ~1); /* mpibpbps */

    memory = (int *)LocalAlloc(LPTR, cb);

    if (memory == NULL)
        {
        ibpMax = ibpMaxSmall;
        iibpHashMax = ibpMax * 2 + 1;
        cb = ((ibpMax * cbSector * sizeof(CHAR) + 1) & ~1) /* rgbp */
             + ((iibpHashMax * sizeof(CHAR) + 1) & ~1) /* rgibpHash */
             + ((ibpMax * sizeof(struct BPS) + 1) & ~1); /* mpibpbps */
        memory = (int *)LocalAlloc(LPTR, cb);
        }

    if (memory == NULL)
        return FALSE;

    rgbp = (CHAR (*)[cbSector])memory;
    memory = (int *)((unsigned)memory + (unsigned)(ibpMax)
             * cbSector);
    memory = (int *)(((unsigned) memory + 1) & ~1); /* word boundary */
    rgibpHash = (CHAR *)memory;
    memory = (int *)((unsigned)memory +
             (unsigned)(iibpHashMax * sizeof(CHAR)));
    memory = (int *)(((unsigned) memory + 1) & ~1); /* word boundary */
    mpibpbps = (struct BPS *)memory;

/*
    memory = (int *)((unsigned)memory +
             (unsigned)(ibpMax * sizeof(struct BPS)));
    memory = (int *)(((unsigned) memory + 1) & ~1);*/

    return TRUE;
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\looks.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains the definitions of the various codes returned from the
"looks" expert keys in Windows Word. */

#define fLooks		0x4000

#define fCharLooks	0x0100
#define fParaLooks	0x0200
#define fSectLooks	0x0400
#define fUserDefined	0x0800

#define ilkNil		0x4fff

/* Character looks */
#define ilkStd		0x4100
#define ilkBold		0x4101
#define ilkItalic	0x4102
#define ilkUline	0x4103
#define ilkSuper	0x4104
#define ilkSub		0x4105
#define ilkSmCaps	0x4106
#define ilkHpsSmall	0x4107
#define ilkHpsBig	0x4108
#define ilkFont		0x4109

/* Paragraph looks */
#define ilkGeneral	0x4200
#define ilkLeft		0x4201
#define ilkRight	0x4202
#define ilkCenter	0x4203
#define ilkJust		0x4204
#define ilkOpen		0x4205
#define ilkIndent	0x4206
#define ilkNest		0x4207
#define ilkUnnest	0x4208
#define ilkHang		0x4209

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\macro.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains some useful macros. */

#define FillBuf(pb, cb, ch)     bltbc((pb), (CHAR)(ch), cb)

#define FSzSame(sz1, sz2)       (WCompSz(sz1, sz2) == 0)

#define SetWords(pw, w, cw)     bltc((CHAR *)(pw), (unsigned)(w), cw)

#define SetBytes(pb, b, cb)     bltbc((CHAR *)(pb), (CHAR)(b), cb)

#define NMultDiv(w1, w2, w3)    MultDiv(w1, w2, w3)

/* Theses macros are used by Windows Word to facilitate the conversion form
Mac Word. */

#define SetSpaceExtra(dxp)      SetTextJustification(vhMDC, dxp, 1)

#define TextWidth(rgch, w, cch) LOWORD(GetTextExtent(vhMDC, (LPSTR)rgch, cch))


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\loadfnt2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* loadfnt2.c - MW font support code */

#define NOWINMESSAGES
#define NOVIRTUALKEYCODES
#define NOSYSMETRICS
#define NOMENUS
#define NOWINSTYLES
#define NOCTLMGR
#define NOCLIPBOARD
#include <windows.h>

#include "mw.h"
#include "macro.h"
#define NOUAC
#include "cmddefs.h"
#include "fontdefs.h"
#include "docdefs.h"


extern int vifceMac;
extern union FCID vfcidScreen;
extern union FCID vfcidPrint;
extern struct FCE rgfce[ifceMax];
extern struct FCE *vpfceMru;
extern struct FCE *vpfceScreen;
extern struct FCE *vpfcePrint;
extern struct DOD (**hpdocdod)[];


struct FCE * (PfceLruGet(void));
struct FCE * (PfceFcidScan(union FCID *));


struct FCE * (PfceLruGet())
/* tosses out the LRU cache entry's information */

    {
    struct FCE *pfce;

    pfce = vpfceMru->pfcePrev;
    FreePfce(pfce);
    return(pfce);
    }


FreePfce(pfce)
/* frees the font objects for this cache entry */
struct FCE *pfce;

    {
    int ifce;
    HFONT hfont;

    if (pfce->fcidRequest.lFcid != fcidNil)
	{
	hfont = pfce->hfont;

	/* see if we're about to toss the screen or printer's current font */
	if (pfce == vpfceScreen)
	    {
	    ResetFont(FALSE);
	    }
	else if (pfce == vpfcePrint)
	    {
	    ResetFont(TRUE);
	    }

#ifdef DFONT
	CommSzNum("Deleting font: ", hfont);
#endif /* DFONT */

	if (hfont != NULL)
	    {
            DeleteObject(hfont);
	    pfce->hfont = NULL;
	    }

	if (pfce->hffn != 0)
	    {
	    FreeH(pfce->hffn);
	    }

	pfce->fcidRequest.lFcid = fcidNil;
	}
    }


FreeFonts(fScreen, fPrinter)
/* frees up the font objects for the screen, and the printer */

int fScreen, fPrinter;
    {
    int ifce, bit;

    for (ifce = 0; ifce < vifceMac; ifce++)
	{
	bit = (rgfce[ifce].fcidRequest.strFcid.wFcid & bitPrintFcid) != 0;
	if (bit && fPrinter || !bit && fScreen)
	    FreePfce(&rgfce[ifce]);
	}
    }


struct FCE * (PfceFcidScan(pfcid))
union FCID *pfcid;

/* look for this font the "hard way" in the LRU list */
    {
    struct FFN **hffn, **hffnT;
    register struct FCE *pfce;
    struct FFN **MpFcidHffn();

    hffn = MpFcidHffn(pfcid);
    pfce = vpfceMru;
    do
	{
	hffnT = pfce->hffn;
	if (hffnT != NULL)
	    if (WCompSz((*hffn)->szFfn, (*hffnT)->szFfn) == 0 &&
	      pfcid->strFcid.hps == pfce->fcidRequest.strFcid.hps &&
	      pfcid->strFcid.wFcid == pfce->fcidRequest.strFcid.wFcid)
		{
		pfce->fcidRequest.strFcid.doc = pfcid->strFcid.doc;
		pfce->fcidRequest.strFcid.ftc = pfcid->strFcid.ftc;
		return(pfce);
		}
	pfce = pfce->pfceNext;
	}
    while (pfce != vpfceMru);

    return(NULL);
    }



struct FFN **MpFcidHffn(pfcid)
/* makes sure we use a font code that exists in the table - this is insurance
   against out of memory problems */

union FCID *pfcid;
    {
    int ftc;
    struct FFNTB **hffntb;

    ftc = pfcid->strFcid.ftc;
    hffntb = HffntbGet(pfcid->strFcid.doc);
    if (ftc >= (*hffntb)->iffnMac)
	ftc = 0;

    return((*hffntb)->mpftchffn[ftc]);
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\mainloop.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* MainLoop.c -- WRITE's main message loop */

#define NOGDICAPMASKS
//#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOOPENFILE
#define NOPEN
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#define NOFONT
#define NOGDI
#define NOBRUSH
#define NOATOM
#define NOSCROLL
#define NOCOLOR
#include <windows.h>

#define NOUAC
#include "mw.h"
#include "cmddefs.h"
#include "ch.h"
#include "docdefs.h"
#include "fmtdefs.h"
#include "dispdefs.h"
#include "printdef.h"
#include "wwdefs.h"
#include "propdefs.h"
#include "filedefs.h"
#define NOSTRUNDO
#define NOSTRERRORS
#include "str.h"
#include "preload.h"


extern CHAR		(*rgbp)[cbSector];
extern CHAR		*rgibpHash;
extern struct BPS	*mpibpbps;
extern int		ibpMax;
extern int		iibpHashMax;
extern struct DOD	(**hpdocdod)[];
extern int		docCur;
extern int		visedCache;
extern typeCP		cpMinDocument;
extern struct WWD	rgwwd[];
extern int		wwCur;
extern struct FLI	vfli;
extern struct WWD	*pwwdCur;
extern int		docMode;
extern CHAR		stMode[];
extern int		isedMode;
extern int		vdocPageCache;
extern typeCP		vcpMinPageCache;
extern typeCP		vcpMacPageCache;
extern int		vipgd;
extern int		vfInsLast;
extern struct SEP	vsepAbs;
extern struct DOD	(**hpdocdod)[];
extern int		vfSelHidden;
extern struct SEL	selCur;
extern int		vfAwfulNoise;
extern HWND		vhWndPageInfo;
extern int		vfSeeSel;
extern int		vipgd;
extern int		vfInsEnd;   /* Is insert point at end-of-line? */
extern int		vfModeIsFootnote;   /*	true when szMode contains string "Footnote" */
/* used by ShowMode */
extern int		docMode;
static int		isedMode = iNil;
static int		ipgdMode = iNil;
extern CHAR		szMode[];
extern HCURSOR		vhcIBeam;
#ifdef DBCS
extern int		donteat;	/* disp.c : if TRUE vmsgLast has msg */
#endif
static int		vfSizeMode = false;
int vcCount = 1; /* count to be decremented until 0 before trying to grow rgbp */





NEAR FNeedToGrowRgbp(void);



MainLoop()
{
    extern int vfIconic;
    extern int vfDead;
    extern int vfDeactByOtherApp;
    extern MSG vmsgLast;
    extern int vfDiskFull;
    extern int ferror;
    extern HWND hParentWw;
    extern HANDLE   vhAccel; /* handle to accelerator table */
    extern HWND vhDlgFind, vhDlgRunningHead, vhDlgChange;

    while (TRUE)
	{
	if (!vfDeactByOtherApp && !vfIconic && !vfDead &&
	  !FImportantMsgPresent())
	    {	/* Neither an icon nor a dying ember -- perform background
		   tasks like screen update, showing selection, etc. */
	    Idle();
	    }

	/* We are done Idling or there's a message waiting for us */
#ifdef DBCS
	if ( donteat ) {
	    /* We have already get message */
	    donteat = FALSE;
	    }
	else {
	    if (!GetMessage( (LPMSG)&vmsgLast, NULL, 0, 0 ))
	        {
	        /* Terminating the app; return from WinMain */
LTerm:
	        break;
	        }
	}
#else
	if (!GetMessage( (LPMSG)&vmsgLast, NULL, 0, 0 ))
	    {
	    /* Terminating the app; return from WinMain */
LTerm:
	    break;
	    }
#endif

	/* Reset disk full error flag */
	vfDiskFull = false;
	ferror = false;

#if WINVER >= 0x300    
    if (hParentWw == NULL)
        /* Odd shut-down condition where we've hParentWw has been 
           invalidated without our genuine knowledge and thus RIP's */
        goto LTerm; 
#endif

	/* Handle modeless dialog box messages thru IsDialogMessage. */
	if (
         !(vhDlgFind        != NULL && IsDialogMessage(vhDlgFind,       &vmsgLast))
	  && !(vhDlgChange      != NULL && IsDialogMessage(vhDlgChange,     &vmsgLast)) 
      && !(vhDlgRunningHead != NULL && IsDialogMessage(vhDlgRunningHead,&vmsgLast)) 
      && !(TranslateAccelerator(hParentWw, vhAccel, &vmsgLast))
       )
	    {
	    int kc;

	    /* Even if we process the toggle key, still want to translate it */
	    if (FCheckToggleKeyMessage( &vmsgLast ))
		{
		goto Translate;
		}

	    if ( ((kc = KcAlphaKeyMessage( &vmsgLast )) != kcNil) &&
		 (kc != kcAlphaVirtual) )
		{
#ifdef CYCLESTOBURN
		PreloadCodeTsk( tskInsert );
#endif
		AlphaMode( kc );
		}
	    else if (!FNonAlphaKeyMessage( &vmsgLast, TRUE ))
		{
Translate:
		TranslateMessage( (LPMSG)&vmsgLast);
		DispatchMessage((LPMSG)&vmsgLast);
		}
	    }
	}   /* end while (TRUE) */
}


/* I D L E */
#ifdef DEBUG
int vfValidateCode;
#endif

Idle()
{     /* Idle routine -- do background processing things */
    extern int vfOutOfMemory;
    extern int ibpMaxFloat;
    extern int vfLargeSys;
    extern int vfDeactByOtherApp;
    typeCP cpEdge;
    int cdr;

#ifdef DEBUG
    extern int fIbpCheck;
    extern int fPctbCheck;
    int fIbpT=fIbpCheck;
    int fPctbT=fPctbCheck;

    fIbpT = fIbpCheck;
    fPctbT = fPctbCheck;
    fPctbCheck = fIbpCheck = TRUE;
    CheckIbp();
    CheckPctb();
    fIbpCheck = fIbpT;
    fPctbCheck = fPctbT;
#endif

    vfAwfulNoise = false; /* Re-enable beep */

    /* Here is where we attempt to recognize that we have
       regained memory and are no longer in an error state */
    if (vfOutOfMemory)
	{
	extern int vfMemMsgReported;

	if (FStillOutOfMemory())
	    {
	    return;
	    }
	else
	    {
	    /* Hooray! We recovered from out-of-memory */
	    vfOutOfMemory = vfMemMsgReported = FALSE;
	    }
	if (FImportantMsgPresent())
	    return;
	}

    /* Make sure we repaint what Windows considers to be invalid */
    UpdateInvalid();
    UpdateDisplay(true);
    if (wwdCurrentDoc.fDirty)
	    /* Update was interrupted */
	return;

    Assert( wwCur >= 0 );

    {
    extern int vfSeeEdgeSel;
    int dlMac = pwwdCur->dlMac;
    struct EDL *pedl = &(**(pwwdCur->hdndl))[dlMac - 1];

    cpEdge = CpEdge();

    if ( vfSeeSel &&
	    (vfSeeEdgeSel || (selCur.cpFirst == selCur.cpLim) ||
	    (selCur.cpLim <= pwwdCur->cpFirst) ||
	    (selCur.cpFirst >= pedl->cpMin + pedl->dcpMac)) )
	{
	extern int vfInsEnd;

	if (vfInsEnd)
		/* Adjust for insert point at end of line */
	    cpEdge--;
   cpEdge = max(0, cpEdge);    /* make sure cpEdge is at least 0 */

	if (selCur.cpFirst == selCur.cpLim)
	    ClearInsertLine();
	PutCpInWwHz(cpEdge);
	if (FImportantMsgPresent())
	    return;
	}
    vfSeeSel = vfInsLast = vfSeeEdgeSel = false;


#ifdef DEBUG
    if (vfValidateCode)
	ValidateCodeSegments(); /* Special kernel call to test checksums */
#endif

    if (vfSelHidden && !vfDeactByOtherApp)
	{ /* Turn on selection highlight */
	vfInsEnd = selCur.fEndOfLine;
	vfSelHidden = false;
	ToggleSel(selCur.cpFirst, selCur.cpLim, true);
	if (FImportantMsgPresent())
	    return;
	}

    if (!vfSizeMode)
	{
	CheckMode();
	if (FImportantMsgPresent())
	    return;
	}
    }

#define cbpIncr 5

    if (--vcCount == 0)
	{
#ifdef DEBUG
	dummy();    /* So Chi-Chuen can set a breakpoint here */
#endif
	UnlockData(0);
	if ( GlobalCompact((DWORD)0) >= (DWORD)LCBAVAIL )
	    {
	    vfLargeSys = TRUE;
	    ibpMaxFloat = 255; /* about 32K for rgbp */
	    }
	else
	    {
	    vfLargeSys = FALSE;
	    ibpMaxFloat = 75; /* about 10K for rgbp */
	    }
	LockData(0);
	/* after adjustment, ibpMaxFloat may be smaller than current ibpMax
	   but we will not grow rgbp anymore and rgbp will be reduced eventually
	   when we need more heap space */
	if ( ibpMax < ibpMaxFloat && FNeedToGrowRgbp() )
	    if (!FGrowRgbp(cbpIncr))
		FGrowRgbp(1);
	if (FImportantMsgPresent())
	    return;
	}

    CloseEveryRfn( FALSE ); /* Close files on removable media */

#ifdef CYCLESTOBURN
    if (vfLargeSys)
	{   /* Large system, preload code for as much as possible */
	int tsk;

	for ( tsk = tskMin; tsk < tskMax; tsk++ )
	    PreloadCodeTsk( tsk );
	}
    else
	    /* Small system, preload code for insert only */
	PreloadCodeTsk( tskInsert );
#endif

    EndLongOp(vhcIBeam);
}


#ifdef DEBUG
dummy()
{
}
#endif


UpdateInvalid()
{   /* Find out what Windows considers to be the invalid range of
       the current window.  Mark it invalid in WRITE's data structures &
       blank the area on the screen */

extern HWND hParentWw;
extern long ropErase;
extern int vfDead;

RECT rc;

if ( (pwwdCur->wwptr != NULL) &&
	/* Getting the update rect for the parent is essentially the same as
	   processing any WM_ERASEBKGND messages that might be out there for the
	   parent. */
     (GetUpdateRect( hParentWw, (LPRECT) &rc, TRUE ),
     GetUpdateRect( pwwdCur->wwptr, (LPRECT) &rc, TRUE )) &&
	/* Check for vfDead is so we don't repaint after we have
	   officially closed.  Check is AFTER GetUpdateRect call so
	   we DO clear the background and validate the border */
     !vfDead )
    {
    int ypTop = rc.top;

    if (ypTop < pwwdCur->ypMin)
        {   /* Repaint area includes stripe above ypMin -- validate it,
               since erasure is the only repaint necessary */
        ypTop = pwwdCur->ypMin; /* Only invalidate below ypMin */

        /* The above is NOT ensuring that the upper 4 pixel rows
           in the text window get cleared, so we use brute force ..pault */
        PatBlt(GetDC(pwwdCur->wwptr), 0, 0, pwwdCur->xpMac, pwwdCur->ypMin, 
               ropErase);
        }

    if (ypTop < rc.bottom)
	{
	InvalBand( pwwdCur, ypTop, rc.bottom );
	}

    /* Since we have found out the invalid rect, and marked it invalid
       in our structures, we don't want to hear about it again,
       so we tell windows that we have made everything valid */
    ValidateRect( pwwdCur->wwptr, (LPRECT) NULL );
    }
}



/* C H E C K  M O D E */
CheckMode()
{
    typeCP cp;
    int pgn;
    struct PGTB **hpgtb;
    CHAR st[30];
    CHAR *pch;

#ifdef BOGUS
    /* The mode is driven off of the first cp in the window. */
    cp = pwwdCur->cpFirst;
#else /* not BOGUS */
    /* The mode is driven off of the last cp of the first line in the window. */
	{
	register struct EDL *pedl = &(**pwwdCur->hdndl)[0];

	cp = CpMax(pedl->cpMin + pedl->dcpMac - 1, cp0);
	}
#endif /* not BOGUS */

#ifdef CASHMERE
    if (cp > CpMacText(docCur)) /* in footnote and running head */
	{
	SetModeToFootnote();
	return;
	}
#endif /* CASHMERE */

    CacheSect(docCur, cp);

    /* If the doc has changed since the last time we entered, or the current cp
    is not in the last page that was cached, then cache the current page. */
    if (!(vdocPageCache == docCur && cp >= vcpMinPageCache && cp <
      vcpMacPageCache))
	{
	CachePage(docCur, cp);
	}

    /* If the current doc, ised, and ipgd have not changed then the page number
    is the same, so return. */
    if (docMode == docCur && isedMode == visedCache && ipgdMode == vipgd)
	{
	return;
	}

    /* szMode is going to be set to "Page nnn" or "Pnnn Dnnn". */
    vfModeIsFootnote = false;

    /* Record the current doc, ised and ipgd. */
    docMode = docCur;
    isedMode = visedCache;
    ipgdMode = vipgd;

    /* Retrieve the current page number. */
    hpgtb = (**hpdocdod)[docMode].hpgtb;
    pgn = (vipgd == iNil) ? ((vsepAbs.pgnStart == pgnNil) ? 1 : vsepAbs.pgnStart)
			  : (**hpgtb).rgpgd[vipgd].pgn;

#ifdef CASHMERE
    /* If the document has multiple sections and we had to set szMode to "Pnnn
    Dnnn", then return. */
    if ((isedMode != iNil) && (FSetModeForSection(pgn)))
	{
	return;
	}
#endif /* CASHMERE */

    /* Place "Page nnn" in szMode and output to mode field of window. */
#if defined(KOREA)
    pch = &szMode[0];
    *pch++ = chSpace;
    ncvtu(pgn, &pch);
    *pch++ = chSpace;
    FillStId(st, IDSTRChPage, sizeof(st));
    bltbyte(&st[1], pch, st[0]+1);
    //*pch = '\0';
#else
    FillStId(st, IDSTRChPage, sizeof(st));
    st[1] = ChUpper(st[1]);
    bltbyte(&st[1], szMode, st[0]);
    pch = &szMode[st[0]];
    *pch++ = chSpace;
    ncvtu(pgn, &pch);
    *pch = '\0';
#endif
    DrawMode();
}  /* end CheckMode */


NEAR FNeedToGrowRgbp()
{ /* return true iif page buffers are all used up */
register struct BPS *pbps;
struct BPS *pbpsMax = &mpibpbps[ibpMax];
extern int ibpMaxFloat;

vcCount = 512;

if (ibpMax + 1 > ibpMaxFloat)
    return(FALSE); /* don't even try if adding one more page will exceed limit */

for (pbps = &mpibpbps[0]; pbps < pbpsMax; pbps++)
    {
    /* any unused page? */
    if (pbps->fn == fnNil)
	{
	return(FALSE);
	}
    }
return(TRUE);
}


CachePage(doc,cp)
int	doc;
typeCP	cp;
    {
    struct PGTB **hpgtb;
    int cpgd;
    typeCP cpMacPage;

    vdocPageCache = doc;
    hpgtb = (**hpdocdod)[doc].hpgtb;

    if (hpgtb == 0 || (**hpgtb).cpgd == 0)
	{
	vcpMinPageCache = cp0;
	vcpMacPageCache = cpMax;
	vipgd = -1;
	return;
	}

	/* Get index to beginning of NEXT page */
    cpgd = (**hpgtb).cpgd;
    vipgd = IcpSearch(cp+1, &((**hpgtb).rgpgd[0]), sizeof(struct PGD),
			    bcpPGD, cpgd);
    cpMacPage = (**hpgtb).rgpgd[vipgd].cpMin;
    if (cp >= cpMacPage)
	{ /* Last page */
	vcpMinPageCache = cpMacPage;
	vcpMacPageCache = (**hpdocdod)[doc].cpMac + 1;
	}
    else
	{
	vcpMinPageCache = (vipgd == 0) ? cpMinDocument : (**hpgtb).rgpgd[vipgd - 1].cpMin;
	vcpMacPageCache = cpMacPage;
	vipgd -= 1;  /* so that ShowMode can get correct pgn */
	}
    }



#ifdef CASHMERE
/* A D D  V I S I  S P A C E S */
AddVisiSpaces(ww, pedl, dypBaseline, dypFontSize)
int ww;
struct EDL *pedl;  /* Do no heap movement in this subroutine */
int dypBaseline, dypFontSize;
	{
	/* Put a centered dot in each space character, and show all tabs */
	int ich;
	struct WWD *pwwd = &rgwwd[ww];
	int xpPos = vfli.xpLeft + xpSelBar - pwwd->xpMin;
	int ypPos;
	WORDPTR bitsDest = pwwd->wwptr + (long)STRUCIDX(portBits);
	RECT rcDest;
	int xpRightReal = vfli.xpRight - pwwd->xpMin;
	extern BITPAT patVisiTab;
	BITMAP bmap;

	ypPos = pedl->yp - dypBaseline - dypFontSize / 4;
	rcDest.bottom = ypPos + 4;
	rcDest.top = rcDest.bottom - 8;

	SetRect(&bmap.bounds, 8, 0, 16, 8);
	bmap.rowBytes = 2;
	bmap.baseAddr = MPLP(&patVisiTab);

	PenSize(1, 1);
	PenMode(patXor);

	for (ich = 0; ich < vfli.ichMac; ++ich)
		{
		switch(vfli.rgch[ich])
			{
		case chSpace:
			MoveTo(xpPos + vfli.rgdxp[ich] / 2, ypPos);
			Line(0, 0);
			break;
		case chTab:
			rcDest.left = xpPos - 1;
			rcDest.right = rcDest.left + 8;
			CopyBits(MPLP(&bmap), bitsDest, &(bmap.bounds),
				&rcDest, srcXor, 0l);
			}
		xpPos += vfli.rgdxp[ich];
		}
	}
#endif /* CASHMERE */


#ifdef ENABLE
/* F  S E T  M O D E  F O R  S E C T I O N  */
FSetModeForSection(pgn)
int pgn;  /* pgn is the current page number */
	{
	struct	SETB *psetb;
	struct	SED  *psed;
	int cch, sectn;
	CHAR *pch;

#ifdef DEBUG
	Assert(HsetbGet(docMode) != 0);
#endif /* DEBUG*/

	psetb = *HsetbGet(docMode);
	psed  = psetb->rgsed;

	/* Decide if a mode string of the form "Pnnn Dnnn" needs to be */
	/* displayed. If no, just return. If yes, derive the section # */

	if(psed->cp == CpMacText(docMode))
		return(FALSE);
	else
		{
		if (psetb->csed <= 1)
		       return(FALSE);
		sectn = isedMode + 1;
		}

	/*  Place "Pnnn Dnnn"  in stMode and output to window */
	pch = &stMode[1];
	*pch++ = chPnMode;
	ncvtu(pgn,&pch);
	*pch++ = chSpace;
	*pch++ = chDivMode;
	ncvtu(sectn,&pch);
	stMode[0] = pch - stMode - 1;
	DrawMode();
	return(TRUE);
	}
#endif /* ENABLE */


#ifdef CASHMERE
Visify(pch, pcch)
CHAR *pch;
int  *pcch;
{ /* Transform chars to "Visible font" */
CHAR *pchT = pch;
int cch = *pcch;

while (cch--)
	{
	if ((*pchT = ChVisible(*pch++)) != 0)
		pchT++;
	else
		--(*pcch);
	}
}
#endif /* CASHMERE */



#ifdef CASHMERE
int ChVisible(ch)
int ch;
{ /* Return "visible font" for ch */
switch (ch)
	{
#ifdef CRLF
case chReturn:
	return 0;  /* chNil won't fit into a byte */
#endif
case chNRHFile: return chHyphen;
case chNewLine: return chVisNewLine;
case chEol: return chVisEol;
case chTab: return chVisTab;
case chSect: return chVisSect;
default:
	return ch;
	}
}
#endif /* CASHMERE */




#ifdef CYCLESTOBURN
void PreloadCodeTsk( tsk )
int tsk;
{
switch (tsk) {

    case tskInsert:
	LoadF( IbpMakeValid );		/* FILE.C */
	LoadF( MoveLeftRight ); 	/* CURSKEYS.C */
	LoadF( CtrBackDypCtr ); 	/* SCROLLVT.C */    /* Sometimes */
	LoadF( PutCpInWwHz );		/* SCROLLHZ.C */
	LoadF( ValidateTextBlt );	/* INSERT2.C  */
	LoadF( InsertEolInsert );	/* INSERTCO.C */
	LoadF( Replace );		/* EDIT.C     */
	LoadF( AlphaMode );		/* INSERT.C   */
	break;
    case tskFormat:
	LoadF( DoPrm ); 		    /* DOPRM.C */
	LoadF( AddSprmCps );		    /* ADDPRM.C */
	LoadF( SetUndo );		    /* EDIT.C */
	LoadF( FInitFontEnum ); 	    /* FONTS.C */
	LoadF( SetAppMenu );		    /* MENU.C */
	break;
    case tskScrap:
	LoadWindowsF( SetClipboardData );   /* USER!WINCLIP */
	LoadF( Replace );		    /* EDIT.C */
	LoadF( fnCutEdit );		    /* CLIPBORD.C */
	LoadF( SetAppMenu );		    /* MENU.C */
	break;
    }
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\mdoc.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/


#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOOPENFILE
#define NORESOURCE
#include <windows.h>

#include "mw.h"
#include "winddefs.h"
#include "cmddefs.h"
#include "wwdefs.h"
#include "dispdefs.h"
#include "docdefs.h"
#include "debug.h"
#if defined(OLE)
#include "obj.h"
#endif

#ifdef PENWIN
#define WM_PENWINFIRST 0x0380   // Remove when #define WIN31

#include <penwin.h>
int vcFakeMessage = 0;

extern HCURSOR         vhcPen;                 /* handle to pen cursor */
extern int (FAR PASCAL *lpfnProcessWriting)(HWND, LPRC);
extern VOID (FAR PASCAL *lpfnPostVirtualKeyEvent)(WORD, BOOL);
extern VOID (FAR PASCAL *lpfnTPtoDP)(LPPOINT, int);
extern BOOL (FAR PASCAL *lpfnCorrectWriting)(HWND, LPSTR, int, LPRC, DWORD, DWORD);
extern BOOL (FAR PASCAL *lpfnSymbolToCharacter)(LPSYV, int, LPSTR, LPINT);


VOID NEAR PASCAL PostCharacter(WORD wch);
VOID NEAR PASCAL SendVirtKeyShift(WORD wVk, BYTE bFlags);
VOID NEAR PASCAL SetSelection(HWND hWnd, LPPOINT lpPtFirst, LPPOINT lpPtLast, WORD wParam);
int NEAR PASCAL WGetClipboardText(HWND hwndOwner, LPSTR lpsz, int cbSzSize);
VOID NEAR PASCAL ClearAppQueue(VOID);

#define VKB_SHIFT 0x01
#define VKB_CTRL  0x02
#define VKB_ALT   0x04
#endif

extern HWND             vhWnd;
extern HCURSOR          vhcArrow;
extern HCURSOR          vhcIBeam;
extern HCURSOR          vhcBarCur;
extern struct WWD       rgwwd[];
extern struct WWD       *pwwdCur;
extern HANDLE           hMmwModInstance; /* handle to own module instance */
extern int              vfShiftKey;
extern int              vfCommandKey;
extern int              vfOptionKey;
extern int              vfDoubleClick;
extern struct SEL       selCur;
extern long             rgbBkgrnd;
extern long             rgbText;
extern HBRUSH           hbrBkgrnd;
extern long             ropErase;

int                     vfCancelPictMove = FALSE;
BOOL                    vfEraseWw = FALSE;

long FAR PASCAL MdocWndProc(HWND, unsigned, WORD, LONG);
void MdocCreate(HWND, LONG);
void MdocSize(HWND, int, int, WORD);
void MdocGetFocus(HWND, HWND);
void MdocLoseFocus(HWND, HWND);
void MdocMouse(HWND, unsigned, WORD, POINT);
void MdocTimer(HWND, WORD);

#if defined(JAPAN) & defined(DBCS_IME)
#include <ime.h>
extern  BOOL    bGetFocus;
extern  BOOL	bImeFontEx;
//  for Non_PeekMessage mode in 'FImportantMsgPresent()'. [yutakan]
BOOL    bImeCnvOpen = FALSE;
BOOL	bSendFont = FALSE;
BOOL    GetIMEOpen(HWND);
#endif

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IR_UNDETERMINE
extern typeCP selUncpFirst;
extern typeCP selUncpLim;
extern int    vfImeHidden;   /*ImeHidden Mode flag*/
#endif




#ifdef PENWIN
// Helper routines to get events into system.  Would be better (more efficient) if
// could just call routines to set selection, copy, etc,
// but this is the easiest way without touching any internals

// Minics penwin internal routine, exception messages are posted instead
// of sent since Write does a lot of peek ahead

VOID NEAR PASCAL SetSelection(HWND hWnd,
    LPPOINT lpPtFirst, LPPOINT lpPtLast, WORD wParam)
    {
    static LONG lFirst = 0L;

    if (lpPtFirst)
        {
        (*lpfnTPtoDP)(lpPtFirst, 1);
        ScreenToClient(hWnd, lpPtFirst);
        }
    if (lpPtLast != NULL)
        {
        (*lpfnTPtoDP)(lpPtLast, 1);
        ScreenToClient(hWnd, lpPtLast);
        }

    if (lpPtFirst)
        {
        lFirst = MAKELONG(lpPtFirst->x, lpPtFirst->y);
        PostMessage(hWnd, WM_LBUTTONDOWN, wParam, lFirst);
        if (lpPtLast)
            {
            LONG lLast = MAKELONG(lpPtLast->x, lpPtLast->y);

            PostMessage(hWnd, WM_MOUSEMOVE, wParam, lLast);
            vcFakeMessage++;
            PostMessage(hWnd, WM_LBUTTONUP, wParam, lLast);
            }
        else
            {
            PostMessage(hWnd, WM_LBUTTONUP, wParam, lFirst);
            vcFakeMessage++;
            }
        }
    else    // doubleclick
        {
        PostMessage(hWnd, WM_LBUTTONDBLCLK, wParam, lFirst);
        vcFakeMessage++;
        PostMessage(hWnd, WM_LBUTTONUP, wParam, lFirst);
        vcFakeMessage++;
        }
    }




/*
PURPOSE: Map a symbol value to a set of virtual keystrokes and then
    send the virtual keystrokes.
    TODO: Add real mapping of symbol values instead of assuming ANSI values
        Right now, this routine is worthless
RETURN:
GLOBALS:
CONDITIONS: Kanji is not handled now, but could be.
*/
VOID NEAR PASCAL PostCharacter(WORD wch)
    {
    int iVk = VkKeyScan(LOBYTE(wch));
    WORD wVk = (WORD)LOBYTE(iVk);
    char bFl = HIBYTE(iVk);

    if ((wVk != -1))
        SendVirtKeyShift(wVk, bFl);
    }


/*--------------------------------------------------------------------------
PURPOSE: Send an optionally shifted key sequence as system events
RETURN: nothing
GLOBALS:
CONDITIONS: see flags in mspen.h
*/
VOID NEAR PASCAL SendVirtKeyShift(WORD wVk, BYTE bFlags)
    {
    // send DOWN events:
    if (bFlags & VKB_SHIFT)
        (*lpfnPostVirtualKeyEvent)(VK_SHIFT, fFalse);
    if (bFlags & VKB_CTRL)
        (*lpfnPostVirtualKeyEvent)(VK_CONTROL, fFalse);
    if (bFlags & VKB_ALT)
        (*lpfnPostVirtualKeyEvent)(VK_MENU, fFalse);
    (*lpfnPostVirtualKeyEvent)(wVk, fFalse);

    // send UP events (in opposite order):
    (*lpfnPostVirtualKeyEvent)(wVk, fTrue);
    if (bFlags & VKB_ALT)
        (*lpfnPostVirtualKeyEvent)(VK_MENU, fTrue);
    if (bFlags & VKB_CTRL)
        (*lpfnPostVirtualKeyEvent)(VK_CONTROL, fTrue);
    if (bFlags & VKB_SHIFT)
        (*lpfnPostVirtualKeyEvent)(VK_SHIFT, fTrue);
    }


/* Fill buffer with contents of clipboard
*/
int NEAR PASCAL WGetClipboardText(HWND hwndOwner, LPSTR lpsz, int cbSzSize)
    {
    HANDLE hClip;
    int wLen = 0;

    OpenClipboard(hwndOwner);
    if (hClip = GetClipboardData(CF_TEXT))
        {
        LPSTR lpszClip = (LPSTR)GlobalLock(hClip);

        if (lpsz && cbSzSize > 0)
            {
            wLen = lstrlen(lpszClip);
            if (wLen > cbSzSize)
                lpszClip[cbSzSize-1] = 0;
            lstrcpy(lpsz, lpszClip);
            }
        GlobalUnlock(hClip);
        }
#ifdef KKBUGFIX
    else
        *lpsz = '\0';
#endif
    CloseClipboard();
    return wLen;
    }


/*--------------------------------------------------------------------------
PURPOSE: Dispatches any messages currently pending in our queue
RETURN: nothing
GLOBALS:
CONDITIONS:
*/
VOID NEAR PASCAL ClearAppQueue(VOID)
    {
    MSG msg;

    while (PeekMessage(&msg, (HWND)NULL, NULL, NULL, PM_REMOVE))
        {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        }
    }

#endif



static RECT rSaveInv;

long FAR PASCAL MdocWndProc(hWnd, message, wParam, lParam)
HWND      hWnd;
unsigned  message;
WORD      wParam;
LONG      lParam;
{
extern int vfCloseFilesInDialog;
extern BOOL fPrinting;
long lReturn=0L;
#ifdef PENWIN
static cCharSent;
#endif

/*  if IME Window mode is MCW_HIDDEN then IME don't send IR_OPENCONVERT.
    so I add this routine. */ 

#ifdef PENWIN
 if (message < WM_CUT || message == WM_RCRESULT)
#else
 if (message < WM_CUT )
#endif

    {
    switch (message)
        {
        default:
            goto DefaultProc;

        /* For each of following mouse window messages, wParam contains
        ** bits indicating whether or not various virtual keys are down,
        ** and lParam is a POINT containing the mouse coordinates.   The
        ** keydown bits of wParam are:  MK_LBUTTON (set if Left Button is
        ** down); MK_RBUTTON (set if Right Button is down); MK_SHIFT (set
        ** if Shift Key is down); MK_ALTERNATE (set if Alt Key is down);
        ** and MK_CONTROL (set if Control Key is down). */

        case WM_LBUTTONDBLCLK:
#ifdef PENWIN
        if (vcFakeMessage > 0)
            vcFakeMessage--;
        // fall through
#endif
        case WM_LBUTTONUP:
        case WM_MOUSEMOVE:
        case WM_LBUTTONDOWN:
            MdocMouse(hWnd, message, wParam, MAKEPOINT(lParam));
            break;



#ifdef PENWIN
        case WM_RCRESULT:
            {
            LPRCRESULT lpr = (LPRCRESULT)lParam;
            LPPOINT lpPntHot;
            LPPOINT lpPntHot2;

            if( (lpr->wResultsType&(RCRT_ALREADYPROCESSED|RCRT_NOSYMBOLMATCH))!=0 || lpr->lpsyv==NULL
                || lpr->cSyv == 0)
                return( FALSE );

            if (lpr->wResultsType&RCRT_GESTURE)
                {
                SYV syv = *(lpr->lpsyv);

                vcFakeMessage = 0;

                lpPntHot = lpr->syg.rgpntHotSpots;
                lpPntHot2 = lpr->syg.cHotSpot > 1 ? lpr->syg.rgpntHotSpots + 1: NULL;

                switch ( LOWORD(syv))
                    {
                case LOWORD( SYV_EXTENDSELECT ):
                    SetSelection(hWnd, lpPntHot, NULL, MK_SHIFT);   // extend sel
                    break;

                case LOWORD( SYV_CLEARWORD ):       // dbl click & drag
                    if (lpPntHot2)
                        {
                        SetSelection(hWnd, lpPntHot, NULL, 0);
                        SetSelection(hWnd, NULL, NULL, 0);  // dblclick selects word
                        }
                    SendVirtKeyShift(VK_DELETE, 0);
                    break;

                case LOWORD( SYV_COPY):
                case LOWORD( SYV_CLEAR ):
                case LOWORD( SYV_CUT ):
                    if ( selCur.cpFirst == selCur.cpLim && (lpr->wResultsType&RCRT_GESTURETRANSLATED)==0)
                        {
                        SetSelection(hWnd, lpPntHot, NULL, 0);
                        if (syv != SYV_CLEAR)
                            SetSelection(hWnd, NULL, NULL, 0);  // dblclick
                        }

                    switch ( LOWORD(syv))
                        {
                        case LOWORD( SYV_COPY):
                            SendVirtKeyShift(VK_INSERT, VKB_CTRL);
                            break;

                        case LOWORD( SYV_CLEAR ):
                            SendVirtKeyShift(VK_DELETE, 0);
                            break;

                        case LOWORD( SYV_CUT ):
                            SendVirtKeyShift(VK_DELETE, VKB_SHIFT);
                            break;
                        }

                    break;


                case LOWORD( SYV_PASTE ):
                    if ((lpr->wResultsType&RCRT_GESTURETRANSLATED)==0)
                        SetSelection(hWnd, lpPntHot, NULL, 0);
                    SendVirtKeyShift(VK_INSERT, VKB_SHIFT);
                    break;

                case LOWORD( SYV_UNDO):
                    SendVirtKeyShift(VK_BACK, VKB_ALT);
                    break;

                case LOWORD(SYV_BACKSPACE):
                case LOWORD(SYV_SPACE):
                case LOWORD(SYV_RETURN):
                case LOWORD(SYV_TAB):
                    SetSelection(hWnd, lpPntHot, NULL, 0);
                    PostCharacter(LOWORD(*(lpr->lpsyv))&0x00ff);
                    break;

#if defined(KKBUGFIX) && !defined(KOREA)
                case LOWORD( SYV_CORRECT ):
                case LOWORD( SYV_KKCONVERT ):
                    {
                    WORD wLen;
                    HANDLE hMem = NULL;
                    LPSTR lpstr;
                    LPSTR lpsz;
                    BOOL fDoubleClickSent = fFalse;
                    DWORD dwFlags = NULL;
                    DWORD dwReserved = NULL;
                    POINT pt;
                    extern int vxpCursLine;
                    extern int vypCursLine;
    #define cbCorrectMax 128

                    // Strategy: If no selection, send in a double click to
                    // select a word.  Then copy selection to clipboard
                    // read off of clipboard.  Call CorrectWriting, and
                    // but changed text in clipboard and then paste
                    // from clipboard.
                    if ( selCur.cpFirst == selCur.cpLim )
                        {
                        if (LOWORD(syv) == LOWORD(SYV_KKCONVERT))
                            {
                            SetSelection(hWnd, lpPntHot, lpPntHot2, 0);
                            }
                        else
                            {
                            // No selection so send double click
                            SetSelection(hWnd, lpPntHot, NULL, 0);  // set caret
                            SetSelection(hWnd, NULL, NULL, 0);  // dblclick
                            }
                        fDoubleClickSent = fTrue;
                        ClearAppQueue();
                        }

                    SendMessage(hWnd, WM_COPY, 0, 0L);

                    hMem = GlobalAlloc(GMEM_MOVEABLE, (DWORD)cbCorrectMax);
                    if (hMem == NULL || (lpsz = (LPSTR)GlobalLock(hMem)) == NULL)
                        return 1;   // Just bag out for now: should add error message
                    wLen = WGetClipboardText(hWnd, lpsz, cbCorrectMax);
                    if (LOWORD(syv) == LOWORD(SYV_KKCONVERT) && wLen == 0)
                        {
                        beep();
                        return 1;
                        }
                    if (IsClipboardFormatAvailable(CF_TEXT) || wLen == 0)
                        {
                        if (wLen < cbCorrectMax)
                            {
                            if (LOWORD(syv) == LOWORD(SYV_KKCONVERT))
                                {
                                dwFlags = CWR_KKCONVERT | CWR_SIMPLE;
                                pt.x = vxpCursLine;
                                pt.y = vypCursLine;
                                ClientToScreen(hWnd, &pt);
                                dwReserved = MAKELONG(pt.x, pt.y);
                                }
                            // Only bring up corrector if selection wasn't too big
                            if ((*lpfnCorrectWriting)(hWnd, lpsz, cbCorrectMax, NULL, dwFlags, dwReserved))
                                {
                                if (*lpsz==0)
                                    {
                                    // User deleted all text in correction
                                    SendVirtKeyShift(VK_DELETE, 0);
                                    }
                                else if (LOWORD(syv) == LOWORD(SYV_CORRECT))
                                    {
                                    GlobalUnlock(hMem);
                                    OpenClipboard(GetParent(hWnd)); // Use parent as
                                            // owner to circumvent write's short check
                                            // cuts if it is owner of clipboard
                                    EmptyClipboard();
                                    SetClipboardData(CF_TEXT, hMem);
                                    CloseClipboard();
                                    hMem = NULL;
                                    SendMessage(hWnd, WM_PASTE, 0, 0L);
                                    UpdateWindow(hWnd);
                                    }
                                }
                            else if (fDoubleClickSent)
                                {
                                // Need to clear bogus selection.  Just send in a tap.
                                SetSelection(hWnd, lpPntHot, NULL, 0);
                                }
                            }

                        }
                    if (hMem)   // may never have been alloc'd if user canceled
                        {
                        GlobalUnlock(hMem);
                        GlobalFree(hMem);
                        }
                    }
                    break;
#else		// KKBUGFIX
                case LOWORD( SYV_CORRECT ):
                    {
                    WORD wLen;
                    HANDLE hMem = NULL;
                    LPSTR lpstr;
                    LPSTR lpsz;
                    BOOL fDoubleClickSent = fFalse;
    #define cbCorrectMax 128

                    // Strategy: If no selection, send in a double click to
                    // select a word.  Then copy selection to clipboard
                    // read off of clipboard.  Call CorrectWriting, and
                    // but changed text in clipboard and then paste
                    // from clipboard.
                    if ( selCur.cpFirst == selCur.cpLim )
                        {
                        // No selection so send double click
                        SetSelection(hWnd, lpPntHot, NULL, 0);  // set caret
                        SetSelection(hWnd, NULL, NULL, 0);  // dblclick
                        fDoubleClickSent = fTrue;
                        ClearAppQueue();
                        }

                    SendMessage(hWnd, WM_COPY, 0, 0L);

                    if (IsClipboardFormatAvailable(CF_TEXT))
                        {
                        hMem = GlobalAlloc(GMEM_MOVEABLE, (DWORD)cbCorrectMax);
                        if (hMem == NULL || (lpsz = (LPSTR)GlobalLock(hMem)) == NULL)
                            return 1;   // Just bag out for now: should add error message
                        if (WGetClipboardText(hWnd, lpsz, cbCorrectMax) < cbCorrectMax)
                            {
                            // Only bring up corrector if selection wasn't too big
                            if ((*lpfnCorrectWriting)(hWnd, lpsz, cbCorrectMax, NULL, 0, 0))
                                {
                                if (*lpsz==0)
                                    {
                                    // User deleted all text in correction
                                    SendVirtKeyShift(VK_DELETE, 0);
                                    }
                                else
                                    {
                                    GlobalUnlock(hMem);
                                    OpenClipboard(GetParent(hWnd)); // Use parent as
                                            // owner to circumvent write's short check
                                            // cuts if it is owner of clipboard
                                    EmptyClipboard();
                                    SetClipboardData(CF_TEXT, hMem);
                                    CloseClipboard();
                                    hMem = NULL;
                                    SendMessage(hWnd, WM_PASTE, 0, 0L);
                                    UpdateWindow(hWnd);
                                    }
                                }
                            else if (fDoubleClickSent)
                                {
                                // Need to clear bogus selection.  Just send in a tap.
                                SetSelection(hWnd, lpPntHot, NULL, 0);
                                }


                            }

                        if (hMem)   // may never have been alloc'd if user canceled
                            {
                            GlobalUnlock(hMem);
                            GlobalFree(hMem);
                            }
                        }
                    }
                    break;
#endif		// KKBUGFIX


                default:
                    return( FALSE );
                    }
                }
            else // Not a gesture,see if normal characters
                {
#define cbTempBufferSize 128
                char rgch[cbTempBufferSize+2];
                int cb=0;
                int cbT;
                LPSTR lpstr = (LPSTR)lpr->lpsyv;
                typeCP  cp=cp0;
                LPSYV lpsyv;
                LPSYV lpsyvEnd;

                extern int              docScrap;
                extern int              vfScrapIsPic;
                extern struct PAP       *vppapNormal;
                extern struct CHP       vchpNormal;

                vfScrapIsPic = fFalse;
                ClobberDoc( docScrap, docNil, cp0, cp0 );

                // Replace CR with LF's  These are treated as EOLs
                // by CchReadLineExt.  Then, before inserting
                // buffer, change all LFs to CR LFs as write expects
                // Will work for Kanji

                for (lpsyv=lpr->lpsyv, lpsyvEnd=&lpr->lpsyv[lpr->cSyv+1];
                        lpsyv<lpsyvEnd; lpsyv++)
                    {
                    if (*lpsyv == SyvCharacterToSymbol(0xD))
                        {
                        *lpstr++ = 0xd;
                        *lpstr++ = 0xa;
                        cb+=2;
                        }
                    else
                        {
                        (*lpfnSymbolToCharacter)(lpsyv, 1, lpstr, &cbT);
                        lpstr += cbT;
                        cb += cbT;
                        }
                    }
                lpstr = (LPSTR)lpr->lpsyv;
                Assert(cb>0 && lpstr[cb-1] == 0);

                // This code is abstracted for FReadExtScrap where it copies
                // text from clipboard into the scrap document.  We do similar.
                // copy result into scrap and then insert scrap with
                // no formating.
                while (cb > 0)
                    {
                    struct PAP *ppap=NULL;
                    int fEol;
                    unsigned cch=min(cb, cbTempBufferSize);

                    if ((cch = CchReadLineExt((LPCH) lpstr, cch, rgch, &fEol))==0)
                            /* Reached terminator */
                        break;

                    if (fEol)
                        ppap = vppapNormal;

                    InsertRgch(docScrap, cp, rgch, cch, &vchpNormal, ppap);

                    cb -= cch;
                    cp += (typeCP) cch;
                    lpstr += cch;
                    }

                CmdInsScrap(fTrue);
                }
            }
        return TRUE;

#endif  // PENWIN

#if defined(OLE)
        case WM_DROPFILES:
            /* We got dropped on, so bring ourselves to the top */
            BringWindowToTop(hParentWw);
            ObjGetDrop(wParam,FALSE);
        break;
#endif

        case WM_TIMER:
            /* Timer message.  wParam contains the timer ID value */
#if defined(JAPAN) & defined(DBCS_IME) //01/19/93
			if(bSendFont == TRUE) {
                SetImeFont(hWnd);
				bSendFont = FALSE;
			}

			if(bImeCnvOpen == TRUE) {	//03/08/93 #4687 T-HIROYN
	            if(FALSE == GetIMEOpen(hWnd))
		            bImeCnvOpen = FALSE;
			}
#endif
            MdocTimer(hWnd, wParam);
            break;

        case WM_CREATE:
            /* Window's being created; lParam contains lpParam field
            ** passed to CreateWindow */
            SetRectEmpty(&rSaveInv);
            MdocCreate(hWnd, lParam);

#if defined(JAPAN) & defined(DBCS_IME) //IME3.1J
			bImeFontEx = FALSE;
#if defined(IME_HIDDEN)
            vfImeHidden = 0;
#endif
            if(TRUE == GetIMEVersioOk(hWnd)) {
			    //IME_SETCONVERSIONFONTEX use OK ?
				if(TRUE == GetIMESupportFontEx(hWnd))
					bImeFontEx = TRUE;
#if defined(IME_HIDDEN)
                vfImeHidden = 1;
#endif
			}
			SetFocus(hWnd); //03/29/93 after TestWordCnv (INITMMW.C)
							// WM_SETFOCUS dose not come.
#endif
            break;

        case WM_SIZE:
            /* Window's size is changing.  lParam contains the height
            ** and width, in the low and high words, respectively.
            ** wParam contains SIZENORMAL for "normal" size changes,
            ** SIZEICONIC when the window is being made iconic, and
            ** SIZEFULLSCREEN when the window is being made full screen. */
            MdocSize(hWnd, LOWORD(lParam), HIWORD(lParam), wParam);
            break;

        case WM_PAINT:
#if defined(OLE)
            if (nBlocking || fPrinting)
            // this'll reduce async problems
            {
                PAINTSTRUCT Paint;
                RECT rTmp=rSaveInv;

                BeginPaint(hWnd,&Paint);
                UnionRect(&rSaveInv,&rTmp,&Paint.rcPaint);
                EndPaint(hWnd,&Paint);
                break;
            }
#endif
            /* Time for the window to draw itself. */
            UpdateInvalid();
            UpdateDisplay( FALSE );

            break;

        case WM_SETFOCUS:
            /* The window is getting the focus.  wParam contains the window
            ** handle of the window that previously had the focus. */

#if defined(JAPAN) & defined(DBCS_IME)

//  If we're getting input focus, we have to get current status of IME convert
// window, and initialize 'bImeCnvOpen'.    [yutakan:07/15/91]
//
#if 1 //#3221 01/25/93
            if(TRUE == GetIMEOpen(hWnd)) {
				bImeCnvOpen = TRUE;
				if (TRUE == SendIMEVKFLUSHKey(hWnd))    //Win3.1J t-hiroyn
					bImeCnvOpen = FALSE;
			} else
	            bImeCnvOpen = FALSE;
#else
            /* If err return, supporse IME is not enalble.*/
            if(TRUE == GetIMEOpen(hWnd)) {
                bImeCnvOpen = TRUE;
            } else
                bImeCnvOpen = FALSE;
#endif
            bGetFocus = TRUE;

			//T-HIROYN add
			bImeFontEx = FALSE;
            if(TRUE == GetIMEVersioOk(hWnd)) {
			    //IME_SETCONVERSIONFONTEX use OK ?
				if(TRUE == GetIMESupportFontEx(hWnd))
					bImeFontEx = TRUE;
			}

#endif
            MdocGetFocus(hWnd, (HWND)wParam);
            break;

        case WM_KILLFOCUS:
            /* The window is losing the focus.  wParam contains the window
            ** handle of the window about to get the focus, or NULL. */

#if defined(JAPAN) & defined(DBCS_IME)

/*  If we're losing input focus, we have to clear OpenStatus of convertwindow,
**  'bImeCnvOpen'.                  [yutakan:07/15/91]
*/
            bImeCnvOpen = FALSE;
            bGetFocus = FALSE;

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IME3.1J IR_UNDETERMINE
            if(selUncpFirst < selUncpLim) {
                UndetermineToDetermine(hWnd);
            }
#endif
            SendIMEVKFLUSHKey(hWnd);    //Win3.1J t-hiroyn
#endif
            MdocLoseFocus(hWnd, (HWND)wParam);
            /* Since we might be moving/sizing a picture, set flag to
            ** cancel this. */
            vfCancelPictMove = TRUE;
            break;

#if defined(JAPAN) & defined(DBCS_IME) 

        case WM_IME_REPORT:

            /*   if IME convert window has been opened,
            **  we're getting into Non PeekMessage
            **  Mode at 'FImportantMsgPresent()'
            */

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IR_UNDETERMINE
            if(wParam == IR_UNDETERMINE) {
                LONG GetIRUndetermin(HWND, LPARAM);          //clipbrd2.c
                return(GetIRUndetermin(hWnd, lParam));
            }
#endif

			if(wParam == IR_IMESELECT) {
				bImeFontEx = FALSE;
    	        if(TRUE == GetIMEVersioOk(hWnd)) {
				    //IME_SETCONVERSIONFONTEX use OK ?
					if(TRUE == GetIMESupportFontEx(hWnd))
						bImeFontEx = TRUE;
				}
			}

            if (wParam == IR_STRING) {
#if 0   //t-hiroyn
            // Do nothing with IR_STRING // Yutakan
                break;
        /* put string from KKC to scrap */
//              PutImeString(hWnd, LOWORD(lParam));  // need more bug fix.
//              return 1L;
#endif
                LONG GetIRString(HWND, LPARAM);          //clipbrd2.c
                return(GetIRString(hWnd, lParam));
            }

//IR_STRINGEX New Win3.1J
            if(wParam == IR_STRINGEX) {
                LONG GetIRStringEx(HWND, LPARAM);          //clipbrd2.c
                return(GetIRStringEx(hWnd, lParam));
            }

            if(wParam == IR_OPENCONVERT || wParam == IR_CHANGECONVERT) {
                bImeCnvOpen = TRUE;
//IME3.1J
                if(wParam == IR_OPENCONVERT) {
                    SetImeFont(hWnd);
					bSendFont = TRUE;	//01/19/93
                }
            }

            if(wParam == IR_CLOSECONVERT) {
                bImeCnvOpen = FALSE;
            }

            if (wParam == IR_STRINGSTART) {
                HANDLE hMem;
                LPSTR lpText;

                if (hMem = GlobalAlloc(GMEM_MOVEABLE, 512L)) {
                    if (lpText = GlobalLock(hMem)) {
                        if (EatString(hWnd, (LPSTR)lpText, 512)) {
                            ForceImeBlock(hWnd, TRUE);  //T-HIROYN 3.1J
                            PutImeString( hWnd, hMem );
                            CmdInsIRString();           //T-HIROYN 3.1J
                            ForceImeBlock(hWnd, FALSE); //T-HIROYN 3.1J
                        }
                        GlobalUnlock(hMem);
                    }
                    GlobalFree(hMem);
                }
            }
            goto DefaultProc;
#endif
        }

    }
 else if (message < WM_USER)
    {   /* Clipboard messages */
    if (!FMdocClipboardMsg( message, wParam, lParam ))
        goto DefaultProc;
    }
 else
    {   /* Private WRITE messages */
    switch (message)
        {
        default:
            goto DefaultProc;

#if defined(OLE)
        case WM_WAITFORSERVER:
        {
            extern int vfDeactByOtherApp;
            if (!hwndWait && !vfDeactByOtherApp)
            {
                vbCancelOK = TRUE;
                ((LPOBJINFO)lParam)->fCanKillAsync =  wParam;
                ((LPOBJINFO)lParam)->fCompleteAsync = TRUE;
                DialogBoxParam(hMmwModInstance, (LPSTR)"DTWAIT", hParentWw, lpfnWaitForObject, ((LPOBJINFO)lParam)->lpobject);
            }
        }
        break;

        case WM_OBJUPDATE:
            ObjObjectHasChanged(wParam,(LPOLEOBJECT)lParam);
        break;

        case WM_OBJERROR:
            ObjReleaseError(wParam);
        break;

        case WM_OBJBADLINK:
            ObjHandleBadLink(wParam,(LPOLEOBJECT)lParam);
        break;

        case WM_OBJDELETE:
            ObjDeleteObject((LPOBJINFO)lParam,wParam);
        break;
#endif

        case wWndMsgDeleteFile:
            /* wParam is a global handle to the file to be deleted */
            /* Return code: TRUE - Ok to delete
                            FALSE - don't delete */
            lReturn = (LONG)FDeleteFileMessage( wParam );
            break;

        case wWndMsgRenameFile:
            /* wParam is a global handle to the file being renamed */
            /* LOWORD( lParam ) is a global handle to the new name */
            /* No return code */
            RenameFileMessage( wParam, LOWORD( lParam ) );
            break;
        }
    }

 goto Ret;

DefaultProc:    /* All messages not processed come here. */

    lReturn = DefWindowProc(hWnd, message, wParam, lParam);
Ret:
    if (vfCloseFilesInDialog)
        CloseEveryRfn( FALSE );

    return lReturn;
}




void MdocMouse(hWnd, message, wParam, pt)
HWND       hWnd;
unsigned   message;
WORD       wParam;
POINT      pt;
{
extern int vfFocus;
extern int vfDownClick;
extern int vfMouseExist;
extern HCURSOR vhcHourGlass;
extern int vfInLongOperation;

MSG msg;

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IR_UNDETERMINE
    if(message == WM_LBUTTONDOWN || message == WM_LBUTTONDBLCLK) {
        if(selUncpFirst < selUncpLim) {
            UndetermineToDetermine(hWnd);
        }
    }
#endif

    if (vfInLongOperation)
        {
        SetCursor(vhcHourGlass);
        return;
        }

    if (message == WM_MOUSEMOVE)
        {
        if (vfMouseExist)
            {
            HCURSOR hc;

            /* All we do on move moves is set the cursor. */

            if (pt.y < wwdCurrentDoc.ypMin)
                {
                hc = vhcArrow;
                }
            else
                {
#ifdef PENWIN
                hc = (pt.x > xpSelBar ) ? vhcPen  : vhcBarCur;

#else
                hc = (pt.x > xpSelBar) ? vhcIBeam : vhcBarCur;
#endif
                }
            SetCursor( hc );
            }
        return;
        }

    /* Save the state of the shift keys. */
    vfShiftKey = wParam & MK_SHIFT;
    vfCommandKey = wParam & MK_CONTROL;
    /* high bit returned from GetKeyState is 1 when the key is down, else
       it is up, the low bit is 1 if it is toggled */

    PeekMessage(&msg, (HWND)NULL, NULL, NULL, PM_NOREMOVE);

    vfOptionKey = GetKeyState(VK_MENU) < 0 ? true : false;
    vfDoubleClick = (message == WM_LBUTTONDBLCLK);

    if (message == WM_LBUTTONUP)
        {
        /* Windows demands this */
        if (vfDownClick && !vfFocus)
            {
            SetFocus( hWnd );
            vfDownClick = FALSE;
            }
        }
    else
        {
        extern int vfGotoKeyMode;

        vfGotoKeyMode = FALSE;
        /* WM_LBUTTONDOWN or WM_LBUTTONDBLCLK */
        vfDownClick = TRUE;

#ifdef PENWIN
#ifdef KKBUGFIX
        if( lpfnProcessWriting == NULL ||
            vfDoubleClick ||
            pt.x < xpSelBar )
            //Normal mouse processing
            DoContentHit(pt);
         else
            {
            if ((*lpfnProcessWriting)( hWnd, NULL ) < 0)
                //Normal mouse processing
                DoContentHit(pt);
            else
                // During recognition, caret blinking rate is destroyed
                SetTimer( hWnd, tidCaret, GetCaretBlinkTime(), (FARPROC)NULL );
            }
#else
        if( lpfnProcessWriting == NULL ||
            vfDoubleClick ||
            pt.x < xpSelBar ||
            (*lpfnProcessWriting)( hWnd, NULL ) < 0
            )
            //Normal mouse processing
            DoContentHit(pt);
#endif
#else
        DoContentHit(pt);
#endif
        }
#ifdef JAPAN
        if(bImeCnvOpen)
            SetImeFont(hWnd);
#endif
}



void MdocTimer(hWnd, id)
HWND hWnd;
WORD id;
{
extern int vfSkipNextBlink;
extern int vfInsertOn;
extern int vfFocus;

#if defined(OLE)
 ++nGarbageTime;
#endif

    /* A timer event has occurred with ID id.  Process it here. */
 Assert( id == tidCaret );  /* Caret blink is the only timer event we know */

 if ( ( vhWnd != hWnd ) ||   /* Document window is not current */
      ( !vfFocus ) ||        /* Don't have the focus */
      ( wwdCurrentDoc.fDirty) ) /* dl's are not up to date */
    return;

 if ( vfSkipNextBlink )
    {   /* We have been warned not to blank the cursor this time around */
    vfSkipNextBlink = FALSE;
    if ( vfInsertOn )
        return;
    }

#if defined(OLE)
 if (nGarbageTime > GARBAGETIME)
    ObjCollectGarbage();
#endif

 if ( selCur.cpFirst == selCur.cpLim )
    {
    /* We must use ToggleSel instead of DrawInsertLine because the */
    /* insert cp might not be on the screen & ToggleSel can */
    /* figure this out */

    extern int vypCursLine;
    extern int vdypCursLine;

    /* The following condition may not be true if we get a timer message
       after a size message but before a paint message; ypMac will
       have been adjusted but dlMac does not get adjusted to reflect
       the change until UpdateDisplay is called. We have violated the
       Windows dictate that ALL size-related calculations must occur
       in the Size proc and we must compensate here */

    if ( vypCursLine - vdypCursLine < wwdCurrentDoc.ypMac )
        {
        ToggleSel( selCur.cpFirst, selCur.cpFirst, !vfInsertOn );
        vfSkipNextBlink = FALSE;
        }
    }
}


void CatchupInvalid(HWND hWnd)
{
    if (!nBlocking && !IsRectEmpty(&rSaveInv))
    {
        InvalidateRect(hWnd,&rSaveInv,FALSE);
        SetRectEmpty(&rSaveInv);
    }
}

#if defined(JAPAN) & defined(DBCS_IME)

/*
**   We want to get 'IME ConvertWindow OpenStatus' but IME_GETOPEN
**  subfunction.
**  now does not support 'wCount' in IMESTRUCT (will support in future).
**   So this function will always return FALSE since wCount is always 0
**  as we set it before do SendIMEMessage(). [yutakan:07/16/91]
*/

BOOL    GetIMEOpen(HWND hwnd)
{
    LPIMESTRUCT lpmem;
    HANDLE      hIMEBlock;
    int         wRet;

    /* Get comunication area with IME */
    hIMEBlock=GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE | GMEM_LOWER,
            (DWORD)sizeof(IMESTRUCT));
    if(!hIMEBlock)  return FALSE;

    lpmem           = (LPIMESTRUCT)GlobalLock(hIMEBlock);
    lpmem->fnc      = IME_GETOPEN;
    lpmem->wCount   = 0;	//01/25/93

    GlobalUnlock(hIMEBlock);
    if(FALSE == (MySendIMEMessageEx(hwnd,MAKELONG(hIMEBlock,NULL)))){
        wRet = FALSE;   /* Error */
    }
    else
        wRet = TRUE;    /* Success */

	//01/25/93
    if (lpmem = (LPIMESTRUCT)GlobalLock(hIMEBlock)) {
        if(wRet == TRUE && lpmem->wCount == 0) 
            wRet = FALSE; //ok
        GlobalUnlock(hIMEBlock);
    }

    GlobalFree(hIMEBlock);
    return  wRet;
}

//T_HIROYN
//SendIMEMessageEx New3.1J
MySendIMEMessageEx(HWND hwnd, LPARAM lParam)
{
    return(SendIMEMessageEx(hwnd, lParam));
//    return(SendIMEMessage(hwnd, lParam));
}

BOOL    GetIMEVersioOk(HWND hwnd)
{
    LPIMESTRUCT lpmem;
    WORD        wVersion;
    int         wRet = FALSE;

    /* comunication area with IME */
    HANDLE hImeStruct;

    /* Get comunication area with IME */
    hImeStruct = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE,
				 (DWORD)sizeof(IMESTRUCT));
    if( !hImeStruct )
        return FALSE;

    if(lpmem = (LPIMESTRUCT)GlobalLock(hImeStruct)) {
        lpmem->fnc      = IME_GETIMECAPS;
        lpmem->wParam   = IME_GETVERSION;

        GlobalUnlock(hImeStruct);
        if(FALSE == (MySendIMEMessageEx(hwnd,MAKELONG(hImeStruct,NULL)))) {
            goto retVercheck;
        }
    }

    if(lpmem = (LPIMESTRUCT)GlobalLock(hImeStruct)) {
        lpmem->fnc      = IME_GETVERSION;

        GlobalUnlock(hImeStruct);
        wVersion = MySendIMEMessageEx(hwnd,MAKELONG(hImeStruct,NULL));

        if(wVersion >= 0x0a03) 
            wRet = TRUE;
        else
            wRet = FALSE;
    }

retVercheck:

    GlobalFree(hImeStruct);
    return  wRet;
}

BOOL    GetIMESupportFontEx(HWND hwnd)
{
    LPIMESTRUCT lpmem;
    int         wRet = FALSE;

    /* comunication area with IME */
    HANDLE hImeStruct;

    /* Get comunication area with IME */
    hImeStruct = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE,
				 (DWORD)sizeof(IMESTRUCT));
    if( !hImeStruct )
        return FALSE;

    if(lpmem = (LPIMESTRUCT)GlobalLock(hImeStruct)) {
        lpmem->fnc      = IME_GETIMECAPS;
       	lpmem->wParam   = IME_SETCONVERSIONFONTEX;

        GlobalUnlock(hImeStruct);
        if(TRUE == (MySendIMEMessageEx(hwnd,MAKELONG(hImeStruct,NULL)))) {
            wRet = TRUE;
        }
    }

    GlobalFree(hImeStruct);
    return  wRet;
}

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
BOOL    GetIMEOpenMode(HWND hwnd)
{
    LPIMESTRUCT lpmem;
    int  wRet = TRUE;

    /* comunication area with IME */
    extern HANDLE hImeMem;

    if (lpmem = (LPIMESTRUCT)GlobalLock(hImeMem)) {
        lpmem->fnc      = IME_GETOPEN;
        lpmem->wCount   = 0;

        GlobalUnlock(hImeMem);
        if(0 == (MySendIMEMessageEx(hwnd,MAKELONG(hImeMem,NULL))))
            wRet = FALSE;   /* close ok */
        else
            wRet = TRUE;    /* open ok ? */
    }

    if (lpmem = (LPIMESTRUCT)GlobalLock(hImeMem)) {
        if(wRet == TRUE && lpmem->wCount == 0) 
            wRet = FALSE; //ok
        GlobalUnlock(hImeMem);
    }
    return  wRet;
}

#endif //IME_HIDDEN

/* routine to retrieve WM_CHAR from the message queue associated with hwnd.
 * this is called by EatString.
 */
WORD NEAR PASCAL EatOneCharacter(hwnd)
register HWND hwnd;
{
    MSG msg;
    register int i = 10;

    while(!PeekMessage((LPMSG)&msg, hwnd, WM_CHAR, WM_CHAR, PM_REMOVE)) {
        if (--i == 0)
            return -1;
        Yield();
    }
    return msg.wParam & 0xFF;
}

/* This routine is called when the MSWRITE_DOC class receives WM_IME_REPORT
 * with IR_STRINGSTART message. The purpose of this function is to eat
 * all strings between IR_STRINGSTART and IR_STRINGEND.
 */
BOOL EatString(hwnd, lpSp, cchLen)
register HWND   hwnd;
LPSTR lpSp;
WORD cchLen;
{
    MSG msg;
    int i = 10;
    int w;

    *lpSp = '\0';
    if (cchLen < 4)
    return NULL;    // not enough
    cchLen -= 2;

    while(i--) {
        while(PeekMessage((LPMSG)&msg, hwnd, NULL, NULL, PM_REMOVE)) {
        i = 10;
        switch(msg.message) {
            case WM_CHAR:
            *lpSp++ = (BYTE)msg.wParam;
            cchLen--;
            if (IsDBCSLeadByte((BYTE)msg.wParam)) {
            if ((w = EatOneCharacter(hwnd)) == -1) {
                /* Bad DBCS sequence - abort */
                lpSp--;
                goto WillBeDone;
            }
            *lpSp++ = (BYTE)w;
            cchLen--;
            }
            if (cchLen <= 0)
            goto WillBeDone;   // buffer exhausted
            break;
            case WM_IME_REPORT:
            if (msg.wParam == IR_STRINGEND) {
            if (cchLen <= 0)
                goto WillBeDone; // no more room to stuff
            if ((w = EatOneCharacter(hwnd)) == -1)
                goto WillBeDone;
            *lpSp++ = (BYTE)w;
            if (IsDBCSLeadByte((BYTE)w)) {
                if ((w = EatOneCharacter(hwnd)) == -1) {
                    /* Bad DBCS sequence - abort */
                    lpSp--;
                    goto WillBeDone;
                }
                *lpSp++ = (BYTE)w;
            }
            goto WillBeDone;
            }
            /* Fall through */
            default:
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            break;
        }
        }
    }
    /* We don't get WM_IME_REPORT + IR_STRINGEND
     * But received string will be OK
     */

WillBeDone:

    *lpSp = '\0';
    return TRUE;
}

#endif      /* JAPAN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\menu.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* menu.c -- WRITE menu handling routines */
#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOCTLMGR
#define NOSYSMETRICS
#define NOICON
#define NOKEYSTATE
#define NORASTEROPS
#define NOSHOWWINDOW
//#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMETAFILE
#define NOSOUND
#define NOSCROLL
#define NOWH
#define NOOPENFILE
#define NOCOMM
#define NOMSG
#define NOREGION
#define NORECT

#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "filedefs.h"
#include "wwdefs.h"
#include "docdefs.h"
#include "propdefs.h"
#include "prmdefs.h"
#define NOKCCODES
#include "ch.h"
#include "editdefs.h"
#include "menudefs.h"
#include "str.h"
#include "fontdefs.h"
#include "dlgdefs.h"
#include "dispdefs.h"
#include <shellapi.h>
#if defined(OLE)
#include "obj.h"
#endif

#ifdef JAPAN //T-HIROYN Win3.1
#include "kanji.h"
#endif

extern int FAR PASCAL ShellAbout(HWND hWnd, LPSTR szApp, LPSTR szOtherStuff, HICON hIcon);

extern typeCP cpMinCur, cpMacCur;
extern struct WWD       rgwwd[];
extern CHAR             stBuf[];
extern int              docCur;
extern struct DOD       (**hpdocdod)[];
extern struct SEL       selCur;
extern int              vfOutOfMemory;
extern BOOL             vfWinFailure;
extern int              vfSysFull;
extern int              vfDiskError;
extern struct CHP       vchpAbs;
extern struct PAP       vpapAbs;
extern struct CHP       vchpFetch;
extern struct CHP       vchpSel;
extern int              vfSeeSel;
extern typeCP           vcpFetch;
extern int              vccpFetch;
extern typeCP           cpMacCur;
extern typeCP           vcpLimParaCache;
extern HMENU            vhMenu; /* global handle to the top level menu */
extern HANDLE           hParentWw;
extern HCURSOR          vhcHourGlass;
extern HANDLE           hMmwModInstance;
extern HANDLE           vhDlgFind;
extern HANDLE           vhDlgChange;
extern HANDLE           vhDlgChange;
extern CHAR             (**hszSearch)[];    /* Default search string */
#ifdef CASHMERE
extern int              vfVisiMode;
extern HWND             vhWndGlos;
extern HWND             vhWndScrap;
#endif /* CASHMERE */

#ifdef ONLINEHELP
extern fnHelp(void);
#endif /* ONLINEHELP */

/* These values are comprised of one bit for each menu item in the
   applicable menu (for example, there are bitcount(0xfff)==12 menu
   items under Character) ..pault */

static int rgmfAllItems[CMENUS] = {
    0x01ff,  /* FILE */
    0x003f,  /* EDIT */
    0x000f,  /* FIND */
#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
    0x03ff,  /* CHARACTER */
#else
    0x01ff,  /* CHARACTER */
#endif
    0x01ff,  /* PARA */
    0x001f,  /* DOCU */
    0x000f   /* HELP */
};


/* When we're editing a running header or footer, use this */
static int rgmfRunning[CMENUS] = {
    0x0020,        /* FILE -- enable printer-setup only */
    0x003F,        /* EDIT -- everything */
    0x0007,        /* FIND -- enable find/again and change */
#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
    0x03ff,        /* CHARACTER -- everything */
#else
    0x01FF,        /* CHARACTER -- everything */
#endif
    0x01FF,        /* PARAGRAPH -- everything */
    0x001F,        /* DOCUMENT -- everything */
    0x000f         /* HELP -- everything */
};


int viffnMenuMac;

NEAR PutSzUndoInMenu(void);
NEAR GetChpVals (struct CHP *, TSV *);
NEAR GetPapVals (struct PAP *, TSV *);
NEAR GetHffn (struct CHP *, TSV *);
NEAR SetChUndef(TSV *, struct CHP *, int *);
NEAR SetParaUndef(TSV *, struct PAP *, int *);
NEAR FNoSearchStr(HWND);



SetAppMenu(hMenu, index)
HMENU hMenu;   /* handle to popup menu */
int   index;   /* index to popup menu */
{
/* Mark greying and checks on menus as appropriate to current state. */
extern BOOL vfPrinterValid;
extern CHAR (**hszPrPort)[];
extern CHAR szNul[];
extern int vfPictSel;
extern int vfOwnClipboard;
extern int docScrap;
extern struct UAB vuab;
extern HWND vhWnd;
typeCP CpMacText();

register int rgmfT[CMENUS]; /* Our workspace for menu greying */
int imi;
int imiMin = 0;
int imiMax = 0;
int *pflags;
TSV rgtsv[itsvchMax];  /* gets attributes and gray flags from CHP, PAP */
unsigned wPrintBitPos = ~(0x0001 << (imiPrint - imiFileMin));


/* If we are out of memory or the disk is full, then... */
if (vfOutOfMemory || vfSysFull || vfDiskError || vfWinFailure)
    {
    bltc( rgmfT, 0, CMENUS );
#if WINVER >= 0x300
    /* Disable the print stuff, but leave New/Open/Save/SaveAs/Exit */
    rgmfT[FILE] = 0x008f;
#else
    /* Disable everything except Save & SaveAs */
    rgmfT[FILE] = 0x0018;
#endif
    }
else
    {
    /* Start with all items or subset if editing running head/foot */
    blt( (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter) ? rgmfRunning
      : rgmfAllItems, rgmfT, CMENUS );

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
        {
            extern int  vfImeHidden;   /*T-HIROYN ImeHidden Mode flag*/
    
            if(index == CHARACTER) {
                /* Version 3.1 or more ok */
                if(FALSE == GetIMEVersioOk(vhWnd)) {
                    rgmfT[CHARACTER] = 0x1ff;       //Set Ime mode memu gray
                    vfImeHidden = 0;
                }
                if(TRUE == GetIMEOpenMode(vhWnd))
                    rgmfT[CHARACTER] = 0x1ff;       //Set Ime mode memu gray
            }
        }
#endif
    }

pflags = &rgmfT[index];

switch (index)
    {
    case FILE:
        imiMin = imiFileMin;
        imiMax = imiFileMax;

        /* Disallow print, if the printer or the port is not valid. */
        if (!vfPrinterValid || hszPrPort == NULL ||
                WCompSz( *hszPrPort, szNul ) == 0)
            *pflags &= wPrintBitPos;
        break;

    case EDIT:
        imiMin = imiEditMin;
        imiMax = imiEditMax;
        /* Disallow cut, copy if the selection is empty */
        if (selCur.cpFirst == selCur.cpLim)
            {
            *pflags &= 0xfff9;
            }
        /* Move and Size picture are only allowed if a picture is selected */
        if (!vfPictSel)
            *pflags &= 0xFFCF;
        /* Disallow Paste if we can determine that the scrap is empty.
           Regrettably, we can be fooled into thinking it is not by
           another instance of MEMO that is the clipboard owner and has
           an empty scrap. */

        /* Disallow UNDO if appropriate; set UNDO string into menu */
        {
        if ((vuab.uac == uacNil) || vfOutOfMemory)
            {
            /* Gray out undo */
            *pflags &=  0xfffe;
            }
        PutSzUndoInMenu();
        }
        break;

    case FIND:
        imiMin = imiFindMin;
        imiMax = imiFindMax;
        if ((GetActiveWindow() == hParentWw && CchSz(**hszSearch) == 1) ||
            (!vhDlgFind && !vhDlgChange && (CchSz(**hszSearch) == 1)) ||
            (vhDlgFind && FNoSearchStr(vhDlgFind)) ||
            (vhDlgChange && FNoSearchStr(vhDlgChange)))
            *pflags &= 0xfffd; /* disable find again */

        if (CpMacText( docCur ) == cp0)
            *pflags &= 0xfff0; /* disable find, search, change, goto page */
        break;

    case CHARACTER:
        imiMin = imiCharMin;
        imiMax = imiCharMax;

        if (!(vfOutOfMemory || vfWinFailure))
        {
        int iffn, iffnCurFont, fSetFontList;
        struct FFN **hffn, *pffn;
        union FCID fcid;
        extern struct FFN **MpFcidHffn();

        /* GetRgtsvChpSel() fills up rgtsv */
        GetRgtsvChpSel(rgtsv);

        CheckMenuItem(hMenu, imiBold,
           (rgtsv[itsvBold].fGray == 0 && rgtsv[itsvBold].wTsv != 0) ?
             MF_CHECKED : MF_UNCHECKED);
        CheckMenuItem(hMenu, imiItalic,
           (rgtsv[itsvItalic].fGray == 0 && rgtsv[itsvItalic].wTsv != 0) ?
             MF_CHECKED : MF_UNCHECKED);
        CheckMenuItem(hMenu, imiUnderline,
           (rgtsv[itsvUline].fGray == 0 && rgtsv[itsvUline].wTsv != 0) ?
             MF_CHECKED : MF_UNCHECKED);

               /* note that the value stored in rgtsv[itsvPosition].wTsv
                  is really a signed integer, so we can just check for
                  0, > 0, and < 0 */

        CheckMenuItem(hMenu, imiSuper,
           (rgtsv[itsvPosition].fGray == 0
            && (int)(rgtsv[itsvPosition].wTsv) > 0) ?
             MF_CHECKED : MF_UNCHECKED);
        CheckMenuItem(hMenu, imiSub,
           (rgtsv[itsvPosition].fGray == 0
            && (int)(rgtsv[itsvPosition].wTsv) < 0) ?
             MF_CHECKED : MF_UNCHECKED);

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IME3.1J
{
        extern int  vfImeHidden;   /*T-HIROYN ImeHidden Mode flag*/
        CheckMenuItem(hMenu, imiImeHidden,
           vfImeHidden ? MF_CHECKED : MF_UNCHECKED);
}
#endif

#if 0
        /* SetFontMenuItems() pulled on line */
        {
        /* make sure that the right font names are on the character dropdown */

        /* These two lines avoid calculating bdodCur twice */
        unsigned int bdodCur = docCur * sizeof (struct DOD);
#define pdodCur  ( (struct DOD *) ( (CHAR *)(&(**hpdocdod) [0]) + bdodCur))

        fSetFontList = !(*(pdodCur->hffntb))->fFontMenuValid;
        if (fSetFontList)
            {
            /* need to get the current list */
            viffnMenuMac = 0;
            if (FInitFontEnum(docCur, 3, TRUE))
                {
                for (iffn = 0; iffn < 3; iffn++)
                    {
                    if (!FEnumFont((struct FFN *)rgffnFontMenu[iffn]))
                        break;
                    viffnMenuMac++;
                    }
                EndFontEnum();
                (*(pdodCur->hffntb))->fFontMenuValid = TRUE;
                }
            }

        /* make sure the current font is on the list - ok, so it's kind of
           a hack */
        mfFonts = 0xffff; /* template to mask "no font" entries */
        iffnCurFont = -1;
        hffn = (struct FFN **)rgtsv[itsvFfn].wTsv;
        for (iffn = 0; iffn < 3; iffn++)
            {
            if (iffn >= viffnMenuMac)
                mfFonts ^= (0x0040 << iffn); /* disable this entry */
            else if (iffnCurFont < 0 && !rgtsv[itsvFfn].fGray)
                {
                pffn = (struct FFN *)rgffnFontMenu[iffn];
                if (WCompSz((*hffn)->szFfn, pffn->szFfn) == 0)
                    iffnCurFont = iffn;
                }
            }

        if (!rgtsv[itsvFfn].fGray && iffnCurFont < 0)
            {
            /* no match for this font - ram it in */
            if (viffnMenuMac < 3)
                viffnMenuMac++;
            iffnCurFont = viffnMenuMac - 1;
            bltbyte(*hffn, rgffnFontMenu[iffnCurFont],
                    CbFfn(CchSz((*hffn)->szFfn)));

            mfFonts |= (0x0040 << iffnCurFont); /* enable this entry */

            /* invalidate cache since we're messing it up */
            (*pdodCur->hffntb)->fFontMenuValid = FALSE;
            fSetFontList = TRUE;
            }

        if (fSetFontList)
            /* font name cache has changed - update the menu dropdown */
            for (iffn = 0; iffn < 3; iffn++)
                {
                int imi;
#ifdef  KOREA
                int i;
                CHAR rgb[LF_FACESIZE + 8];
#else
                CHAR rgb[LF_FACESIZE + 4];
#endif

                if (iffn < viffnMenuMac)
                    {
#ifdef  KOREA   /* sangl 91.6.19 */
                    i = CchCopySz(((struct FFN *)rgffnFontMenu [iffn])->szFfn,
                               &rgb [0]);
                    rgb[i] = '(';
                    rgb[i+1] = '\036';
                    rgb[i+2] = '1' + iffn;
                    rgb[i+3] = '\037';
                    rgb[i+4] = '';
                    rgb[i+5] = '' + iffn;
                    rgb[i+6] = ')';
                    rgb[i+7] = '\0';
#else
                    rgb[0] = '&';
                    rgb[1] = '1' + iffn;
                    rgb[2] = '.';
                    rgb[3] = ' ';
                    CchCopySz(((struct FFN *)rgffnFontMenu [iffn])->szFfn,
                               &rgb [4]);
#endif
                    }
                else
                    {
                    /* empty font name -- don't display it */
                    rgb [0] = '\0';
                    }

                /* Set the menu */
                imi = imiFont1 + iffn;
                ChangeMenu( vhMenu, imi, (LPSTR)rgb, imi, MF_CHANGE );
                }
        }

        *pflags &= mfFonts;

        /* see which (if any) fonts apply */
        /* note that the value stored in rgtsv[itsvFfn].wTsv
           is the font name handle, rather than the ftc */
        for (iffn = 0; iffn < 3; iffn++)
            {
            CheckMenuItem(hMenu, imiFont1 + iffn,
                iffn == iffnCurFont ? MF_CHECKED : MF_UNCHECKED);
            }
#endif
        }
        break;

    case PARA:
        imiMin = imiParaMin;
        imiMax = imiParaMax;

        if (!(vfOutOfMemory || vfWinFailure))
        {
        int jc;

        /* GetRgtsvPapSel() fills up rgtsv  with paragraph properties */
        GetRgtsvPapSel(rgtsv);

           /* if gray, set jc to invalid value */
        jc = (rgtsv[itsvJust].fGray == 0) ? rgtsv[itsvJust].wTsv : jcNil;

        CheckMenuItem(hMenu, imiParaNormal, MF_UNCHECKED);
        CheckMenuItem(hMenu, imiLeft, jc == jcLeft ? MF_CHECKED : MF_UNCHECKED);
        CheckMenuItem(hMenu, imiCenter, jc == jcCenter ? MF_CHECKED :
          MF_UNCHECKED);
        CheckMenuItem(hMenu, imiRight, jc == jcRight ? MF_CHECKED :
          MF_UNCHECKED);
        CheckMenuItem(hMenu, imiJustified, jc == jcBoth ? MF_CHECKED :
          MF_UNCHECKED);


        CheckMenuItem(hMenu, imiSingleSpace,
         (rgtsv[itsvSpacing].fGray == 0
          && rgtsv[itsvSpacing].wTsv == czaLine) ?
             MF_CHECKED : MF_UNCHECKED);

        CheckMenuItem(hMenu, imiOneandhalfSpace,
         (rgtsv[itsvSpacing].fGray == 0
          && rgtsv[itsvSpacing].wTsv == (3 * czaLine / 2)) ?
             MF_CHECKED : MF_UNCHECKED);

        CheckMenuItem(hMenu, imiDoubleSpace,
         (rgtsv[itsvSpacing].fGray == 0
          && rgtsv[itsvSpacing].wTsv == (2 * czaLine)) ?
             MF_CHECKED : MF_UNCHECKED);
        }
        break;

    case DIV:
        imiMin = imiDocuMin;
        imiMax = imiDocuMax;

        if (wwdCurrentDoc.fEditHeader)
            *pflags &= ~2; /* disable footer */
        else if (wwdCurrentDoc.fEditFooter)
            *pflags &= ~1; /* disable header */
        break;

    default:
        break;
    } /* end of switch */

    { /* enable or gray menu items */
    register WORD wFlagMask = 1;

    for (imi = imiMin; imi < imiMax; imi++)
        {
        EnableMenuItem(hMenu, imi, (*pflags & wFlagMask ? MF_ENABLED :
          MF_GRAYED));
        wFlagMask <<= 1;
        }
    }

#if defined(OLE)
    if (index == EDIT)
        ObjUpdateMenu(hMenu);
#endif
}




NEAR PutSzUndoInMenu()
{
/* Put the proper string for the current undo into the EDIT menu.
idstrCurrentUndo gives the resource id for the current undo string.  An
idstrCurrentUndo value of -1 means use the last value loaded.
This routine caches Undo strings so resource loads are needed only
when the string changes. */

extern struct UAB vuab;
extern int idstrCurrentUndo;   /* Current UNDO's string ID */
extern CHAR szAltBS[];

#ifdef JAPAN //T-HIROYN Win3.1
static CHAR szUndo[ cchSzUndo + 5];
#else
static CHAR szUndo[ cchSzUndo ];
#endif
static int idstrUndoCache = -1;

if (vuab.uac == uacNil)
    {
    idstrCurrentUndo = IDSTRUndoBase;
    }

if (idstrCurrentUndo < 0)
    {
    /* This means we should use the last Undo string */
    Assert(idstrUndoCache > 0);

    idstrCurrentUndo = idstrUndoCache;
    }

if (idstrCurrentUndo != idstrUndoCache)
    {
    /* Cached string is no good, build another */

    CHAR *PchFillPchId();
    CHAR *pch = szUndo;
#if defined(KOREA)
    if (idstrCurrentUndo != IDSTRUndoBase)
        {
        /* need the tail part */
        pch = PchFillPchId(pch, idstrCurrentUndo, (int)sizeof(szUndo) );
        }
    pch += LoadString(hMmwModInstance, IDSTRUndoBase, (LPSTR)pch,
                  (int)(szUndo + sizeof(szUndo) - pch));
    CchCopySz((PCH)szAltBS, pch);
#else
    pch += LoadString(hMmwModInstance, IDSTRUndoBase, (LPSTR)szUndo,
                  cchSzUndo);
    if (idstrCurrentUndo != IDSTRUndoBase)
        {
        /* need the tail part */
        pch = PchFillPchId(pch, idstrCurrentUndo,
            (int)(szUndo + sizeof(szUndo) - pch));
        }
    CchCopySz((PCH)szAltBS, pch);
#endif

    /* Set the menu */
    ChangeMenu( vhMenu, imiUndo, (LPSTR)szUndo, imiUndo, MF_CHANGE );

    /* Set cache for next time */
    idstrUndoCache = idstrCurrentUndo;
    }
}


GetRgtsvChpSel (prgtsv)
TSV        *prgtsv;
{
/* Return properties for the character menu.  */

typeCP cpLim;
typeCP cpStartRun;
struct CHP chp;
int cchGray = 0;  /* number of undefined (grayed) character attributes */
int ccpFetch = 0;  /* number of calls made to FetchCp */
                  /* max number of calls to FetchCp */
#define ccpFetchMax 50

#ifndef SAND
if (selCur.cpLim > cpMacCur)
    {
    bltbc(prgtsv, 1, (cchTSV * itsvchMax));  /* turn all grays on */
    return;
    }
#endif /* NOT SAND */

bltbc(prgtsv, 0, (cchTSV * itsvchMax));  /* initializw rgtsv */
CachePara(docCur, selCur.cpFirst);
if (selCur.cpFirst == selCur.cpLim)
    {
    GetChpVals (&vchpSel,prgtsv);  /* load up chp values */
    GetHffn (&vchpSel,prgtsv);  /* load up handle for font name */
    }
else
    {
    typeCP CpLimNoSpaces(typeCP, typeCP);

    cpLim = CpLimNoSpaces(selCur.cpFirst, selCur.cpLim);
    FetchCp(docCur, selCur.cpFirst, 0, fcmProps);
    blt(&vchpFetch, &chp, cwCHP);  /* CHP for use in comparisons */
    GetChpVals (&vchpFetch,prgtsv);  /* load up chp values */

    while ((vcpFetch + vccpFetch) < cpLim && ++ccpFetch <= ccpFetchMax)
        {
        /* Indicate which attributes should be grayed */
        FetchCp(docNil, cpNil, 0, fcmProps);
        chp.fSpecial = vchpFetch.fSpecial;
        if (CchDiffer (&chp, &vchpFetch, cchCHP) != 0)
            {
            SetChUndef(prgtsv, &vchpFetch, &cchGray);
            if (cchGray == itsvchMax)  /* all gray - don't bother */
                break;
            }
        }
    if (ccpFetch > ccpFetchMax)
        {
        /* never finished - make everything gray */
        bltbc(prgtsv, 1, (cchTSV * itsvchMax));
        }
    else
        GetHffn (&chp,prgtsv);  /* load up handle for font name */
    }
}


GetRgtsvPapSel (prgtsv)
TSV        *prgtsv;
{
/* Return properties for the paragraph menu.  */

/* Using selCur, the current para props are left in vpapAbs and the paragraph
   attributes in rgtsv are set to gray if that attribute differs from that
   in the previous paragraph. Up to cparaMax paragraphs will be checked */


int cparaGray = 0;  /* number of undefined (grayed) paragraph attributes */
                  /* max number of calls to CachePara */
#define cparaMax 50

int cpara = 0;
struct PAP pap;

CachePara(docCur, selCur.cpFirst);

#ifdef ENABLE /* we will show defaults even if the cursor is next to endmark */
if (selCur.cpFirst == cpMacCur)
    {
    bltbc(prgtsv, 1, (cchTSV * itsvparaMax));  /* turn all grays on */
    return;
    }
#endif

bltbc(prgtsv, 0, (cchTSV * itsvparaMax));  /* initializw rgtsv */

blt(&vpapAbs, &pap, cwPAP);   /* save 1st paragraph for compares */
GetPapVals (&pap,prgtsv);  /* load rgtsv with pap values */

while (vcpLimParaCache < selCur.cpLim && ++cpara <= cparaMax)
    {
    /* If any props are different, set appropriate flags */
    CachePara(docCur, vcpLimParaCache);
    if (CchDiffer(&pap, &vpapAbs, (cwPAPBase * cchINT)) != 0)
           {
           SetParaUndef(prgtsv, &vpapAbs, &cparaGray);
           if (cparaGray == itsvparaMax)  /* all gray - don't bother */
              break;
           }
     }

if (cpara > cparaMax)
    /* never finished - make everything gray */
    bltbc(prgtsv, 1, (cchTSV * itsvparaMax));
}


NEAR GetChpVals (pchp,prgtsv)  /* load chp values into rgtsv */
register struct CHP        *pchp;
register TSV        *prgtsv;
{

  (prgtsv+itsvBold)->wTsv = pchp->fBold;
  (prgtsv+itsvItalic)->wTsv = pchp->fItalic;
  (prgtsv+itsvUline)->wTsv = pchp->fUline;

  (prgtsv+itsvFfn)->wTsv = pchp->ftc;
  (prgtsv+itsvSize)->wTsv = pchp->hps;

                  /*  sub/superscripts - note that value is stored
                      as a signed integer, so we can just check for
                      the value relative to 0 */

  (int)((prgtsv+itsvPosition)->wTsv) = (char)pchp->hpsPos;
}

NEAR GetPapVals (ppap,prgtsv)  /* load pap values into rgtsv */
register struct PAP        *ppap;
register TSV        *prgtsv;
{

  (prgtsv+itsvJust)->wTsv = ppap->jc;
  (prgtsv+itsvSpacing)->wTsv = ppap->dyaLine;
  (prgtsv+itsvLIndent)->wTsv = ppap->dxaLeft;
  (prgtsv+itsvFIndent)->wTsv = ppap->dxaLeft1;
  (prgtsv+itsvRIndent)->wTsv = ppap->dxaRight;

}

NEAR GetHffn (pchp,prgtsv)  /* load font name handle into rgtsv */
register struct CHP        *pchp;
register TSV        *prgtsv;
{
union FCID fcid;
extern struct FFN **MpFcidHffn();
         /* store handle for font name in font name entry */
  Assert(sizeof(struct FFN **) == sizeof(prgtsv->wTsv));

  fcid.strFcid.doc = docCur;
  fcid.strFcid.ftc = pchp->ftc + (pchp->ftcXtra << 6);
  (struct FFN **)((prgtsv+itsvFfn)->wTsv) = MpFcidHffn(&fcid);
}


NEAR SetChUndef(prgtsv, pchp, pcchGray)
register TSV        *prgtsv;
register struct CHP        *pchp;
int        *pcchGray;
{

        /* compare chp to values stored in rgtsv and set undefined
           flags for differing fields of interest.  */
                     /* BOLD */
        if ((prgtsv+itsvBold)->fGray == 0)
           if (pchp->fBold != (prgtsv+itsvBold)->wTsv)
              {
              (prgtsv+itsvBold)->fGray = 1;
              (*pcchGray)++;
              }
                     /* ITALIC */
        if ((prgtsv+itsvItalic)->fGray == 0)
           if (pchp->fItalic != (prgtsv+itsvItalic)->wTsv)
              {
              (prgtsv+itsvItalic)->fGray = 1;
              (*pcchGray)++;
              }
                     /* UNDERLINE */
        if ((prgtsv+itsvUline)->fGray == 0)
           if (pchp->fUline != (prgtsv+itsvUline)->wTsv)
              {
              (prgtsv+itsvUline)->fGray = 1;
              (*pcchGray)++;
              }
                     /* Position (SUBSCRIPT OR SUPERSCRIPT) */
                     /* if different: gray both sub and superscript.
                        The properties are really mutually exclusive,
                        even though they appear on the menu as separate
                        items. Also, for Write, off and gray are the
                        same, so if either is grayed, the other must be
                        either off or gray, so the appearance is the
                        same. */

        if ((prgtsv+itsvPosition)->fGray == 0)
           if (pchp->hpsPos != (prgtsv+itsvPosition)->wTsv)
              {
              (prgtsv+itsvPosition)->fGray = 1;
              (*pcchGray)++;
              }

                     /* FONT NAME */
        if ((prgtsv+itsvFfn)->fGray == 0)
           if (pchp->ftc != (prgtsv+itsvFfn)->wTsv)
              {
              (prgtsv+itsvFfn)->fGray = 1;
              (*pcchGray)++;
              }

                     /* FONT SIZE */
        if ((prgtsv+itsvSize)->fGray == 0)
           if (pchp->hps != (prgtsv+itsvSize)->wTsv)
              {
              (prgtsv+itsvSize)->fGray = 1;
              (*pcchGray)++;
              }

}

NEAR SetParaUndef(prgtsv, ppap, pcparaGray)
register TSV    *prgtsv;
register struct PAP    *ppap;
int    *pcparaGray;
{

    /* compare pap to values stored in rgtsv and set undefined
           flags for differing fields of interest.  */
                     /* JUSTIFICATION */
        if ((prgtsv+itsvJust)->fGray == 0)
           if (ppap->jc != (prgtsv+itsvJust)->wTsv)
              {
              (prgtsv+itsvJust)->fGray = 1;
              (*pcparaGray)++;
              }
                     /* LINE SPACING */
        if ((prgtsv+itsvSpacing)->fGray == 0)
           if (ppap->dyaLine != (prgtsv+itsvSpacing)->wTsv)
              {
              (prgtsv+itsvSpacing)->fGray = 1;
              (*pcparaGray)++;
              }
                     /* LEFT INDENT */
        if ((prgtsv+itsvLIndent)->fGray == 0)
           if (ppap->dxaLeft != (prgtsv+itsvLIndent)->wTsv)
              {
              (prgtsv+itsvLIndent)->fGray = 1;
              (*pcparaGray)++;
              }
                     /* FIRST LINE INDENT */
        if ((prgtsv+itsvFIndent)->fGray == 0)
           if (ppap->dxaLeft1 != (prgtsv+itsvFIndent)->wTsv)
              {
              (prgtsv+itsvFIndent)->fGray = 1;
              (*pcparaGray)++;
              }
                     /* RIGHT INDENT */
        if ((prgtsv+itsvRIndent)->fGray == 0)
           if (ppap->dxaRight != (prgtsv+itsvRIndent)->wTsv)
              {
              (prgtsv+itsvRIndent)->fGray = 1;
              (*pcparaGray)++;
              }

}



/* C P  L I M  N O  S P A C E S */
typeCP CpLimNoSpaces(cpFirst, cpLim)
typeCP cpFirst, cpLim;
{
/* Truncate trailing spaces unless only spaces are in sel. */

int cch;
typeCP cpLimOrig;
CHAR rgch[cchMaxSz];

cpLimOrig = cpLim;

FetchRgch(&cch, rgch, docCur, CpMax(cpFirst + cchMaxSz, cpLim) - cchMaxSz,
  cpLim, cchMaxSz);
while (cch-- > 0 && rgch[cch] == chSpace)
    {
    --cpLim;
    }
return cch < 0 ? cpLimOrig : cpLim;
} /* end of CpLimNoSpaces */




NEAR FNoSearchStr(hDlg)
HWND hDlg;
{
CHAR szBuf[255];
HWND hWndFrom = GetActiveWindow();

if (hDlg == hWndFrom || hDlg == (HANDLE)GetWindowWord(hWndFrom, GWW_HWNDPARENT))
    {
    if (GetDlgItemText(hDlg, idiFind, (LPSTR)szBuf, 255) == 0)
        return(TRUE);
    }
return(FALSE);
}




PhonyMenuAccelerator( menu, imi, lpfn )
int menu;
int imi;
FARPROC lpfn;
{
    HMENU hSubmenu = GetSubMenu(vhMenu,menu);

    SetAppMenu( hSubmenu , menu );

    if (FIsMenuItemEnabled( hSubmenu , imi ))
    {
        HiliteMenuItem( hParentWw, vhMenu, menu, MF_BYPOSITION | MF_HILITE );
        (*lpfn) ();
        HiliteMenuItem( hParentWw, vhMenu, menu, MF_BYPOSITION );
    }
}




FIsMenuItemEnabled (HMENU hMenu , int id )
{   /* Find out if a menu item in vhMenu is enabled. */
    return !(GetMenuState(hMenu, id, MF_BYCOMMAND ) & (MF_DISABLED|MF_GRAYED));
}


int FAR PASCAL NewFont(HWND hwnd);

void MmwCommand(hWnd, wParam, hWndCtl, codeCtl)
HWND hWnd;
WORD wParam;
HWND hWndCtl;
WORD codeCtl;
{
#ifdef INEFFLOCKDOWN
extern FARPROC lpDialogHelp;
extern FARPROC lpDialogGoTo;
extern FARPROC lpDialogCharFormats;
extern FARPROC lpDialogParaFormats;
extern FARPROC lpDialogTabs;
extern FARPROC lpDialogDivision;
extern FARPROC lpDialogPrinterSetup;
#else
extern BOOL far PASCAL DialogPrinterSetup(HWND, unsigned, WORD, LONG);
extern BOOL far PASCAL DialogHelp(HWND, unsigned, WORD, LONG);
extern BOOL far PASCAL DialogGoTo(HWND, unsigned, WORD, LONG);
extern BOOL far PASCAL DialogCharFormats(HWND, unsigned, WORD, LONG);
extern BOOL far PASCAL DialogParaFormats(HWND, unsigned, WORD, LONG);
extern BOOL far PASCAL DialogTabs(HWND, unsigned, WORD, LONG);
extern BOOL far PASCAL DialogDivision(HWND, unsigned, WORD, LONG);
#endif
extern int vfPictSel;
extern CHAR *vpDlgBuf;

int DialogOk = 0;
int fQuit = fFalse;

    if (wParam & fMenuItem)
        {
        switch (wParam & MENUMASK)
            {
        case FILEMENU:
            switch(wParam)
                {
            case imiNew:
                fnNewFile();
                break;
            case imiOpen:
                fnOpenFile((LPSTR)NULL);
                break;
            case imiSave:
#if defined(OLE)
                if (CloseUnfinishedObjects(TRUE) == FALSE)
                    return;
#endif
                fnSave();
                break;
            case imiSaveAs:
#if defined(OLE)
                if (CloseUnfinishedObjects(TRUE) == FALSE)
                    return;
#endif
                fnSaveAs();
                break;
            case imiPrint:
                fnPrPrinter();
                break;
            case imiPrintSetup:
                /* Bring up the Change Printer dialog box. */
                PrinterSetupDlg(FALSE);
                break;
            case imiRepaginate:
                fnRepaginate();
                break;
            case imiQuit:
                fnQuit(hWnd);
                fQuit = fTrue;
                break;
            default:
                break;
                }
            break;

        case EDITMENU:
            switch(wParam)
                {
            case imiUndo:
                CmdUndo();
                break;
            case imiCut:
                fnCutEdit();
                break;
            case imiCopy:
                fnCopyEdit();
                break;
            case imiPaste:
#if defined(OLE)
                vbObjLinkOnly = FALSE;
#endif
                fnPasteEdit();
                break;
#if defined(OLE)
            case imiPasteSpecial:
                vbObjLinkOnly = FALSE;
                fnObjPasteSpecial();
                break;
            case imiPasteLink:
                vbObjLinkOnly = TRUE;
                fnPasteEdit();
                break;
            case imiInsertNew:
                fnObjInsertNew();
            break;
#endif
            case imiMovePicture:
                fnMovePicture();
                break;
            case imiSizePicture:
                fnSizePicture();
                break;
#if defined(OLE)
            case imiProperties:
                fnObjProperties();
            break;
#endif
            default:
                break;
                }
            break;

#if defined(OLE)
        case VERBMENU:
            fnObjDoVerbs(wParam);
        break;
#endif

        case FINDMENU:
            if (wParam != imiGoTo && wParam != imiFindAgain)
                StartLongOp();
            switch(wParam)
                {
            case imiFind:
                fnFindText();
                break;
            case imiFindAgain:
                fnFindAgain();
                break;
            case imiChange:
                fnReplaceText();
                break;
            case imiGoTo:
                {
#ifndef INEFFLOCKDOWN
                FARPROC lpDialogGoTo = MakeProcInstance(DialogGoTo, hMmwModInstance);
                if (!lpDialogGoTo)
                    goto LNotEnufMem;
#endif
                DialogOk = OurDialogBox(hMmwModInstance, MAKEINTRESOURCE(dlgGoTo),
                  hParentWw, lpDialogGoTo);
#ifndef INEFFLOCKDOWN
                FreeProcInstance(lpDialogGoTo);
#endif

/* the following block has been commentted out because
   the corresponding file(DISP.C) doesn't inlcude MmwCatSt
   routine anymore */

#if  0
            {
            extern void far MmwCatSt( HWND, BOOL );
                MmwCatSt(hParentWw, FALSE);
            }
#endif

                break;
                }
            default:
                break;
                }
            break;

        case CHARMENU:
            if (wParam != imiCharFormats)
                StartLongOp();
            {
            /* rgtsv gets attributes and gray flags from CHP */
            TSV rgtsv[itsvchMax];
            CHAR rgbDlgBuf[sizeof(BOOL)];
               void NEAR fnCharSelectFont(int);

            /* GetRgtsvChpSel() fills up rgtsv */
            GetRgtsvChpSel(rgtsv);
            switch(wParam)
                {
            case imiCharNormal:
                ApplyCLooks(0, sprmCPlain, 0);
                break;
            case imiBold:
                ApplyCLooks(0, sprmCBold, (rgtsv[itsvBold].fGray != 0) ? TRUE :
                  !rgtsv[itsvBold].wTsv);
                break;
            case imiItalic:
                ApplyCLooks(0, sprmCItalic, (rgtsv[itsvItalic].fGray != 0) ?
                  TRUE : !rgtsv[itsvItalic].wTsv);
                break;
            case imiUnderline:
                ApplyCLooks(0, sprmCUline, (rgtsv[itsvUline].fGray != 0) ? TRUE
                  : !rgtsv[itsvUline].wTsv);
                break;
            case imiSuper:
                /* Note that the value stored in rgtsv[itsvPosition].wTsv is
                really a signed integer, so we can just check for 0, > 0, and <
                0. */
                ApplyCLooks(0, sprmCPos, !(rgtsv[itsvPosition].fGray == 0 &&
                  (int)rgtsv[itsvPosition].wTsv > 0) ? ypSubSuper : 0);
                break;
            case imiSub:
                ApplyCLooks(0, sprmCPos, !(rgtsv[itsvPosition].fGray == 0 &&
                  (int)rgtsv[itsvPosition].wTsv < 0) ? -ypSubSuper : 0);
                break;
#if 0
            case imiFont1:
                fnCharSelectFont(0);
                break;
            case imiFont2:
                fnCharSelectFont(1);
                break;
            case imiFont3:
                fnCharSelectFont(2);
                break;
#endif
            case imiSmFont:
                if (CanChangeFont(-1))
                {
                    ApplyCLooks(0, sprmCChgHps, -1);
                    vfSeeSel = TRUE;
                }
                break;
            case imiLgFont:
                if (CanChangeFont(1))
                {
                    ApplyCLooks(0, sprmCChgHps, 1);
                    vfSeeSel = TRUE;
                }
                break;
            case imiCharFormats:
                {
#if 0

#ifndef INEFFLOCKDOWN
                FARPROC lpDialogCharFormats = MakeProcInstance(DialogCharFormats, hMmwModInstance);
                if (!lpDialogCharFormats)
                    goto LNotEnufMem;
#endif
                vpDlgBuf = &rgbDlgBuf[0];
                DialogOk = OurDialogBox(hMmwModInstance,
                                     MAKEINTRESOURCE(dlgCharFormats),
                                     hParentWw, lpDialogCharFormats);
#ifndef INEFFLOCKDOWN
                FreeProcInstance(lpDialogCharFormats);
#endif

#else
        DialogOk = NewFont(hParentWw);
#endif

break;
                }
#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IME3.1J
            case imiImeHidden:
                ChangeImeConversionMode();
                break;
#endif
            default:
                break;
                }

#if defined(JAPAN) & defined(DBCS_IME) //Win3.1J
            SetImeFont(vhWnd);
#endif
  
            break;
            }

        case PARAMENU:
            switch(wParam)
                {
            case imiParaNormal:
                ApplyLooksParaS(0, sprmPNormal, 0);
                if (vfPictSel)
                    {
                    CmdUnscalePic();
                    }
                break;
            case imiLeft:
                ApplyLooksParaS(0, sprmPJc, jcLeft);
                break;
            case imiCenter:
                ApplyLooksParaS(0, sprmPJc, jcCenter);
                break;
            case imiRight:
                ApplyLooksParaS(0, sprmPJc, jcRight);
                break;
            case imiJustified:
                ApplyLooksParaS(0, sprmPJc, jcBoth);
                break;
            case imiSingleSpace:
                ApplyLooksPara(0, sprmPDyaLine, czaLine);
                break;
            case imiOneandhalfSpace:
                ApplyLooksPara(0, sprmPDyaLine, czaLine * 3 / 2);
                break;
            case imiDoubleSpace:
                ApplyLooksPara(0, sprmPDyaLine, czaLine * 2);
                break;
            case imiParaFormats:
                {
#ifndef INEFFLOCKDOWN
                FARPROC lpDialogParaFormats = MakeProcInstance(DialogParaFormats, hMmwModInstance);
                if (!lpDialogParaFormats)
                    goto LNotEnufMem;
#endif
                DialogOk = OurDialogBox(hMmwModInstance,
                                     MAKEINTRESOURCE(dlgParaFormats),
                                     hParentWw, lpDialogParaFormats);
#ifndef INEFFLOCKDOWN
                FreeProcInstance(lpDialogParaFormats);
#endif
                break;
                }
            default:
                break;
                }
            break;

        case DOCUMENU:
            switch(wParam)
                {
            case imiFooter:
            case imiHeader:
                fnEditRunning(wParam);
                break;
            case imiShowRuler:
                fnShowRuler();
                break;
            case imiTabs:
                {
#ifndef INEFFLOCKDOWN
                FARPROC lpDialogTabs = MakeProcInstance(DialogTabs, hMmwModInstance);
                if (!lpDialogTabs)
                    goto LNotEnufMem;
#endif
                DialogOk = OurDialogBox(hMmwModInstance, MAKEINTRESOURCE(dlgTabs),
                  hParentWw, lpDialogTabs);
#ifndef INEFFLOCKDOWN
                FreeProcInstance(lpDialogTabs);
#endif
                break;
                }
            case imiDivFormats:
                {
#ifndef INEFFLOCKDOWN
                FARPROC lpDialogDivision = MakeProcInstance(DialogDivision, hMmwModInstance);
                if (!lpDialogDivision)
                     goto LNotEnufMem;
#endif
                DialogOk = OurDialogBox(hMmwModInstance,
                                     MAKEINTRESOURCE(dlgDivision),
                  hParentWw, lpDialogDivision);
#ifndef INEFFLOCKDOWN
                FreeProcInstance(lpDialogDivision);
#endif
                break;
                }
            default:
                break;
                }
            break;

        case HELPMENU:
            {
            int wHelpCode;
            extern WORD wWinVer;
            CHAR sz[ cchMaxFile ];
LDefaultHelp:
            PchFillPchId( sz, IDSTRHELPF, sizeof(sz) );
            switch(wParam)
                {
                case imiIndex:
                    WinHelp(hParentWw, (LPSTR)sz, HELP_INDEX, NULL);
                    break;
                case imiHelpSearch:
                    WinHelp(hParentWw, (LPSTR)sz, HELP_PARTIALKEY, (DWORD)(LPSTR)"");
                    break;
                case imiUsingHelp:
                    WinHelp(hParentWw, (LPSTR)NULL, HELP_HELPONHELP, NULL);
                    break;
                default:
                case imiAbout:
                    if (((wWinVer & 0xFF) >= 3) && ((wWinVer & 0xFF00) >= 0x0A00))
                    {
                        extern CHAR         szMw_icon[];
                        extern  CHAR    szAppName[];
                        ShellAbout(hParentWw, szAppName, "",
                            LoadIcon( hMmwModInstance, (LPSTR)szMw_icon ));
                    }
                    break;
                }
            break;
            }

        default:
            if (wParam == imiHelp)
                {
#ifdef WIN30
                wParam = imiIndex;  /* For all Win3 applets, pressing F1
                                       should bring up the Help Index */
#endif
                goto LDefaultHelp;
                }
            }
        if (DialogOk == -1)
            {
LNotEnufMem:
#ifdef WIN30
            WinFailure();
#else
            Error(IDPMTNoMemory);
#endif
            }
        }

    if (!fQuit)
        UpdateInvalid();   /* To be sure we update the area behind dialogs */
}




#if 0
void NEAR fnCharSelectFont(iffn)
/* select the specified font from the three listed on char dropdown */

int iffn;
    {
    struct FFN *pffn;
    int ftc;

    extern CHAR rgffnFontMenu[3][ibFfnMax];
    extern int            docCur;

    pffn = (struct FFN *)rgffnFontMenu[iffn];

    ftc = FtcChkDocFfn(docCur, pffn);
    if (ftc != ftcNil)
        ApplyCLooks(0, sprmCFtc, ftc);
    vfSeeSel = TRUE;
    }
#endif

#ifdef JAPAN //Win3.1J
int KanjiFtc = ftcNil;

GetKanjiFtc(pchp)
struct CHP *pchp;
{
    int ftc;
    int CharSet;

    CharSet = GetCharSetFromChp(pchp);

    if (NATIVE_CHARSET == CharSet) {
		KanjiFtc = GetFtcFromPchp(pchp);
        return(ftcNil);
    } else {
        if(KanjiFtc == ftcNil)
            ftc = SearchKanjiFtc(docCur);    //Get set New szFfn chs
        else
            ftc = KanjiFtc;
        return(ftc);
    }
}

GetCharSetFromChp(pchp)
struct CHP *pchp;
{
    TSV rgtsv[itsvchMax];  /* gets attributes and gray flags from CHP, PAP */
    struct FFN **hffn;

    GetHffn (pchp,rgtsv);  /* load up handle for font name */
    hffn = (struct FFN **)rgtsv[itsvFfn].wTsv;
    return((*hffn)->chs);
}

extern CHAR saveKanjiDefFfn[ibFfnMax];

SearchKanjiFtc(doc)
/* looks for described font in docs ffntb - returns ftcNil if not found */
int doc;
{
    int ftc;
    int iffn, iffnMac;
    struct FFNTB **hffntb;
    struct FFN ***mpftchffn;
    struct FFN *pffn;

    ftc = ftcNil;
    hffntb = HffntbGet(doc);
    if (hffntb != 0) {
        mpftchffn = (*hffntb)->mpftchffn;
        iffnMac = (*hffntb)->iffnMac;
        for (iffn = 0; iffn < iffnMac; iffn++) {
            if ( (*mpftchffn[iffn])->chs == NATIVE_CHARSET &&
                 (*mpftchffn[iffn])->szFfn[0] != chGhost)
                return(iffn);
        }
    }

    pffn = (struct FFN *)saveKanjiDefFfn;

    ftc = FtcChkDocFfn(doc, pffn);

    if (ftc != ftcNil)
        return(ftc);

    return(ftcNil);
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\loadfont.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* loadfont.c - MW font support code */

#define NOWINMESSAGES
#define NOVIRTUALKEYCODES
#define NOSYSMETRICS
#define NOMENUS
#define NOWINSTYLES
#define NOCTLMGR
#define NOCLIPBOARD
#include <windows.h>

#include "mw.h"
#include "propdefs.h"
#include "macro.h"
#define NOUAC
#include "cmddefs.h"
#include "wwdefs.h"
#include "fontdefs.h"
#include "docdefs.h"

#ifdef  DBCS
#include "dbcs.h"
#include "kanji.h"
#endif

extern HDC vhMDC;
extern HDC vhDCPrinter;
extern struct CHP vchpNormal;
extern int vifceMac;
extern union FCID vfcidScreen;
extern union FCID vfcidPrint;
extern struct FCE rgfce[ifceMax];
extern struct FCE *vpfceMru;
extern struct FCE *vpfceScreen;
extern struct FCE *vpfcePrint;
extern struct FMI vfmiScreen;
extern struct FMI vfmiPrint;
#ifdef SYSENDMARK
extern struct FMI vfmiSysScreen;
#endif /* KANJI */


extern int dxpLogInch;
extern int dypLogInch;
extern int dxaPrPage;
extern int dyaPrPage;
extern int dxpPrPage;
extern int dypPrPage;
extern int ypSubSuperPr;
extern BOOL vfPrinterValid;


#ifdef DEBUG
BOOL NEAR DogoneTrashTest(HDC hdc, struct FCE *pfce, BOOL fPrint);
#endif

NEAR LoadFcid(union FCID *, struct CHP *);
void NEAR SelectWriteFont(int, HFONT *);
struct FCE * (PfceFcidScan(union FCID *));
struct FCE * (PfceLruGet(void));
#ifdef SMFONT
void NEAR FillWidthTable(HDC, int [], TEXTMETRIC *);
#endif /* SMFONT */

#ifdef JAPAN                  //  added  11 Jun. 1992  by Hiraisi
void fnCheckWriting( LPLOGFONT );
#endif

LoadFont( doc, pchp, mdFont )
/* loads the font specified in pchp for this doc.  mdFont tells us how the
   font will be used (printer, screen, screen modulo printer,... */

int doc;
register struct CHP *pchp;
int mdFont;

    {
    register int wFcid;
    struct CHP *pchpT;
    union FCID fcid;

    Assert(doc != docNil);

    pchpT = pchp;
    if (pchp == NULL)
        pchp = &vchpNormal;

    fcid.strFcid.hps = pchp->hps;
    fcid.strFcid.ftc = pchp->ftc;
    fcid.strFcid.doc = doc;
#ifdef ENABLE
    wFcid = pchp->psWidth;
    wFcid |= bitPrintFcid;
    if (pchp->fItalic)
        wFcid |= bitItalicFcid;
    if (pchp->fBold)
        wFcid |= bitBoldFcid;
    if (pchp->fUline)
        wFcid |= bitUlineFcid;
    if (pchp->fFixedPitch)
        wFcid |= bitFixedPitchFcid;
    fcid.strFcid.wFcid = wFcid;
#else
    /* Super-nitpick-optimization (but worth it because LoadFont can take
       10% of display refresh time): bits being cleared is more
       common than set, and a "jump not taken" plus an "or di, xxxx" is 8
       cycles, vs the above "jump taken" which is 16 */

    wFcid = pchp->psWidth + bitPrintFcid + bitItalicFcid + bitBoldFcid +
      bitUlineFcid + bitFixedPitchFcid;
    if (!pchp->fItalic)
        wFcid &= ~bitItalicFcid;
    if (!pchp->fBold)
        wFcid &= ~bitBoldFcid;
    if (!pchp->fUline)
        wFcid &= ~bitUlineFcid;
    if (!pchp->fFixedPitch)
        wFcid &= ~bitFixedPitchFcid;
    fcid.strFcid.wFcid = wFcid;
#endif

    switch (mdFont)
        {
        /* fall throughs are intentional! */

        default:
            break;

        case mdFontChk:         /* sets font as constrained by printer avail */
        case mdFontPrint:       /* like mdFontScreen, but for the printer */
            /* don't want to jam the chp props back */
            pchpT = NULL;

        case mdFontJam:         /* like mdFontChk, but jams props into chp */

            /* get printer font loaded */
            LoadFcid(&fcid, pchpT);

            if (mdFont == mdFontPrint)
                /* don't need screen font */
                return;

        case mdFontScreen:      /* sets font for random screen chars */
            /* get screen font loaded */
            fcid.strFcid.wFcid &= ~bitPrintFcid;
            LoadFcid(&fcid, (struct CHP *)NULL);
        }
    }


NEAR LoadFcid(pfcid, pchp)
/* loads described font and associates it with the appropriate dc's */

union FCID *pfcid;
struct CHP *pchp;
    {
    register struct FCE *pfce;
    int fPrint;
    int fTouchAndGo;
    int fGetMetrics;
    int fNewFont;
    struct FFN **hffnSave;
    LOGFONT lf;

#ifdef SYSENDMARK
    fPrint = pfcid->strFcid.wFcid & bitPrintFcid;

    /* Since this ftc came from CHP, we have lost the first 2 bits. */
    if (pfcid->strFcid.ftc == (bitFtcChp & ftcSystem)) {
        /* If vpfceScreen == NULL already, the standard system font
           has already been selected. So, save some time here.      */
        if (vpfceScreen != NULL) {
            /* Gives you the standard system font for the screen.   */
            ResetFont(FALSE);
            }
        bltbyte(&vfmiSysScreen, &vfmiScreen, sizeof(struct FMI));
#if defined(KANJI) && defined(DFONT)
        /* CommSz("System Font!\r\n"); */
        KTS();
#endif
        return;
        }
    else if (fPrint)
#else
    if ((fPrint = pfcid->strFcid.wFcid & bitPrintFcid))
#endif /* if-else-def KANJI */
        {
        if (pfcid->lFcid == vfcidPrint.lFcid)
            {
            pfce = vpfcePrint;
            fTouchAndGo = TRUE;
            goto EstablishFont;
            }
        }
    else
        {
        if (pfcid->lFcid == vfcidScreen.lFcid)
            {
            pfce = vpfceScreen;
            fTouchAndGo = TRUE;
            goto EstablishFont;
            }
        }

    /* failed at the "trivial" comparisons - look through list */
    fTouchAndGo = FALSE;
    pfce = vpfceMru;
    do
        {
        if (pfce->fcidRequest.lFcid == pfcid->lFcid)
            {
            /* found a match */
            fGetMetrics = FALSE;
            goto EstablishFont;
            }
        pfce = pfce->pfceNext;
        }
    while (pfce != vpfceMru);

    /* failed at the "easy" search - look for name text & property match */
    fGetMetrics = TRUE;
    if (fNewFont = (pfce = PfceFcidScan(pfcid)) == NULL)
        {
        /* this font isn't in our list - we have to create it */
        int wFcid = pfcid->strFcid.wFcid;
        int dyaHeight;
        int cwAlloc;
        int ich;
        struct FFN **hffnT;
        struct FFN **MpFcidHffn();

        pfce = PfceLruGet();    /* disposes of a font to make room */

        bltbc(&lf, 0, sizeof(LOGFONT));
        dyaHeight = pfcid->strFcid.hps * (czaPoint / 2);
        if (fPrint)
            {
            lf.lfHeight = -MultDiv(dyaHeight, dypPrPage, dyaPrPage);
            }
        else
            {
            /* In the Z version we have tried the idea of using a
               positive value for selection based on cell height
               rather than character height because of weirdness
               with the Courier screen font -- but it seemed to
               mess too many things up (like make all other fonts
               a bit too small and it didn't always make Courier
               work right).  I believe Win Word *is* using this
               trick but only when selecting Courier fonts.  It
               seems to me like there has got to be a different
               cause of this anamoly.  ..pault 9/22/89 */

            lf.lfHeight = -MultDiv(dyaHeight, dypLogInch, czaInch);
            if (wFcid & grpbitPsWidthFcid)
                {
// Sync Win3.0 //T-HIROYN
#ifdef JAPAN
#ifdef KKBUGFIX     //  added by Hiraisi (BUG#1980)
                lf.lfWidth = 0;
#else
                lf.lfWidth = MultDiv((wFcid & grpbitPsWidthFcid) * czaPoint,
                dxpLogInch, czaInch);
#endif
#else
                //lf.lfWidth = MultDiv((wFcid & grpbitPsWidthFcid) * czaPoint,
                  //dxpLogInch, czaInch);
                lf.lfWidth = 0;
#endif
                }
            }

        if (wFcid & bitItalicFcid)
            {
            lf.lfItalic = 1;
            }
        if (wFcid & bitUlineFcid)
            {
            lf.lfUnderline = 1;
            }
        lf.lfWeight = wFcid & bitBoldFcid ? FW_BOLD : FW_NORMAL;

        hffnSave = MpFcidHffn(pfcid);

#ifdef  JAPAN
//   When we need system font, we want rather variable pitch than fixed,
//  since fixed pitch system font is probably same as terminal font.
//   So we specify VARIABLE_PITCH especialy for system font.

{
    extern  char    szSystem[];
    extern  char    szAtSystem[];

        if( WCompSz(szSystem,(*hffnSave)->szFfn) == 0
        ||  WCompSz(szAtSystem,(*hffnSave)->szFfn) == 0  )// Add '@'systemfont
            lf.lfPitchAndFamily = (*hffnSave)->ffid | VARIABLE_PITCH ;
        else
            lf.lfPitchAndFamily
            = ((*hffnSave)->ffid) | ((wFcid & bitPrintFcid) ?
                DEFAULT_PITCH : ((wFcid & bitFixedPitchFcid) ? FIXED_PITCH :
                VARIABLE_PITCH));
}
#else
        lf.lfPitchAndFamily = ((*hffnSave)->ffid) | ((wFcid & bitPrintFcid) ?
          DEFAULT_PITCH : ((wFcid & bitFixedPitchFcid) ? FIXED_PITCH :
          VARIABLE_PITCH));
#endif

#if defined(NEWFONTENUM) && !defined(KANJI)
        lf.lfCharSet = (*hffnSave)->chs; /* pass the character set that
                                            enumfonts told us this fontname
                                            was associated with ..pault */
#else
/*T-HIROYN from 3.0 loadfont.c*/
#if defined(NEWFONTENUM) && defined(JAPAN)
        lf.lfCharSet = (*hffnSave)->chs; /* pass the character set that
                                            enumfonts told us this fontname
                                            was associated with ..pault */
#endif  /* NEWFONTENUM and JAPAN */

#endif

        ich = 0;
        if ((*hffnSave)->szFfn[0] == chGhost)
            {
            ich++;
            }
        bltszLimit(&(*hffnSave)->szFfn[ich], lf.lfFaceName, LF_FACESIZE);

#ifdef  KOREA
    if ( (*hffnSave)->szFfn[ich] > 0xA0 ||
         ( (*hffnSave)->szFfn[ich]=='@' && (*hffnSave)->szFfn[ich+1] > 0xA0 ) ||
         ( WCompSz(lf.lfFaceName,"terminal")==0 ) ||
         ( WCompSz(lf.lfFaceName,"@terminal")==0 ) ||
         ( WCompSz(lf.lfFaceName,"system")==0 ) ||
         ( WCompSz(lf.lfFaceName,"@system")==0 ) )

        lf.lfCharSet = HANGEUL_CHARSET;
#endif

#if defined(DFONT) || defined (PRDRVTEST)
        {
        char rgch[100];
        wsprintf(rgch, "Creating %s font: %s,\t\th %d, w %d, charset %d\n\r",
                 (LPSTR)(fPrint ? "prt" : "scr"), (LPSTR)lf.lfFaceName,
                 lf.lfHeight, lf.lfWidth, (int)(lf.lfCharSet));
        CommSz(rgch);

        CommSzNum("     Requested weight: ", lf.lfWeight);
        CommSzNum("     Requested italics: ", lf.lfItalic);
        CommSzNum("     Requested underline: ", lf.lfUnderline);
        CommSzNum("     Requested family: ", lf.lfPitchAndFamily >> 4);
        CommSzNum("     Requested pitch: ", lf.lfPitchAndFamily & 3);
        }
#endif /* DFONT */

#ifdef JAPAN                  //  added  11 Jun. 1992  by Hiraisi
{
    extern BOOL fPrinting;    //  Specifies printing doc.
                              //  PrintDoc function had set this flag.
    extern BOOL fWriting;     //  Specifies printing direction.
                              //  TRUE vertically  or  FALSE horizontally.
                              //  This flag had been set in the PRINT DIALOG.

        if( fPrinting && fWriting )
            fnCheckWriting( (LPLOGFONT)&lf );
}
#endif

        if ((pfce->hfont = CreateFontIndirect((LPLOGFONT)&lf)) == NULL)
            {
            pfce->hfont = GetStockObject( fPrint && vfPrinterValid ?
                                DEVICE_DEFAULT_FONT : SYSTEM_FONT );
            Assert( pfce->hfont );
            /* if the above fails, I don't know what we can do */

            WinFailure();     /* report the failure so we give the user notice
                               for weird behavior to follow */
            }

#ifdef DFONT
        CommSzNum("Font handle: ", pfce->hfont);
#endif /* DFONT */

        pfce->fcidRequest = *pfcid;
        cwAlloc = CwFromCch(CbFfn(CchSz((*hffnSave)->szFfn)));
        if (FNoHeap(hffnT = (struct FFN **)HAllocate(cwAlloc)))
            {
            FreePfce(pfce);
            return;
            }
        else
            {
            blt((*hffnSave), (*hffnT), cwAlloc);
            }
        pfce->hffn = hffnT;
        }

EstablishFont:
    if ((pfce != vpfceMru) && (pfce != vpfceMru->pfceNext))
        {
        /* make this the mru font cache entry */
        /* Only do it if pfce is not already one of the first 2 mru fonts */
        /* since we generally ask for the things in groups of 2 */

        /* pull it out of its current place */
        pfce->pfceNext->pfcePrev = pfce->pfcePrev;
        pfce->pfcePrev->pfceNext = pfce->pfceNext;

        /* insert it at mru position */
        pfce->pfceNext = vpfceMru;
        pfce->pfcePrev = vpfceMru->pfcePrev;
        pfce->pfceNext->pfcePrev = pfce;
        pfce->pfcePrev->pfceNext = pfce;
        vpfceMru = pfce;

#ifndef JAPAN  // added by Hiraisi(BUG#4645/WIN31)
#ifndef DISCARDABLE_FONTS
        /* KLUDGE ALERT: To accomodate Windows inability to make synthesized
        fonts discardable, we will now throw out the third font in the LRU chain
        if it is taller than 16 points.  (Ain't this a doozey...) */
            {
            register struct FCE *pfceThird = vpfceMru->pfceNext->pfceNext;

            if (pfceThird->fcidRequest.lFcid != fcidNil &&
#ifdef OLD
              pfceThird->fcidActual.strFcid.hps > 32)
#else
              pfceThird->fcidActual.strFcid.hps > 48)
#endif /* if-else-def OLD */
                {
                /* Free this particular font. */
                FreePfce(pfceThird);
                }
            }
#endif /* not DISCARDABLE_FONTS */
#endif // not JAPAN

        }

    if (!fTouchAndGo)
        {
        /* we have this font in our cache, but we need to select it */
        SelectWriteFont(fPrint, &pfce->hfont);

        /**
            I wish I knew why this is needed, but I don't want to spend
            more time on it.  For some reason the font width table
            (pfce->rgdxp) is getting either trashed or is simply
            incorrect when first obtained.  I suspect it is a GDI bug
            because it only happens the first time you use certain fonts
            (at least in Write) during a given session of Windows.
            The DogoneTrashTest detects the problem and fixes it.
            It is slow though, unfortunately.
            (7.25.91) v-dougk.
        **/

#ifdef DEBUG
        if (!fGetMetrics)
            DogoneTrashTest(fPrint ? vhDCPrinter : vhMDC, pfce, fPrint);
#endif

        if (fGetMetrics)
            {
            register union FCID *pfcidT = &pfce->fcidActual;
            HDC hDCMetrics = fPrint ? vhDCPrinter : vhMDC;
            TEXTMETRIC tm;

            Assert(hDCMetrics);
            if (hDCMetrics == NULL)
                return;

            GetTextMetrics(hDCMetrics, (LPTEXTMETRIC)&tm);
            if (fNewFont)
                {
                /* We need all of the metrics for this guy. */
                CHAR szFace[LF_FACESIZE];
                int wFcid;
                int dypHeight;
                int dxpch;

#if defined(DFONT) || defined(PRDRVTEST)
                {
                char rgch[100];
                GetTextFace(hDCMetrics, LF_FACESIZE, (LPSTR)szFace);
                wsprintf(rgch, "     Actual fname: %s,\t\th %d, w %d, charset %d\n\r",
                         (LPSTR)szFace, tm.tmHeight-tm.tmInternalLeading,
                         tm.tmAveCharWidth, (int)(tm.tmCharSet));
                CommSz(rgch);
                }
                CommSzNum("     Actual width: ", tm.tmAveCharWidth);
                CommSzNum("     Actual leading: ", tm.tmInternalLeading +
                  tm.tmExternalLeading);
                CommSzNum("     Actual weight: ", tm.tmWeight);
                CommSzNum("     Actual italics: ", tm.tmItalic);
                CommSzNum("     Actual underline: ", tm.tmUnderlined);
                CommSzNum("     Actual font family: ", tm.tmPitchAndFamily >>
                  4);
                CommSzNum("     Actual pitch: ", tm.tmPitchAndFamily & 1);
#endif /* DFONT */

                SetTextJustification(hDCMetrics, 0, 0);
                pfce->fmi.dxpOverhang = tm.tmOverhang;
#if defined(KOREA)
                if ((tm.tmPitchAndFamily & 1) == 0)
                     pfce->fmi.dxpSpace = tm.tmAveCharWidth;
                else
#endif
                pfce->fmi.dxpSpace = LOWORD(GetTextExtent(hDCMetrics,
                  (LPSTR)" ", 1)) - tm.tmOverhang;
#ifdef PRDRVTEST
                {
                /* Just so no printers or printer driver manufacturers
                   get funky on us!  ..pault */
                int dxpSpace = pfce->fmi.dxpSpace + tm.tmOverhang;

                CommSzNum("    GetTextExtent(space) ", LOWORD(GetTextExtent(hDCMetrics, (LPSTR)" ", 1)));
                if (dxpSpace < 1 || dxpSpace > tm.tmMaxCharWidth+tm.tmOverhang)
                    {
                    pfce->fmi.dxpSpace = tm.tmAveCharWidth;
                    CommSzNum("    ...resetting to ",pfce->fmi.dxpSpace);
                    }
                }
#endif
                pfce->fmi.dypAscent = tm.tmAscent;
                pfce->fmi.dypDescent = tm.tmDescent;
                pfce->fmi.dypBaseline = tm.tmAscent;
                pfce->fmi.dypLeading = tm.tmExternalLeading;
#ifdef DBCS
                pfce->fmi.dypIntLeading = tm.tmInternalLeading;
//#ifdef  KOREA
//        if (tm.tmPitchAndFamily & 1) /* Is variable pitch ? */
//                        pfce->fmi.dxpDBCS = dxpNil;
//        else
//#endif
                {
#if defined(TAIWAN) || defined(KOREA) || defined(PRC) //fix Italic display error, for Bug# 3362, MSTC - pisuih, 3/4/93
                CHAR    rgchT[cchDBCS << 1];
                int     dxpOverhang;
#else
                CHAR rgchT[cchDBCS];
#endif //TAIWAN
                int  dxpDBCS;

                rgchT[0] = rgchT[1] = bKanji1Min;

                dxpDBCS = LOWORD(GetTextExtent(hDCMetrics,
                                                (LPSTR) rgchT, cchDBCS));

#if defined(TAIWAN) || defined(KOREA) || defined(PRC) //fix Italic display error, for Bug# 3362, MSTC - pisuih, 3/4/93
                rgchT[2] = rgchT[3] = bKanji1Min;
                dxpOverhang = (dxpDBCS << 1) - LOWORD( GetTextExtent(
                  hDCMetrics, (LPSTR) rgchT, cchDBCS << 1 ));

               //for compatible with SBCS's overhang
               dxpDBCS += (pfce->fmi.dxpOverhang - dxpOverhang);
#endif //TAIWAN

                pfce->fmi.dxpDBCS =
#if defined(JAPAN) || defined(KOREA) || defined(PRC)       //Win3.1 BYTE-->WORD
                pfce->fmi.dxpDBCS =
                    (WORD) ((0 <= dxpDBCS && dxpDBCS < dxpNil) ? dxpDBCS : dxpNil);
#elif TAIWAN        //Win3.1 BYTE-->WORD
                pfce->fmi.dxpDBCS =
                    (WORD) ((0 <= dxpDBCS && dxpDBCS < dxpNil) ? dxpDBCS : dxpNil);
#else
                pfce->fmi.dxpDBCS =
                    (BYTE) ((0 <= dxpDBCS && dxpDBCS < dxpNil) ? dxpDBCS : dxpNil);
#endif
                }
#endif

#ifdef SMFONT
                FillWidthTable(hDCMetrics, pfce->rgdxp, &tm);
#ifdef DEBUG
                if (DogoneTrashTest(hDCMetrics, pfce, fPrint))
                    OutputDebugString("That was an immediate check\n\r");
#endif

#else /* not SMFONT */
                /* Fill the width table.  If this is a fixed font and the width
                fits in a byte, then go ahead and fill the width table with the
                width; otherwise, put dxpNil in the table. */
                dxpch = (tm.tmPitchAndFamily & 1 || tm.tmAveCharWidth >= dxpNil)
                  ? dxpNil : tm.tmAveCharWidth;
                bltc(pfce->rgdxp, dxpch, chFmiMax - chFmiMin);
#endif /* SMFONT */

                if ((*hffnSave)->ffid == FF_DONTCARE && (tm.tmPitchAndFamily &
                  grpbitFamily) != FF_DONTCARE)
                    {
                    /* Hey! maybe we've discovered a family for this orphan
                    font? */
                    GetTextFace(hDCMetrics, LF_FACESIZE, (LPSTR)szFace);
                    if (WCompSz((*hffnSave)->szFfn, szFace) == 0)
                        {
                        /* name matches - jam family in */
                        (*hffnSave)->ffid = tm.tmPitchAndFamily & grpbitFamily;
                        }
                    }

                /* jam back the properties we found */
                dypHeight = tm.tmHeight - tm.tmInternalLeading;
                if (fPrint)
                    {
                    /* Save the height of this font. */
                    pfcidT->strFcid.hps = umin((MultDiv(dypHeight, dyaPrPage,
                      dypPrPage) + (czaPoint / 4)) / (czaPoint / 2), 0xff);

#ifdef APLLW
                    /* Save the width of this font if it is a fixed pitch
                       device font. */
                    wFcid = ((tm.tmPitchAndFamily & 0x09) == 0x08) ?
#else
                    /* Save the width of this font if it is a device font. */
#ifdef  KOREA   /* give width info for all (like excel) to select DuBae shape */
            wFcid = (1==1) ?
#else
                    wFcid = (tm.tmPitchAndFamily & 0x08) ?
#endif

#endif /* if-else-def APLLW */
                      umin((MultDiv(tm.tmAveCharWidth, dxaPrPage, dxpPrPage) +
                      (czaPoint / 2)) / czaPoint, psWidthMax) : 0;
                    wFcid |= bitPrintFcid;
                    }
                else
                    {
                    pfcidT->strFcid.hps = umin((MultDiv(dypHeight, czaInch,
                      dypLogInch) + (czaPoint / 4)) / (czaPoint / 2), 0xff);
                    wFcid = 0;
                    }

                if (tm.tmWeight > (FW_NORMAL + FW_BOLD) / 2)
                    {
                    wFcid |= bitBoldFcid;
                    }

                if (tm.tmItalic)
                    {
                    wFcid |= bitItalicFcid;
                    }

                if (tm.tmUnderlined)
                    {
                    wFcid |= bitUlineFcid;
                    }

                if ((tm.tmPitchAndFamily & bitPitch) == 0)
                    {
                    wFcid |= bitFixedPitchFcid;
                    }

                pfcidT->strFcid.wFcid = wFcid;
                }

            /* Set the document and the font code. */
            pfcidT->strFcid.doc = pfce->fcidRequest.strFcid.doc;
            if (fPrint)
                {
                CHAR rgb[ibFfnMax];
                struct FFN *pffn = (struct FFN *)&rgb[0];

                /* Get the font code for this font. */
                GetTextFace(vhDCPrinter, LF_FACESIZE, (LPSTR)pffn->szFfn);
                if (WCompSz(pffn->szFfn, (*pfce->hffn)->szFfn) == 0)
                    {
                    /* The face name is the same as what we requested; so, the
                    font code should be the same. */
                    pfcidT->strFcid.ftc = pfce->fcidRequest.strFcid.ftc;
                    }
                else
                    {
                    /* Well, we've got to go hunting for the font code. */
                    int ftc;

                    pffn->ffid = tm.tmPitchAndFamily & grpbitFamily;
#ifdef NEWFONTENUM
                    pffn->chs = tm.tmCharSet;
#endif
                    ftc = FtcScanDocFfn(pfcidT->strFcid.doc, pffn);
                    if (ftc == ftcNil)
                        {
                        /* Make the first character of the face name a sentinal
                        to mark that this font was not requested by the user. */
                        bltszLimit(pffn->szFfn, &pffn->szFfn[1], LF_FACESIZE);
                        pffn->szFfn[0] = chGhost;
                        ftc = FtcChkDocFfn(pfcidT->strFcid.doc, pffn);
                        }
                    pfcidT->strFcid.ftc = ftc;
                    }
                }
            else
                {
                pfcidT->strFcid.ftc = pfce->fcidRequest.strFcid.ftc;
                }
            }

        if (fPrint)
            {
            vpfcePrint = pfce;
            vfcidPrint = pfce->fcidRequest;
            bltbyte(&pfce->fmi, &vfmiPrint, sizeof(struct FMI));
            }
        else
            {
            vpfceScreen = pfce;
            vfcidScreen = pfce->fcidRequest;
            bltbyte(&pfce->fmi, &vfmiScreen, sizeof(struct FMI));
            }
        }

    if (pfce->fcidRequest.lFcid != pfce->fcidActual.lFcid)
        {
        /* all's not as we asked for - feed properties back to caller */
        pfcid->lFcid = pfce->fcidActual.lFcid;
        if (pchp != NULL)
            { /* JamChpFcid(pchp, pfcid) bring in line for speed */
            register struct CHP *pchpT = pchp;
            int wFcid = pfcid->strFcid.wFcid;

            pchpT->ftc = pfcid->strFcid.ftc;
            pchpT->hps = pfcid->strFcid.hps;
            pchpT->psWidth = wFcid & grpbitPsWidthFcid;

            pchpT->fBold = pchpT->fItalic = pchpT->fUline = pchpT->fFixedPitch =
              FALSE;

            if (wFcid & bitBoldFcid)
                {
                pchpT->fBold = TRUE;
                }
            if (wFcid & bitItalicFcid)
                {
                pchpT->fItalic = TRUE;
                }
            if (wFcid & bitUlineFcid)
                {
                pchpT->fUline = TRUE;
                }
            if (wFcid & bitFixedPitchFcid)
                {
                pchpT->fFixedPitch = TRUE;
                }
            }
        }
    }


void NEAR SelectWriteFont(fPrint, phfont)
int fPrint;
HFONT *phfont;
    {
    extern HWND hParentWw;
    extern int wwMac;
    extern struct WWD rgwwd[];

    if (fPrint)
        {

#ifdef DFONT
        CommSzNum("Selecting printer font: ", *phfont);
#endif /* DFONT */

        /* The printer DC should be valid. */
        if (vhDCPrinter == NULL)
            {
/* This case can occur from ResetFont when closing */
            return;
            }
        else
            {
            /* Establish the font with the printer DC. */
            if (SelectObject(vhDCPrinter, *phfont) == NULL)
                {
                if (SelectObject(vhDCPrinter, GetStockObject(vfPrinterValid ?
                        DEVICE_DEFAULT_FONT : SYSTEM_FONT)) == NULL)
                    {
                    if (vfPrinterValid)
                        {
                        /* This is a real printer DC; delete it. */
                        DeleteDC(vhDCPrinter);
                        }
                    else
                        {
                        /* This is really the screen DC; it must be released. */
                        ReleaseDC(hParentWw, vhDCPrinter);
                        }
                    vhDCPrinter = NULL;
                    }
                WinFailure();
                if (vhDCPrinter == NULL)
                    {
                    GetPrinterDC(FALSE);
                    }
                return;
                }
            }
        }
    else
        {
        /* Establish it with screen and memory DC's. */
        register int ww;
        register struct WWD *pwwd;

#ifdef DFONT
        CommSzNum("Selecting screen font: ", *phfont);
#endif /* DFONT */

        /* The current memory DC had best be active. */
        if (vhMDC == NULL)
            {
/* this case occurs from ResetFont when Write is closed */
            return;
            }
        else
            {
            /* Select the font into the memory DC. */
            if (SelectObject(vhMDC, *phfont) == NULL)
                {

                Assert(*phfont != GetStockObject(SYSTEM_FONT));
                *phfont = GetStockObject(SYSTEM_FONT);
                Assert( *phfont );
#ifdef DEBUG
                Assert( SelectObject( vhMDC, *phfont ) );
#else /* not DEBUG */
                SelectObject(vhMDC, *phfont );
#endif /* not DEBUG */

                WinFailure();
                }
            }

        /* Select the font into all of the window DC's. */
        for (ww = 0, pwwd = &rgwwd[0]; ww < wwMac; ww++, pwwd++)
            {
            if (pwwd->hDC != NULL)
                {
                if (SelectObject(pwwd->hDC, *phfont) == NULL)
                    {
                    HFONT hSysFont = GetStockObject(SYSTEM_FONT);
                    int wwT;
                    struct WWD *pwwdT;

#ifdef DEBUG
                    Assert(*phfont != hSysFont);
                    Assert(SelectObject(vhMDC, hSysFont) != NULL);
#else /* not DEBUG */
                    SelectObject(vhMDC, hSysFont);
#endif /* not DEBUG */
                    *phfont = hSysFont;

                    for (wwT = 0, pwwdT = &rgwwd[0]; wwT <= ww; wwT++, pwwdT++)
                        {
                        if (pwwdT->hDC != NULL)
                            {

#ifdef DEBUG
                            Assert(SelectObject(pwwdT->hDC, hSysFont) != NULL);
#else /* not DEBUG */
                            SelectObject(pwwdT->hDC, hSysFont);
#endif /* not DEBUG */

                            }
                        }

                    WinFailure();
                    }
                }
            }
        }
    }


ResetFont(fPrint)
BOOL fPrint;
    {
    /* This routine sets to NULL the currently selected printer or screen font,
    depending on the value of fPrint. */

    extern HFONT vhfSystem;
    HFONT hfont;

#ifdef DFONT
    CommSzSz("Resetting the ", (fPrint ? "printer font." : "screen font."));
#endif /* DEBUG */

#ifdef JAPAN   /* T-YOSHIO win 3.1 */
    hfont = GetStockObject(fPrint && vfPrinterValid ?
                                         DEVICE_DEFAULT_FONT : ANSI_VAR_FONT);
#else
    hfont = GetStockObject(fPrint && vfPrinterValid ?
                                         DEVICE_DEFAULT_FONT : SYSTEM_FONT);
#endif

    SelectWriteFont( fPrint, &hfont );
    if (fPrint)
        {
        vpfcePrint = NULL;
        vfcidPrint.lFcid = fcidNil;
        }
    else
        {
        vpfceScreen = NULL;
        vfcidScreen.lFcid = fcidNil;
        }
    }




BOOL OurGetCharWidth(hdc, chFirst, chLast, lpw)
HDC hdc;
CHAR chFirst, chLast;
LPINT lpw;
    {
    int i;
    BYTE b;

    for (i = chFirst; i <= chLast; i++)
        {
/*T-HIROYN  from 3.0 loadfont.c */
#ifdef  DBCS    /* KenjiK '90-11-26 */
    if(IsDBCSLeadByte(i))
       {
        *(lpw++) = dxpNil;
       }
    else
       {
            b = i;
            *(lpw++) = LOWORD(GetTextExtent(hdc, (LPSTR)&b, 1));
       }
        }
#else
        b = i;
        *(lpw++) = LOWORD(GetTextExtent(hdc, (LPSTR)&b, 1));
        }
#endif


    return(fTrue);
    }

#ifdef SMFONT
/* Note: we put widths in here that represent true char widths,
   not considering bold/italics Overhang.  This is because of the
   following formula for string widths:

   strwidth = overhang +
              summation [ (gettextextent_or_getcharwidth - overhang) ]

   ..pault 9/22/89 */

void NEAR FillWidthTable(hdc, rgdxp, ptm)
HDC hdc;
int rgdxp[];
TEXTMETRIC *ptm;
    {
    int rgWidth[chFmiMax - chFmiMin];
    if ((ptm->tmPitchAndFamily & 1) == 0)
        {
#ifdef PRDRVTEST
        CommSzNum("  * Fixed pitch font! tmAveCharWidth==",ptm->tmMaxCharWidth);
#endif
#if defined(DBCS) && !defined(KOREA)                /* was in JAPAN */
        bltc(rgdxp, (WORD)dxpNil, chFmiMax - chFmiMin);
#else
        bltc(rgdxp, (WORD)ptm->tmAveCharWidth, chFmiMax - chFmiMin);
#endif
        }

    /* Attempt to get the width table from the DC. */
    else
    {
        int *pdxpMax = &rgdxp[chFmiMax - chFmiMin];
        register int *pWidth;
        register int *pdxp;
        int dxpOverhang = ptm->tmOverhang;

#ifdef  DBCS    /* was in JAPAN; KenjiK '90-11-26 */
//92.10.26 T-HIROYN
//Win3.1J    if(OurGetCharWidth(hdc, chFmiMin, chFmiMax - 1, (LPINT)rgWidth))
        if( (GetDeviceCaps(hdc, DRIVERVERSION) > 0x300) ?
             GetCharWidth(hdc, chFmiMin, chFmiMax - 1, (LPINT)rgWidth) :
             OurGetCharWidth(hdc, chFmiMin, chFmiMax - 1, (LPINT)rgWidth) )
#else
        if (GetCharWidth(hdc, chFmiMin, chFmiMax - 1, (LPINT)rgWidth))
#endif

        {
#if defined(JAPAN) || defined(KOREA)        //  added by Hiraisi (BUG#2690)
            int ch = chFmiMin;
#endif

#ifdef PRDRVTEST
            CommSz("  * GetCharWidth() supported\n\r");
#endif

            /* Remove the overhang factor from individual char widths
            (see formula for widths of character strings above) */
            for (pWidth = &rgWidth[0], pdxp = &rgdxp[0];
                    pdxp != pdxpMax; pWidth++, pdxp++)
                {
#ifdef  DBCS        /* was in JAPAN */
#if defined(JAPAN) || defined(KOREA)        //  added by Hiraisi (BUG#2690)
                if(!IsDBCSLeadByte(ch++))
                {
#endif
                   if(*pWidth == dxpNil)
/*T-HIROYN            *pdxp = (CHAR)dxpNil;*/
                      *pdxp = dxpNil;
                   else
                      *pdxp = (*pWidth - dxpOverhang);
#if defined(JAPAN) || defined(KOREA)        //  added by Hiraisi (BUG#2690)
                }
                else
                   *pdxp = dxpNil;
#endif
#else
                *pdxp = (*pWidth - dxpOverhang);
#endif
                }
        }
        else
        {
            /* There is no easy way, put dxpNil in the table.  It looks like each
            char has a bogus width but FormatLine will make individual calls to
            GetTextExtent() and replace the dxpNil on an as-needed basis ..pault */

#ifdef PRDRVTEST
            CommSz("  * GetCharWidth() not supported!\n\r");
#endif
            bltc(rgdxp, (WORD)dxpNil, chFmiMax - chFmiMin);
        }
    }

#ifdef PRDRVTEST
/* Take a quick look through to see if this printer is returning any
   char widths that seem odd -- report those!  This should
   end my searching for WRITE problems which are really caused by bad
   printer-driver return values! */
    {
    BOOL fReported = fFalse;
    int rgch[cchMaxSz];
    int i,w;
    BYTE b;
    for (i = chFmiMin; i < chFmiMax; i++)
        {
        b = i;
        w = LOWORD(GetTextExtent(hdc, (LPSTR)&b, 1));
        if (w < 1)
            {
            wsprintf(rgch,"    GetTextExtent(ascii %d) return value %d is invalid\n\r",b,(int)w);
            CommSz(rgch);
            if (!fReported)
                {
                CommSz("");
                fReported = fTrue;
                }
            }
        else if (w > (ptm->tmMaxCharWidth + ptm->tmOverhang))
            {
            wsprintf(rgch,"    GetTextExtent(ascii %d) return value %d exceeds tmMaxCharWidth %d\n\r",
                    b,(int)w,(int)(ptm->tmMaxCharWidth + ptm->tmOverhang));
            CommSz(rgch);
            if (!fReported)
                {
                CommSz("");
                fReported = fTrue;
                }
            }
        else if ((rgdxp[i] != dxpNil) && (rgdxp[i] > (ptm->tmMaxCharWidth + ptm->tmOverhang)))
            {
            wsprintf(rgch,"    GetCharWidth(ascii %d) return value %d questionable, exceeds tmMaxCW %d\n\r",
                    b, (int)(rgdxp[i]), (int)(ptm->tmMaxCharWidth + ptm->tmOverhang));
            CommSz(rgch);
            if (!fReported)
                {
                CommSz("");
                fReported = fTrue;
                }
            }
        }
    }
#endif /* PRDRVTEST */

    }
#endif /* SMFONT */

#ifdef DEBUG
BOOL NEAR DogoneTrashTest(HDC hdc, struct FCE *pfce, BOOL fPrint)
{
#if 1
    int i,width;
    int *pdxpMax = pfce->rgdxp + chFmiMax - chFmiMin;
    int dxpOverhang = pfce->fmi.dxpOverhang;
    register int *rgdxp;
    int rgdxpNew[chFmiMax - chFmiMin];
    register int *dxpNew;

    return 0;
    for (i=chFmiMin,
         rgdxp = pfce->rgdxp;
         i < chFmiMax; rgdxp++, ++i)
    {
        width = LOWORD(GetTextExtent(hdc,&i,1));
        if (*rgdxp != (width - dxpOverhang))
        {
#ifdef DEBUG
            {
            char msg[120];
            wsprintf(msg,"widths have changed!  Getting new width. (%s)\n\r",
                (LPSTR)(fPrint ? "PrinterDc" : "ScreenDC"));
            OutputDebugString(msg);
            }
#endif
            GetCharWidth(hdc, chFmiMin, chFmiMax - 1, (LPINT)rgdxpNew);
            for (dxpNew = rgdxpNew,
                    rgdxp = pfce->rgdxp;
                    rgdxp != pdxpMax; dxpNew++, rgdxp++)
                    *rgdxp = (*dxpNew - dxpOverhang);
            return TRUE;
        }
    }
#else
    int rgdxpNew[chFmiMax - chFmiMin];
    int *pdxpMax = pfce->rgdxp + chFmiMax - chFmiMin;
    int dxpOverhang = pfce->fmi.dxpOverhang;
    register int *dxpNew;
    register int *rgdxp;
    if (GetCharWidth(hdc, chFmiMin, chFmiMax - 1, (LPINT)rgdxpNew))
    {
        /* Remove the overhang factor from individual char widths
        (see formula for widths of character strings above) */
        for (dxpNew = rgdxpNew,
             rgdxp = pfce->rgdxp;
             rgdxp != pdxpMax; dxpNew++, rgdxp++)
        {
            if (*rgdxp != (*dxpNew - dxpOverhang))
            {
#ifdef DEBUG
                {
                char msg[120];
                wsprintf(msg,"widths have changed!  Getting new width. (%s)\n\r",
                    (LPSTR)(fPrint ? "PrinterDc" : "ScreenDC"));
                OutputDebugString(msg);
                }
#endif
                for (dxpNew = rgdxpNew,
                     rgdxp = pfce->rgdxp;
                     rgdxp != pdxpMax; dxpNew++, rgdxp++)
                        *rgdxp = (*dxpNew - dxpOverhang);
                return TRUE;
            }
        }
    }
#endif
return FALSE;
}
#endif

#ifdef JAPAN                  //  added  11 Jun. 1992  by Hiraisi

int FAR PASCAL _export fnFontHook( lf, tm, nType, lpData )
LPLOGFONT lf;
LPTEXTMETRIC tm;
short nType;
LPSTR lpData;
{
    if( lf->lfFaceName[0] == '@' &&
        lf->lfEscapement == 0 ){        /* @facename is found */
        return( FALSE );
    }

    return( TRUE );
}

void fnCheckWriting( LPLOGFONT lf )
{
    extern HANDLE hMmwModInstance;
    FARPROC lpfnFontHook;
    char cFaceName[LF_FACESIZE+1] = "@";

    lstrcat( (LPSTR)cFaceName, lf->lfFaceName );
    lpfnFontHook = MakeProcInstance(fnFontHook, hMmwModInstance);
    if( !EnumFonts( vhDCPrinter, cFaceName, lpfnFontHook, NULL ) )
        lstrcpy( (LPSTR)lf->lfFaceName, (LPSTR)cFaceName );
    FreeProcInstance( lpfnFontHook );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\machdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define MACHA
       /* definition of macha moved here by bz instead of on command
          like to compiler to allow other command line args */

/* cbSector -- Number of bytes in sector */
/* p2bSector -- Power of two of bytes in sector (iff cbSector==2^n) */
/* cbPad -- Difference between real sector size and our sector size. (Used
            only if the real sector size is odd) */
/* cbWorkspace -- Number of bytes needed by interpreter for file overhead */


#ifdef SAND
#define cbSector        128
#define p2bSector       7
#define cbPad           0
#define cbWorkspace     0
#define rfnMax          5
#define pnMaxScratch    (1 << (16 - p2bSector))

#else

#ifdef MACHA            /* IBM PC, PC-XT, OR PC-AT */
#define cbSector        128
#define p2bSector       7
#define cbPad           0
#define cbWorkspace     1

#define rfnMacEdit      9        /* # of rfn's to use during editing */
#define rfnMacSave      10       /* # of rfn's to use during saving */
#define rfnMax          10       /* Allocated # of rfn slots */

#define pnMaxScratch    (1 << (16 - p2bSector))


/* -------------------------------------------------------------------- */
/* Added conditional compilation for long filename support under OS/2   */
/* t-carlh - August, 1990                                               */
/* -------------------------------------------------------------------- */
#ifdef OS2
#define cchMaxLeaf      260     /* Largest filename (w/ ext, w/o drv,path) */
#define cchMaxFile      260     /* Largest filename (w/ ext, drv, path) */
#else   /* OS2 */
#define cchMaxLeaf      13      /* Largest filename (w/ ext, w/o drv,path) */
#define cchMaxFile      128     /* Largest filename (w/ ext, drv, path) */
#endif  /* OS2 */

#endif

#ifdef MACHB
#define cbSector        252
#define cbPad           1
#define cbWorkspace     (64+253)
#endif

#ifdef MACHC
#define cbSector        512
#define p2bSector       9
#define cbPad           0
#define cbWorkspace     20
#endif

#ifdef MACHD
#define cbSector        256
#define p2bSector       8
#define cbPad           0
#define cbWorkspace     (31+256)
#endif

#ifdef MACHE
#define cbSector        512
#define p2bSector       9
#define cbPad           0
#define cbWorkspace     0
#define rfnMax          2
#endif

#ifdef MACHF
#define cbSector        512
#define p2bSector       9
#define cbPad           0
#define cbWorkspace     38
#endif
#endif /* SAND */


#define EOF     (-1)

#ifdef SAND
#define mdRandom        0
#define mdRanRO         0100000 /* Read only random file */
#define mdBinary        1
#define mdBinRO         0100001 /* Read only binary save file */
#define mdText          2
#define mdTxtRO         0100002 /* Read only text file */
#define mdPrint         3
#endif

#ifdef MACHA
#define mdRandom        0x0002
#define mdBinary        mdRandom
#define mdText          mdRandom
#define mdRanRO         0x0000
#define mdBinRO         mdRanRO
#define mdTxtRO         mdRanRO

#define mdExtMax        5       /* # chars in an extension, including the . */

#endif

extern int ibpMax;
extern int iibpHashMax;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\mergedef.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#ifdef SAND
#define ihszMax			127     /* max fields */
#else /* not SAND */
#define ihszMax			255     /* max fields */
#endif /* not SAND */

#define cchMaxMName		128     /* max field name length */
#define levNil			(-1)
#define cIncludesMax		64     /* max number of nested include files */
#define typeNumMaxOver10	(214748364L)

typedef long typeNum;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\menudefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/*
This file contains the definitions of the numerical indexes to the menu
items (imi) used by Windows WRITE.
Each imi should be unique and be continuous within the same
menu. The middle 2 bytes of imi are masked against MENUMASK to
provide the submenu index.
IF any of the menu item order has changed, menu.c has
to be modified also -- rgmfAllItem, rgmfScrap, SetMenuFlags etc.
*/

/* number of pulldown submenus */
#define CMENUS 7

/* menu index */
#define FILE 0
#define EDIT 1
#define FIND 2
#define CHARACTER 3
#define PARA 4
#define DIV 5
#define HELP 6

#define MENUMASK           0x0ff0
#define FILEMENU           0x0000
#define EDITMENU           0x0010
#define FINDMENU           0x0020
#define CHARMENU           0x0040
#define PARAMENU           0x0080
#define DOCUMENU           0x0100
#define HELPMENU        0x0200
#define VERBMENU        0x0400

#define fMenuItem                       0x1000

#define imiNil                          0x1fff
#define imiHelp                         0xf2f0

/* Menu items */
/* #define imiAbout                     0x1000 */
#define imiNew                          0x1001
#define imiOpen                         0x1002
#define imiSave                         0x1003
#define imiSaveAs               0x1004
#define imiPrint                        0x1005
#define imiPrintSetup           0x1006
#define imiRepaginate           0x1007
#define imiQuit                         0x1008
#define imiFileMin                      (imiNew)
#define imiFileMax                      (imiQuit + 1)

#define imiUndo                         0x1010
#define imiCut                          0x1011
#define imiCopy                         0x1012
#define imiPaste                        0x1013
#define imiMovePicture                  0x1014
#define imiSizePicture                  0x1015
#if defined(OLE)
#if !defined(SMALL_OLE_UI)
#define imiPasteLink                    0x1016
#define imiProperties                   0x1017
#endif
#define imiInsertNew                    0x1018
#define imiPasteSpecial         0x1019
#endif
#define imiEditMin         (imiUndo)
/* note imiEditMax intentionally doesn't include OLE menu items. (1.25.91) D. Kent */
#define imiEditMax         (imiSizePicture + 1)

#if defined(OLE)
/* verbs */
#define imiVerb                 0x1400
#define imiVerbEdit             0x1401
#define imiVerbPlay             0x1402
#define imiVerbMax              0x14FF
#endif


#define imiFind                         0x1020
#define imiFindAgain       0x1021
#define imiChange                       0x1022
#define imiGoTo                          0x1023
#define imiFindMin         (imiFind)
#define imiFindMax         (imiGoTo + 1)

#if defined(OLE)
/* these aren't really menu items, but we'll associate them with
   WM_COMMAND messages like cardfile does. 01/24/91 -- dougk */
#define imiActivate     1030
#define imiUpdate       1031
#define imiFreeze       1032
#define imiClone        1033
#define imiCopyfromlink 1034
#endif

#define imiCharNormal      0x1040
#define imiBold                                 0x1041
#define imiItalic                       0x1042
#define imiUnderline                    0x1043
#define imiSuper                        0x1044
#define imiSub                          0x1045
#if 0
#define imiFont1           0x1046
#define imiFont2           0x1047
#define imiFont3           0x1048
#endif
#define imiSmFont          0x1046
#define imiLgFont          0x1047
#define imiCharFormats          0x1048

#if defined(JAPAN) & defined(IME_HIDDEN)  //IME3.1J
#define imiImeHidden       0x1049
#endif

#define imiCharMin         (imiCharNormal)

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
#define imiCharMax         (imiImeHidden + 1)
#else
#define imiCharMax         (imiCharFormats + 1)
#endif

/* special accelerator key
#define imiAccelBold       0x104c
#define imiAccelItalic     0x104d
#define imiAccelUnderline  0x104e*/

#define imiParaNormal                   0x1080
#define imiLeft                         0x1081
#define imiCenter                       0x1082
#define imiRight                        0x1083
#define imiJustified                    0x1084
#define imiSingleSpace                  0x1085
#define imiOneandhalfSpace              0x1086
#define imiDoubleSpace                  0x1087
#define imiParaFormats                  0x1088
#define imiParaMin                      (imiParaNormal)
#define imiParaMax                      (imiParaFormats + 1)

#define imiHeader                0x1100
#define imiFooter               0x1101
#define imiShowRuler                 0x1102
#define imiTabs                 0x1103
#define imiDivFormats           0x1104
#define imiDocuMin         (imiHeader)
#define imiDocuMax         (imiDivFormats + 1)

#define imiIndex                 0x1200
#define imiHelpSearch            0x1201
#define imiUsingHelp             0x1202
#define imiAbout                 0x1203
#define imiHelpMin               (imiIndex)
#define imiHelpMax               (imiAbout + 1)

#ifdef CASHMERE
#define imiFootnote
#define imiPreferences
#endif

#ifdef ENABLE /* CFILE, CEDIT ... */
/* number of items in each submenu */
#define CFILE  (imiFileMax - imiFileMin)
#define CEDIT  (imiEditMax - imiEditMin)
#define CFIND  (imiFindMax - imiFindMin)
#define CCHAR  (imiCharMax - imiCharMin)
#define CPARA  (imiParaMax - imiParaMin)
#define CDOCU  (imiDocuMax - imiDocuMin)
#define CHELP  (imiHelpMax - imiHelpMin)
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\mglobals.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* WRITE Globals */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOMINMAX
#define NOOPENFILE
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#define NOUAC
#include "cmddefs.h"
#include "dispdefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "fmtdefs.h"  /* formatdefs.h */
#include "propdefs.h"
#include "fkpdefs.h"
#include "printdef.h"   /* printdefs.h */
#include "wwdefs.h"
#include "prmdefs.h"
#include "rulerdef.h"
#include "editdefs.h"
#define NOSTRERRORS
#include "str.h"
#include "fontdefs.h"
#include "globdefs.h"   /* text for static strings */

VAL rgval [ivalMax];            /* General purpose parm-passing array */
#ifdef ENABLE
VAL rgvalAgain[ivalMax];
#endif

CHAR         vchDecimal = '?';  /* "decimal point" character
                    real value set in initwin.c */

int      vzaTabDflt = vzaTabDfltDef; /* width of default tab in twips */

/* pen windows */
VOID (FAR PASCAL *lpfnRegisterPenApp)(WORD, BOOL) = NULL;

/* page buffers stuff */
CHAR        *rgibpHash;
int     iibpHashMax;
struct BPS  *mpibpbps;
int     ibpMax;
int     ibpMaxFloat = 128;
typeTS      tsMruBps;
CHAR        (*rgbp)[cbSector];
struct ERFN dnrfn[rfnMax];
int     rfnMac;
typeTS      tsMruRfn;
int     vfBuffersDirty = FALSE;

/* doc stuff */
struct DOD  (**hpdocdod)[];
int     docCur;         /* current doc */
int     docMac;
int     docScrap;
#ifdef CASHMERE     /* No docBuffer in WRITE */
int     docBuffer;
#endif
int     docUndo;

#if defined(JAPAN) & defined(DBCS_IME) /* Doc for Insert IR_STRING from IME [yutakan]*/
int     docIRString;
#endif

int     docRulerSprm;
int     docMode = docNil;   /* doc with "Page nnn" message */
int     vpgn;           /* current page number of document */
typeCP      cpMinCur;
typeCP      cpMacCur;

/* file stuff */
struct FCB  (**hpfnfcb)[];
int     fnMac;
int     ferror;
int     errIO;          /* i/o error code */
int     versFile = 0;
int     vrefFile = 0;
int     vrefSystem = 0;

#ifdef  DBCS_VERT
CHAR        szAtSystem [] = szAtSystemDef; // for vertical-sysfont
#endif

WORD        vwDosVersion; /* Current DOS version, maj in lo 8, minor in hi */
int     vfInitializing = TRUE;  /* TRUE during inz, FALSE thereafter */
int     vfDiskFull = FALSE; /* Disk full error, fn != fnScratch */
int     vfSysFull = FALSE;  /* Disk holding fnScratch is full */
int     vfDiskError = FALSE;    /* Serious Disk Error has occurred */
int     vfLargeSys = FALSE;
int     vfMemMsgReported = FALSE;
int     vfCloseFilesInDialog = FALSE;   /* Set inside OPEN, SAVE dialog */
int     vfSizeMode;
int     vfPictSel;
int     vfPMS = FALSE;      /* Currently doing picture move/size */
int     vfnWriting = fnNil; /* fn that gets written to disk */
int     vfnSaving = fnNil;  /* Like above, but longer lifetime */
int     vibpWriting;
CHAR        (**vhrgbSave)[];    /* emergency space for save events */
struct FPRM fprmCache;      /* scratch file property modifiers */

/* global boolean flags */
int  vfTextOnlySave = FALSE; /* reset by each new/open, use by save as */
int  vfBackupSave; /* use by save as box */

#if defined(JAPAN) || defined(KOREA)
int  vfWordWrap;   /*t-Yoshio WordWrap flag*/
#elif defined(TAIWAN) || defined(PRC) //Daniel/MSTC, 1993/02/25
int  vfWordWrap= 1; // always set it on
#endif

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
int  vfImeHidden;   /*T-HIROYN ImeHidden Mode flag*/
#endif

int  vfOutOfMemory = FALSE;
int  vfOvertype = FALSE; /* still using this ? */
int  vfPrintMode = FALSE; /* TRUE if format to printer mode on screen */
int  vfDraftMode = FALSE; /* TRUE if the user choose the draft mode option */
int  vfRepageConfirm = FALSE; /* repaginate confirm page break option */
int  vfVisiMode = FALSE; /* TRUE if visible char mode on */
int  vfModeIsFootnote; /* TRUE when szMode contains string "Footnote" */
int  vfNoIdle = FALSE;
int  vfDeactByOtherApp = FALSE; /* TRUE if we are deactivated by another app */
int  vfDownClick = FALSE; /* TRUE when we received a down click in our window */
int  vfCursorVisible = FALSE; /* TRUE if want to show the cursor in a mouseless
                 system */
int  vfMouseExist = FALSE; /* TRUE if mouse hardware is installed */
int  vfInLongOperation = FALSE; /* TRUE if we are still in a long operation
                   so that the cursor should stay hourglass */
int  vfScrapIsPic = FALSE; /* Whether docScrap contains picture */
BOOL fDestroyOK;

int  fGrayChar; /* TRUE if selection consists of mixed char properties */
int  fGrayPara; /* TRUE if selection consists of mixed para properties */

int  vfPrPages = FALSE; /* TRUE if print page range */
int  vpgnBegin; /* starting page number to print */
int  vpgnEnd; /* ending page number to print */
int  vcCopies = 1;       /* nubmer of copies to print */
BOOL vfPrErr = FALSE;        /* TRUE iff a printing error occurred */
BOOL vfPrDefault = TRUE;     /* TRUE iff Write chose printer */
BOOL vfWarnMargins = FALSE;  /* TRUE if we should warn user about bad margins */

/* Show that Print, Help, and Glossary processing is uninitialized */
int  vfPrintIsInit = FALSE;
int  vfHelpIsInit = FALSE;
int  vfGlyIsInit = FALSE;

int  vfInsEnd = false;   /* Is insert point at end-of-line? */
int  vfInsertOn;
int  vfMakeInsEnd;
int  vfSelAtPara;
int  vfSeeSel = FALSE;
int  vfLastCursor;       /* TRUE iff the last selection was made
                       by an Up/Down cursor key */
int  vfGotoKeyMode = FALSE;  /* Apply GOTO meta mode to next cursor
                       key */
#ifdef SAND
int  vftcDaisyPS = -1;
int  vftcDaisyNoPS = -1;
int  vfDaisyWheel = FALSE;
int  vifntApplication;
int  vifntMac;
#endif /* SAND */

#ifdef UNUSED
int  vfCanPrint;
#endif

int  vchInch;
int  vfMouse;
typeCP      vcpSelect;

#ifdef DEBUG
int  fIbpCheck = TRUE;
int  fPctbCheck = TRUE;
#ifdef CKSM
unsigned (**hpibpcksm) [];   /* Checksums for buffer page contents */
unsigned ibpCksmMax;         /* Alloc limit for cksm array */
#endif
#endif /* DEBUG */

int  vWordFmtMode = FALSE; /* used during saves. If false, no conversion is
                  done. True is convert to Word format,CVTFROMWORD
                  is translate chars from Word character set at
                  save */

/* **************************************************************** */
/* strings, predefined file names - definitions stored in globdefs.h */
/*                                                                   */
/* NOTE NOTE NOTE   Win 3.0                                          */
/*                                                                   */
/* Some of these strings have now been moved from globdefs.h         */
/* to write.rc.  This was done to easy localization.                 */
/*                                                                   */
/* **************************************************************** */

CHAR        (**hszTemp)[];
CHAR        (**hszGlosFile)[];
CHAR        (**hszXfOptions)[];
CHAR            szMode[30];              /* buffer for "Page nnn" message */

CHAR        szEmpty[] = "";
CHAR        szExtDoc[] = szExtDocDef;
CHAR        szExtWordDoc[] = szExtWordDocDef;
CHAR        szExtGls[] = szExtGlsDef;
CHAR        szExtDrv[] = szExtDrvDef;
           /* for Intl added szExtWordDoc entry */
CHAR        *mpdtyszExt [] = { szExtDoc, szExtGls, szEmpty, szEmpty,
             szEmpty, szEmpty,
             szExtWordDoc };
CHAR        szExtBackup[] = szExtBackupDef;
CHAR        szExtWordBak[] = szExtWordBakDef;
               /* WIN.INI: our app entry */
CHAR        szWriteProduct[] = szWriteProductDef;
CHAR        szFontEntry[] = szFontEntryDef;    /* WIN.INI: our font list */
CHAR            szWriteDocPrompt[25];                     /* OpenFile prompts */
CHAR            szScratchFilePrompt[25];
CHAR            szSaveFilePrompt[25];
#if defined(KOREA)  // jinwoo : 10/16/92
CHAR            szAppName[13];               /* For message box headings */
#else
CHAR            szAppName[10];               /* For message box headings */
#endif
CHAR            szUntitled[20];                  /* Unnamed doc */
CHAR        szSepName[] = szSepNameDef;  /* separator between product
                        name and file name in header */

#ifdef STYLES
CHAR        szSshtEmpty[] = szSshtEmptyDef;
#endif /* STYLES */

/* Strings for parsing the user profile. */
CHAR        szWindows[] = szWindowsDef;
CHAR        szDevice[] = szDeviceDef;
CHAR        szDevices[] = szDevicesDef;
CHAR        szBackup[] = szBackupDef;

#if defined(JAPAN) || defined(KOREA) //Win3.1J
CHAR        szWordWrap[] = szWordWrapDef;
#endif

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
CHAR        szImeHidden[] = szImeHiddenDef;
#endif

/* Strings for our window classes (MUST BE < 39 CHARS) */

CHAR        szParentClass[] = szParentClassDef;
CHAR        szDocClass[] = szDocClassDef;
CHAR        szRulerClass[] = szRulerClassDef;
CHAR        szPageInfoClass[] = szPageInfoClassDef;
#ifdef ONLINEHELP
CHAR        szHelpDocClass[] = szHelpDocClassDef;
#endif

CHAR            szWRITEText[30];
CHAR            szFree[15];
CHAR        szMWTemp [] = szMWTempDef;
CHAR        szSystem [] = szSystemDef;

CHAR         szMw_acctb[] = szMw_acctbDef;
CHAR         szNullPort[] = szNullPortDef;
CHAR         szNone[15];
CHAR         szMwlores[] = szMwloresDef;
CHAR         szMwhires[] = szMwhiresDef;
CHAR         szMw_icon[] = szMw_iconDef;
CHAR         szMw_menu[] = szMw_menuDef;
CHAR         szScrollBar[] = szScrollBarDef;
CHAR         szAltBS[20];
CHAR         szPmsCur[] = szPmsCurDef;
CHAR         szHeader[15];
CHAR         szFooter[15];

CHAR     szModern[] = szModernDef;
CHAR     szRoman[] = szRomanDef;
CHAR     szSwiss[] = szSwissDef;
CHAR     szScript[] = szScriptDef;
CHAR     szDecorative[] = szDecorativeDef;

CHAR     szExtSearch[] = szExtSearchDef; /* store default search spec */
CHAR     szLoadFile[25];
CHAR     szCvtLoadFile[45];

CHAR     szIntl[] = szIntlDef;
CHAR     szsDecimal[] = szsDecimalDef;
CHAR     szsDecimalDefault[] = szsDecimalDefaultDef;
CHAR     sziCountry[] = sziCountryDef;
CHAR     sziCountryDefault[5];

/*  table of unit names from util2.c - Must agree with cmddefs.h */
CHAR    *mputsz[utMax] =
    {
        "     ",
        "     ",
        "     ",
        "     ",
        "     ",
        "     ",
    };


/* For convenience, we reserves Mac's st concept, the difference is that
cch stored in the first byte of the array includes the '\0' so that we
can use it as a sz by chopping the 1st byte */
CHAR        stBuf[256];

CHAR        szCaptionSave[cchMaxFile]; /* save the caption text */
/* insert stuff */
CHAR        rgchInsert[cchInsBlock]; /* temporary insert buffer */
typeCP      cpInsert;       /* beginning cp of insert block */
int     ichInsert;      /* number of chars used in rgchInsert */
typeFC      fcMacPapIns = fc0;
typeFC      fcMacChpIns = fc0;
struct FKPD vfkpdCharIns;
struct FKPD vfkpdParaIns;
int     vdlIns;         /* Display line for current insert */
int     vcchBlted=0;        /* # of chars blted onto vdlIns */
int     vidxpInsertCache=-1;    /* Current position in vfli.rgdxp
                       during fast insert */
int     vfInsFontTooTall;   /* Ins chr will be too tall for line */
struct EDL  *vpedlAdjustCp;
int     vfSuperIns;     /* whether in super-fast insert mode */
typeCP      cpInsLastInval;
int     vdypCursLineIns;
int     vdypBase;
int     vdypAfter;
int     vxpIns;
int     vxpMacIns;
int     vypBaseIns;
int     vfTextBltValid;
typeCP      cpWall = cp0;
int     vfInsLast;

/* Keyboard shift/lock flags */
int     vfShiftKey = FALSE; /* whether Shift is down */
int     vfCommandKey = FALSE;   /* whether Ctrl key is down */
int     vfOptionKey = FALSE;    /* whether Alt key is down */

/* cache stuff */
CHAR        *vpchFetch;
CHAR        (**hgchExpand)[];
int     vichFetch;
int     vdocFetch;
int     vccpFetch;
int     vcchFetch;
int     visedCache;
int     vdocExpFetch;
int     vdocParaCache = docNil;
int     vdocPageCache;
int     vdocSectCache;
typeCP      vcpFetch;
typeCP      vcpFirstParaCache;
typeCP      vcpLimParaCache;
typeCP      vcpMinPageCache;
typeCP      vcpMacPageCache;
typeCP      vcpLimSectCache;
typeCP      vcpFirstSectCache;

/* cache stuff for display purpose */
int     ctrCache = 0;
int     itrFirstCache = 0;
int     itrLimCache = itrMaxCache;
int     dcpCache = 0;
typeCP      cpCacheHint = cp0;

/* The picture bitmap cache */

int     vdocBitmapCache = docNil;
typeCP      vcpBitmapCache;
HBITMAP     vhbmBitmapCache = NULL;
BOOL        vfBMBitmapCache;

/* style property stuff */
int     ichpMacFormat;
struct CHP  vchpNormal;
struct CHP  vchpAbs;
struct CHP  vchpInsert;
struct CHP  vchpFetch;
struct CHP  vchpSel;        /* Holds the props when the selection is
                       an insert point */
struct CHP  *pchpDefault;
struct CHP  (**vhgchpFormat)[];
struct PAP  vpapPrevIns;
struct PAP  vpapAbs;
struct PAP  *vppapNormal;
struct SEP  vsepNormal;
struct SEP  vsepAbs;
struct SEP  vsepStd;
struct SEP  vsepPage;

#define ESPRM(cch, sgc, spr, fSame, fClobber) \
    (cch + (ESPRM_sgcMult * sgc) + (ESPRM_spr * spr) + \
      (ESPRM_fSame * fSame) + (ESPRM_fClobber * fClobber))

/* ESPRM fields are:
    cch     2 bits of length, 0 means determined by procedure
    sgc     2 bits of group: char, para, or running head
    spr     1 bit priority, fClobber sprms clobber sprms in same group with
          priority less than or equal
    fSame   means overrides previous instance of same sprm
    fClobber    see spr
*/

#define ESPRMChar   ESPRM(2,0,0,1,0)
#define ESPRMPara   ESPRM(2,1,1,1,0)
#define ESPRMParaLong   ESPRM(3,1,1,1,0)

/* This table corresponds to sprm's in prmdefs.h */
CHAR    dnsprm[sprmMax] = {
/*  0 */ 0,         /* */
     ESPRMParaLong,     /* PLMarg */
/*  2 */ ESPRMParaLong,     /* PRMarg */
     ESPRMParaLong,     /* PFIndent */
/*  4 */ ESPRMPara,     /* PJc */
     ESPRM(1,1,1,1,0),  /* Ruler */
/*  6 */ ESPRM(0,1,1,1,0),  /* Ruler1 */
     ESPRMPara,     /* PKeep */
/*  8 */ ESPRM(2,1,1,1,1),  /* PNormal (formerly Pstyle) */
     ESPRM(2,2,0,1,0),  /* PRhc running head code */
/* 10 */ ESPRM(0,1,0,1,1),  /* PSame, clobbers all tabs but related ones */
     ESPRMParaLong,     /* PDyaLine */
/* 12 */ ESPRMParaLong,     /* PDyaBefore */
     ESPRMParaLong,     /* PDyaAfter */
/* 14 */ ESPRM(1,1,1,0,0),  /* PNest */
     ESPRM(1,1,1,0,0),  /* PUnNest */
/* 16 */ ESPRM(1,1,1,0,0),  /* PHang - hanging indent */
     ESPRM(0,1,1,1,0),  /* PRgtbd */
/* 18 */ ESPRMPara,     /* PKeepFollow */
     ESPRM(1,1,0,1,1),  /* PCAll - NUSED */
/* 20 */ ESPRMChar,     /* CBold */
     ESPRMChar,     /* CItalic */
/* 22 */ ESPRMChar,     /* CUline */
     ESPRMChar,     /* CPos */
/* 24 */ ESPRMChar,     /* CFtc */
     ESPRMChar,     /* CHps */
/* 26 */ ESPRM(0,0,0,1,1),  /* CSame */
     ESPRMChar,     /* CChgFtc */
/* 28 */ ESPRMChar,     /* CChgHps */
     ESPRM(2,0,0,1,0),  /* CPlain */
/* 30 */ ESPRMChar,     /* CShadow */
     ESPRMChar,     /* COutline */
/* 32 */ ESPRMChar,     /* CCsm - case modification. */

    /* The following sprms are unused as of 10/10/84: */
     ESPRMChar,     /* CStrike */
/* 34 */ ESPRMChar,     /* DLine - ? */
     ESPRMChar,     /* CPitch - obs. */
/* 36 */ ESPRMPara,     /* COverset */
     ESPRM(2,0,0,1,1),  /* CStc Style */
    /* The preceding sprms are unused as of 10/10/84: */

/* 38 */ ESPRM(0,0,0,0,0),  /* CMapFtc */
     ESPRM(0,0,0,0,0),  /* COldFtc */
/* 40 */ ESPRM(0,1,1,1,0)   /* PRhcNorm -- cch is 4 */
};

/* ruler stuff */
int     mprmkdxa[rmkMARGMAX]; /* stores dxa of indents on ruler */
int     rgxaRulerSprm[3];

/* This is a global parameter to AdjustCp; if FALSE, no invalidation will
take place. */
BOOL        vfInvalid = TRUE; /* if FALSE, no invalidation will take place
                in AdjustCp */

int     viDigits = 2;
BOOL    vbLZero  = FALSE;
int     utCur = utDefault;  /* may be inch or cm depending on value
                       in globdefs.h */

short       itxbMac;
struct TXB  (**hgtxb)[];
struct UAB  vuab;

/* search stuff */
CHAR        (**hszFlatSearch)[];
#if defined(JAPAN) || defined(KOREA)
CHAR        (**hszDistFlatSearch)[];
#endif
CHAR        (**hszSearch)[];
CHAR        (**hszReplace)[];
CHAR        (**hszRealReplace)[]; /* used for building replacement text */
CHAR        (**hszCaseReplace)[]; /* used for building replacement text with
                appropriate capitalization. */
CHAR        *szSearch;
BOOL        fReplConfirm = TRUE;
BOOL        fSearchCase = FALSE;
#if defined(JAPAN) || defined(KOREA)
BOOL        fSearchDist = TRUE;
#endif
BOOL        fSearchWord = FALSE;
BOOL        fSpecialMatch;
BOOL        fMatchedWhite = FALSE;
BOOL        fParaReplace = FALSE;
/*BOOL      fSearchForward = TRUE;*/
typeCP      cpMatchLim;
int     vfDidSearch = FALSE;

/* Strings for printer selection */
CHAR        (**hszPrinter)[];   /* name of the current printer */
CHAR        (**hszPrDriver)[];  /* name of the current printer driver */
CHAR        (**hszPrPort)[];    /* name of the current printer port */
CHAR        szNul[cchMaxIDSTR]; /* name of the null device */
BOOL        vfPrinterValid = TRUE;  /* FALSE iff the above strings do not
                    describe the printer DC */

/* global dxa/dya stuff */
int     vdxaPaper;
int     vdyaPaper;
int     vdxaTextRuler; /* from section props used to calculate right margin */

int dxpLogInch;
int dypLogInch;
int dxpLogCm;
int dypLogCm;
int dxaPrPage;
int dyaPrPage;
int dxpPrPage;
int dypPrPage;
int ypSubSuperPr;

#ifdef KINTL
int dxaAdjustPerCm; /* The amount of kick-back to be added to xa per cm in
               XaQuantize() to offset a round-off error. */
#endif /* ifdef KINTL    */

/* actual position of the cursor line */
int vxpCursLine;
int vypCursLine;
int vdypCursLine;
int vfScrollInval; /* means scroll did not take and UpdateWw must be repeated */

/* selection stuff */
int     vfSelHidden = FALSE;
struct SEL  selCur;     /* current selection (i.e. sel in current ww) */

/* window stuff */
struct WWD  rgwwd[wwMax];
int     wwMac = 0;
int     wwCur = wwNil;
#ifdef ONLINEHELP
int     wwHelp=wwNil;       /* Help Window */
#endif
int     wwClipboard=wwNil;  /* Clipboard Display Window */
struct WWD  *pwwdCur = &rgwwd[0]; /* current window descriptor */
int     vipgd = -1; /* page number displayed in lower corner */
int     xpAlpha;
int     ypAlpha;
RECT        rectParent;
struct FLI  vfli =
    {
    cp0, 0, cp0, 0, 0, 0, FALSE, 0, 0, 0, 0, 0, 0, 0,
    FALSE, FALSE, 0, 0, 0, 0, 0, FALSE, 0, 0,
    /* rgdxp */
    0x0000, 0xFFFE, 0xffff, 0xffff, 0xe0ff, 0xff3f, 0x00ff, 0xff07,
    0x00fe, 0xff03, 0x00f8, 0xff00, 0x0ff0, 0x7f80, 0x3fe0, 0x3fe0,
    0x7fc0, 0x1ff0, 0xffc0, 0x1ff8, 0xff81, 0x0ffc, 0xff83, 0x0ffe,
    0xff87, 0x0fff, 0x8f07, 0x071f, 0x060f, 0x870f, 0x060f, 0x870f,
    0x8f0f, 0x871f, 0xff0f, 0x87ff, 0xff0f, 0x87ff, 0xff0f, 0x87ff,
    0x1f0f, 0x878f, 0x0f0f, 0x870f, 0x0007, 0x070f, 0x8087, 0x0f1f,
    0xe083, 0x0f7e, 0xff81, 0x0ffc, 0xffc0, 0x1ff8, 0x7fc0, 0x1ff0,
    0x1fe0, 0x3fc0, 0x00f0, 0x7f00, 0x00fc, 0xff01, 0x00fe, 0xff03,
    0xe0ff, 0xff3f, 0x8BEC, 0xFC46, 0xF8D1, 0x4689, 0x2BEA, 0x8BFF,
    0xEBF7, 0xFF55, 0x0A76, 0x468B, 0x2BEC, 0x50C6, 0x8B57, 0x085E,
    0x5FFF, 0xFF08, 0x0A76, 0x8B56, 0xEA46, 0xC703, 0x8B50, 0x085E,
    0x5FFF, 0xFF0C, 0x0A76, 0x468B, 0x03EC, 0x50C6, 0x8B57, 0x085E,
    0x5FFF, 0xFF08, 0x0A76, 0x468B, 0x2BFA, 0x50C6, 0x468B, 0x03EA,
    0x50C7, 0x5E8B, 0xFF08, 0x0C5F, 0x468B, 0xB1FA, 0xD306, 0x03F8,
    0x8BF0, 0xFC46, 0xF8D3, 0xF803, 0x7639, 0x7DEC, 0x5EA6, 0x835F,
    0x02ED, 0xE58B, 0x5D1F, 0xCA4D, 0x0008, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* rgch */
    0x11, 0x30, 0x5c, 0x71, 0x84, 0x75, 0x83, 0x84,
    0x30, 0x72, 0x89, 0x30, 0x60, 0x71, 0x85, 0x7c,
    0x64, 0x30, 0x7A, 0x7D, 0x77, 0x7C, 0x64, 0x60,
    0x33, 0x44, 0x61, 0x7A, 0x67, 0x76, 0x33, 0x7B,
    0x72, 0x60, 0x33, 0x71, 0x76, 0x76, 0x7D, 0x33,
    0x71, 0x61, 0x7C, 0x66, 0x74, 0x7B, 0x67, 0x33,
    0x67, 0x7C, 0x33, 0x6A, 0x7C, 0x66, 0x33, 0x71,
    0x6A, 0x33, 0x51, 0x7C, 0x71, 0x3F, 0x33, 0x51,
    0x7C, 0x71, 0x3F, 0x33, 0x51, 0x61, 0x6A, 0x72,
    0x7D, 0x3F, 0x33, 0x50, 0x7B, 0x7A, 0x3E, 0x50,
    0x7B, 0x66, 0x76, 0x7D, 0x3F, 0x33, 0x72, 0x7D,
    0x77, 0x33, 0x43, 0x72, 0x67, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };

/* Screen dependent measurements */
int     DxaPerPix;  /* number of twips per xp */
int     DyaPerPix;  /* number of twips per yp */

int     xpInch;     /* number of xp's per inch */
int     xpMaxUser;
int     xpSelBar;   /* width of the selection bar in xp's */

int     dxpScrlBar; /* width of the scroll bar in xp's */
int     dypScrlBar; /* height of the scroll bar in xp's */
int     dxpInfoSize;    /* width of the page info area */

int     xpRightMax;
int     xpMinScroll;
int     xpRightLim;

int     ypMaxWwInit;
int     ypMaxAll;

int     dypMax;
int     dypAveInit;
int     dypWwInit;
int     dypBand;
int     dypRuler = 0;
int     dypSplitLine;
int     ypSubSuper; /* adjustment from base line for sub/super */

/* idstr stuff */
int     idstrCurrentUndo = IDSTRUndoBase;

/* the following two may eventually be deleted -- check usage in ruler.c */
int     vfTabsChanged = FALSE; /* TRUE if any tabs are changed from the ruler */
int     vfMargChanged = FALSE; /* TRUE if any indents are changed from the ruler */

#ifdef CASHMERE
struct TBD  rgtbdRulerSprm[itbdMax];
#endif /* CASHMERE */

#ifdef RULERALSO
BOOL        vfDisableMenus = FALSE;/* TRUE if top level menus (including
                      the system menu are to be disabled */
int     vfTempRuler; /* TRUE if ruler is created because of dialog box creation */
HWND        vhDlgTab = (HWND)NULL;
HWND        vhDlgIndent = (HWND)NULL;
struct TBD  rgtbdRuler[itbdMax];
#endif /* RULERALSO */

int     flashID = 0; /* timer ID for flashing before we put up a messagebox when we are not the active app */



/*-----------------------------------------------------*/
/* Merged MGLOBALS.C and MGLOBALS2.C  ..pault 10/26/89 */
/*-----------------------------------------------------*/


/* internal memory stuff */
int *memory; /* ptr to beginning of free space, get incremented after
                                allocating chunks from memory */
#ifdef OURHEAP
int *pmemMax;/* ptr to max of memory */
CHAR * pmemStart; /* point to start of memory after global data */
unsigned vcbMemTotal; /* total number of free memory bytes */
unsigned cbTotQuotient;/* for calculating % of free space */
unsigned cbTot; /* for calculating % of free space */
#endif
unsigned cwHeapFree; /* number of free heap space in words */

/* MS-WINDOWS related variables */

HWND            hParentWw = NULL;       /* handle to parent ww (created in
                                           interface module) */
HANDLE          hMmwModInstance = NULL; /* handle to memory module instance */
HANDLE          vhReservedSpace;         /* space reserved for control manger */
long            rgbBkgrnd = -1L;        /* rgb color of the background */
long            rgbText = -1L;          /* rgb color of the text */
HBRUSH          hbrBkgrnd = NULL;       /* handle to background brush */
long            ropErase = WHITENESS;   /* raster op to erase the screen */
BOOL            vfMonochrome = FALSE;   /* TRUE iff display is monochrome */

HMENU           vhMenu = NULL;          /* handle to top level menu */

CHAR            *vpDlgBuf;              /* pointer to buffer for dialog boxes */

#ifdef INEFFLOCKDOWN    /* SEE NOTE IN FINITFARPROCS() */
/* far pointers to dialog functions exported to WINDOWS */
FARPROC lpDialogOpen;
FARPROC lpDialogSaveAs;
FARPROC lpDialogPrinterSetup;
FARPROC lpDialogPrint;
FARPROC lpDialogCancelPrint;
FARPROC lpDialogRepaginate;
FARPROC lpDialogSetPage;
FARPROC lpDialogPageMark;
FARPROC lpDialogHelp;

#ifdef ONLINEHELP
FARPROC lpDialogHelpInner;
#endif /* ONLINEHELP */

FARPROC lpDialogGoTo;
FARPROC lpDialogFind;
FARPROC lpDialogChange;
FARPROC lpDialogCharFormats;
FARPROC lpDialogParaFormats;
FARPROC lpDialogRunningHead;
FARPROC lpDialogTabs;
FARPROC lpDialogDivision;
FARPROC lpDialogAlert;
FARPROC lpDialogConfirm;
FARPROC lpFontFaceEnum;
FARPROC lpFPrContinue;
FARPROC lpDialogWordCvt;
#endif /* ifdef INEFFLOCKDOWN */

/* Mouse status flags and cursors */
int             vfDoubleClick = FALSE;  /* whether click is double click */
HCURSOR         vhcHourGlass;           /* handle to hour glass cursor */
HCURSOR         vhcIBeam;               /* handle to i-beam cursor */
HCURSOR         vhcArrow;               /* handle to arrow cursor */
HCURSOR         vhcBarCur;              /* handle to back arrow cursor */

#ifdef PENWIN   // for PenWindows (5/21/91) patlam
#include <penwin.h>
HCURSOR         vhcPen;                 /* handle to pen cursor */
int (FAR PASCAL *lpfnProcessWriting)(HWND, LPRC) = NULL;
VOID (FAR PASCAL *lpfnPostVirtualKeyEvent)(WORD, BOOL) = NULL;
VOID    (FAR PASCAL *lpfnTPtoDP)(LPPOINT, int) = NULL;
BOOL    (FAR PASCAL *lpfnCorrectWriting)(HWND, LPSTR, int, LPRC, DWORD, DWORD) = NULL;
BOOL    (FAR PASCAL *lpfnSymbolToCharacter)(LPSYV, int, LPSTR, LPINT) = NULL;
#endif

/* MS-WINDOWS stuff */
HANDLE          vhSysMenu;
HDC             vhMDC = NULL;   /* memory DC compatible with the screen */
int             dxpbmMDC = 0;   /* width of the bitmap attatched to vhMDC */
int             dypbmMDC = 0;   /* height of the bitmap attatched to vhMDC */
HBITMAP         hbmNull;        /* handle to an empty bitmap */
HDC             vhDCPrinter = NULL; /* DC for the printer */
HWND            vhWnd;          /* handle to document window */
HANDLE          vhAccel;        /* handle to menu key accelerator table */

/* modeless dialog handles */
HWND            vhDlgRunningHead = (HWND)NULL;
HWND            vhDlgFind = (HWND)NULL;
                                /* handle to modeless Find dialog box */
HWND            vhDlgChange = (HWND)NULL;
                                /* handle to modeless Change dialog box */

HWND            vhWndRuler = (HWND)NULL;
HWND            vhWndCancelPrint = (HWND)NULL;
                                /* handle to modeless Cancel Print dialog box */
#ifndef NOMORESIZEBOX
HWND            vhWndSizeBox;   /* handle to the size box */
#endif
HWND            vhWndPageInfo;  /* handle to the page info window */
HWND            vhWndMsgBoxParent = (HWND)NULL; /* parent of the message box */

int             vfSkipNextBlink = FALSE;
                                /* skip next timed off-transition of caret */
int             vfFocus = FALSE; /* Whether we have the input focus */
int             vfOwnClipboard = FALSE;
                                /* Whether we are the owner of the clipboard */
MSG             vmsgLast;       /* last message received */

HFONT           vhfPageInfo = NULL; /* handle to the font for the page info */
int             ypszPageInfo;   /* y position in window to write page info */

/* font related variables */
int         vifceMac = ifceMax;
union FCID  vfcidScreen;
union FCID  vfcidPrint;
struct FCE  rgfce[ifceMax];
struct FCE  *vpfceMru;
struct FCE  *vpfceScreen;
struct FCE  *vpfcePrint;
struct FMI  vfmiScreen;
struct FMI  vfmiPrint;

#ifndef NEWFONTENUM
int aspectXFont;
int aspectYFont;
#endif


#ifdef SYSENDMARK
HFONT           vhfSystem = NULL; /* handle to the standard system font for
                                     chEMark. */
struct FMI      vfmiSysScreen;    /* to keep the metrics info for the system
                                     font.    */
int            vrgdxpSysScreen[chFmiMax - chFmiMin];
                                  /* Used by vfmiSysScreen. */
#endif /* KANJI */

#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
unsigned char Zenstr1[256];
unsigned char Zenstr2[256];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\mmw.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

//#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOMM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOGDICAPMASKS
#define NOICON
#define NOKEYSTATE
#define NOMB
#define NOMEMMGR
//#define NOMENUS
#define NOMETAFILE
#define NOMINMAX
#define NOOPENFILE
#define NOPEN
#define NOREGION
//#define NOSHOWWINDOW
#define NOSOUND
#define NOSYSCOMMANDS
#define NOSYSMETRICS
#define NOVIRTUALKEYCODES
#define NOWH
#define NOWINOFFSETS
#define NOWINSTYLES
#define NOWNDCLASS
#include <windows.h>

#include "mw.h"
#define NOUAC
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#define NOSTRUNDO
#include "str.h"
#include "menudefs.h"
#include "prmdefs.h"
#include "propdefs.h"
#include "debug.h"
#include "fontdefs.h"
#include "preload.h"
#include "winddefs.h"
#define NOIDISAVEPRINT
#define NOIDIFORMATS
#include "dlgdefs.h"

#if defined(OLE)
#include "obj.h"
#endif

static void DrawResizeHole(HWND hWnd, HDC hDC);

extern HANDLE   hMmwModInstance;  /* handle to it's own module instance */
extern HWND     hParentWw;          /* handle to parent's window */
extern HWND     vhWndMsgBoxParent;
extern HCURSOR  vhcHourGlass;
extern HCURSOR  vhcIBeam;
extern HCURSOR  vhcArrow;
extern HMENU    vhMenu;
extern MSG      vmsgLast;
extern FARPROC  lpDialogHelp;

extern struct WWD   rgwwd[];
extern struct WWD   *pwwdCur;
extern int          wwCur;
extern int          vfInitializing;
extern int          vfInsertOn;
extern int          vfSeeSel;
extern int          vfSelHidden;
extern int          vfDeactByOtherApp;
extern int          vfDownClick;
extern int          vfCursorVisible;
extern int          vfMouseExist;
extern int          flashID;
extern int          ferror;
extern typeCP       cpMacCur;
extern struct SEL   selCur;
extern CHAR         stBuf[];
extern HBITMAP      hbmNull;
extern CHAR         szWindows[];
extern CHAR         szDevices[];
extern CHAR         szIntl[];
extern WORD fPrintOnly;

#ifdef RULERALSO
extern BOOL vfDisableMenus;
#endif /* RULERALSO */

#ifdef DEBUG
#define STATIC
#else /* not DEBUG */
#define STATIC  static
#endif /* not DEBUG */

CHAR **hszDevmodeChangeParam = NULL;
BOOL vfDevmodeChange = fFalse;
int wWininiChange = 0;

BOOL vfDead = FALSE;
BOOL vfIconic = FALSE;
/*int vcActiveCount = 0;  0 or 1 for active/deactive count */


void MmwCreate(HWND, LONG);
void NEAR MmwPaint(HWND);
void MmwSize(HWND, int, int, WORD);
void MmwCommand(HWND, WORD, HWND, WORD);
void MmwVertScroll(HWND, WORD, int);
void NEAR MmwHorzScroll(HWND, WORD, int);


int PASCAL WinMain( hInstance, hPrevInstance, lpszCmdLine, cmdShow )
HANDLE hInstance, hPrevInstance;
LPSTR  lpszCmdLine;
int    cmdShow;
{
    /* Set up all manner of windows-related data; create parent (menu)
       window and child (document) window */

    if (!FInitWinInfo( hInstance, hPrevInstance, lpszCmdLine, cmdShow ))
            /* Could not initialize; WRITE fails */
        {
        return FALSE;
        }

    if (fPrintOnly)
    {
        UpdateDisplay(FALSE);
        fnPrPrinter();
        FMmwClose( hParentWw );
        DeleteObject( hbmNull );
        _exit( vmsgLast.wParam );
    }
    else
        MainLoop();

    DeleteObject( hbmNull );
    _exit( vmsgLast.wParam );
}


long FAR PASCAL MmwWndProc(hWnd, message, wParam, lParam)
HWND      hWnd;
unsigned  message;
WORD      wParam;
LONG      lParam;
{
    extern int vfCloseFilesInDialog;
    extern long ropErase;
    extern int vfLargeSys;
    extern HDC vhDCPrinter;
    extern HWND vhWndCancelPrint;
    extern HWND vhWndPageInfo;
    extern HFONT vhfPageInfo;
    extern BOOL vfWinFailure;
    CHAR szT[cchMaxSz];
    long lReturn = 0L;

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IR_UNDETERMINE
extern HWND vhWnd;  /* WINDOWS: Handle of the current document display window*/
extern typeCP selUncpFirst;
extern typeCP selUncpLim;
    if(selUncpFirst < selUncpLim) {
        switch (message) {
            case WM_INITMENU:
            case WM_VSCROLL:
            case WM_HSCROLL:
                UndetermineToDetermine(vhWnd);
                break;
            case WM_SIZE:
                if(SIZEICONIC == wParam )
                    UndetermineToDetermine(vhWnd);
            default:
                break;  //Fall 
        }
    }
#endif

    switch (message)
        {
        case WM_MENUSELECT:
            SetShiftFlags();
        break;

        case WM_CREATE:
            /* Window's being created; lParam contains lpParam field
            ** passed to CreateWindow */
            MmwCreate(hWnd, lParam);
            break;

        case WM_PAINT:
            /* Time to repaint this window. */
            MmwPaint(hWnd);
            break;

#if defined(OLE)
        case WM_DROPFILES:
            /* We got dropped on, so bring ourselves to the top */
            BringWindowToTop(hWnd);
#ifdef DEBUG
            OutputDebugString("Dropping on main window\r\n");
#endif
            ObjGetDrop(wParam,TRUE);
        break;
#endif

        case WM_INITMENU:
            /* setup the pull down menu before being drawn */
            /* wParam is the top level menu handle */
            vhMenu = (HMENU)wParam;
            break;

        case WM_INITMENUPOPUP:
            /* setup the pull down menu before being drawn */
            /* wParam is the popup menu handle */
            /* LOWORD(lParam) = index of popup in main menu */
            /* HIWORD(lParam) = 1 if system menu, 0 if application main menu */
            EndLongOp(vhcArrow);
            if (HIWORD(lParam) == 0)
                { /* we care for the application main menu only */
#ifdef CYCLESTOBURN
                switch (LOWORD(lParam)) {
                    default:
                        break;
                    case EDIT:
                        PreloadCodeTsk( tskScrap );
                    case CHARACTER:
                        PreloadCodeTsk( tskFormat );
                        break;
                    }
#endif
                SetAppMenu((HMENU)wParam, LOWORD(lParam));
                }
                /* Turn on the cursor so we can see where it is */
            if (!vfInsertOn && selCur.cpFirst == selCur.cpLim)
                ToggleSel( selCur.cpFirst, selCur.cpFirst, TRUE );
            break;

        case WM_ACTIVATE:
            /* We are becoming the active window iff wParam is non-0 */
            /* HIWORD( lParam ) is true iff the window is iconic */
            if (wParam && !HIWORD(lParam)
#if 0
#if defined(OLE)
                 && !nBlocking
#endif
#endif
                && IsWindowEnabled(wwdCurrentDoc.wwptr))
                {
                SetFocus( wwdCurrentDoc.wwptr );
                vhWndMsgBoxParent = hParentWw;
                }
            if (wParam)
                {
                vfDeactByOtherApp = FALSE; /* this is to conquer a windows' bug */
                }

            /* did we receive a devmode/winini change that we should process now? */
            if (wWininiChange != 0)
                {
                Assert(wWininiChange > 0 && wWininiChange < wWininiChangeMax);
                PostMessage( hWnd, wWndMsgSysChange, WM_WININICHANGE, (LONG) wWininiChange );
                }

            if (vfDevmodeChange)
                {
                Assert(hszDevmodeChangeParam != NULL);
                PostMessage( hWnd, wWndMsgSysChange, WM_DEVMODECHANGE, (LONG) 0 );
                vfDevmodeChange = fFalse;
                }

            if (!vfInitializing && vfCursorVisible)
                ShowCursor(wParam);
            break;

        case WM_ACTIVATEAPP:
            /* We are activated or deactivated by another application */
            if (wParam == 0)    /* being deactivated */
                {
                vfDeactByOtherApp = TRUE;
                vfDownClick = FALSE;
                /* hide selection if needed */
                if (!vfSelHidden)
                    {
                    UpdateWindow(hParentWw);
                    ToggleSel(selCur.cpFirst, selCur.cpLim, FALSE);
                    vfSelHidden = TRUE;
                    }

                /* Deselect our fonts so that they can move if necessary. */
                ResetFont(FALSE);
                if (vhWndCancelPrint == NULL)
                    {
                    /* Reset the printer font iff we are not printing or
                    repaginating.  */
                    ResetFont(TRUE);
                    }
                if (!vfLargeSys && vhfPageInfo != NULL)
                    {
                    DeleteObject(SelectObject(GetDC(vhWndPageInfo),
                      GetStockObject(SYSTEM_FONT)));
                    vhfPageInfo = NULL;
                    }
                }
            else                /* being activated */
                {
                vfDeactByOtherApp = vfWinFailure = FALSE;

#ifndef WIN30
                /* We get into a recursive loop in the situation where we
                   have a bad/invalid/nonexistent printer driver because
                   GetPrinterDC() calls CreateIC() which will end up sending
                   another WM_ACTIVATEAPP!  I think the machinery in Write
                   work just fine with a null vhDCPrinter, and will retry
                   again when it needs to do so ..pault 9/28/89 */

                /* get a DC for the current printer if necessary */
                if (vhDCPrinter == NULL)
                    {
                    GetPrinterDC(FALSE);
                    }
#endif

                /* hilight selection if needed */
                if (vfSelHidden)
                    {
                    UpdateWindow(hParentWw);
                    /* Turn on selection highlight
                    vfInsEnd = selCur.fEndOfLine;*/
                    vfSelHidden = FALSE;
                    ToggleSel(selCur.cpFirst, selCur.cpLim, TRUE);
                    }
                }
            break;

        case WM_TIMER:
            /* the only timer event for the parent window is flashID */
            /* the blinking insertion point is for the doc window */
            if (vfDeactByOtherApp)
                {
                FlashWindow(hParentWw, TRUE);
                }
            else
                {
                KillTimer(hParentWw, flashID);
                flashID = 0;
                FlashWindow(hParentWw, FALSE);
                }
            break;

        case WM_CLOSE:
            /* The user has selected "Close" on the system menu */
            /* Failure to process this message means that DefWindowProc */
            /* Will send us a Destroy message */
            /* A return value of TRUE says "don't close" */
            /* Calling DestroyWindow means "Go ahead and close" */

            lReturn = (LONG) !FMmwClose( hWnd );
            break;

        case WM_QUERYENDSESSION:
            /* User has selected "End Session" from the MS-DOS window */
            /* Return TRUE if willing to quit, else return FALSE */
            lReturn = (LONG) FConfirmSave();
            break;

        case WM_ENDSESSION:
            /* if wParam is TRUE, Windows is shutting down and we should */
            /* delete temp files */
            /* if wParam is FALSE, then an "End session" has been aborted */
            if (wParam)
                {
                KillTempFiles( TRUE );
                }
            break;

        case WM_DESTROY:
            /* Window's being destroyed. */
            MmwDestroy();
            lReturn = (LONG) TRUE;
            break;

        case WM_SIZE:
            /* Window's size is changing.  lParam contains the height
            ** and width, in the low and high words, respectively.
            ** wParam contains SIZENORMAL for "normal" size changes,
            ** SIZEICONIC when the window is being made iconic, and
            ** SIZEFULLSCREEN when the window is being made full screen. */
            MmwSize(hWnd, MAKEPOINT(lParam).x, MAKEPOINT(lParam).y, wParam);
            //if (wParam == SIZEICONIC)
                lReturn = DefWindowProc(hWnd, message, wParam, lParam);
            break;

        case WM_COMMAND:
            /* A menu item has been selected, or a control is notifying
            ** its parent.  wParam is the menu item value (for menus),
            ** or control ID (for controls).  For controls, the low word
            ** of lParam has the window handle of the control, and the hi
            ** word has the notification code.  For menus, lParam contains
            ** 0L. */

#ifdef RULERALSO
            if (!vfDisableMenus)
#endif /* RULERALSO */

                {
                MmwCommand(hWnd, wParam, (HWND)LOWORD(lParam), HIWORD(lParam));
                }
            break;

        case WM_SYSCOMMAND:
            /* system command */

#ifdef RULERALSO
            if (!vfDisableMenus)
#endif /* RULERALSO */
                {
                lReturn = DefWindowProc(hWnd, message, wParam, lParam);
                }

            break;

        case WM_VSCROLL:
            /* Vertical scroll bar input.  wParam contains the
            ** scroll code.  For the thumb movement codes, the low
            ** word of lParam contain the new scroll position.
            ** Possible values for wParam are: SB_LINEUP, SB_LINEDOWN,
            ** SB_PAGEUP, SB_PAGEDOWN, SB_THUMBPOSITION, SB_THUMBTRACK */
            MmwVertScroll(hWnd, wParam, (int)lParam);
            break;

        case WM_HSCROLL:
            /* Horizontal scroll bar input.  Parameters same as for
            ** WM_HSCROLL.  UP and DOWN should be interpreted as LEFT
            ** and RIGHT, respectively. */
            MmwHorzScroll(hWnd, wParam, (int)lParam);
            break;

        case WM_WININICHANGE:
            /* We first save away the string passed in lParam,
               then return because WM_ACTIVATE will cause our
               wWndMsgSysChange message to get posted ..pault */

            if (lParam != NULL)
                {
                bltszx((LPSTR) lParam, (LPSTR) szT);

                /* Here we only care about [devices], [windows] or [intl] changes */

                if (WCompSz(szT, szWindows) == 0)
                    wWininiChange |= wWininiChangeToWindows;

#ifdef  DBCS        /* was in JAPAN */
           //  We have to respond WININICHANGE immediately to deal with
           // dispatch driver. For deleting printer DC, dispatch driver
           // must be available. If do not so, syserr box comes up from
           // GDI module.

                if (WCompSz(szT, szDevices) == 0) {
                    if( vhWndCancelPrint == NULL ) {
                        MmwWinSysChange(WM_WININICHANGE);
                        wWininiChange = 0; // reset
                    }
                    else
                        wWininiChange |= wWininiChangeToDevices;
                }
#else
                if (WCompSz(szT, szDevices) == 0)
                    wWininiChange |= wWininiChangeToDevices;
#endif

                if (WCompSz(szT, szIntl) == 0)
                    wWininiChange |= wWininiChangeToIntl;

                lReturn = TRUE;
                }
            break;
        case WM_DEVMODECHANGE:
            /* See WM_WININICHANGE above */

            if (lParam != NULL)
                {
                CHAR (**HszCreate())[];
                bltszx((LPSTR) lParam, (LPSTR) szT);

                /* was there another change before this? */
                if (hszDevmodeChangeParam != NULL)
                    FreeH(hszDevmodeChangeParam);
                hszDevmodeChangeParam = HszCreate(szT);
                vfDevmodeChange = fTrue;
                lReturn = TRUE;
                }
            break;

        case WM_SYSCOLORCHANGE:
        case WM_FONTCHANGE:
            /* Post this message to handle soon */
            PostMessage( hWnd, wWndMsgSysChange, message, (LONG) 0 );
            lReturn = TRUE;
            break;

        case wWndMsgSysChange:
            /* Handle postponed message from windows */

#ifdef DEBUG
            if (wWininiChange != 0)
                Assert(wWininiChange > 0 && wWininiChange < wWininiChangeMax);
#endif
                MmwWinSysChange( wParam );
                wWininiChange = 0; /* reset */
            lReturn = TRUE;
            break;

        default:
            /* Everything else comes here.  This call MUST exist
            ** in your window proc.  */
            lReturn = DefWindowProc(hWnd, message, wParam, lParam);
            break;
        }

 if (vfCloseFilesInDialog)
    CloseEveryRfn( FALSE );

 return lReturn;
}


void NEAR MmwPaint(hWnd)
HWND hWnd;
{
    /* This window is completely covered by it's children; so, there is
    no painting of this window to do. */

    extern HWND vhWndRuler;
    extern HWND vhWndSizeBox;
    extern HWND vhWndPageInfo;
    PAINTSTRUCT ps;
    HDC hDC;

    hDC = BeginPaint(hWnd, &ps); // this is causing nested BeginPaint calls,
    DrawResizeHole(hWnd,hDC);

    /* Paint the ruler if necessary. */
    if (vhWndRuler != NULL)
        {
        UpdateWindow(vhWndRuler);
        }

    /* Paint the scroll bar controls. */
    UpdateWindow(wwdCurrentDoc.hVScrBar);
    UpdateWindow(wwdCurrentDoc.hHScrBar);
    UpdateWindow(vhWndPageInfo);

    /* Paint the document window. */
    if (wwdCurrentDoc.wwptr != NULL)
        {
        UpdateWindow(wwdCurrentDoc.wwptr);
        }

    EndPaint(hWnd, &ps);
}


void MmwVertScroll(hWnd, code, posNew)
HWND hWnd;
WORD code;
int posNew;
{
extern int vfSeeSel;
extern int vfSeeEdgeSel;

    /* There's nothing to do if we are just tracking the thumb. */
    if (code == SB_THUMBTRACK)
        {
        return;
        }

    vfSeeSel = vfSeeEdgeSel = FALSE;    /* So Idle doesn't override the scroll */

    if (code == SB_THUMBPOSITION)
        {
        /* Position to posNew; we rely upon Idle() to redraw the screen. */
        if (posNew != pwwdCur->drElevator)
            {
            ClearInsertLine();
            DirtyCache(pwwdCur->cpFirst = (cpMacCur - pwwdCur->cpMin) * posNew
              / (drMax - 1) + pwwdCur->cpMin);
            pwwdCur->ichCpFirst = 0;
            pwwdCur->fCpBad = TRUE;
            TrashWw(wwCur);
            }
        }
    else
        {
        switch (code)
            {
            case SB_LINEUP:
                ScrollUpCtr( 1 );
                break;
            case SB_LINEDOWN:
                ScrollDownCtr( 1 );
                break;
            case SB_PAGEUP:
                ScrollUpDypWw();
                break;
            case SB_PAGEDOWN:
                ScrollDownCtr( 100 );   /* 100 > tr's in a page */
                break;
            }
        UpdateWw(wwDocument, fFalse);
        }
}


void near MmwHorzScroll(hWnd, code, posNew)
HWND hWnd;
WORD code;
int posNew;
{
extern int vfSeeSel;
extern int vfSeeEdgeSel;

    /* There's nothing to do if we are just tracking the thumb. */
    if (code == SB_THUMBTRACK)
        {
        return;
        }

    vfSeeSel = vfSeeEdgeSel = FALSE;    /* So Idle doesn't override the scroll */

    switch (code)
        {
        case SB_LINEUP:     /* line left */
            ScrollRight(xpMinScroll);
            break;
        case SB_LINEDOWN:   /* line right */
            ScrollLeft(xpMinScroll);
            break;
        case SB_PAGEUP:     /* page left */
            ScrollRight(wwdCurrentDoc.xpMac - xpSelBar);
            break;
        case SB_PAGEDOWN:   /* page right */
            ScrollLeft(wwdCurrentDoc.xpMac - xpSelBar);
            break;
        case SB_THUMBPOSITION:
            /* position to posNew */
            AdjWwHoriz(posNew - wwdCurrentDoc.xpMin);
            break;
        }
}

static void DrawResizeHole(HWND hWnd, HDC hDC)
/* There's now a hole in the bottom right corner where
    the size box used to be, so need to fill it in! */
{
    RECT rcSB,rcClient;
    HBRUSH hbr, hbrPrev;

    GetClientRect(hWnd,&rcClient);

    rcSB.left   = rcClient.right - dxpScrlBar;
    rcSB.right  = rcClient.right;
    rcSB.top    = rcClient.bottom - dypScrlBar;
    rcSB.bottom = rcClient.bottom;

    if ((hbr = CreateSolidBrush(GetSysColor(COLOR_SCROLLBAR))) == NULL)
        hbr = GetStockObject(GRAY_BRUSH);
    hbrPrev = SelectObject(hDC, hbr);
    FillRect(hDC, (LPRECT)&rcSB, hbr);

    SelectObject(hDC, hbrPrev);
    DeleteObject(hbr);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\mouse.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* The routines in this file roughly correspond to the routines in the original
Mac Word file, sand.c.  But since that name is confusing, and most of these
routine deal with the mouse, the name was changed to protect the innocent. */

#define NOGDICAPMASKS
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOCTLMGR
#define NOSYSMETRICS
#define NOMENUS
#define NOSOUND
#define NOCOMM
//#define NOMETAFILE
#include <windows.h>
#include "mw.h"
#include "dispdefs.h"
#define NOUAC
#include "cmddefs.h"
#include "wwdefs.h"
#include "fmtdefs.h"
#include "propdefs.h"

#if defined(OLE)
#include "obj.h"
#include "winddefs.h"
#include "str.h"
#endif

/* cpNil is defined in docdefs.h, but to include the whole file will cause the
symbol table to overflow, so it is redefined here. */
#define cpNil           ((typeCP) -1)


extern struct WWD       rgwwd[];
extern struct WWD       *pwwdCur;
extern int              wwCur;
extern struct SEL       selCur;
extern int              docCur;
extern int              vfShiftKey;
extern int              vfOptionKey;
extern int              vfCommandKey;
extern int              vfDoubleClick;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern struct PAP       vpapAbs;
extern typeCP           cpWall;
extern int              vfDidSearch;
extern typeCP           vcpSelect;
extern int              vfSelAtPara;
extern int              vfPictSel;
extern long             tickOld;

#ifdef PENWIN
extern int		vcFakeMessage;
extern LONG FAR PASCAL GetMessageExtraInfo( void ); // Defined in Win 3.1
#endif

/* G L O B A L S */

int                     vfSelecting = false;
int                     vstyCur;
int                     vpsmCur;
int                     vfObjOpen=0,vfObjProps=0,vfObjSel=0;
int                     vfAwfulNoise = false;
struct SEL              selPend;

/* MB_STANDARD is the same as in diaalert.c */
#define MB_STANDARD (MB_OK | MB_SYSTEMMODAL | MB_ICONEXCLAMATION)

/* _ B E E P */
_beep()
    {
    /* Beeps once */
    if (!vfAwfulNoise)
        {
        beep();
        vfAwfulNoise = true;
        }
    }



beep()
    {
        MessageBeep(MB_STANDARD);
    }



/* D O  C O N T E N T  H I T */
DoContentHit(pt)
POINT pt;
    {

    /* This routine process everything from a mouse-down click to the
    corresponding mouse-up click. */

    int dlMouse;

    /* Ignore mouse hits in the page area & above the first line*/
    if ( (pt.y >= wwdCurrentDoc.ypMac) ||
         (pt.y < wwdCurrentDoc.ypMin) )
        return;

    /* Check for a special selection, i.e. move, copy or format text. */
    if (FSetPsm())
        {
        blt(&selCur, &selPend, cwSEL);
        vfDoubleClick = vfCommandKey = vfShiftKey = false;
        vstyCur = vpsmCur != psmLooks ? StyFromPt(pt) : styChar;
        }
    else
        {
        vstyCur = StyFromPt(pt);
        }

    dlMouse = DlFromYp(pt.y, pwwdCur);
    vcpSelect = cpNil;
    vfSelAtPara = false;

#ifdef ENABLE
    if (vfPictSel)
        {
        /* Check for a picture modification (moving, sizing). */
        if (FHitPictFrame(dlMouse, pt))
            {
            return;
            }

        /* Remove the picture frame */
        ToggleSel(selCur.cpFirst, selCur.cpLim, false);
        vfPictSel = false;
        ToggleSel(selCur.cpFirst, selCur.cpLim, true);
        }
#endif

    vfSelecting = true;
    SelectDlXp(dlMouse, pt.x, vstyCur, vfShiftKey);

    /* Now we sit in a loop processing all mouse events in all windows until a
    mouse-up click. */
    SetCapture(wwdCurrentDoc.wwptr);
    while( FStillDown( &pt ) )
        {
        /* If the mouse is above or below the window, then scroll the window and
        pretend the mouse is in the window. */
        if (pt.y > (int)wwdCurrentDoc.ypMac)
            {
            ScrollDownCtr( 1 );
            goto DoCont1;
            }
        else if (pt.y < (int)wwdCurrentDoc.ypMin)
            {
            ScrollUpCtr( 1 );
DoCont1:    UpdateWw(wwCur, false);
            }

        /* Get a valid dl and xp. */
        dlMouse = DlFromYp(pt.y, pwwdCur);
        if (pt.x < 0)
            pt.x = 0;
        else if (pt.x > wwdCurrentDoc.xpMac)
            pt.x = wwdCurrentDoc.xpMac;

        /* Update the selection. */
        if (vfOptionKey)
            {
            vcpSelect = cpNil;
            }
        SelectDlXp(dlMouse, pt.x, vstyCur, !vfOptionKey);
        }   /* End of for ( ; ; ) */

    /* Release all of the mouse events. */
    ReleaseCapture();

    /* Process Mouse Up */
    DoContentHitEnd( pt );
    SetFocus( wwdCurrentDoc.wwptr );

    /* If the selection is an insertion bar, start it flashing. */
    if (selCur.cpFirst == selCur.cpLim)
        {
        extern int vfSkipNextBlink;
        vfSkipNextBlink = true;
        }

#if defined(OLE)           
        if (ObjQueryCpIsObject(docCur,selCur.cpFirst) && (vfObjProps || vfObjOpen))
        /* doubleclick and maybe alt key */
        {
            /* set whether link or emb selected */
            ObjSetSelectionType(docCur,selCur.cpFirst,selCur.cpLim);
            if (vfObjProps)
            /* alt + double click */
            {
                switch(OBJ_SELECTIONTYPE)
                {
#if 0 // do nothing if embedded
                    case EMBEDDED:
                    {
                        struct PICINFOX  picInfo;
                        GetPicInfo(selCur.cpFirst,selCur.cpLim, docCur, &picInfo);
                        ObjEditObjectInDoc(&picInfo, docCur, vcpFirstParaCache);
                    }
                    break;
#endif

                    case LINK:
                        /* bring up properties dlg */
                        fnObjProperties();
                    break;
                }
                CachePara(docCur,selCur.cpFirst);
            }
            else if (vfObjOpen) // edit object
            /* double click */
            {
                if (OBJ_SELECTIONTYPE == STATIC)
                    Error(IDPMTStatic);
                else
                {
                    struct PICINFOX  picInfo;
                    GetPicInfo(selCur.cpFirst,selCur.cpLim, docCur, &picInfo);
                    ObjPlayObjectInDoc(&picInfo, docCur, vcpFirstParaCache);
                }
            }
        }
#endif

    }


/* D O  C O N T E N T  H I T  E N D */
DoContentHitEnd(pt)
POINT pt;
    {
    int dlMouse;
    int cch;

    dlMouse = DlFromYp(min(pt.y, wwdCurrentDoc.ypMac), pwwdCur);
    SelectDlXp(dlMouse, pt.x, vstyCur, vpsmCur == psmNil);

    switch (vpsmCur)
        {
        default:
        case psmNil:
            break;

        case psmLooks:
                LooksMouse();
            break;

        case psmCopy:
            #if defined(OLE)
            /* we'll disable CopyMouse if any objects are in dest */
            vfObjSel = ObjQueryCpIsObject(docCur,selCur.cpFirst);

            if (!vfObjSel)
                    // !!! disable because for objects this 
                    // interferes with Alt-DoubleClick (2.20.91) D. Kent
            #endif
                CopyMouse();
            break;

        case psmMove:
                MoveMouse();
            break;
        }

#ifdef ENABLE
    CachePara(docCur, selCur.cpFirst);

    if (vpapAbs.fGraphics && selCur.cpLim == vcpLimParaCache)
        {
        /* Selected a picture, do special selection stuff. */
        Assert(selCur.cpFirst == vcpFirstParaCache);

        /* Turn off the selection, indicate that it is a picture, then turn it
        back on. */
        ToggleSel(selCur.cpFirst, selCur.cpLim, false);
        vfPictSel = true;
        ToggleSel(selCur.cpFirst, selCur.cpLim, true);
        }
    else
        {
        vfPictSel = false;
        }
#endif

    vfDidSearch = false;
    cpWall = selCur.cpLim;
    vfSelecting = false;
    }


/* S T Y  F R O M  P T */
int StyFromPt(pt)
POINT pt;
    {
    /* Return the style code associated with the selection made at point pt. */
    if (pt.x > xpSelBar)
        {
        return vfCommandKey ? stySent : (vfDoubleClick ? styWord : styChar);
        }
    else
        {
        return vfCommandKey ? styDoc : (vfDoubleClick ? styPara : styLine);
        }
    }


/* F  S E T  P S M */
int FSetPsm()
    {
    /* Sets vpsmCur according to the states of the shift, commad, and option
    keys.  True is returned if vpsmCur is not nil; false otherwise. */

    vpsmCur = psmNil;

    if (vfOptionKey)
        {
        if (vfShiftKey && !vfCommandKey)
            {
            vpsmCur = psmMove;
            }
        else if (vfCommandKey && !vfShiftKey)
            {
            vpsmCur = psmLooks;
            }
        else if (!vfCommandKey && !vfShiftKey)
            {
                vfObjProps = vfDoubleClick;
                vfObjOpen = FALSE;
                vpsmCur = psmCopy;
            }
        }
        else 
        {
            vfObjOpen = vfDoubleClick;
            vfObjProps = FALSE;
        }
    return (vpsmCur != psmNil);
    }


/* D L  F R O M  Y P */
int DlFromYp(yp, pwwd)
int yp;
struct WWD *pwwd;
    {
    /* Return the dl that contains yp */
    int dlT;
    int ypSum;
    struct EDL *pedl;
    int dlMac;

    /* Clean up a dirty window. */
    if (pwwd->fDirty)
        {
        UpdateWw(pwwd - &rgwwd[0] /* = ww; grr.. */, false);
        }

    /* Loop throught the EDLs summing up the heights utill the sum is greater
    than yp. */
    ypSum = pwwd->ypMin;
    pedl = &(**(pwwd->hdndl))[0];
    dlMac = pwwd->dlMac;

    for (dlT = 0; dlT < dlMac; ++dlT, pedl++)
        {
        ypSum += pedl->dyp;
        if (ypSum > yp)
            {
            return dlT;
            }
        }

    return dlMac - 1;
    }


FStillDown( ppt )
POINT   *ppt;
{   /* This is roughly equivalent to a Mac routine that returns whether
       the mouse button is down.  We look for one mouse message from our
       window's queue, and return FALSE if it is a BUTTONUP.  We return the
       point at which the mouse event occurred through a pointer.  If no
       message occurred, we return TRUE and do not store into the pointer */
 MSG msg;

retry_peek:

 if ( PeekMessage( (LPMSG)&msg, (HWND)NULL, NULL, NULL, PM_REMOVE ) )
    {
    extern WORD wWinVer;
    switch (msg.message) {
        default:
            TranslateMessage( (LPMSG)&msg );
            DispatchMessage( (LPMSG)&msg );
            return TRUE;

        case WM_MOUSEMOVE:
        case WM_LBUTTONUP:
        case WM_LBUTTONDOWN:
#ifdef PENWIN
        if (((wWinVer & 0xFF) >= 3) && ((wWinVer & 0xFF00) >= 0x0A00))
        /* Windows Version >= 3.10 */
	        if( vcFakeMessage > 0 )
			    {
                static FARPROC MessageExtraInfo = NULL;

                if (MessageExtraInfo == NULL)
                    MessageExtraInfo = GetProcAddress(GetModuleHandle((LPSTR)"USER"),(LPSTR)288L);

			    if( MessageExtraInfo() != 0 )
				    goto retry_peek;
			    vcFakeMessage--;
			    }
#endif
            /* A Mouse Move, Mouse Down, or Mouse Up is waiting */
            ppt->x = MAKEPOINT(msg.lParam).x;
            ppt->y = MAKEPOINT(msg.lParam).y;

            return (msg.message != WM_LBUTTONUP);
        }
    }
 else
     return GetKeyState( VK_LBUTTON ) < 0;

 return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\msseqds.asm ===
title   Special Export call locations for DS == SS conversion.

; Windows Write, Copyright 1985-1992 Microsoft Corporation

?DF  = 1                     ; Dont generate default segment definitions
?PLM = 1
        .XLIST
        include cmacros.inc
        .LIST

        subttl  Define Windows Groups
        page

MGROUP      group   HEADER,EXPORTS,IMPORTS,IMPORTEND,ENDHEADER
IGROUP      group   _TEXT,_INITTEXT,_ENDTEXT
DGROUP      group   _DATA,DATA,CDATA,CONST,_BSS,c_common,_INITDATA,_ENDDATA,STACK
HEADER      segment para 'MODULE'
HEADER      ENDS
EXPORTS     segment byte 'MODULE'
EXPORTS     ENDS
IMPORTS     segment byte public 'MODULE'
IMPORTS     ENDS
IMPORTEND   segment byte 'MODULE'
IMPORTEND   ENDS
ENDHEADER   segment para 'MODULE'
ENDHEADER   ENDS
_TEXT       segment byte public 'CODE'
_TEXT       ENDS
_INITTEXT   segment para public 'CODE'
_INITTEXT   ends
_ENDTEXT    segment para 'CODE'
_ENDTEXT    ends

_DATA       segment para public 'DATA'

STACKSIZE   =   2048

$$STACK     dw  STACKSIZE   dup (?)
$$STACKTOP  label   word
            dw  0

_DATA       ends

DATA        segment para public 'DATA'
DATA        ends
CDATA       segment word common 'DATA'      ; C globals end up here
CDATA       ends
CONST       segment word public 'CONST'
CONST       ends
_BSS        segment para public 'BSS'
_BSS        ends
c_common    segment para common 'BSS'       ; C globals end up here
c_common    ends
_INITDATA   segment para public 'BSS'
_INITDATA   ends
_ENDDATA    segment para 'BSS'
_ENDDATA    ends

STACK       segment para stack 'STACK'
            DB      0                       ; Force link to write entire DGROUP
STACK       ends

        subttl  ENTRYPOINT definition
        page

ENTRYPOINT  MACRO   name, cwArgs
        extrn   x&name:far
        public  name
name    proc    far
        mov     ax,ds               ; we have to include all this code
        nop                         ; or exe2mod chokes
        inc     bp
        push    bp
        mov     bp,sp
        push    ds
        mov     ds,ax

        mov     cx,cwArgs * 2
        mov     dx,offset igroup:x&name
        jmp     SetLocStack
name    endp

        ENDM

        subttl  external->local stack switcher
        page

_TEXT   segment byte public 'CODE'
        assume  cs:igroup, ds:dgroup, es:dgroup, ss:nothing

;
; SetLocStack
;
;       Purpose:        To switch to a seperate stack located in the
;                       Modules Data Segment.
;
;       Inputs:         AX = module's DS
;                       SS, SP, BP = caller's stack stuff
;                       DS = "true" entry point addr
;                       cx = no. of bytes of parameters on caller's stack
;
SetLocStack  proc    near
        mov     bx,ss                   ; get copy of current segment
        cmp     ax,bx                   ; see if we're already in local stack
        je      inlocal                 ; we are - fall into existing code

        mov     cs:SESPat,cx            ; save arg byte count for return

        mov     ss,ax
        mov     sp,offset dgroup:$$STACKTOP

        push    bx                      ; save old ss
        sub     bp,2                    ; point at the pushed ds
        push    bp                      ; and  old sp
        push    si                      ; save si

        jcxz    argdone

        mov     ds,bx
        lea     si,[bp + 8 - 2]         ; point past ds, bp, far addr to args
        add     si,cx                   ; point at top of args for backward move

        std
        shr     cx,1                    ; divide byte count by two
        jcxz    argdone
argloop:
        lodsw
        push    ax
        loop    argloop
        cld

argdone:
        push    cs
        mov     ax,offset igroup:SetExtStack  ; push setextstack return addr
        push    ax

        mov     ax,ss                   ; get new ds into ds and ax
        mov     ds,ax

        push    dx                      ; jump to true entry point via RET
        ret

inlocal:
        add     dx,10                   ; point past prolog code
        push    dx                      ; jump into middle of prolog code
        ret

SetLocStack     endp

SetExtStack     proc    near
        pop     si                      ; get back saved si
        pop     bp                      ; get old sp
        pop     bx                      ; and old ss

        mov     ss,bx
        mov     sp,bp                   ; now set them up

        pop     ds                      ; standard epilog stuff
        pop     bp
        dec     bp

        db      0cah                    ;RETF n instruction
SESPat  dw      0

SetExtStack     endp

        subttl  Entry point definitions
        page
;
; mp module entry points
;
ENTRYPOINT MMpNew,    3
ENTRYPOINT MMpLoad,   2
ENTRYPOINT MMpFree,   2
;
; routines called by interface module
;
ENTRYPOINT MRgchVal, 6
ENTRYPOINT Mdecode,  2
ENTRYPOINT MEnter,   1
ENTRYPOINT Fill,     1
ENTRYPOINT Clear,    0
ENTRYPOINT Format,   1
ENTRYPOINT MCellsContract, 0
ENTRYPOINT MInsertBents,   8
ENTRYPOINT MSheetCut, 0
ENTRYPOINT MSheetCopy, 0
ENTRYPOINT MSheetPaste, 1
ENTRYPOINT MExeCut, 0
ENTRYPOINT MExePaste, 0
ENTRYPOINT CheckRecalc, 0
ENTRYPOINT recalc, 1
ENTRYPOINT MLoadSheet, 2
ENTRYPOINT MSaveSheet, 3
ENTRYPOINT MSortDialog, 4


_TEXT   ENDS

        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\mouse.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains the mouse definitions used by Windows Word.  The verbosity
of this file is due to the fact that although the resource compiler will accept
include files, it will do no algerbraic simplification. */

#define cMouseButton	1

#define fMouseKey	0x2000

#define fUp		0
#define fDown		1
#define fCommand	2
#define fOption		4
#define fShift		8

#define imbMove		0x2000

#if cMouseButton > 0
    #define fMouseButton1	0x2100
    #define imb1Up		0x2100	/* fMouseButton1 | fUp */
    #define imb1Dn		0x2101	/* fMouseButton1 | fDown */
    #define imb1ComUp		0x2102	/* fMouseButton1 | fCommand | fUp */
    #define imb1ComDn		0x2103	/* fMouseButton1 | fCommand | fDown */
    #define imb1OptUp		0x2104	/* fMouseButton1 | fOption | fUp */
    #define imb1OptDn		0x2105	/* fMouseButton1 | fOption | fDown */
    #define imb1ShfUp		0x2108	/* fMouseButton1 | fShift | fUp */
    #define imb1ShfDn		0x2109	/* fMouseButton1 | fShift | fDown */
    #define imb1ComOptUp	0x2106	/* fMouseButton1 | fCommand | fOption |
					   fUp */
    #define imb1ComOptDn	0x2107	/* fMouseButton1 | fCommand | fOption |
					   fDown */
    #define imb1ComShfUp	0x210a	/* fMouseButton1 | fCommand | fShift |
					   fUp */
    #define imb1ComShfDn	0x210b	/* fMouseButton1 | fCommand | fShift |
					   fDown */
    #define imb1OptShfUp	0x210c	/* fMouseButton1 | fOption | fShift |
					   fUp */
    #define imb1OptShfDn	0x210d	/* fMouseButton1 | fOption | fShift |
					   fDown */
    #define imb1ComOptShfUp	0x210e	/* fMouseButton1 | fCommand | fOption |
					   fShift | fUp */
    #define imb1ComOptShfDn	0x210f	/* fMouseButton1 | fCommand | fOption |
					   fShift | fDown */
#endif /* cMouseButtonButton > 0 */

#if cMouseButton > 1
    #define fMouseButton2	0x2200
    #define imb2Up		0x2200	/* fMouseButton2 | fUp */
    #define imb2Dn		0x2201	/* fMouseButton2 | fDown */
    #define imb2ComUp		0x2202	/* fMouseButton2 | fCommand | fUp */
    #define imb2ComDn		0x2203	/* fMouseButton2 | fCommand | fDown */
    #define imb2OptUp		0x2204	/* fMouseButton2 | fOption | fUp */
    #define imb2OptDn		0x2205	/* fMouseButton2 | fOption | fDown */
    #define imb2ShfUp		0x2208	/* fMouseButton2 | fShift | fUp */
    #define imb2ShfDn		0x2209	/* fMouseButton2 | fShift | fDown */
    #define imb2ComOptUp	0x2206	/* fMouseButton2 | fCommand | fOption |
					   fUp */
    #define imb2ComOptDn	0x2207	/* fMouseButton2 | fCommand | fOption |
					   fDown */
    #define imb2ComShfUp	0x220a	/* fMouseButton2 | fCommand | fShift |
					   fUp */
    #define imb2ComShfDn	0x220b	/* fMouseButton2 | fCommand | fShift |
					   fDown */
    #define imb2OptShfUp	0x220c	/* fMouseButton2 | fOption | fShift |
					   fUp */
    #define imb2OptShfDn	0x220d	/* fMouseButton2 | fOption | fShift |
					   fDown */
    #define imb2ComOptShfUp	0x220e	/* fMouseButton2 | fCommand | fOption |
					   fShift | fUp */
    #define imb2ComOptShfDn	0x220f	/* fMouseButton2 | fCommand | fOption |
					   fShift | fDown */
#endif /* cMouseButton > 1 */

#if cMouseButton > 2
    #define fMouseButton3	0x2400
    #define imb3Up		0x2400	/* fMouseButton3 | fUp */
    #define imb3Dn		0x2401	/* fMouseButton3 | fDown */
    #define imb3ComUp		0x2402	/* fMouseButton3 | fCommand | fUp */
    #define imb3ComDn		0x2403	/* fMouseButton3 | fCommand | fDown */
    #define imb3OptUp		0x2404	/* fMouseButton3 | fOption | fUp */
    #define imb3OptDn		0x2405	/* fMouseButton3 | fOption | fDown */
    #define imb3ShfUp		0x2408	/* fMouseButton3 | fShift | fUp */
    #define imb3ShfDn		0x2409	/* fMouseButton3 | fShift | fDown */
    #define imb3ComOptUp	0x2406	/* fMouseButton3 | fCommand | fOption |
					   fUp */
    #define imb3ComOptDn	0x2407	/* fMouseButton3 | fCommand | fOption |
					   fDown */
    #define imb3ComShfUp	0x240a	/* fMouseButton3 | fCommand | fShift |
					   fUp */
    #define imb3ComShfDn	0x240b	/* fMouseButton3 | fCommand | fShift |
					   fDown */
    #define imb3OptShfUp	0x240c	/* fMouseButton3 | fOption | fShift |
					   fUp */
    #define imb3OptShfDn	0x240d	/* fMouseButton3 | fOption | fShift |
					   fDown */
    #define imb3ComOptShfUp	0x240e	/* fMouseButton3 | fCommand | fOption |
					   fShift | fUp */
    #define imb3ComOptShfDn	0x240f	/* fMouseButton3 | fCommand | fOption |
					   fShift | fDown */
#endif /* cMouseButton > 2 */

#if cMouseButton > 3
    #define fMouseButton4	0x2800
    #define imb4Up		0x2800	/* fMouseButton4 | fUp */
    #define imb4Dn		0x2801	/* fMouseButton4 | fDown */
    #define imb4ComUp		0x2802	/* fMouseButton4 | fCommand | fUp */
    #define imb4ComDn		0x2803	/* fMouseButton4 | fCommand | fDown */
    #define imb4OptUp		0x2804	/* fMouseButton4 | fOption | fUp */
    #define imb4OptDn		0x2805	/* fMouseButton4 | fOption | fDown */
    #define imb4ShfUp		0x2808	/* fMouseButton4 | fShift | fUp */
    #define imb4ShfDn		0x2809	/* fMouseButton4 | fShift | fDown */
    #define imb4ComOptUp	0x2806	/* fMouseButton4 | fCommand | fOption |
					   fUp */
    #define imb4ComOptDn	0x2807	/* fMouseButton4 | fCommand | fOption |
					   fDown */
    #define imb4ComShfUp	0x280a	/* fMouseButton4 | fCommand | fShift |
					   fUp */
    #define imb4ComShfDn	0x280b	/* fMouseButton4 | fCommand | fShift |
					   fDown */
    #define imb4OptShfUp	0x280c	/* fMouseButton4 | fOption | fShift |
					   fUp */
    #define imb4OptShfDn	0x280d	/* fMouseButton4 | fOption | fShift |
					   fDown */
    #define imb4ComOptShfUp	0x280e	/* fMouseButton4 | fCommand | fOption |
					   fShift | fUp */
    #define imb4ComOptShfDn	0x280f	/* fMouseButton4 | fCommand | fOption |
					   fShift | fDown */
#endif /* cMouseButton > 3 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\mw.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* MW.H  --  Main header file for Windows Write */


/* some defines that used to be done in the makefile... 
   (started exceeding command line length!) */

#define OLE         /* Object Linking and Embedding 01/23/91 -- dougk 
		               Also defined in write.rc. */

#define PENWIN      /* pen windows: also defined in write.rc (6.21.91) v-dougk */

#define WIN30
/* #define WINVER 310 */  /* First convention was to use WIN30 defined above, 
                       but later switched to use of WINVER so it will be 
                       easier next time we change either the Windows or 
                       Write products  12/3/89..pault */

#define INTL        /* This MUST be turned on (even for the Z version now) */
#define CRLF        /* MS-DOS defines the carriage-return/line-feed sequence */

/* Major intermodule defines */

#define SMFONT          /* SmartFont? */
#define NOMORESIZEBOX   /* The CUA spec has changed for Win30 and
                           we no longer have a special size box in
                           the lower-right corner of the Write window */
#define NEWFONTENUM     /* So many problems have come up that I'm
                           revamping a large part of the font enumeration
                           code and it'll be marked by this.  Among others:
                           -- removed font filtering based on aspect ratio,
                           -- don't disallow fonts not in ANSI_CHARSET, etc.
                        ..pault */
#define SYSENDMARK      /* This enables code for putting the end mark
                           in the system font -- previously Kanji only */
#ifndef NEWFONTENUM
 #define INEFFLOCKDOWN
#endif

#undef  MSDOS
#undef  M_I86MM
#undef  M_I86

#ifndef SAND
#define REG1 register
#define REG2 register
#endif /* not SAND */

#define true	1
#define false	0
#define fTrue	true
#define fFalse	false

#ifdef SAND
/*  already defined in windows.h */
#define NULL	0
#endif /* SAND */

#define LNULL	0L

#define bNil	(-1)
#define iNil	(-1)
#define valNil	(-1)

#define cchINT	(sizeof (int))

#define BStructMember( s, field )  ((unsigned)&(((struct s *)(0))->field))


#define hOverflow	(-1)

#define ivalMax 	24
#define mrgNil		(-32766)

#define cchMaxSz	350
typedef long typeCP;
typedef long typeFC;
typedef unsigned typePN;
typedef unsigned typeTS;		/* TS = time stamp */

#ifdef CRLF
#define ccpEol	2
#else /* not CRLF */
#define ccpEol	1
#endif /* not CRLF */

#ifdef SAND
typedef char CHAR;
#else /* not SAND */
typedef unsigned char CHAR;
#endif /* not SAND */

typedef CHAR *PCH;
typedef CHAR far *LPCH;
#if WINVER >= 0x300
typedef CHAR huge *HPCH;    /* this is a far but C generates extra code
                               to make sure segment arithmetic is done
                               correctly, esp. important in protect mode.
                               added for handling >64k clipboard text.
                               apologies re apparently odd hungarian ..pault */
#endif

#ifdef SAND
/* ifdef out because typedef unsigned char BYTE in windows.h */
#define BYTE unsigned char
#endif /* SAND */

#define VAL	int
#define MD	int
#define BOOL	int
#define IDFLD	int
#define IDSTR	int
#define IDPMT	int
#define CC	int

#ifdef WIN30
/* DialogBox has been fixed so it automatically brings up the hourglass! */

#ifdef DBCS /* was in KKBUGFIX */
 // [yutakan:05/17/91] 'c' can be null at initialize.
#define OurDialogBox(a,b,c,d) DialogBox(a,b,((c==(HWND)NULL)?hParentWw:c),d)
#else
#define OurDialogBox(a,b,c,d) DialogBox(a,b,c,d)
#endif	/* DBCS */

#endif

/* bltsz: copy only up to terminator, inclusive
   4/20/89 NOTE: using CchCopySz kills previously returned value of a psz! */
#define bltsz(pFrom, pTo) CchCopySz((pFrom), (pTo))

/* bltszx: far version of above */
#define bltszx(lpFrom, lpTo) \
        bltbx((LPCH) (lpFrom), (LPCH) (lpTo), IchIndexLp((LPCH) (lpFrom), '\0')+1)

/* bltszLimit: added 4/20/89 to assure safe copying of strings which just 
   might not have fit the terminating zero within their buffer space ..pt */
#define bltszLimit(pFrom, pTo, cchMax) \
        bltbyte((pFrom), (pTo), min(cchMax, CchSz(pFrom)))

/* Extra-verbose diagnostic debugging output... */

#ifdef DIAG
#define Diag(s) s
#else
#define Diag(s)
#endif

#define cwVal	(1)

#define CwFromCch(cch)		(((cch) + sizeof (int) - 1) / sizeof (int))
#define FNoHeap(h)		((int)(h) == hOverflow)
#define iabs(w) 		((w) < 0 ? (-(w)) : (w))
#define low(ch) 		((ch) & 0377)
#define walign(pb)		{if ((unsigned)(pb) & 1) \
				  (*((unsigned *)&(pb)))++;}
#define FtcFromPchp(pchp)	(((pchp)->ftcXtra << 6) | (pchp)->ftc)
#define WFromCh(ch)		((ch) - '0')

#ifndef OURHEAP
#define FreezeHp()		LocalFreeze(0)
#define MeltHp()		LocalMelt(0)
#else
#ifdef DEBUG
#define FreezeHp()		{ extern int cHpFreeze; ++cHpFreeze; }
#define MeltHp()		{ extern int cHpFreeze; --cHpFreeze; }
#else /* not DEBUG */
#define FreezeHp()
#define MeltHp()
#endif /* not DEBUG */
#endif


#define HideSel()

typeCP CpMacText(), CpFirstFtn(), CpRefFromFtn(), CpFromDlTc(),
	CpBeginLine(), CpInsertFtn(), CpRSearchSz(),
	CpLimSty(), CpFirstSty(), CpGetCache(), CpHintCache(),
	CpEdge(), CpMax(), CpMin();

typeFC FcParaFirst(), FcParaLim(), FcWScratch(), FcNewSect();
typeFC (**HgfcCollect())[];
CHAR (**HszCreate())[];


#ifndef OURHEAP
#define FreeH(h)		((FNoHeap(h) || ((int)h == 0)) ? NULL : LocalFree((HANDLE)h))
#endif

#ifdef DEBUG
#define Assert(f)		_Assert(__FILE__, __LINE__, f)
#define panic() 		Assert(false)
extern _Assert(PCH pch, int line, BOOL f);
#else /* not DEBUG */
#define Assert(f)
#endif /* DEBUG */

#define cbReserve  (1024) /* reserved in our local heap */
			  /* for windows to create dialog boxes */

/* The flag KINTL is used to share some code between the international
   and the kanji Write. */

#ifdef INTL
#define KINTL
#endif

extern void Error(IDPMT idpmt);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\obj.c ===
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/*
    Some comments on how the Obj subsystem for handling OLE objects
    is herein implemented.

        Written (2.14.92) by v-dougk (Doug Kent)

    Metafile and bitmaps have always been described in the Write
    file format (and in memory) by a PICINFOX structure.  For OLE
    objects the PICINFOX structure is replaced by the OBJPICINFO
    structure of the same size.

    OBJPICINFO has a field (lpObjInfo) which is a pointer to another
    structure (OBJINFO) which is globally allocated. This structure contains
    info about the object which doesn't need to be stored in the file 
    with the object data.

    The object data as obtained from OleSaveToStream() is stored in the
    Write file format immediately following the OBJPICINFO structure.
    Object data is not actually written to the file until the user
    does a File.Save.  For a newly-created object, the OBJPICINFO structure
    is the only data saved until that point.  If the object is an
    unfinished one from an Insert.Object operation, then not even the
    OBJPICINFO structure is saved.  In that case the object is solely
    represented by the OBJINFO structure until an OLE_CHANGED or OLE_SAVED
    is received. Then an OBJPICINFO structure is saved to the file.

    The OBJINFO structures are allocated for all objects when the file
    is opened.  This involves writing new OBJPICINFO data to the doc
    (with the new lpObjInfo values) on open.  This makes the doc dirty,
    but we reset the doc dirty flag to make it undirty.

    The lpObjInfo pointers are passed to the OLE create functions for the
    lpClient value.  This is a crucial aspect of the implementation as
    the CallBack function passes back this pointer, allowing us to identify
    the object, and query and set its state without having to access
    the file on disk.  As I was not aware of the importance (or existence)
    of this feature until late, it was patched in.  It is not perfectly
    implemented and could use some polishing.

    As much as I tried to seamlessly integrate objects into the existing
    Write architecture, there have been glitches:

    1)  Writing into the doc as the visible page is being drawn
        (See ObjLoadObjectInDoc() in DisplayGraphics() in picture.c)
        tends to mess things up.  The drawing code (namely
        UpdateWw(), expects certain state variables (like the
        pedls and the pwwds) to be constant during a single call
        to UpdateWw().  Writing into the doc alters those variables.
        Workaround uses vfInvalid in ObjSetPicInfo().
    2)  Write does not expect data to be entered other than in data
        currently being displayed on the screen, whereas we
        frequently operate on objects all over the doc (ObjEnumInDoc()).
        Workaround is to use ObjCachePara() instead of CachePara().
    3)  Asynchronicity wreaks havoc on Write.  Since every action
        in Write is affected by the current state, if an action
        occurs out of normal sequence, i.e., occurs in an improper
        state, then blamo big trouble.  When events happen
        recursively state variables cannot be restored without a
        state 'Pushing and Popping' mechanism.

        This is especially true for 'cp' variables.  cp's are pointers
        into the document and global cp state variables are ubiguitous.
        Global cp variables include the selection and undo variables
        mentioned above, plus many others.  See ObjPopParms() and
        ObjPushParms().

        While waiting for an object to release (see WMsgLoop()) we
        stub out WM_PAINT message responses using the nBlocking variable.
        Between document opening and closing we set the doc fDisplayable
        flag to FALSE.  NOTE: we ought to do something like this in
        IDPromptBoxSz() -- many of the asynchronicity problems occur
        when calling MessageBox() (which yields).

        Hopefully OLE 2.0 will implement an OleBlockClient() mechanism.


    Notes on Asynchronicity:  Ole calls that require communication with the
    server may be asynchronous.  The following rules apply:

    1)  Only one asynchronous call at a time may be made for a given object.
    2)  The OleCreate* calls must complete before some synchronous
        calls such as OleGetData().
    3)  All asynchronous activity must be complete before calling
        OleRevokeClientDoc.

    Asynchronous calls return OLE_WAIT_FOR_RELEASE.  You don't know
    that an asynchronous call has completed until the CallBack function
    receives an OLE_RELEASE message for that object. If you ignore this
    and issue an offending call for the object, the call will
    return OLE_BUSY.

    We deal with these rules by calling OleQueryReleaseStatus to
    determine whether an object is busy before making any Ole call
    (see ObjWaitForObject()). If the object is busy then we spin until the
    object is not busy.  After 6 seconds we put up a msg box which, depending
    on the flags we set, may allow the user to stop waiting and cancel the
    operation (see notes in fnObjWait()).

    Note that the OleCreate calls can fail in 3 different ways that aren't 
    documented (not at this point anyway).

    1)  The call returns error immediately.  In this case you mustn't depend
        on the returned lpObject to be NULL.  If it is not NULL, ignore
        it -- it needn't be deleted.

    2)  The call returns OLE_WAIT_FOR_RELEASE and eventually you get an
        OLE_RELEASE and OleQueryReleaseError() is != OLE_OK.  In
        this case you gotta delete the lpObject that was returned by
        the original call.

    3)  The call completes, but you receive OLE_CLOSED on the object
        without receiving OLE_CHANGED.  This indicates that for some
        reason the native data could not be obtained from the server.
        The object must be deleted in this case.  Write currently
        handles this properly for Insert.Object (OleCreate), but not
        for other cases (OleCreateFromFile,...).

    The Links dialog should be optimized so that it doesn't require that all 
    links be loaded at once.  The Printing process could use the same
    optimization.

    Cutting, copying and pasting works as follows.  Any object that exists
    in docScrap (where clipboard contents are stored) must be a unique
    object.  Thus when we copy we clone any objects in the selection.
    When we cut we needn't clone since the objects have been deleted
    from the document.  When we paste we clone.

    Deleted objects and cut objects that get purged from docScrap (and
    therefore become effectively deleted), are not actually deleted right
    away.  These objects get shovelled into docUndo for access by the
    Undo function.  Even when the objects get purged from docUndo
    (by another undoable operation), they are still not deleted.  These
    objects never finally get deleted until ObjCollectGarbage() is
    called.  This function is called on a timer about every 5 minutes.
    It enumerates all documents and deletes any objects not found.

    The reason for not deleting objects right away is that it would've
    hurt performance to check the contents of docUndo and docScrap
    every time they change.  It also would've been a nasty programming job
    since those change points are not localized physically or logically.
*/

#include "windows.h"
#include "mw.h"
#include "winddefs.h"
#include "obj.h"
#include "menudefs.h"
#include "cmddefs.h"
#include "str.h"
#include "objreg.h"
#include "docdefs.h"
#include "editdefs.h"
#include "propdefs.h"
#include "wwdefs.h"
#include "filedefs.h"
#include <shellapi.h>
#include <stdlib.h>

extern struct FCB (**hpfnfcb)[];
HANDLE hlpObjInfo = NULL;       // array of allocated ObjInfos
LPLPOBJINFO lplpObjInfo = NULL; // array of allocated ObjInfos
static  BOOL        bSavedDoc=FALSE;
static  BOOL        bDontFix=FALSE;
int                 vcObjects=0;  // count in doc. Note limit of 32K!!!
BOOL                fOleEnabled=FALSE;
BOOL                bKillMe=FALSE;
OLECLIENTVTBL       clientTbl = {NULL};
OLESTREAMVTBL       streamTbl;
//LPOLECLIENT         lpclient = NULL;
LPOLESTREAM         lpStream = NULL;
OLECLIPFORMAT       vcfLink = 0;
OLECLIPFORMAT       vcfOwnerLink = 0;
OLECLIPFORMAT       vcfNative = 0;
int                 cOleWait = 0;
HWND                hwndWait=NULL;
BOOL                vbObjLinkOnly;
int           vObjVerb;
OBJECTTYPE          votObjSelType;
ATOM                aNewName=NULL;
ATOM                aOldName=NULL;
LHCLIENTDOC         lhClientDoc=NULL;
BOOL                bLinkProps=FALSE;
FARPROC             lpfnLinkProps=NULL;
FARPROC             lpfnInvalidLink=NULL;
FARPROC             lpfnInsertNew=NULL;
FARPROC             lpfnWaitForObject=NULL;
FARPROC             lpfnPasteSpecial=NULL;
static BOOL WMsgLoop ( BOOL fExitOnIdle, BOOL fIgnoreInput, BOOL bOK2Cancel, LPOLEOBJECT lpObject);
BOOL ObjFreeAllObjInfos();
static BOOL ObjUpdateAllOpenObjects(void);

int nBlocking=0; // block WM_PAINTS if > 0
static  int        nWaitingForObject=0; // in ObjWaitForObject()
int nGarbageTime=0;

extern struct UAB       vuab;
extern  HCURSOR     vhcIBeam;
extern  HCURSOR     vhcHourGlass;
extern int          docUndo;
extern struct PAP      vpapAbs;
extern struct DOD (**hpdocdod)[];
extern struct WWD       rgwwd[];
extern BOOL ferror;
extern int vfDeactByOtherApp;
extern HCURSOR      vhcArrow;
extern HANDLE hStdTargetDevice;
extern typeCP cpMinCur,cpMacCur;

BOOL fPropsError=FALSE;
static  HANDLE      hobjStream = NULL;
char        szOPropMenuStr[21];
char        szPPropMenuStr[21];
int   ObjPlayEdit=OLEVERB_PRIMARY;

int FAR PASCAL CallBack(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);

/****************************************************************/
/******************** STARTUP/SHUTDOWN **************************/
/****************************************************************/
BOOL ObjInit(HANDLE hInstance)
{
    int bRetval=TRUE;

    vcfLink      = RegisterClipboardFormat("ObjectLink");
    vcfNative    = RegisterClipboardFormat("Native");
    vcfOwnerLink = RegisterClipboardFormat("OwnerLink");

    if ((clientTbl.CallBack = MakeProcInstance(CallBack, hInstance)) == NULL)
        goto error;

    if ((hobjStream = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof(OLESTREAM))) == NULL)
        goto error;

    ObjSetTargetDevice(FALSE);

    if((lpStream = (LPOLESTREAM)(GlobalLock(hobjStream))) == NULL)
        goto error;
    else
    {
        lpStream->lpstbl = (LPOLESTREAMVTBL)&streamTbl;
        lpStream->lpstbl->Get       =  MakeProcInstance( (FARPROC)BufReadStream, hInstance );
        lpStream->lpstbl->Put       =  MakeProcInstance( (FARPROC)BufWriteStream, hInstance);
        //lpStream->lpstbl->Seek      =  MakeProcInstance( (FARPROC)BufPosStream, hInstance);
    }

    /* Initialize the registration database */
    RegInit(hINSTANCE);

    /* commdlg stuff */
    OfnInit(hInstance);

    /* dragdrop */
    DragAcceptFiles(hMAINWINDOW,TRUE);

    if ((hlpObjInfo = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, sizeof(LPOBJINFO))) == NULL)
        goto error;

    if ((lplpObjInfo = (LPLPOBJINFO)GlobalLock(hlpObjInfo)) == NULL)
        goto error;

    if (LoadString(hInstance, IDSTRMenuVerb, szOPropMenuStr, sizeof(szOPropMenuStr)) == NULL)
        goto error;

    if (LoadString(hInstance, IDSTRMenuVerbP, szPPropMenuStr, sizeof(szPPropMenuStr)) == NULL)
        goto error;

#if !defined(SMALL_OLE_UI)
    lpfnLinkProps   = MakeProcInstance(fnProperties, hInstance);
#endif
    lpfnInvalidLink = MakeProcInstance(fnInvalidLink, hInstance);
    lpfnInsertNew   = MakeProcInstance(fnInsertNew, hInstance);
    lpfnWaitForObject = MakeProcInstance(fnObjWait, hInstance);
    lpfnPasteSpecial = MakeProcInstance(fnPasteSpecial, hInstance);

    goto end;

    error:
    bRetval = FALSE;
    ObjShutDown();

    end:
    return bRetval;
}

void ObjShutDown(void)
{
    extern HANDLE vhMenu;

#ifdef KKBUGFIX
//if we close write.exe when write.exe is iconic. GetSubMenu() return NULL
    if (vhMenu) {
		HMENU	hsMenu;
        hsMenu = GetSubMenu(vhMenu,EDIT);
		if(hsMenu)
	        DeleteMenu(hsMenu, EDITMENUPOS, MF_BYPOSITION);
	}
#else
    if (vhMenu)
        DeleteMenu(GetSubMenu(vhMenu,EDIT), EDITMENUPOS, MF_BYPOSITION);
#endif

    if (hobjStream)
    {
        if (lpStream)
            if (lpStream->lpstbl)
            {
                if (lpStream->lpstbl->Get)
                    FreeProcInstance((FARPROC)(lpStream->lpstbl->Get));
                if (lpStream->lpstbl->Put)
                    FreeProcInstance((FARPROC)(lpStream->lpstbl->Put));
            }

        GlobalUnlock(hobjStream);
        if (lpStream)
            GlobalFree(hobjStream);
    }

    if (hStdTargetDevice)
        GlobalFree(hStdTargetDevice);

    if (clientTbl.CallBack)
        FreeProcInstance(clientTbl.CallBack);

    if (lpfnLinkProps)
        FreeProcInstance(lpfnLinkProps);
    if (lpfnInvalidLink)
        FreeProcInstance(lpfnInvalidLink);
    if (lpfnInsertNew)
        FreeProcInstance(lpfnInsertNew);
    if (lpfnWaitForObject)
        FreeProcInstance(lpfnWaitForObject);
    if (lpfnPasteSpecial)
        FreeProcInstance(lpfnPasteSpecial);

    RegTerm();

    /* dragdrop */
    DragAcceptFiles(hMAINWINDOW,FALSE);

    /* make sure all OInfo structures are freed */
    ObjFreeAllObjInfos();

    if (hlpObjInfo)
        GlobalFree(hlpObjInfo);
}

#if 0
BOOL ObjFreeObjInfo(OBJPICINFO *pPicInfo)
/* return whether an error */
{
    LPLPOBJINFO lplpObjTmp;

    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return FALSE;

    /* find slot in lplpObjInfo and NULL it out */
    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
        if (*lplpObjTmp == lpOBJ_QUERY_INFO(pPicInfo))
        {
            lpOBJ_QUERY_INFO(pPicInfo) = NULL;

            return ObjDeleteObjInfo(*lplpObjTmp);
        }

    Assert(0); // make sure we found it
    return TRUE;
}
#endif

BOOL ObjUpdateFromObjInfo(OBJPICINFO *pPicInfo)
/* update picinfo from objinfo */
{
    char *pdumb;
    szOBJNAME szObjName;
    LPOBJINFO lpObjInfo = lpOBJ_QUERY_INFO(pPicInfo);

    if (lpObjInfo == NULL)
        return TRUE;

    /* we won't do data size, that'll get set in SaveObjectToDoc */

    /* object name */
    if (lpObjInfo->aObjName)
    {
        GetAtomName(lpObjInfo->aObjName,szObjName,sizeof(szObjName));
        pPicInfo->dwObjNum = strtoul(szObjName,&pdumb,16);
    }

    /* object type */
    pPicInfo->objectType = lpObjInfo->objectType;

    return FALSE;
}

BOOL ObjUpdateFromPicInfo(OBJPICINFO *pPicInfo,szOBJNAME szObjName)
/* update objinfo from picInfo, return szObjName */
{
    char *pdumb;
    LPOBJINFO lpObjInfo = lpOBJ_QUERY_INFO(pPicInfo);
    szOBJNAME szTmp;

    if (lpObjInfo == NULL)
        return TRUE;

    /* object name */
    wsprintf(szTmp, "%lx", dwOBJ_QUERY_OBJECT_NUM(pPicInfo));
    lpObjInfo->aObjName = AddAtom(szTmp);

    if (szObjName)
        lstrcpy(szObjName,szTmp);

    /* object type */
     lpObjInfo->objectType = pPicInfo->objectType;

    return FALSE;
}

BOOL ObjFreeObjInfoWithObject(LPOLEOBJECT lpObject)
/**
    Given lpObject, find lpObjInfo for that object and free the ObjInfo.
    Return whether an error.
    This deletes objects if not already deleted.
  **/
{
    LPLPOBJINFO lplpObjTmp;

    /* find slot in lplpObjInfo, free it and NULL it out */
    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
    {
        if ((*lplpObjTmp)->lpobject == lpObject)
            return ObjDeleteObjInfo(*lplpObjTmp);
    }

#ifdef DEBUG
    OutputDebugString("No OInfo for object\n\r");
#endif
    return TRUE;
}

BOOL ObjDeleteObjInfo(LPOBJINFO lpOInfo)
{
    WORD wSegment;
    HANDLE hInfo;
    LPLPOBJINFO lplpObjTmp;

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Nulling objinfo slot.\n\r");
#endif

    /* find slot in lplpObjInfo, free it and NULL it out */
    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
    {
        if (*lplpObjTmp == lpOInfo)
            break;
    }

    if (lplpObjTmp == NULL) // hmmm, shouldn't happen
    {
        Assert(0);
        return NULL;
    }

    if ((*lplpObjTmp)->aName)
        DeleteAtom((*lplpObjTmp)->aName);
    if ((*lplpObjTmp)->aObjName)
        DeleteAtom((*lplpObjTmp)->aObjName);
    wSegment = HIWORD(((DWORD)*lplpObjTmp));

    *lplpObjTmp = NULL;

    hInfo = GlobalHandle(wSegment) & 0xFFFFL;
    return (BOOL)GlobalFree(hInfo);
}

LPOBJINFO ObjGetObjInfo(szOBJNAME szObjName)
/* allocate objinfo, return szObjName if !NULL */
{
    HANDLE hObjInfo=NULL;
    DWORD dwCount,dwCountSave;
    LPLPOBJINFO lplpObjTmp;
    LPOBJINFO lpObjInfoNew=NULL;

    if (lplpObjInfo == NULL)
        return NULL;

    if ((hObjInfo = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, sizeof(OBJINFO))) == NULL)
    {
        /* gotta recover better here !!! (7.5.91) v-dougk */
        Error(IDPMTCantRunM);
        return NULL;
    }

    if ((lpObjInfoNew = (LPOBJINFO)GlobalLock(hObjInfo)) == NULL)
    {
        /* gotta recover better here !!! (7.5.91) v-dougk */
        Error(IDPMTCantRunM);
        GlobalFree(hObjInfo);
        return NULL;
    }

    /* now add to lplpObjInfo array */
    dwCount = dwCountSave = GlobalSize(hlpObjInfo) / sizeof(LPLPOBJINFO);

    /* find if any NULL slots */
    for (lplpObjTmp = lplpObjInfo; dwCount ; --dwCount, ++lplpObjTmp)
        if (*lplpObjTmp == NULL)
            break;

    if (dwCount) // then found a NULL slot
    {
#ifdef DEBUG
        OutputDebugString( (LPSTR) "Adding objinfo to empty slot.\n\r");
#endif
        *lplpObjTmp = lpObjInfoNew;
    }
    else // gotta reallocate
    {
        ++dwCountSave;
        if ((hlpObjInfo = GlobalRealloc(hlpObjInfo,dwCountSave * sizeof(LPLPOBJINFO),GMEM_MOVEABLE|GMEM_ZEROINIT)) == NULL)
        {
            /* gotta recover better here !!! (7.5.91) v-dougk */
            GlobalFree(hObjInfo);
            lplpObjInfo = NULL;
            Error(IDPMTCantRunM);
            return NULL;
        }
        if ((lplpObjInfo = (LPLPOBJINFO)GlobalLock(hlpObjInfo)) == NULL)
        {
            /* gotta recover better here !!! (7.5.91) v-dougk */
            GlobalFree(hObjInfo);
            Error(IDPMTCantRunM);
            return NULL;
        }

#ifdef DEBUG
        OutputDebugString( (LPSTR) "Adding objinfo to new slot.\n\r");
#endif
        /* put new gal in last slot */
        lplpObjInfo[dwCountSave-1] = lpObjInfoNew;
    }

    if (szObjName)
        /* make object's unique name */
        ObjMakeObjectName(lpObjInfoNew, szObjName);
    else
        lpObjInfoNew->aObjName = NULL;

    /* this is a requirement of the OLECLIENT structure */
    lpObjInfoNew->lpvtbl = (LPOLECLIENTVTBL)&clientTbl;

    return lpObjInfoNew;
}

BOOL ObjAllocObjInfo(OBJPICINFO *pPicInfo, typeCP cpParaStart, OBJECTTYPE ot, BOOL bInitPicinfo, szOBJNAME szObjName)
/* return whether an error */
{
    if (lpOBJ_QUERY_INFO(pPicInfo) = ObjGetObjInfo(NULL))
    {
        //cpOBJ_QUERY_WHERE(pPicInfo) = cpParaStart;

        if (bInitPicinfo)
        /* new object, make a new szObjName, use passed-in ot */
        {
            /* get new values and put into ObjInfo */
            if (szObjName)
                ObjMakeObjectName(lpOBJ_QUERY_INFO(pPicInfo), szObjName);

            lpOBJ_QUERY_INFO(pPicInfo)->objectType = ot;

            /* this'll take values from ObjInfo and put into PicInfo */
            return GimmeNewPicinfo(pPicInfo,lpOBJ_QUERY_INFO(pPicInfo));
        }
        else // picInfo already has values.  Put 'em into ObjInfo
        {
            ObjUpdateFromPicInfo(pPicInfo,szObjName);
            return FALSE;
        }
    }
    else
        return TRUE;

}


BOOL ObjCloneObjInfo(OBJPICINFO *pPicInfo, typeCP cpParaStart, szOBJNAME szObjName)
/* clone pPicInfo->lpObjInfo */
{
    if (ObjCopyObjInfo(lpOBJ_QUERY_INFO(pPicInfo),
                      &lpOBJ_QUERY_INFO(pPicInfo),
                      szObjName))
            return TRUE;

    return FALSE;
}

BOOL ObjCopyObjInfo(LPOBJINFO lpOldObjInfo,
                         LPLPOBJINFO lplpNewObjInfo,
                         szOBJNAME szObjName)
/* lpobject field is NULL'd!  Atoms are cloned, new unique object name */
{
    char szTmp[180];

    if (lplpObjInfo == NULL)
        return TRUE;

    if ((*lplpNewObjInfo = ObjGetObjInfo(NULL)) == NULL)
        return TRUE;

    /* copy old stuff over to new */
    /* note new will inherit old lpclone if there is one */
    **lplpNewObjInfo = *lpOldObjInfo;

    (*lplpNewObjInfo)->lpobject = NULL;

    /* clone the utility (class or whatever) name */
    if (lpOldObjInfo->aName)
    {
        GetAtomName(lpOldObjInfo->aName,szTmp,sizeof(szTmp));
        (*lplpNewObjInfo)->aName = AddAtom(szTmp);
    }

    /* make a new ObjName if requested */
    if (szObjName)
        /* make object's unique name */
        ObjMakeObjectName(*lplpNewObjInfo, szObjName);
    else
        (*lplpNewObjInfo)->aObjName = NULL;

    return FALSE;
}

BOOL ObjFreeAllObjInfos()
/**
    Return whether an error.
  **/
{
    WORD wSegment;
    HANDLE hInfo;
    DWORD dwCount;
    LPLPOBJINFO lplpObjTmp;

    if (lplpObjInfo == NULL)
        return FALSE;

    /* find slot in lplpObjInfo, free it and NULL it out */
    dwCount = GlobalSize(hlpObjInfo) / sizeof(LPLPOBJINFO);
    for (lplpObjTmp = lplpObjInfo; dwCount ; --dwCount, ++lplpObjTmp)
    {
        if (*lplpObjTmp)
        {
#ifdef DEBUG
            OutputDebugString( (LPSTR) "Nulling objinfo slot (from object).\n\r");
#endif
            /** Delete info about this object.  This assumes picinfo will not
                be reused unless via file.open. **/
            if ((*lplpObjTmp)->aName)
                DeleteAtom((*lplpObjTmp)->aName);
            if ((*lplpObjTmp)->aObjName)
                DeleteAtom((*lplpObjTmp)->aObjName);
            wSegment = HIWORD(((DWORD)*lplpObjTmp));
            *lplpObjTmp = NULL;
            hInfo = GlobalHandle(wSegment) & 0xFFFF;
            GlobalFree(hInfo);
        }
    }
    return FALSE;
}

LPLPOBJINFO EnumObjInfos(LPLPOBJINFO lplpObjInfoPrev)
{
    LPLPOBJINFO lplpOIMax;

    if (lplpObjInfo == NULL)
        return NULL;

    if (lplpObjInfoPrev == NULL) // starting out
        lplpObjInfoPrev = lplpObjInfo;
    else
        ++lplpObjInfoPrev;

    lplpOIMax = (LPLPOBJINFO)((LPSTR)lplpObjInfo + GlobalSize(hlpObjInfo));

    for ( ; lplpObjInfoPrev < lplpOIMax ; ++lplpObjInfoPrev)
    {
        if (*lplpObjInfoPrev == NULL)
            continue;
        else
            return lplpObjInfoPrev;
    }
    return NULL;
}


void ObjCollectGarbage()
{
    LPLPOBJINFO lplpObjTmp;
    int nObjCount=0,doc;

    if (nBlocking)
        return;

    StartLongOp();

#ifdef DEBUG
    OutputDebugString("Collecting Garbage...\n\r");
#endif

    ObjPushParms(docCur);

    /* mark all as not in doc */
    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
    {
        ++nObjCount;
        (*lplpObjTmp)->fInDoc = FALSE;
    }

    if (nObjCount == 0)
        goto end;

    /* mark in doc if in */
    /* go through all the docs */
    for (doc = 0; doc < docMac; doc++)
    {
        OBJPICINFO picInfo;
        typeCP cpPicInfo;

        if ((doc != docNil) && (**hpdocdod)[doc].hpctb)
        for (cpPicInfo = cpNil;
            ObjPicEnumInRange(&picInfo,doc,cp0,CpMacText(doc),&cpPicInfo);
            )
            {
                if (lpOBJ_QUERY_INFO(&picInfo) == NULL)
                    continue;

                fOBJ_INDOC(&picInfo) = TRUE;
            }
    }


    /* if not in doc delete */
    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
    {
        if (!(*lplpObjTmp)->fInDoc)
            ObjDeleteObject(*lplpObjTmp,TRUE);
    }

    end:

    /* 'til next time... */
    nGarbageTime=0;

    ObjPopParms(TRUE);

    EndLongOp(vhcArrow);
}

/****************************************************************/
/********************** OLE DOCUMENT FUNCTIONS ******************/
/****************************************************************/
BOOL ObjClosingDoc(int docOld,LPSTR szNewDocName)
/**
    Clone objects in docScrap from docOld into szNewDocName.
    Release all objects in docOld.
    Return whether an error occurred.  Error indicates to caller that
        a new document cannot be opened.  No error indicates to caller
        that a new document *must* be reopened via ObjOpenedDoc() (because
        all lpObjInfos have been deleted).
    If szNewDocName is NULL then don't make a new doc. 
    Important point to remember is that for objects whose data has never
        been saved, there is no recovery from release/delete in an error
        condition.  There is no state to which we can recover in an
        error condition.  This function should not be allowed to exit
        on the basis of a busy object.
 **/
{
    char szTitle[120];
    BOOL bRetval=FALSE;
    OBJPICINFO picInfo;
    typeCP cpPicInfo;
    extern int              vfScrapIsPic;
    extern int              docScrap;
    extern int              vfOwnClipboard;
    extern CHAR szUntitled[];
    LPOBJINFO lpObjInfo;
    LPOLEOBJECT lpObject;
    LHCLIENTDOC lhNewClientDoc=NULL;
    OLESTATUS olestat;
    LPLPOBJINFO lplpObjTmp;

    if (!lhClientDoc)
        return FALSE;

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Closing Doc\n\r");
#endif

    /* ensure all async ops are complete */
    if (FinishAllAsyncs(TRUE))
    {
        UPDATE_INVALID();
        return TRUE;
    }

    ++nBlocking; // inhibit repaints

    /* drag drop */
    DragAcceptFiles(hDOCWINDOW,FALSE);

    if (szNewDocName)
    /* then we'll be opening another doc soon, so plan ahead */
    {
        if (!szNewDocName[0])
            lstrcpy((LPSTR)szTitle,(LPSTR)szUntitled);
        else
            lstrcpy((LPSTR)szTitle,szNewDocName);

        if (ObjError(OleRegisterClientDoc(szDOCCLASS,szTitle,0L,&lhNewClientDoc)))
        {
            lhNewClientDoc = NULL; // just in case OLE flatlined
            goto error;
        }

        /**
            Clone any objects from docScrap into new doc.  Since this
            requires knowing the name of the new doc you
            would think it should go into ObjOpeningDoc, but it can't.
            You have to do it *before* releasing the objects below!
            (Because OleEnumObjects keys off of the lhClientDoc).
        **/
        ObjCloneScrapToNewDoc(lhNewClientDoc);

        /* ensure all async ops are complete */
        if (FinishAllAsyncs(FALSE))
            goto error;
    }


    /* release objects in docOld (assume not busy) */
    if ((**hpdocdod)[docOld].fFormatted)
    {
        /* objects are being released/deleted, don't allow display */
        (**hpdocdod)[docOld].fDisplayable = FALSE;

        for (cpPicInfo = cpNil;
            ObjPicEnumInRange(&picInfo,docOld,cp0,CpMacText(docOld),&cpPicInfo);
            )
        {
            lpObjInfo=lpOBJ_QUERY_INFO(&picInfo);

            if (lpObjInfo == NULL)
                continue;

            if (lpObjInfo->lpobject == NULL)
                continue;

    #ifdef DEBUG
            OutputDebugString( (LPSTR) "Releasing object\n\r");
    #endif

            switch (olestat = OleRelease(lpObjInfo->lpobject))
            {
                case OLE_OK:
                    lpObjInfo->lpobject = NULL;
                break;
                case OLE_WAIT_FOR_RELEASE:
                    lpObjInfo->fCompleteAsync = TRUE;
                    /* No cancel allowed! */
                    if (ObjWaitForObject(lpObjInfo,FALSE))
                        goto error;
                    else
                        lpObjInfo->lpobject = NULL;
                break;
            }
        }
    }

    if (FinishAllAsyncs(FALSE)) // necessary?
        goto error;

    /* delete remaining objects in lhClientDoc (assume not busy) */
    lpObject=NULL;
    do
    {
        lpObject=NULL;
        OleEnumObjects(lhClientDoc,&lpObject);
        if (lpObject)
        {
            lpObjInfo = GetObjInfo(lpObject);
            switch (olestat = OleDelete(lpObject))
            {
                case OLE_OK:
                    if (lpObjInfo)
                        lpObjInfo->lpobject = NULL;
                break;
                case OLE_WAIT_FOR_RELEASE:
                    if (lpObjInfo)
                    {
                        lpObjInfo->fCompleteAsync = TRUE;
                        /* no cancel allowed! */
                        if (ObjWaitForObject(lpObjInfo,FALSE))
                            goto error;
                        else
                            lpObjInfo->lpobject = NULL;
                    }
                    else
                        FinishUp();
                break;
                default:
                    ObjError(olestat);
                    goto error;
            }
        }
    }
    while (lpObject);

    /* say goodbye to old doc if there was one */
    if (!bSavedDoc)
    {
        ObjRevertedDoc();
        bSavedDoc=FALSE;
    }

#ifdef DEBUG
    OutputDebugString("Revoking doc\n\r");
#endif

    if (ObjError(OleRevokeClientDoc(lhClientDoc)))
        goto error;

    lhClientDoc = lhNewClientDoc;

    /**
        Delete all the lpObjInfos having NULL lpobjects (non-NULLs
        belong to docScrap).  Make sure that ObjOpenedDoc is
        called if this doc is reopened.  This is the point of no return.
     **/
    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
        if ((*lplpObjTmp)->lpobject == NULL)
            ObjDeleteObjInfo(*lplpObjTmp);

    goto end;

    error:
    bRetval = TRUE;

    if (lhNewClientDoc)
    {
        OleRevokeClientDoc(lhNewClientDoc);
        /**
            If any objects are in the scrap, they must be made to belong to
            lhClientDoc, or be deleted.
        **/
        ObjCloneScrapToNewDoc(lhClientDoc);
    }

    end:

    --nBlocking; // reenable repaints
    UPDATE_INVALID();  // let WM_PAINTS get through now that we're no longer blocking

    return bRetval;
}

BOOL ObjOpenedDoc(int doc)
/*
    Return whether error that precludes continuing with opening this doc.
    If an error, then a new doc *must* be opened via ObjOpenedDoc().  We
        will clean this doc up to closed state if couldn't open it (ie,
        delete all objects and lpObjInfos).
*/
{
    BOOL bRetval=FALSE,bLinkError=FALSE;
    OBJPICINFO picInfo;
    typeCP cpPicInfo;
    BOOL bPrompted=FALSE;
    char szMsg[cchMaxSz];
    extern CHAR szUntitled[];

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Opened Doc\n\r");
#endif

    /* prevent display until done updating */
    ++nBlocking;

    StartLongOp();

    /* start collection timer all over */
    nGarbageTime=0;

    /* in case contains any picInfos left over from previous doc */
    ClobberDoc(docUndo,docNil,cp0,cp0);

    /* drag drop */
    DragAcceptFiles(hDOCWINDOW,TRUE);

    if (!lhClientDoc)
        if (ObjError(OleRegisterClientDoc(szDOCCLASS,szUntitled,0L,&lhClientDoc)))
            goto error;

    /* Do this first because much code assumes every picInfo has an
       lpObjInfo associated with it */
    if ((**hpdocdod)[doc].fFormatted)
    {
        for (cpPicInfo = cpNil;
            ObjPicEnumInRange(&picInfo,doc,cp0,CpMacText(doc),&cpPicInfo);
            )
        {
            if (ObjAllocObjInfo(&picInfo,cpPicInfo,picInfo.objectType,FALSE,NULL))
                goto error; // this is a real problem condition

            /* note this makes doc dirty right off the bat, but gotta do it because
               we gotta save ObjInfo handle in doc. (8.20.91) v-dougk */
            if (ObjSetPicInfo(&picInfo, doc, cpPicInfo))
                goto error;
        }

        /* OK to display.  Any error hereafter is not fatal. */
        (**hpdocdod)[doc].fDisplayable  = TRUE;

#if !defined(SMALL_OLE_UI)

    /**** Now see if links need updating ****/
    bDontFix=TRUE;  // don't bring up change links on release error

    if ((**hpdocdod)[doc].fFormatted)
    for (cpPicInfo = cpNil;
         ObjPicEnumInRange(&picInfo,doc,cp0,CpMacText(doc),&cpPicInfo);
         )
    {
        if (otOBJ_QUERY_TYPE(&picInfo) == LINK)
        if (ObjLoadObjectInDoc(&picInfo, doc, cpPicInfo) != cp0)
        {
            OLESTATUS olestat;

            if (!bPrompted)
            {
                LoadString(hINSTANCE, IDSTRUpdateObject, szMsg, sizeof(szMsg));
                if (MessageBox(hPARENTWINDOW, (LPSTR)szMsg, (LPSTR)szAppName, MB_YESNO|MB_ICONEXCLAMATION) == IDYES)
                    bPrompted = TRUE;
                else
                    break; // no updating requested
            }

#ifdef DEBUG
            OutputDebugString( (LPSTR) "Updating link\n\r");
#endif
            if (ObjError(OleUpdate(lpOBJ_QUERY_OBJECT(&picInfo))))
            {
                bLinkError = TRUE;
                fOBJ_BADLINK(&picInfo) = TRUE; // in case didn't get release, gotta set
                ferror = FALSE; // to reenable error messages
            }
        }
        else /* if load object failed, then give up */
        {
            bLinkError = FALSE; /*  Don't put up Links dialog */
            goto end;           /*  Not fatal, though they need to reopen doc
                                    after freeing memory */
        }
    }
    bDontFix=FALSE;
#endif
    }
    else /* OK to display. */
        (**hpdocdod)[doc].fDisplayable  = TRUE;

    goto end;

    error:
    bRetval = TRUE;

    end:

    if (bLinkError)
    /* fix 'em */
    {
        if (DialogBox(hINSTANCE, "DTINVALIDLINKS",
                    hPARENTWINDOW, lpfnInvalidLink) == IDD_CHANGE)
            fnObjProperties();
    }

    --nBlocking;
    EndLongOp(vhcArrow);

    UPDATE_INVALID();  // let WM_PAINTS get through now that we're no longer blocking

    return bRetval;
}


BOOL ObjSavingDoc(BOOL bFormatted)
/* return whether there was an error */
{
    /* drag drop */
    DragAcceptFiles(hDOCWINDOW,FALSE);

    /* update any other objects */

    vcObjects = 0;
    if (bFormatted)
        vcObjects = ObjEnumInDoc(docCur,ObjSaveObjectToDoc);

    return (vcObjects < 0); // return whether error
}

void ObjSavedDoc(void)
{
#ifdef DEBUG
    OutputDebugString( (LPSTR) "Saved Doc\n\r");
#endif

    if (lhClientDoc)
        ObjError(OleSavedClientDoc(lhClientDoc));
    bSavedDoc=TRUE;

    /* drag drop */
    DragAcceptFiles(hDOCWINDOW,TRUE);
}

static BOOL ObjUpdateAllOpenObjects(void)
/* Update all open embedded objects. Return whether successful.
   Called on file.close.  */
{
    OBJPICINFO picInfo;
    typeCP cpPicInfo;
    BOOL bRetval=TRUE;

    StartLongOp();
    for (cpPicInfo = cpNil;
        ObjPicEnumInRange(&picInfo,docCur,cp0,CpMacText(docCur),&cpPicInfo);
        )
    {
        if (((otOBJ_QUERY_TYPE(&picInfo) == NONE) ||
            (otOBJ_QUERY_TYPE(&picInfo) == EMBEDDED)) &&
                (OleQueryOpen(lpOBJ_QUERY_OBJECT(&picInfo)) == OLE_OK))
        {
            fnObjUpdate(lpOBJ_QUERY_INFO(&picInfo));
        }
    }

    end:

    /*  To make sure we've gotten all messages relevant to calling 
        ObjObjectHasChanged() and setting doc dirty. */
    if (FinishAllAsyncs(TRUE))
        bRetval = FALSE;

    EndLongOp(vhcArrow);
    UPDATE_INVALID();  // let WM_PAINTS get through now that we're no longer blocking
    return bRetval;
}


BOOL CloseUnfinishedObjects(BOOL bSaving)
/**
    Used with File.Save or File.Exit.
    Return TRUE whether should proceed with Save/Exit.
 **/
{
    char szMsg[cchMaxSz];

    if (ObjContainsOpenEmb(docCur, cp0, CpMacText(docCur),TRUE))
    {
        if (bSaving)
            LoadString(hINSTANCE, IDPMTSaveOpenEmb, szMsg, sizeof(szMsg));
        else
            LoadString(hINSTANCE, IDPMTExitOpenEmb, szMsg, sizeof(szMsg));

        switch (MessageBox(hPARENTWINDOW, (LPSTR)szMsg, (LPSTR)szAppName, MB_YESNOCANCEL))
        {
            case IDYES:
                return ObjUpdateAllOpenObjects();
            case IDNO:
            default:
                return TRUE;
            case IDCANCEL:
                return FALSE;
        }
    }
    return TRUE;
}

void ObjRenamedDoc(LPSTR szNewName)
{
    OBJPICINFO picInfo;
    typeCP cpPicInfo;

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Renamed Doc\n\r");
#endif
    if (lhClientDoc)
        ObjError(OleRenameClientDoc(lhClientDoc,szNewName));

    /* don't need to do all docs since objects can only be active in docCur */
    for (cpPicInfo = cpNil;
        ObjPicEnumInRange(&picInfo,docCur,cp0,CpMacText(docCur),&cpPicInfo);
        )
        /* ignore return value on purpose */
        ObjSetHostNameInDoc(&picInfo,docCur,cpPicInfo);
}

void ObjRevertedDoc()
{
#ifdef DEBUG
    OutputDebugString( (LPSTR) "Reverted Doc\n\r");
#endif
    if (lhClientDoc)
        ObjError(OleRevertClientDoc(lhClientDoc));
}

/****************************************************************/
/*********************** ERROR HANDLING *************************/
/****************************************************************/
BOOL FAR
ObjError(OLESTATUS olestat)
{
    register HWND hWndParent = hPARENTWINDOW;

    switch (olestat) {
        case OLE_WAIT_FOR_RELEASE:
        case OLE_OK:
            return FALSE;
    }

    ferror = FALSE; // to enable error message

    switch (olestat) {
    case OLE_ERROR_LAUNCH:
        Error(IDPMTFailedToLaunchServer);
    break;

    case OLE_ERROR_COMM:
        Error(IDPMTFailedToCommWithServer);
    break;

    case OLE_ERROR_MEMORY:
        Error(IDPMTWinFailure);
    break;

    case OLE_BUSY:
        Error(IDPMTServerBusy);
    break;

    case OLE_ERROR_FORMAT:
        Error(IDPMTFormat);
    break;

    case OLE_ERROR_DRAW:
        Error(IDPMTFailedToDraw);
    break;

    default:
#ifdef DEBUG
        ObjPrintError(olestat,FALSE);
#endif

        Error(IDPMTOLEError);
    break;
    }
    return TRUE;
}

void
ObjReleaseError(OLE_RELEASE_METHOD rm)
/*
    There's an async problem here, in that the posted message 
    that invokes this routine may be allowed through by Error() which
    isn't reentrant (or at least causes problems when called recursively).
*/
{
    register HWND hWndParent = hPARENTWINDOW;

    switch (rm) {

    case OLE_DELETE:
        Error(IDPMTFailedToDeleteObject);
    break;

    case OLE_LOADFROMSTREAM:
        Error(IDPMTFailedToReadObject);
    break;

    case OLE_LNKPASTE:
    case OLE_EMBPASTE:
        Error(IDPMTGetFromClipboardFailed);
    break;

    case OLE_ACTIVATE:
        Error(IDPMTFailedToLaunchServer);
    break;

    case OLE_UPDATE:
        Error(IDPMTFailedToUpdate);
    break;

    case OLE_CREATE:
    case OLE_CREATELINKFROMFILE:
    case OLE_CREATEFROMFILE:
        Error(IDPMTFailedToCreateObject);
    break;

    case OLE_SETUPDATEOPTIONS:
        Error(IDPMTImproperLinkOptionsError);
    break;

    default:
        Error(IDPMTOLEError);
    break;
    }
#ifdef DEBUG
        ObjPrintError(rm,TRUE);
#endif
}

#ifdef DEBUG
void ObjPrintError(WORD olestat, BOOL bRelease)
{
    #define szMsgMax       100
    char szError[szMsgMax];
    if (!bRelease)
        wsprintf(szError, "***Ole Error #%d\n\r",olestat);
    else
        wsprintf(szError, "***Ole Release Error on Method #%d\n\r",olestat);
    OutputDebugString(szError);
}
#endif

/****************************************************************/
/***************** ASYNCRONICITY HANDLING ***********************/
/****************************************************************/
int FAR PASCAL
CallBack(LPOLECLIENT lpclient,
         OLE_NOTIFICATION flags,
         LPOLEOBJECT lpObject)
{
    extern int     vdocParaCache;
    LPOBJINFO lpOInfo = (LPOBJINFO)lpclient;

    switch(flags)
    {
        case OLE_SAVED:
        case OLE_CLOSED:
        case OLE_CHANGED:
            /**
                Post a message instead of process here because we have to return from
                CallBack before making any other OLE calls.
              **/
#ifdef DEBUG
            OutputDebugString(flags == OLE_CHANGED ? "received OLE_CHANGED\n\r" :
                              flags == OLE_SAVED   ? "received OLE_SAVED\n\r"   :
                                                     "received OLE_CLOSED\n\r");
#endif
            PostMessage(hDOCWINDOW,WM_OBJUPDATE,flags,(DWORD)lpOInfo);
        break;

        case OLE_RELEASE:
        {
            OLE_RELEASE_METHOD ReleaseMethod = OleQueryReleaseMethod(lpObject);

            if (!CheckPointer((LPSTR)lpOInfo,1))
                return FALSE;

            lpOInfo->fKillMe = FALSE; // pending async is dead

            if (lpOInfo->fDeleteMe && (ReleaseMethod != OLE_DELETE))   // not dead enough
            {
                PostMessage(hDOCWINDOW,WM_OBJDELETE,1,(DWORD)lpOInfo);
                return FALSE; // error message will already have been given
            }

            if (lpOInfo->fReleaseMe && (ReleaseMethod != OLE_DELETE))  // not dead enough
            {
                PostMessage(hDOCWINDOW,WM_OBJDELETE,0,(DWORD)lpOInfo);
                return FALSE; // error message will already have been given
            }

            if (lpOInfo->fFreeMe && (ReleaseMethod == OLE_DELETE)) // on OLE_DELETE release
            {
                ObjDeleteObjInfo(lpOInfo);
                return FALSE;
            }

            if (OleQueryReleaseError(lpObject) == OLE_OK)
            {
                switch (ReleaseMethod)
                {
                    case OLE_SETUPDATEOPTIONS:
                    {
                        if (bLinkProps) // we're in Link Properties dialog
                        {
                            PostMessage(hPARENTWINDOW, WM_UPDATELB, 0, 0L);
                            PostMessage(hPARENTWINDOW, WM_COMMAND, IDD_REFRESH, (DWORD)lpOInfo);
                        }
                    }
                    break;

                    case OLE_UPDATE:
                        ObjInvalidateObj(lpObject);
                    break;

                    case OLE_DELETE: // get this for delete and release
                        lpOInfo->lpobject = NULL;
                    break;
                }
            }
            else // release error != OLE_OK
            {
#ifdef DEBUG
                PostMessage(hDOCWINDOW,WM_OBJERROR,ReleaseMethod,0L);
#endif

                switch(ReleaseMethod)
                {
                    case OLE_CREATE:
                    case OLE_CREATELINKFROMFILE:
                    case OLE_CREATEFROMFILE:
                        /*
                            OleQueryReleaseError won't help us after callback returns
                            so this is how we tell that the object wasn't created.
                        */
                        lpOInfo->fDeleteMe = TRUE;
                        // creator should ObjDeleteObject and issue error message
                    break;

                    default:
                        switch (OleQueryReleaseError(lpObject))
                        {
                            case OLE_ERROR_OPEN:
                            case OLE_ERROR_ADVISE_NATIVE:
                            case OLE_ERROR_ADVISE_PICT:
                            case OLE_ERROR_REQUEST_NATIVE:
                            case OLE_ERROR_REQUEST_PICT:
                                /**
                                    Post a message instead of process here because we have to return from
                                    CallBack before making any other OLE calls.
                                **/
                                if (lpOInfo->objectType == LINK)
                                    lpOInfo->fBadLink = TRUE;
                                if (bLinkProps)
                                    fPropsError = TRUE; // so linkprops knows there was a problem
                                else if (!bDontFix && (lpOInfo->objectType == LINK))
                                    PostMessage(hDOCWINDOW,WM_OBJBADLINK,OleQueryReleaseMethod(lpObject),(DWORD)lpObject);
                            break;
                        }
                    break;
                }
            }
        }
        break;

        case OLE_QUERY_RETRY:
        {
            Assert(CheckPointer((LPSTR)lpOInfo,1));

            if (lpOInfo->fKillMe)
            {
                lpOInfo->fKillMe = FALSE;
                return FALSE;
            }
            else if (hwndWait)
                PostMessage(hwndWait,WM_UKANKANCEL,0,0L);
            else if (nWaitingForObject == 0)
                PostMessage(hDOCWINDOW,WM_WAITFORSERVER,TRUE,(DWORD)lpOInfo);

            return TRUE;
        }
        break;

        case OLE_QUERY_PAINT:
            return TRUE;
        break;

        default:
        break;
    }
    return FALSE;
}

void ObjObjectHasChanged(int flags, LPOBJINFO lpObjInfo)
{
    typeCP cpParaStart,
           cpParaCache = vcpFirstParaCache;
    int docCache = vdocParaCache;
    OBJPICINFO picInfo;
    LPOLEOBJECT lpObject = lpObjInfo->lpobject;

    /**
    For Embeds (including InsertObject objects):
        OLE_SAVED   is sent with server File.Update
                    (set undo if not NONE)
        OLE_CHANGED is sent with server File.Save or File.Close (?)
                    with update (set undo if not NONE), or when OleSetData()
                    causes a change in the presentation of the object.
        OLE_CLOSED  is sent when doc closes in server (clear undo if set)
    For Links:
        OLE_SAVED   is sent with server File.Save (As?) if update_options
                    == update_on_save (that never happens)
        OLE_CHANGED is sent when something in the server doc changes
        OLE_CLOSED  is never sent
    **/

    Assert(lpObjInfo != NULL);

    if (lpObjInfo == NULL)
        return;

    if (lpObjInfo->objectType == NONE) // result of InsertObject
    {
        cpParaStart=lpObjInfo->cpWhere; // note only used here!

        if (flags == OLE_CLOSED) // delete object
        {
            if (lpObject) /* may already be released or deleted */
                ObjDeleteObject(lpObjInfo,TRUE);
            NoUndo();
            BringWindowToTop(hMAINWINDOW);
        }
        else
        {
            extern int              vfSeeSel;

            (**hpdocdod)[docCur].fFormatted = fTrue;

            /* insert EOL if needed */
            if (cpParaStart > cp0)
            {
                ObjCachePara(docCur, cpParaStart - 1);
                if (vcpLimParaCache != cpParaStart)
                {
                    InsertEolPap(docCur, cpParaStart, &vpapAbs);
                    cpParaStart += ccpEol;
                }
            }

            GimmeNewPicinfo(&picInfo, lpObjInfo);
            ObjCachePara(docCur,cpParaStart);
            /* this'll clear selection. */
            if (ObjSaveObjectToDoc(&picInfo,docCur,cpParaStart) == cp0)
                Error(IDPMTFailedToCreateObject);
            NoUndo();
            ObjInvalidatePict(&picInfo,cpParaStart);
            vfSeeSel = true; /* Tell    Idle() to scroll the selection into view */
            (**hpdocdod) [docCur].fDirty = TRUE;
        }
    }
    else if (ObjGetPicInfo(lpObject,docCur,&picInfo,&cpParaStart))
    {
        BOOL bSizeChanged;

        //GetPicInfo(cpParaStart,cpParaStart + cchPICINFOX, docCur, &picInfo);

        /* invalidate rect before updating size (cause invalidate
            needs to know old pic size) */
        ObjInvalidatePict(&picInfo,cpParaStart);

        bSizeChanged = ObjUpdatePicSize(&picInfo,cpParaStart);

        if ((flags == OLE_CHANGED) ||
            (flags == OLE_SAVED) && (otOBJ_QUERY_TYPE(&picInfo) == EMBEDDED))
        {
            NoUndo();
#ifdef DEBUG
            if (!fOBJ_QUERY_DIRTY_OBJECT(&picInfo))
                OutputDebugString( (LPSTR) "Marking object dirty\n\r");
#endif
            fOBJ_QUERY_DIRTY_OBJECT(&picInfo) = TRUE;
#ifdef DEBUG
            if (!(**hpdocdod) [docCur].fDirty)
                OutputDebugString( (LPSTR) "Marking doc dirty\n\r");
#endif
            (**hpdocdod) [docCur].fDirty = TRUE;
        }

        if (bSizeChanged)
            if (ObjSetPicInfo(&picInfo,docCur,cpParaStart))
                Error(IDPMTFailedToUpdate);

        if (otOBJ_QUERY_TYPE(&picInfo) == EMBEDDED)
        {
            if (flags == OLE_CLOSED)
            {
                //if (fOBJ_QUERY_DIRTY_OBJECT(&picInfo))
                    BringWindowToTop(hMAINWINDOW);
#ifdef UPDATE_UNDO
                ObjClearUpdateUndo(&picInfo,docCur,cpParaStart);
#endif
            }
#ifdef UPDATE_UNDO
            else if (flags == OLE_SAVED)
            {
                ObjSetUpdateUndo(&picInfo,docCur,cpParaStart);
                SetUndo(uacObjUpdate,docCur,cpParaStart,cp0,docNil,cp0,cp0,0);
            }
#endif
        }
    }

    ObjCachePara(docCache,cpParaCache); // reset state
}

BOOL ObjUpdatePicSize(OBJPICINFO *pPicInfo, typeCP cpParaStart)
/* returns whether size changed */
{
int xSize,ySize;
BOOL bUpdate = FALSE;

    /* object may have changed size */
    if (!FComputePictSize(pPicInfo, &xSize, &ySize ))
        Error(IDPMTFailedToUpdate);
    else
        bUpdate = (xSize != pPicInfo->dxaSize) ||
                  (ySize != pPicInfo->dyaSize);

    if (bUpdate)
    {
        int yOldSize = pPicInfo->dyaSize;

        pPicInfo->dxaSize = xSize;
        pPicInfo->dyaSize = ySize;

        if (yOldSize < pPicInfo->dyaSize)
        { /* If the picture height was increased, make sure proper EDLs are
                invalidated. */
            typeCP dcp = CpMacText(docCur) - cpParaStart + (typeCP) 1;
            ObjPushParms(docCur);
            AdjustCp(docCur, cpParaStart, dcp, dcp);  // major async problems here?
            ObjPopParms(TRUE);
        }
    }
    return bUpdate;
}

void ObjHandleBadLink(OLE_RELEASE_METHOD rm, LPOLEOBJECT lpObject)
{
    switch (rm)
    {
        case OLE_ACTIVATE:
        case OLE_UPDATE:
        {
            typeCP cpParaStart,cpParaCache = vcpFirstParaCache;
            int docCache = vdocParaCache;
            OBJPICINFO picInfo;

            /* don't need to do all docs since objects can only be active in docCur */
            if (!ObjGetPicInfo(lpObject,docCur,&picInfo,&cpParaStart))
            {
                /* maybe in scrap, just ignore */
                ObjCachePara(docCache,cpParaCache); // reset state
                return;
            }

            ObjCachePara(docCur,cpParaStart);
            if (FixInvalidLink(&picInfo,docCur,cpParaStart))
                switch (rm)
                {
                    case OLE_ACTIVATE:
                        StartLongOp();
                        ObjError(OleActivate(lpObject,
                            fOBJ_QUERY_PLAY(&picInfo),
                            TRUE,
                            TRUE,
                            hDOCWINDOW,
                            NULL));
                        EndLongOp(vhcArrow);
                    break;
                    case OLE_UPDATE:
                        StartLongOp();
                        ObjError(OleUpdate(lpObject));
                        EndLongOp(vhcArrow);
                    break;
                }
            ObjCachePara(docCache,cpParaCache); // reset state
        }
        break;
    }
}

BOOL ObjWaitForObject(LPOBJINFO lpObjInfo, BOOL bOK2Cancel)
{
    HCURSOR hCursor = NULL;
    BOOL bRetval;
    /**
        WMsgLoop allows WM_PAINT messages which wreak havoc.  Try to
        recover from the insult.
     **/
    typeCP cpParaCache = vcpFirstParaCache;
    int docCache = vdocParaCache;
    LPOLEOBJECT lpObject;

    if (lpObjInfo == NULL) // shouldn't happen
    {
        Assert(0);
        return FALSE;
    }

    /*  Since ObjPicEnumInRange returns unloaded picinfo's this is a 
        valid possibility, but we shouldn't be getting called!!! */
    Assert(lpObjInfo->lpobject != NULL);

    Assert (CheckPointer((LPSTR)lpObjInfo,1));

    lpObject = lpObjInfo->lpobject;

    if (!ObjIsValid(lpObject))
    {
        Assert (0);
        return FALSE;
    }

    hCursor = SetCursor(vhcHourGlass);
    StartLongOp();
    bRetval = WMsgLoop(TRUE,TRUE,bOK2Cancel,lpObject);
    if (hCursor)
        EndLongOp(hCursor);

    ObjCachePara(docCache,cpParaCache); // reset state

    /* problem here is that we may have been waiting for a release or delete */
    if (ObjIsValid(lpObject))
    {
        lpObjInfo->fCancelAsync = FALSE; // clear after use
        lpObjInfo->fCompleteAsync = FALSE; // clear after use
        lpObjInfo->fCanKillAsync = FALSE;
    }

    UPDATE_INVALID();  // let WM_PAINTS get through now that we're no longer blocking
    return bRetval;
}


#if 0
BOOL ObjObjectSync(LPOBJINFO lpObjInfo, OLESTATUS (FAR PASCAL *lpProc)(LPOLEOBJECT lpObject), BOOL bOK2Cancel)
/*
    This makes an asynchronous call synchronous.  lpProc must have only
    lpObject as argument.  This will block if operation cannot be completed
    or cancelled.
*/
{
    /* caller has set or not set CancelAsync flag for object */
    if (ObjWaitForObject(lpObjInfo,bOK2Cancel))
        return TRUE;

    switch((*lpProc)(lpObjInfo->lpobject))
    {
            case OLE_WAIT_FOR_RELEASE:
            {
                /* cancel button should only be enabled if this operation
                   can be cancelled. */
                lpObjInfo->fCancelAsync = FALSE;  // don't cancel automatically
                lpObjInfo->fCompleteAsync = TRUE; // this op must complete or be cancelled

                if (ObjWaitForObject(lpObjInfo,TRUE))
                    return TRUE;

                /*  the trouble with this is that lpObject may now be released
                    (and thus invalid):
                    return ObjError(OleQueryReleaseError(lpObjInfo->lpobject));
                */

                return FALSE;
            }
            case OLE_OK:
                return FALSE;
            default:
                return TRUE;
    }
}
#endif

#define WM_NCMOUSEFIRST 0x00A0
#define WM_NCMOUSELAST  0x00A9

static BOOL WMsgLoop
(
BOOL fExitOnIdle,       // if true, return as soon as no messages to process
                        // (not used, assumed FALSE).
BOOL fIgnoreInput,      // if true, ignore keyboard and mouse input
BOOL bOK2Cancel,
LPOLEOBJECT lpObject
)
    {
    MSG     msg;
    DWORD GetCurrentTime();
    DWORD cTime=GetCurrentTime();
    BOOL bRetval=FALSE,bBeeped=FALSE;
    int fParentEnable;
    extern int flashID;

#ifdef DEBUG
    if (OleQueryReleaseStatus(lpObject) == OLE_BUSY)
        OutputDebugString("waiting for object\n\r");
#endif

    ++nBlocking;

    ferror = FALSE;

    ++nWaitingForObject;

    StartLongOp();

    while (OleQueryReleaseStatus(lpObject) == OLE_BUSY)
    {
        /* put up wait dialog after 6 seconds */
        if ((GetCurrentTime() - cTime) > 6000L)
        {
            // bring up wait dialog.
            if (!hwndWait)
            {
                if (vfDeactByOtherApp)
                {
                    if (!bBeeped) // flash until we're activated
                    {
                        fParentEnable = IsWindowEnabled(hMAINWINDOW);
                        //MessageBeep(0);
                        bBeeped = TRUE;

                        if (!fParentEnable)
                            EnableWindow(hMAINWINDOW, TRUE); /* make sure parent window is enabled
                                                            to let the user click in it */
                        flashID = 1234; // arbitrary ID
                        SetTimer(hMAINWINDOW, flashID, 500, (FARPROC)NULL);
                        // this'll cause flashing, see mmw.c
                    }
                }
                else // Write is active app
                {
                    if (bBeeped)
                    /* then we've regained the activation */
                    {
                        if (!fParentEnable)
                            EnableWindow(hMAINWINDOW, FALSE); /* reset */
                        bBeeped = FALSE;
                        KillTimer(hMAINWINDOW, flashID);
                        flashID = 0;
                        FlashWindow(hMAINWINDOW, FALSE);
                    }

                    if (OleQueryReleaseStatus(lpObject) == OLE_BUSY)
                    {
                        /* this'll set hwndWait */
                        vbCancelOK = bOK2Cancel;
                        bRetval = DialogBoxParam(hINSTANCE, (LPSTR)"DTWAIT", hPARENTWINDOW, lpfnWaitForObject, (DWORD)lpObject);
                       break;
                    }
                }
            }
            else
            {
                bRetval = TRUE;
                break;
            }
        }

        if (!PeekMessage (&msg, NULL, 0, 0, PM_REMOVE))
            {
            /* No messages, do Idle processing */
            /* this is where we'd use ExitOnIdle */
            }
        else
        {
            /* The following code will put the app into a
            sleeping state if the fIgnoreInput flag is set
            to TRUE.  It will allow Quit, DDE, and any
            other non input messages to be passed along
            and dispatched but will prohibit the user from
            interacting with the app.  The user can
            Alt-(sh)Tab, Alt-(sh)Esc, and Ctrl-Esc away from the
            app as well as use any Windows hot keys to
            activate other apps */

            /* if we pass this test, then the message may be one we can ignore */
            if ((fIgnoreInput) &&
                (!(vfDeactByOtherApp &&
                  (msg.message == WM_NCLBUTTONDOWN))) &&
                ((msg.message >= WM_NCMOUSEFIRST &&
                 msg.message <= WM_NCMOUSELAST) ||
                (msg.message >= WM_KEYFIRST  &&
                 msg.message <= WM_KEYLAST) ||
                (msg.message >= WM_MOUSEFIRST &&
                 msg.message <= WM_MOUSELAST)))
                {
                static BOOL fAltCtl = FALSE;

                if (msg.message != WM_SYSKEYDOWN)
                    continue; // ignore

                if (msg.wParam == VK_MENU)
                    fAltCtl = TRUE;
                else if (fAltCtl && msg.wParam != VK_SHIFT)
                    {
                    fAltCtl = FALSE;
                    if (msg.wParam != VK_TAB && msg.wParam != VK_ESCAPE)
                        continue; // ignore
                    }
                }


            if ((vfDeactByOtherApp &&
                    (msg.message == WM_NCLBUTTONDOWN)))
                BringWindowToTop(hwndWait ? hwndWait : msg.hwnd);
            else
            {
                TranslateMessage ((LPMSG) &msg);
                DispatchMessage ((LPMSG) &msg);
            }
        }
    }

    Assert(hwndWait == NULL);

    if (bBeeped) // then beeped but done before received activation
    {
        if (!fParentEnable)
            EnableWindow(hMAINWINDOW, FALSE); /* reset */
        KillTimer(hMAINWINDOW, flashID);
        flashID = 0;
        FlashWindow(hMAINWINDOW, FALSE);
    }

    --nBlocking;
    --nWaitingForObject;

    EndLongOp(vhcArrow);

    Assert(nBlocking >= 0);
    return bRetval;
}

void FinishUp(void)
/* let all pending messages through and return */
/*
    !!! Note that we may accumulate WM_PAINTS.  Caller is responsible for
    calling UPDATE_INVALID() to catch up on them!!!
*/
{
    MSG     msg;

    /* now allow through all messages posted from callback */
    ++nBlocking; // block WM_PAINTS
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        TranslateMessage ((LPMSG) &msg);
        DispatchMessage ((LPMSG) &msg);
    }
    --nBlocking;

    return FALSE;
}

BOOL FinishAllAsyncs(BOOL bAllowCancel)
/*
    !!! Note that we may accumulate WM_PAINTS.  Caller is responsible for
    calling UPDATE_INVALID() to catch up on them!!!  (see FinishUp())
*/
{
    LPOLEOBJECT lpObject;
    LPOBJINFO lpObjInfo;

    /* first make sure all async ops are complete */
    lpObject=NULL;
    do
    {
        OleEnumObjects(lhClientDoc,&lpObject);
        if (lpObject)
        {
            lpObjInfo = GetObjInfo(lpObject);

            if (lpObjInfo)
            {
                /* cancel takes us outa here.  Pending asyncs will block us. */
                if (ObjWaitForObject(lpObjInfo,bAllowCancel))
                    return TRUE;
            }
            else // shouldn't happen, but don't assume for now
            {
                Assert(0);
                if (WMsgLoop(TRUE,TRUE,bAllowCancel,lpObject))
                    return TRUE;
            }

            if (!ObjIsValid(lpObject)) // then got deleted
                lpObject = NULL; // start over
        }
    }
    while (lpObject);

    /* let all messages posted from callback get through */
    FinishUp();

    return FALSE;
}

static typeCP       cpPPSave;
static int          docPPSave;
static struct SEL   selPPSave;
static int nPushed=FALSE;

ObjPushParms(int doc)
/*  Save selCur and Cache info to reset with Pop after writing to
    doc.  Assumes aren't changing size of doc.  
*/
{
    if (nPushed) // prevent recursion
    {
#ifdef DEBUG
        OutputDebugString("Unmatched ObjPushParms\n\r");
#endif
        return;
    }
    ++nPushed;

    cpPPSave = vcpFirstParaCache;
    docPPSave = vdocParaCache;

    selPPSave = selCur;
    Select(selCur.cpFirst,selCur.cpFirst); // this caches para
//T-HIROYN raid #3538
#ifdef KKBUGFIX
	if(docPPSave == docNil)
		docPPSave = vdocParaCache;
#endif
    CachePara(docPPSave,cpPPSave);
}

ObjPopParms(BOOL bCache)
{
    typeCP cpMac = (**hpdocdod) [docPPSave].cpMac;

    if (!nPushed) // unmatched push/pops
    {
#ifdef DEBUG
        OutputDebugString("Unmatched ObjPopParms\n\r");
#endif
        return;
    }
    --nPushed;

    if (docPPSave == docCur)
    {
        if (selPPSave.cpLim > cpMac)
            selPPSave.cpLim = cpMac;
        if (cpPPSave > cpMac)
            cpPPSave = cpMac;
    }

    Select(selPPSave.cpFirst,selPPSave.cpLim); // this caches para
    if (bCache)
        CachePara(docPPSave,cpPPSave);
    //(**hpdocdod) [docPPSave].fDirty = TRUE; /* why? */
}


void ObjCachePara(int doc, typeCP cp)
{
    typeCP cpMac = (**hpdocdod) [doc].cpMac;
    typeCP cpMacCurSave = cpMacCur,
           cpMinCurSave = cpMinCur;

    if (doc == docNil)
        return;

    /**
        cpMinCur and cpMacCur are the min and mac value for whatever is
        currently docCur.  Their values will be different for the header,
        footer and regular docs.  OBJ code doesn't distinguish.  Async
        operations can happen on any and all cps at once.  Gotta set so
        CachePara wil understand that.
    **/
    cpMinCur = cp0;
    cpMacCur = cpMac;

    if (cp >= cpMac)
        cp = cpMac;
    else if (cp < cp0)
        cp = cp0;

    CachePara(doc,cp);

    cpMinCur = cpMinCurSave;
    cpMacCur = cpMacCurSave;
}

#if 0
void ObjWriteFixup(int doc, BOOL bStart, typeCP cpStart)
/* note this must not be called recursively!!  It is for use where size of
   doc may change between bStart=TRUE and bStart=FALSE. */
{
    static typeCP dcp,cpLim;
    static struct SEL selSave;
    typeCP cpMac;

    /* reset selection accounting for change in size if any */
    if (bStart)
    {
        cpLim = CpMacText(doc);
        selSave=selCur;
        if ((selCur.cpFirst != selCur.cpLim) && (doc == docCur))
            Select(selCur.cpFirst,selCur.cpFirst);  /* Take down sel before we mess with cp's */
        /* select undoes cache */
        ObjCachePara(doc,cpStart);
    }
    else
    {
        cpMac =  CpMacText(doc);

        dcp = cpMac-cpLim; /* change in size of doc */

        if (doc == docCur)
        {
            if (selSave.cpFirst <= cpStart)
            {
                if ((selSave.cpLim) > cpStart)
                    selSave.cpLim += dcp;
            }
            else if (selSave.cpFirst > cpStart)
                /* selection proceeds object */
            {
                selSave.cpFirst += dcp;
                selSave.cpLim += dcp;
            }

            if (selSave.cpFirst > cpMac)
                selSave.cpFirst = selSave.cpLim = cpMac;
            else if (selSave.cpLim > cpMac)
                selSave.cpLim = cpMac;

            /* this'll cache first para in selection */
            if (selSave.cpFirst != selSave.cpLim)
                Select(selSave.cpFirst,selSave.cpLim);
        }

        ObjCachePara(doc,cpStart);

        /* Fixup Undo pointers */
        if (vuab.doc == docCur)
        {
            if (doc == docUndo) /* operating on docUndo, cpStart is irrelevant */
                vuab.dcp += dcp;
            else if (doc == docCur)
            {
                if (vuab.cp <= cpStart)
                {
                    /* undo encloses object */
                    if ((vuab.cp+vuab.dcp) > cpStart)
                        vuab.dcp += dcp;
                }
                else if (vuab.cp > cpStart)
                    /* undo proceeds object */
                    vuab.cp += dcp;
            }
        }

        if (vuab.doc2 == docCur)
        {
            if (doc == docUndo) /* operating on docUndo, cpStart is irrelevant */
                vuab.dcp += dcp;
            else if (doc == docCur)
            {
                if (vuab.cp2 <= cpStart)
                {
                    /* undo encloses object */
                    if ((vuab.cp2+vuab.dcp2) > cpStart)
                        vuab.dcp2 += dcp;
                }
                else if (vuab.cp2 > cpStart)
                    /* undo proceeds object */
                    vuab.cp2 += dcp;
            }
        }
    }
}
#endif

void ObjWriteClearState(int doc)
/** Call this before writing asynchronously to doc.  In practise, this is
    being called in synchronous times as well, so higher level code
    must take care of resetting selection and undo after writing to doc.
**/
{
    typeCP cpSave=vcpFirstParaCache;
    int docSave=vdocParaCache;

    if (doc == docCur)
    {
        Select(selCur.cpFirst,selCur.cpFirst);  /* Take down sel before we mess with cp's */
        /* select undoes cache */
        ObjCachePara(docSave,cpSave);
    }
    //NoUndo(); /** Higher level code must SetUndo *after* calling **/
}

LPOBJINFO GetObjInfo(LPOLEOBJECT lpObject)
{
    LPLPOBJINFO lplpObjTmp;

    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
        if ((*lplpObjTmp)->lpobject == lpObject)
            return *lplpObjTmp;

    Assert(0);
    return NULL;
}


BOOL ObjIsValid(LPOLEOBJECT lpobj)
{
    if (!CheckPointer((LPSTR)lpobj, 1))
        return FALSE;

    if (OleQueryReleaseStatus(lpobj) == OLE_ERROR_OBJECT)
        return FALSE;

#if 0 // can't depend on this in future version of OLE
    if (!(((LPRAWOBJECT)lpobj)->objId[0] == 'L' && ((LPRAWOBJECT)lpobj)->objId[1] == 'E'))
        return FALSE;
#endif

    return TRUE;
}

#if 0  // these should work, but not using them now
LPOBJINFO ObjGetClientInfo(LPOLEOBJECT lpobj)
{
    LPOBJINFO lpObjInfo;

    if (!CheckPointer((LPSTR)lpobj, 1))
    {
        Assert(0);
        return NULL;
    }

#if 0 // can't depend on this in future versions of OLE
    if (!CheckPointer((LPSTR)(((LPRAWOBJECT)lpobj)->lpclient), 1))
    {
        Assert(0);
        return NULL;
    }
    else
        return (LPOBJINFO)(((LPRAWOBJECT)lpobj)->lpclient);
#endif

    if (*(lpObject->lpvtbl->ObjectLong)(lpObject,OF_GET,(LPLONG)&lpObjInfo) == OLE_OK)
        return lpClient;
    else
        return NULL;
}

BOOL ObjSetClientInfo(LPOBJINFO lpObjInfoNew, LPOLEOBJECT lpobj)
/* return if error */
{
    if (!CheckPointer((LPSTR)lpobj, 0))
    {
        Assert(0);
        return TRUE;
    }

    if (*(lpObject->lpvtbl->ObjectLong)(lpObject,OF_SET,(LPLONG)&lpObjInfoNew) == OLE_OK)
        return FALSE;
    else
    {
        Assert(0);
        return TRUE;
    }
}
#endif

#if 0
int ObjMarkInDoc(int doc)
/* mark as 'InDoc' all objects located in docScrap, all others are marked
   as not 'InDoc'.  Return count of objects in doc. */
{
    LPLPOBJINFO lplpObjTmp;
    int nObjCount=0,doc;
    OBJPICINFO picInfo;
    typeCP cpPicInfo;

    /* mark all as not in doc */
    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
    {
        ++nObjCount;
        (*lplpObjTmp)->fInDoc = FALSE;
    }

    if (nObjCount == 0)
        return 0;

    for (cpPicInfo = cpNil,nObjCount=0;
        ObjPicEnumInRange(&picInfo,doc,cp0,CpMacText(doc),&cpPicInfo);
        )
        {
            if (lpOBJ_QUERY_INFO(&picInfo))
            {
                fOBJ_INDOC(&picInfo) = TRUE;
                ++nObjCount;
            }
        }
    return nObjCount;
}

BOOL AllocObjInfos()
/* return whether error */
{
    OBJPICINFO picInfo;
    typeCP cpPicInfo;
    int doc;

    for (doc = 0; doc < docMac; doc++)
    {
        if ((doc != docNil) && (**hpdocdod)[doc].hpctb)
        {
            for (cpPicInfo = cpNil;
                ObjPicEnumInRange(&picInfo,doc,cp0,CpMacText(doc),&cpPicInfo);
                )
            {
                if (picInfo.lpObjInfo)
                    continue;

                if (ObjAllocObjInfo(&picInfo,cpPicInfo,picInfo.objectType,FALSE,NULL))
                    return TRUE;

                /* note this makes doc dirty right off the bat, but gotta do it because
                    we gotta save ObjInfo handle in doc. (8.20.91) v-dougk */
                ObjWriteFixup(doc,TRUE,cpPicInfo);
                if (ObjSetPicInfo(&picInfo, doc, cpPicInfo))
                    return TRUE;
                ObjWriteFixup(doc,FALSE,cpPicInfo);
            }
        }
    }
}
#endif

BOOL ObjCloneScrapToNewDoc(LHCLIENTDOC lhNewClientDoc)
/* return whether an error */
{
    szOBJNAME szObjName;
    OBJPICINFO picInfo;
    typeCP cpPicInfo;
    int nCount=0;
    extern int docScrap;



    for (cpPicInfo = cpNil;
        ObjPicEnumInRange(&picInfo,docScrap,cp0,CpMacText(docScrap),&cpPicInfo);
    )
    {
        szOBJNAME szObjName;
        LPOBJINFO   lpObjInfo = lpOBJ_QUERY_INFO(&picInfo);
        LPOLEOBJECT lpObject  = lpObjInfo->lpobject;
        OBJPICINFO NewPicInfo = picInfo;

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Cloning object in scrap\n\r");
#endif

        if (ObjCloneObjInfo(&NewPicInfo, cpPicInfo, szObjName))
            goto error;

        if (ObjError(OleClone(lpObject,
            (LPOLECLIENT)lpOBJ_QUERY_INFO(&NewPicInfo),
            lhNewClientDoc,szObjName,
            &lpOBJ_QUERY_OBJECT(&NewPicInfo))))
            goto error;

        if (ObjSetPicInfo(&NewPicInfo, docScrap, cpPicInfo))
            goto error;

        ObjDeleteObject(lpObjInfo,TRUE);

        ++nCount;
    }

    goto end;

    error:

    /* cleanup after failure by deleting docScrap objects */
    for (cpPicInfo = cpNil;
        ObjPicEnumInRange(&picInfo,docScrap,cp0,CpMacText(docScrap),&cpPicInfo);
    )
    {
        ObjDeleteObject(lpOBJ_QUERY_INFO(&picInfo),TRUE);
    }

    ClobberDoc(docScrap,docNil,cp0,cp0);

    nCount = -1;

    end:

    if (nCount) // docScrap has changed
        NoUndo();

    return nCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\obj.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/
#ifndef OLEH
#define OLEH
#include <ole.h>

//#define SMALL_OLE_UI

/* 
 * Constant IDs used in the Object Properties... dialog
 */
#define IDD_WHAT	    0x0100
#define IDD_CLASSID     0x0101
#define IDD_AUTO        0x0102
#define IDD_MANUAL      0x0103
#define IDD_EDIT        imiActivate
#define IDD_FREEZE      imiFreeze
#define IDD_UPDATE      imiUpdate
#define	IDD_CHANGE	    0x106
#define	IDD_LINK	    0x107
#define	IDD_LINKDONE	0x108
#define	IDD_LISTBOX 	0x109
#define	IDD_EMBEDDED	0x110
#define IDD_PLAY        0x111
#define IDD_UNDO        0x112
#define IDD_REFRESH     0x113
#define IDD_UPDATEOTHER 0x114
#define IDD_WAIT	    0x115
#define IDD_MESSAGE     0x116
#define IDD_CLIPOWNER   0x117
#define IDD_ITEM        0x118
#define IDD_PASTE       0x119
#define IDD_PASTELINK   0x11a
#define IDD_SOURCE      0x11b
#define IDD_SWITCH      0x11c

typedef enum { NONE, STATIC, EMBEDDED, LINK } OBJECTTYPE;

#define UPDATE_INVALID() CatchupInvalid(hDOCWINDOW)

#define PROTOCOL 	((LPSTR)"StdFileEditing")
#define	SPROTOCOL	((LPSTR)"Static")
#if OBJ_EMPTY_OBJECT_FRAME
#define nOBJ_BLANKOBJECT_X 0x480
#define nOBJ_BLANKOBJECT_Y 0x480
#else
#define nOBJ_BLANKOBJECT_X 0x0
#define nOBJ_BLANKOBJECT_Y 0x0
#endif

#define wOleMagic 0137062 // for ole file headers (wMagic+1)
#define OBJ_PLAYEDIT ObjPlayEdit
#if !defined(SMALL_OLE_UI)
#define EDITMENUPOS 9
#else
#define EDITMENUPOS 7
#endif

/* number of timer ticks between garbage collection */
#define GARBAGETIME  200
extern int nGarbageTime;

/* properties list flags */
#define OUT     0
#define IN      1
#define DELETED 2

/* for ObjDeletionOK and fnClearEdit */
#define OBJ_DELETING 0
#define OBJ_INSERTING  1
#define OBJ_CUTTING  2

#define UNDO_EVERY_UPDATE 
#undef UPDATE_UNDO

typedef char szOBJNAME[9];

/* object information that needn't be stored in file.  This is also used as
   the OLECLIENT structure passed to the OLE object creation API's.  It is
   passed as an argument into the Callback proc. */
struct _OBJINFO
{
    LPOLECLIENTVTBL   lpvtbl;
    unsigned fTooBig        : 1; // see LoadObject
    unsigned fWasUpdated    : 1; // Links diaog crappola
    unsigned fPropList      : 2; // Links diaog crappola
    unsigned fDirty         : 1; // changed size or got updated
    unsigned fDontSaveData  : 1; // see ObjSaveObject
    unsigned fBadLink       : 1; // Links dialog
    unsigned fKillMe        : 1; // means return FALSE for QUERYRETRY
    unsigned fDeleteMe      : 1; // means this object is deleted on OLE_RELEASE
                                 //   (set if can't call OleDelete)
    unsigned fReleaseMe      : 1; // means this object is released on OLE_RELEASE
                                 //   (set if can't call OleDelete)
    unsigned fFreeMe        : 1; // free ObjInfo on OLE_RELEASE
    unsigned fReuseMe       : 1;
    unsigned fInDoc         : 1; // see CollectGarbage

    /* waiting for server dialog flags */
    unsigned fCancelAsync   : 1; // means cancel pending async if possible
    unsigned fCompleteAsync : 1; // means must complete pending async to allow cancel
    unsigned fCanKillAsync  : 1; // like CompleteAsync, indicates cancel is possible

    int    OlePlay;          
    LPOLEOBJECT lpobject;
    ATOM  aName;        // docname for links, server class for unfinished insertnew objects,
    ATOM  aObjName;     // unique object name

    struct _OBJINFO FAR *lpclone;      // clone used for link properties cancel
    typeCP cpWhere;     /* cp where picinfo is to be found (only used in ObjHasChanged! for NONE objects) */
    OLECLIPFORMAT objectType;   /* dup of what's in picInfo (so can get type
                                   for unfinished objects not yet stored in a picinfo)
                                 */

    unsigned fCantDisplay  : 1;
} ;
typedef struct _OBJINFO OBJINFO;
typedef OBJINFO FAR * LPOBJINFO ;
typedef LPOBJINFO FAR * LPLPOBJINFO;

/* the following return OBJINFO pointers */
#define lpOBJ_QUERY_UPDATE_UNDO(lpPicInfo)  (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->lpUndoUpdate)
#if defined(UNDO_EVERY_UPDATE)
#define lpOBJ_QUERY_UPDATE_UNDO2(lpPicInfo)  (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->lpUndoUpdate2)
#endif
#define lpOBJ_QUERY_CLONE(lpPicInfo)        (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->lpclone)
#define lpOBJ_QUERY_INFO(lpPicInfo)         (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo)

/* the following return stuff from lpPicInfo */
#define dwOBJ_QUERY_OBJECT_NUM(lpPicInfo)   (((lpOBJPICINFO)(lpPicInfo))->dwObjNum)
#define dwOBJ_QUERY_DATA_SIZE(lpPicInfo)    (((lpOBJPICINFO)(lpPicInfo))->dwDataSize)
#define bOBJ_QUERY_IS_OBJECT(lpPicInfo)     (((lpOBJPICINFO)(lpPicInfo))->mm == MM_OLE)

/* the following return stuff from lpPicInfo->lpObjInfo */
#define otOBJ_QUERY_TYPE(lpPicInfo)         (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->objectType)
#define docOBJ_QUERY_DOC(lpPicInfo)        (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->doc)
#define cpOBJ_QUERY_WHERE(lpPicInfo)        (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->cpWhere)
#define lpOBJ_QUERY_CLONE_OBJECT(lpPicInfo)        (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->lpclone->lpobject)
//#define uoiFLAGS(lpObjInfo) (*((unsigned FAR *)((LPSTR)lpObjInfo + sizeof(LPOLECLIENTVTBL))))
#define bOBJ_REUSE_ME(lpPicInfo)            (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fReuseMe)
#define fOBJ_INDOC(lpPicInfo)               (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fInDoc)
#define fOBJ_BADLINK(lpPicInfo)             (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fBadLink)
#define bOBJ_QUERY_DONT_SAVE_DATA(lpPicInfo) (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fDontSaveData)
#define bOBJ_QUERY_DATA_INVALID(lpPicInfo)  (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fDataInvalid)
#define bOBJ_QUERY_TOO_BIG(lpPicInfo)       (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fTooBig)
#define bOBJ_WAS_UPDATED(lpPicInfo)         (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fWasUpdated)
//#define aOBJ_QUERY_SERVER_CLASS(lpPicInfo)  (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->aName)
#define aOBJ_QUERY_DOCUMENT_LINK(lpPicInfo) (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->aName)
#define lpOBJ_QUERY_OBJECT(lpPicInfo)       (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->lpobject)
#define fOBJ_QUERY_DIRTY_OBJECT(lpPicInfo)  (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fDirty)
#define fOBJ_QUERY_IN_PROP_LIST(lpPicInfo)  (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->fPropList)
#define fOBJ_QUERY_PLAY(lpPicInfo)          (((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->OlePlay)
#define cfOBJ_QUERY_CLIPFORMAT(lpPicInfo)   ( \
    ((((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->objectType) == EMBEDDED) ? vcfNative : \
    ((((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->objectType) == LINK)     ? vcfLink : \
    ((((lpOBJPICINFO)(lpPicInfo))->lpObjInfo->objectType) == STATIC)   ? vcfOwnerLink : NULL)



/* this coerces the PICINFO structure: */
typedef struct
{
    /* overlay METAFILEPICT structure: */
    int mm;                     // mfp.mm  (MM_OLE if an object)
    WORD xExt; // not used
    WORD yExt; // not used
    OLECLIPFORMAT objectType;   // mfp.hMF

    /* real PICINFO stuff we won't mess with: */
    int  dxaOffset;
    int  dxaSize;
    int  dyaSize;
    WORD cbOldSize; // not used

    /* overlay the BITMAP structure: */
    DWORD   dwDataSize;       // bmType,bmWidth, this supercedes cbSize
    WORD  bmHeight; // not used
    WORD  bmWidthBytes; // not used
    DWORD dwObjNum;           // bmPlanes,bmBitsPixel, 2 bytes of bmBits
    WORD  bmBits; // two bytes of it, not used
    /** 
        If you want to add more fields here, don't wipe out the cbHeader,
        mx and my fields because they are being used. 
     **/
    unsigned cbHeader;        
    LPOBJINFO lpObjInfo;      // cbSize
    unsigned mx, my;         
} OBJPICINFO, FAR *lpOBJPICINFO;

extern LPLPOBJINFO lplpObjInfo;
extern LHCLIENTDOC      lhClientDoc;
extern BOOL	            fOleEnabled;
extern LPOLESTREAM	    lpStream;
extern OLESTREAMVTBL	streamTbl;
extern OLECLIENTVTBL	clientTbl;
//extern LPOLECLIENT	    lpclient;
extern OBJECTTYPE       votObjSelType;

extern HWND		        hwndLinkWait;
extern FARPROC          lpfnLinkProps;
extern FARPROC          lpfnObjProps;
extern FARPROC          lpfnWaitForObject;
extern FARPROC          lpfnInvalidLink;
extern FARPROC          lpfnInsertNew;
extern FARPROC          lpfnPasteSpecial;
extern BOOL             vbObjLinkOnly;
extern BOOL             vObjPasteLinkSpecial;
extern WORD             cfObjPasteSpecial;
//extern int              vcEmbeds;
extern int		        cObjWait;	/* Count of "open" OLE transactions */
extern OLECLIPFORMAT	vcfNative;
extern OLECLIPFORMAT	vcfLink;
extern OLECLIPFORMAT	vcfOwnerLink;
extern ATOM             aNewName;
extern ATOM             aOldName;    
extern BOOL             bLinkProps;
extern int              vcObjects;  // count in doc. Note limit of 32K!!!
extern int              ObjPlayEdit;
extern int              nBlocking;
extern int              vcVerbs;
extern BOOL             vbCancelOK;
extern HWND		        hwndWait;

void CatchupInvalid(HWND hWnd);
extern int FAR PASCAL fnPasteSpecial(HWND hDlg, unsigned message, WORD wParam, LONG lParam);
extern int FAR PASCAL fnInsertNew(HWND hDlg, unsigned msg, WORD wParam, LONG lParam) ;
extern BOOL FAR PASCAL fnObjWait(HWND hDlg, unsigned msg, WORD wParam, LONG lParam);
extern   int far PASCAL fnProperties();
extern   int far PASCAL fnInvalidLink();
extern   void fnObjDoVerbs(WORD wVerb);
extern   void fnObjProperties(void);
extern   void fnObjInsertNew(void);
extern   BOOL fnObjFreeze(LPOLEOBJECT far *lplpObject, szOBJNAME szObjName);
extern   BOOL fnObjActivate(LPOLEOBJECT lpObject);
extern   BOOL fnObjUpdate(LPOBJINFO lpObjInfo);
extern   void fnObjPasteSpecial(void);
extern   ATOM MakeLinkAtom(LPOBJINFO lpObjInfo);


#ifdef DEBUG
extern void ObjPrintError(WORD stat,BOOL bRelease);
#endif

extern BOOL ObjUpdateFromPicInfo(OBJPICINFO *pPicInfo,szOBJNAME szObjName);
extern BOOL ObjUpdateFromObjInfo(OBJPICINFO *pPicInfo);
void FinishUp(void);
BOOL FinishAllAsyncs(BOOL bAllowCancel);
BOOL FAR ObjError(OLESTATUS olestat) ;
extern BOOL ObjDeletionOK(int nMode);
//extern BOOL ObjContainsUnfinished(int doc, typeCP cpFirst, typeCP cpLim);
extern BOOL ObjContainsOpenEmb(int doc, typeCP cpFirst, typeCP cpLim, BOOL bLookForUnfinished);
extern BOOL ObjSetTargetDeviceForObject(LPOBJINFO lpObjInfo);
extern void ObjSetTargetDevice(BOOL bSetObjects);
extern BOOL ObjSetClientInfo(LPOBJINFO lpObjInfoNew, LPOLEOBJECT lpobj);
extern  WORD  _cdecl  CheckPointer (LPSTR lp, WORD access);
extern LPOBJINFO ObjGetClientInfo(LPOLEOBJECT lpobj);
extern BOOL ObjIsValid(LPOLEOBJECT lpobj);
extern BOOL ObjFreeObjInfoWithObject(LPOLEOBJECT lpObject);
extern BOOL ObjAllocObjInfo(OBJPICINFO *,typeCP,OBJECTTYPE,BOOL,szOBJNAME);
extern BOOL ObjFreeObjInfo(OBJPICINFO *pPicInfo);
extern LONG FAR PASCAL BufReadStream(LPOLESTREAM lpStream, char huge *lpstr, DWORD cb) ;
extern LONG FAR PASCAL BufWriteStream(LPOLESTREAM lpStream, char huge *lpstr, DWORD cb) ;
extern BOOL ObjUpdatePicSize(OBJPICINFO *pPicInfo, typeCP cpParaStart);
extern BOOL ObjSetPicInfo(OBJPICINFO *pSrcPicInfo, int doc, typeCP cpParaStart);
extern void ObjCachePara(int doc, typeCP cp);
extern void ObjUpdateMenu(HMENU hMenu);
extern void ObjUpdateMenuVerbs( HMENU hMenu );
extern void ObjShutDown(void);
extern BOOL ObjInit(HANDLE hInstance);
extern BOOL ObjCreateObjectInClip(OBJPICINFO *pPicInfo);
extern BOOL ObjWriteToClip(OBJPICINFO FAR *lpPicInfo);
extern BOOL ObjDisplayObjectInDoc(OBJPICINFO FAR *lpPicInfo, int doc, typeCP cpParaStart, HDC hDC, LPRECT lpBounds);
extern BOOL ObjQueryObjectBounds(OBJPICINFO FAR *lpPicInfo, HDC hDC, 
                            int *pdxa, int *pdya);
extern ObjGetPicInfo(LPOLEOBJECT lpObject, int doc, OBJPICINFO *pPicInfo, typeCP *pcpParaStart);
extern BOOL ObjQueryNewLinkName(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern BOOL CloseUnfinishedObjects(BOOL bSaving);
extern BOOL ObjOpenedDoc(int doc);
extern BOOL ObjClosingDoc(int docOld,LPSTR szNewDocName);
extern BOOL ObjSavingDoc(BOOL bFormatted);
extern void ObjSavedDoc(void);
extern void ObjRenamedDoc(LPSTR szNewName);
extern void ObjRevertedDoc();
extern void ObjObjectHasChanged(int flags, LPOBJINFO lpObjInfo);
extern void ObjGetObjectName(LPOBJINFO lpObjInfo, szOBJNAME szObjName);
extern void ObjMakeObjectName(LPOBJINFO lpObjInfo, LPSTR lpstr);
extern void ObjHandleBadLink(OLE_RELEASE_METHOD rm, LPOLEOBJECT lpObject);
extern void ObjQueryInvRect(OBJPICINFO FAR *lpPicInfo, RECT *rc, typeCP cp);
extern void ObjReleaseError(OLE_RELEASE_METHOD rm);
extern char *ObjGetServerName(LPOLEOBJECT lpObject, char *szServerName);
extern void ObjGetDrop(HANDLE hDrop, BOOL bOpenFile);
extern LPOBJINFO GetObjInfo(LPOLEOBJECT lpObject);
extern BOOL ObjDeleteObjInfo(LPOBJINFO lpOInfo);

/* enumeration functions */
extern LPLPOBJINFO EnumObjInfos(LPLPOBJINFO lpObjInfoPrev);
extern ObjPicEnumInRange(OBJPICINFO *pPicInfo,int doc, typeCP cpFirst, typeCP cpLim, typeCP *cpCur);
typedef typeCP (FAR PASCAL *cpFARPROC)();
extern int ObjEnumInDoc(int doc, cpFARPROC lpFunc);
extern int ObjEnumInAllDocs(cpFARPROC lpFunc);
extern int ObjEnumInRange(int doc, typeCP cpStart, typeCP cpEnd, cpFARPROC lpFunc);
extern typeCP ObjSaveObjectToDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjReleaseObjectInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjLoadObjectInDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjNullObjectInDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjDeleteObjectInDoc (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjCloneObjectInDoc  (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjCheckObjectTypes  (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjChangeLinkInDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjFreezeObjectInDoc (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjUpdateObjectInDoc (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjUpdateLinkInDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjMakeUniqueInDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjPlayObjectInDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjEditObjectInDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjSetNoUpdate       (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjToCloneInDoc      (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjFromCloneInDoc    (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjClearCloneInDoc   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjUseCloneInDoc     (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjBackupInDoc       (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjNewDocForObject   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjSetHostNameInDoc  (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjSetUpdateUndo     (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjClearUpdateUndo   (OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart);
extern typeCP ObjCloseObjectInDoc(OBJPICINFO *pPicInfo, int doc, typeCP cpParaStart);

extern BOOL ObjCreateObjectInDoc (int doc,typeCP cpParaStart);
extern void ObjDoUpdateUndo(int doc,typeCP cpParaStart);
extern BOOL ObjSetData(OBJPICINFO far *lpPicInfo, OLECLIPFORMAT cf, HANDLE hData);
extern OLESTATUS ObjGetData(LPOBJINFO lpObjInfo, OLECLIPFORMAT cf, HANDLE far *lphData);
extern void UpdateOtherLinks(int doc);
extern void ChangeOtherLinks(int doc, BOOL bChange, BOOL bPrompt);
extern BOOL ObjSetUpdateOptions(OBJPICINFO *pPicInfo, WORD wParam, int doc, typeCP cpParaStart) ;
extern OLEOPT_UPDATE ObjGetUpdateOptions(OBJPICINFO far *lpPicInfo);
extern BOOL ObjWaitForObject(LPOBJINFO lpObjInfo,BOOL bCancelOK);
extern BOOL ObjObjectSync(LPOBJINFO lpObjInfo, OLESTATUS (FAR PASCAL *lpProc)(LPOLEOBJECT lpObject),BOOL bCancelOK);
extern int ObjSetSelectionType(int doc, typeCP cpFirst, typeCP cpLim);
extern BOOL ObjQueryCpIsObject(int doc,typeCP cpFirst);
extern FixInvalidLink(OBJPICINFO far *lpPicInfo,int doc, typeCP cpParaStart);
extern void OfnInit(HANDLE hInst);
extern ObjPushParms(int doc);
extern ObjPopParms(BOOL bCache);
void ObjWriteClearState(int doc);
extern void ObjInvalidateObj(LPOLEOBJECT lpObject);
extern void ObjInvalidatePict(OBJPICINFO *pPicInfo, typeCP cp);
extern BOOL ObjDeletePrompt(int doc,typeCP cpFirst,typeCP cpLim);
extern BOOL ObjSetHostName(LPOBJINFO lpOInfo, int doc);
extern void ObjTryToKill(OBJPICINFO *pPicInfo);
extern BOOL ObjCloneObjInfo(OBJPICINFO *pPicInfo, typeCP cpParaStart, szOBJNAME szObjName);
extern LPOBJINFO ObjGetObjInfo(szOBJNAME szObjName);
extern BOOL ObjCopyObjInfo(LPOBJINFO lpOldObjInfo, LPLPOBJINFO lplpNewObjInfo, szOBJNAME szObjName);
extern BOOL ObjDeleteObject(LPOBJINFO lpObjInfo,BOOL bDelete);
extern void ObjAdjustCps(int doc,typeCP cpLim, typeCP dcpAdj);
extern void ObjAdjustCpsForDeletion(int doc);
extern BOOL GimmeNewPicinfo(OBJPICINFO *pPicInfo, LPOBJINFO lpObjInfo);
extern BOOL ObjMakeObjectReady(OBJPICINFO *pPicInfo, int doc, typeCP cpParaStart);
extern BOOL ObjInitServerInfo(LPOBJINFO lpObjInfo);

#ifdef KOREA
extern CHAR     szAppName[13];
#else
extern CHAR     szAppName[10];
#endif

extern HWND     vhWndMsgBoxParent,hParentWw,vhWnd;
extern HANDLE   hMmwModInstance;
extern int              vdocParaCache;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern int              docCur;
extern struct SEL       selCur;
extern int  docMac;

#define	WM_UPDATELB	    (WM_USER+0x100)
#define	WM_UPDATEBN	    (WM_USER+0x101)
#define	WM_OBJUPDATE    (WM_USER+0x102)
#define	WM_OBJERROR     (WM_USER+0x103)
#define	WM_OBJBADLINK   (WM_USER+0x104)
#define	WM_DOLINKSCOMMAND (WM_USER+0x105)
#define WM_UPDATE_INVALID (WM_USER+0x106)
#define WM_OBJDELETE     (WM_USER+0x107)
#define WM_DIESCUMSUCKINGPIG     (WM_USER+0x108)
#define WM_RUTHRUYET        (WM_USER+0x109)
#define WM_UKANKANCEL       (WM_USER+0x10a)
#define WM_WAITFORSERVER    (WM_USER+0x10b)

#define szDOCCLASS "WINWRITE"
#define hINSTANCE  hMmwModInstance
#define hDOCWINDOW vhWnd
#define hMAINWINDOW hParentWw
#define hPARENTWINDOW  ((vhWndMsgBoxParent == NULL) ? \
                    hParentWw : vhWndMsgBoxParent)

#define OBJ_SELECTIONTYPE (votObjSelType)

typedef struct {
    WORD deviceNameOffset;
    WORD driverNameOffset;
    WORD portNameOffset;
    WORD extDevmodeOffset;
    WORD extDevmodeSize;
    WORD environmentOffset;
    WORD environmentSize;
} STDTARGETDEVICE;
typedef STDTARGETDEVICE FAR *LPSTDTARGETDEVICE;

#if 0
typedef struct _RAWOLEOBJECT {
    LPOLEOBJECTVTBL lpvtbl;
    char            objId[2];
    HOBJECT         hobj;
    LPOLECLIENT     lpclient;
    } RAWOBJECT;
typedef RAWOBJECT FAR *LPRAWOBJECT;
#endif

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\obj2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#include "windows.h"
#include "mw.h"
#include "winddefs.h"
#include "docdefs.h"
#include "propdefs.h"
#include "editdefs.h"
#include "filedefs.h"
#include "cmddefs.h"
#include "obj.h"
#include "str.h"
#include "objreg.h"
#include <commdlg.h>
#include <stdlib.h>  // for strtoul()

extern struct CHP       vchpNormal;
extern struct DOD (**hpdocdod)[];
extern BOOL ferror;
extern struct PAP      vpapAbs;
extern struct PAP      vpapPrevIns;
extern struct PAP   *vppapNormal;
extern int     vdocParaCache;
extern struct UAB       vuab;
extern int vfOutOfMemory,vfSysFull;
extern int          docUndo;
extern struct FCB (**hpfnfcb)[];
extern HCURSOR		vhcArrow;

/* intercepted stream functions work with this buffer */
static typeCP cpObjectDataCurLoc=cp0, cpObjectDataBase=cp0;
static DWORD cObjectData=0L,dwDataMax;
static int docStream;
static struct CHP *pchpStream;
static struct PAP *ppapStream;

static OPENFILENAME    OFN;

static void GetChp(struct CHP       *pchp, typeCP cp, int doc);
static BOOL ObjParaDup(int doc, typeCP cpFirst, typeCP cpLim);
static BOOL bUniqueData(int doc, typeCP cpFirst, typeCP cpLim);
static ObjOpenStreamIO(typeCP cpParaStart, int doc, struct CHP *pchp, struct PAP *ppapGraph, DWORD dwObjectSize);
static void ObjCloseStreamIO(void);
static typeCP ObjWriteDataToDoc( LPOLEOBJECT lpObject);
static HANDLE OfnGetNewLinkName(HWND hwnd, HANDLE hData);
static void Normalize(LPSTR lpstrFile) ;
static HANDLE ObjMakeNewLinkName(HANDLE hData, ATOM atom) ;
static char            szCustFilterSpec[CBFILTERMAX];
static char            szFileName[CBPATHMAX];
//static char            szFilterSpec[CBFILTERMAX];
//static char            szLastDir[CBPATHMAX];
static char            szLinkCaption[cchMaxSz];
static char            szTemplateName[CBPATHMAX];
static BOOL             fUpdateAll = FALSE;
static BOOL             ObjStop=FALSE;
static BOOL             vbChangeOther;
BOOL                    bNoEol=FALSE;

#define ulmin(a,b)      ((DWORD)(a) < (DWORD)(b) ? \
                         (WORD)(a) : (WORD)(b))


/****************************************************************/
/**************** OLE ENUMERATION FUNCTIONS *********************/
/****************************************************************/

#if 0 // good, just not used
int
ObjEnumInAllDocs(cpFARPROC lpFunc)
{
    int doc,count=0;
    for (doc = 0; doc < docMac; doc++)
    {
        int nRetval;

        nRetval = ObjEnumInDoc(doc, lpFunc);

        if (nRetval < 0)
            return -1;
        else
            count += nRetval;
    }
    return count;
}
#endif

int
ObjEnumInDoc(int doc, cpFARPROC lpFunc)
{
    typeCP cpMac = (**hpdocdod) [doc].cpMac;

    return ObjEnumInRange(doc, cp0, cpMac, lpFunc);
}


int
ObjEnumInRange(int doc, typeCP cpStart, typeCP cpEnd, cpFARPROC lpFunc)
/*  Call lpFunc for each OLE object.  
    lpFunc takes the following args: 
        a far pointer to a PICINFOX struct (can be NULL).
        an int for the doc we're operating on.
        a typeCP that gives the cp position of the PICINFOX struct.
    lpFunc returns the cp of the paragraph following the PICINFO struct
        if OK, or cp0 if error.
    Enumeration quits if error returned from FARPROC.
    Return number of objects operated on, or -1 if error. 
*/
{
        typeCP cpNow, cpLimPara;
        int count;

        /* Loop on paras */

        for ( count = 0, cpNow = cpStart; cpNow < cpEnd; cpNow = cpLimPara )
        {

            Assert(cpEnd <= (**hpdocdod) [doc].cpMac);

            /* this shouldn't happen */
            if (cpEnd > (**hpdocdod) [doc].cpMac)
                goto done;

            ObjCachePara( doc, cpNow );

            if (vpapAbs.fGraphics)
            {
                /* get PICINFO struct and see if its an object */
                OBJPICINFO  picInfo;
                GetPicInfo(vcpFirstParaCache,vcpFirstParaCache + cchPICINFOX, doc, &picInfo);
                if (bOBJ_QUERY_IS_OBJECT(&picInfo))
                {
                    typeCP cpOldLimPara = vcpLimParaCache;

                    if (!lpFunc)
                        cpLimPara = vcpLimParaCache;
                    else
                        if ((cpLimPara = (*lpFunc)(&picInfo,doc,vcpFirstParaCache)) == 0)
                            goto error;

                    ++count;

                    /* amount para has grown ( < 0 if shrunk, 0 if none )*/
                    cpEnd += cpLimPara - cpOldLimPara;

                    continue;
                }
            }

            cpLimPara = vcpLimParaCache;
        }

        /* success */
        goto done;

        error:
        count = -1;

        done:

        return count;
}

ObjPicEnumInRange(OBJPICINFO *pPicInfo,int doc, typeCP cpFirst, typeCP cpLim, typeCP *cpCur) 
/*  
    Enumerate over PicInfos between cpFirst and cpLim in doc. If 
    cpCur == cpNil, then start at cpFirst, else start at *cpCur.  
    Return 0 if done, 1 otherwise.
    Calls ObjCachePara() at picInfo.
*/
{
    /* static typeCP cpCur;
       used to use static, but that prevented being able to recursively
       call this function, and its almost impossible to prevent with
       asynchronicity rampant.
    */

    typeCP cpMac = (**hpdocdod) [doc].cpMac;

    if (cpFirst >= cpMac)
        return 0;

    if (cpLim > cpMac)
        cpLim = cpMac;

    /* initialize cpCur */
    if (*cpCur == cpNil)
        /* then starting afresh */
        *cpCur = cpFirst;
    else
    {
        ObjCachePara(doc,*cpCur); // cache the previous para
        *cpCur = vcpLimParaCache;  // get next para
    }

    /* pull in next para */
    do
    {
        if (*cpCur >= cpLim)
        {
            /* all done */
            *cpCur = vcpFirstParaCache; // we want to point to last para hit
            return 0;
        }

        ObjCachePara(doc,*cpCur);

        if (vpapAbs.fGraphics)
        {
            GetPicInfo(*cpCur,*cpCur + cchPICINFOX, doc, pPicInfo);
            if (bOBJ_QUERY_IS_OBJECT(pPicInfo))
                return 1;
        }
        *cpCur = vcpLimParaCache;
    }
    while (1);
}

typeCP ObjSaveObjectToDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/* 
    Assumes para is cached.  
    In some cases we only write the picinfo.  In others we write the
    object data after the picinfo.  We assume that the latter case
    only occurs when the file is being saved.
*/
{
    typeCP cpRetval;  // cp of next byte in doc after what we just wrote
    static BOOL bMyRecurse=FALSE;
    DWORD dwObjectSize;
    OLESTATUS olestat;
    struct CHP chp;
    struct PAP          papGraph;

    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);
        
    if (lpOBJ_QUERY_OBJECT(pPicInfo) == NULL)
        return(vcpLimParaCache);
        
    /* we don't save nothing if it ain't dirty and has data */
    if (!fOBJ_QUERY_DIRTY_OBJECT(pPicInfo) &&
        dwOBJ_QUERY_DATA_SIZE(pPicInfo) != 0L)
        return(vcpLimParaCache);

    if (vfOutOfMemory || vfSysFull /*|| ObjStop*/)
        return cp0;

    olestat = OleQuerySize(lpOBJ_QUERY_OBJECT(pPicInfo),&dwObjectSize);

    if (olestat == OLE_ERROR_BLANK)
        dwObjectSize = 0L;
    else if (ObjError(olestat))
        return cp0;

    /** don't let this function recurse (in CallBack) **/
    if (bMyRecurse)
    {
        Assert(0); // this has never happened yet (8.21.91) v-dougk
        return cp0;
    }
    bMyRecurse = TRUE;

    fOBJ_QUERY_DIRTY_OBJECT(pPicInfo) = FALSE;

    /** 
        If docUndo will want to undo some region that contains this
        object, and if saving the object changes the size of that
        region, then vuab will become obsolete.
    **/

    ObjWriteClearState(doc);

    GetChp(&chp, cpParaStart, doc);

    if (dwOBJ_QUERY_DATA_SIZE(pPicInfo) != 0xFFFFFFFF)
    /* then has been saved before */
    {
        /* zap the entire existing object */
        papGraph = vpapAbs;
        Replace(doc, cpParaStart, (vcpLimParaCache - vcpFirstParaCache), fnNil, fc0, fc0);
    }
    else // new object
    {
        ObjCachePara(doc,cpParaStart-1); // use previous PAP
        papGraph = vpapAbs;
        papGraph.fGraphics = TRUE;
        ObjCachePara(doc,cpParaStart);
    }

    if (otOBJ_QUERY_TYPE(pPicInfo) == NONE)
    {
        if (dwObjectSize)
        /* 
            Insert New has culminated in a new baby object!
        */
        {
            otOBJ_QUERY_TYPE(pPicInfo) = EMBEDDED; // do this first
            if (!FComputePictSize(pPicInfo, &(pPicInfo->dxaSize), &(pPicInfo->dyaSize)))
            {
                cpRetval = cp0;
                goto end;
            }
#if 0
	        DeleteAtom(aOBJ_QUERY_SERVER_CLASS(pPicInfo));
	        aOBJ_QUERY_SERVER_CLASS(pPicInfo) = NULL;
#endif
        }
        else // don't save empty object
        {
            Assert(0);
            goto end;
        }
    }

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Saving object\n\r");
#endif

    /* 
        Insert PICINFO struct.  There is a problem here which is a 
        bug in Write (CheckGraphic()).  EOL gets inserted when we are
        replacing an object which is immediately in front of
        another object.  Kludge is to set this flag to inhibit.
    */
    bNoEol = TRUE;

    if (bOBJ_QUERY_DONT_SAVE_DATA(pPicInfo))
    /* only save picinfo until user does File.Save */
    {
        ObjUpdateFromObjInfo(pPicInfo);

        bOBJ_QUERY_DONT_SAVE_DATA(pPicInfo) = FALSE;
        dwOBJ_QUERY_DATA_SIZE(pPicInfo) = 0L;

        pPicInfo->mm |= MM_EXTENDED;    /* Extended file format */
        InsertRgch( doc, cpParaStart, pPicInfo, sizeof(OBJPICINFO), &chp, &papGraph);
        pPicInfo->mm &= ~MM_EXTENDED;

        ObjCachePara(doc,cpParaStart);
        cpRetval = vcpLimParaCache;
    }
    else
    {
        dwOBJ_QUERY_DATA_SIZE(pPicInfo) = dwObjectSize;
        ObjUpdateFromObjInfo(pPicInfo);

        pPicInfo->mm |= MM_EXTENDED;    /* Extended file format */
        InsertRgch( doc, cpParaStart, pPicInfo, sizeof(OBJPICINFO), &chp, NULL );
        pPicInfo->mm &= ~MM_EXTENDED;

        /* insert object data into doc */
        ObjOpenStreamIO(cpParaStart + cchPICINFOX, doc, &chp, &papGraph, dwObjectSize);
        cpRetval = ObjWriteDataToDoc(lpOBJ_QUERY_OBJECT(pPicInfo));
        ObjCloseStreamIO();
    }

    bNoEol = FALSE;

    end:

    ObjCachePara(doc,cpParaStart);

    bMyRecurse = FALSE;
    return ((cpRetval == cp0) ? cp0 : vcpLimParaCache);
}

typeCP ObjLoadObjectInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/*  
    Do an OleLoad from object data in doc.  Set lpobject in PICINFO struct.
    Assumes para is cached.
    This is a *synchronous* function.
*/
{
    typeCP cpRetval = vcpLimParaCache;
    szOBJNAME szObjName;

    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
    {
        if (ObjAllocObjInfo(pPicInfo,cpParaStart,pPicInfo->objectType,FALSE,NULL))
            return(cp0);

        if (ObjSetPicInfo(pPicInfo, doc, cpParaStart))
            return(cp0);
    }

    else if (lpOBJ_QUERY_OBJECT(pPicInfo)) // already loaded
        return(vcpLimParaCache);

    if (otOBJ_QUERY_TYPE(pPicInfo) == NONE)
        return(vcpLimParaCache);

    if (bOBJ_QUERY_TOO_BIG(pPicInfo)) // ObjLoadObject previously failed
        return(cp0);

    if ((dwOBJ_QUERY_DATA_SIZE(pPicInfo) == 0L) ||
        (dwOBJ_QUERY_DATA_SIZE(pPicInfo) == 0xFFFFFFFFL))
        /* then has no data */
        return(cp0);

    if (vfOutOfMemory || vfSysFull /*|| ObjStop*/)
        return cp0;

    StartLongOp();

    ObjGetObjectName(lpOBJ_QUERY_INFO(pPicInfo),szObjName);

    Assert(szObjName[0]);

    ObjOpenStreamIO(cpParaStart + cchPICINFOX, doc, NULL, NULL, 0L);

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Loading object\n\r");
#endif

    if (ObjError(OleLoadFromStream(lpStream,
        otOBJ_QUERY_TYPE(pPicInfo) == STATIC ? SPROTOCOL : PROTOCOL,
        (LPOLECLIENT)lpOBJ_QUERY_INFO(pPicInfo),
        lhClientDoc,szObjName,&lpOBJ_QUERY_OBJECT(pPicInfo))))
    {
         /*  mark as unloadable to prevent infinite LoadObject loops */
         bOBJ_QUERY_TOO_BIG(pPicInfo) = TRUE;
         lpOBJ_QUERY_OBJECT(pPicInfo) = NULL; // just in case (OLE ain't good about this)
         ferror = FALSE; // be sure to issue this message
         Error(IDPMTFailedToLoadObject);
         cpRetval = cp0;
         goto end;
    }

    if (ObjInitServerInfo(lpOBJ_QUERY_INFO(pPicInfo)))
    {
        ferror = FALSE; // be sure to issue this message
        Error(IDPMTOLEError);
        goto end;
    }

    if (ObjUpdatePicSize(pPicInfo,cpParaStart))
        if (ObjSetPicInfo(pPicInfo, doc, cpParaStart))
            goto end;

    ObjCachePara(doc,cpParaStart); // just in case

    cpRetval = vcpLimParaCache;

    end:
    ObjCloseStreamIO();
	EndLongOp(vhcArrow);
    return cpRetval;
}

typeCP ObjEditObjectInDoc(OBJPICINFO *pPicInfo, int doc, typeCP cpParaStart)
{
    typeCP cpRetval;
    OBJ_PLAYEDIT = OLEVERB_PRIMARY+1;
    cpRetval = ObjPlayObjectInDoc(pPicInfo, doc, cpParaStart);
    OBJ_PLAYEDIT = OLEVERB_PRIMARY;  // the default
    return cpRetval;
}

typeCP ObjPlayObjectInDoc(OBJPICINFO *pPicInfo, int doc, typeCP cpParaStart)
{
    OLESTATUS olestat;
    LPOBJINFO lpOInfo=lpOBJ_QUERY_INFO(pPicInfo);

    if ((otOBJ_QUERY_TYPE(pPicInfo) == STATIC) ||
        (otOBJ_QUERY_TYPE(pPicInfo) == NONE))
        return(vcpLimParaCache);

    if (ObjMakeObjectReady(pPicInfo,doc,cpParaStart))
        goto err;

    fOBJ_QUERY_PLAY(pPicInfo) = OBJ_PLAYEDIT; 

    do
    {
#ifdef DEBUG
        OutputDebugString( "Opening Object\n\r");
#endif

        StartLongOp();
        olestat = OleActivate(lpOBJ_QUERY_OBJECT(pPicInfo), 
                            OBJ_PLAYEDIT,
                            TRUE, 
                            TRUE, 
                            hDOCWINDOW, 
                            NULL);
	    EndLongOp(vhcArrow);

        switch (olestat)
        {
            /* check for bad link */
            case OLE_ERROR_OPEN:
            case OLE_ERROR_ADVISE_NATIVE:
            case OLE_ERROR_ADVISE_PICT: 
            case OLE_ERROR_REQUEST_NATIVE:
            case OLE_ERROR_REQUEST_PICT:

            fOBJ_BADLINK(pPicInfo) = TRUE;
            if (bLinkProps)
            {
                Error(IDPMTLinkUnavailable);
                goto err;
            }
            else
            {
                ObjCachePara(doc,cpParaStart);
                if (!FixInvalidLink(pPicInfo,doc,cpParaStart))
                    goto err;
                olestat = OLE_OK;
                lpOInfo->fCompleteAsync = TRUE; // cancel OleSetData (FixInvalid) as well
                if (ObjWaitForObject(lpOInfo,TRUE))
                    goto err;
            }
            break;
        }

        if (ObjError(olestat))
            goto err;
        else
            break;
    }
    while (1);

    fOBJ_BADLINK(pPicInfo) = FALSE; // can't be bad if succeeded
    //(**hpdocdod) [doc].fDirty = TRUE; // assume dirty is opened.
    ObjCachePara(doc,cpParaStart); // just in case
    return(vcpLimParaCache);

    err:
    Error(IDPMTFailedToActivate);
    return cp0;
}

typeCP ObjUpdateObjectInDoc(OBJPICINFO *pPicInfo, int doc, typeCP cpParaStart)
{
    int xSize,ySize;
    BOOL  bUpdate = FALSE;
    OLESTATUS olestat;

    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);
        
    if ((otOBJ_QUERY_TYPE(pPicInfo) == STATIC) ||
        (otOBJ_QUERY_TYPE(pPicInfo) == NONE))
        return(vcpLimParaCache);

    if (bLinkProps && bOBJ_WAS_UPDATED(pPicInfo))
        return(vcpLimParaCache);

    if (ObjMakeObjectReady(pPicInfo,doc,cpParaStart))
        goto err;

    do
    {
#ifdef DEBUG
        OutputDebugString( "Updating Object\n\r");
#endif

        StartLongOp();
        olestat = OleUpdate(lpOBJ_QUERY_OBJECT(pPicInfo));
	    EndLongOp(vhcArrow);

        switch (olestat)
        {
            /* check for bad link */
            case OLE_ERROR_OPEN:
            case OLE_ERROR_ADVISE_NATIVE:
            case OLE_ERROR_ADVISE_PICT: 
            case OLE_ERROR_REQUEST_NATIVE:
            case OLE_ERROR_REQUEST_PICT:

            fOBJ_BADLINK(pPicInfo) = TRUE;
            if (bLinkProps)
            {
                Error(IDPMTLinkUnavailable);
                goto err;
            }
            else
            {
                ObjCachePara(doc,cpParaStart);
                if (!FixInvalidLink(pPicInfo,doc,cpParaStart))
                    goto err;
                olestat = OLE_OK;
                lpOBJ_QUERY_INFO(pPicInfo)->fCompleteAsync = TRUE; // cancel OleSetData (FixInvalid) as well 
                if (ObjWaitForObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE))
                    goto err;
            }
            break;
        }

        if (ObjError(olestat))
            goto err;
        else
            break;
    }
    while (1);

    ObjCachePara(doc,cpParaStart); // just in case

    fOBJ_BADLINK(pPicInfo) = FALSE; // can't be bad if succeeded

    if (bLinkProps)
    {
        bOBJ_WAS_UPDATED(pPicInfo) = TRUE;
    }

    return(vcpLimParaCache);

    err:
    Error(IDPMTFailedToUpdate);
    return cp0;
}

typeCP ObjFreezeObjectInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
{
    szOBJNAME szObjName;
    OBJPICINFO NewPicInfo = *pPicInfo;

    if ((otOBJ_QUERY_TYPE(pPicInfo) == STATIC) || 
        (otOBJ_QUERY_TYPE(pPicInfo) == NONE))
        return(vcpLimParaCache);

    if (ObjMakeObjectReady(pPicInfo,doc,cpParaStart))
        goto err;

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Freezing object\n\r");
#endif

    if (ObjCloneObjInfo(&NewPicInfo, cpParaStart, szObjName))
        return cp0;

    /* Make the object static.  Note side effect of changing lpObject!! */
    if (ObjError(OleObjectConvert(lpOBJ_QUERY_OBJECT(pPicInfo), SPROTOCOL,
                (LPOLECLIENT)lpOBJ_QUERY_INFO(&NewPicInfo), 
                lhClientDoc, szObjName, 
                &lpOBJ_QUERY_OBJECT(&NewPicInfo))))
        goto err;

    /* now delete original */
    ObjDeleteObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE);

    *pPicInfo = NewPicInfo;
    fOBJ_QUERY_DIRTY_OBJECT(pPicInfo) = TRUE;
    otOBJ_QUERY_TYPE(pPicInfo) = STATIC;

    /* we got a new name to save */
    if (ObjSetPicInfo(pPicInfo, doc, cpParaStart))
        goto err;

    return(vcpLimParaCache);

    err:
    ObjDeleteObjInfo(lpOBJ_QUERY_INFO(&NewPicInfo));
    Error(IDPMTFailedToFreeze);
    return cp0;
}

typeCP ObjCloneObjectInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/* note we are *not* deleting the cloned object!   Note side effect that
   *pPicInfo gets altered to new clone values. */
{
    BOOL fDirty;
    szOBJNAME szObjName;
    OBJPICINFO NewPicInfo = *pPicInfo;
    LPOLEOBJECT lpObject;

    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);

    if (bOBJ_REUSE_ME(pPicInfo))
    /* assume that the original picInfo will be deleted!!! */
    {

#ifdef DEBUG
        OutputDebugString( (LPSTR) "Reusing object\n\r");
#endif
        bOBJ_REUSE_ME(pPicInfo) = FALSE;
        return(vcpLimParaCache);
    }

    if (ObjMakeObjectReady(pPicInfo,doc,cpParaStart))
        goto err;

    lpObject = lpOBJ_QUERY_OBJECT(pPicInfo);

    /* clone it.  This assumes the one we're cloning from is still in use
       (shouldn't be deleted). */

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Cloning object\n\r");
#endif

    if (ObjCloneObjInfo(&NewPicInfo, cpParaStart, szObjName))
        return cp0;

    if (ObjError(OleClone(lpObject,
        (LPOLECLIENT)lpOBJ_QUERY_INFO(&NewPicInfo),
        lhClientDoc,szObjName,
        &lpOBJ_QUERY_OBJECT(&NewPicInfo))))
        goto err;


    lpOBJ_QUERY_INFO(&NewPicInfo)->fCompleteAsync = TRUE;
    if (ObjWaitForObject(lpOBJ_QUERY_INFO(&NewPicInfo),TRUE))
        goto err;

    if (lpOBJ_QUERY_INFO(&NewPicInfo)->fDeleteMe)
    /* this is how we know it failed asynchronously */
        goto err;

    /** 
        Save object name and objinfo that we just got.
    **/
    *pPicInfo = NewPicInfo;

    if (ObjSetPicInfo(pPicInfo, doc, cpParaStart))
        goto err;

    return(vcpLimParaCache);

    err:
    ObjDeleteObjInfo(lpOBJ_QUERY_INFO(&NewPicInfo));
    Error(IDPMTFailedToCreateObject);
    return cp0;
}

typeCP ObjToCloneInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
{
    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);
        
#ifdef DEBUG
    OutputDebugString( (LPSTR) "Marking object reusable\n\r");
#endif

    bOBJ_REUSE_ME(pPicInfo) = TRUE;

    return(vcpLimParaCache);
}

typeCP ObjFromCloneInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
{
    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);
        
#ifdef DEBUG
    OutputDebugString( (LPSTR) "Marking object not reusable\n\r");
#endif

    bOBJ_REUSE_ME(pPicInfo) = FALSE;

    return(vcpLimParaCache);
}

typeCP ObjBackupInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/* !!! used by link properties only !!!. Object guaranteed loaded */
{
    szOBJNAME szObjName;
    LPOBJINFO lpCloneInfo=NULL;

    if (lpOBJ_QUERY_CLONE(pPicInfo) == NULL) // then clone it
    {
#ifdef DEBUG
        OutputDebugString( (LPSTR) "Backing up object\n\r");
#endif

        if (ObjWaitForObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE))
            return cp0;

        if (ObjCopyObjInfo(lpOBJ_QUERY_INFO(pPicInfo),
                            &lpOBJ_QUERY_CLONE(pPicInfo),
                            szObjName))
            return(cp0);

        if (ObjError(OleClone(lpOBJ_QUERY_OBJECT(pPicInfo),
            (LPOLECLIENT)lpOBJ_QUERY_CLONE(pPicInfo),
            lhClientDoc,szObjName,&(lpOBJ_QUERY_CLONE(pPicInfo)->lpobject))))
                return cp0;
    }

    return(vcpLimParaCache);
}

typeCP ObjClearCloneInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/* !!! used by link properties only !!! Object guaranteed loaded */
/* delete clone, don't use it */
{
    if (lpOBJ_QUERY_CLONE(pPicInfo))
    {
#ifdef DEBUG
        OutputDebugString( (LPSTR) "Deleting clone\n\r");
#endif
        ObjDeleteObject(lpOBJ_QUERY_CLONE(pPicInfo),TRUE);
        lpOBJ_QUERY_CLONE(pPicInfo) = NULL;
    }

    return(vcpLimParaCache);
}

typeCP ObjUseCloneInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/* !!! used by link properties only !!! */
{
    szOBJNAME szObjName;

    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);
        
    if (lpOBJ_QUERY_CLONE(pPicInfo))
    {
        extern int FAR _cdecl sscanf(const char FAR *, const char FAR *, ...);
        LPOBJINFO lpClone = lpOBJ_QUERY_CLONE(pPicInfo);

#ifdef DEBUG
        OutputDebugString( (LPSTR) "using clone\n\r");
#endif

        ObjDeleteObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE);

        lpOBJ_QUERY_INFO(pPicInfo) = lpClone;
        lpOBJ_QUERY_CLONE(pPicInfo) = NULL;
        fOBJ_QUERY_DIRTY_OBJECT(pPicInfo) = TRUE;   // wanna save clone information
                                                    // just in case

        /* might've been frozen, used by LoadObject (this is what is unique
           in the context of link properties) */
        otOBJ_QUERY_TYPE(pPicInfo) = LINK;  

        if (ObjSetPicInfo(pPicInfo, doc, cpParaStart))
            return cp0;
    }

    return(vcpLimParaCache);
}


typeCP ObjSetNoUpdate(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
{
    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);
        
#ifdef DEBUG
    OutputDebugString( (LPSTR) "Set no update for object\n\r");
#endif

    if (otOBJ_QUERY_TYPE(pPicInfo) == LINK)
    {
        bOBJ_WAS_UPDATED(pPicInfo) = FALSE;
    }

    return(vcpLimParaCache);
}


typeCP ObjCheckObjectTypes(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
{
#ifdef DEBUG
    //OutputDebugString( (LPSTR) "Checking Object Type\n\r");
#endif

    /*  Result returned in OBJ_SELECTIONTYPE is highest object type which 
        exists at cpParaStart relative to current value of OBJ_SELECTIONTYPE.
    */
    switch(otOBJ_QUERY_TYPE(pPicInfo))
    {
        case STATIC:
            if (OBJ_SELECTIONTYPE < STATIC)
                OBJ_SELECTIONTYPE = STATIC;
            //OBJ_CEMBEDS = 0;
            return(vcpLimParaCache);

        case LINK:
            OBJ_SELECTIONTYPE = LINK;
            //OBJ_CEMBEDS = 0;
            return(vcpLimParaCache);

        case NONE:
            if (OBJ_SELECTIONTYPE < NONE)
                OBJ_SELECTIONTYPE = NONE;
            //OBJ_CEMBEDS = 0;
            return(vcpLimParaCache);

        case EMBEDDED:
            if (OBJ_SELECTIONTYPE < EMBEDDED)
                OBJ_SELECTIONTYPE = EMBEDDED;
            //++OBJ_CEMBEDS;
            return(vcpLimParaCache);

        default:
            Assert(0);
            return cp0;
    }
}

typeCP ObjSetHostNameInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
{
    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);

    if (lpOBJ_QUERY_OBJECT(pPicInfo) == NULL)
        return(vcpLimParaCache); // dont care if not loaded

    if ((otOBJ_QUERY_TYPE(pPicInfo) != EMBEDDED) &&
        (otOBJ_QUERY_TYPE(pPicInfo) != NONE))
        return(vcpLimParaCache);

    //if (OleQueryOpen(lpOBJ_QUERY_OBJECT(pPicInfo)) != OLE_OK)
        //return(vcpLimParaCache);
        
    if (ObjWaitForObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE))
        return cp0;

    if (ObjSetHostName(lpOBJ_QUERY_INFO(pPicInfo),doc))
        return(cp0);

    return(vcpLimParaCache);
}

typeCP ObjChangeLinkInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/* assumes aNewName is set */
{
    HANDLE      hData,hNewData=NULL;
    typeCP cpRetval=cp0;
    OLESTATUS olestat=OLE_OK;

    if (otOBJ_QUERY_TYPE(pPicInfo) != LINK)
        return(vcpLimParaCache);

    if (ObjMakeObjectReady(pPicInfo,doc,cpParaStart))
        return cp0;

    /* Change the link information */
    /* if theres a newname, then use it.  Else get a new name from user */
    olestat = ObjGetData(lpOBJ_QUERY_INFO(pPicInfo), vcfLink, &hData); 

    if ((olestat == OLE_WARN_DELETE_DATA) || (olestat ==  OLE_OK))
    {
        if (!(hNewData = ObjMakeNewLinkName(hData, aNewName))
            || !ObjSetData(pPicInfo, vcfLink, hNewData))
            goto end;

        if (olestat == OLE_WARN_DELETE_DATA)
            GlobalFree(hData);

       /* this may not be necessary any more, check carefully. */
        if (ObjUpdateObjectInDoc(pPicInfo,doc,cpParaStart) == cp0)
            goto end;

        fOBJ_QUERY_DIRTY_OBJECT(pPicInfo) = TRUE;
        fOBJ_BADLINK(pPicInfo) = FALSE;

        cpRetval = vcpLimParaCache;
    }

    end:
    if (hNewData)
        GlobalFree(hNewData);
    return cpRetval;
}

typeCP ObjUpdateLinkInDoc(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/** 
    Change or update link to aNewName if == aOldName.  Assumes vbChangeOther
    has been initialized.
**/
{
    HANDLE      hData;
    char        szRename[cchMaxSz];

    if (otOBJ_QUERY_TYPE(pPicInfo) != LINK)
        return(vcpLimParaCache);

    if (aOBJ_QUERY_DOCUMENT_LINK(pPicInfo) == aOldName) 
    /* Change the link information */
    {
        if (bLinkProps && bOBJ_WAS_UPDATED(pPicInfo))
            return(vcpLimParaCache);
            
        if (!fUpdateAll) 
        {
            char szTmp[sizeof(szRename) + 90];
            char szLink[30],szDocName[30];
            CHAR szDocPath[ cchMaxFile ]; 
            CHAR szFullPath[ cchMaxFile ]; 

            SplitSzFilename( (**((**hpdocdod)[doc].hszFile)), szDocPath, szDocName );

            GetAtomName(aOBJ_QUERY_DOCUMENT_LINK(pPicInfo),szFullPath,sizeof(szFullPath));
            SplitSzFilename( szFullPath, szDocPath, szLink );

            if (!szDocName[0])
                LoadString(hINSTANCE, IDSTRUntitledDef, szDocName, sizeof(szDocName));

            /* Ask the user if they want to update the links */
            if (vbChangeOther)
                LoadString(hINSTANCE, IDSTRRename, szRename, sizeof(szRename));
            else // update other
                LoadString(hINSTANCE, IDSTRUpdate, szRename, sizeof(szRename));

            /* cast cause compiler is screwing up */
            wsprintf((LPSTR)szTmp,(LPSTR)szRename,(LPSTR)szLink,(LPSTR)szDocName,(LPSTR)szLink);

            if (MessageBox(hPARENTWINDOW, szTmp, szAppName,
                            MB_YESNO|MB_ICONEXCLAMATION) == IDNO) 
                return cp0;

            ObjCachePara(doc,cpParaStart); // MessageBox screws things up
            fUpdateAll = TRUE;
        }

        if (vbChangeOther)
        {
            if (ObjBackupInDoc(pPicInfo,doc,cpParaStart))
                return ObjChangeLinkInDoc(pPicInfo,doc,cpParaStart);
        }
        else
        {
            if (ObjBackupInDoc(pPicInfo,doc,cpParaStart))
                return ObjUpdateObjectInDoc(pPicInfo,doc,cpParaStart);
        }
    }

    return(vcpLimParaCache);
}


typeCP ObjCloseObjectInDoc(OBJPICINFO *pPicInfo, int doc, typeCP cpParaStart)
{
    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(cp0);
    
    if (lpOBJ_QUERY_OBJECT(pPicInfo) == NULL)
        return(vcpLimParaCache);

    if (otOBJ_QUERY_TYPE(pPicInfo) == STATIC) // nothing to close
        return(vcpLimParaCache);

    if (ObjWaitForObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE))
        return cp0;

    /* 
        Note that if this is an unfinished object, then the OLE_CLOSE 
        (whenever it happens to arrive) will cause the picinfo to be 
        deleted.
    */
    if (ObjError(OleClose(lpOBJ_QUERY_OBJECT(pPicInfo))))
        return(cp0);

    return(vcpLimParaCache);
}

/****************************************************************/
/****************** OLE OBJECT DATA I/O *************************/
/****************************************************************/
static typeCP ObjWriteDataToDoc(LPOLEOBJECT lpObject)
/* 
    Return cp after end of paragraph we've created or 0 if error.
    Assume ObjStream is initialized.
*/
{
    BOOL fSaveError = ferror;
    
    if (vfOutOfMemory || vfSysFull /*|| ObjStop*/)
        return cp0;

    Assert(!ferror);

    ferror = FALSE; /* so we can still call Replace().  */

    if (ObjError(OleSaveToStream(lpObject,lpStream)))
    {
        if (ferror)
        /* uh oh, hope we can clean up enough to look clean */
        {
            /* delete what we inserted if possible */
            ferror = FALSE;
            Replace(docStream, cpObjectDataBase  - cchPICINFOX,  cpObjectDataCurLoc - cpObjectDataBase + cchPICINFOX, fnNil, fc0, fc0);
            ferror = TRUE;
            return cp0;
        }
    }

    /* is this call necessary? Important to do if InsertRgch doesn't. */
    ObjCachePara(docStream,cpObjectDataBase - cchPICINFOX);

    ferror = fSaveError || ferror;

    return vcpLimParaCache; // cp after para we just inserted
}


/****************************************************************/
/******************** OLE STREAM I/O ****************************/
/****************************************************************/

static 
ObjOpenStreamIO(typeCP cpParaStart, int doc, struct CHP *pchp, struct PAP *ppapGraph, DWORD dwObjectSize)
{
    if (cpObjectDataCurLoc)
        ObjCloseStreamIO();

    cpObjectDataBase = cpObjectDataCurLoc = cpParaStart;
    cObjectData = 0L;
    dwDataMax = dwObjectSize;
    docStream = doc;
    pchpStream = pchp;
    ppapStream = ppapGraph;
}

static void
ObjCloseStreamIO(void)
{
    cpObjectDataBase = cpObjectDataCurLoc = cp0;
}

LONG FAR PASCAL BufReadStream(LPOLESTREAM lpStream, char huge *lpstr, DWORD cb) 
{
    DWORD dwRetval;
    typeCP cpMac = vcpLimParaCache;
    int cchRun;

    if ((cb + cpObjectDataCurLoc) > cpMac) // reading past end of para
    {
        Assert(0);
        return 0L;
    }

    for (   dwRetval = 0L;
            cb;
            cb -= cchRun, 
            cObjectData += cchRun,
            cpObjectDataCurLoc += (typeCP) cchRun,
            dwRetval += cchRun)
    {
        CHAR rgch[ 255 ];
        register char *chT;
        register unsigned cchT;
        unsigned cch = ulmin(cb, 255L);

        FetchRgch( &cchRun, rgch, docStream, cpObjectDataCurLoc, cpMac, cch);

        if (ferror)
            return -dwRetval;

        for(chT = rgch,cchT=cchRun; cchT--; )
            *lpstr++ = *chT++;
    }

    return dwRetval;
}


LONG FAR PASCAL BufWriteStream(LPOLESTREAM lpStream, char huge *lpstr, DWORD cb) 
{
    DWORD dwRetval;
    char *chT;
    unsigned cchT;
    CHAR                rgch[255];
    unsigned cch;
    struct PAP *ppap=NULL;
    
    for (   dwRetval = 0L;
            dwRetval < cb;
            cpObjectDataCurLoc += (typeCP) cch,
            cObjectData += cch,
            dwRetval += cch)
    {
        cch = ulmin(cb - dwRetval, 255L);

        for(chT = rgch,cchT=cch; cchT--;)
            *chT++ = *lpstr++;

        if ((cObjectData + cch) == dwDataMax)
            ppap = ppapStream;

        InsertRgch( docStream, cpObjectDataCurLoc, rgch, cch, pchpStream, ppap);

        if (ferror)
            return 0L;
    }

    return dwRetval;
}

ObjGetPicInfo(LPOLEOBJECT lpObject, int doc, OBJPICINFO *pPicInfo, typeCP *pcpParaStart)
/* get picInfo that has lpObject */
/* !!! since writing this it has occurred to me that a quicker way to do
   this would be to keep a list of pieces that point to objects.  Pieces
   never */
{
    OBJPICINFO picInfoT;
    typeCP cpStart,cpMac= CpMacText(doc);

    for (cpStart = cpNil; ObjPicEnumInRange(&picInfoT,doc,cp0,cpMac,&cpStart); ) 
    {
        if (lpOBJ_QUERY_INFO(&picInfoT) == NULL)
            continue;
        
        if (lpOBJ_QUERY_OBJECT(&picInfoT) == lpObject) // bingo
         {
            if (pPicInfo)
                *pPicInfo = picInfoT;
            if (pcpParaStart)
                *pcpParaStart = cpStart;
            return TRUE;
         }
    }

    return FALSE;
}

BOOL vfObjDisplaying=FALSE;
BOOL ObjSetPicInfo(OBJPICINFO *pSrcPicInfo, int doc, typeCP cpParaStart)
{
/* 
    NOTE that you only gotta call this when you change the OBJPICINFO fields:
        mm,
        objecttype,
        dwDataSize,
        dwObjNum, or
        lpObjInfo.
*/
    BOOL bError = FALSE;
    typeFC fcT;
    extern BOOL            vfInvalid;
    BOOL vfSaveInvalid = vfInvalid;
    BOOL docDirty = (**hpdocdod) [doc].fDirty;

    ObjPushParms(doc);

    ObjCachePara(doc,cpParaStart);

    if (vfObjDisplaying)  
        vfInvalid = FALSE; // this'll suppress things that mess up UpdateWw()
    bNoEol = TRUE;

    if (dwOBJ_QUERY_DATA_SIZE(pSrcPicInfo) == 0L)
    /* is this ever executed? */
    {
        struct CHP chp;

        /* problem is to retain graphics property of picinfo structure */
        GetChp(&chp, cpParaStart, doc); // calls CachePara
        NewChpIns(&chp);
        ObjUpdateFromObjInfo(pSrcPicInfo);
        pSrcPicInfo->mm |= MM_EXTENDED;
        InsertRgch( doc, cpParaStart + (typeCP)cchPICINFOX, pSrcPicInfo, 
                   (unsigned)cchPICINFOX, &chp, &vpapAbs );
        pSrcPicInfo->mm &= ~MM_EXTENDED;

        if (ferror)
            return TRUE;

        /* delete old pieces (in front) that pointed to duped data */
        Replace(doc, cpParaStart, (typeCP)cchPICINFOX, fnNil, fc0, fc0);
    }
    else
    {
        ObjUpdateFromObjInfo(pSrcPicInfo);
        pSrcPicInfo->mm |= MM_EXTENDED;
        fcT = FcWScratch( pSrcPicInfo, cchPICINFOX );
        pSrcPicInfo->mm &= ~MM_EXTENDED;

        if (ferror)
            return TRUE;
        Replace( doc, cpParaStart, (typeCP)cchPICINFOX,
            fnScratch, fcT, (typeFC)cchPICINFOX);
    }

    if (ferror)
        return TRUE;

    bNoEol = FALSE;
    if (vfObjDisplaying)
        vfInvalid = vfSaveInvalid;

    /* don't want this to affect docDirty flag */
    (**hpdocdod) [doc].fDirty = docDirty; 

    ObjPopParms(TRUE);

    return bError;
}


void ChangeOtherLinks(int doc, BOOL bChange, BOOL bPrompt)
/** For any items == aOldName, set to aNewName.  Query user if OK first. 
    Assumes aOldName and aNewName are set.  (See FixInvalidLink() and
    ObjChangeLinkInDoc()).
    bChange is TRUE if ChangeLink, FALSE if UpdateObject.
    bPrompt is TRUe if prompt user for change.
  **/
{
    fUpdateAll = !bPrompt;

    vbChangeOther = bChange; // TRUE to change links, FALSE to update links
    ObjEnumInDoc(doc,ObjUpdateLinkInDoc);

}

BOOL ObjQueryNewLinkName(OBJPICINFO *pPicInfo,int doc,typeCP cpParaStart)
/** Return whether obtained new link name from user.  Set aOldName 
    and aNewName. **/
{
    HANDLE      hData,hNewData=NULL;
    LPSTR       lpdata=NULL;
    BOOL bRetval = FALSE;
    OLESTATUS olestat=OLE_OK;

    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return(FALSE);

    if (otOBJ_QUERY_TYPE(pPicInfo) != LINK)
        return(FALSE);

    if (ObjMakeObjectReady(pPicInfo,doc,cpParaStart))
        return(FALSE);

    /* query user for new name */
    olestat = ObjGetData(lpOBJ_QUERY_INFO(pPicInfo), vcfLink, &hData); 
    if ((olestat == OLE_WARN_DELETE_DATA) || (olestat ==  OLE_OK))
        if (!(hNewData = OfnGetNewLinkName(hPARENTWINDOW, hData)))
            goto end;

    if (olestat == OLE_WARN_DELETE_DATA)
        GlobalFree(hData);

    aOldName = aOBJ_QUERY_DOCUMENT_LINK(pPicInfo);

    lpdata=MAKELP(hNewData,0);

    while (*lpdata++);

    aNewName = AddAtom(lpdata);

    bRetval = TRUE;

    end:
    if (olestat == OLE_WARN_DELETE_DATA)
        GlobalFree(hData);

    if (hNewData)
        GlobalFree(hNewData); 

    return bRetval;
}

FixInvalidLink(OBJPICINFO far *lpPicInfo, int doc, typeCP cpParaStart)
/* returns FALSE if couldn't or wouldn't do anything, RETRY if reset link */
{

    fOBJ_BADLINK(lpPicInfo) = TRUE;
    if (DialogBox(hINSTANCE, "DTINVALIDLINK",
                    hPARENTWINDOW, lpfnInvalidLink) == IDD_CHANGE) 
#if !defined(SMALL_OLE_UI)
        fnObjProperties();
#else
        ObjChangeLinkInDoc(lpPicInfo,doc,cpParaStart);
#endif
    return FALSE;
}

/* ObjMakeNewLinkName() - Constructs a new link name from an atom.
 */
static HANDLE ObjMakeNewLinkName(HANDLE hData, ATOM atom) 
{
    BOOL    fSuccess    = FALSE;
    HANDLE  hData2      = NULL;
    HANDLE  hData3      = NULL;
    LPSTR   lpstrData   = NULL;
    LPSTR   lpstrLink   = NULL;
    LPSTR   lpstrTemp;
    char    szFile[CBPATHMAX];

    if (!GetAtomName(atom, szFile, CBPATHMAX)
     || !(lpstrData = (LPSTR)GlobalLock(hData))
     || !(hData2 = GlobalAlloc(GMEM_DDESHARE | GMEM_ZEROINIT, CBPATHMAX * 2))
     || !(lpstrLink = lpstrTemp = (LPSTR)GlobalLock(hData2)))
        goto Error;

    /* ... copy the server name */
    while (*lpstrTemp++ = *lpstrData++);

    /* ... copy the document name */
    lstrcpy(lpstrTemp, szFile);
    lpstrTemp += lstrlen(lpstrTemp) + 1;
    lpstrData += lstrlen(lpstrData) + 1;

    /* ... copy the item name */
    while (*lpstrTemp++ = *lpstrData++);
    *lpstrTemp = 0;

    /* ... and compress the memory block to minimal size */
    GlobalUnlock(hData2);
    hData3 = GlobalReAlloc(hData2, (DWORD)(lpstrTemp - lpstrLink + 1), 0);

    if (!hData3)
        hData3 = hData2;

    fSuccess = TRUE;

Error:
    if (!fSuccess) {
        if (lpstrLink)
            GlobalUnlock(hData2);
        if (hData2)
            GlobalFree(hData2);
        hData3 = NULL;
    }

    if (lpstrData)
        GlobalUnlock(hData);

    return hData3;
}

char *ObjGetServerName(LPOLEOBJECT lpObject, char *szServerName)
{
    LPSTR   lpstrData;
    HANDLE  hData;
	LONG        otobject;
    OLESTATUS olestat;

    /**  NOTE: OleGetData can return OLE_BUSY.  Because of how 
        ObjGetServerName is used, we're not going to wait for the 
        object here, we'll just return if its busy **/

    if (OleQueryReleaseStatus(lpObject) == OLE_BUSY)
        return NULL;

    if (ObjError(OleQueryType(lpObject,&otobject)))
        return NULL;

    olestat = OleGetData(lpObject, 
                    otobject == OT_LINK ? vcfLink : vcfOwnerLink, 
                    &hData);

    if ((olestat != OLE_WARN_DELETE_DATA) && (olestat !=  OLE_OK))
    {
        ObjError(olestat);
        return NULL;
    }

    lpstrData = MAKELP(hData,0);
    RegGetClassId(szServerName, lpstrData);
    if (olestat == OLE_WARN_DELETE_DATA)
        GlobalFree(hData);

    return szServerName;
}

/* OfnInit() - Initializes the standard file dialog OFN structure.
 */
void OfnInit(HANDLE hInst) {
    LPSTR lpstr;

    OFN.lStructSize         = sizeof(OPENFILENAME);
    OFN.hInstance           = hInst;
    OFN.nMaxCustFilter      = CBFILTERMAX;
    OFN.nMaxFile            = CBPATHMAX;
    OFN.Flags               = OFN_HIDEREADONLY;
    OFN.lCustData           = NULL;
    OFN.lpfnHook            = NULL;
    OFN.lpTemplateName      = NULL;
    OFN.lpstrDefExt         = NULL;
    OFN.lpstrFileTitle      = NULL;

    LoadString(hInst, IDSTRChangelink, szLinkCaption, sizeof(szLinkCaption));
}

/* OfnGetNewLinkName() - Sets up the "Change Link..." dialog box
 */
static HANDLE OfnGetNewLinkName(HWND hwnd, HANDLE hData) 
{
    BOOL    fSuccess    = FALSE;
    HANDLE  hData2      = NULL;
    HANDLE  hData3      = NULL;
    LPSTR   lpData2     = NULL;
    LPSTR   lpstrData   = NULL;
    LPSTR   lpstrFile   = NULL;
    LPSTR   lpstrLink   = NULL;
    LPSTR   lpstrPath   = NULL;
    LPSTR   lpstrTemp   = NULL;
    char    szDocFile[CBPATHMAX];
    char    szDocPath[CBPATHMAX];
    HANDLE  hServerFilter=NULL;

    /* Get the link information */
    if (!(lpstrData = GlobalLock(hData)))
        goto Error;

    /* Figure out the link's path name and file name */
    lpstrTemp = lpstrData;
    while (*lpstrTemp++);
    lpstrPath = lpstrFile = lpstrTemp;
    while (*(lpstrTemp = AnsiNext(lpstrTemp)))
        if (*lpstrTemp == '\\')
            lpstrFile = lpstrTemp + 1;

    /* Copy the document name */
    lstrcpy(szDocFile, lpstrFile);
    *(lpstrFile - 1) = 0;

    /* Copy the path name */
    lstrcpy(szDocPath, ((lpstrPath != lpstrFile) ? lpstrPath : ""));
    if (lpstrPath != lpstrFile)                 /* Restore the backslash */
        *(lpstrFile - 1) = '\\';
    while (*lpstrFile != '.' && *lpstrFile)     /* Get the extension */
        lpstrFile++;

    /* Make a filter that respects the link's class name */
    OFN.hwndOwner           = hwnd;

    OFN.nFilterIndex        = RegMakeFilterSpec(lpstrData, lpstrFile, &hServerFilter);
    if (OFN.nFilterIndex == -1)
        goto Error;
    OFN.lpstrFilter         = (LPSTR)MAKELP(hServerFilter,0);

    Normalize(szDocFile);
    OFN.lpstrFile           = (LPSTR)szDocFile;
    OFN.lpstrInitialDir     = (LPSTR)szDocPath;
    OFN.lpstrTitle          = (LPSTR)szLinkCaption;
    OFN.lpstrCustomFilter   = (LPSTR)szCustFilterSpec;


    /* If we get a file... */
    if (GetOpenFileName((LPOPENFILENAME)&OFN)) 
    {
        if (!(hData2 = GlobalAlloc(GMEM_DDESHARE | GMEM_ZEROINIT, CBPATHMAX * 2))
         || !(lpstrLink = lpstrTemp = GlobalLock(hData2)))
            goto Error;

        /* ... copy the server name */
        while (*lpstrTemp++ = *lpstrData++);

        /* ... copy the document name */
        lstrcpy(lpstrTemp, szDocFile);
        lpstrTemp += lstrlen(lpstrTemp) + 1;
        lpstrData += lstrlen(lpstrData) + 1;

        /* ... copy the item name */
        while (*lpstrTemp++ = *lpstrData++);
        *lpstrTemp = 0;

        /* ... and compress the memory block to minimal size */
        GlobalUnlock(hData2);
        hData3 = GlobalReAlloc(hData2, (DWORD)(lpstrTemp - lpstrLink + 1), 0);

        if (!hData3)
            hData3 = hData2;

        fSuccess = TRUE;
    }

Error:
    if (!fSuccess) 
    {
        if (lpstrLink)
            GlobalUnlock(hData2);
        if (hData2)
            GlobalFree(hData2);
        hData3 = NULL;
    }

    if (lpstrData)
        GlobalUnlock(hData);

    if (hServerFilter)
        GlobalFree(hServerFilter);

    return hData3;
}

/* Normalize() - Removes the path specification from the file name.
 *
 * Note:  It isn't possible to get "<drive>:<filename>" as input because
 *        the path received will always be fully qualified.
 */
static void Normalize(LPSTR lpstrFile) 
{
    LPSTR   lpstrBackslash  = NULL;
    LPSTR   lpstrTemp       = lpstrFile;

    while (*lpstrTemp) {
        if (*lpstrTemp == '\\')
            lpstrBackslash = lpstrTemp;

        lpstrTemp = AnsiNext(lpstrTemp);
    }
    if (lpstrBackslash)
        lstrcpy(lpstrFile, lpstrBackslash + 1);
}

/* ObjSetUpdateOptions() - Sets the update options of the object.
 *
 * Returns:  TRUE iff the command completed successfully
 */
BOOL ObjSetUpdateOptions(OBJPICINFO *pPicInfo, WORD wParam, int doc, typeCP cpParaStart) 
/* !!! Used by Link Properties only!!!  Object guaranteed loaded */
{
    if (ObjWaitForObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE))
    {
        Error(IDPMTFailedToUpdateLink);
        return FALSE;
    }

    if (ObjError(OleSetLinkUpdateOptions(lpOBJ_QUERY_OBJECT(pPicInfo),
            (wParam == IDD_AUTO) ? oleupdate_always : oleupdate_oncall)))
    {
        Error(IDPMTFailedToUpdateLink);
        return FALSE;
    }

    fOBJ_QUERY_DIRTY_OBJECT(pPicInfo) = TRUE;

    return TRUE;
}

/* ObjGetUpdateOptions() - Retrieves the update options of the object.
 */
OLEOPT_UPDATE ObjGetUpdateOptions(OBJPICINFO far *lpPicInfo) 
/* !!! Used by Link Properties only!!!  Object guaranteed loaded */
{
    BOOL        fSuccess = FALSE;
    OLEOPT_UPDATE fUpdate;

    if (otOBJ_QUERY_TYPE(lpPicInfo) == LINK)
    {
        if (ObjWaitForObject(lpOBJ_QUERY_INFO(lpPicInfo),TRUE))
            return FALSE;

        fSuccess = !ObjError(OleGetLinkUpdateOptions(lpOBJ_QUERY_OBJECT(lpPicInfo), &fUpdate));
    }
    return (fSuccess ? fUpdate : oleupdate_onsave);
}

OLESTATUS ObjGetData(LPOBJINFO lpObjInfo, OLECLIPFORMAT cf, HANDLE far *lphData)
/*  
    Return olestat.
    Put handle to data into lphData.
    Assumes object is loaded.
*/
{
    HANDLE      hData;
    OLESTATUS olestat;

    if (ObjWaitForObject(lpObjInfo,TRUE))
        return OLE_BUSY;

    olestat = OleGetData(lpObjInfo->lpobject, cf, lphData);
    if ((olestat != OLE_WARN_DELETE_DATA) && (olestat !=  OLE_OK))
        ObjError(olestat);
    return olestat;
}

/* ObjSetData() - Set the object's (link) information
   Sets DOCUMENT_LINK ATOM in pPicInfo
 */
BOOL ObjSetData(OBJPICINFO far *lpPicInfo, OLECLIPFORMAT cf, HANDLE hData) 
/* assumes object is loaded */
{
    HANDLE      hitem;
    LPSTR       lpdata;

    if (ObjWaitForObject(lpOBJ_QUERY_INFO(lpPicInfo),TRUE))
        return FALSE;

    if (ObjError(OleSetData(lpOBJ_QUERY_OBJECT(lpPicInfo), cf, hData)))
        return FALSE;

    /* If we have a link, update the document name */
    if (cf == vcfLink && (lpdata = GlobalLock(hData))) 
    {
        ATOM aSaveOld = aOBJ_QUERY_DOCUMENT_LINK(lpPicInfo);

        while (*lpdata++);

        aOBJ_QUERY_DOCUMENT_LINK(lpPicInfo) = AddAtom(lpdata);

        if (aSaveOld)
            DeleteAtom(aSaveOld);

        GlobalUnlock(hData);
    }
    else
        return FALSE;

    return TRUE;
}

int ObjSetSelectionType(int doc, typeCP cpFirst, typeCP cpLim)
{
    /* set whether link or emb selected */
    OBJ_SELECTIONTYPE = NONE;  // this'll be set by ObjCheckObjectTypes()
    //OBJ_CEMBEDS       = 0;     // this'll be set by ObjCheckObjectTypes()
    return ObjEnumInRange(doc,cpFirst,cpLim,ObjCheckObjectTypes);
}

BOOL ObjQueryCpIsObject(int doc,typeCP cpFirst)
{
    OBJPICINFO picInfo;

    /* assume its cached already! */
    //ObjCachePara(doc,cpFirst); /* NOTE side effect of caching */

    if (!vpapAbs.fGraphics)
        return FALSE;

    if (cpFirst >= CpMacText(doc))
        return FALSE;

    GetPicInfo(cpFirst,cpFirst + cchPICINFOX, doc, &picInfo);
    return bOBJ_QUERY_IS_OBJECT(&picInfo);
}


ATOM MakeLinkAtom(LPOBJINFO lpObjInfo)
{
    HANDLE      hData;
    LPSTR       lpdata;
    ATOM aRetval=NULL;
    OLESTATUS olestat=OLE_OK;

    olestat = ObjGetData(lpObjInfo, vcfLink, &hData);

    if ((olestat == OLE_WARN_DELETE_DATA) || (olestat ==  OLE_OK))
    {
        lpdata = MAKELP(hData,0);
        while (*lpdata++);
        aRetval =  AddAtom(lpdata);
    
        if (olestat == OLE_WARN_DELETE_DATA)
            GlobalFree(hData);
    }
    return aRetval;
}

#include <time.h>
void ObjGetObjectName(LPOBJINFO lpObjInfo, szOBJNAME szObjName)
/* put object name from ObjInfo into szObjName */
{
    if (szObjName && lpObjInfo)
        GetAtomName(lpObjInfo->aObjName,szObjName,sizeof(szObjName));
}

void ObjMakeObjectName(LPOBJINFO lpObjInfo, LPSTR lpstr)
{
    szOBJNAME szObjName;

    time_t lTime;
    time(&lTime);
    wsprintf(szObjName, "%lx", lTime);

    if (lpObjInfo)
        lpObjInfo->aObjName = AddAtom(szObjName);

    if (lpstr)
        lstrcpy(lpstr,szObjName);
}

static void GetChp(struct CHP *pchp, typeCP cp, int doc)
{
 /** 
    Return chp at cp in *pchp.
    Resets Cache to cp when done. 
    We assume that we're always inserting after an EOL or at beginning of
    document.
  **/

extern struct CHP       vchpAbs;

if (cp == cp0) // beginning of doc
{
    typeCP cpMac =  CpMacText(doc);
    if (cpMac == cp0) // empty doc
    {
	    /* force default character properties, font size to be 10 point */
	    *pchp = vchpNormal;
	    pchp->hps = hpsDefault;
        return;
    }
    else // get next char props
    {
        ObjCachePara(doc,cp+1); // to reset
        FetchCp( doc, cp+1, 0, fcmProps );
    }
}
else
{
    ObjCachePara(doc,cp-1); // to reset
    FetchCp( doc, cp-1, 0, fcmProps ); // previous paragraph's chp
}

*pchp = vchpAbs;

if (pchp->fSpecial && pchp->hpsPos != 0)
	{ /* if this char is a footnote or page marker, then ignore */
	pchp->hpsPos = 0;		  /* super/subscript stuff. */
	pchp->hps = HpsAlter(pchp->hps, 1);
	}

pchp->fSpecial = fFalse;

ObjCachePara(doc,cp); // to reset
}

BOOL ObjSetHostName(LPOBJINFO lpOInfo, int doc)
/* TRUE if error */
/* we assume object ain't busy!!! */
{
    extern  CHAR    szUntitled[20];
    CHAR *PchStartBaseNameSz(),*szTitle= **((**hpdocdod)[doc].hszFile);

    if (szTitle[0])
        szTitle = PchStartBaseNameSz(szTitle);
    else
        szTitle = szUntitled;

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Setting host name\n\r");
#endif

    /*  
        Note that OleSetHostNames can return OLE_BUSY!!!  So you
        better call ObjWaitForObject() first.
     */

    if (ObjError(OleSetHostNames(lpOInfo->lpobject,szAppName,szTitle))) 
        return TRUE;

    return FALSE;
}

BOOL ObjMakeObjectReady(OBJPICINFO *pPicInfo, int doc, typeCP cpParaStart)
/* Load object, complete async.  Return whether an error. */
{
    if (lpOBJ_QUERY_INFO(pPicInfo) == NULL)
        return TRUE;

    if (lpOBJ_QUERY_OBJECT(pPicInfo) == NULL)
    {
        if (ObjLoadObjectInDoc(pPicInfo,doc,cpParaStart) == cp0)
            return TRUE;
    }
    else if (ObjWaitForObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE))
        return TRUE;

    ObjCachePara(doc, cpParaStart);

    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\obj3.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/
#include "windows.h"
#include "mw.h"
#include "winddefs.h"
#include "obj.h"
#include "menudefs.h"
#include "cmddefs.h"
#include "str.h"
#include "objreg.h"
#include "docdefs.h"
#include "editdefs.h"
#include "propdefs.h"
#include "wwdefs.h"
#include "filedefs.h"
#include "shellapi.h"
#include <commdlg.h>

extern BOOL ferror;
extern HCURSOR      vhcArrow;
extern  HCURSOR     vhcIBeam;
extern struct DOD (**hpdocdod)[];
extern struct PAP      vpapAbs;
extern struct UAB       vuab;
extern struct WWD       rgwwd[];
extern BOOL         bKillMe;
extern BOOL fPropsError;
extern int docScrap;
extern int          docUndo;
extern PRINTDLG PD;

static BOOL DoLinksCommand(WORD wParam, DWORD lParam, HWND hDlg, BOOL *bError);

/****************************************************************/
/*********************** OLE DISPLAY HANDLING *******************/
/****************************************************************/
BOOL ObjDisplayObjectInDoc(OBJPICINFO far *lpPicInfo,
                           int doc, typeCP cpParaStart,
                           HDC hDC, LPRECT lpBounds)
{
    BOOL bSuccess;


    if (lpOBJ_QUERY_INFO(lpPicInfo) == NULL)
        return(FALSE);

#ifndef JAPAN  // added by Hiraisi (BUG#2732/WIN31)
    // If we return here, we can never redraw the object again.
    if (lpOBJ_QUERY_INFO(lpPicInfo)->fCantDisplay)
        return(FALSE);
#endif  // not JAPAN

    if (otOBJ_QUERY_TYPE(lpPicInfo) == NONE)
    switch(otOBJ_QUERY_TYPE(lpPicInfo))
    {
        case NONE:
        {
#if OBJ_EMPTY_OBJECT_FRAME
            extern DrawBlank(HDC hDC, RECT FAR *rc);
            DrawBlank(hDC,lpBounds);
#else
#ifdef DEBUG
            OutputDebugString( (LPSTR) "Displaying empty object\n\r");
#endif
#endif
            return TRUE;
        }
    }

#ifdef DEBUG
    OutputDebugString( (LPSTR) "Displaying object\n\r");
#endif

#ifdef JAPAN   // added by Hiraisi (BUG#2732/WIN31)
    if (lpOBJ_QUERY_INFO(lpPicInfo)->fCantDisplay)
       bSuccess = (OLE_OK == OleDraw(lpOBJ_QUERY_OBJECT(lpPicInfo),hDC,lpBounds,NULL,NULL));
    else
       bSuccess = !ObjError(OleDraw(lpOBJ_QUERY_OBJECT(lpPicInfo),hDC,lpBounds,NULL,NULL));
    if (!bSuccess)
        lpOBJ_QUERY_INFO(lpPicInfo)->fCantDisplay = TRUE;
    else
        lpOBJ_QUERY_INFO(lpPicInfo)->fCantDisplay = FALSE;
#else
    bSuccess = !ObjError(OleDraw(lpOBJ_QUERY_OBJECT(lpPicInfo),hDC,lpBounds,NULL,NULL));
    if (!bSuccess)
        lpOBJ_QUERY_INFO(lpPicInfo)->fCantDisplay = TRUE;
#endif    // JAPAN
    return bSuccess;
}

BOOL ObjQueryObjectBounds(OBJPICINFO far *lpPicInfo, HDC hDC,
                            int *pdxa, int *pdya)
/* return bounds in twips */
{
    RECT bounds;
    BOOL bRetval;
    OLESTATUS olestat;
    int mmOld;
    POINT pt;

    if (otOBJ_QUERY_TYPE(lpPicInfo) == NONE)
    {
        /* set to default */
        *pdxa = nOBJ_BLANKOBJECT_X;
        *pdya = nOBJ_BLANKOBJECT_Y;
        return TRUE;
    }

    if ((olestat = OleQueryBounds(lpOBJ_QUERY_OBJECT(lpPicInfo),&bounds))
                        == OLE_ERROR_BLANK)
    {
        Assert(0);
        if (ObjWaitForObject(lpOBJ_QUERY_INFO(lpPicInfo),TRUE))
            return FALSE;
        olestat = OleQueryBounds(lpOBJ_QUERY_OBJECT(lpPicInfo),&bounds);
    }

    if (ObjError(olestat))
        return FALSE;

    pt.x = bounds.right - bounds.left;
    pt.y = -(bounds.bottom - bounds.top);
#ifdef DEBUG
    {
        char szMsg[180];
        wsprintf(szMsg,"Object HIMETRIC width: %d height: %d\n\r",pt.x,-pt.y);
        OutputDebugString(szMsg);
    }
#endif
    mmOld = SetMapMode(hDC,MM_HIMETRIC);
    LPtoDP(hDC,&pt,1);

    SetMapMode(hDC,MM_TWIPS);
    DPtoLP(hDC,&pt,1);

    SetMapMode(hDC,mmOld);
    *pdxa = pt.x;
    *pdya = pt.y;

    return TRUE;
}

void ObjInvalidatePict(OBJPICINFO *pPicInfo, typeCP cp)
{
    struct EDL      *pedl;
    RECT rc;
    extern int              wwCur;

    ObjPushParms(docCur);

    ObjCachePara(docCur,cp);
    Select(vcpFirstParaCache,vcpLimParaCache);

    FreezeHp();
    if (FGetPictPedl(&pedl))  // find pedl at selCur.cpFirst;
    {
        ComputePictRect( &rc, pPicInfo, pedl, wwCur );
        InvalidateRect(hDOCWINDOW, &rc, FALSE);
    }
    MeltHp();

    ObjPopParms(TRUE);
    UPDATE_INVALID();
}

void ObjInvalidateObj(LPOLEOBJECT lpObject)
{
    typeCP cp;
    OBJPICINFO picInfo;

    ObjPushParms(docCur);
    if (ObjGetPicInfo(lpObject,docCur,&picInfo,&cp))
        ObjInvalidatePict(&picInfo,cp);
    ObjPopParms(TRUE);
}

/****************************************************************/
/*********************** OLE CLIPBOARD  *************************/
/****************************************************************/
BOOL ObjCreateObjectInClip(OBJPICINFO *pPicInfo)
{
    LONG        otobject;
    szOBJNAME szObjName;
    OLESTATUS olestat;
    BOOL bRetval = FALSE;

    Assert (lhClientDoc != NULL);

    if (ObjAllocObjInfo(pPicInfo,selCur.cpFirst,NONE,TRUE,szObjName))
        goto error;

    if (vbObjLinkOnly)
    {
        if (ObjError(OleCreateLinkFromClip(PROTOCOL, (LPOLECLIENT)lpOBJ_QUERY_INFO(pPicInfo),
                    lhClientDoc, szObjName,
                    &lpOBJ_QUERY_OBJECT(pPicInfo), olerender_draw, 0)))
        {
            lpOBJ_QUERY_OBJECT(pPicInfo) = NULL;
            goto error;
        }
    }
    else if (vObjPasteLinkSpecial)
    {
        if (ObjError(OleCreateLinkFromClip(PROTOCOL, (LPOLECLIENT)lpOBJ_QUERY_INFO(pPicInfo),
                    lhClientDoc, szObjName,
                    &lpOBJ_QUERY_OBJECT(pPicInfo), olerender_format, cfObjPasteSpecial)))
        {
            lpOBJ_QUERY_OBJECT(pPicInfo) = NULL;
            goto error;
        }
    }
    else
    {
        WORD cfClipFormat=0;
        OLEOPT_RENDER orRender = olerender_draw;

        if (cfObjPasteSpecial && (cfObjPasteSpecial != vcfOwnerLink))
        /* from PasteSpecial.  There's a format on clipboard that
           user wants to paste and its not the embedded object format.
           So we'll do it as a static object. */
        {
            cfClipFormat = cfObjPasteSpecial;
            orRender = olerender_format;
            olestat = OLE_ERROR_CLIPBOARD; // force get static object
        }
        else // try for embedded
            olestat = OleCreateFromClip(PROTOCOL, (LPOLECLIENT)lpOBJ_QUERY_INFO(pPicInfo),
                                    lhClientDoc, szObjName,
                                    &lpOBJ_QUERY_OBJECT(pPicInfo), orRender, cfClipFormat);

        switch(olestat)
        {
            case OLE_ERROR_CLIPBOARD:
                /* try static protocol */
                olestat = OleCreateFromClip(SPROTOCOL, (LPOLECLIENT)lpOBJ_QUERY_INFO(pPicInfo),
                                    lhClientDoc, szObjName,
                                    &lpOBJ_QUERY_OBJECT(pPicInfo), orRender, cfClipFormat);
                switch(olestat)
                {
                    case OLE_ERROR_CLIPBOARD:
                    goto error;

                    case OLE_WAIT_FOR_RELEASE:
                    case OLE_OK:
                    break;

                    default:
                        lpOBJ_QUERY_OBJECT(pPicInfo) = NULL;
                    goto error;
                }
            break;

            case OLE_WAIT_FOR_RELEASE:
            case OLE_OK:
            break;

            default:
                ObjError(olestat);
            goto error;
        }
    }

    /* Figure out what kind of object we have */
    if (ObjError(OleQueryType(lpOBJ_QUERY_OBJECT(pPicInfo),&otobject)))
        goto error;

    switch(otobject)
    {
        case OT_LINK:
            otOBJ_QUERY_TYPE(pPicInfo) = LINK;
        break;
        case OT_EMBEDDED:
            otOBJ_QUERY_TYPE(pPicInfo) = EMBEDDED;
        break;
        default:
            otOBJ_QUERY_TYPE(pPicInfo) = STATIC;
        break;
    }

    if (ObjInitServerInfo(lpOBJ_QUERY_INFO(pPicInfo)))
        goto error;

    if (!FComputePictSize(pPicInfo, &(pPicInfo->dxaSize),
                          &(pPicInfo->dyaSize) ))
        goto error;

    return TRUE;

    error:
    if (lpOBJ_QUERY_INFO(pPicInfo))
        ObjDeleteObject(lpOBJ_QUERY_INFO(pPicInfo),TRUE);
    Error(IDPMTFailedToCreateObject);
    return FALSE;
}

BOOL ObjWriteToClip(OBJPICINFO FAR *lpPicInfo)
/* return TRUE if OK, FALSE if not */
{
#ifdef DEBUG
        OutputDebugString( (LPSTR) "Copying Object to Clipboard\n\r");
#endif

    if (otOBJ_QUERY_TYPE(lpPicInfo) == NONE)
        return FALSE;

    if (ObjWaitForObject(lpOBJ_QUERY_INFO(lpPicInfo),TRUE))
        return FALSE;
    return (!ObjError(OleCopyToClipboard(lpOBJ_QUERY_OBJECT(lpPicInfo))));
}

/****************************************************************/
/*********************** OLE MENU HANDLING **********************/
/****************************************************************/
void ObjUpdateMenu(HMENU hMenu)
/* this *MUST* be called *AFTER* paste menuitem has already been enabled
   according to presence of non-object contents of the clipboard!!! (1.25.91) D. Kent */
{
    int     mfPaste      = MF_GRAYED;
#if !defined(SMALL_OLE_UI)
    int     mfPasteLink  = MF_GRAYED;
    int     mfLinks = MF_GRAYED;
#endif
    int     mfPasteSpecial  = MF_GRAYED;
    int     mfInsertNew  = MF_GRAYED;
    WORD cfFormat = NULL;
    BOOL bIsEmbed=FALSE,bIsLink=FALSE;
    extern BOOL vfOutOfMemory;
    extern int vfOwnClipboard;

    if (!vfOutOfMemory)
    {
        if (vfOwnClipboard)
        {
            if (CpMacText( docScrap ) != cp0) // something in scrap
                mfPaste = MF_ENABLED;
        }
        else
        {
            if (OleQueryCreateFromClip(PROTOCOL, olerender_draw, 0) == OLE_OK)
                mfPaste = MF_ENABLED, bIsEmbed=TRUE;
            else if (OleQueryCreateFromClip(SPROTOCOL, olerender_draw, 0) == OLE_OK)
                mfPaste = MF_ENABLED;

            // Enable "Paste Link" if there is a link-able object in the clipboard
            if (OleQueryLinkFromClip(PROTOCOL, olerender_draw, 0) == OLE_OK)
            {
                bIsLink=TRUE;
#if !defined(SMALL_OLE_UI)
                mfPasteLink = MF_ENABLED;
#endif
            }
        }

        /* There's no point in putting up pastespecial if there are no
            alternate clip formats to choose from. */

#if defined(SMALL_OLE_UI)
        /* except to get paste link */
#endif

        if (OpenClipboard( hPARENTWINDOW ) )
        {
            int ncfCount=0;
            while (cfFormat = EnumClipboardFormats(cfFormat))
                switch (cfFormat)
                {
                    case CF_TEXT:
                        mfPaste = MF_ENABLED;
                    case CF_BITMAP:
                    case CF_METAFILEPICT:
                    case CF_DIB:
                        ++ncfCount;
                    break;
                }
            CloseClipboard();

            if (bIsLink || bIsEmbed)
            {
#if !defined(SMALL_OLE_UI)
                if (ncfCount >= 1)
#endif
                    mfPasteSpecial = MF_ENABLED;
            }
            else if (ncfCount > 1)
                mfPasteSpecial = MF_ENABLED;
        }

#if !defined(SMALL_OLE_UI)
        mfLinks = MF_ENABLED;
#endif

        // Insert_New is always enabled?
        mfInsertNew = MF_ENABLED;
    }

    ObjUpdateMenuVerbs( hMenu );
    EnableMenuItem(hMenu, imiPaste,  mfPaste);
#if !defined(SMALL_OLE_UI)
    EnableMenuItem(hMenu, imiPasteLink,  mfPasteLink);
    EnableMenuItem(hMenu, imiProperties, mfLinks);
#endif
    EnableMenuItem(hMenu, imiPasteSpecial, mfPasteSpecial);
    EnableMenuItem(hMenu, imiInsertNew,  mfInsertNew);
}


/****************************************************************/
/*********************** OLE DIALOG PROCS ***********************/
/****************************************************************/
#if !defined(SMALL_OLE_UI)
/* Properties... dialog */
BOOL FAR PASCAL fnProperties(HWND hDlg, unsigned msg, WORD wParam, LONG lParam)
{
    ATOM    aDocName    = 0;
    ATOM    aCurName    = 0;
    static int     idButton    = 0;
    OBJPICINFO picInfo;
    BOOL    bSelected;
    int     cSelected     = 0;
    int     iListItem     = 0;
    HWND    vhwndObjListBox      = GetDlgItem(hDlg, IDD_LISTBOX);
    extern HWND vhWndMsgBoxParent;
    static BOOL bDidSomething;

    switch (msg) {
        case WM_ACTIVATE:
            if (wParam)
                vhWndMsgBoxParent = hDlg;
        break;

        case WM_UPDATELB: /* Redrawing listbox contents */
            SendMessage(vhwndObjListBox, WM_SETREDRAW, 0, 0L);

        case WM_UPDATEBN: /* Updating Buttons only */
        case WM_INITDIALOG: {
            HANDLE  hData = NULL;
            LPSTR   lpstrData = NULL;
            LPSTR   lpstrTemp;
            char    szType[40];
            char    szFull[cchMaxSz];
            typeCP cpPicInfo;
            struct SEL selSave;
            OLESTATUS olestat;

            idButton    = 0;

            /* Reset the list box */
            if (msg == WM_INITDIALOG) // see fall through above
            {
                SendMessage(vhwndObjListBox, LB_RESETCONTENT, 0, 0L);
                EnableOtherModeless(FALSE);
                selSave=selCur;
                //ObjWriteFixup(docCur,TRUE,cp0);
                bLinkProps = TRUE;
                bDidSomething = FALSE;
                ObjSetSelectionType(docCur, selSave.cpFirst, selSave.cpLim);
            }

            /* Insert all the items in list box */
            cpPicInfo = cpNil;
            while (ObjPicEnumInRange(&picInfo,docCur,cp0,CpMacText(docCur),&cpPicInfo))
            {
                if (otOBJ_QUERY_TYPE(&picInfo) != LINK)
                {
                    if (msg == WM_UPDATEBN)
                        continue;  // object ain't in list box

                    if (msg == WM_INITDIALOG)
                        fOBJ_QUERY_IN_PROP_LIST(&picInfo) = OUT;
                    else if (fOBJ_QUERY_IN_PROP_LIST(&picInfo) == IN)
                    /** then this is an object which was in the list and
                        has been frozen */
                    {
                        fOBJ_QUERY_IN_PROP_LIST(&picInfo) = DELETED;
                        SendMessage(vhwndObjListBox, LB_DELETESTRING, iListItem, 0L);
                    }
                    else
                        continue; // object ain't in list box

                    continue;
                }
                else if (msg == WM_INITDIALOG)
                {
                    fOBJ_QUERY_IN_PROP_LIST(&picInfo) = IN;

                    /**
                        This flag causes object to be cloned if any changes
                        are made to it.  Clone will be used for cancel button.
                     **/

                    if (ObjLoadObjectInDoc(&picInfo,docCur,cpPicInfo) == cp0)
                        goto onOut;
                }


                if (msg == WM_INITDIALOG) // select in list if selected in doc
                {
                    if (OBJ_SELECTIONTYPE == LINK)
                        bSelected = (cpPicInfo >= selSave.cpFirst &&
                                        cpPicInfo < selSave.cpLim);
                    else // no selection, select first item
                        bSelected = iListItem == 0;

                    /* OR if its a bad link, take the liberty of selecting it */
                    if (fOBJ_BADLINK(&picInfo))
                        bSelected = TRUE;
                }
                else // select in list if already selected in list
                    bSelected = SendMessage(vhwndObjListBox, LB_GETSEL, iListItem, 0L);

                /* Get the update options */
                if (fOBJ_BADLINK(&picInfo))
                {
                    LoadString(hINSTANCE, IDSTRFrozen, szType, sizeof(szType));
                    if (bSelected)
                        idButton = -1;
                }
                else switch (ObjGetUpdateOptions(&picInfo))
                {
                    case oleupdate_always:
                        LoadString(hINSTANCE, IDSTRAuto, szType, sizeof(szType));
                        if (bSelected)
                            switch (idButton) {
                                case 0:          idButton = IDD_AUTO; break;
                                case IDD_MANUAL: idButton = -1;       break;
                                default:         break;
                            }
                        break;
                    case oleupdate_oncall:
                        LoadString(hINSTANCE, IDSTRManual, szType, sizeof(szType));
                        if (bSelected)
                            switch (idButton) {
                                case 0:         idButton = IDD_MANUAL; break;
                                case IDD_AUTO:  idButton = -1;         break;
                                default:        break;
                            }
                        break;

                    default:
                        LoadString(hINSTANCE, IDSTRFrozen, szType, sizeof(szType));
                        if (bSelected)
                            idButton = -1;

                        /* Disable the change link button, can't change frozen link */
                        aCurName = -1;
                }

                /* Retrieve the server name */
                olestat = ObjGetData(lpOBJ_QUERY_INFO(&picInfo), vcfLink, &hData);

                if ((olestat != OLE_WARN_DELETE_DATA) && (olestat !=  OLE_OK))
                    return TRUE;

                lpstrData = MAKELP(hData,0);

                /* The link format is:  "szClass0szDocument0szItem00" */

                /* Retrieve the server's class ID */
                RegGetClassId(szFull, lpstrData);
                lstrcat(szFull, "\t");

                /* Display the Document and Item names */
                while (*lpstrData++);

                /* Get this document name */
                aDocName = AddAtom(lpstrData);

                /* Make sure only one document selected for Change Link */
                if (bSelected)
                    switch (aCurName) {
                        case 0:
                            aCurName = aDocName;
                        break;
                        case -1:
                        break;
                        default:
                            if (aCurName != aDocName)
                                aCurName = -1;
                        break;
                    }

                DeleteAtom(aDocName);

                /* Strip off the path name and drive letter */
                lpstrTemp = lpstrData;
                while (*lpstrTemp)
                {
                    if (*lpstrTemp == '\\' || *lpstrTemp == ':')
                        lpstrData = lpstrTemp + 1;
#ifdef DBCS //T-HIROYN 1992.07.13
                    lpstrTemp = AnsiNext(lpstrTemp);
#else
                    lpstrTemp++;
#endif
                }

                /* Append the file name */
                lstrcat(szFull, lpstrData);
                lstrcat(szFull, "\t");

                /* Append the item name */
                while (*lpstrData++);
                lstrcat(szFull, lpstrData);
                lstrcat(szFull, "\t");

                if (olestat == OLE_WARN_DELETE_DATA)
                    GlobalFree(hData);

                /* Append the type of link */
                lstrcat(szFull, szType);

                switch (msg)
                {
                    case WM_UPDATELB:
                        SendMessage(vhwndObjListBox, LB_DELETESTRING, iListItem, 0L);
                        // fall through...

                    case WM_INITDIALOG:
                        SendMessage(vhwndObjListBox, LB_INSERTSTRING, iListItem, (DWORD)(LPSTR)szFull);
                        SendMessage(vhwndObjListBox, LB_SETSEL, bSelected, (DWORD)iListItem);
                    break;

                }

                if (bSelected)
                    cSelected++;

                iListItem++;
            }

            /* Uncheck those buttons that shouldn't be checked */
            CheckDlgButton(hDlg, IDD_AUTO,   idButton == IDD_AUTO);
            CheckDlgButton(hDlg, IDD_MANUAL, idButton == IDD_MANUAL);

            /* Gray the Change Link... button, as appropriate */
            EnableWindow(GetDlgItem(hDlg, IDD_CHANGE), (aCurName && aCurName != -1));
            EnableWindow(GetDlgItem(hDlg, IDD_EDIT), cSelected);
            EnableWindow(GetDlgItem(hDlg, IDD_PLAY), cSelected);
            EnableWindow(GetDlgItem(hDlg, IDD_UPDATE), cSelected);
            EnableWindow(GetDlgItem(hDlg, IDD_FREEZE), cSelected);
            EnableWindow(GetDlgItem(hDlg, IDD_AUTO), cSelected);
            EnableWindow(GetDlgItem(hDlg, IDD_MANUAL), cSelected);

            if (msg == WM_UPDATELB)
            {
                /* WM_UPDATELB case:  Redraw the list box */
                InvalidateRect(vhwndObjListBox, NULL, TRUE);
                SendMessage(vhwndObjListBox, WM_SETREDRAW, 1, 0L);
            }

            return TRUE;
        }

        case WM_SYSCOMMAND:
            switch(wParam & 0xFFF0)
            {
                case SC_CLOSE:
                    goto onOut;
                break;
            }
        break;

        case WM_DOLINKSCOMMAND:
        {
            BOOL bError;
            bDidSomething |= DoLinksCommand(wParam,lParam,hDlg,&bError);
            switch (wParam)
            {
                case IDD_PLAY:
                case IDD_EDIT:
                    InvalidateRect(hDOCWINDOW, NULL, TRUE);
                    if (!bError) // don't leave if there was an error 
                        goto onOut;
            }
        }
        break;

        case WM_COMMAND:
            switch (wParam)
            {
                case IDCANCEL:
                    if (bDidSomething)
                    {
                        SendMessage(hDlg,WM_DOLINKSCOMMAND,IDD_UNDO,0L);
                        InvalidateRect(hDOCWINDOW, NULL, TRUE);
                        bDidSomething = FALSE;  // cause its undone now
                    }
                    // fall through...

                case IDOK:
                onOut:
                    if (bDidSomething)
                    {
                        ObjEnumInDoc(docCur,ObjClearCloneInDoc);
                    }
                    NoUndo();
                    bLinkProps = FALSE;
                    //ObjWriteFixup(docCur,FALSE,cp0);
                    OurEndDialog(hDlg, TRUE);
                    UpdateWindow(hDOCWINDOW); // cause we may have lost activation
                    return TRUE;

                default:
                    /** posting message avoids some weird asynchronicities when
                        waiting for objects before returning after pressing a
                        button **/
                    PostMessage(hDlg,WM_DOLINKSCOMMAND,wParam,lParam);
                break;
            }
        break;
    }
    return FALSE;
}

static BOOL DoLinksCommand(WORD wParam, DWORD lParam, HWND hDlg, BOOL *bError)
{
    int     cItems;
    int     i;
    HANDLE hSelected=NULL;
    int far *lpSelected;
    typeCP cpSuccess;
    typeCP cpPicInfo;
    BOOL bFirst=TRUE;
    OBJPICINFO picInfo;
    BOOL bDidSomething=FALSE;
    HWND    vhwndObjListBox      = GetDlgItem(hDlg, IDD_LISTBOX);

    StartLongOp();

    *bError = FALSE;

    switch (wParam)
    {
        case IDD_REFRESH:
        /** update a link if its been set to AUTOMATIC update */
        {
            OLEOPT_UPDATE UpdateOpt;
            if (!ObjError(OleGetLinkUpdateOptions(((LPOBJINFO)lParam)->lpobject,&UpdateOpt)))
                if (UpdateOpt == oleupdate_always)
                    fnObjUpdate((LPOBJINFO)lParam);
            goto SkipIt;
        }
        break;
        case IDD_LISTBOX:
            switch (HIWORD(lParam))
            {
                case LBN_SELCHANGE:
                    PostMessage(hDlg, WM_UPDATEBN, 0, 0L); // fall through
                default:
                    goto SkipIt;
            }
        break;

        case IDD_CHANGE:
            aNewName = aOldName = 0;
            // fall through...

        case IDD_UPDATE:
            ObjEnumInDoc(docCur,ObjSetNoUpdate);
        break;

        case IDD_AUTO:
        case IDD_MANUAL:
            if (IsDlgButtonChecked(hDlg,wParam))
                goto SkipIt;
            /* work around for bug #8280 */
            CheckDlgButton(hDlg,wParam,TRUE);
        break;
    }


    /**
        Everything after here is done for each item selected in
        links list box *
        **/

    /* If nothing is selected, quit! */
    if (wParam != IDD_UNDO)
    {
        if ((cItems = SendMessage(vhwndObjListBox, LB_GETSELCOUNT, 0, 0L)) <= 0)
            goto SkipIt;

        if ((hSelected = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT,
                                cItems * sizeof(int))) == NULL)
        {
            Error(IDPMTNoMemory);
            goto SkipIt;
        }

        if ((lpSelected = (int far *)GlobalLock(hSelected)) == NULL)
        {
            Error(IDPMTNoMemory);
            goto SkipIt;
        }

        /* Retrieve the selected items (in sorted order) */
        SendMessage(vhwndObjListBox, LB_GETSELITEMS,
                            cItems, (DWORD)lpSelected);
    }


    for (i = 0, cpPicInfo = cpNil;
            ObjPicEnumInRange(&picInfo,docCur,cp0,CpMacText(docCur),&cpPicInfo);)
    {
        /**
            For IDD_UNDO we do all.  Dirty flag will filter in the ones
            we've operated on.  Assumes Saved before calling (see
            fnObjProperties())
            **/
        if (fOBJ_QUERY_IN_PROP_LIST(&picInfo)) // is or was in list
        {
            if (wParam == IDD_UNDO)
            {
                cpSuccess = ObjUseCloneInDoc(&picInfo,docCur,cpPicInfo);
                if ((cpSuccess == cp0) || ferror || fPropsError)
                    break; // there was an error
            }
            else if (fOBJ_QUERY_IN_PROP_LIST(&picInfo) == IN)
            {
                /** We're enumerating all objects, not just 
                    ones in list box **/
                if (*lpSelected == i)  // selected item
                {
                    ObjCachePara(docCur,cpPicInfo);
                    switch(wParam)
                    {
                        case IDD_AUTO:          /* Change the (link) update options */
                        case IDD_MANUAL:
                            if (!fOBJ_BADLINK(&picInfo))
                            {
                                cpSuccess = ObjBackupInDoc(&picInfo,docCur,cpPicInfo);
                                if (cpSuccess)
                                    cpSuccess = (typeCP)ObjSetUpdateOptions(&picInfo, wParam, docCur, cpPicInfo);

                            }
                        break;

                        case IDD_CHANGE:
                            if (bFirst)
                            {
                                if (!ObjQueryNewLinkName(&picInfo,docCur,cpPicInfo))
                                    // then didn't get new link name
                                    goto SkipIt;

                                bFirst=FALSE;
                            }

                            cpSuccess = ObjBackupInDoc(&picInfo,docCur,cpPicInfo);

                            if (cpSuccess)
                                cpSuccess = ObjChangeLinkInDoc(&picInfo,docCur,cpPicInfo);

                            /*  must do this because we don't want to put up
                                ChangeOtherLinks dialog until we know the first
                                change was a success */
                            if (cpSuccess)
                            {
                                lpOBJ_QUERY_INFO(&picInfo)->fCompleteAsync = TRUE;
                                if (ObjWaitForObject(lpOBJ_QUERY_INFO(&picInfo),TRUE))
                                    cpSuccess = cp0;
                                else if (ferror || fPropsError)
                                    cpSuccess = cp0;
                            }
                        break;

                        case IDD_PLAY:
                            cpSuccess = ObjPlayObjectInDoc(&picInfo,docCur,cpPicInfo);
                        break;

                        case IDD_EDIT:
                            cpSuccess = ObjEditObjectInDoc(&picInfo,docCur,cpPicInfo);
                        break;

                        case IDD_UPDATE:

                                cpSuccess = ObjBackupInDoc(&picInfo,docCur,cpPicInfo);

                                if (cpSuccess)
                                    cpSuccess = ObjUpdateObjectInDoc(&picInfo,docCur,cpPicInfo);

                                /*  must do this because we don't want to put up
                                    ChangeOtherLinks dialog until we know the first
                                    change was a success */
                                if (cpSuccess)
                                {
                                    lpOBJ_QUERY_INFO(&picInfo)->fCompleteAsync = TRUE;
                                    if (ObjWaitForObject(lpOBJ_QUERY_INFO(&picInfo),TRUE))
                                        cpSuccess = cp0;
                                    else if (ferror || fPropsError)
                                        cpSuccess = cp0;
                                }
                        break;
                        case IDD_UPDATEOTHER:
                            aOldName = aOBJ_QUERY_DOCUMENT_LINK(&picInfo);
                            if (cpSuccess)
                                ChangeOtherLinks(docCur,FALSE,TRUE);
                            aOldName=0;
                        break;
                        case IDD_FREEZE:
                            cpSuccess = ObjBackupInDoc(&picInfo,docCur,cpPicInfo);

                            if (cpSuccess)
                                cpSuccess = ObjFreezeObjectInDoc(&picInfo,docCur,cpPicInfo);
                        break;
                    }
                    if ((cpSuccess == cp0) || ferror || fPropsError)
                        break; // there was an error
                    lpSelected++;
                }
                i++;  // counting all objects in list box
            }  // end if IN
        }
    }

    /*** Handle error conditions ***/
    if ((cpSuccess == cp0) || ferror || fPropsError)
    {
        *bError = TRUE;
        if (!ferror) // issue error message
        {
            switch (wParam)
            {
                case IDD_UPDATE:
                case IDD_CHANGE:
                    Error(IDPMTLinkUnavailable);
                break;
                default:
                    Error(IDPMTOLEError);
                break;
            }
        }

        if (wParam != IDD_UNDO)
        {
            /** so we can continue calling Replace(), etc */
            ferror = FALSE;

            /* undo whatever we tried to do that failed */
            ObjCachePara(docCur,cpPicInfo); // for use clone
            ObjUseCloneInDoc(&picInfo,docCur,cpPicInfo);
            lpOBJ_QUERY_INFO(&picInfo)->fCompleteAsync = TRUE;
            ObjWaitForObject(lpOBJ_QUERY_INFO(&picInfo),TRUE);
            ObjInvalidatePict(&picInfo,cpPicInfo);
            PostMessage(hDlg,WM_UPDATELB,0,0L);

            ferror = FALSE; // again
        }

        fPropsError = FALSE;
    }

    switch (wParam)
    {
        /* Dismiss the dialog on Open */
        case IDD_UPDATEOTHER:
            UPDATE_INVALID();
        break;

        case IDD_PLAY:
        case IDD_EDIT:
        case IDD_UNDO:
        break;

        case IDD_UPDATE:
        if (cpSuccess)
            SendMessage(hDlg,WM_COMMAND,IDD_UPDATEOTHER,0L);
        bDidSomething = TRUE;
        break;

        case IDD_CHANGE:
            if (cpSuccess)
            {
                /** aOldName and aNewName are now set, change other links having
                    aOldName */
                /** if first change is bad, don't change others */
                ChangeOtherLinks(docCur,TRUE,TRUE);
                UPDATE_INVALID();
            }

            aOldName=0;
            aNewName=0;

            // fall through....

        case IDD_FREEZE:
        case IDD_AUTO:
        case IDD_MANUAL:
            PostMessage(hDlg,WM_UPDATELB,0,0L);
            bDidSomething = TRUE;
        break;
    }

    SkipIt:

    if (hSelected)
        GlobalFree(hSelected);

    EndLongOp(vhcArrow);

    return bDidSomething;
}
#else
// cause I don't wanna change def file yet...
BOOL FAR PASCAL fnProperties(HWND hDlg, unsigned msg, WORD wParam, LONG lParam)
{
    hDlg;
}
#endif

/* Invalid Link dialog */
int FAR PASCAL fnInvalidLink(HWND hDlg, unsigned msg, WORD wParam, LONG lParam)
{
    switch (msg) {
        case WM_INITDIALOG:
#if 0
        {
            char lpString[120];

            LoadString(hINSTANCE, (WORD)lParam, lpString, sizeof(lpString));
            SetDlgItemText(hDlg,IDD_MESSAGE,lpString);
        }
#endif
        break;

        case WM_SYSCOMMAND:
            switch(wParam & 0xFFF0)
            {
                case SC_CLOSE:
                    EndDialog(hDlg, IDOK);
                break;
            }
        break;

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                case IDD_CHANGE:
                    EndDialog(hDlg, wParam);
            }
    }
    return FALSE;
}

/* Insert New... dialog */
int FAR PASCAL fnInsertNew(HWND hDlg, unsigned msg, WORD wParam, LONG lParam)
{
    HWND hwndList = GetDlgItem(hDlg, IDD_LISTBOX);

    switch (msg) {
        case WM_INITDIALOG:
            if (!RegGetClassNames(hwndList))
                OurEndDialog(hDlg, IDCANCEL);

            EnableOtherModeless(FALSE);
            SendMessage(hwndList, LB_SETCURSEL, 0, 0L);
            break;

        case WM_ACTIVATE:
            if (wParam)
                vhWndMsgBoxParent = hDlg;
        break;

        case WM_SYSCOMMAND:
            switch(wParam & 0xFFF0)
            {
                case SC_CLOSE:
                    OurEndDialog(hDlg, IDCANCEL);
                break;
            }
        break;

        case WM_COMMAND:
            switch (wParam) {

                case IDD_LISTBOX:
                    if (HIWORD(lParam) != LBN_DBLCLK)
                        break;

                case IDOK:
                    StartLongOp();
                    if (!RegCopyClassName(hwndList, (LPSTR)szClassName))
                        wParam = IDCANCEL;
                    // fall through ...

                case IDCANCEL:
                    OurEndDialog(hDlg, wParam);
                break;
            }
            break;
    }
    return FALSE;
}

BOOL vbCancelOK=FALSE;

/* Waiting for object dialog */
BOOL FAR PASCAL fnObjWait(HWND hDlg, unsigned msg, WORD wParam, LONG lParam)
{
    static LPOLEOBJECT lpObject;
    static LPOBJINFO lpOInfo;
    static BOOL bCanCancel;
    extern HWND             hwndWait;
    extern int vfDeactByOtherApp;
    extern int flashID;

    switch (msg) {
        case WM_INITDIALOG:
        {
            /**
                NOTE: the key idea in setting these options is that the cancel
                button must cancel what the user thinks is the current operation.

                vbCancelOK == TRUE,
                    cancel button may be enabled, depending on other flags
                    vbCancelOK is set in WMsgLoop.

                lpOInfo->fCancelAsync == TRUE,
                    Cancel is enabled if vbCancelOK
                    Cancel button cancels dialog without regard to pending async.
                    Pending async is killed quietly in CallBack if possible.
                    Generally use if the pending async is not part of the operation
                    being cancelled, and:
                        1)  You're about to make a very important call which justifies
                            silently killing any pending operation.
                    Note: this one is weird if you're trying to release or delete, because
                        the pending async could itself be a release or delete.

                lpOInfo->fCompleteAsync == TRUE,
                    Cancel is enabled only if pending async can be cancelled.
                    Cancel button cancels pending async.
                    Generally use if the pending async *is* part of the operation
                    being cancelled, and:
                        1)  You're in a sequence of async calls and cancelling
                            would require cancelling the previous async in the
                            sequence, or
                        2)  You have just made an async call which you want to make
                            synchronous but don't mind if the user cancels it.

                lpOInfo->fCanKillAsync == TRUE,
                    Use with lpOInfo->fCompleteAsync.
                    Indicates that we already know that the async can be cancelled,
                    so Cancel button can be enabled immediately.
            **/

            hwndWait = hDlg;
            lpObject = (LPOLEOBJECT)lParam;

            Assert (lpObject != NULL);

            lpOInfo = GetObjInfo(lpObject);

            Assert(lpOInfo != NULL);

            bCanCancel=FALSE;
            if (vbCancelOK && (!lpOInfo->fCompleteAsync || lpOInfo->fCanKillAsync))
                SendMessage(hDlg,WM_UKANKANCEL,0,0L);

            if (lpOInfo->fCancelAsync)
            /* we'll cancel async in CallBack if get a QUERY_RETRY */
                 lpOInfo->fKillMe = TRUE;

            SetTimer(hDlg, 1234, 250, (FARPROC)NULL);

            return TRUE;
        }
        break;


        case WM_ACTIVATE:
            if (wParam)
                vhWndMsgBoxParent = hDlg;
        break;

        case WM_RUTHRUYET:
        case WM_TIMER:
            /* this is a lot easier than making this modeless */
            /* we gotta check this because if server dies we don't get 
                an OLE_RELEASE (the 'normal way this dialog is knocked off),
                rather OleQueryReleaseStatus will return OLE_OK */
            if (OleQueryReleaseStatus(lpObject) != OLE_BUSY)
                PostMessage(hDlg,WM_DIESCUMSUCKINGPIG,0,0L);
        break;

        case WM_UKANKANCEL:
        /* we got a QUERY_RETRY or are initing */
        if (!bCanCancel && vbCancelOK)
        {
            char szMsg[20];

            LoadString(hINSTANCE, IDSTRCancel, szMsg, sizeof(szMsg));
            SetDlgItemText(hDlg,IDOK,szMsg);
            bCanCancel=TRUE;
        }
        break;

        case WM_DIESCUMSUCKINGPIG:
            hwndWait = NULL;

            KillTimer(hDlg, 1234);

            /* clear flags */
            if (CheckPointer(lpOInfo,1))
            {
                lpOInfo->fCompleteAsync =
                lpOInfo->fCancelAsync =
                lpOInfo->fCanKillAsync = FALSE;
            }

            /* wParam is TRUE if error */
            OurEndDialog(hDlg,wParam);
        break;

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                    if (bCanCancel) // pressed cancel button
                    {
                        if (lpOInfo->fCompleteAsync)
                            lpOInfo->fKillMe = TRUE; // cancel async asynchronously
                        else if (lpOInfo->fCancelAsync)
                            lpOInfo->fKillMe = FALSE; // had a chance to kill, user doesn't care anymore
                        PostMessage(hDlg,WM_DIESCUMSUCKINGPIG,1,0L);
                    }
                    else
                    {
                        /* retry */
                        if (OleQueryReleaseStatus(lpObject) != OLE_BUSY)
                            PostMessage(hDlg,WM_DIESCUMSUCKINGPIG,0,0L);
                    }
                    break;

                case IDD_SWITCH:
                    /* bring up task list */
                    DefWindowProc(hDlg,WM_SYSCOMMAND,SC_TASKLIST,0L);
                break;
            }
            break;

        default:
            break;
    }
    return FALSE;
}


/****************************************************************/
/*********************** VARIOUS OLE FUNCTIONS ******************/
/****************************************************************/
void fnObjInsertNew(void)
{
    OBJPICINFO picInfo;
    typeCP cpNext=selCur.cpFirst;

    if (!FWriteOk( fwcInsert ))
        return;

    /* this'll set global szClassName */
    if (OurDialogBox(hINSTANCE, "DTCREATE" ,hMAINWINDOW, lpfnInsertNew) == IDCANCEL)
        return;

    StartLongOp();

    ObjCachePara( docCur, cpNext);

    if (!ObjCreateObjectInDoc(docCur, cpNext))
    {
        ClearInsertLine();
        fnClearEdit(OBJ_INSERTING);
        NoUndo();
    }
    EndLongOp(vhcIBeam);
}


BOOL ObjCreateObjectInDoc(int doc,typeCP cpParaStart)
/* assumes szClassName is set to server class */
/* called only for InsertObject */
/* return whether error */
{
    szOBJNAME szObjName;
    LPOBJINFO lpObjInfo=NULL;

    if ((lpObjInfo = ObjGetObjInfo(szObjName)) == NULL)
        goto err;

    if (ObjError(OleCreate(PROTOCOL, (LPOLECLIENT)lpObjInfo,
                    (LPSTR)szClassName,
                    lhClientDoc, szObjName, &(lpObjInfo->lpobject), olerender_draw, 0)))
    {
        /* will free memory later */
        lpObjInfo->lpobject = NULL;
        goto err;
    }

    /* normally set in ObjAllocObjInfo, but for unfinished objects we need it now! */
    lpObjInfo->cpWhere = cpParaStart;

    lpObjInfo->objectType = NONE;

    //lpObjInfo->aName = AddAtom(szClassName);

    if (ObjInitServerInfo(lpObjInfo))
        goto err;

    return FALSE;

    err:
    if (lpObjInfo)
        ObjDeleteObject(lpObjInfo,TRUE);
    Error(IDPMTFailedToCreateObject);
    return TRUE;
}

#define DRAG_EMBED      0               /* nothing */
#define DRAG_LINK       6               /* Ctrl + Shift + Drag */
#define DRAG_MULTIPLE   4               /* Shift + Drag */

void ObjGetDrop(HANDLE hDrop, BOOL bOpenFile)
{
    int nNumFiles,count;
    char szFileName[cchMaxFile];
    extern struct CHP vchpSel;
    struct CHP chpT;
    BYTE    bKeyState = 0;
    typeCP cpFirst=selCur.cpFirst, dcp = 0;
    int cchAddedEol=0;
    typeCP cpNext=selCur.cpFirst,cpPrev=selCur.cpFirst,cpSel;
    OBJPICINFO picInfo;
    BOOL bError=FALSE;
    static char szPackage[] = "Package";
    MSG msg;

    if (!FWriteOk( fwcInsert ))
        return;

    /* get number of files dropped */
    nNumFiles = DragQueryFile(hDrop,0xFFFF,NULL,0);

    /* See what the user wants us to do */
    PeekMessage(&msg, (HWND)NULL, NULL, NULL, PM_NOREMOVE);
    bKeyState = ((((GetKeyState(VK_SHIFT) < 0) << 2)
                | ((GetKeyState(VK_CONTROL) < 0) << 1)));

    if ((nNumFiles == 0) ||
        ((bKeyState != DRAG_EMBED) && (bKeyState != DRAG_LINK) && (bKeyState != DRAG_MULTIPLE)) ||
         (bOpenFile && (bKeyState != DRAG_EMBED) && (bKeyState != DRAG_MULTIPLE)))
    {
        DragFinish(hDrop);
        return;
    }

    if (bOpenFile)
    {
        DragQueryFile(hDrop,0,szFileName,sizeof(szFileName));
        fnOpenFile((LPSTR)szFileName);
        DragFinish(hDrop);
        return;
    }

    ClearInsertLine();

    if (fnClearEdit(OBJ_INSERTING))
        return;

    StartLongOp();

    chpT = vchpSel;

    (**hpdocdod)[docCur].fFormatted = fTrue;

    if (cpFirst > cp0)
    {
        ObjCachePara(docCur, cpFirst - 1);
        if (vcpLimParaCache != cpFirst)
        {
            cchAddedEol = ccpEol;
            InsertEolPap(docCur, selCur.cpFirst, &vpapAbs);
            cpNext += (typeCP)ccpEol;
        }
    }

    ObjCachePara( docCur, cpNext );

    /* create object for each file dropped */
    for (count=0; count < nNumFiles; ++count)
    {
        szOBJNAME szObjName;
        typeCP cpTmp;

        /* get the filename */
        DragQueryFile(hDrop,count,szFileName,sizeof(szFileName));

        if (ObjAllocObjInfo(&picInfo,cpNext,EMBEDDED,TRUE,szObjName))
        {
            bError=TRUE;
            goto end;
        }

        if ((bKeyState == DRAG_LINK))
        {
            if (ObjError(OleCreateLinkFromFile(PROTOCOL, (LPOLECLIENT)lpOBJ_QUERY_INFO(&picInfo),
                        szPackage,
                        szFileName, NULL,
                        lhClientDoc, szObjName,
                        &lpOBJ_QUERY_OBJECT(&picInfo), olerender_draw, 0)))
            {
                bError=TRUE;
                lpOBJ_QUERY_OBJECT(&picInfo) = NULL;
                goto end;
            }
        }
        else // if ((bKeyState == DRAG_EMBED))
        {
            if (ObjError(OleCreateFromFile(PROTOCOL, (LPOLECLIENT)lpOBJ_QUERY_INFO(&picInfo),
                        szPackage,
                        szFileName,
                        lhClientDoc, szObjName,
                        &lpOBJ_QUERY_OBJECT(&picInfo), olerender_draw, 0)))
            {
                bError=TRUE;
                lpOBJ_QUERY_OBJECT(&picInfo) = NULL;
                goto end;
            }
        }

        if (ObjInitServerInfo(lpOBJ_QUERY_INFO(&picInfo)))
        {
            bError=TRUE;
            goto end;
        }

        if (!FComputePictSize(&picInfo, &(picInfo.dxaSize),
                              &(picInfo.dyaSize)))
        {
            bError=TRUE;
            goto end;
        }

        ObjCachePara(docCur,cpNext);
        if ((cpTmp = ObjSaveObjectToDoc(&picInfo,docCur,cpNext)) == cp0)
        {
            bError=TRUE;
            goto end;
        }

        cpNext = cpTmp;
    }

    end:

    dcp = cpNext-cpFirst;
    if (dcp)
    {
        cpSel=CpFirstSty(cpFirst + dcp, styChar );

        SetUndo( uacInsert, docCur, cpFirst, dcp, docNil, cpNil, cp0, 0 );
        SetUndoMenuStr(IDSTRUndoEdit);

        if (vuab.uac == uacReplNS)
            /* Special UNDO code for picture paste */
            vuab.uac = uacReplPic;

        Select(cpSel, cpSel);
        vchpSel = chpT; /* Preserve insert point props across this operation */
        if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
            {   /* If running head/foot, remove chSects & set para props */
            MakeRunningCps( docCur, cpFirst, dcp    );
            }
        if (ferror)
            NoUndo();
    }

    if (bError)
    {
        Error(IDPMTFailedToCreateObject);
        ObjDeleteObject(lpOBJ_QUERY_INFO(&picInfo),TRUE);
    }

    EndLongOp(vhcIBeam);
    DragFinish(hDrop);
}

int vcVerbs;
void fnObjDoVerbs(WORD wVerb)
{
    NoUndo();

    if ((wVerb == imiVerb) // more than one object selected
        || (vcVerbs == 1)) // one verb
        OBJ_PLAYEDIT = OLEVERB_PRIMARY;
    else
        OBJ_PLAYEDIT = (int)(wVerb - imiVerb - 1);
    ObjEnumInRange(docCur,selCur.cpFirst,selCur.cpLim,ObjPlayObjectInDoc);
    OBJ_PLAYEDIT = OLEVERB_PRIMARY;
}

void fnObjProperties(void)
{
    int nRetval;

    if (nRetval != -1)
        OurDialogBox(hINSTANCE, "DTPROP", hMAINWINDOW, lpfnLinkProps);
}

BOOL fnObjUpdate(LPOBJINFO lpObjInfo)
{
    BOOL bRetval;
#ifdef DEBUG
        OutputDebugString( (LPSTR) "Updating object\n\r");
#endif
    if (ObjWaitForObject(lpObjInfo,TRUE))
        return TRUE;

    StartLongOp();
    if ((bRetval = ObjError(OleUpdate(lpObjInfo->lpobject))))
            Error(IDPMTFailedToUpdate);
    EndLongOp(vhcArrow);
    return bRetval;
}


BOOL ObjDeleteObject(LPOBJINFO lpObjInfo, BOOL bDelete)
/** Delete object as well as objinfo.  Note this must be synchronous.
    Return whether an error.
**/
{
    LPOLEOBJECT lpObject;

    Assert(lpObjInfo != NULL);

    if (!CheckPointer((LPSTR)lpObjInfo,1))
        return FALSE; // already deleted

    lpObject = lpObjInfo->lpobject;

    if (lpObject == NULL)
    {
        ObjDeleteObjInfo(lpObjInfo);
        return FALSE;
    }

    /* make sure not already deleted */
    if (!ObjIsValid(lpObject))
    {
        ObjDeleteObjInfo(lpObjInfo);
        return FALSE;
    }

    /** asynchronous deletion **/
    if (OleQueryReleaseStatus(lpObject) != OLE_BUSY)
    {
        OLESTATUS olestat;

        if (bDelete)
            olestat = OleDelete(lpObject);
        else
            olestat = OleRelease(lpObject);

        switch (olestat)
        {
            case OLE_OK:
                ObjDeleteObjInfo(lpObjInfo);
            break;
            case OLE_WAIT_FOR_RELEASE:
                lpObjInfo->fFreeMe = TRUE;
            break;
        }
    }
    else if (bDelete)
        lpObjInfo->fDeleteMe = TRUE; // delete on OLE_RELEASE
    else
        lpObjInfo->fReleaseMe = TRUE; // release on OLE_RELEASE

    return FALSE;
}


#include <print.h>
HANDLE hStdTargetDevice=NULL;

void ObjSetTargetDevice(BOOL bSetObjects)
{
    extern PRINTDLG PD;  /* Common print dlg structure, initialized in the init code */
    extern CHAR (**hszPrinter)[];
    extern CHAR (**hszPrDriver)[];
    extern CHAR (**hszPrPort)[];
    LPSTDTARGETDEVICE lpStdTargetDevice;
    WORD nCount;
    DEVMODE FAR *lpDevmodeData;
    char FAR *lpData;
    LPOLEOBJECT lpObject;
    STDTARGETDEVICE stdT;

    if (!PD.hDevMode)
    /* then get for default printer */
    {
        if (hszPrinter == NULL || hszPrDriver == NULL || hszPrPort == NULL)
            return;

        if (**hszPrinter == '\0' || **hszPrDriver == '\0' || **hszPrPort == '\0')
            return;

        if (fnPrGetDevmode())
            return;
    }

    lpDevmodeData = MAKELP(PD.hDevMode,0);

    /* get the offsets */
    stdT.deviceNameOffset = 0;
    nCount = CchSz(*hszPrinter);

    stdT.driverNameOffset = nCount;
    nCount += CchSz(*hszPrDriver);

    stdT.portNameOffset = nCount;
    nCount += CchSz(*hszPrPort);

    stdT.extDevmodeOffset = nCount;
    nCount += (stdT.extDevmodeSize = lpDevmodeData->dmSize);

    stdT.environmentOffset = nCount;
    nCount += (stdT.environmentSize = lpDevmodeData->dmSize);

    /* alloc the buffer */
    if (hStdTargetDevice == NULL)
    {
        if ((hStdTargetDevice = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,nCount+sizeof(STDTARGETDEVICE))) == NULL)
            return;
    }
    else
    {
        if ((hStdTargetDevice =
            GlobalReAlloc(hStdTargetDevice,
                            nCount+sizeof(STDTARGETDEVICE),GMEM_MOVEABLE|GMEM_ZEROINIT)) == NULL)
        {
            return;
        }
    }

    lpStdTargetDevice = (LPSTDTARGETDEVICE)GlobalLock(hStdTargetDevice);
    GlobalUnlock(hStdTargetDevice);

    /* copy stdT into lpStdTargetDevice */
    bltbx((LPSTR)&stdT, lpStdTargetDevice, sizeof(STDTARGETDEVICE));

    /* get temporary pointer to the end of StdTargetDevice (the data buffer) */
    lpData = ((LPSTR)lpStdTargetDevice) + sizeof(STDTARGETDEVICE);

    /* now fill the buffer */
    nCount = lpStdTargetDevice->driverNameOffset;
    bltbx((LPSTR)*hszPrinter, lpData, nCount);
    lpData += nCount;

    nCount = lpStdTargetDevice->portNameOffset -
                                lpStdTargetDevice->driverNameOffset;
    bltbx((LPSTR)*hszPrDriver, lpData, nCount);
    lpData += nCount;

    nCount = lpStdTargetDevice->extDevmodeOffset -
                                lpStdTargetDevice->portNameOffset;
    bltbx((LPSTR)*hszPrPort, lpData, nCount);
    lpData += nCount;

    nCount = lpStdTargetDevice->extDevmodeSize;
    bltbx(lpDevmodeData, (LPSTR)lpData, nCount);
    lpData += nCount;

    /* environment info is the same as the devmode info */
    bltbx(lpDevmodeData, (LPSTR)lpData, nCount);

    /* now set all the objects to this printer */
    if (bSetObjects)
    {
        lpObject=NULL;
        do
        {
            OleEnumObjects(lhClientDoc,&lpObject);
            if (lpObject)
            {
#ifdef DEBUG
                OutputDebugString("Setting Target Device\n\r");
#endif

                OleSetTargetDevice(lpObject,hStdTargetDevice);
            }
        }
        while (lpObject);
    }
}

BOOL ObjSetTargetDeviceForObject(LPOBJINFO lpObjInfo)
/* return whether error */
/* we assume object ain't busy!! */
{
    extern CHAR (**hszPrinter)[];
    extern CHAR (**hszPrDriver)[];
    extern CHAR (**hszPrPort)[];

    if (lpObjInfo == NULL)
    {
        Assert(0);
        return TRUE;
    }
    if (lpObjInfo->lpobject == NULL)
    {
        Assert(0);
        return TRUE;
    }

    if (lpObjInfo->objectType == STATIC)
        return FALSE;

    if (hszPrinter == NULL || hszPrDriver == NULL || hszPrPort == NULL)
        return FALSE;

    if (**hszPrinter == '\0' || **hszPrDriver == '\0' || **hszPrPort == '\0')
        return FALSE;

    if (PD.hDevMode == NULL)
        ObjSetTargetDevice(FALSE);

    if (PD.hDevMode == NULL)
    {
        return FALSE;   // punt, couldn't get extdevmode structure.  
                        // device doesn't support it
    }

#ifdef DEBUG
    OutputDebugString("Setting Target Device\n\r");
#endif

    return (ObjError(OleSetTargetDevice(lpObjInfo->lpobject,hStdTargetDevice)));
}

#if 0
BOOL ObjContainsUnfinished(int doc, typeCP cpFirst, typeCP cpLim)
{
    OBJPICINFO picInfo;
    typeCP cpPicInfo;
    BOOL bRetval=FALSE;

    StartLongOp();

    for (cpPicInfo = cpNil;
        ObjPicEnumInRange(&picInfo,doc,cpFirst,cpLim,&cpPicInfo);
        )
        {
            if (lpOBJ_QUERY_INFO(&picInfo) == NULL)
                continue;

            if (otOBJ_QUERY_TYPE(&picInfo) == NONE)
            {
                bRetval = TRUE;
                break;
            }
        }

    EndLongOp(vhcArrow);
    return bRetval;
}
#endif

BOOL ObjContainsOpenEmb(int doc, typeCP cpFirst, typeCP cpLim, BOOL bLookForUnfinished)
{
    OBJPICINFO picInfo;
    typeCP cpPicInfo;
    BOOL bRetval=FALSE;
    LPLPOBJINFO lplpObjTmp;

    StartLongOp();

    for (cpPicInfo = cpNil;
        ObjPicEnumInRange(&picInfo,doc,cpFirst,cpLim,&cpPicInfo);
        )
        {
            if (lpOBJ_QUERY_INFO(&picInfo) == NULL)
                continue;

            if (lpOBJ_QUERY_OBJECT(&picInfo) == NULL)
                continue;

#if 0  // see new check below (NONEs are no longer saved to doc)
            if (otOBJ_QUERY_TYPE(&picInfo) == NONE)
            {
                bRetval = TRUE;
                break;
            }
#endif

            if ((otOBJ_QUERY_TYPE(&picInfo) == EMBEDDED) &&
                OleQueryOpen(lpOBJ_QUERY_OBJECT(&picInfo)) == OLE_OK)
            {
                bRetval = TRUE;
                break;
            }
        }

    if (bLookForUnfinished)
        for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
        {
            if (((*lplpObjTmp)->objectType == NONE) &&
                ((*lplpObjTmp)->cpWhere >= cpFirst) &&
                ((*lplpObjTmp)->cpWhere <= cpLim))
                {
                    bRetval = TRUE;
                    break;
                }
        }

    EndLongOp(vhcArrow);
    return bRetval;
}

BOOL ObjDeletionOK(int nMode)
/**
    Return whether OK to delete objects in current selection.
    We don't worry about unfinished objects because they are just floating around in space
    (ie, no picinfo has been yet saved to the doc),
    and we don't allow the user to delete them until they are finished or the
    document is abandonded.
  **/
{
    if (ObjContainsOpenEmb(docCur, selCur.cpFirst, selCur.cpLim,FALSE))
    {
        switch (nMode)
        {
            case OBJ_INSERTING:
                Error(IDPMTInsertOpenEmb);
                return FALSE;
            break;
            case OBJ_CUTTING:
            case OBJ_DELETING:
            {
                char szMsg[cchMaxSz];

                LoadString(hINSTANCE,
                    nMode == OBJ_DELETING ? IDPMTDeleteOpenEmb : IDPMTCutOpenEmb,
                    szMsg, sizeof(szMsg));

                if (MessageBox(hPARENTWINDOW, (LPSTR)szMsg, (LPSTR)szAppName, MB_OKCANCEL) == IDCANCEL)
                    return FALSE;

                if (ObjEnumInRange(docCur,selCur.cpFirst,selCur.cpLim,ObjCloseObjectInDoc) < 0)
                    return FALSE;

                /* handle any unfinished objects in selection region */
                ObjAdjustCpsForDeletion(docCur);

                return TRUE;
            }
            break;
        }
    }
    else
    {
        /* handle any unfinished objects in selection region */
        ObjAdjustCpsForDeletion(docCur);
        return TRUE;
    }
}

void ObjAdjustCps(int doc,typeCP cpLim, typeCP dcpAdj)
/* for every picinfo after cpLim, adjust the cp value in its objinfo */
{
    LPLPOBJINFO lplpObjTmp;
    typeCP cpMac = CpMacText(doc);

    if (dcpAdj == cp0)
        return;

    if (doc != docCur)
        return;

    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
    {
        if (((*lplpObjTmp)->objectType == NONE) &&
            ((*lplpObjTmp)->cpWhere >= cpLim))
            {
                typeCP cpNew = (*lplpObjTmp)->cpWhere + dcpAdj;
                if (cpNew > cpMac)
                    cpNew = cpMac;
                else if (cpNew < cp0)
                    cpNew = cp0;
                (*lplpObjTmp)->cpWhere = cpNew;
            }
    }
}

void ObjAdjustCpsForDeletion(int doc)
/* for every picinfo in selCur, set cpWhere to selCur.cpFirst (presumably
   selCur is about to be deleted) */
{
    LPLPOBJINFO lplpObjTmp;

    if (selCur.cpFirst == selCur.cpLim)
        return;

    if (doc != docCur)
        return;

    for (lplpObjTmp = NULL; lplpObjTmp = EnumObjInfos(lplpObjTmp) ;)
    {
        if (((*lplpObjTmp)->objectType == NONE) &&
            ((*lplpObjTmp)->cpWhere >= selCur.cpFirst) &&
            ((*lplpObjTmp)->cpWhere <= selCur.cpLim))
                (*lplpObjTmp)->cpWhere = selCur.cpFirst;
    }
}

#include <stdlib.h>

BOOL GimmeNewPicinfo(OBJPICINFO *pPicInfo, LPOBJINFO lpObjInfo)
/* assume lpObjInfo already is filled out */
/* return whether error */
{
    szOBJNAME szObjName;
    char *pdumb;

    if (lpObjInfo == NULL)
        return TRUE;

    bltbc( pPicInfo, 0, cchPICINFOX );

    /* objinfo */
    lpOBJ_QUERY_INFO(pPicInfo) = lpObjInfo;

    /* so Save'll save */
    fOBJ_QUERY_DIRTY_OBJECT(pPicInfo) = TRUE;

    /* only save picinfo until File.Save */
    bOBJ_QUERY_DONT_SAVE_DATA(pPicInfo) = TRUE;

    ObjUpdateFromObjInfo(pPicInfo);

    /* data size */
    dwOBJ_QUERY_DATA_SIZE(pPicInfo) = 0xFFFFFFFF; // to indicate brand new object

    pPicInfo->mx = mxMultByOne;
    pPicInfo->my = myMultByOne;
    pPicInfo->cbHeader = cchPICINFOX;
    pPicInfo->dxaOffset = 0;
    pPicInfo->mm = MM_OLE;
    pPicInfo->dxaSize = nOBJ_BLANKOBJECT_X;
    pPicInfo->dyaSize = nOBJ_BLANKOBJECT_Y;
    return FALSE;
}

BOOL ObjInitServerInfo(LPOBJINFO lpObjInfo)
/* this is called right after creating an object */
/* return whether error */
{
    lpObjInfo->fCompleteAsync = TRUE; // kill prev async (OleCreate...)
    if (ObjWaitForObject(lpObjInfo,TRUE))
        return TRUE;

    /* make sure Create succeeded */
    if (lpObjInfo->fDeleteMe)
    /* this is how we know it failed asynchronously */
        return TRUE;

    if ((lpObjInfo->objectType == EMBEDDED) ||
        (lpObjInfo->objectType == NONE))
    {
        if (ObjSetHostName(lpObjInfo,docCur))
            return TRUE;

        lpObjInfo->fCompleteAsync = TRUE; // kill SetHostName if Cancel
        if (ObjWaitForObject(lpObjInfo,TRUE))
            return TRUE;
    }

    if (ObjSetTargetDeviceForObject(lpObjInfo))
        return TRUE;

    if (lpObjInfo->aName == NULL)
        if (lpObjInfo->objectType == LINK)
        {
            lpObjInfo->fCompleteAsync = TRUE; // kill SetTarget if Cancel
            if (ObjWaitForObject(lpObjInfo,TRUE))
                return TRUE;
            if ((lpObjInfo->aName = MakeLinkAtom(lpObjInfo)) == NULL)
                return TRUE;
        }

    /* note: Caller needs to handle getting the size of object. */

    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\objmini.asm ===
;\
    ;   obj.asm
    ;
    ;   Copyright (C) 1992, MicroSoft Corporation
    ;
    ;   Contains pointer validation routine
    ;       
    ;   History:  sriniK   02/01/1991 original
    ;             (8.20.91) v-dougk made into far proc
   ;/               

.286p
.MODEL MEDIUM
.CODE

;**************************** _CheckPointer ****************************
;
;   WORD    _CheckPointer (lp, access)
;
;   Args:
;       lp          pointer to be verified
;       access      0 test the pointer for read access
;                   1 test the pointer for write access
;   returns: 
;       FALSE       invalid pointer
;       TRUE        valid pointer
;
;
;
        public  _CheckPointer

_CheckPointer   proc

            push    bp
            mov     bp, sp
            
            xor     ax, ax ; assume an error
            and     word ptr [bp+0AH], -1
            jnz     check_write_access

            verr    word ptr [bp+8]     ; check selector for read access
            jnz     error
            jmp short check_offset

check_write_access:
            verw    word ptr [bp+8]     ; check selector for write access
            jnz     error                                         
                                                                        
check_offset:
            lsl     bx, word ptr [bp+8] ; segment limit gets copied into BX
            jnz     error                                         
            cmp     [bp+6], bx          
            ja      error                                       
            or      ax, -1                                              
error:                  
            pop     bp
            ret

_CheckPointer   endp


            end


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\objpsp.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#include "windows.h"
#include "mw.h"
#include "winddefs.h"
#include "obj.h"
#include "objreg.h"
#include "str.h"

static BOOL GetClipObjectInfo(LPSTR szClass, LPSTR szItem);
BOOL QueryPasteFromClip(OLEOPT_RENDER lpRender, OLECLIPFORMAT lpFormat);
BOOL QueryLinkFromClip(OLEOPT_RENDER lpRender, OLECLIPFORMAT lpFormat);
static int FillListFormat(HWND hwndList, BOOL bObjAvail);
static WORD GetFormatClip(int i);
static BOOL IsFormatAvailable(WORD cfFormat);

WORD cfObjPasteSpecial;
BOOL vObjPasteLinkSpecial;
WORD rgchFormats[5];
int  irgchFormats = 0;

void fnObjPasteSpecial(void)
{
    if (OurDialogBox(hINSTANCE, "PasteSpecial", hMAINWINDOW, lpfnPasteSpecial))
        fnPasteEdit();
    cfObjPasteSpecial = 0; // clear it for next time
    vbObjLinkOnly =  vObjPasteLinkSpecial = FALSE;
}

int FAR PASCAL fnPasteSpecial(HWND hDlg, unsigned message, WORD wParam, LONG lParam)
{
    extern HWND vhWndMsgBoxParent;
    static BOOL bLinkAvail,bObjAvail;
    extern BOOL ferror;

    switch (message)
        {
        case WM_INITDIALOG:
        {
            char szClassName[KEYNAMESIZE];
            char szItemName[CBPATHMAX];
            int nWhichToSelect;

            HWND hwndList = GetDlgItem(hDlg,IDD_LISTBOX);

            szClassName[0] = szItemName[0] = '\0';
            irgchFormats = 0; //always start with 0
            vObjPasteLinkSpecial = vbObjLinkOnly = FALSE;

            bObjAvail  = OleQueryCreateFromClip(PROTOCOL, olerender_draw, 0) == OLE_OK;
            bLinkAvail = OleQueryLinkFromClip(PROTOCOL, olerender_draw, 0) == OLE_OK;

            if (bObjAvail || bLinkAvail)
            {
                GetClipObjectInfo(szClassName, szItemName);
                SetWindowText(GetDlgItem(hDlg,IDD_CLIPOWNER), szClassName);
                SetWindowText(GetDlgItem(hDlg,IDD_ITEM), szItemName);
            }
            else
                ShowWindow(GetDlgItem(hDlg,IDD_SOURCE), SW_HIDE);

            if (bObjAvail || bLinkAvail)
            /* then there's an object on clipboard */
            {
                char szListItem[CBMESSAGEMAX]; // hope this is big enough!
                char szTmp[CBMESSAGEMAX];

                LoadString(hINSTANCE, IDSTRObject, szTmp, sizeof(szTmp));
                wsprintf(szListItem,"%s %s",(LPSTR)szClassName,(LPSTR)szTmp);
                SendMessage(hwndList, LB_INSERTSTRING, irgchFormats, (DWORD)(LPSTR)szListItem);
                if (bObjAvail)
                    rgchFormats[irgchFormats++] = vcfOwnerLink;
                else
                    rgchFormats[irgchFormats++] = vcfLink;
            }

            nWhichToSelect = FillListFormat(hwndList,bObjAvail || bLinkAvail);

            /* select what Write would normally take */
            SendMessage(hwndList, LB_SETCURSEL, nWhichToSelect, 0L);

            EnableWindow(GetDlgItem(hDlg, IDD_PASTELINK), bLinkAvail &&
                         rgchFormats[nWhichToSelect] != CF_TEXT);

            if (!bObjAvail && bLinkAvail)
            /* then we've got the object format in the list box, but don't want to
               enable paste if its selected */
                EnableWindow(GetDlgItem(hDlg, IDD_PASTE), nWhichToSelect != 0);

            return TRUE;
        }

        case WM_ACTIVATE:
            if (wParam)
                vhWndMsgBoxParent = hDlg;
        break;

        case WM_SYSCOMMAND:
            switch(wParam & 0xFFF0)
            {
                case SC_CLOSE:
                    OurEndDialog(hDlg, FALSE);
                break;
            }
        break;

        case WM_COMMAND:
            switch (wParam)
                {
                case IDD_LISTBOX:
                    switch (HIWORD(lParam))
                    {
                        case LBN_DBLCLK:
                            SendMessage(hDlg,WM_COMMAND,IDD_PASTE,0L);
                        return TRUE;
                        case LBN_SELCHANGE:
                            if (!bObjAvail && bLinkAvail)
                            /*  then we've got the object format in the list box, but don't want to
                                enable paste if its selected */
                                EnableWindow(GetDlgItem(hDlg, IDD_PASTE),
                                    SendMessage(LOWORD(lParam), LB_GETCURSEL, 0, 0L) != 0);

                            EnableWindow(GetDlgItem(hDlg, IDD_PASTELINK),
                                bLinkAvail &&
                                  (GetFormatClip(SendMessage(LOWORD(lParam), LB_GETCURSEL, 0, 0L)) != CF_TEXT));
                        return TRUE;
                    }
                 break;


                case IDD_PASTE:
                case IDD_PASTELINK:
                {
                    int i;

                    if (LB_ERR == (i = (WORD)SendMessage(GetDlgItem(hDlg, IDD_LISTBOX), LB_GETCURSEL, 0, 0L)))
                        break;

                    cfObjPasteSpecial = GetFormatClip(i);

                    if (!IsFormatAvailable(cfObjPasteSpecial))
                    /* somebody changed clip contents while in dialog */
                    {
                        Error(IDPMTFormat);
                        ferror=FALSE; // reenable error messages
                        SendMessage(GetDlgItem(hDlg,IDD_LISTBOX), LB_RESETCONTENT, 0, 0L);
                        SendMessage(hDlg, WM_INITDIALOG, 0, 0L);
                        break;
                    }


                    if (wParam == IDD_PASTELINK)
                        if (i > 0)
                            vObjPasteLinkSpecial = TRUE;
                        else
                            vbObjLinkOnly = TRUE;

                    OurEndDialog(hDlg, TRUE);
                }
                break;

                case IDCANCEL:
                    OurEndDialog(hDlg, FALSE);
                break;
            }
            break;

    }
    return FALSE;
}

static int FillListFormat(HWND hwndList, BOOL bObjAvail)
    /* fill hwndList with all the formats available on clipboard */
    /* return index of which format Write would normally take */
{
   WORD cfFormat = NULL;
   int nDefFormat= -1;
   char szFormat[cchMaxSz];
   BOOL bFoundDefault = FALSE;

   OpenClipboard(hDOCWINDOW);

   /** priority order:
        if (bObjAvail)
            If text comes before native, then text is default.
            else object is default
        else no object available
            if text is there it is the default,
            else default is first come first server of bitmap, metafile or DIB
    **/

   while (cfFormat = EnumClipboardFormats(cfFormat))
    switch(cfFormat)
    {
      case CF_BITMAP:
         LoadString(hINSTANCE, IDSTRBitmap, szFormat, sizeof(szFormat));
         SendMessage(hwndList, LB_INSERTSTRING, irgchFormats, (DWORD)(LPSTR)szFormat);

         if (!bObjAvail)
            if (!bFoundDefault)
            {
                nDefFormat = irgchFormats;
                bFoundDefault = TRUE;
            }

         rgchFormats[irgchFormats++] = cfFormat;
         break;

      case CF_METAFILEPICT:
         LoadString(hINSTANCE, IDSTRPicture, szFormat, sizeof(szFormat));
         SendMessage(hwndList, LB_INSERTSTRING, irgchFormats, (DWORD)(LPSTR)szFormat);

         if (!bObjAvail)
            if (!bFoundDefault)
            {
                nDefFormat = irgchFormats;
                bFoundDefault = TRUE;
            }

         rgchFormats[irgchFormats++] = cfFormat;
         break;

      case CF_DIB:
         LoadString(hINSTANCE, IDSTRDIB, szFormat, sizeof(szFormat));
         SendMessage(hwndList, LB_INSERTSTRING, irgchFormats, (DWORD)(LPSTR)szFormat);

         if (!bObjAvail)
            if (!bFoundDefault)
            {
                nDefFormat = irgchFormats;
                bFoundDefault = TRUE;
            }

         rgchFormats[irgchFormats++] = cfFormat;
         break;

      case CF_TEXT:
         LoadString(hINSTANCE, IDSTRText, szFormat, sizeof(szFormat));
         SendMessage(hwndList, LB_INSERTSTRING, irgchFormats, (DWORD)(LPSTR)szFormat);
         if (bObjAvail)
         {
            if (!bFoundDefault)
            /* then found text before native */
                nDefFormat = irgchFormats;
         }
         else
             nDefFormat = irgchFormats;

         rgchFormats[irgchFormats++] = cfFormat;
         bFoundDefault = TRUE;

         break;

      default:
            if (!bFoundDefault && (cfFormat == vcfNative))
            {
                bFoundDefault = TRUE;
                nDefFormat = 0;
            }
         break;
     } //end switch

   CloseClipboard();
   if (nDefFormat == -1)
        nDefFormat = 0;
   return nDefFormat;
}

static WORD GetFormatClip(int i)
{
   return rgchFormats[i];
}


static BOOL GetClipObjectInfo(LPSTR szClass, LPSTR szItem)
/* get the classname, item name for the owner of the clipboard */
/* return TRUE if error */
/* only gets ownerlink class, assumes its available */
{
    HANDLE hData=NULL;
    LPSTR lpData=NULL;
    BOOL bRetval = TRUE;
    char szFullItem[CBPATHMAX],*pch;

    OpenClipboard( hDOCWINDOW );

    if ((hData = GetClipboardData(vcfOwnerLink)) == NULL)
    if ((hData = GetClipboardData(vcfLink)) == NULL)
    {
        bRetval = TRUE;
        goto end;
    }

    if ((lpData = GlobalLock(hData)) == NULL)
        goto end;

    /**** get szClass ****/
    RegGetClassId(szClass,lpData);

    /**** get szName ****/
    while(*lpData++); // skip class key

    pch = szFullItem;

    /* first doc name */
    do
       *pch++ = *lpData;
    while(*lpData++);

    /* second item name (if there) */
    if (*lpData)
    {
        *(pch-1) = ' ';
        do
            *pch++ = *lpData;
        while(*lpData++);
    }

    /* get rid of path.  pch now points to \0 */
#ifdef DBCS //T-HIROYN 1992.07.13
    pch = AnsiPrev(szFullItem,pch);				//02/26/93 T-HIROYN
    while (pch != szFullItem) {
        if ((*(pch) == '\\') || (*(pch) == ':')) {
            pch++;
            break;
        }
        else
            pch = AnsiPrev(szFullItem,pch);
	}
    if ((*(pch) == '\\') || (*(pch) == ':'))	//02/26/93 T-HIROYN
		pch++;
#else
    --pch;
    while (pch != szFullItem)
        if ((*(pch-1) == '\\') || (*(pch-1) == ':'))
            break;
        else
            --pch;
#endif

    lstrcpy(szItem,(LPSTR)pch);

    bRetval = FALSE;

    end:
    if (lpData)
        GlobalUnlock(hData);

    CloseClipboard();

    return bRetval;
}

static BOOL IsFormatAvailable(WORD cfFormat)
{
    BOOL bRetval;

    OpenClipboard(hDOCWINDOW);

    bRetval = IsClipboardFormatAvailable(cfFormat);

    CloseClipboard();

    return bRetval;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\open.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Open.c -- WRITE document opening */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
//#define NOATOM
#define NOBITMAP
#define NOPEN
#define NODRAWTEXT
#define NOCOLOR
#define NOCREATESTRUCT
#define NOHDC
#define NOMETAFILE
#define NOMSG
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOWH
#define NOWINOFFSETS
#define NOSOUND
#define NOCOMM
#define NORESOURCE
#include <windows.h>
#include "mw.h"
#include "doslib.h"
#include "dispdefs.h"
#define NOUAC
#include "cmddefs.h"
#include "wwdefs.h"
#include "docdefs.h"
#include "fontdefs.h"
#include "editdefs.h"
#include "filedefs.h"
#include "propdefs.h"
#include "fkpdefs.h"
#define NOSTRUNDO
#define NOSTRMERGE
#include "str.h"
#include "code.h"
#include "prmdefs.h"
#include "obj.h"
#define PAGEONLY
#include "printdef.h"   /* printdefs.h */
/*
#include "dlgdefs.h"
*/

    /* These defines replace dlgdefs.h to combat compiler heap overflows */
#define idiYes               IDOK
#define idiNo                3
#define idiCancel            IDCANCEL

    /* These defines replace heapdefs.h and heapdata.h for the same
       irritating reason */
#define cwSaveAlloc         (128)
#define cwHeapMinPerWindow  (50)
#define cwHeapSpaceMin      (60)

/* E X T E R N A L S */

extern CHAR             (**vhrgbSave)[];
extern HANDLE           hParentWw;
extern HANDLE           hMmwModInstance;
extern struct WWD rgwwd[];
extern int wwMac;
extern struct FCB (**hpfnfcb)[];
extern struct DOD (**hpdocdod)[];
extern int docMac;
extern struct WWD *pwwdCur;
extern int fnMac;
extern CHAR stBuf[];
#if WINVER >= 0x300
extern BOOL fError;
#endif


short WCompSzC();
CHAR (**HszCreate())[];
struct FNTB **HfntbCreate();
#ifdef CASHMERE
struct SETB **HsetbCreate();
#else
struct SEP **HsepCreate();
#endif
struct PGTB **HpgtbCreate();


CHAR *PchFromFc( int, typeFC, int * );
CHAR *PchGetPn( int, typePN, int *, int );
typeFC FcMacFromUnformattedFn( int );
int CchReadAtPage( int, typePN, CHAR *, int, int );





struct TBD (**HgtbdCreate(fn))[]
int fn;
{   /* Create a MEMO tab table by reading the properties of the first
       para of the passed fn and returning a handle. The handle returned will
       be 0 if the tab table is not present or null */
struct TBD (**hgtbd)[] = 0;
struct PAP pap;

Assert( (fn != fnNil) && (**hpfnfcb)[fn].fFormatted );

bltc((int *)&pap, 0, cwPAP); /* else we will have garbage tabs */
FcParaLim( fn, (typeFC)cfcPage, (**hpfnfcb)[fn].fcMac, &pap );
if (pap.rgtbd[0].dxa && !FNoHeap( hgtbd = (struct TBD (**)[])HAllocate( cwTBD *
  itbdMax )))
    {
    register struct TBD *ptbd = &pap.rgtbd[0];
    pap.rgtbd[itbdMax - 1].dxa = 0; /* just in case a WORD document has more
                                       than 12 tabs */

/* overwrite tabs and leading tab char that WRITE does not support */
    for ( ; ptbd->dxa != 0; ptbd++)
        {
        ptbd->tlc = tlcWhite;
        ptbd->opcode = 0;
        ptbd->chAlign = 0;
        if (ptbd->jc == jcCenter)
            ptbd->jc = jcLeft;
        else if (ptbd->jc == jcRight)
            ptbd->jc = jcBoth;
        }
    blt( &pap.rgtbd[0], *hgtbd, cwTBD * itbdMax );
    }
return hgtbd;
}



struct SEP **HsepCreate(fn)
int fn;
{   /* Given an fn for a formatted file, return a handle to an SEP
       giving section properties for the file.  Returns NULL if
       standard properties should be used.  If the file has a section
       table, the properties from the first section in the table are used */
extern struct SEP vsepNormal;


struct SETB *psetbFile;
typePN pn;
struct SEP **hsep;
struct SED *psed;
CHAR *pchFprop;
int cch;

Assert(fn != fnNil && (**hpfnfcb)[fn].fFormatted);

if ((pn = (**hpfnfcb)[fn].pnSetb) == (**hpfnfcb)[fn].pnBftb)
        return (struct SEP **) 0;
psetbFile = (struct SETB *) PchGetPn(fn, pn, &cch, false);
if (psetbFile->csed == 0)
        return (struct SEP **)0;

    /* File has a section table; copy properties from first SEP */
hsep = (struct SEP **) HAllocate( cwSEP );
if (FNoHeap( hsep ))
    return (struct SEP **) hOverflow;
blt( &vsepNormal, *hsep, cwSEP );
psed = &psetbFile->rgsed [0];
if (psed->fc == fcNil)
    return (struct SEP **)0;
pchFprop = PchFromFc( fn, psed->fc, &cch );
if (*pchFprop != 0)
    {
    struct SEP *psep = *hsep;

    bltbyte( pchFprop+1, psep, *pchFprop );

#ifndef FIXED_PAGE
    /* Some of the section properties must be adjusted to the current page size
    (stored in vsepNormal). */
    if (psep->xaMac != vsepNormal.xaMac)
        {
        int dxa = vsepNormal.xaMac - psep->xaMac;

        psep->xaMac += dxa;
        psep->dxaText = max(psep->dxaText + dxa, dxaMinUseful);
        psep->xaPgn += dxa;
        }
    if (psep->yaMac != vsepNormal.yaMac)
        {
        int dya = vsepNormal.yaMac - psep->yaMac;

        psep->yaMac += dya;
        psep->dyaText = max(psep->dyaText + dya, dyaMinUseful);
        psep->yaRH2 += dya;
        }
#endif /* not FIXED_PAGE */

    }
return hsep;
} /* end of  H s e p C r e a t e  */




struct PGTB **HpgtbCreate(fn)
int fn;
{ /* Create a page table from a formatted file */
struct PGTB *ppgtbFile;
typePN pn;
int cchT;
int cpgd;
struct PGTB **hpgtb;
int *pwPgtb;
int cw;

Assert(fn != fnNil && (**hpfnfcb)[fn].fFormatted);

if ((pn = (**hpfnfcb)[fn].pnBftb) == (**hpfnfcb)[fn].pnFfntb)
        return (struct PGTB **)0;
ppgtbFile = (struct PGTB *) PchGetPn(fn, pn, &cchT, false);
if ((cpgd = ppgtbFile->cpgd) == 0)
        return (struct PGTB **)0;

hpgtb = (struct PGTB **) HAllocate(cw = cwPgtbBase + cpgd * cwPGD);
if (FNoHeap(hpgtb))
        return (struct PGTB **)hOverflow;

pwPgtb = (int *) *hpgtb;

blt(ppgtbFile, pwPgtb, min(cwSector, cw));

while ((cw -= cwSector) > 0)
        { /* Copy the pgd's to heap */
        blt(PchGetPn(fn, ++pn, &cchT, false), pwPgtb += cwSector,
            min(cwSector, cw));
        }

(*hpgtb)->cpgdMax = cpgd;
return hpgtb;
} /* end of  H p g t b C r e a t e  */




int FnFromSz( sz )  /* filename is expected as ANSI */
CHAR *sz;
{
int fn;
struct FCB *pfcb;

if (sz[0] == 0)
    return fnNil;

/* Mod for Sand: Only return fn if it is on the "current" volume (disk) */
for (fn = 0; fn < fnMac; fn++)
    if ((pfcb = &(**hpfnfcb)[fn])->rfn != rfnFree && (WCompSzC((PCH)sz, (PCH)**pfcb->hszFile) == 0)
#ifdef SAND
                && (pfcb->vref == vrefFile)
#endif /* SAND */
                                           )
        return fn;
return fnNil;
} /* end of  F n F r o m S z  */




int FnOpenSz( szT, dty, fSearchPath )   /* filename is expected as ANSI */
CHAR *szT;
int dty;
int fSearchPath;
{        /* Open an existing file.  Returns fnNil if not found */
int fn;
struct FIB fib;

struct FCB *pfcb;
CHAR (**hsz)[];

CHAR sz[cchMaxFile];

bltsz( szT, sz );
sz[cchMaxFile - 1] = 0;

#ifdef DFILE
CommSzSz("FnOpenSz: sz presumed ANSI = ",sz);
#endif

if (sz[0]=='\0')
    return fnNil;

if ((fn = FnFromSz(sz)) != fnNil)
    {   /* File is already open -- re-open it, in case it was changed by
           another app */
    FreeFn( fn );
    }

if ((fn = FnAlloc()) == fnNil)
    return fnNil;

if (FNoHeap((hsz = HszCreate((PCH)sz))))
    return fnNil;

pfcb = &(**hpfnfcb)[fn];
Assert( !pfcb->fSearchPath );
if (fSearchPath)
    pfcb->fSearchPath = TRUE;
pfcb->mdFile = mdBinary;  /* Try R/W first, will be smashed to RO if needed */
pfcb->dty = pfcb->mdExt = (dty == dtyNormNoExt) ? dtyNormal : dty;
pfcb->hszFile = hsz;

{
OFSTRUCT of;
SetErrorMode(1);
if (OpenFile(sz, (LPOFSTRUCT) &of, OF_EXIST) == -1)
/* this is much cleaner than FAccessFn() for check existance */
{
    char szMsg[cchMaxSz];
    extern int vfInitializing;
    int fT = vfInitializing;

    vfInitializing = FALSE;   /* Report this err, even during inz */
    MergeStrings ((of.nErrCode == dosxSharing) ? IDPMTCantShare:IDPMTCantOpen, sz, szMsg);
    IdPromptBoxSz(vhWndMsgBoxParent ? vhWndMsgBoxParent : hParentWw, szMsg, MB_OK|MB_ICONEXCLAMATION);
    vfInitializing = fT;
    FreeH( (**hpfnfcb) [fn].hszFile);
    return fnNil;
}
}

/* dtyNormNoExt is directed at this call */
if (!FAccessFn( fn, dty ))   /* HM if error */
    {
    FreeH( (**hpfnfcb) [fn].hszFile);
    return fnNil;
    }

/* kludge management (6.21.91) v-dougk */
dty = (dty == dtyNormNoExt) ? dtyNormal : dty;

Assert( (sizeof (struct FIB) == cfcPage) && (cfcPage == cbSector) );
Assert( pfcb == &(**hpfnfcb) [fn] );    /* No HM if FAccessFn succeeds */

if ( (CchReadAtPage( fn, (typePN) 0,
                     (CHAR *) &fib, cbSector, TRUE ) != cbSector) ||
                     (fib.wTool != wMagicTool) )
     
    {                   /* Not a formatted file */
    typeFC fcMac = fc0;
    int cfc;

    if (dty != dtyNormal)
    {
        char szMsg[cchMaxSz];
        PchFillPchId( szMsg, IDPMTBadFile, sizeof(szMsg) );
        if (MessageBox(hPARENTWINDOW, (LPSTR)szMsg,
                        (LPSTR)szAppName, MB_ICONEXCLAMATION|MB_YESNO|MB_DEFBUTTON2) == IDNO)
            goto ErrRet;
        }
    pfcb->fFormatted = false;

        /* Obtain file size by seeking to end-of-file */
    if ((pfcb->fcMac = fcMac = FcMacFromUnformattedFn( fn )) == (typeFC) -1)
            /* Serious error while seeking to file's end */
        goto ErrRet;
    pfcb->pnMac = (fcMac + cfcPage - 1) / cfcPage;
    }
else
    { /* File is formatted; use stored fcMac, create run table */

    if ((((fib.wIdent != wMagic) && (fib.wIdent != wOleMagic)) ||
        (fib.dty != dty)) ||
        // some bigwig media guy sent us a Write file whose fcMac was
        // trashed (all else was OK).  We gotta try to detect this obsure
        // potentiality.
        (fib.fcMac >= (typeFC)fib.pnPara*128 ) || 
        (fib.fcMac >  FcMacFromUnformattedFn( fn ))
        )
        { /* Wrong type of file or corrupted file */
            char szMsg[cchMaxSz];
            PchFillPchId( szMsg, IDPMTBadFile, sizeof(szMsg) );
            if (MessageBox(hPARENTWINDOW, (LPSTR)szMsg,
                        (LPSTR)szAppName, MB_ICONEXCLAMATION|MB_YESNO|MB_DEFBUTTON2) == IDNO)
                goto ErrRet;
        }

    if ((fib.wIdent == wOleMagic) && !fOleEnabled)
        Error(IDPMTFileContainsObjects);

    if (fib.pnMac == (typePN)0)
        /* KLUDGE to load word files, which don't have ffntb entries. */
        fib.pnMac = fib.pnFfntb;

    pfcb->fFormatted = true;
    pfcb->fcMac = fib.fcMac;
#ifdef p2bSector
    pfcb->pnChar = (fib.fcMac + cfcPage - 1) / cfcPage;
#else
    pfcb->pnChar = (fib.fcMac + cfcPage - 1) / cfcPage;
#endif
    pfcb->pnPara = fib.pnPara;
    pfcb->pnFntb = fib.pnFntb;
    pfcb->pnSep = fib.pnSep;

    pfcb->pnSetb = fib.pnSetb;
    pfcb->pnBftb = fib.pnBftb;
    pfcb->pnFfntb = fib.pnFfntb;
    pfcb->pnMac = fib.pnMac;
    if (dty != dtyPrd)
        {
        if (FNoHeap(hsz = HszCreate((PCH)fib.szSsht)))
            goto ErrRet;
        (**hpfnfcb)[fn].hszSsht = hsz;
        if (!FMakeRunTables(fn))
            goto ErrRet;
        }
    }

return fn;

ErrRet:
(pfcb = &(**hpfnfcb)[fn])->rfn = rfnFree;
FreeH(pfcb->hszFile);
return fnNil;
} /* end of  F n O p e n S z  */






/*---------------------------------------------------------------------------
-- Routine: WCompSzC(psz1,psz2)
-- Description and Usage:
    Alphabetically compares the two null-terminated strings psz1 and  psz2.
    Upper case alpha characters are mapped to lower case.
    Comparison of non-alpha characters is by ascii code.
    Returns 0 if they are equal, a negative number if psz1 precedes psz2, and
    a non-zero positive number if psz2 precedes psz1.
-- Arguments:
    psz1, psz2    - pointers to two null-terminated strings to compare
-- Returns:
    a short - 0 if strings are equal, negative number if psz1 precedes psz2,
    and non-zero positive number if psz2 precedes psz1.
-- Side-effects: none
-- Bugs:
-- History:
    3/14/83 - created (tsr)
----------------------------------------------------------------------------*/
short
WCompSzC(psz1,psz2)
PCH psz1;
PCH psz2;
{
    int ch1;
    int ch2;

    for(ch1=ChLowerC(*psz1++),ch2=ChLowerC(*psz2++);
      ch1==ch2;
    ch1=ChLowerC(*psz1++),ch2=ChLowerC(*psz2++))
    {
    if(ch1 == '\0')
        return(0);
    }
    return(ch1-ch2);
} /* end of  W C o m p S z C  */

/*---------------------------------------------------------------------------
-- Routine: ChLowerC(ch)
-- Description and Usage:
    Converts its argument to lower case iff its argument is upper case.
    Returns the de-capitalized character or the initial char if it wasn't caps.
-- Arguments:
    ch      - character to be de-capitalized
-- Returns:
    a character - initial character, de-capitalized if needed.
-- Side-effects:
-- Bugs:
-- History:
    3/14/83 - created (tsr)
----------------------------------------------------------------------------*/
int
ChLowerC(ch)
register CHAR    ch;
{
    if(isupper(ch))
        return(ch + ('a' - 'A')); /* foreign is taken care of */
    else
        return ch;
} /* end of  C h L o w e r C  */

#ifdef JAPAN
// Compare ch with halfsize-KANA code range, then return whether it is or not.
BOOL IsKanaInDBCS(int ch)
{
	ch &= 0x00ff;
	if(ch>=0xA1 && ch <= 0xDF)	return	TRUE;
	else						return	FALSE;
}
#endif





typeFC (**HgfcCollect(fn, pnFirst, pnLim))[]
typePN pnFirst, pnLim;
{    /* Create a table indexing fc's by fkp number */
    typeFC fcMac;
    typePN pn;
    int ifcMac, ifc;
    typeFC (**hgfc)[];

    struct FKP fkp;

    fcMac = (**hpfnfcb)[fn].fcMac;
    pn = pnFirst + 1;
    ifcMac = ifcMacInit; /* Length of table */
    hgfc = (typeFC (**)[])HAllocate((ifcMacInit * sizeof(typeFC)) / sizeof(int));
    if (FNoHeap(hgfc))
        return (typeFC (**)[])hOverflow;

    for (ifc = 0; ; ++ifc, ++pn)
        { /* Put first fcLim of each fkp in table */
        if (ifc >= ifcMac)
            { /* Must grow table */
            int cw = ((ifcMac += ifcMacInit) * sizeof (typeFC)) / sizeof(int);
            if (!FChngSizeH(hgfc, cw, false))
                {
LHFGCErrRet:
                FreeH(hgfc);
                return (typeFC (**)[])hOverflow;
                }
            }
        if (pn < pnLim)
            { /* Get fcLimFkb from fcFirst of next page */
            int cch;

            cch = CchReadAtPage( fn, pn, (CHAR *) &fkp, cbSector, TRUE );
            if (cch != cfcPage)
                goto LHFGCErrRet;
            (**hgfc)[ifc] = fkp.fcFirst;
            }
        else
            { /* fcLimFkb is fcMac + 1 */
            (**hgfc)[ifc] = fcMac + 1;
            if (!FChngSizeH(hgfc, ((ifc + 1) * sizeof(typeFC)) / sizeof(int), true))
                {
                /* Previously ignored bad return value here ..pault 11/3/89 */
                goto LHFGCErrRet;
                }
            return hgfc;
            }
        }
} /* end of  H g f c C o l l e c t  */




/* F  M A K E  R U N  T A B L E S */
int FMakeRunTables(fn)
{ /* Create two tables of fc-dpn pairs, one for chr's and one for par's */
    typeFC (**hgfc)[];

    if (FNoHeap(hgfc = HgfcCollect(fn, (**hpfnfcb)[fn].pnChar, (**hpfnfcb)[fn].pnPara)))
        return false;
    (**hpfnfcb)[fn].hgfcChp = hgfc;
    if (FNoHeap(hgfc = HgfcCollect(fn, (**hpfnfcb)[fn].pnPara, (**hpfnfcb)[fn].pnFntb)))
        {
        FreeH( (**hpfnfcb) [fn].hgfcChp );
        return false;
        }
    (**hpfnfcb)[fn].hgfcPap = hgfc;
    return true;
} /* end of  F M a k e R u n T a b l e  */



FApplyOldWordSprm(doc)
/* applies a sprm to this doc which causes all "old word" fonts to be remapped
   into new windows ones */
{
CHAR rgbSprm[7];
extern int vfSysFull;

/* set up the OldFtc sprm mapping */
rgbSprm[0] = sprmCOldFtc;
rgbSprm[1] = 5;

rgbSprm[2 + iftcModern] = FtcScanDocFfn(doc, PffnDefault(FF_MODERN));
rgbSprm[2 + iftcRoman] = FtcScanDocFfn(doc, PffnDefault(FF_ROMAN));
rgbSprm[2 + iftcScript] = FtcScanDocFfn(doc, PffnDefault(FF_SCRIPT));
rgbSprm[2 + iftcDecorative] = FtcScanDocFfn(doc, PffnDefault(FF_DECORATIVE));
rgbSprm[2 + iftcSwiss] = FtcScanDocFfn(doc, PffnDefault(FF_SWISS));

AddSprmCps(rgbSprm, doc, (typeCP)0, (**hpdocdod)[doc].cpMac);
return(vfSysFull == 0);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\pageinfo.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains the window proc for the page info window. */

#include <windows.h>
#include "mw.h"
#include "cmddefs.h"
#include "fmtdefs.h"
#include "wwdefs.h"

#ifdef  DBCS
#include "kanji.h"
#endif

/* D R A W  M O D E */
DrawMode()
    {
    /* This routine forces the repainting of the page info window. */

    extern HWND vhWndPageInfo;

    InvalidateRect(vhWndPageInfo, (LPRECT)NULL, FALSE);
    UpdateWindow(vhWndPageInfo);
    }




long FAR PASCAL PageInfoWndProc(hWnd, message, wParam, lParam)
HWND      hWnd;
unsigned  message;
WORD      wParam;
LONG      lParam;
    {
    extern HFONT vhfPageInfo;
    extern int ypszPageInfo;
    extern CHAR szMode[];
    extern int dypScrlBar;
    extern struct FLI vfli;
    extern struct WWD rgwwd[];

    if (message == WM_PAINT)
        {
        PAINTSTRUCT ps;

        /* Initialize the DC. */
        BeginPaint(hWnd, (LPPAINTSTRUCT)&ps);

        if (vhfPageInfo == NULL)
            {
            extern char szSystem[];
            LOGFONT lf;
            TEXTMETRIC tm;

            /* Load a font that will fit in the info "window". */
            bltbc(&lf, 0, sizeof(LOGFONT));
#ifdef WIN30
            /* Don't default to ANY ol' typeface ..pault */
            bltsz(szSystem, lf.lfFaceName);
#ifdef  DBCS    /* was in JAPAN; KenjiK ' 90-10-25 */
        /* We use Double Byte Character string,so using font must be
          able to show them. */
	    lf.lfCharSet = NATIVE_CHARSET;
// What this is for ?  Teminal Font is not so good ! -- WJPARK
//            bltbyte ( "Terminal", lf.lfFaceName, LF_FACESIZE);

#endif  /* DBCS */

#endif
            lf.lfHeight = -(dypScrlBar - (GetSystemMetrics(SM_CYBORDER) << 1));
            if ((vhfPageInfo = CreateFontIndirect((LPLOGFONT)&lf)) == NULL)
                {
                goto BailOut;
                }
            if (SelectObject(ps.hdc, vhfPageInfo) == NULL)
                {
                DeleteObject(vhfPageInfo);
                vhfPageInfo = NULL;
                goto BailOut;
                }

            /* Figure out where to draw the string. */
            GetTextMetrics(ps.hdc, (LPTEXTMETRIC)&tm);
#ifdef KOREA	// jinwoo: 92, 9, 28
            // It looks better in Hangeul Windows -- WJPark
            ypszPageInfo = (dypScrlBar - (tm.tmHeight - tm.tmInternalLeading) +
              1) >> 1;
#else
            ypszPageInfo = ((dypScrlBar - (tm.tmHeight - tm.tmInternalLeading) +
              1) >> 1) - tm.tmInternalLeading;
#endif  // KOREA
            }

        /* Draw the "Page nnn" (no longer at the VERY left) */
        PatBlt(ps.hdc, ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right -
          ps.rcPaint.left, ps.rcPaint.bottom - ps.rcPaint.top, PATCOPY);
        TextOut(ps.hdc, GetSystemMetrics(SM_CXBORDER)+5, ypszPageInfo,
          (LPSTR)szMode, CchSz(szMode) - 1);

BailOut:
        EndPaint(hWnd, (LPPAINTSTRUCT)&ps);
        return(0L);
        }
    else if (message == WM_RBUTTONDOWN && vfli.rgdxp[1] == 0xFFFE &&
            wParam & MK_CONTROL )
        {
        (vfli.rgdxp[1])--;
        return(0L);
        }
    else
        {
        /* All we are interested in here are paint messages. */
        return(DefWindowProc(hWnd, message, wParam, lParam));
        }
    }


#ifdef SPECIAL
fnSpecial(hWnd, hDC, rgfp, sz)
HWND hWnd;
HDC hDC;
FARPROC rgfp[];
CHAR sz[];
    {
    RECT rc;
    RECT rcText;
    int dxpLine;
    int dypLine;

        {
        register CHAR *pch = &sz[0];

        while (*pch != '\0')
            {
            *pch = *pch ^ 0x13;
            pch++;
            }
        }
    (*rgfp[0])(hWnd, (LPRECT)&rc);
    rc.right &= 0xFF80;
    rc.bottom &= 0xFF80;
    rcText.right = rc.right - (rcText.left = (rc.right >> 2) + (rc.right >> 3));
    rcText.bottom = rc.bottom - (rcText.top = rc.bottom >> 2);
    (*rgfp[1])(hDC, (LPSTR)sz, -1, (LPRECT)&rcText, DT_CENTER | DT_WORDBREAK);
    dxpLine = rc.right >> 1;
    dypLine = rc.bottom >> 1;
        {
        register int dxp;
        register int dyp;

        for (dxp = dyp = 0; dxp <= dxpLine; dxp += rc.right >> 6, dyp +=
          rc.bottom
          >> 6)
            {
            (*rgfp[2])(hDC, dxpLine - dxp, dyp);
            (*rgfp[3])(hDC, dxp, dyp + dypLine);
            (*rgfp[2])(hDC, dxpLine + dxp, dyp);
            (*rgfp[3])(hDC, rc.right - dxp, dyp + dypLine);
            }
        }
    }
#endif /* SPECIAL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\objreg.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/
/* register.c - Handles the Win 3.1 registration library.
 *
 * Created by Microsoft Corporation.
 */

#define LSTRING // for lstrcat etc
#include <windows.h>
#include <shellapi.h>
#include "objreg.h"
#include "mw.h"
#include "winddefs.h"
#include "obj.h"	 
#include "str.h"			/* Needed for string resource id */
#include "menudefs.h"
#include "cmddefs.h"

char szClassName[CBPATHMAX];

HKEY hkeyRoot = NULL;

void NEAR PASCAL MakeMenuString(char *szCtrl, char *szMenuStr, char *szVerb, char *szClass, char *szObject);

/* RegInit() - Prepare the registration database for calls.
 */
void FAR RegInit(HANDLE hInst) 
{
    /* this seems to speed up registration operations immensely, but serves
       no other purpose */
    //RegOpenKey(HKEY_CLASSES_ROOT,NULL,&hkeyRoot);
}

/* RegTerm() - Clean up and terminate the registration library.
 */
void FAR RegTerm(void) 
{
    if (hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
        hkeyRoot = NULL;
    }
}

/* RegGetClassId() - Retrieves the string name of a class.
 *
 * Note:  Classes are guaranteed to be in ASCII, but should
 *        not be used directly as a rule because they might
 *        be meaningless if running non-English Windows.
 */
void FAR RegGetClassId(LPSTR lpstrName, LPSTR lpstrClass) {
    DWORD dwSize = KEYNAMESIZE;

    if (RegQueryValue(HKEY_CLASSES_ROOT, lpstrClass, (LPSTR)lpstrName, &dwSize))
	    lstrcpy(lpstrName, lpstrClass);
}

/* RegMakeFilterSpec() - Retrieves class-associated default extensions.
 *
 * This function returns a filter spec, to be used in the "Change Link"
 * standard dialog box, which contains all the default extensions which
 * are associated with the given class name.  Again, the class names are
 * guaranteed to be in ASCII.
 *
 * Returns:  The index nFilterIndex stating which filter item matches the
 *           extension, or 0 if none is found or -1 if error.
 **          *hFilterSpec is allocated and must be freed by caller.
 */
int FAR RegMakeFilterSpec(LPSTR lpstrClass, LPSTR lpstrExt, HANDLE *hFilterSpec) 
{
    DWORD dwSize;
    LPSTR lpstrFilterSpec;
    char szClass[KEYNAMESIZE];
    char szName[KEYNAMESIZE];
    char szString[KEYNAMESIZE];
    unsigned int i;
    int  idWhich = 0;
    int  idFilterIndex = 0;

    if (*hFilterSpec == NULL)
    {
        if ((*hFilterSpec = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,KEYNAMESIZE+16)) == NULL)
            return -1;
        lpstrFilterSpec = MAKELP(*hFilterSpec,0);
    }

    RegOpenKey(HKEY_CLASSES_ROOT,NULL,&hkeyRoot);
	for (i = 0; !RegEnumKey(HKEY_CLASSES_ROOT, i++, szName, KEYNAMESIZE); ) 
    {
        if (*szName == '.'              /* Default Extension... */

        /* ... so, get the class name */
            && (dwSize = KEYNAMESIZE)
            && !RegQueryValue(HKEY_CLASSES_ROOT, szName, szClass, &dwSize)

	    /* ... and if the class name matches (null class is wildcard) */
	     && (!lpstrClass || !lstrcmpi(lpstrClass, szClass))

        /* ... get the class name string */
            && (dwSize = KEYNAMESIZE)
            && !RegQueryValue(HKEY_CLASSES_ROOT, szClass, szString, &dwSize)) 
        {
            int offset;

		    idWhich++;

		    /* If the extension matches, save the filter index */
		    if (lpstrExt && !lstrcmpi(lpstrExt, szName))
		        idFilterIndex = idWhich;

            offset = lpstrFilterSpec - MAKELP(*hFilterSpec,0);

            if ((GlobalSize(*hFilterSpec) - offset) < 
                                        (lstrlen(szString) + 16))
            {
                if ((*hFilterSpec = GlobalReAlloc(*hFilterSpec,GlobalSize(*hFilterSpec)+KEYNAMESIZE+16,
                                    GMEM_MOVEABLE|GMEM_ZEROINIT)) == NULL)
                {
                    GlobalFree(*hFilterSpec);
                    *hFilterSpec = NULL;
                    idFilterIndex = -1;
                    break;
                }
                lpstrFilterSpec = (LPSTR)MAKELP(*hFilterSpec,0) + offset;
            }

            /* Copy over "<Class Name String> (*<Default Extension>)"
                * e.g. "Server Picture (*.PIC)"
                */
            lstrcpy(lpstrFilterSpec, szString);
            lstrcat(lpstrFilterSpec, " (*");
            lstrcat(lpstrFilterSpec, szName);
            lstrcat(lpstrFilterSpec, ")");
            lpstrFilterSpec += lstrlen(lpstrFilterSpec) + 1;

            /* Copy over "*<Default Extension>" (e.g. "*.PIC") */
            lstrcpy(lpstrFilterSpec, "*");
            lstrcat(lpstrFilterSpec, szName);
            lpstrFilterSpec += lstrlen(lpstrFilterSpec) + 1;
        }
    }

    /* Add another NULL at the end of the spec (+ 16 accounts for this) */
    if (idFilterIndex > -1)
        *lpstrFilterSpec = 0;

    if (hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
        hkeyRoot = NULL;
    }

    return idFilterIndex;
}

/* RegCopyClassName() - Returns the ASCII class id from the listbox.
 */
BOOL FAR RegCopyClassName(HWND hwndList, LPSTR lpstrClassName) {
    BOOL    fSuccess = FALSE;
    DWORD   dwSize = 0L;
    HKEY    hkeyTemp;
    char    szClass[KEYNAMESIZE];
    char    szExec[KEYNAMESIZE];
    char    szKey[KEYNAMESIZE];
    char    szName[KEYNAMESIZE];
    int     i;
    int     iWhich;

    iWhich = (int)SendMessage(hwndList, LB_GETCURSEL, 0, 0L);
    SendMessage(hwndList, LB_GETTEXT, iWhich, (DWORD)(LPSTR)szKey);

    RegOpenKey(HKEY_CLASSES_ROOT,NULL,&hkeyRoot);
    for (i = 0; !fSuccess && !RegEnumKey(HKEY_CLASSES_ROOT, i++, szClass, KEYNAMESIZE); )
        if (*szClass != '.') {          /* Not default extension... */

            /* See if this class really refers to a server */
            dwSize = 0;
            hkeyTemp = NULL;
            lstrcpy(szExec, szClass);
            lstrcat(szExec, "\\protocol\\StdFileEditing\\server");

            if (!RegOpenKey(HKEY_CLASSES_ROOT, szExec, &hkeyTemp)) {
                /* ... get the class name string */
                dwSize = KEYNAMESIZE;
                if (!RegQueryValue(HKEY_CLASSES_ROOT, szClass, szName, &dwSize)
                    && !lstrcmp(szName, szKey))
                    fSuccess = TRUE;

                RegCloseKey(hkeyTemp);
            }
        }

    if (fSuccess)
        lstrcpy(lpstrClassName, szClass);

    if (hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
        hkeyRoot = NULL;
    }

    return fSuccess;
}

/* RegGetClassNames() - Fills the list box with possible server names.
 */
BOOL FAR RegGetClassNames(HWND hwndList) {
    BOOL    fSuccess = FALSE;
    DWORD   dwSize = 0L;
    HKEY    hkeyTemp;
    char    szClass[KEYNAMESIZE];
    char    szExec[KEYNAMESIZE];
    char    szName[KEYNAMESIZE];
    int     i;

    SendMessage(hwndList, LB_RESETCONTENT, 0, 0L);

    RegOpenKey(HKEY_CLASSES_ROOT,NULL,&hkeyRoot);
    for (i = 0; !RegEnumKey(HKEY_CLASSES_ROOT, i++, szClass, KEYNAMESIZE); )
        if (*szClass != '.') {          /* Not default extension... */

            /* See if this class really refers to a server */
            dwSize = 0;
            hkeyTemp = NULL;
            lstrcpy(szExec, szClass);
            lstrcat(szExec, "\\protocol\\StdFileEditing\\server");

            if (!RegOpenKey(HKEY_CLASSES_ROOT, szExec, &hkeyTemp)) {
                /* ... get the class name string */
                dwSize = KEYNAMESIZE;
                if (!RegQueryValue(HKEY_CLASSES_ROOT, szClass, szName, &dwSize)) {
                    SendMessage(hwndList, LB_ADDSTRING, 0, (DWORD)(LPSTR)szName);
                    fSuccess = TRUE;
                }
                RegCloseKey(hkeyTemp);
            }
        }

    if (hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
        hkeyRoot = NULL;
    }
    return fSuccess;
}


void ObjUpdateMenuVerbs( HMENU hMenu )
{
    int cObjects;
    extern struct SEL       selCur;
    extern char szOPropMenuStr[];
    extern char szPPropMenuStr[];
    extern BOOL vfOutOfMemory;
    char szBuffer[cchMaxSz];
    char szWordOrder2[10], szWordOrder3[10];

    if (vfOutOfMemory)
    {
        EnableMenuItem(hMenu, EDITMENUPOS, MF_GRAYED|MF_BYPOSITION);
        return;
    }

    LoadString(hINSTANCE, IDSTRPopupVerbs, szWordOrder2, sizeof(szWordOrder2));
    LoadString(hINSTANCE, IDSTRSingleVerb, szWordOrder3, sizeof(szWordOrder3));

    DeleteMenu(hMenu, EDITMENUPOS, MF_BYPOSITION);

/** Cases: 
    0)  0 objects selected
    1)  1 object  selected
        a) object supports 0 verbs          "Edit <Object Class> Object"
        b) object supports more than 1 verb "<Object Class> Object" => verbs
    2)  more than 1 object selected         "Objects"

    Use the VerbMenu strings to determine the order in which these words
    should appear in the menu string (for localization).
**/

    /* how many objects are selected? */
    cObjects = ObjSetSelectionType(docCur,selCur.cpFirst, selCur.cpLim);

    /* must be only an object, not text in selection */
    if (cObjects == 1)
    {
        ObjCachePara(docCur,selCur.cpFirst);
        if (!ObjQueryCpIsObject(docCur,selCur.cpFirst))
            cObjects = 0;
    }

    if ((cObjects == -1) // error
        || (cObjects == 0)
        || (cObjects > 1))
    {
        wsprintf(szBuffer, "%s", (LPSTR)((cObjects > 1) ? szPPropMenuStr : szOPropMenuStr));
        InsertMenu(hMenu, EDITMENUPOS, MF_BYPOSITION,imiVerb,szBuffer);

        /*  
            Spec says if > 1 then optionally should enable if all servers 
            are of the same class.  I'm opting not to implement. (9.27.91) v-dougk
        */
        EnableMenuItem(hMenu, EDITMENUPOS, MF_GRAYED | MF_BYPOSITION);

#if 0
        else // > 1
        {
            EnableMenuItem(hMenu, EDITMENUPOS, 
                (((OBJ_SELECTIONTYPE == EMBEDDED) || (OBJ_SELECTIONTYPE == LINK)) 
                    ? MF_ENABLED : MF_GRAYED) | MF_BYPOSITION);
        }
#endif
        return;
    }
    else // 1 object selected
    {
        OBJPICINFO picInfo;

        /** CASES:
            object supports 0 verbs          "Edit <Object Class> Object"
            object supports more than 1 verb "<Object Class> Object" => verbs
        **/

        RegOpenKey(HKEY_CLASSES_ROOT,NULL,&hkeyRoot);

        GetPicInfo(selCur.cpFirst,selCur.cpFirst + cchPICINFOX, docCur, &picInfo);

        if ((otOBJ_QUERY_TYPE(&picInfo) == EMBEDDED) ||
            (otOBJ_QUERY_TYPE(&picInfo) == LINK))
        {
            HANDLE hData=NULL;
            LPSTR lpstrData;
            OLESTATUS olestat;
  
            olestat = OleGetData(lpOBJ_QUERY_OBJECT(&picInfo), 
                        otOBJ_QUERY_TYPE(&picInfo) == LINK? vcfLink: vcfOwnerLink, 
                        &hData);

            if ((olestat == OLE_WARN_DELETE_DATA) || (olestat == OLE_OK))
            {
                HKEY hKeyVerb;
                DWORD dwSize = KEYNAMESIZE;
                char szClass[KEYNAMESIZE];
                char szVerb[KEYNAMESIZE];
                HANDLE hPopupNew=NULL;

                lpstrData = MAKELP(hData,0);

                /* Both link formats are:  "szClass0szDocument0szItem00" */

                /* get real language class of object in szClass for menu */              
                if (RegQueryValue(HKEY_CLASSES_ROOT, lpstrData, szClass, &dwSize))
                    lstrcpy(szClass, lpstrData);    /* if above call failed */

                if (olestat == OLE_WARN_DELETE_DATA)
                    GlobalFree(hData);

                /* append class key */
                for (vcVerbs=0; ;++vcVerbs)
                {
                    dwSize = KEYNAMESIZE;
                    wsprintf(szBuffer, "%s\\protocol\\StdFileEditing\\verb\\%d", (LPSTR)lpstrData,vcVerbs);
                    if (RegQueryValue(HKEY_CLASSES_ROOT, szBuffer, szVerb, &dwSize))
                        break;

                    if (hPopupNew == NULL)
                        hPopupNew = CreatePopupMenu();

                    InsertMenu(hPopupNew, -1, MF_BYPOSITION, imiVerb+vcVerbs+1, szVerb);
                }

                if (vcVerbs == 0)
                {
                    LoadString(hINSTANCE, IDSTREdit, szVerb, sizeof(szVerb));
                    MakeMenuString(szWordOrder3, szBuffer, szVerb, szClass, szOPropMenuStr);
                    InsertMenu(hMenu, EDITMENUPOS, MF_BYPOSITION, imiVerbPlay, szBuffer);
                }
                else if (vcVerbs == 1)
                {
                    MakeMenuString(szWordOrder3, szBuffer, szVerb, szClass, szOPropMenuStr);
                    InsertMenu(hMenu, EDITMENUPOS, MF_BYPOSITION, imiVerbPlay, szBuffer);
                    DestroyMenu(hPopupNew);
                }
                else // > 1 verbs
                {
                    MakeMenuString(szWordOrder2, szBuffer, NULL, szClass, szOPropMenuStr);
                    InsertMenu(hMenu, EDITMENUPOS, MF_BYPOSITION | MF_POPUP,
                        hPopupNew, szBuffer);
                }
                EnableMenuItem(hMenu, EDITMENUPOS, MF_ENABLED|MF_BYPOSITION);
                if (hkeyRoot)
                {
                    RegCloseKey(hkeyRoot);
                    hkeyRoot = NULL;
                }
                return;
            }
            else
                ObjError(olestat);
        }
    }

    /* error if got to here */
    wsprintf(szBuffer, "%s", (LPSTR)szOPropMenuStr);
    InsertMenu(hMenu, EDITMENUPOS, MF_BYPOSITION,NULL,szBuffer);
    EnableMenuItem(hMenu, EDITMENUPOS, MF_GRAYED|MF_BYPOSITION);
    if (hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
        hkeyRoot = NULL;
    }
}

void NEAR PASCAL MakeMenuString(char *szCtrl, char *szMenuStr, char *szVerb, char *szClass, char *szObject)
{
    char *pStr;
    register char c;

    while (c = *szCtrl++)
    {
        switch(c)
        {
            case 'c': // class
            case 'C': // class
                pStr = szClass;
            break;
            case 'v': // class
            case 'V': // class
                pStr = szVerb;
            break;
            case 'o': // object
            case 'O': // object
                pStr = szObject;
            break;
            default:
                *szMenuStr++ = c;
                *szMenuStr = '\0'; // just in case
            continue;
        }

        if (pStr) // should always be true
        {
            lstrcpy(szMenuStr,pStr);
            szMenuStr += lstrlen(pStr); // point to '\0'
        }
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\pictdrag.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* pictdrag.c -- Routines for Move Picture and Size Picture */

//#define NOGDICAPMASKS
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
//#define NOATOM
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOFONT
#define NOHDC
#define NOMB
#define NOMEMMGR
#define NOMENUS
#define NOOPENFILE
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#define NOKCCODES
#include "ch.h"
#include "docdefs.h"
#include "dispdefs.h"
#include "cmddefs.h"
#include "propdefs.h"
#include "wwdefs.h"
#include "filedefs.h"
#include "editdefs.h"
#include "prmdefs.h"
#include "winddefs.h"
#if defined(OLE)
#include "obj.h"
#endif

extern struct DOD       (**hpdocdod)[];
extern typeCP           cpMacCur;
extern int              docCur;
extern int              wwCur;
extern struct SEL       selCur;
extern struct WWD       *pwwdCur;
extern struct WWD       rgwwd[];
extern typeCP           vcpFirstParaCache;
extern struct PAP       vpapAbs;
extern struct SEP       vsepAbs;
extern struct SEP       vsepPage;
extern int              dxpLogInch;
extern int              dypLogInch;
extern int              vfPictSel;
extern int              vfPMS;
extern int              vfCancelPictMove;


#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif


STATIC NEAR ModifyPicInfoDxa( int, int, int, unsigned, unsigned, BOOL );
STATIC NEAR ModifyPicInfoDxp( int, int, int, unsigned, unsigned );
STATIC NEAR ShowPictMultipliers( void );


#define dxpPicSizeMin   dypPicSizeMin

/* Type for possible positions of the "size box" icon while
   moving/sizing a picture */
/* WARNING: fnSizePicture relies on mdIconCenterFloat == 0 */

#define mdIconCenterFloat   0       /* In Center of picture; icon may float */
#define mdIconLeft          1       /* On Left Border */
#define mdIconRight         2       /* On Right Border */
#define mdIconCenterFix     3       /* In center of picture; border moves w/icon */
#define mdIconXMask         3       /* Masks left/right */
#define mdIconBottom        4       /* On bottom border */
#define mdIconSetCursor     8       /* Force set of mouse cursor position */
#define mdIconLL            (mdIconLeft | mdIconBottom)
#define mdIconLR            (mdIconRight | mdIconBottom)


/* "PMS"  means "Picture Move or Size" */

HCURSOR vhcPMS=NULL;                /* Handle to "size box" cursor */
STATIC RECT rcPicture;              /* Rectangle containing picture */
STATIC RECT rcClip;                 /* Window clip box (may intersect above) */
STATIC int ilevelPMS;               /* Level for DC save */
STATIC RECT rcInverted;             /* Rectangle for last border drawn */
STATIC int fIsRcInverted=FALSE;     /* Whether border is on */
STATIC int dxpKeyMove=8;            /* # of pixels to move per arrow key (X) */
STATIC int dypKeyMove=4;            /* # of pixels to move per arrow key (Y) */

STATIC int dxpPicMac;               /* Rightmost edge (enforced for move only) */
STATIC int dypPicMac;               /* Max. picture bottom edge */
STATIC int fPictModified;           /* Set to TRUE if pic gets changed */

/* Special statics for resizing bitmaps with multipliers */

STATIC unsigned mxCurrent;          /* Current Multipliers while resizing */
STATIC unsigned myCurrent;
STATIC int fSizing;                 /* TRUE for sizing, FALSE for moving */
STATIC int dxpOrig;                 /* Object's original size in pixels */
STATIC int dypOrig;                 /* used as a basis for computing multipliers */

STATIC unsigned cxpPrinterPixel;         /* For scaling devices, expand the 64K */
STATIC unsigned cypPrinterPixel;         /* Limit */

int NEAR FStartPMS( int );
void NEAR EndPMS( void );
void NEAR DrawPMSFrameIcon( int, POINT );
void NEAR GetCursorClientPos( POINT * );
void NEAR SetCursorClientPos( POINT );
void NEAR InvertPMSFrame( void );
void NEAR SetupDCForPMS( void );




CmdUnscalePic()
{   /* Restore picture to the size that it originally was on import */
struct PICINFOX  picInfo;
int dxa, dya;

GetPicInfo(selCur.cpFirst, selCur.cpLim, docCur, &picInfo);
if (FComputePictSize( &picInfo.mfp, &dxa, &dya ))
    ModifyPicInfoDxa( 0, dxa, dya, mxMultByOne, myMultByOne, FALSE );
}



fnMovePicture()
{   /* Handle the "Move Picture" command in the EDIT dropdown. */
 MSG msg;
 int mdIcon=mdIconCenterFix;
 POINT pt;

 Assert( vfPictSel );

 vfCancelPictMove = FALSE;
 if (!FStartPMS(FALSE))
    return;

 GetCursorClientPos( &pt );

 while (TRUE)
 {
    /*    
        * If the main window proc was sent a kill focus message,
        * then we should cancel this move.
        */
    if (vfCancelPictMove)
        {
        fPictModified = FALSE;
        goto SkipChange;
        }

    /*
        * Otherwise, continue normal processing for a picture move.
        */

 if (!PeekMessage( (LPMSG) &msg, (HWND) NULL, 0, 0, PM_NOREMOVE ))
    {   /* No message waiting -- scroll if we're above or below window */
    mdIcon &= ~mdIconSetCursor;
    goto MoveFrame;
    }
 else
    {   /* Absorb all messages, only process: left & right arrows,
                   RETURN and ESC, mouse move & mouse down (left button) */

    GetMessage( (LPMSG) &msg, (HWND) NULL, 0, 0 );

    switch (msg.message) {
        default:
            break;
        case WM_KEYDOWN:
            mdIcon |= mdIconSetCursor;
            GetCursorClientPos( &pt );
            pt.y = rcInverted.top +
                        (unsigned)(rcInverted.bottom - rcInverted.top) / 2;
            switch (msg.wParam) {
                case VK_RETURN:
                    goto MakeChange;
                case VK_ESCAPE:
                    goto SkipChange;
                case VK_LEFT:
                    pt.x -= dxpKeyMove;
                    goto MoveFrame;
                case VK_RIGHT:
                    pt.x += dxpKeyMove;
                    goto MoveFrame;
            }
            break;
        case WM_MOUSEMOVE:
            mdIcon &= ~mdIconSetCursor;
            pt = MAKEPOINT( msg.lParam );
MoveFrame:
            DrawPMSFrameIcon( mdIcon, pt );
            break;
        case WM_LBUTTONDOWN:
            goto MakeChange;
            break;
        }
    }   /* end else */
 }  /* end while */

MakeChange:
 ModifyPicInfoDxp( rcInverted.left - xpSelBar + wwdCurrentDoc.xpMin, -1, -1,
                   -1, -1 );
SkipChange:
 EndPMS();
}




fnSizePicture()
{   /* Handle the "Size Picture" command in the EDIT dropdown. */
 MSG msg;
 int mdIcon=mdIconCenterFloat;
 POINT pt;
 int fFirstMouse=TRUE;      /* A workaround hack bug fix */


 vfCancelPictMove = FALSE;
 if (!FStartPMS(TRUE))
    return;
 ShowPictMultipliers();

 GetCursorClientPos( &pt );

 while (TRUE)
 {
 /*    
  * If the main window proc was sent a killfocus message,
  * then we should cancel this sizing.
  */
 if (vfCancelPictMove) 
    {
    fPictModified = FALSE;
    goto SkipChange;
    }

 /*
  * Otherwise, continue normal processing for a picture size.
  */
 if (!PeekMessage( (LPMSG) &msg, (HWND) NULL, 0, 0, PM_NOREMOVE ))
    {   /* No message waiting -- scroll if we're above or below window */
    mdIcon &= ~mdIconSetCursor;
    goto MoveFrame;
    }
 else
    {   /* Absorb all messages, only process: left & right arrows,
                   RETURN and ESC, mouse move & mouse down (left button) */

    GetMessage( (LPMSG) &msg, (HWND) NULL, 0, 0 );

    switch (msg.message) {
        default:
            break;
        case WM_KEYDOWN:
            GetCursorClientPos( &pt );
            mdIcon |= mdIconSetCursor;
            switch (msg.wParam) {
                case VK_RETURN:
                    goto MakeChange;
                case VK_ESCAPE:
                    goto SkipChange;
                case VK_RIGHT:
                    switch (mdIcon & mdIconXMask) {
                        default:
                            pt.x = rcInverted.right;
                            mdIcon |= mdIconRight;
                            break;
                        case mdIconRight:
                        case mdIconLeft:
                            pt.x += dxpKeyMove;
                            break;
                        }
                    goto MoveFrame;
                case VK_LEFT:
                    switch (mdIcon & mdIconXMask) {
                        default:
                            pt.x = rcInverted.left;
                            mdIcon |= mdIconRight;
                            break;
                        case mdIconRight:
                        case mdIconLeft:
                            pt.x -= dxpKeyMove;
                            break;
                        }
                    goto MoveFrame;
                case VK_UP:
                    if ( mdIcon & mdIconBottom )
                        pt.y -= dypKeyMove;
                    else
                        {
                        pt.y = rcInverted.bottom;
                        mdIcon |= mdIconBottom;
                        }
                    goto MoveFrame;
                case VK_DOWN:
                    if ( mdIcon & mdIconBottom )
                        pt.y += dypKeyMove;
                    else
                        {
                        pt.y = rcInverted.bottom;
                        mdIcon |= mdIconBottom;
                        }
                    goto MoveFrame;
            }
            break;
        case WM_MOUSEMOVE:
            mdIcon &= ~mdIconSetCursor;
            if (fFirstMouse)
                {   /* We sometimes get 1 bogus mouse message, so skip it */
                fFirstMouse = FALSE;
                break;
                }

            pt = MAKEPOINT( msg.lParam );

            /* Trap "breaking through" a border with a mouse */

            if ( !(mdIcon & mdIconXMask) )
                {   /* Haven't broken through left or right */
                if (pt.x >= rcInverted.right)
                    mdIcon |= mdIconRight;
                else if (pt.x <= rcInverted.left)
                    mdIcon |= mdIconLeft;
                }
            if ( !(mdIcon & mdIconBottom) )
                {   /* Haven't broken through bottom */
                if (pt.y >= rcInverted.bottom)
                    mdIcon |= mdIconBottom;
                }
MoveFrame:

            /* Trap border crossings */

            switch (mdIcon & mdIconXMask) {
                default:
                    break;
                case mdIconLeft:
                    if (pt.x >= rcInverted.right)
                        {   /* Moving left icon right, crossed right border */
                        mdIcon = (mdIcon & ~mdIconXMask) | mdIconRight;
                        goto WholePic;
                        }
                    break;
                case mdIconRight:
                    if (pt.x <= rcInverted.left)
                        {   /* Moving right icon left, crossed border */
                        mdIcon = (mdIcon & ~mdIconXMask) | mdIconLeft;
WholePic:
                        if (fIsRcInverted)
                            InvertPMSFrame();
                        rcInverted = rcPicture;
                        }
                    break;
                }

            DrawPMSFrameIcon( mdIcon, pt );
            break;
        case WM_LBUTTONDOWN:
            goto MakeChange;
            break;
        }
    }   /* end else */
 }   /* end while */

MakeChange:

 {
 unsigned NEAR MxRoundMx( unsigned );
    /* Round multipliers if near an even multiple */
 unsigned mx = MxRoundMx( mxCurrent );
 unsigned my = MxRoundMx( myCurrent );

    /* Assert must be true for above call to work for an my */
 Assert( mxMultByOne == myMultByOne );

 ModifyPicInfoDxp( rcInverted.left - xpSelBar + wwdCurrentDoc.xpMin,
                   rcInverted.right - rcInverted.left,
                   rcInverted.bottom - rcInverted.top,
                   mx, my );
 }

SkipChange:
 EndPMS();
}


unsigned NEAR MxRoundMx( mx )
unsigned mx;
{   /* If mx is near an "interesting" multiple, round it to be exactly that
       multiple.  Interesting multiples are:
                    1 (m=mxMultByOne), 2 (m=2 * mxMultByOne), 3 , ...
                    0.5 (m = .5 * mxMultByOne)
     This routine works for my, too, as long as mxMultByOne == myMultByOne */

    /* This means close enough to round (1 decimal place accuracy) */
#define dmxRound    (mxMultByOne / 20)

 unsigned mxRemainder;

 if (mx >= mxMultByOne - dmxRound)
    {   /* Multiplier > 1 -- look for rounding to integer multiple */
    if ((mxRemainder = mx % mxMultByOne) < dmxRound)
        mx -= mxRemainder;
    else if (mxRemainder >= mxMultByOne - dmxRound)
        mx += (mxMultByOne - mxRemainder);
    }
 else
    {   /* Multiplier < 1 -- look for multiplication by 1/2 */
    if ((mxRemainder = mx % (mxMultByOne >> 1)) < dmxRound)
        mx -= mxRemainder;
    else if (mxRemainder >= ((mxMultByOne >> 1) - dmxRound))
        mx += (mxMultByOne >> 1) - mxRemainder;
    }

 return mx;
}




int NEAR FStartPMS( fSize )
int fSize;
{               /* Initialization for Picture Move/Size */
extern HCURSOR vhcHourGlass;
extern HWND hParentWw;
extern struct SEP vsepAbs;
extern struct SEP vsepPage;
extern HDC vhDCPrinter;

 struct PICINFOX picInfo;
 struct EDL *pedl;
 RECT rc;
 HDC hdcT;
 POINT pt;

 Assert(vhDCPrinter);
 fSizing = fSize;

 UpdateWw( wwCur, FALSE );  /* Screen must be up-to-date */

    /* Set the rect that defines our display area */
 SetRect( (LPRECT) &rcClip, xpSelBar, wwdCurrentDoc.ypMin,
           wwdCurrentDoc.xpMac, wwdCurrentDoc.ypMac );

 GetPicInfo( selCur.cpFirst, selCur.cpLim, docCur, &picInfo );

 if (fSize)
    {
    if (BStructMember( PICINFOX, my ) >= picInfo.cbHeader )
        {   /* OLD file format (no multipliers), scaling not supported */
        return FALSE;
        }
    }

/* Set multiplier factor used by the printer (will be { 1, 1 } if
   the printer is not a scaling device; greater if it is.)
   This info is used for the 64K limit test of picture growth. */
     
    if (!(GetDeviceCaps( vhDCPrinter, RASTERCAPS ) & RC_BITMAP64))
    /* doesn't support > 64K bitmaps */
    {
        if (GetDeviceCaps( vhDCPrinter, RASTERCAPS ) & RC_SCALING)
        {
            POINT pt;

            pt.x = pt.y = 0;   /* Just in case */
            Escape( vhDCPrinter, GETSCALINGFACTOR, 0, (LPSTR) NULL,
                    (LPSTR) (LPPOINT) &pt );
            cxpPrinterPixel = 1 << pt.x;
            cypPrinterPixel = 1 << pt.y;
        }
        else
        {
            cxpPrinterPixel = cypPrinterPixel = 1;
        }
    }
    else
    {
        cxpPrinterPixel = cypPrinterPixel = 0xFFFF;
    }

 /* Compute picture's original (when pasted) size in
    screen pixels {dxpOrig, dypOrig}.
    These numbers are the bases for computing the multiplier. */

 switch(picInfo.mfp.mm)
 {
    case MM_BITMAP:
        GetBitmapSize( &dxpOrig, &dypOrig, &picInfo, FALSE );

        /* Compensate for effects of existing multipliers */

        dxpOrig = MultDiv( dxpOrig, mxMultByOne, picInfo.mx );
        dypOrig = MultDiv( dypOrig, myMultByOne, picInfo.my );
    break;

    default: // OLE and META
    {
    int dxa, dya;

    if (!FComputePictSize( &picInfo.mfp, &dxa, &dya ))
        return FALSE;

    dxpOrig = DxpFromDxa( dxa, FALSE );
    dypOrig = DypFromDya( dya, FALSE );
    }
    break;
 }

 if (!FGetPictPedl( &pedl ))
        /* Picture must be on the screen */
    return FALSE;
 ComputePictRect( &rcPicture, &picInfo, pedl, wwCur );
 rcInverted = rcPicture;    /* Initial grey box is the size of the picture */

 vfPMS = TRUE;      /* So ToggleSel knows not to invert the pict */
 fPictModified = FALSE;

    /* Amt to move for arrow keys is derived from size of fixed font */

 if ( ((hdcT=GetDC( hParentWw ))!=NULL) &&
      (SelectObject( hdcT, GetStockObject( ANSI_FIXED_FONT ) )!=0))
    {
    TEXTMETRIC tm;

    GetTextMetrics( hdcT, (LPTEXTMETRIC) &tm );
    ReleaseDC( hParentWw, hdcT );
    dxpKeyMove = tm.tmAveCharWidth;
    dypKeyMove = (tm.tmHeight + tm.tmExternalLeading) / 2;
    }

 SetupDCForPMS();   /* Save DC and select in a grey brush for border drawing */

    /* Assure that the "size box" mouse cursor is loaded */
 if (vhcPMS == NULL)
    {
    extern HANDLE hMmwModInstance;
    extern CHAR szPmsCur[];

    vhcPMS = LoadCursor( hMmwModInstance, (LPSTR) szPmsCur );
    }

    /* Compute maximum allowable area for picture to roam
       (relative to para left edge, picture top) */
 CacheSectPic( docCur, selCur.cpFirst );
 dxpPicMac = imax(
             DxpFromDxa( vsepAbs.dxaText, FALSE ),
             rcPicture.right - xpSelBar + wwdCurrentDoc.xpMin );
 dypPicMac = DypFromDya( vsepAbs.yaMac, FALSE );

    /* Since the picture is selected, need to un-invert it */
 InvertRect( wwdCurrentDoc.hDC, (LPRECT) &rcPicture );

 SetCapture( wwdCurrentDoc.wwptr );     /* Hog all mouse actions */

 /* Draw initial size box icon in the center of the picture */

 pt.x = rcInverted.left + (unsigned)(rcInverted.right - rcInverted.left)/2;
 pt.y = rcInverted.top + (unsigned)(rcInverted.bottom - rcInverted.top)/2;
 DrawPMSFrameIcon( mdIconCenterFix | mdIconSetCursor, pt );

 SetCursor( vhcPMS );        /* Make the mouse cursor a size box */
 ShowCursor( TRUE );        /* So cursor appears even on mouseless systems */

 return TRUE;
}




void NEAR SetupDCForPMS()
{   /* Save current document DC & set it up for picture move/sizing:
        - A gray background brush for drawing the border
        - A drawing area resricted to rcClip */

 ilevelPMS = SaveDC( wwdCurrentDoc.hDC );
 SelectObject( wwdCurrentDoc.hDC, GetStockObject( GRAY_BRUSH ) );
 IntersectClipRect( wwdCurrentDoc.hDC,
                    rcClip.left, rcClip.top, rcClip.right, rcClip.bottom );
}




void NEAR EndPMS()
{       /* Leaving Picture Move/Size */
extern int docMode;
struct PICINFOX picInfo;

 vfPMS = FALSE;
 ReleaseCapture();  /* Allow other windows to receive mouse events */
 SetCursor( NULL );

 docMode = docNil;
 CheckMode();       /* Compensate for multiplier display */

 if (fIsRcInverted)
    InvertPMSFrame();

 if (!fPictModified && !vfCancelPictMove)
    {   /* Picture did not change, restore inversion to show selection */
        /* Must do this BEFORE RestoreDC so excess above ypMin is clipped */
    InvertRect( wwdCurrentDoc.hDC, (LPRECT) &rcPicture );
    }

 RestoreDC( wwdCurrentDoc.hDC, ilevelPMS );

 ShowCursor( FALSE );   /* Decrement cursor ref cnt (blanks if no mouse) */

    /* Since we've been ignoring messages, make sure our key flags are OK */
 SetShiftFlags();
}



void NEAR DrawPMSFrameIcon( mdIcon, pt )
int mdIcon;
POINT pt;
{       /* Draw Picture Move/Size frame and icon, with the icon at position
           pt.  The icon type is given by mdIcon.

           Scrolls the correct part of the picture into view if necessary.

           Uses statics: rcPicture, rcClip, rcInverted, fIsRcInverted
        */
#define FEqualRect( r1, r2 )    ((r1.left==r2.left)&&(r1.right==r2.right)&&\
                                 (r1.top==r2.top)&&(r1.bottom==r2.bottom))

 extern int vfAwfulNoise;
 int xpCntr;
 int dxpCntr = ((unsigned)(rcInverted.right - rcInverted.left)) / 2;
 RECT rcT;

 rcT = rcInverted;

 /* Set pt.y so it does not exceed limits */

 if (mdIcon & mdIconBottom)
    {
    if (pt.y - rcInverted.top > dypPicMac)
        {
        pt.y = rcInverted.top + dypPicMac;  /* max y-size is 1 page */
        }
    else if (pt.y < rcInverted.top + 1)
        pt.y = rcInverted.top + 1;          /* min y-size is 1 pixel */

    /* Restrict pt.x as necessary to keep printer bitmap < 64K */

    if ((pt.y > rcInverted.bottom) && (cxpPrinterPixel < 0xFFFF) && (cypPrinterPixel < 0xFFFF))
        {   /* Really sizing in y */
        unsigned dxpScreen = imax (imax(pt.x,rcInverted.right)-rcInverted.left,
                                   dxpPicSizeMin);
        unsigned dxpPrinter = DxpFromDxa(DxaFromDxp( dxpScreen, FALSE ), TRUE);
        unsigned dypLast = 0xFFFF / (dxpPrinter / 8);
        unsigned dyp = DypFromDya( DyaFromDyp( pt.y - rcInverted.top , FALSE),
                                   TRUE );

        if (dyp / (cxpPrinterPixel * cypPrinterPixel) > dypLast )
            {   /* Bitmap would overflow 64K boundary */
            pt.y = rcInverted.top +
                  DypFromDya( DyaFromDyp( dypLast, TRUE ), FALSE );
            }
        }
    }
 else if (pt.y < rcInverted.top)
    pt.y = rcInverted.top;          /* Can't go above picture top */
 else if (pt.y > rcInverted.bottom)
    pt.y = rcInverted.bottom;       /* Necessary? */

 /* Set pt.x so it does not execeed limits */

 switch (mdIcon & mdIconXMask) {
    case mdIconCenterFloat:
    case mdIconRight:

        /* Restrict pt.x as necessary to keep printer bitmap < 64K */
         if ((cxpPrinterPixel < 0xFFFF) && (cypPrinterPixel < 0xFFFF))
         {
         unsigned dyp = DypFromDya( DyaFromDyp( imax( pt.y - rcInverted.top,
                                    dypPicSizeMin), FALSE ), TRUE );
         unsigned dxpLast = 0xFFFF / (dyp / 8);
         unsigned dxp = DxpFromDxa( DxaFromDxp( pt.x - rcInverted.left,
                                    FALSE ), TRUE );

         if (dxp / (cxpPrinterPixel * cypPrinterPixel) > dxpLast )
             {   /* Printer bitmap would overflow 64K boundary */
             pt.x = rcInverted.left +
                        DxpFromDxa( DxaFromDxp( dxpLast, TRUE ), FALSE );
             }
         }

    default:
        break;
    case mdIconLeft:
        if ((pt.x < rcClip.left) && (wwdCurrentDoc.xpMin == 0))
            pt.x = rcClip.left;     /* Reached left scroll limit */
        break;
    case mdIconCenterFix:
        if ( (pt.x - dxpCntr < rcClip.left) && (wwdCurrentDoc.xpMin == 0))
            pt.x = rcClip.left + dxpCntr;   /* Reached left scroll limit */
        else if (pt.x - xpSelBar + wwdCurrentDoc.xpMin + dxpCntr > dxpPicMac)
                /* Move Picture only: can't move past margins */
            pt.x = dxpPicMac + xpSelBar - wwdCurrentDoc.xpMin - dxpCntr;
        break;
    }

 /* Check for pt outside of clip rectangle; scroll/bail out as needed */

 if (!PtInRect( (LPRECT)&rcClip, pt ))
    {
    int dxpHalfWidth =  (unsigned)(rcClip.right - rcClip.left) / 2;
    int dypHalfHeight = (unsigned)(rcClip.bottom - rcClip.top) / 2;
    int dxpScroll=0;
    int dypScroll=0;

    if (pt.x < rcClip.left)
        {
        if (wwdCurrentDoc.xpMin == 0)
            {
            _beep();                /* Reached left-hand scroll limit */
            pt.x = rcClip.left;
            }
        else
            {   /* SCROLL LEFT */
            dxpScroll = imax( -wwdCurrentDoc.xpMin,
                               imin( -dxpHalfWidth, pt.x - rcClip.left ) );
            }
        }
    else if (pt.x > rcClip.right)
        {
        if (wwdCurrentDoc.xpMin + rcClip.right - rcClip.left >= xpRightLim )
            {
            _beep();
            pt.x = rcClip.right;    /* Reached right-hand scroll limit */
            }
        else
            {   /* SCROLL RIGHT */
            dxpScroll = imin( xpRightLim - wwdCurrentDoc.xpMin +
                              rcClip.right - rcClip.left,
                              imax( dxpHalfWidth, pt.x - rcClip.right ) );
            }
        }

    if (pt.y < rcClip.top)
        {
        struct EDL *pedl = &(**wwdCurrentDoc.hdndl)[wwdCurrentDoc.dlMac - 1];

        if ( (rcInverted.top >= rcClip.top) ||
                /* May not scroll all of the original picture off the screen */
             (wwdCurrentDoc.dlMac <= 1) ||
             ( (pedl->cpMin == selCur.cpFirst) &&
                 ( ((pedl-1)->cpMin != pedl->cpMin) || !(pedl-1)->fGraphics)))
            {
            _beep();
            pt.y = rcClip.top;
            }
        else
            {   /* SCROLL UP */
            dypScroll = rcInverted.top - rcClip.top;
            }
        }
    else if (pt.y > rcClip.bottom)
        {
        struct EDL *pedl=&(**wwdCurrentDoc.hdndl)[0];

                /* May not scroll all of the original picture off the screen */
        if ( (wwdCurrentDoc.dlMac <= 1) ||
             ( (pedl->cpMin == selCur.cpFirst) &&
               ( ((pedl+1)->ichCpMin == 0) || !(pedl+1)->fGraphics) ))
            {
            _beep();                /* Reached downward scroll limit */
            pt.y = rcClip.bottom;   /* Must have at least 1 picture dl visible */
            }
        else
            dypScroll = 1;      /* SCROLL DOWN */
        }

    if (dxpScroll || dypScroll)
        {                       /* SCROLL */
        struct EDL *pedl;
        struct PICINFOX picInfo;
        int xpMinT = wwdCurrentDoc.xpMin;
        int ypTopT = rcPicture.top;
        int dxpAdjust, dypAdjust;

        if (dxpScroll && dypScroll)
                /* Did not need to truncate coordinates; re-enable beep */
            vfAwfulNoise = FALSE;

        if (fIsRcInverted)
            InvertPMSFrame();

        /* Scroll by the appropriate amount:
                dxpScroll in x-direction; one line in y-direction */

        RestoreDC( wwdCurrentDoc.hDC, ilevelPMS );  /* Use orig DC props */
        if (dxpScroll)
            AdjWwHoriz( dxpScroll );
        if (dypScroll > 0)
            ScrollDownCtr( 1 );
        else if (dypScroll < 0)
            ScrollUpCtr( 1 );
        UpdateWw( wwCur, FALSE );
        SetupDCForPMS();                         /* Compensate for RestoreDC */

        /* Update rcPicture to reflect new scroll position */

        GetPicInfo( selCur.cpFirst, selCur.cpLim, docCur, &picInfo );
        if (!FGetPictPedl( &pedl ))
            {
            Assert (FALSE);     /* If we get here, we're in trouble */
            _beep();
            return;
            }
        ComputePictRect( &rcPicture, &picInfo, pedl, wwCur );

        /* Adjust rcT, pt relative to the amount we actually scrolled */

        dxpAdjust = xpMinT - wwdCurrentDoc.xpMin;
        dypAdjust = rcPicture.top - ypTopT;
        OffsetRect( (LPRECT) &rcT, dxpAdjust, dypAdjust );
        pt.x += dxpAdjust;
        pt.y += dypAdjust;

        goto Display;   /* Dont let rcInverted be edited until we have
                           scrolled the icon into view */
        }
    }

 /* Compute effect of new icon position and/or type on rcInverted */

 switch (mdIcon & mdIconXMask) {
    case mdIconCenterFix:
        if (!fSizing)
            {
            xpCntr = rcInverted.left + dxpCntr;
            OffsetRect( (LPRECT) &rcT, pt.x - xpCntr, 0 );
            }
        break;
    case mdIconLeft:
        rcT.left = pt.x;
        goto ComputeY;
    case mdIconRight:
        rcT.right = pt.x;
    default:
    case mdIconCenterFloat:
ComputeY:
        if (mdIcon & mdIconBottom)
            rcT.bottom = pt.y;
        break;
     }

Display:

 /* If redrawing the border is necessary, do it */

 if (!FEqualRect( rcT, rcInverted ) || (mdIcon & mdIconSetCursor))
    {
    if (fIsRcInverted)
        InvertPMSFrame();
    rcInverted = rcT;
    InvertPMSFrame();
    }
 if (mdIcon & mdIconSetCursor)
    {
    SetCursorClientPos( pt );
    SetCursor( vhcPMS );
    }

 /* If the multipliers have changed, redisplay them */

 if (fSizing)
     {
     unsigned mx, my;

     mx = MultDiv( rcInverted.right - rcInverted.left, mxMultByOne, dxpOrig );
     my = MultDiv( rcInverted.bottom - rcInverted.top, myMultByOne, dypOrig );

     if (mx != mxCurrent || my != myCurrent)
        {   /* Multipliers have changed */
        mxCurrent = mx;
        myCurrent = my;
        ShowPictMultipliers();
        }
     }
}




void NEAR InvertPMSFrame()
{   /* Draw a frame for rcInverted in XOR mode, update fIsRcInverted */
 int dxpSize=rcInverted.right - rcInverted.left - 1;
 int dypSize=rcInverted.bottom - rcInverted.top - 1;

 PatBlt( wwdCurrentDoc.hDC, rcInverted.left, rcInverted.top,
                            dxpSize, 1, PATINVERT );
 PatBlt( wwdCurrentDoc.hDC, rcInverted.right - 1, rcInverted.top,
                            1, dypSize, PATINVERT );
 PatBlt( wwdCurrentDoc.hDC, rcInverted.left + 1, rcInverted.bottom - 1,
                            dxpSize, 1, PATINVERT );
 PatBlt( wwdCurrentDoc.hDC, rcInverted.left, rcInverted.top + 1,
                            1, dypSize, PATINVERT );

 fIsRcInverted ^= -1;
}




void NEAR GetCursorClientPos( ppt )
POINT *ppt;
{       /* Get current mouse cursor coordinates (window-relative) */
GetCursorPos( (LPPOINT) ppt );
ScreenToClient( wwdCurrentDoc.wwptr, (LPPOINT) ppt );
}




void NEAR SetCursorClientPos( pt )
POINT pt;
{     /* Set current mouse cursor coordinates (window-relative) */
ClientToScreen( wwdCurrentDoc.wwptr, (LPPOINT) &pt );
SetCursorPos( pt.x, pt.y );
}



STATIC NEAR ModifyPicInfoDxp( xpOffset, xpSize, ypSize, mx, my )
int xpOffset, xpSize, ypSize;
unsigned mx, my;
{   /* Modify the currently selected picture by adjusting its offset and
       size to the pixel values specified. Negative values mean don't
       set that value.
       Added    9/23/85: mx and my parms give the multiplier, redundant
                         info used for scaling bitmaps. */

 int xaOffset, xaSize, yaSize;

 xaOffset = xaSize = yaSize = -1;

 if (xpSize >= 0)
    xaSize = DxaFromDxp( umax( xpSize, dxpPicSizeMin ), FALSE );
 if (ypSize >= 0)
    yaSize = DyaFromDyp( umax( ypSize, dypPicSizeMin ), FALSE );
 if (xpOffset >= 0)
    xaOffset = DxaFromDxp( xpOffset, FALSE );
 ModifyPicInfoDxa( xaOffset, xaSize, yaSize, mx, my, TRUE );
}




/* M O D I F Y  P I C  I N F O  D X A */
STATIC NEAR ModifyPicInfoDxa( xaOffset, xaSize, yaSize, mx, my, fSetUndo )
int xaOffset, xaSize, yaSize;
unsigned mx, my;
BOOL fSetUndo;
{   /* Modify the currently selected picture by adjusting its offset and
       size to the twip values specified. Negative values mean don't
       set that value.
       Added 9/23/85: mx, my are size "multipliers", used for
                      bitmaps only */

typeFC fcT;
struct PICINFOX  picInfo;
typeCP  cp = selCur.cpFirst;
int     dyaSizeOld;
int     fBitmap,fObj;

fPictModified = TRUE;
FreeBitmapCache();

GetPicInfo(cp, cpMacCur, docCur, &picInfo);
fBitmap = (picInfo.mfp.mm == MM_BITMAP);
fObj =    (picInfo.mfp.mm == MM_OLE);

dyaSizeOld = picInfo.dyaSize;

if (fBitmap || fObj)
    {
    if ((int)mx > 0 && (int)my > 0)
        {
        picInfo.mx = mx;
        picInfo.my = my;
        }
    }
else 
    {
    if (xaSize >= 0)
        picInfo.dxaSize = xaSize;

    if (yaSize >= 0)
        picInfo.dyaSize = yaSize;
    }

if (xaOffset >= 0)
    picInfo.dxaOffset = xaOffset;

if (picInfo.cbHeader > cchOldPICINFO)
        /* Extended picture format, set extended format bit */
    picInfo.mfp.mm |= MM_EXTENDED;

if (!fObj)
    fcT = FcWScratch( &picInfo, picInfo.cbHeader );

picInfo.mfp.mm &= ~MM_EXTENDED;

/* Right or center justify becomes invalid if the picture is moved
   without being sized */

CachePara(docCur, cp);
if ( (xaSize < 0 && yaSize < 0) &&
     (vpapAbs.jc == jcRight || vpapAbs.jc == jcCenter))
        {
        CHAR rgb[2];

	if (fSetUndo)
	    SetUndo(uacPictSel, docCur, cp, selCur.cpLim - selCur.cpFirst,
                                                docNil, cpNil, cpNil, 0);
        TrashCache();
        rgb[0] = sprmPJc;
        rgb[1] = jcLeft;
        AddSprm(&rgb[0]);
        }
else
	{
	if (fSetUndo)
	    SetUndo( uacPictSel, docCur, cp, (typeCP) picInfo.cbHeader,
                 docNil, cpNil, cpNil, 0);
	}

if (fObj)
    ObjSetPicInfo(&picInfo, docCur, cp);
else
    Replace( docCur, cp, (typeCP) picInfo.cbHeader,
            fnScratch, fcT, (typeFC) picInfo.cbHeader);

if ( ((fBitmap || fObj) && (my > myMultByOne)) ||
     (!fBitmap && (dyaSizeOld < picInfo.dyaSize)))
        { /* If the picture height was increased, make sure proper EDLs are
                        invalidated. */
        typeCP dcp = cpMacCur - cp + (typeCP) 1;
        AdjustCp(docCur, cp, dcp, dcp);
        }
}




STATIC NEAR ShowPictMultipliers( )
{   /* Display the current multipliers (mxCurrent, myCurrent) in the page info
       window in the form "n.nX/n.nY". */

CHAR *PchCvtMx( unsigned, CHAR * );
extern CHAR szMode[];

CHAR *pch = szMode;

pch = PchCvtMx( mxCurrent, pch );
*(pch++) = 'X';
*(pch++) = '/';
Assert( mxMultByOne == myMultByOne );   /* Necessary for below to work w/ my */
pch = PchCvtMx( myCurrent, pch );
*(pch++) = 'Y';
*pch = '\0';

DrawMode();
}


CHAR *PchCvtMx( mx, pch )
CHAR *pch;
unsigned mx;
{   /* Convert the passed multiplier word to a string representation.
       Number is based on a mxMultByOne === 1 scale
       (e.g. mx == .9 * mxMultByOne yields "0.9")
       String always has at least one digit before the decimal point,
       and exactly one after.
       Examples of return strings: "10.5", "0.0", "5.5" */

 int nTenths;
 int nWholes;
 int cch;
 extern CHAR vchDecimal;
 extern BOOL    vbLZero;
 extern int     viDigits;

 /* Round up to nearest single decimal place */

 if (mx % (mxMultByOne / 10) >= mxMultByOne / 20)
    mx += mxMultByOne / 20;

 /* Write digit(s) before decimal place */

 if (((nWholes = mx / mxMultByOne) == 0) && vbLZero)
    *(pch++) = '0';
 else
    ncvtu( nWholes, &pch );

 /* Write Decimal Point and following digit */

 *(pch++) = vchDecimal;

 if (viDigits > 0)
    *(pch++) = ((mx % mxMultByOne) / (mxMultByOne / 10)) + '0';

 *pch = '\0';

 return pch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\picture2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* picture2.c -- MW format and display routines for pictures */

//#define NOGDICAPMASKS
#define NOWINMESSAGES
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOCTLMGR
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
//#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOFONT
#define NOMB
#define NOMENUS
#define NOOPENFILE
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#define NOKCCODES
#include "ch.h"
#include "docdefs.h"
#include "fmtdefs.h"
#include "dispdefs.h"
#include "cmddefs.h"
#include "propdefs.h"
#include "stcdefs.h"
#include "wwdefs.h"
#include "filedefs.h"
#include "editdefs.h"
/* #include "str.h" */
#include "prmdefs.h"
/* #include "fkpdefs.h" */
/* #include "macro.h" */
#include "winddefs.h"
#if defined(OLE)
#include "obj.h"
#endif

extern typeCP           cpMacCur;
extern int              docCur;
extern int              vfSelHidden;
extern struct WWD       rgwwd[];
extern int              wwCur;
extern int              wwMac;
extern struct FLI       vfli;
extern struct SEL       selCur;
extern struct WWD       *pwwdCur;
extern struct PAP       vpapCache;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern int              vfPictSel;
extern struct PAP       vpapAbs;
extern struct SEP       vsepAbs;
extern struct SEP       vsepPage;
extern struct DOD       (**hpdocdod)[];
extern unsigned         cwHeapFree;
extern int              vfInsertOn;
extern int              vfPMS;
extern int              dxpLogInch;
extern int              dypLogInch;
extern int              dxaPrPage;
extern int              dyaPrPage;
extern int              dxpPrPage;
extern int              dypPrPage;
extern HBRUSH           hbrBkgrnd;
extern long             ropErase;
extern int              vdocBitmapCache;
extern typeCP           vcpBitmapCache;
extern HBITMAP          vhbmBitmapCache;
extern HCURSOR          vhcIBeam;


/* Used in this module only */
#ifdef DEBUG
#define STATIC static
#else
#define STATIC
#endif


/* (windows naming convention for func name, not Hung.) */

long GetBitmapMultipliers( hDC, dxpOrig, dypOrig, dxmmIdeal, dymmIdeal )
HDC hDC;
int dxpOrig, dypOrig;
int dxmmIdeal, dymmIdeal;
{   /* Return the "best" integer bit-multiples to use when displaying a bitmap
       of size { dxpOrig, dypOrig } (in pixels) on device DC hDC.
       The "ideal size" of the bitmap is { dxmmIdeal, dymmIdeal } (in 0.1mm units);
       this conveys the desired aspect ratio as well.
       Returns the y-multiplier in the hi word, the x-multiplier in the lo word.
       Default/error value returned is { 1, 1 }. */

 typedef unsigned long ul;

 long lT;
 int cx, cy;
 int cxBest, cyBest;
 int dcx=1, dcy=1;
 int dxpT, dypT;
 int dxmmOrig, dymmOrig;
 int dxmmDevice = GetDeviceCaps( hDC, HORZSIZE ) * 10;
 int dymmDevice = GetDeviceCaps( hDC, VERTSIZE ) * 10;
 int dxpDevice = GetDeviceCaps( hDC, HORZRES );
 int dypDevice = GetDeviceCaps( hDC, VERTRES );
 int cxMac, cyMac;
 int pctAspectBest, pctSizeBest;

 /* Compute scale factor (dcx, dcy, our minimum scale multiple) */

 if (GetDeviceCaps( hDC, RASTERCAPS ) & RC_SCALING)
    {
    POINT pt;

    pt.x = pt.y = 0;   /* Just in case */
    Escape( hDC, GETSCALINGFACTOR, 0, (LPSTR) NULL, (LPSTR) (LPPOINT) &pt );
    dcx = 1 << pt.x;
    dcy = 1 << pt.y;
    }

 /* Compute size of unscaled picture on hDC in 0.1 mm units */

 if (dxpDevice <= 0 || dypDevice <= 0)
    goto Error;

 dxmmOrig = MultDiv( dxpOrig, dxmmDevice, dxpDevice );
 dymmOrig = MultDiv( dypOrig, dymmDevice, dypDevice );

 /* Ideal size not supplied; return 1,1 (times device multipliers) */

 if (dxmmIdeal <= 0 || dymmIdeal <= 0)
    {
    goto Error;
    }

 /* Compute absolute maximums for cx, cy */
 /* 2nd term of min restricts search space by refusing to consider
    more tham one size above the ideal */

 if (dxmmOrig <= 0 || dymmOrig <= 0)
    goto Error;

 cxMac = min ( (dxmmDevice / dxmmOrig) + 1, (dxmmIdeal / dxmmOrig) + 2 );
 cyMac = min ( (dymmDevice / dymmOrig) + 1, (dymmIdeal / dymmOrig) + 2 );

 /* Search all possible multiplies to see what would be best */

 cxBest = dcx;
 cyBest = dcy;
 pctAspectBest = pctSizeBest = 32767;

 for ( cx = dcx ; cx < cxMac; cx += dcx )
    for ( cy = dcy ; cy < cyMac; cy += dcy )
        {
        int dxmm = dxmmOrig * cx;
        int dymm = dymmOrig * cy;
        int pctAspect = PctDiffUl( (ul) dxmmIdeal * (ul) dymm,
                                   (ul) dymmIdeal * (ul) dxmm );
        int pctSize = PctDiffUl( (ul) dxmmIdeal * (ul) dymmIdeal,
                                 (ul)dxmm * (ul)dymm );

        /* ??? Strategy for loss on one, gain on the other ??? */

        if (pctAspect <= pctAspectBest && pctSize <= pctSizeBest )
            {
            cxBest = cx;
            cyBest = cy;
            pctAspectBest = pctAspect;
            pctSizeBest = pctSize;
            }
        }

 Assert( cxBest > 0 && cyBest > 0 );

 return MAKELONG( cxBest, cyBest );

Error:
 return MAKELONG( dcx, dcy );
}



int PctDiffUl( ul1, ul2 )
unsigned long ul1, ul2;
{   /* Return a number that is proportional to the percentage
       of difference between the two numbers */
    /* Will not work for > 0x7fffffff */

#define dulMaxPrec  1000     /* # of "grains" of response possible */

unsigned long ulAvg = (ul1 >> 1) + (ul2 >> 1);
unsigned long ulDiff = (ul1 > ul2) ? ul1 - ul2 : ul2 - ul1;

if (ulAvg == 0)
    return (ul1 == ul2) ? 0 : dulMaxPrec;

if (ulDiff > 0xFFFFFFFF / dulMaxPrec)
    return dulMaxPrec;

return (int) ((ulDiff * dulMaxPrec) / ulAvg);
}


int PxlConvert( mm, val, pxlDeviceRes, milDeviceRes )
int mm;
int val;
int pxlDeviceRes;
int milDeviceRes;
{   /* Return the # of pixels spanned by val, a measurement in coordinates
       appropriate to mapping mode mm.  pxlDeviceRes gives the resolution
       of the device in pixels, along the axis of val. milDeviceRes gives
       the same resolution measurement, but in millimeters.
       returns 0 on error */
 typedef unsigned long ul;

 ul ulMaxInt = 32767L;   /* Should be a constant, but as of 7/12/85,
                           CMERGE generates incorrect code for the
                           ul division if we use a constant */
 ul ulPxl;
 ul ulDenom;
 unsigned wMult=1;
 unsigned wDiv=1;


    if (milDeviceRes == 0)
        {   /* to make sure we don't get divide-by-0 */
        return 0;
        }

    switch ( mm ) {
        case MM_LOMETRIC:
            wDiv = 10;
            break;
        case MM_HIMETRIC:
            wDiv = 100;
            break;
        case MM_TWIPS:
            wMult = 25;
            wDiv = 1440;
            break;
        case MM_LOENGLISH:
            wMult = 25;
            wDiv = 100;
            break;
        case MM_HIENGLISH:
            wMult = 25;
            wDiv = 1000;
            break;
        case MM_BITMAP:
        case MM_OLE:
        case MM_TEXT:
            return val;
        default:
            Assert( FALSE );        /* Bad mapping mode */
        case MM_ISOTROPIC:
        case MM_ANISOTROPIC:
                /* These picture types have no original size */
            return 0;
    }

/* Add Denominator - 1 to Numerator, to avoid rounding down */

 ulDenom = (ul) wDiv * (ul) milDeviceRes;
 ulPxl = ((ul) ((ul) wMult * (ul) val * (ul) pxlDeviceRes) + ulDenom - 1) /
         ulDenom;

 return (ulPxl > ulMaxInt) ? 0 : (int) ulPxl;
}




/* F O R M A T  G R A P H I C S */
FormatGraphics(doc, cp, ichCp, cpMac, flm)
int     doc;
typeCP  cp;
int     ichCp;
typeCP  cpMac;
int     flm;
{       /* Format a line of graphics  */
        CHAR rgch[10];
        int cch;
        int dypSize;
        int dxpSize;
        int dxaText;
        int dxa;
        struct PICINFOX  picInfo;
        int fPrinting = flm & flmPrinting;

        GetPicInfo(cp, cpMac, doc, &picInfo);

        /* Compute the size of the pict in device pixels */

        if (picInfo.mfp.mm == MM_BITMAP && ((picInfo.dxaSize == 0) ||
                                            (picInfo.dyaSize == 0)))
            {
            GetBitmapSize( &dxpSize, &dypSize, &picInfo, fPrinting);
            }
#if defined(OLE)
        else if (picInfo.mfp.mm == MM_OLE)
        {
            dxpSize = DxpFromDxa( picInfo.dxaSize, fPrinting );
            dypSize = DypFromDya( picInfo.dyaSize, fPrinting );
            dxpSize = MultDiv( dxpSize, picInfo.mx, mxMultByOne );
            dypSize = MultDiv( dypSize, picInfo.my, myMultByOne );
        }
#endif
        else
            {
            dxpSize = DxpFromDxa( picInfo.dxaSize, fPrinting );
            dypSize = DypFromDya( picInfo.dyaSize, fPrinting );
            }

        if (fPrinting)
                {
                /* If we are printing, then the picture consists of a single
                band. */
                vfli.cpMac = vcpLimParaCache;
                vfli.ichCpMac = 0;
                vfli.dypLine = dypSize;
                }
        else if ((ichCp + 2) * dypPicSizeMin > dypSize)
                {
                /* Last band of picture.  NOTE: last band is always WIDER than
                dypPicSizeMin */
                vfli.cpMac = vcpLimParaCache;
                vfli.ichCpMac = 0;

#ifdef CASHMERE
                vfli.dypLine = dypSize - max(0, dypSize / dypPicSizeMin - 1) *
                        dypPicSizeMin + DypFromDya( vpapAbs.dyaAfter, FALSE );
#else /* not CASHMERE */
                vfli.dypLine = dypSize - max(0, dypSize / dypPicSizeMin - 1) *
                        dypPicSizeMin;
#endif /* not CASHMERE */

                }
        else
                {
                vfli.ichCpMac = vfli.ichCpMin + 1;
                vfli.cpMac = vfli.cpMin;
                vfli.dypLine = dypPicSizeMin;
                }

#ifdef CASHMERE
        if (ichCp == 0) /* Add in the 'space before' field. */
                {
                vfli.dypLine += DypFromDya( vpapAbs.dyaBefore, fPrinting );
                }
#endif /* CASHMERE */

        vfli.dypFont = vfli.dypLine;

        dxaText = vsepAbs.dxaText;

        switch (vpapAbs.jc)
                {
        case jcLeft:
        case jcBoth:
                dxa = picInfo.dxaOffset;
                break;
        case jcCenter:
                dxa = (dxaText - (int)vpapAbs.dxaRight + (int)vpapAbs.dxaLeft -
                                DxaFromDxp( dxpSize, fPrinting )) >> 1;
                break;
        case jcRight:
                dxa = dxaText - (int)vpapAbs.dxaRight -
                                DxaFromDxp( dxpSize, fPrinting );
                break;
                }

        vfli.xpLeft = DxpFromDxa( max( (int)vpapAbs.dxaLeft, dxa ), fPrinting );
#ifdef BOGUSBL
        vfli.xpReal = imin( dxpSize + vfli.xpLeft,
                            DxpFromDxa( dxaText - vpapAbs.dxaRight, fPrinting );
#else   /* Don't crunch the picture to fit the margins */
        vfli.xpReal = dxpSize + vfli.xpLeft;
#endif
        vfli.fGraphics = true;
}

GetPicInfo(cp, cpMac, doc, ppicInfo)
typeCP  cp, cpMac;
int     doc;
struct PICINFOX  *ppicInfo;
{   /* Fetch the header structure for a picture at cp into *ppicInfo.
       Supports the OLD file format (which used cbOldSize); always returns
       the NEW PICINFO structure. */
int     cch;

FetchRgch(&cch, ppicInfo, doc, cp, cpMac, cchPICINFOX);

if (ppicInfo->mfp.mm & MM_EXTENDED)
    {
    ppicInfo->mfp.mm &= ~MM_EXTENDED;
    }
 else
    {   /* Old file format -- fill out extended fields */
    ppicInfo->cbSize = ppicInfo->cbOldSize;
    ppicInfo->cbHeader = cchOldPICINFO;
    }

 /* Fill in defaults for extended fields that are not present in the file */
 /* These are:  mx, my      Added 9/19/85 by bryanl */

 if (BStructMember( PICINFOX, my ) >= ppicInfo->cbHeader )
    {   /* Scaling multipliers not present */
    ppicInfo->mx = mxMultByOne;
    ppicInfo->my = myMultByOne;
    }

  if (ppicInfo->dyaSize < 0)
  /* 3.1 beta III bug, wrote negative height values */
{
    ppicInfo->dyaSize = -ppicInfo->dyaSize;
#ifdef DEBUG
    OutputDebugString("Negative object height found!\n\r");
#endif
}
}




GetBitmapSize( pdxp, pdyp, ppicInfo, fPrinting )
int *pdxp, *pdyp;
struct PICINFOX *ppicInfo;
int fPrinting;
{   /* Compute the appropriate display or printing (depending on fPrinting)
       size of the bitmap described by the passed PICINFOX structure.
       The interesting fields are:

       ppicInfo->bm.bmWidth, bmHeight   Bitmap size in pixels
       ppicInfo->mfp.xExt, yExt         Desired size in 0.1 mm
       Return the results through *pdxp, *pdyp. */

 long GetBitmapMultipliers();
 extern HDC vhDCPrinter;
 extern int dxaPrPage, dxpPrPage, dyaPrPage, dypPrPage;

 long lT;
 int cx, cy;
 int dxpT, dypT;
 int dxpOrig = ppicInfo->bm.bmWidth;
 int dypOrig = ppicInfo->bm.bmHeight;
 int dxmmIdeal = ppicInfo->mfp.xExt;
 int dymmIdeal = ppicInfo->mfp.yExt;
 Assert(vhDCPrinter);

 /* Scale for printer */

 lT = GetBitmapMultipliers( vhDCPrinter, dxpOrig, dypOrig, dxmmIdeal, dymmIdeal );
 cx = LOWORD( lT );
 cy = HIWORD( lT );
 dxpT = cx * dxpOrig;
 dypT = cy * dypOrig;

 if (!fPrinting)
    {   /* Re-scale for screen */
    dxpT = DxpFromDxa( DxaFromDxp( dxpT, TRUE ), FALSE );
    dypT = DypFromDya( DyaFromDyp( dypT, TRUE ), FALSE );
    }

 /* apply the user's "ideal multiple" of the computed size */

 dxpT = MultDiv( dxpT, ppicInfo->mx, mxMultByOne );
 dypT = MultDiv( dypT, ppicInfo->my, myMultByOne );

 *pdxp = dxpT;
 *pdyp = dypT;
 return;
}


int DxpFromDxa( dxa, fPrinter )
int dxa;
int fPrinter;
{       /* Given twips for an x-axis measurement, return printer
           or logical screen pixels */
 extern int dxpPrPage, dxaPrPage;
 extern int dxpLogInch;

 if (fPrinter)
    return MultDiv( dxa, dxpPrPage, dxaPrPage );
 else
    return MultDiv( dxa, dxpLogInch, czaInch );
}




int DxaFromDxp( dxp, fPrinter )
int dxp;
int fPrinter;
{       /* Given printer or logical screen pixels for an x-axis measurement,
           return twips */
 extern int dxpPrPage, dxaPrPage;
 extern int dxpLogInch;

 if (fPrinter)
    return MultDiv( dxp, dxaPrPage, dxpPrPage );
 else
    return MultDiv( dxp, czaInch, dxpLogInch );
}


int DypFromDya( dya, fPrinter )
int dya;
int fPrinter;
{   /* Given twips for a y-axis measurement, return printer or logical screen
       pixels */
 extern int dypPrPage, dyaPrPage;
 extern int dypLogInch;

 if (fPrinter)
    return MultDiv( dya, dypPrPage, dyaPrPage );
 else
    return MultDiv( dya, dypLogInch, czaInch );
}

int DyaFromDyp( dyp, fPrinter )
int dyp;
int fPrinter;
{   /* Given printer or logical screen pixels for a y-axis measurement,
       return twips */
 extern int dypPrPage, dyaPrPage;
 extern int dypLogInch;

 if (fPrinter)
    return MultDiv( dyp, dyaPrPage, dypPrPage );
 else
    return MultDiv( dyp, czaInch, dypLogInch );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\objreg.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/
/* olereg.h - Contains the header for registration database related calls.
 *
 * Created by Microsoft Corporation.
 */
/* Constants */
#define	CBPATHMAX	250
#define KEYNAMESIZE     300             /* Maximum registration key length */
#define	CLASSES	((LPSTR)".classes")	/* Classes root key */
#define	CFILTERMAX	20			/* Max # filters */
#define	CFILTERLEN	30			/* Max length of one filters */
#define	CBFILTERMAX	(CFILTERLEN * CFILTERMAX)	/* Max # chars/filter */
#define CBMESSAGEMAX 80

/* Function prototypes */
BOOL FAR RegCopyClassName(HWND hwndList, LPSTR lpstrClassName);
void FAR RegGetClassId(LPSTR lpstrName, LPSTR lpstrClass);
BOOL FAR RegGetClassNames(HWND hwndList);
void FAR RegInit(HANDLE hInst);
int  FAR RegMakeFilterSpec(LPSTR lpstrClass, LPSTR lpstrExt, HANDLE *hFilterSpec);
void FAR RegTerm(void);

extern char             szClassName[CBPATHMAX];


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\picture.c ===
/************************************************************/

/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* picture.c -- MW format and display routines for pictures */

//#define NOGDICAPMASKS
#define NOWINMESSAGES
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOCTLMGR
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
//#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOFONT
#define NOMB
#define NOMENUS
#define NOOPENFILE
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#define NOKCCODES
#include "ch.h"
#include "docdefs.h"
#include "fmtdefs.h"
#include "dispdefs.h"
#include "cmddefs.h"
#include "propdefs.h"
#include "stcdefs.h"
#include "wwdefs.h"
#include "filedefs.h"
#include "editdefs.h"
/* #include "str.h" */
#include "prmdefs.h"
/* #include "fkpdefs.h" */
/* #include "macro.h" */
#include "winddefs.h"
#if defined(OLE)
#include "obj.h"
#endif

extern typeCP           cpMacCur;
extern int              docCur;
extern int              vfSelHidden;
extern struct WWD       rgwwd[];
extern int              wwCur;
extern int              wwMac;
extern struct FLI       vfli;
extern struct SEL       selCur;
extern struct WWD       *pwwdCur;
extern struct PAP       vpapCache;
extern typeCP           vcpFirstParaCache;
extern typeCP           vcpLimParaCache;
extern int              vfPictSel;
extern struct PAP       vpapAbs;
extern struct SEP       vsepAbs;
extern struct SEP       vsepPage;
extern struct DOD       (**hpdocdod)[];
extern unsigned         cwHeapFree;
extern int              vfInsertOn;
extern int              vfPMS;
extern int              dxpLogInch;
extern int              dypLogInch;
extern int              dxaPrPage;
extern int              dyaPrPage;
extern int              dxpPrPage;
extern int              dypPrPage;
extern HBRUSH           hbrBkgrnd;
extern long             ropErase;
extern int              vdocBitmapCache;
extern typeCP           vcpBitmapCache;
extern HBITMAP          vhbmBitmapCache;
extern BOOL             vfBMBitmapCache;
extern HCURSOR          vhcIBeam;
extern BOOL             vfMonochrome;


/* Used in this module only */
#ifdef DEBUG
#define STATIC static
#else
#define STATIC
#endif

STATIC RECT rcPictInvalid;  /* Rectangle (in window coords) that needs refresh */
int vfWholePictInvalid = TRUE;


FreeBitmapCache()
{
 vdocBitmapCache = docNil;
 if (vhbmBitmapCache != NULL)
    {
    DeleteObject( vhbmBitmapCache );
    vhbmBitmapCache = NULL;
    }
}




MarkInvalidDlPict( ww, dlPict )
int ww;
int dlPict;
{   /* Mark the passed dl (presumed to be part of a picture) as requiring
       eventual update, when DisplayGraphics is called */

 register struct WWD *pwwd = &rgwwd [ww];
 struct EDL (**hdndl)[] = pwwd->hdndl;
 struct EDL *pedl = &(**hdndl)[ dlPict ];
 RECT rcDl;

 SetRect( (LPRECT) &rcDl, 0, pedl->yp - pedl->dyp,
                          pwwd->xpMac, pedl->yp );

 if (vfWholePictInvalid)
    {
    CopyRect( (LPRECT) &rcPictInvalid, (LPRECT) &rcDl );
    vfWholePictInvalid = FALSE;
    }
 else
    {
    RECT rcT;

    rcT = rcPictInvalid;    /* Necessary?  i.e. can UnionRect handle
                                source == destination */
    UnionRect( (LPRECT) &rcPictInvalid, (LPRECT) &rcT, (LPRECT) &rcDl );
    }
}




DisplayGraphics( ww, dl, fDontDisplay )
int ww;
int dl;
int fDontDisplay;
{       /* Display a line of graphics info */
        struct WWD *pwwd = &rgwwd[ww];
        struct EDL *pedl;
        typeCP cpPictStart;
        typeCP cp;
        typeCP cpMac = (**hpdocdod)[vfli.doc].cpMac;
        struct PICINFOX  picInfo;
        RECT rcEnclose;
        RECT rcPict;
        HANDLE hBits=NULL;
        HDC hMDC=NULL;
        HDC hMDCCache=NULL;
        HANDLE hbm=NULL;
        HDC hDC=pwwd->hDC;
        int cchRun;
        unsigned long cbPict=0;
        int dxpOrig;        /* Size of picture in the original */
        int dypOrig;
        int dxpDisplay;     /* Size of picture as we want to show it */
        int dypDisplay;
        int fBitmap;
        int ilevel=0;
    
        /* THIS ROUTINE COULD USE SOME GDI-CALL ERROR CHECKING!  ..pault */

        int fDrew=false;

        /* In the case of monochrome devices, this raster op will map white in
        the bitmap to the background color and black to the foreground color. */
        #define ropMonoBm 0x00990066

        Assert( dl >= 0 && dl < pwwd->dlMax );

        MarkInvalidDlPict( ww, dl );

        if (fDontDisplay)
            {
            return;
            }

        Diag(CommSz("DisplayGraphics:       \n\r"));

        FreezeHp();
        pedl = &(**(pwwd->hdndl))[dl];
        cpPictStart=pedl->cpMin;

        GetPicInfo( cpPictStart, cpMac, vfli.doc, &picInfo );

        /* Compute desired display size of picture (in device pixels) */

        ComputePictRect( &rcPict, &picInfo, pedl, ww );
        dxpDisplay = rcPict.right - rcPict.left;
        dypDisplay = rcPict.bottom - rcPict.top;

        /* Compute original size of picture (in device pixels) */
        /* MM_ANISOTROPIC and MM_ISOTROPIC pictures have no original size */

        switch ( picInfo.mfp.mm ) {
            case MM_ISOTROPIC:
            case MM_ANISOTROPIC:
                break;
            case MM_BITMAP:
                dxpOrig = picInfo.bm.bmWidth;
                dypOrig = picInfo.bm.bmHeight;
                break;
#if defined(OLE)
            case MM_OLE:
            {
                extern BOOL vfObjDisplaying;

                if (lpOBJ_QUERY_INFO(&picInfo) == NULL)
                        goto DontDraw;

                /* just to be safe */
                if (!CheckPointer(lpOBJ_QUERY_INFO(&picInfo),1))
                    goto DontDraw;

                if (lpOBJ_QUERY_OBJECT(&picInfo) == NULL)
                {
                    typeCP cpRet;

                    /* this can require memory, so unlock heap */
                    MeltHp();
                    vfObjDisplaying = TRUE;

                    cpRet = ObjLoadObjectInDoc(&picInfo,vfli.doc,cpPictStart);

                    vfObjDisplaying = FALSE;
                    FreezeHp();
                    pedl = &(**(pwwd->hdndl))[dl];

                    if (cpRet == cp0)
                        goto DontDraw;
                }
            }
            break;
#endif
            default:
                dxpOrig = PxlConvert( picInfo.mfp.mm, picInfo.mfp.xExt,
                                      GetDeviceCaps( hDC, HORZRES ),
                                      GetDeviceCaps( hDC, HORZSIZE ) );
                dypOrig = PxlConvert( picInfo.mfp.mm, picInfo.mfp.yExt,
                                      GetDeviceCaps( hDC, VERTRES ),
                                      GetDeviceCaps( hDC, VERTSIZE ) );
                if (! (dxpOrig && dypOrig) )
                    {
                    goto DontDraw;
                    }
                break;
            }

        /* Save DC as a guard against DC attribute alteration by a metafile */
#ifdef WINDOWS_BUG_FIXED    /* Currently 0 is a valid level for Own DC's */
        if ((ilevel=SaveDC( hDC )) == 0)
            goto DontDraw;
#endif
        ilevel = SaveDC( hDC );
        SetStretchBltMode( hDC, BLACKONWHITE );

        /* Clip out top bar, selection bar */

        IntersectClipRect( hDC, ((wwCur == wwClipboard) ? 0 : xpSelBar),
                           pwwdCur->ypMin, pwwdCur->xpMac, pwwdCur->ypMac );

        if (!vfWholePictInvalid)
                /* Repainting less than the whole picture; clip out
                   what we're not drawing */
            IntersectClipRect( hDC, rcPictInvalid.left, rcPictInvalid.top,
                                    rcPictInvalid.right, rcPictInvalid.bottom );

        /* Build rcEnclose, a rect enclosing the picture that
           includes the "space before" and "space after" fields */

        rcEnclose.left = xpSelBar;
        if ((rcEnclose.top = rcPict.top -
                        DypFromDya( vpapAbs.dyaBefore, FALSE )) < pwwd->ypMin)
            rcEnclose.top = pwwd->ypMin;
        rcEnclose.right = pwwd->xpMac;
        if ((rcEnclose.bottom = rcPict.bottom +
                        DypFromDya( vpapAbs.dyaAfter, FALSE )) > pwwd->ypMac)
            rcEnclose.bottom = pwwd->ypMac;

        /* White out enclosing rect */

        PatBlt( hDC, rcEnclose.left, rcEnclose.top,
                     rcEnclose.right - rcEnclose.left,
                     rcEnclose.bottom - rcEnclose.top, ropErase );

        /* If we have it cached, do display the easy way */

        if (pwwd->doc == vdocBitmapCache &&  cpPictStart == vcpBitmapCache)
            {
            Assert( pwwd->doc != docNil && vhbmBitmapCache != NULL);

            if ( ((hMDC = CreateCompatibleDC( hDC )) != NULL) &&
                 SelectObject( hMDC, vhbmBitmapCache ))
                {
                Diag(CommSz("DisplayGraphics: BitBlt\n\r"));
                BitBlt( hDC, rcPict.left, rcPict.top, dxpDisplay, dypDisplay,
                             hMDC, 0, 0, vfMonochrome && vfBMBitmapCache ?
                             ropMonoBm : SRCCOPY );
                fDrew = TRUE;
                goto DontDraw;
                }
            else
                {   /* Using the cache failed -- empty it
                       (SelectObject will fail if bitmap was discarded) */
                FreeBitmapCache();
                }
            }

        StartLongOp();  /* Put up an hourglass */

        /* Build up all bytes associated with the picture (except the header)
           into the global Windows handle hBits */

        if ( picInfo.mfp.mm != MM_OLE)
        {
        if ((hBits=GlobalAlloc( GMEM_MOVEABLE, (long)picInfo.cbSize )) == NULL)
            {    /* Not enough global heap space to load bitmap/metafile */
            goto DontDraw;
            }

#ifdef DCLIP    
        {
        char rgch[200];
        wsprintf(rgch,"DisplayGraphics: picinfo.cbSize %lu \n\r", picInfo.cbSize);
        CommSz(rgch);
        }
#endif

        for ( cbPict = 0, cp = cpPictStart + picInfo.cbHeader;
              cbPict < picInfo.cbSize;
              cbPict += cchRun, cp += (typeCP) cchRun )
            {
            CHAR rgch[ 256 ];
#if WINVER >= 0x300            
            HPCH lpch;
#else            
            LPCH lpch;
#endif

#define ulmin(a,b)      ((unsigned long)(a) < (unsigned long)(b) ? \
                          (unsigned long)(a) : (unsigned long)(b))

            FetchRgch( &cchRun, rgch, vfli.doc, cp, cpMac,
                                 (int) ulmin( picInfo.cbSize - cbPict, 256 ) );
            if ((lpch=GlobalLock( hBits )) != NULL)
                {
#ifdef DCLIP    
            {
            char rgch[200];
            wsprintf(rgch," copying %d bytes from %lX to %lX \n\r",cchRun,(LPSTR)rgch,lpch+cbPict);
            CommSz(rgch);
            }

            {
            char rgchT[200];
            int i;
            for (i = 0; i< min(20,cchRun); i++,i++)
                {
                wsprintf(rgchT,"%X ",* (int *) &(rgch[i]));
                CommSz(rgchT);
                }
            CommSz("\n\r");
            }
#endif
#if WINVER >= 0x300                
                bltbh( (LPSTR)rgch, lpch+cbPict, cchRun );
#else
                bltbx( (LPSTR)rgch, lpch+cbPict, cchRun );
#endif
                GlobalUnlock( hBits );
                }
            else
                {
                goto DontDraw;
                }
            }
        }


        /* Display the picture */

        MeltHp();

#if defined(OLE)
        /* CASE 0: OLE */
        if (picInfo.mfp.mm == MM_OLE)
        {
            Diag(CommSz("Case 0:\n\r"));
            if (ObjDisplayObjectInDoc(&picInfo, vfli.doc, cpPictStart,
                            hDC, &rcPict) == FALSE)
                goto DontDraw;
            fDrew = true;
        }
        else
#endif
        /* CASE 1: Bitmap */
        if (fBitmap = (picInfo.mfp.mm == MM_BITMAP))
            {
            Diag(CommSz("Case 1: \n\r"));
            if ( ((hMDC = CreateCompatibleDC( hDC )) != NULL) &&
                 ((picInfo.bm.bmBits = GlobalLock( hBits )) != NULL) &&
                 ((hbm=CreateBitmapIndirect((LPBITMAP)&picInfo.bm))!=NULL))
                {
                picInfo.bm.bmBits = NULL;
                GlobalUnlock( hBits );
                GlobalFree( hBits ); /* Free handle to bits to allow max room */
                hBits = NULL;
                SelectObject( hMDC, hbm );

                goto CacheIt;
                }
            }

        /* Case 2: non-scalable metafile pictures which we are, for
           user interface consistency, scaling by force using StretchBlt */

        else if ( ((dxpDisplay != dxpOrig) || (dypDisplay != dypOrig)) &&
                  (picInfo.mfp.mm != MM_ISOTROPIC) &&
                  (picInfo.mfp.mm != MM_ANISOTROPIC) )
           {

            Diag(CommSz("Case 2: \n\r"));
           if (((hMDC=CreateCompatibleDC( hDC)) != NULL) &&
               ((hbm=CreateCompatibleBitmap( hDC, dxpOrig, dypOrig ))!=NULL) &&
               SelectObject( hMDC, hbm ) && SelectObject( hMDC, hbrBkgrnd ))
                {
                extern int vfOutOfMemory;

                PatBlt( hMDC, 0, 0, dxpOrig, dypOrig, ropErase );
                SetMapMode( hMDC, picInfo.mfp.mm );
                    /* To cover StretchBlt calls within the metafile */
                SetStretchBltMode( hMDC, BLACKONWHITE );
                PlayMetaFile( hMDC, hBits );
                    /* Because we pass pixels to StretchBlt */
                SetMapMode( hMDC, MM_TEXT );

CacheIt:        Assert( hbm != NULL && hMDC != NULL );

                if (vfOutOfMemory)
                    goto NoCache;
#ifndef NOCACHE
                FreeBitmapCache();
                /* Among other things, this code caches the current picture.
                Notice that there are two assumptions: (1) all bitmaps are
                monochrome, and (2) a newly created memory DC has a monochrome
                bitmap selected in. */
                if ( ((hMDCCache = CreateCompatibleDC( hDC )) != NULL) &&
                     ((vhbmBitmapCache = CreateDiscardableBitmap(
                       fBitmap ? hMDCCache : hDC, dxpDisplay, dypDisplay )) !=
                       NULL) &&
                     SelectObject( hMDCCache, vhbmBitmapCache ))
                        {
                        if (!StretchBlt( hMDCCache, 0, 0, dxpDisplay,
                          dypDisplay, hMDC, 0, 0, dxpOrig, dypOrig, SRCCOPY ))
                            {   /* may get here if memory is low */
                            DeleteDC( hMDCCache );
                            hMDCCache = NULL;
                            DeleteObject( vhbmBitmapCache );
                            vhbmBitmapCache = NULL;
                            goto NoCache;
                            }

#ifdef DCLIP            
            if (vfMonochrome && fBitmap)
                CommSzNum("BitBlt using ropMonoBm == ",ropMonoBm);
#endif

                        BitBlt( hDC, rcPict.left, rcPict.top, dxpDisplay,
                          dypDisplay, hMDCCache, 0, 0, vfMonochrome && fBitmap ?
                          ropMonoBm : SRCCOPY );

                            /* Cached bitmap OK, make cache valid */
                        vdocBitmapCache = pwwd->doc;
                        vcpBitmapCache = cpPictStart;
                        vfBMBitmapCache = fBitmap;
                        }
                else
#endif  /* ndef NOCACHE */
                    {
NoCache:
                    StretchBlt( hDC, rcPict.left, rcPict.top,
                                dxpDisplay, dypDisplay,
                                hMDC, 0, 0, dxpOrig, dypOrig, vfMonochrome &&
                                fBitmap ? ropMonoBm : SRCCOPY );
                    }
                fDrew = TRUE;
                }
            }

        /* Case 3: A metafile picture which can be directly scaled
           or does not need to be because its size has not changed */
        else
            {
            fDrew = true;
            Diag(CommSz("Case 3:\n\r"));
            SetMapMode( hDC, picInfo.mfp.mm );

            SetViewportOrg( hDC, rcPict.left, rcPict.top );
            switch( picInfo.mfp.mm ) {
                case MM_ISOTROPIC:
                    if (picInfo.mfp.xExt && picInfo.mfp.yExt)
                        /* So we get the correct shape rectangle when
                           SetViewportExt gets called */
                        SetWindowExt( hDC, picInfo.mfp.xExt, picInfo.mfp.yExt );
                    /* FALL THROUGH */
                case MM_ANISOTROPIC:
                    /** (9.17.91) v-dougk 
                        Set the window extent in case the metafile is bad 
                        and doesn't call it itself.  This will prevent
                        possible gpfaults in GDI
                     **/
                    SetWindowExt( hDC, dxpDisplay, dypDisplay );

                    SetViewportExt( hDC, dxpDisplay, dypDisplay );
                    break;
                }

            PlayMetaFile( hDC, hBits );
            }
DontDraw:

        /* Clean up */
        if ( *(pLocalHeap+1) )
            MeltHp();

        if (ilevel > 0)
            RestoreDC( hDC, ilevel );
        if (hMDCCache != NULL)
            DeleteDC( hMDCCache );
        if (hMDC != NULL)
            DeleteDC( hMDC );
        if (hbm != NULL)
            DeleteObject( hbm );
        if (hBits != NULL)
            {
            if (fBitmap && picInfo.bm.bmBits != NULL)
                GlobalUnlock( hBits );
            GlobalFree( hBits );
            }

        if (!fDrew)
        {
            void DrawBlank(HDC hDC, RECT FAR *rc);
            DrawBlank(hDC,&rcPict);
        }   

        /* Invert the selection */
        if (ww == wwDocument && !vfSelHidden && !vfPMS)
            {
            extern int vypCursLine;

            ilevel = SaveDC( hDC );  /* Because of clip calls below */

            if (!vfWholePictInvalid)
                    /* Repainting less than the whole picture; clip out
                       what we're not drawing */
                IntersectClipRect( hDC, rcPictInvalid.left, rcPictInvalid.top,
                                   rcPictInvalid.right, rcPictInvalid.bottom );

            /* Clip out top bar, selection bar */

            IntersectClipRect( hDC, xpSelBar,
                           pwwdCur->ypMin, pwwdCur->xpMac, pwwdCur->ypMac );

            if (selCur.cpLim > cpPictStart && selCur.cpFirst <= cpPictStart)
                { /* Take into account 'space before' field */
                rcEnclose.left = rcPict.left;
                rcEnclose.right = rcPict.right;
                InvertRect( hDC, (LPRECT) &rcEnclose );
                }
            else if ((selCur.cpLim == selCur.cpFirst) &&
                     (selCur.cpFirst == cpPictStart) &&
                     (vfWholePictInvalid || rcPictInvalid.top < vypCursLine))
                {   /* We erased the insert point */
                vfInsertOn = fFalse;
                }
            RestoreDC( hDC, ilevel );
            }

        vfWholePictInvalid = TRUE;   /* Next picture, start invalidation anew */
        {
        extern int vfPMS;
        extern HCURSOR vhcPMS;


        EndLongOp( vfPMS ? vhcPMS : vhcIBeam );
        }
}


#ifdef ENABLE   /* Don't use this anymore */
int
FPointInPict(pt)
POINT pt;
{       /* Return true if point is within the picture frame */
struct EDL      *pedl;
struct PICINFOX  picInfo;
RECT rcPict;

GetPicInfo(selCur.cpFirst, cpMacCur, docCur, &picInfo);

if (!FGetPictPedl(&pedl))
        return false;

ComputePictRect( &rcPict, &picInfo, pedl, wwCur );

return PtInRect( (LPRECT)&rcPict, pt );
}
#endif  /* ENABLE */


/* C O M P U T E  P I C T  R E C T */
ComputePictRect( prc, ppicInfo, pedl, ww )
RECT *prc;
register struct PICINFOX  *ppicInfo;
struct EDL      *pedl;
int     ww;
{       /* Compute rect containing picture indicated by passed ppicInfo,
           pedl, in the indicated ww. Return the computed rect through
           prc.  picInfo structure is not altered. */

        int dypTop, xaLeft;
        struct WWD *pwwd = &rgwwd[ww];
        int xaStart;
        int dxaText, dxa;
        int dxpSize, dypSize;
        int dxaSize, dyaSize;

        CacheSectPic(pwwd->doc, pedl->cpMin);

        if (ppicInfo->mfp.mm == MM_BITMAP && ((ppicInfo->dxaSize == 0) ||
                                              (ppicInfo->dyaSize == 0)))
            {
            GetBitmapSize( &dxpSize, &dypSize, ppicInfo, FALSE );
            dxaSize = DxaFromDxp( dxpSize, FALSE );
            dyaSize = DyaFromDyp( dypSize, FALSE );
            }
#if defined(OLE)
        else if (ppicInfo->mfp.mm == MM_OLE)
        {
            dxpSize = DxpFromDxa(ppicInfo->dxaSize, FALSE );
            dypSize = DypFromDya(ppicInfo->dyaSize, FALSE );
            dxpSize = MultDiv( dxpSize, ppicInfo->mx, mxMultByOne );
            dypSize = MultDiv( dypSize, ppicInfo->my, myMultByOne );
            dxaSize = DxaFromDxp( dxpSize, FALSE );
            dyaSize = DyaFromDyp( dypSize, FALSE );
        }
#endif
        else
            {

            dxpSize = DxpFromDxa( dxaSize = ppicInfo->dxaSize, FALSE );
            dypSize = DypFromDya( dyaSize = ppicInfo->dyaSize, FALSE );
            }

        dypTop = pedl->dcpMac != 0 ?
                /* Last line of picture */
            DypFromDya( dyaSize + vpapAbs.dyaAfter, FALSE ) :
            (pedl->ichCpMin + 1) * dypPicSizeMin;
        dypTop = pedl->yp - dypTop;

        xaStart = DxaFromDxp( xpSelBar - (int) pwwd->xpMin, FALSE );
        dxaText = vsepAbs.dxaText;
        switch (vpapAbs.jc)
                {
        case jcBoth:
        case jcLeft:
                dxa = ppicInfo->dxaOffset;
                break;
        case jcCenter:
                dxa = (dxaText - (int)vpapAbs.dxaRight + (int)vpapAbs.dxaLeft -
                        dxaSize) / 2;
                break;
        case jcRight:
                dxa = dxaText - (int)vpapAbs.dxaRight - dxaSize;
                break;
                }

        xaLeft = xaStart + max( (int)vpapAbs.dxaLeft, dxa );

        prc->right = (prc->left = DxpFromDxa( xaLeft, FALSE )) + dxpSize;
        prc->bottom = (prc->top = dypTop) + dypSize;
}

FGetPictPedl(ppedl)
struct EDL      **ppedl;
{
int dlLim = pwwdCur->dlMac;
int     dl;
typeCP  cpFirst = selCur.cpFirst;
struct EDL      *pedl;

//Assert(vfPictSel);

if (!vfPictSel)
    return FALSE;

pedl = &(**(pwwdCur->hdndl)[0]);

for (dl = 0; dl < dlLim; ++dl, ++pedl)
        {
        //if (!pedl->fValid)
                //return false;

        if (pedl->cpMin == cpFirst)
                break;
        }
if (dl >= dlLim)
        return false;   /* No part of picture is on screen */

*ppedl = pedl;
return true;
}




/* C P  W I N  G R A P H I C */
typeCP CpWinGraphic(pwwd)
struct WWD *pwwd;
        {
        int cdlPict, dl;
        struct EDL *dndl = &(**(pwwd->hdndl))[0];

        Assert( !pwwd->fDirty );    /* So we can rely on dl info */
        CachePara(pwwd->doc, dndl->cpMin);
        for (dl = 0; (dl < pwwd->dlMac - 1 && dndl[dl].fIchCpIncr); ++dl)
                ;
        Assert(dndl[dl].fGraphics);
        cdlPict = dndl[dl].ichCpMin + 1;
        return (dndl[0].cpMin +
                (vcpLimParaCache - vcpFirstParaCache) * dndl[0].ichCpMin / cdlPict);
        }




CacheSectPic(doc, cp)
int doc;
typeCP cp;
{ /* Cache section and para props, taking into account that footnotes take props
                                        from the reference point */
#ifdef FOOTNOTES
struct DOD *pdod = &(**hpdocdod)[doc];
struct FNTB (**hfntb) = pdod->hfntb;
#endif

CachePara(doc, cp);

#ifdef FOOTNOTES
if ( (hfntb != 0) && (cp >= (**hfntb).rgfnd[0].cpFtn) )
    CacheSect( doc, CpRefFromFtn( doc, cp ) )
else
#endif
    CacheSect(doc, cp); /* Normal text */
}


void DrawBlank(HDC hDC, RECT FAR *rc)
{   /* To tell us when the draw tried but failed */
    int xpMid=rc->left + (rc->right-rc->left)/2;
    int ypMid=rc->top + (rc->bottom - rc->top)/2;
    int dxpQ=(rc->right-rc->left)/4;
    int dypQ=(rc->bottom-rc->top)/4;
    HPEN hOldPen;
    HBRUSH hOldBrush;

    hOldPen = SelectObject( hDC, GetStockObject( BLACK_PEN ) );
    hOldBrush = SelectObject( hDC, GetStockObject( WHITE_BRUSH ) );
    Rectangle(hDC,rc->left,rc->top,rc->right,rc->bottom);
    MoveTo( hDC, rc->left, rc->top );
    LineTo( hDC, rc->right, rc->bottom );
    MoveTo( hDC, rc->left, rc->bottom );
    LineTo( hDC, rc->right, rc->top );
    MoveTo( hDC, xpMid, rc->top );
    LineTo( hDC, xpMid, rc->bottom );
    MoveTo( hDC, rc->left, ypMid );
    LineTo( hDC, rc->right, ypMid );
    Ellipse( hDC,
                xpMid-dxpQ, ypMid-dypQ,
                xpMid+dxpQ, ypMid+dypQ );
    SelectObject( hDC, hOldPen );
    SelectObject( hDC, hOldBrush );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\preload.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/*----------------TASK ENUMERATED TYPE FOR CODE PRELOAD-----------------*/

#define tskMin      0
#define tskMax      3

#define tskInsert   0   /* Insert, backspace, cursoring */
#define tskFormat   1   /* Char dropdown, formatting, fonts */
#define tskScrap    2   /* Edit dropdown, cut/paste, clipboard */

/*----------------------------------------------------------------------*/

void PreloadCodeTsk( int );

/* Macros for function preloading */

#define LoadWindowsF(f)      GetCodeHandle( (FARPROC) f )
#define LoadF(f)             {  int f();  GetCodeHandle( (FARPROC) f );  }

#define LCBAVAIL             0x00030D40 /* 200K */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\print2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* These routines are the guts of the text print code. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOATOM
#define NOFONT
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOMB
#define NOOPENFILE
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>
#include "mw.h"
#include "printdef.h"
#include "fmtdefs.h"
#include "propdefs.h"
#include "fontdefs.h"
#include "docdefs.h"
#define NOKCCODES
#include "ch.h"
#include "debug.h"
#include "str.h"

#if defined(JAPAN) || defined(KOREA)                  //  added  01 Jul. 1992  by Hiraisi
#include "kanji.h"
#endif

BOOL FPrintBand(doc, hrgpld, cpld, prcBand)
int doc;
struct PLD (**hrgpld)[];
int cpld;
PRECT prcBand;
    {
    /* This routine prints the lines in document doc that any part of which fall
    in the rectange *prcBand.  The first cpld print line descriptors in hrgpld
    describe the current page in the document that will be printed.  TRUE is
    returned if the band is printed, FALSE otherwise. */

    void PrintGraphics(int, int);
    void near PrintFli(int, int);

    extern struct DOD (**hpdocdod)[];
    extern struct FLI vfli;
    extern int vfOutOfMemory;
    extern FARPROC lpFPrContinue;

    int ipld;
    typeCP cpMac = (**hpdocdod)[doc].cpMac;

    for (ipld = 0; ipld < cpld; ipld++)
        {
        register struct PLD *ppld;

        /* Check for user cancellation. */
        if (!(*lpFPrContinue)(NULL, wNotSpooler))
            {
            return (FALSE);
            }

        /* Is this line within the band? */
        ppld = &(**hrgpld)[ipld];
        if (ppld->rc.top < prcBand->bottom && ppld->rc.bottom > prcBand->top &&
          ppld->rc.left < prcBand->right && ppld->rc.right > prcBand->left)
            {
            /* Format this line for the printer. */
            FormatLine(doc, ppld->cp, ppld->ichCp, cpMac, flmPrinting);

            /* If memory failure occurred, then punt. */
            if (vfOutOfMemory)
                {
                return (FALSE);
                }

            /* Reset the pointer to the print line descriptors (possible heap
            movement in FormatLine()). */
            ppld = &(**hrgpld)[ipld];

            /* Print this line. */
            if (vfli.fGraphics)
                {
                PrintGraphics(ppld->rc.left, ppld->rc.top);
                }
            else
                {
                PrintFli(ppld->rc.left, ppld->rc.top);
                }
            }
        }
    return (TRUE);
    }


void near PrintFli(xpPrint, ypPrint)
int xpPrint;
int ypPrint;
    {
    /* This routine prints the line of text stored in the vfli structure at
    position (xpPrint, ypPrint). */

#ifdef	KOREA  // jinwoo: 92, 9, 28
     /* process Subscript separatedly from descent 920605 KDLEE*/
    extern int isSubs;
#endif  /* KOREA */
    extern HDC vhDCPrinter;
    extern struct FLI vfli;
    extern struct DOD (**hpdocdod)[];
    extern struct CHP (**vhgchpFormat)[];
    extern int dxpPrPage;
    extern int dypPrPage;
    extern int ypSubSuperPr;
    extern CHAR stBuf[];
    extern struct FMI vfmiPrint;
    extern typeCP cpMinDocument;
    extern int vpgn;

    int dcp;
    int dxp;            /* Width of current run */
    int dxpExtra;       /* Width of pad for each space */
    int yp;             /* Y-coordinate to print at. */
    struct CHP *pchp;   /* CHP associated with the current run */
    BOOL fTabsKludge = (vfli.ichLastTab >= 0);
    int cBreakRun;              /* break characters in run (no relation to Dick or Jane) */

#if defined(JAPAN) || defined(KOREA)                  //  added  04 Jul. 1992  by Hiraisi
    extern struct PAP vpapAbs;
    extern int vfWordWrap;    /* WordWrap flag : TRUE=ON, FALSE=OFF */
    extern int iNonWideSpaces;
    int iRun;
#endif

    Scribble(5,'P');
    Assert(vhDCPrinter);

    pchp = &(**vhgchpFormat)[0];
    dxpExtra = fTabsKludge ? 0 : vfli.dxpExtra;

#if defined(JAPAN) || defined(KOREA)                  //  added  04 Jul. 1992  by Hiraisi
    iRun = 0;
#endif
    for (dcp = 0; dcp < vfli.ichReal; pchp++)
        {
        /* For all runs do: */
        int ichFirst;   /* First character in the current run */
        int cchRun;     /* Number of characters in the current run */

        dcp = ichFirst = pchp->ichRun;
        dcp += pchp->cchRun;
        if (dcp > vfli.ichReal)
            {
            dcp = vfli.ichReal;
            }
        cchRun = dcp - ichFirst;

        /* Compute dxp = sum of width of characters in current run (formerly
        DxpFromIcpDcp). */
            {
            register int *pdxp;
            register int cchT = cchRun;
            PCH pch = vfli.rgch + ichFirst;

            dxp = cBreakRun = 0;
            pdxp = &vfli.rgdxp[ichFirst];
            while (cchT-- > 0)
                {
                dxp += *pdxp++;
                if (*pch++ == chSpace)
                    ++cBreakRun;
                }
            }

        if (dxp > 0)
            {
            int cchDone;
            PCH pch = &vfli.rgch[ichFirst];
#if defined(JAPAN) || defined(KOREA)                  //  added  08 Jul. 1992  by Hiraisi
            int *pdxpT = &vfli.rgdxp[ichFirst];
#endif

            LoadFont(vfli.doc, pchp, mdFontPrint);
#ifdef	KOREA	/* 920605 KDLEE */  // jinwoo: 92, 9, 28
#ifdef	NODESC
		yp = ypPrint+vfli.dypLine - (vfli.dypBase + (pchp->hpsPos != 0 ? (pchp->hpsPos <
		     hpsNegMin ? ypSubSuperPr : -ypSubSuperPr) : 0)) -
		     vfmiPrint.dypBaseline - ( isSubs ? ypSubSuperPr : 0 );
#else	/* NODESC */
            yp = ypPrint + vfli.dypLine - vfli.dypBase - (pchp->hpsPos != 0 ?
              (pchp->hpsPos < hpsNegMin ? ypSubSuperPr : -ypSubSuperPr) : 0) -
	      vfmiPrint.dypBaseline;
#endif	/* NODESC */
#else   /* KOREA */
            yp = ypPrint + vfli.dypLine - vfli.dypBase - (pchp->hpsPos != 0 ?
              (pchp->hpsPos < hpsNegMin ? ypSubSuperPr : -ypSubSuperPr) : 0) -
              vfmiPrint.dypBaseline;
#endif  /* KOREA */

            /* Note: tabs and other special characters are guaranteed to come at
            the start of a run. */
#ifdef JAPAN                  //  added  01 Jul. 1992  by Hiraisi
            if( vpapAbs.jc != jcBoth || fTabsKludge )
              SetTextJustification(vhDCPrinter, dxpExtra*cBreakRun, cBreakRun);
#else
            SetTextJustification(vhDCPrinter, dxpExtra * cBreakRun, cBreakRun);
#endif /* JAPAN */
            cchDone = 0;
            while (cchDone < cchRun)
                {
                int cch;

                /* Does the wide-space zone begin in this run? */
                if (vfli.fAdjSpace && (vfli.ichFirstWide < ichFirst + cchRun) &&
                  (ichFirst + cchDone <= vfli.ichFirstWide))
                    {
                    int cchDoneT = cchDone;

                    /* Is this the beginning of the wide-space zone? */
                    if (ichFirst + cchDone == vfli.ichFirstWide)
                        {
                        /* Reset the width of the spaces. */
#ifdef JAPAN                  //  added  01 Jul. 1992  by Hiraisi
                        if( vpapAbs.jc != jcBoth || fTabsKludge )
                            SetTextJustification(vhDCPrinter, ++dxpExtra*cBreakRun, cBreakRun);
#else
                        SetTextJustification(vhDCPrinter, ++dxpExtra * cBreakRun, cBreakRun);
#endif /* JAPAN */
                        cch = cchRun - cchDone;
                        cchDone = cchRun;
                        }
                    else
                        {
                        cchDone = cch = vfli.ichFirstWide - ichFirst;
                        }

                    /* This run is cut short because of a wide space, so we need
                    to calculate a new width. */
                        {
                        register int *pdxp;
                        register int cchT = cch;
                        PCH pch = &vfli.rgch[ichFirst + cchDoneT];

                        dxp = 0;
                        pdxp = &vfli.rgdxp[ichFirst + cchDoneT];
                        while (cchT-- > 0)
                            {
                            dxp += *pdxp++;
                            if (*pch++ == chSpace)
                                ++cBreakRun;
                            }
                        }
                    }
                else
                    {
                    cchDone = cch = cchRun;
                    }

                while (cch > 0)
                    {
                    switch (*pch)
                        {
                        CHAR ch;
                        int dxpT;

                    case chTab:

#ifdef CASHMERE
                        /* chLeader contains tab leader character (see
                        FormatLine) */
                        if ((ch = pchp->chLeader) != chSpace)
                            {
                            int cxpTab;
                            CHAR rgch[32];
                            int dxpLeader = DxpFromCh(ch, TRUE);
                            int xp = xpPrint;
                            int iLevelT = SaveDC(vhDCPrinter);

                            SetBytes(&rgch[0], ch, 32);
                            dxpT = vfli.rgdxp[ichFirst];
                            cxpTab = ((dxpT + dxpLeader - 1) / dxpLeader + 31)
                              >> 5;
#ifdef CLIP
                            IntersectClipRect(vhDCPrinter, xpPrint, 0, xpPrint +
                              dxpT, vfli.dypLine);
#endif

                            while (cxpTab-- > 0)
                                {
                                TextOut(vhDCPrinter, xp, yp, (LPSTR)rgch,
                                  32);
                                xp += dxpLeader << 5;
                                }
                            RestoreDC(vhDCPrinter, iLevelT);
                            xpPrint += dxpT;
                            }
                        else
#endif /* CASHMERE */

                            {
                            xpPrint += vfli.rgdxp[ichFirst];
                            }

                        if (fTabsKludge && ichFirst >= vfli.ichLastTab)
                            {
#ifdef JAPAN                  //  added  01 Jul. 1992  by Hiraisi
                            if( vpapAbs.jc != jcBoth )
                                SetTextJustification(vhDCPrinter, (dxpExtra =
                                       vfli.dxpExtra) *cBreakRun, cBreakRun);
                            else
                                dxpExtra = vfli.dxpExtra;
#else
                            SetTextJustification(vhDCPrinter, (dxpExtra =
                              vfli.dxpExtra) * cBreakRun, cBreakRun);
#endif /* JAPAN */
                            fTabsKludge = FALSE;
                            }
                        dxp -= vfli.rgdxp[ichFirst];
                        pch++;
                        cch--;
#if defined(JAPAN) || defined(KOREA)                  //  added  04 Jul. 1992  by Hiraisi
                        iRun++;
                        pdxpT++;
#endif
                        goto EndLoop;

#ifdef CASHMERE
                    case schPage:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = CchExpPgn(&stBuf[1], vpgn, vsepAbs.nfcPgn,
                          flmPrinting, ichMaxLine);
                        goto DrawSpecial;

                    case schFootnote:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = CchExpFtn(&stBuf[1], cpMin + ichFirst,
                          flmPrinting, ichMaxLine);
DrawSpecial:
#else /* not CASHMERE */
                    case schPage:
                    case schFootnote:
                        if (!pchp->fSpecial)
                            {
                            goto EndLoop;
                            }
                        stBuf[0] = *pch == schPage && vfli.cpMin + ichFirst <
                          cpMinDocument ? CchExpPgn(&stBuf[1], vpgn, 0,
                          flmPrinting, ichMaxLine) : CchExpUnknown(&stBuf[1],
                          flmPrinting, ichMaxLine);
#endif /* not CASHMERE */

                        TextOut(vhDCPrinter, xpPrint, yp, (LPSTR)&stBuf[1],
                          stBuf[0]);
                        break;

                    default:
                        goto EndLoop;
                        }
                    dxp -= vfli.rgdxp[ichFirst];
                    xpPrint += vfli.rgdxp[ichFirst++];
                    pch++;
                    cch--;
#if defined(JAPAN) || defined(KOREA)                  //  added  09 Jul. 1992  by Hiraisi
                    pdxpT++;
#endif
                    }
EndLoop:

                /* Output cch characters starting at pch */
#if 0
            {
                char msg[180];
                wsprintf(msg,"putting out %d characters\n\r",cch);
                OutputDebugString(msg);
            }
#endif

#ifdef JAPAN                  //  added  01 Jul. 1992  by Hiraisi
                if( vpapAbs.jc == jcBoth && !fTabsKludge ){
                   CHAR *ptr1, *ptr2;
                   int len, cnt;
                   int iExtra, iSpace, iWid;
                   BOOL bFlag;
                   ptr2 = pch;
                   for( cnt=0 ; cnt<cch ; ){
                      ptr1 = ptr2;
                      iExtra = dxpExtra;
                      iWid = len = 0;
                      bFlag = TRUE;
                      if( IsDBCSLeadByte( *ptr2 ) ){
                         for( ; cnt<cch ; ){
                            iWid += *pdxpT;
                            pdxpT+=2;
                            cnt+=2;
                            len += 2;
                            iRun += 2;
                            ptr2 += 2;
                            if( --iNonWideSpaces == 0){
                               dxpExtra++;
                               break;
                            }
                            if( iRun == dcp-2 )
                               break;
                            if( iRun == dcp ){    /* last DBC (maybe) */
                               iExtra = 0;
                               break;
                            }
                            if( !IsDBCSLeadByte( *ptr2 ) )
                               break;
                         }
                      }
                      else{
                         if( FKana( (int)*ptr2 ) ){
                            for( ; cnt<cch ; ){
                               iWid += *pdxpT++;
                               cnt++;
                               len++;
                               iRun++;
                               ptr2++;
                               if( --iNonWideSpaces == 0){
                                  dxpExtra++;
                                  break;
                               }
                               if( iRun == dcp-1 )
                                  break;
                               if( iRun == dcp ){    /* last SBC (maybe) */
                                  iExtra = 0;
                                  break;
                               }
                               if( !FKana( (int)*ptr2 ) )
                                  break;
                            }
                         }
                         else{
                            for( bFlag=FALSE,iSpace = 0 ; cnt<cch ; ){
                               iWid += *pdxpT++;
                               cnt++;
                               len++;
                               iRun++;
                               if( *ptr2++ == chSpace || !vfWordWrap ){
                                   iSpace++;
                                   if( --iNonWideSpaces == 0){
                                       dxpExtra;
                                       break;
                                   }
                               }
                               if( iRun == dcp-1 )
                                  break;
                               if( iRun == dcp ){    /* last SBC (maybe) */
                                  iExtra = 0;
                                  break;
                               }
                               if( IsDBCSLeadByte( *ptr2 ) ||
                                  FKana( (int)*ptr2 ) )
                                  break;
                            }
                         }
                      }
                      if( vfWordWrap && !bFlag ){
                         SetTextCharacterExtra( vhDCPrinter, 0 );
                         SetTextJustification(vhDCPrinter, iExtra*iSpace,
                                              iSpace);
                      }
                      else{
                         SetTextJustification( vhDCPrinter, 0, 0 );
                         SetTextCharacterExtra( vhDCPrinter, iExtra );
                      }
                      TextOut(vhDCPrinter, xpPrint, yp, ptr1, len);
                      xpPrint += iWid;
                   }
                }
                else{
                    iRun += cch;
                    SetTextCharacterExtra( vhDCPrinter, 0 );
                    TextOut(vhDCPrinter, xpPrint, yp, pch, cch);
                    xpPrint += dxp;
                }
#else
                TextOut(vhDCPrinter, xpPrint, yp, (LPSTR)pch, cch);
                xpPrint += dxp;
#endif
                pch += cch;
                }
            }
        }

    Scribble(5,' ');
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\print3.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* These routines are the guts of the graphics print code. */

#define	NOGDICAPMASKS
#define	NOVIRTUALKEYCODES
#define	NOWINMESSAGES
#define	NOWINSTYLES
#define	NOSYSMETRICS
#define	NOICON
#define	NOKEYSTATE
#define	NOSYSCOMMANDS
#define	NOSHOWWINDOW
//#define	NOATOM
#define	NOFONT
#define	NOBRUSH
#define	NOCLIPBOARD
#define	NOCOLOR
#define	NOCREATESTRUCT
#define	NOCTLMGR
#define	NODRAWTEXT
#define	NOMB
#define	NOOPENFILE
#define	NOPEN
#define	NOREGION
#define	NOSCROLL
#define	NOSOUND
#define	NOWH
#define	NOWINOFFSETS
#define	NOWNDCLASS
#define	NOCOMM
#include <windows.h>
#include "mw.h"
#include "printdef.h"
#include "fmtdefs.h"
#include "docdefs.h"
#define	NOKCCODES
#include "winddefs.h"
#include "debug.h"
#include "str.h"
#if defined(OLE)
#include "obj.h"
#endif

PrintGraphics(xpPrint, ypPrint)
int	xpPrint;
int	ypPrint;
	{
	/* This	routine	prints the picture in the vfli structure at	position
	(xpPrint, ypPrint).	*/

	extern HDC vhDCPrinter;
	extern struct FLI vfli;
	extern struct DOD (**hpdocdod)[];
	extern int dxpPrPage;
	extern int dypPrPage;
	extern FARPROC lpFPrContinue;

	typeCP cp;
	typeCP cpMac = (**hpdocdod)[vfli.doc].cpMac;
	struct PICINFOX	picInfo;
	HANDLE hBits = NULL;
	HDC	hMDC = NULL;
	HBITMAP	hbm	= NULL;
	LPCH lpBits;
	int	cchRun;
	unsigned long cbPict = 0;
	int	dxpOrig;		/* Size	of picture in the original */
	int	dypOrig;
	int	dxpDisplay;		/* Size	of picture as we want to show it */
	int	dypDisplay;
	BOOL fRescale;
	BOOL fBitmap;
	BOOL fPrint	= FALSE;
	int	iLevel = 0;
    RECT bounds;

	Assert(vhDCPrinter);
    GetPicInfo(vfli.cpMin, cpMac, vfli.doc,	&picInfo);

	/* Compute desired display size	of picture (in device pixels) */
	dxpDisplay = vfli.xpReal - vfli.xpLeft;
	dypDisplay = vfli.dypLine;

	/* Compute original	size of	picture	(in	device pixels) */
	/* MM_ANISOTROPIC and MM_ISOTROPIC pictures	have no	original size */

	fRescale = FALSE;
	switch (picInfo.mfp.mm)
		{
	case MM_ISOTROPIC:
	case MM_ANISOTROPIC:
		break;

#if defined(OLE)
    case MM_OLE:
        if (lpOBJ_QUERY_INFO(&picInfo) == NULL)
                goto DontDraw;

        if (lpOBJ_QUERY_OBJECT(&picInfo) == NULL)
                goto DontDraw;
    break;
#endif

	case MM_BITMAP:
		dxpOrig	= picInfo.bm.bmWidth;
		dypOrig	= picInfo.bm.bmHeight;
		break;

	default:
		dxpOrig	= PxlConvert(picInfo.mfp.mm, picInfo.mfp.xExt, dxpPrPage,
		  GetDeviceCaps(vhDCPrinter, HORZSIZE));
		dypOrig	= PxlConvert(picInfo.mfp.mm, picInfo.mfp.yExt, dypPrPage,
		  GetDeviceCaps(vhDCPrinter, VERTSIZE));
		if (dxpOrig	== 0 ||	dypOrig	== 0)
			{
#ifdef DPRINT            
            CommSz("PrintGraphics: nodraw because dxpOrig==0 | dypOrig==0\r\n");
#endif
			goto DontDraw;
			}
		fRescale = (dxpOrig	!= dxpDisplay) || (dypOrig != dypDisplay);
		break;
		}

	/* Get a handle	to a global	object large enough	to hold	the	picture. */
    if (picInfo.mfp.mm != MM_OLE)
    {
	if ((hBits = GlobalAlloc(GMEM_MOVEABLE,	(long)picInfo.cbSize)) == NULL)
		{
		/* Not enough global heap space	to load	bitmap/metafile	*/
#ifdef DPRINT        
        CommSz("PrintGraphics: nodraw because not enough mem to alloc\r\n");
#endif
		goto DontDraw;
		}

	/* Build up	all	bytes associated with the picture (except the header) into
	the	global handle hBits	*/
	for	(cbPict	= 0, cp	= vfli.cpMin + picInfo.cbHeader; cbPict	<
	  picInfo.cbSize; cbPict +=	cchRun,	cp += cchRun)
		{
		CHAR rgch[256];
		LPCH lpch;

		#define	ulmin(a,b)	((a) < (b) ? (a) : (b))

		FetchRgch(&cchRun, rgch, vfli.doc, cp, cpMac, (int)ulmin(picInfo.cbSize
		  -	cbPict,	256));

		if ((lpch =	GlobalLock(hBits)) == NULL)
			{
#ifdef DPRINT            
            CommSz("PrintGraphics: nodraw because couldn't lock\r\n");
#endif
			goto DontDraw;
			}

		bltbx((LPSTR)rgch, lpch	+ cbPict, cchRun);
		GlobalUnlock(hBits);
		}
    }

	/* Save	the	printer	DC as a	guard against DC attribute alteration by a
	metafile */
	iLevel = SaveDC(vhDCPrinter);

	fBitmap	= picInfo.mfp.mm ==	MM_BITMAP;

#if defined(OLE)
        /* CASE 0: OLE */
        if (picInfo.mfp.mm == MM_OLE)
        {
            RECT rcPict;

            rcPict.left  = xpPrint;
            rcPict.top   = ypPrint;
            rcPict.right = rcPict.left + dxpDisplay;
            rcPict.bottom   = rcPict.top  + dypDisplay;
	        SetMapMode(vhDCPrinter, MM_TEXT);
            //SetViewportOrg( vhDCPrinter, xpPrint, ypPrint);
            fPrint = ObjDisplayObjectInDoc(&picInfo, vfli.doc, vfli.cpMin, vhDCPrinter, &rcPict);
        }
        else
#endif
	if (fBitmap)
		{
		if (((hMDC = CreateCompatibleDC(vhDCPrinter)) != NULL) &&
		  ((picInfo.bm.bmBits =	GlobalLock(hBits)) != NULL)	&& ((hbm =
		  CreateBitmapIndirect((LPBITMAP)&picInfo.bm)) != NULL))
			{
			picInfo.bm.bmBits =	NULL;
			GlobalUnlock(hBits);
			if (SelectObject(hMDC, hbm)	!= NULL)
				{
				fPrint = StretchBlt(vhDCPrinter, xpPrint, ypPrint, dxpDisplay,
				  dypDisplay, hMDC,	0, 0, dxpOrig, dypOrig,	SRCCOPY);
#ifdef DPRINT                
                CommSzNum("PrintGraphics: after StretchBlt1, fPrint==", fPrint);
#endif
				}
			}
		}

	/* Case	2: a non-scalable picture which	we are nevertheless	scaling	by force
	using StretchBlt */
	else if	(fRescale)
		{
		if (((hMDC = CreateCompatibleDC(vhDCPrinter)) != NULL) && ((hbm	=
		  CreateCompatibleBitmap(vhDCPrinter, dxpOrig, dypOrig)) !=	NULL))
			{
			if (SelectObject(hMDC, hbm)	&& PatBlt(hMDC,	0, 0, dxpOrig, dypOrig,
			  WHITENESS) &&	SetMapMode(hMDC, picInfo.mfp.mm) &&
			  PlayMetaFile(hMDC, hBits))
				{
				/* Successfully	played metafile	*/
				SetMapMode(hMDC, MM_TEXT);
				fPrint = StretchBlt(vhDCPrinter, xpPrint, ypPrint, dxpDisplay,
				  dypDisplay, hMDC,	0, 0, dxpOrig, dypOrig,	SRCCOPY);
#ifdef DPRINT                
                CommSzNum("PrintGraphics: after StretchBlt2, fPrint==", fPrint);
#endif
				}
			}
		}

	/* Case	3: A metafile picture which	can	be directly	scaled or does not
	need to	be because its size	has	not	changed	*/
	else
		{
		SetMapMode(vhDCPrinter,	picInfo.mfp.mm);

		SetViewportOrg(vhDCPrinter,	xpPrint, ypPrint);
		switch (picInfo.mfp.mm)
			{
		case MM_ISOTROPIC:
			if (picInfo.mfp.xExt &&	picInfo.mfp.yExt)
				{
				/* So we get the correct shape rectangle when SetViewportExt
				gets called	*/
				SetWindowExt(vhDCPrinter, picInfo.mfp.xExt,	picInfo.mfp.yExt);
				}

		/* FALL	THROUGH	*/
		case MM_ANISOTROPIC:
            /** (9.17.91) v-dougk 
                Set the window extent in case the metafile is bad 
                and doesn't call it itself.  This will prevent
                possible gpfaults in GDI
                **/
            SetWindowExt( vhDCPrinter,  dxpDisplay, dypDisplay );

			SetViewportExt(vhDCPrinter,	dxpDisplay,	dypDisplay);
			break;
			}

		fPrint = PlayMetaFile(vhDCPrinter, hBits);
#ifdef DPRINT        
        CommSzNum("PrintGraphics: after PlayMetaFile, fPrint==", fPrint);
#endif
		}

DontDraw:
	/* We've drawn all we are going	to draw; now its time to clean up. */
	if (iLevel > 0)
		{
		RestoreDC(vhDCPrinter, iLevel);
		}
	if (hMDC !=	NULL)
		{
		DeleteDC(hMDC);
		}
	if (hbm	!= NULL)
		{
		DeleteObject(hbm);
		}
	if (hBits != NULL)
		{
		if (fBitmap	&& picInfo.bm.bmBits !=	NULL)
			{
			GlobalUnlock(hBits);
			}
		GlobalFree(hBits);
		}

	/* If we couldn't print	the	picture, warn the user.	*/
	if (!fPrint)
		{
		Error(IDPMTPrPictErr);
		}
	}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\propdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* propdefs.h - MW defsfor char/para properties */

#define hpsNegMin       128
/* NOTE - "hpsNormal" is used for incremental encoding/decoding of chps in doc
   files, hpsDefault is the size the guy starts typing into a new doc with */
#define hpsNormal       24

#ifdef KOREA
#define hpsDefault      24
#else
#ifdef JAPAN
#define hpsDefault      24      //T-HIROYN Win3.1
#else
#define hpsDefault      20
#endif
#endif

struct TBD      /* Tab Descriptor */
        {
        unsigned        dxa;        /* distance from left margin of tab stop */
        unsigned char   jc : 3;     /* justification code */
        unsigned char   tlc : 3;    /* leader dot code */
        unsigned char   opcode : 2; /* operation code for Format Tabs */
        CHAR            chAlign;    /* ASCII code of char to align on
                                       if jcTab=3, or 0 to align on '.' */
        };

#define cchTBD          (sizeof (struct TBD))
#define cwTBD           (sizeof (struct TBD) / sizeof (int))
#define itbdMax         13
#define itbdMaxWord     20
#define cchMaxNum       10

struct CHP      /* Character properties */
        {
        unsigned       fStyled : 1;                            /* BYTE 0 */
        unsigned       stc : 7;        /* style */
        unsigned       fBold : 1;                              /* BYTE 1 */
        unsigned       fItalic : 1;
        unsigned       ftc : 6;        /* Font code */
        unsigned       hps : 8;        /* Size in half pts */  /* BYTE 2 */
        unsigned       fUline : 1;                             /* BYTE 3 */
        unsigned       fStrike : 1;
        unsigned       fDline: 1;
        unsigned       fOverset : 1;
        unsigned       csm : 2;        /* Case modifier */
        unsigned       fSpecial : 1;
        unsigned       : 1;
        unsigned       ftcXtra : 3;                            /* BYTE 4 */
        unsigned       fOutline : 1;
        unsigned       fShadow : 1;
        unsigned       : 3;
        unsigned       hpsPos : 8;                             /* BYTE 5 */
        unsigned       fFixedPitch : 1; /* used internally only */
        unsigned       psWidth : 7;
        unsigned       chLeader : 8;
        unsigned       ichRun : 8;
        unsigned       cchRun : 8;
        };

#define cchCHP          (sizeof (struct CHP))
#define cwCHP           (cchCHP / sizeof (int))
#define cchCHPUsed      (cchCHP - 3)


#define csmNormal       0
#define csmUpper        1
#define csmSmallCaps    3


/* Justification codes: must agree with menu.mod */
#define jcLeft          0
#define jcCenter        1
#define jcRight         2
#define jcBoth          3

#define jcTabMin        4
#define jcTabLeft       4
#define jcTabCenter     5
#define jcTabRight      6
#define jcTabDecimal    7
                          /* nice, safe invalid jc value */
#define jcNil           -1

/* Tab leader codes: must agree with menu.mod */
#define tlcWhite        0
#define tlcDot          1
#define tlcHyphen       2
#define tlcUline        3


struct PAP      /* Paragraph properties */
        {
        unsigned        fStyled : 1;                            /* BYTE 0 */
        unsigned        stc : 7;
        unsigned        jc : 2;                                 /* BYTE 1 */
        unsigned        fKeep : 1;
        unsigned        fKeepFollow : 1;
        unsigned        : 4;
        unsigned        stcNormChp : 7;                         /* BYTE 2 */
        unsigned        : 9;                                    /* BYTE 3 */
        unsigned        dxaRight;                               /* BYTE 4-5 */
        unsigned        dxaLeft;                                /* BYTE 6-7 */
        unsigned        dxaLeft1;                               /* BYTE 8-9 */
        unsigned        dyaLine;                                /* 10-11 */
        unsigned        dyaBefore;                              /* 12-13 */
        unsigned        dyaAfter;                               /* 14-15 */
        unsigned        rhc : 4;        /* Running hd code */
        unsigned        fGraphics : 1;  /* Graphics bit */
        unsigned        wUnused1 : 11;
        int             wUnused2;
        int             wUnused3;
        struct TBD      rgtbd[itbdMaxWord];
        };

#define cchPAP  (sizeof (struct PAP))
#define cwPAP   (cchPAP / sizeof (int))
#define cwPAPBase (cwPAP - cwTBD * itbdMaxWord)

struct SEP
        { /* Section properties */
        unsigned        fStyled : 1;                            /* BYTE 0 */
        unsigned        stc : 7;
        unsigned        bkc : 3;        /* Break code */        /* BYTE 1 */
        unsigned        nfcPgn : 3;     /* Pgn format code */
        unsigned        :2;
        unsigned        yaMac;          /* Page height */       /* BYTE 2-3 */
        unsigned        xaMac;          /* Page width */        /* BYTE 4-5 */
        unsigned        pgnStart;       /* Starting pgn */      /* BYTE 6-7 */
        unsigned        yaTop;          /* Start of text */     /* BYTE 8-9 */
        unsigned        dyaText;        /* Height of text */    /* 10-11 */
        unsigned        xaLeft;         /* Left text margin */  /* 12-13 */
        unsigned        dxaText;        /* Width of text */     /* 14-15 */
        unsigned        rhc : 4;        /* *** RESERVED *** */  /* 16 */
                                        /* (Must be same as PAP) */
        unsigned        : 2;
        unsigned        fAutoPgn : 1;   /* Print pgns without hdr */
        unsigned        fEndFtns : 1;   /* Footnotes at end of doc */
        unsigned        cColumns : 8;   /* # of columns */      /* BYTE 17 */
        unsigned        yaRH1;          /* Pos of top hdr */    /* 18-19 */
        unsigned        yaRH2;          /* Pos of bottom hdr */ /* 20-21 */
        unsigned        dxaColumns;     /* Intercolumn gap */   /* 22-23 */
        unsigned        dxaGutter;      /* Gutter width */      /* 24-25 */
        unsigned        yaPgn;          /* Y pos of page nos */ /* 26-27 */
        unsigned        xaPgn;          /* X pos of page nos */ /* 28-29 */
        CHAR            rgbJunk[cchPAP - 30]; /* Pad to cchPAP */
        };


#define cchSEP  (sizeof (struct SEP))
#define cwSEP   (cchSEP / sizeof (int))


struct PROP
        { /* A CHP, PAP, or SEP. */
        unsigned char   fStyled : 1;
        unsigned char   stc : 7;
        CHAR            rgb[cchPAP - 1]; /* Variable size */
        };


#define cchPROP (sizeof (struct PROP))

typedef struct
        {             /* tri-state value for character/paragraph properties */
        unsigned wTsv;  /* 16 bit value */
        unsigned char   fGray;
        }TSV;


#define cchTSV (sizeof (TSV))
#define itsvMax         6
#define itsvchMax       6
#define itsvparaMax     5

    /* character index values */
#define itsvBold        0
#define itsvItalic      1
#define itsvUline       2
#define itsvPosition    3     /* 0 = normal; >0 = superscript; <0 = subscript */
#define itsvFfn         4     /* font name and family */
#define itsvSize        5     /* font size */
    /* paragraph index values */
#define itsvJust        0       /* justification (left, center, right, both) */
#define itsvSpacing     1
#define itsvLIndent     2       /* left indent */
#define itsvFIndent     3       /* first line indent */
#define itsvRIndent     4       /* right indent */





#define cyaInch         czaInch
#define cxaInch         czaInch
#define cyaTl           czaLine
#define dxaNest         720

extern int              cxaTc;

#define yaNil           0xffff
#define xaNil           0xffff

#define ypNil           0xffff
#define xpNil           0xffff

#define dyaMinUseful    cyaInch
#define dxaMinUseful    (cxaInch / 2)
#define cColumnsMax     (10)

#define bkcLine         0
#define bkcColumn       1
#define bkcPage         2
#define bkcRecto        3
#define bkcVerso        4

#define nfcArabic       0
#define nfcUCRoman      1
#define nfcLCRoman      2
#define nfcUCLetter     3
#define nfcLCLetter     4

#define pgnNil          (-1)

struct PROP *PpropXlate();

/* Running head codes */
#define RHC_fBottom     1
#define RHC_fOdd        2
#define RHC_fEven       4
#define RHC_fFirst      8

#define rhcDefault      (RHC_fOdd + RHC_fEven)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\prmdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Single property modifiers */

/*      ***     MUST agree with dnsprm in mglobals.c       ***     */

#ifndef PRMDEFSH
#define PRMDEFSH

/* Paragraph */
#define sprmPLMarg      1       /* Left margin */
#define sprmPRMarg      2       /* Right margin */
#define sprmPFIndent    3       /* First line indent (from LM) */
#define sprmPJc         4       /* Justification code */
#define sprmPRuler      5       /* Ruler (formerly Clear tab) */
#define sprmPRuler1     6       /* Ruler1 (formerly Set tab) */
#define sprmPKeep       7       /* Keep */
#define sprmPNormal     8       /* Normal para (formerly Style, overrides all others) */
#define sprmPRhc        9       /* Running head code */
#define sprmPSame       10      /* Everything (overrides all others) */
#define sprmPDyaLine    11      /* Line height */
#define sprmPDyaBefore  12      /* Space before */
#define sprmPDyaAfter   13      /* Space after */
#define sprmPNest       14      /* Nest para */
#define sprmPUnNest     15      /* Un-nest para */
#define sprmPHang       16      /* Hanging indent */
#define sprmPRgtbd      17      /* add a range of tabs  */
#define sprmPKeepFollow 18      /* Keep follow */
/*#define sprmPCAll       19      /* Clear all tabs */

/* Character */
#define sprmCBold       20      /* Bold */
#define sprmCItalic     21      /* Italic */
#define sprmCUline      22      /* Underline */
#define sprmCPos        23      /* Super/subscript */
#define sprmCFtc        24      /* Font code */
#define sprmCHps        25      /* Half-point size */
#define sprmCSame       26      /* Whole CHP */
#define sprmCChgFtc     27      /* Alter Font code */
#define sprmCChgHps     28      /* Alter point size */
#define sprmCPlain      29      /* Change to plain text (preserve font) */
#define sprmCShadow     30      /* Shadow text attribute */
#define sprmCOutline    31      /* Outline text attribute */
#define sprmCCsm        32      /* case modification */

#define sprmCStrike     33      /* Strikeout */               /* unused */
#define sprmCDline      34      /* Double underline */        /* unused */
/*#define sprmCPitch    35      /* Pitch */
/*#define sprmCOverset  36      /* Margin overset */
/*#define sprmCStc      37      /* Style (overrides all others) */
#define sprmCMapFtc     38      /* Defines font code mapping */
#define sprmCOldFtc     39      /* Defines procedural font code mapping
                                   for old WORD files */

#define sprmPRhcNorm    40      /* Normalize rhc indent to be margin-relatve */
#define sprmMax         41      /* UPDATE WHEN ADDING SPRMS */

struct PRM
        { /* PropeRty Modifier -- 2 bytes only 
            (now 4 bytes so scratch file can be >64K (7.12.91) v-dougk) 
            Couldn't be 3 bytes because Heap mgmt in Write assumes
            word sizes of memory requests .  Don't know what would take 
            to change that. */
        unsigned char    fComplex        : 1; /* If fComplex == false . . . */
        unsigned char    sprm            : 7;
        CHAR     val;
        WORD dummy;
        };

struct PRMX
        { /* PropeRty Modifier, part 2 */
        unsigned     int fComplex        : 1; /* if fComplex == true */
        unsigned     int bfprm_hi        : 15;
        unsigned     int  bfprm_low          ;
        };

extern struct PRM PrmAppend(struct PRM prm, CHAR *psprm);
extern DoPrm(struct CHP *pchp, struct PAP *ppap, struct PRM prm);

#define fcSCRATCHPRM(prm) (((((typeFC)(((struct PRMX *)&(prm))->bfprm_hi )) << 16) + \
                             (((typeFC)(((struct PRMX *)&(prm))->bfprm_low))      )) << 1)
#define bPRMNIL(prm)      (!((prm).fComplex) && !((prm).sprm) && !((prm).val))
#define SETPRMNIL(prm)    ((prm).fComplex = (prm).sprm = (prm).val = (prm).dummy = 0)

/* Definitions for ESPRM */
#define ESPRM_cch       000003  /* Mask for cch of sprm */
#define ESPRM_sgcMult   000004  /* Sgc multiplier */
#define ESPRM_sgc       000014  /* Sprm Group Code mask */
#define ESPRM_spr       000040  /* Sprm priority mask */
#define ESPRM_fClobber  000100  /* Overrides sprms with same sgc and <= spr */
#define ESPRM_fSame     000200  /* Overrides another instance of same sprm */

#define sgcChar         (0 * ESPRM_sgcMult)
#define sgcPara         (1 * ESPRM_sgcMult)
#define sgcParaSpec     (2 * ESPRM_sgcMult)

#define hpsSuperSub     12

#define dxaTabDelta     50
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\printdlg.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1990 Microsoft Corporation */
/************************************************************/

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOCLIPBOARD
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOMETAFILE
#define NOWH
#define NOWNDCLASS
#define NOSOUND
#define NOCOLOR
#define NOSCROLL
#define NOCOMM

#include <windows.h>
#include "mw.h"
#include "dlgdefs.h"
#include "cmddefs.h"
#include "machdefs.h"
#include "docdefs.h"
#include "propdefs.h"
#include "printdef.h"
#include "str.h"
#include "fmtdefs.h"
#include <commdlg.h>
#include <cderr.h>
#include <print.h>
#include <stdlib.h>

extern CHAR (**hszPrinter)[];
extern CHAR (**hszPrDriver)[];
extern CHAR (**hszPrPort)[];
extern BOOL vfPrDefault;

#ifdef JAPAN                  //  added  08 Jun. 1992  by Hiraisi
BOOL FAR PASCAL _export fnPrintHook( HWND, UINT, WPARAM, LPARAM );
extern HANDLE   hMmwModInstance;
BOOL fWriting = FALSE;
BOOL bWriting = FALSE;
#endif    //JAPAN

BOOL vbCollate = TRUE;

static void GetPrNames(BOOL bPrDialog);
PRINTDLG PD = {0,0,0,0,0}; /* Common print dlg structure, initialized in the init code */

void PrinterSetupDlg(BOOL bGetDevmodeOnly /* not used */)
{
    extern HWND vhWnd;
    BOOL bDevMode = PD.hDevMode ? TRUE : FALSE;

    PD.Flags |= PD_PRINTSETUP;
    PD.Flags &= ~PD_RETURNDEFAULT;

    if (vfPrDefault && !PD.hDevNames)
        if (PD.hDevMode)
        {
            /*
                So dlg will show that default is selected.  Its a pity
                to do this because hDevMode is perfectly good.  Alternative
                is to build a DevNames structure which we could do, but
                that would just allocate a new devmode anyways.
             */
            GlobalFree(PD.hDevMode);
            PD.hDevMode = 0;
        }

#ifdef JAPAN                  //  added  08 Jun. 1992  by Hiraisi
    PD.hInstance = NULL;
    PD.lpPrintTemplateName = (LPCSTR)NULL;
    PD.Flags    &= ~PD_ENABLEPRINTTEMPLATE;
    PD.Flags    &= ~PD_ENABLEPRINTHOOK;
#endif    //JAPAN

TryPrnSetupAgain:
    if (!PrintDlg(&PD))
    {
        /* Bug #11531:  When PrintDlg returns 0, it could me we gave it garbage in
        * the DevNames or DevMode structures, perhaps due to the user making
        * changes through Control Panel that we don't monitor.  Clean out the
        * appropriate structure and try again.  Note that these errors can't be
        * returned to us again after cleaning out the structure.
        *   23 August 1991    Clark R. Cyr
        */
        switch (CommDlgExtendedError())
        {
            case PDERR_PRINTERNOTFOUND:
            case PDERR_DNDMMISMATCH:
                if (PD.hDevNames)
                {
                    GlobalFree(PD.hDevNames);
                    PD.hDevNames = 0;
                }

                if (PD.hDevMode)
                {
                    GlobalFree(PD.hDevMode);
                    PD.hDevMode = 0;
                }
            goto TryPrnSetupAgain;

            default:
            return;
        }
    }

    PD.Flags &= ~PD_PRINTSETUP;

    GetPrNames(FALSE); // this gets new PrinterDC

    ResetFontTables();

#if defined(OLE)
    ObjSetTargetDevice(TRUE);
#endif

    InvalidateRect(vhWnd, (LPRECT)NULL, fFalse);

    return;
}

void fnPrPrinter(
    void)
{
    /* This routine is the outside world's interface to the print code. */
    extern int docCur;
    extern int vfPrPages, vpgnBegin, vpgnEnd, vcCopies;
    extern WORD fPrintOnly;
    extern CHAR (**hszPrPort)[];
    HANDLE hPort=NULL;
    LPDEVNAMES lpDevNames;
    int Len3;
    char szPort[cchMaxFile];
    extern struct SEL       selCur;
    BOOL bDevMode = PD.hDevMode ? TRUE : FALSE;
#ifdef JAPAN                  //  added  08 Jun. 1992  by Hiraisi
    FARPROC lpfnPrintHook;
    BOOL bReturn;
#endif

    PD.Flags &= ~(PD_RETURNDEFAULT|PD_PRINTSETUP|PD_SELECTION); /*turn off PRINTSETUP flag */
    if (vbCollate)
        PD.Flags |= PD_COLLATE;
    else
        PD.Flags &= ~PD_COLLATE;

    if (selCur.cpFirst == selCur.cpLim) // no selection
        PD.Flags |= PD_NOSELECTION;
    else
        PD.Flags &= ~PD_NOSELECTION;

    if (vfPrDefault && !PD.hDevNames)
        if (PD.hDevMode)
        {
            /*
                So dlg will show that default is selected.  Its a pity
                to do this beause hDevMode is perfectly good.  Alternative
                is to build a DevNames structure.
             */
            GlobalFree(PD.hDevMode);
            PD.hDevMode = 0;
        }

#ifdef JAPAN                  //  added  08 Jun. 1992  by Hiraisi
    PD.hInstance = hMmwModInstance;
    PD.Flags    |= PD_ENABLEPRINTTEMPLATE;
    PD.lpPrintTemplateName = (LPCSTR)MAKEINTRESOURCE( dlgPrint );
    PD.Flags    |= PD_ENABLEPRINTHOOK;
    lpfnPrintHook = MakeProcInstance( fnPrintHook, hMmwModInstance );
    PD.lpfnPrintHook = (FARPROC)lpfnPrintHook;
TryPrintAgain:
    bReturn = PrintDlg(&PD);
    FreeProcInstance( lpfnPrintHook );
    if (!bReturn)
#else
TryPrintAgain:
    if (!PrintDlg(&PD))
#endif
    {
        switch (CommDlgExtendedError())
        {
            case PDERR_PRINTERNOTFOUND:
            case PDERR_DNDMMISMATCH:
                if (PD.hDevNames)
                {
                    GlobalFree(PD.hDevNames);
                    PD.hDevNames = 0;
                }

                if (PD.hDevMode)
                {
                    GlobalFree(PD.hDevMode);
                    PD.hDevMode = 0;
                }
            goto TryPrintAgain;

            default:
                if (!bDevMode && PD.hDevMode)
                {
                    GlobalFree(PD.hDevMode);
                    PD.hDevMode = 0;
                }
            return;
        }
    }

#ifdef JAPAN                  //  added  08 Jun. 1992  by Hiraisi
    fWriting = bWriting;
#endif

    if (PD.Flags & PD_PAGENUMS)     /* Page Range specified? */
    {
        vfPrPages = TRUE;
        if (PD.nFromPage)
            vpgnBegin = PD.nFromPage;
        if (PD.nToPage)
            vpgnEnd = PD.nToPage;
        if (vpgnEnd < vpgnBegin)
        {
            int temp = vpgnBegin;

            vpgnBegin = vpgnEnd;
            vpgnEnd = temp;
        }
    }
    else                            /* No, print all pages */
        vfPrPages = FALSE;

    vcCopies = PD.nCopies;
    vbCollate = PD.Flags & PD_COLLATE;

    GetPrNames(TRUE);

    /**  At this point, we have the following :

    vfPrPages = true if print page range else print all pages
    vpgnBegin = starting page number (if vfPrPages)
    vpgnEnd   = ending page number (if vfPrPages)
    vcCopies  = number of copies to print
    vbCollate = whuddya think?
    **/

#if defined(OLE)
    ObjSetTargetDevice(TRUE);
#endif

    if (PD.Flags & PD_SELECTION)
    {
        int docTmp;
        BOOL bIssueError;
        extern WORD ferror;
        extern typeCP cpMinCur, cpMacCur, cpMinDocument;
        extern struct DOD      (**hpdocdod)[];
        typeCP cpMinCurT = cpMinCur;
        typeCP cpMacCurT = cpMacCur;
        typeCP cpMinDocumentT = cpMinDocument;

        docTmp = DocCreate(fnNil, HszCreate(""), dtyNormal);
        if (docTmp != docNil)
        {
            ClobberDoc( docTmp, docCur, selCur.cpFirst, selCur.cpLim-selCur.cpFirst );

            if (!ferror)
            {
                cpMinCur = cp0;
                cpMacCur = (**hpdocdod) [docTmp].cpMac;
                PrintDoc(docTmp, TRUE);
                cpMinCur = cpMinCurT;
                cpMacCur = cpMacCurT;
            }

        }

        cpMinDocument = cpMinDocumentT;  /* destroyed possibly by DocCreate */

        bIssueError = ferror;

        if (ferror)
            ferror = FALSE; // to enable the following:

        if (docTmp != docNil)
            KillDoc (docTmp); // do this first to free memory to assist messagebox if necessary

        if (bIssueError)
            Error(IDPMTPRFAIL);
    }
    else
        PrintDoc(docCur, TRUE);
}

BOOL FInitHeaderFooter(fHeader, ppgn, phrgpld, pcpld)
BOOL fHeader;
unsigned *ppgn;
struct PLD (***phrgpld)[];
int *pcpld;
    {
    /* This routine initializes the array of print line descriptors used in
    positioning the header/footer on the printed page.  FALSE is returned if an
    error occurs; TRUE otherwise. */

    extern typeCP cpMinHeader;
    extern typeCP cpMacHeader;
    extern typeCP cpMinFooter;
    extern typeCP cpMacFooter;
    extern int docCur;
    extern struct PAP vpapAbs;
    extern struct SEP vsepAbs;
    extern int dxaPrOffset;
    extern int dyaPrOffset;
    extern int dxpPrPage;
    extern int dxaPrPage;
    extern int dypPrPage;
    extern int dyaPrPage;
    extern struct FLI vfli;
    extern int vfOutOfMemory;

    typeCP cpMin;
    typeCP cpMac;

    /* Get the cpMin and the cpMac for the header/footer. */
    if (fHeader)
        {
        cpMin = cpMinHeader;
        cpMac = cpMacHeader;
        }
    else
        {
        cpMin = cpMinFooter;
        cpMac = cpMacFooter;
        }

    /* Is there a header/footer. */
    if (cpMac - cpMin > ccpEol)
        {
        int cpld = 0;
        int cpldReal = 0;
        int cpldMax;
        int xp;
        int yp;
        int ichCp = 0;
        typeCP cpMacDoc = CpMacText(docCur);

        /* Compute the page number of the start of the headers/footers. */
        CacheSect(docCur, cpMin);
        if ((*ppgn = vsepAbs.pgnStart) == pgnNil)
            {
            *ppgn = 1;
            }

        /* Does the header/footer appear on the first page. */
        CachePara(docCur, cpMin);
        if (!(vpapAbs.rhc & RHC_fFirst))
            {
            (*ppgn)++;
            }

        /* Calculate the bounds of the header/footer in pixels. */
        xp = MultDiv(vsepAbs.xaLeft - dxaPrOffset, dxpPrPage, dxaPrPage);
        yp = fHeader ? MultDiv(vsepAbs.yaRH1 - dyaPrOffset, dypPrPage,
          dyaPrPage) : 0;

        /* Initialize the array of print line descriptors for the header/footer.
        */
        if (FNoHeap(*phrgpld = (struct PLD (**)[])HAllocate((cpldMax = cpldRH) *
          cwPLD)))
            {
            *phrgpld = NULL;
            return (FALSE);
            }

        /* We now have to calculate the array of print line descriptors for the
        header/footer. */
        cpMac -= ccpEol;
        while (cpMin < cpMac)
            {
            /* Format this line of the header/footer for the printer. */
            FormatLine(docCur, cpMin, ichCp, cpMacDoc, flmPrinting);

            /* Bail out if an error occurred. */
            if (vfOutOfMemory)
                {
                return (FALSE);
                }

            /* Is the array of print line descriptors big enough? */
            if (cpld >= cpldMax && !FChngSizeH(*phrgpld, (cpldMax += cpldRH) *
              cwPLD, FALSE))
                {
                return (FALSE);
                }

            /* Fill the print line descriptor for this line. */
                {
                register struct PLD *ppld = &(***phrgpld)[cpld++];

                ppld->cp = cpMin;
                ppld->ichCp = ichCp;
                ppld->rc.left = xp + vfli.xpLeft;
                ppld->rc.right = xp + vfli.xpReal;
                ppld->rc.top = yp;
                ppld->rc.bottom = yp + vfli.dypLine;
                }

            /* Keep track of the non-blank lines in the header/footer */
            if ((vfli.ichReal > 0) || vfli.fGraphics)
                {
                cpldReal = cpld;
                }

            /* Bump the counters. */
            cpMin = vfli.cpMac;
            ichCp = vfli.ichCpMac;
            yp += vfli.dypLine;
            }

        /* If this is a footer, then we have to move the positions of the lines
        around so that the footer ends where the user has requested. */
        if (!fHeader && cpldReal > 0)
            {
            register struct PLD *ppld = &(***phrgpld)[cpldReal - 1];
            int dyp = MultDiv(vsepAbs.yaRH2 - dyaPrOffset, dypPrPage, dyaPrPage)
              - ppld->rc.bottom;
            int ipld;

            for (ipld = cpldReal; ipld > 0; ipld--, ppld--)
                {
                ppld->rc.top += dyp;
                ppld->rc.bottom += dyp;
                }
            }

        /* Record the number of non-blank lines in the head/footer. */
        *pcpld = cpldReal;
        }
    else
        {
        /* Indicate there is no header/footer. */
        *ppgn = pgnNil;
        *phrgpld = NULL;
        *pcpld = 0;
        }
    return (TRUE);
    }



static void GetPrNames(BOOL bPrDialog)
{
    HANDLE hPrinter = NULL, hDriver = NULL, hPort = NULL;
    LPDEVNAMES lpDevNames;
    char szPrinter[cchMaxFile], szDriver[cchMaxFile], szPort[cchMaxFile];
    int Len1, Len2, Len3;            /* count of words in each string */

    hPrinter = NULL;
    hDriver = NULL;
    hPort = NULL;

    lpDevNames = MAKELP(PD.hDevNames,0);

    if (lpDevNames == NULL)
        /* we're in trouble */
        return;

    lstrcpy(szPrinter, (LPSTR)lpDevNames+lpDevNames->wDeviceOffset);
    lstrcpy(szDriver, (LPSTR)lpDevNames+lpDevNames->wDriverOffset);

    if (bPrDialog && (PD.Flags & PD_PRINTTOFILE))
        lstrcpy(szPort, (LPSTR)"FILE:");
    else
        lstrcpy(szPort, (LPSTR)lpDevNames+lpDevNames->wOutputOffset);

    vfPrDefault = lpDevNames->wDefault & DN_DEFAULTPRN;

    if (FNoHeap((hPrinter = (CHAR (**)[])HAllocate(Len1 =
        CwFromCch(CchSz(szPrinter))))))
        goto err;
    if (FNoHeap((hDriver = (CHAR (**)[])HAllocate(Len2 =
        CwFromCch(CchSz(szDriver))))))
        goto err;
    if (FNoHeap((hPort = (CHAR (**)[])HAllocate(Len3 =
        CwFromCch(CchSz(szPort))))))
        goto err;

    /* Free old printer, driver and port handles */
    if (hszPrinter)
        FreeH(hszPrinter);
    if (hszPrDriver)
        FreeH(hszPrDriver);
    if (hszPrPort)
        FreeH(hszPrPort);
    /* Set printer, driver and port handles */
    hszPrinter = hPrinter;
    hszPrDriver = hDriver;
    hszPrPort = hPort;

    /* copy strings into the memory corresponding to the new handles */
    blt(szPrinter, *hszPrinter, Len1);
    blt(szDriver, *hszPrDriver, Len2);
    blt(szPort, *hszPrPort, Len3);

    FreePrinterDC();
    GetPrinterDC(FALSE);
    return;

    err:
    if (FNoHeap(hPrinter))
        FreeH(hPrinter);
    if (FNoHeap(hDriver))
        FreeH(hDriver);
    if (FNoHeap(hPort))
        FreeH(hPort);
}

BOOL fnPrGetDevmode(void)
/*  Set the devmode structure for the currently-selected printer,
    Assumes all needed values are correctly initialized!
    Return whether an error. */
{
    int nCount;
    HANDLE hDevice=NULL;
    FARPROC lpfnDevMode;
    BOOL bRetval=FALSE;
    char  szDrvName[_MAX_PATH];

    if (PD.hDevMode) // then already set (why called?)
        return FALSE;
    else if (PD.hDevNames) // then device is not extended
        return TRUE;

    if (hszPrinter == NULL || hszPrDriver == NULL || hszPrPort == NULL)
        return TRUE;

    if (**hszPrinter == '\0' || **hszPrDriver == '\0' || **hszPrPort == '\0')
        return TRUE;

    /* is this necessary for GetModuleHandle?  For sure if calling LoadLibrary(). */
    wsprintf((LPSTR)szDrvName, (LPSTR)"%s%s", (LPSTR)*hszPrDriver, (LPSTR)".DRV");

#if 1
    SetErrorMode(1); /* No kernel error dialogs */
    if ((hDevice = LoadLibrary((LPSTR)szDrvName)) < 32)
    {
        bRetval = TRUE;
        goto end;
    }
#else
    hDevice = GetModuleHandle((LPSTR)szDrvName);
#endif


    if ((lpfnDevMode = GetProcAddress(hDevice, (LPSTR)"ExtDeviceMode")) == NULL)
    {
#ifdef DEBUG
        OutputDebugString("Unable to get extended device\n\r");
#endif

        bRetval = TRUE;
        goto end;
    }

    /* get sizeof devmode structure */
    nCount = (*lpfnDevMode)(NULL,
                            hDevice,
                            (LPSTR)NULL,
                            (LPSTR)(*hszPrinter),
                            (LPSTR)(*hszPrPort),
                            (LPSTR)NULL,
                            (LPSTR)NULL,
                            NULL);

    if ((PD.hDevMode =
        GlobalAlloc(GMEM_MOVEABLE,(DWORD)nCount)) == NULL)
    {
        bRetval = TRUE;
        goto end;
    }

    if ((*lpfnDevMode)( NULL,
                        hDevice,
                        MAKELP(PD.hDevMode,0),
                        (LPSTR)(*hszPrinter),
                        (LPSTR)(*hszPrPort),
                        (LPSTR)NULL,
                        (LPSTR)NULL,
                        DM_COPY) != IDOK)
    {
        GlobalFree(PD.hDevMode);
        PD.hDevMode = NULL;
        bRetval = TRUE;
        goto end;
    }

    end:

#if 1
    if (hDevice >= 32)
        FreeLibrary(hDevice);
#endif

    SetErrorMode(0); /* reset kernel error dialogs */

    /* can't allow hDevNames to be out of sync with hDevmode */
    if (PD.hDevNames)
    {
        GlobalFree(PD.hDevNames);
        PD.hDevNames = NULL;
    }

    return bRetval;
}


#ifdef JAPAN                  //  added  08 Jun. 1992  by Hiraisi

#include <dlgs.h>

BOOL FAR PASCAL _export fnPrintHook( hDlg, uMsg, wParam, lParam )
HWND hDlg;
UINT uMsg;
WPARAM wParam;
LPARAM lParam;
{
    switch( uMsg ){
    case  WM_INITDIALOG:
        CheckRadioButton(hDlg, rad4, rad5, fWriting ? rad5 : rad4 );
        return TRUE;
    case  WM_COMMAND:
        switch( wParam ){
        case  rad4:
        case  rad5:
            if( HIWORD(lParam) == BN_CLICKED ){
                CheckRadioButton(hDlg, rad4, rad5, wParam );
                bWriting = ( wParam == rad4 ? FALSE : TRUE );
                return TRUE;
            }
        default:
            break;
        }
    default:
        break;
    }
    return FALSE;
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\print.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains the printing routines. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOFONT
#define NOMB
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOOPENFILE
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "str.h"
#include "printdef.h"
#include "fmtdefs.h"
#include "docdefs.h"
#include "propdefs.h"
#include "dlgdefs.h"
#include "debug.h"
#include "fontdefs.h"
#if defined(OLE)
#include "obj.h"
#endif

#ifdef INEFFLOCKDOWN
    extern FARPROC lpDialogCancelPrint;
    extern FARPROC lpFPrContinue;
#else
    extern BOOL far PASCAL DialogCancelPrint(HWND, unsigned, WORD, LONG);
    extern BOOL far PASCAL FPrContinue(HDC, int);
    FARPROC lpFPrContinue;
#endif

BOOL fPrinting;

PrintDoc(doc, fPrint)
int doc;
BOOL fPrint;
    {
    /* This routine formats the document, doc, for printing and prints it if
    fPrint is TRUE. */

    BOOL FInitHeaderFooter(BOOL, unsigned *, struct PLD (***)[], int *);
    BOOL FSetPage(void);
    BOOL FPromptPgMark(typeCP);
    BOOL FPrintBand(int, struct PLD (**)[], int, PRECT);

    extern BOOL vbCollate;
    extern HDC vhDCPrinter;
    extern HWND hParentWw;
    extern HANDLE hMmwModInstance;
    extern struct DOD (**hpdocdod)[];
    extern int vpgn;
    extern struct SEP vsepAbs;
    extern typeCP vcpFirstParaCache;
    extern typeCP vcpLimParaCache;
    extern typeCP cpMinCur;
    extern typeCP cpMinDocument;
    extern struct FLI vfli;
    extern int wwCur;
    extern int docMode;
    extern int vdocPageCache;
    extern int dxaPrPage;
    extern int dyaPrPage;
    extern int dxpPrPage;
    extern int dypPrPage;
    extern int dxaPrOffset;
    extern int dyaPrOffset;
    extern CHAR szMode[30];
    extern int vfRepageConfirm;
    extern int vfPrPages;           /* true if print page range */
    extern int vpgnBegin;           /* starting page number to print */
    extern int vpgnEnd;             /* ending page number to print */
    extern int vcCopies;            /* nubmer of copies to print */
    extern int vfOutOfMemory;
    extern BOOL vfPrinterValid;
    extern BOOL vfPrErr;
    extern BOOL vfDraftMode;
    extern CHAR (**hszPrinter)[];
    extern CHAR (**hszPrDriver)[];
    extern CHAR (**hszPrPort)[];
    extern CHAR *vpDlgBuf;
    extern HWND vhWndCancelPrint;
    extern HCURSOR vhcArrow;
    extern HCURSOR vhcIBeam;

    LONG lHolder;
    int CopyIncr;   /* number of copies the printer can print at a time */
    typeCP cp;
    typeCP cpMin;
    typeCP cpMac;
    int ichCp;
    struct PGD *ppgd;
    struct PGTB **hpgtbOld;
    int cpld;
    unsigned pgnFirst;
    unsigned pgnFirstHeader;
    unsigned pgnFirstFooter;
    int ypTop;
    int ypBottom;
    int xpLeft;
    struct PLD (**hrgpldHeader)[];
    struct PLD (**hrgpldFooter)[];
    int cpldHeader;
    int cpldFooter;
    int cCopies,cCollateCopies;
    BOOL fConfirm = !fPrint && vfRepageConfirm;
    BOOL fSplat;
    CHAR stPage[cchMaxIDSTR];
    struct PDB pdb;
    int iEscape;
#ifndef INEFFLOCKDOWN
    FARPROC lpDialogCancelPrint = MakeProcInstance(DialogCancelPrint, hMmwModInstance);
    lpFPrContinue = MakeProcInstance(FPrContinue, hMmwModInstance);

    if (!lpDialogCancelPrint || !lpFPrContinue)
        goto MemoryAbort;
#endif

    Assert(vhDCPrinter != NULL);

    /* If we are out of memory, we better bail out now. */
    if (vfOutOfMemory || vhDCPrinter == NULL)
    {
    return;
    }

    /* Disable all other windows. */
    EnableWindow(hParentWw, FALSE);
    EnableOtherModeless(FALSE);

    fPrinting = fPrint;

    /* Set some flags associated with printing. */
    vfPrErr = pdb.fCancel = FALSE;

    /* Set up the print dialog buffer for the repagination or cancellation
    dialog boxes. */
    vpDlgBuf = (CHAR *)&pdb;

    if (fConfirm)
        {
    /* Reassure the user that we haven't crashed. */
    StartLongOp();
    }
    else
    {
        /* Bring up the dialog box telling the user how to cancel printing or
        repagination. */
        if ((vhWndCancelPrint = CreateDialog(hMmwModInstance, fPrint ?
          MAKEINTRESOURCE(dlgCancelPrint) : MAKEINTRESOURCE(dlgCancelRepage),
          hParentWw, lpDialogCancelPrint)) == NULL)
            {
MemoryAbort:
        /* Inform the user we cannot print because of a memory failure. */
        Error(IDPMTPRFAIL);
        vfPrErr = TRUE;
        goto Abort;
            }

    /* Immediately halt if the user requests. */
    if (!(*lpFPrContinue)(NULL, wNotSpooler))
        {
        goto Abort;
        }
    }

    if (fPrint)
    {
    /* Get the latest printer DC, in case it has changed. */
    FreePrinterDC();
    GetPrinterDC(TRUE);
    if (!vfPrinterValid)
        {
        goto MemoryAbort;
        }
    }

    /* If we are printing or repaginating without confirmation, then
    immediately halt if the user requests. */
    if (!fConfirm && !(*lpFPrContinue)(NULL, wNotSpooler))
    {
    goto Abort;
    }

#if defined(OLE)
    /*
        Load all OLE objects now because loading them
        can cause changes in doc layout.
    */
    {
        OBJPICINFO picInfo;
        typeCP cpStart=cpNil,cpMac= CpMacText(doc);
        struct SEL selSave = selCur;
        BOOL bAbort=FALSE,bSetMode=FALSE;

        while (ObjPicEnumInRange(&picInfo,doc,cpMinDocument, cpMac, &cpStart))
        {
            if (lpOBJ_QUERY_INFO(&picInfo) == NULL)
            {
                Error(IDPMTCantPrint);
                bAbort=TRUE;
                break;
            }

            if (lpOBJ_QUERY_OBJECT(&picInfo) == NULL)
            {
                /* put message in status window */
                if (!bSetMode)
                {
                    LoadString(hMmwModInstance, IDSTRLoading, szMode, sizeof(szMode));
                    DrawMode();
                    bSetMode=TRUE;
                }

                if (ObjLoadObjectInDoc(&picInfo,doc,cpStart) == cp0)
                {
                    bAbort=TRUE;
                    break;
                }
            }

            if (!(*lpFPrContinue)(NULL, wNotSpooler))
            {
                bAbort=TRUE;
                break;
            }
        }
        Select(selSave.cpFirst,selCur.cpLim); // reset
        if (bAbort)
        {
            /* Invalidate the mode so will redraw */
            docMode = docNil;
            goto Abort;
        }
    }
#endif
    /* Initialize the array of print line descriptors. */
    if (FNoHeap(pdb.hrgpld = (struct PLD (**)[])HAllocate((cpld = cpldInit) *
      cwPLD)))
        {
        goto MemoryAbort;
        }

    /* Get the document properties and set up some local variables. */
    CacheSect(doc, cpMin = cpMinDocument);
    cpMac = CpMacText(doc);
    ypTop = MultDiv(vsepAbs.yaTop - dyaPrOffset, dypPrPage, dyaPrPage);
    ypBottom = MultDiv(vsepAbs.yaTop + vsepAbs.dyaText - dyaPrOffset, dypPrPage,
      dyaPrPage);
    xpLeft = MultDiv(vsepAbs.xaLeft - dxaPrOffset, dxpPrPage, dxaPrPage);
    vdocPageCache = docNil;

    /* Initialize the page table. */
    if (FNoHeap(pdb.hpgtb = (struct PGTB **)HAllocate(cwPgtbBase + cpgdChunk *
      cwPGD)))
        {
        /* Not enough memory for page table; time to bail out. */
        FreeH(pdb.hpgtb);
        goto MemoryAbort;
        }
    (**pdb.hpgtb).cpgdMax = cpgdChunk;
    (**pdb.hpgtb).cpgd = 1;
    ppgd = &((**pdb.hpgtb).rgpgd[0]);
    ppgd->cpMin = cpMin;
    if ((pgnFirst = vsepAbs.pgnStart) == pgnNil)
        {
        pgnFirst = 1;
        }
    ppgd->pgn = pgnFirst;

    /* Ensure that szMode says "Page ". */
    FillStId(stPage, IDSTRChPage, sizeof(stPage));
#if !defined(KOREA)
    stPage[1] = ChUpper(stPage[1]);
    stPage[stPage[0] + 1] = ' ';
    bltbyte(&stPage[1], szMode, ++stPage[0]);
#endif

    /* Attatch the new page table to the document. */
        {
        register struct DOD *pdod = &(**hpdocdod)[doc];

        hpgtbOld = pdod->hpgtb;
        pdod->hpgtb = pdb.hpgtb;
        }

    /* Set cpMinCur to cp0 for the duration of the print. */
    Assert(cpMinCur == cpMinDocument);
    cpMinCur = cp0;

    /* If we are printing or repaginating without confirmation, then
    immediately halt if the user requests. */
    if (!fConfirm && !(*lpFPrContinue)(NULL, wNotSpooler))
    {
    goto ErrorNoAbort;
    }

    if (fPrint)
        {
        CHAR stTitle[cchMaxIDSTR];

        /* Set up the variables that describe the header. */
        if (!FInitHeaderFooter(TRUE, &pgnFirstHeader, &hrgpldHeader,
          &cpldHeader))
            {
        Error(IDPMTPRFAIL);
            goto ErrorNoAbort;
            }

        /* Set up the variables that describe the footer. */
        if (!FInitHeaderFooter(FALSE, &pgnFirstFooter, &hrgpldFooter,
          &cpldFooter))
            {
        Error(IDPMTPRFAIL);
            goto ErrorNoAbort;
            }

        /* Set the name of the function called to query whether the print should
    be aborted. */
        Escape(vhDCPrinter, SETABORTPROC, sizeof(FARPROC), (LPSTR)lpFPrContinue,
      (LPSTR)NULL);

        /* Set the printer into draft mode if necessary. */
        if (vfDraftMode)
            {
            Escape(vhDCPrinter, DRAFTMODE, sizeof(BOOL), (LPSTR)&vfDraftMode,
              (LPSTR)NULL);
            }

        /* Inform the spooler that we are about to print. */
        stTitle[0] = GetWindowText(hParentWw, (LPSTR)&stTitle[1],
          sizeof(stTitle) - 1) + 1;
        if ((iEscape = Escape(vhDCPrinter, STARTDOC, stTitle[0],
      (LPSTR)&stTitle[1], (LPSTR)NULL)) < 0)
        {
ErrorSwitch:
        switch (iEscape)
        {
        default:
        if ((iEscape & SP_NOTREPORTED) == 0)
            {
            break;
            }
        case SP_ERROR:
        Error(IDPMTCantPrint);
        break;

        case SP_APPABORT:
        case SP_USERABORT:
        break;

        case SP_OUTOFDISK:
        Error(IDPMTPrDiskErr);
        break;

        case SP_OUTOFMEMORY:
        Error(IDPMTPRFAIL);
        break;
        }
            goto ErrorNoAbort;
            }
        }
#ifdef DPRINT
CommSzSz("Start doc", "");
#endif

    /* If we are printing or repaginating without confirmation, then
    immediately halt if the user requests. */
    if (!fConfirm && !(*lpFPrContinue)(NULL, wNotSpooler))
    {
    goto Error;
    }

    // vcCopies is how many times to print each page
    // cCollateCopies is how many times to print the doc
    if (vbCollate && fPrint)
    {
        cCollateCopies = vcCopies;
        vcCopies = 1;
    }
    else
        cCollateCopies = 1;

    /* And away we go... */
    while (cCollateCopies--)
    {
    cCopies = 0;
    /*------------------------------------------------*/
    /* Tell the driver how many copies we want        */
    /*------------------------------------------------*/
    lHolder = SETCOPYCOUNT;
    /* Set number of copies the printer can print */
    CopyIncr = vcCopies;
    if (Escape(vhDCPrinter, QUERYESCSUPPORT, 2, (LPSTR) &lHolder, NULL))
        Escape(vhDCPrinter, SETCOPYCOUNT, 2, (LPSTR) &CopyIncr, (LPSTR) &CopyIncr);
    else
        CopyIncr = 1;

    do
        {
        /* Initalize the counters to the beginning of the document. */
        cp = cpMin;
        ichCp = 0;
        vpgn = pgnFirst;

        /* Step through the document, formatting a page and then printing a
        page. */
        while (cp < cpMac)
            {
            register struct PLD *ppld;
            CHAR *pch;
            int yp = ypTop;
            BOOL fPageAdj = FALSE;

            /* If only a range of pages are being printed, then stop when the
            last of the pages are printed. */
            if (fPrint && vfPrPages && vpgn > vpgnEnd)
                {
                goto DocFinished;
                }

            /* Show the page number we are formatting and printing. */
#if defined(KOREA)
            pch = &szMode[0];
            *pch++ = ' ';
            ncvtu(vpgn, &pch);
            *pch++ = ' ';
            bltbyte(&stPage[1], pch, stPage[0]+1);
#else
            pch = &szMode[stPage[0]];
            ncvtu(vpgn, &pch);
            *pch = '\0';
#endif
            DrawMode();

            /* Let's go through the document page by page. */
            pdb.ipld = 0;
            while (cp < cpMac)
                {
                /* If we are printing or repaginating without confirmation, then
                immediately halt if the user requests. */
                if (!fConfirm && !(*lpFPrContinue)(NULL, wNotSpooler))
                    {
                    goto Error;
                    }

                /* We have reached the end of the line descriptors; try to
                increase its size. */
                if (pdb.ipld >= cpld && !FChngSizeH(pdb.hrgpld, (cpld +=
                  cpldChunk) * cwPLD, FALSE))
                    {
                    goto Error;
                    }

PrintFormat:
                /* Format this line. */
                FormatLine(doc, cp, ichCp, cpMac, flmPrinting);

                /* Abort if a memory error has occurred. */
                if (vfOutOfMemory)
                    {
                    goto Error;
                    }

                /* If this line is a splat, we have to decide if we really want
                it or not. */
                if (fSplat = vfli.fSplat)
                    {
                    /* Next, we are going to format either the next line (cp and
                    ichCp) or this line after the page has been removed (cpT and
                    ichCpT). */
                    typeCP cpT = cp;
                    int ichCpT = ichCp;

                    cp = vfli.cpMac;
                    ichCp = vfli.ichCpMac;

                    if (fConfirm)
                        {
                        /* The user must be prompted if he wants to keep this
                        page break. */
                        if (FPromptPgMark(cpT))
                            {
                            if (pdb.fRemove)
                                {
                                /* The page mark was removed, set cp and ichCp
                                to point to the start of the next line. */
                                cp = cpT;
                                ichCp = ichCpT;
                                cpMac--;
                                goto PrintFormat;
                                }
                            }
                        else
                            {
                if (vfPrErr)
                {
                /* Something went wrong; punt. */
                goto Error;
                }
                else
                {
                /* Well, the user wishes to cancel repagination.
                */
                                goto CancelRepage;
                }
                            }
                        }

                    /* Set the print line descriptor for the line after a splat.
                    */
                    ppld = &(**pdb.hrgpld)[pdb.ipld];
                    ppld->cp = cp;
                    ppld->ichCp = ichCp;
                    ppld->rc.left = ppld->rc.top = ppld->rc.right =
                      ppld->rc.bottom = 0;

                    /* Force a page break here with no widow and orphan
                    control. */
                    goto BreakPage;
                    }

                /* Set the value for the current print line descriptor. */
                ppld = &(**pdb.hrgpld)[pdb.ipld];
                ppld->cp = cp;
                ppld->ichCp = ichCp;
                ppld->rc.left = xpLeft + vfli.xpLeft;
                ppld->rc.right = xpLeft + vfli.xpReal;
                ppld->rc.top = yp;
                ppld->rc.bottom = yp + vfli.dypLine;
                ppld->fParaFirst = (cp == vcpFirstParaCache && ichCp == 0 &&
                  vfli.cpMac != vcpLimParaCache);

                /* If this line is not the first line and it won't fit on the
                page, then force a page break, and prompt the user for input.
                NOTE: At least one line is printed on each page. */
                if (yp + vfli.dypLine > ypBottom && pdb.ipld > 0)
                    {
                    /* If the first line on the next page is the last line of a
                    paragraph, an orphan, then put the last line of this page on
                    the next page. */
                    if (vfli.cpMac == vcpLimParaCache && (cp !=
                      vcpFirstParaCache || ichCp != 0) && pdb.ipld > 1)
                        {
                        pdb.ipld--;
                        fPageAdj = TRUE;
                        }

                    /* If the last line on this page is the first line of a
                    paragraph, a widow, then put it on the next page. */
                    if (pdb.ipld > 1 && (**pdb.hrgpld)[pdb.ipld - 1].fParaFirst)
                        {
                        pdb.ipld--;
                        fPageAdj = TRUE;
                        }

BreakPage:
                    /* Add an entry into the page table (only during the first
                    copy of the document). */
                    if (cCopies == 0)
                        {
                        if ((pdb.ipgd = (**pdb.hpgtb).cpgd++) + 1 >=
                          (**pdb.hpgtb).cpgdMax)
                            {
                            if (!FChngSizeH(pdb.hpgtb, cwPgtbBase +
                              ((**pdb.hpgtb).cpgdMax += cpgdChunk) * cwPGD,
                              FALSE))
                                {
                                /* Not enough memory to expand the page table;
                                time to bail out.  */
                                goto ErrorMsg;
                                }
                            }
                        ppgd = &((**pdb.hpgtb).rgpgd[pdb.ipgd]);
                        ppgd->cpMin = (**pdb.hrgpld)[pdb.ipld].cp;
                        ppgd->pgn = vpgn + 1;
                        vdocPageCache = docNil;
                        }

                    /* Now go ask the user for his opinion. */
                    if (fConfirm)
                        {
                        if (!fSplat)
                            {
                            pdb.ipldCur = pdb.ipld;
                            if (FSetPage())
                                {
                                if (pdb.ipld != pdb.ipldCur)
                                    {
                                    /* The user has decided to move the page
                                    break. */
                                    pdb.ipld = pdb.ipldCur;
                                    cpMac++;
                                    fPageAdj = TRUE;
                                    }
                                }
                            else
                                {
                if (vfPrErr)
                    {
                    /* Something went wrong; punt. */
                    goto Error;
                    }
                else
                    {
                    /* Well, the user wishes to cancel
                    repagination.  */
                    goto CancelRepage;
                    }
                                }
                            }

                        /* After repaginating interactively, make certain the
                        screen reflects the current page break. */
                        UpdateWw(wwCur, FALSE);
                        }

                    /* This page has finished formatting, reset the cp and ichCp
                    pair to the top of the next page if necessary and get out of
                    this loop.  */
                    if (fPageAdj)
                        {
                        ppld = &(**pdb.hrgpld)[pdb.ipld];
                        cp = ppld->cp;
                        ichCp = ppld->ichCp;
                        }
                    break;
                    }

                /* Set the cp and ichCp to the start of the next line. */
                cp = vfli.cpMac;
                ichCp = vfli.ichCpMac;
                yp += vfli.dypLine;
                pdb.ipld++;
                }

            /* Now that we have figured out which lines fit on the page, its
            time to print them. */
            if (fPrint && (!vfPrPages || (vpgn >= vpgnBegin && vpgn <=
              vpgnEnd)))
                {
                BOOL fFirstBand = TRUE;

                /* This loop is executed for each band (once for non-banding
                devices). */
                for ( ; ; )
                    {
                    RECT rcBand;

                    /* Abort the print if the user so desires. */
                    if (!(*lpFPrContinue)(NULL, wNotSpooler))
                        {
                        goto Error;
                        }

                    /* Get the next band. */
                    if ((iEscape = Escape(vhDCPrinter, NEXTBAND, 0,
                      (LPSTR)NULL, (LPSTR)&rcBand)) < 0)
                        {
                        goto ErrorSwitch;
                        }
#ifdef DPRINT
CommSzSz("Next band", "");
#endif

                    /* If the band is empty then we are finished with this
                    page. */
                    if (rcBand.top >= rcBand.bottom || rcBand.left >=
                      rcBand.right)
                        {
                        /* Reset the currently selected font. */
                        ResetFont(TRUE);
                        break;
                        }

                    /* The printer DC gets wiped clean at the start of each
                    page.  It must be reinitialized. */
                    if (fFirstBand)
                        {
                        /* Set the printer into transparent mode. */
                        SetBkMode(vhDCPrinter, TRANSPARENT);

                        /* Reset the currently selected font. */
                        ResetFont(TRUE);

                        fFirstBand = FALSE;
                        }

                    /* First, print the header, if there is one. */
                    if (vpgn >= pgnFirstHeader && !FPrintBand(doc,
                      hrgpldHeader, cpldHeader, &rcBand))
                        {
                        goto Error;
                        }

                    /* Print that part of the document that lies in the
                    band. */
                    if (!FPrintBand(doc, pdb.hrgpld, pdb.ipld, &rcBand))
                        {
                        goto Error;
                        }

                    /* Lastly, print the footer, if it exists. */
                    if (vpgn >= pgnFirstFooter && !FPrintBand(doc,
                      hrgpldFooter, cpldFooter, &rcBand))
                        {
                        goto Error;
                        }
                    }
                }

            /* Finally, bump the page counter. */
            vpgn++;
            }
DocFinished:;
        }
    while (fPrint && (cCopies += CopyIncr) < vcCopies);
    }

    /* If a range of pages is being printed then we reattatch the old page table
    to the document. */
    if (fPrint && vfPrPages)
        {
        goto RestorePgtb;
        }

CancelRepage:
    /* If the page table has changed, then mark the document as dirty. */
    if (!(**hpdocdod)[doc].fDirty)
        {
        (**hpdocdod)[doc].fDirty = (hpgtbOld == NULL) || ((**pdb.hpgtb).cpgd !=
          (**hpgtbOld).cpgd) || !FRgchSame((**pdb.hpgtb).rgpgd,
          (**hpgtbOld).rgpgd, (**pdb.hpgtb).cpgd * cchPGD);
        }

    /* Delete the old page table. */
    if (hpgtbOld != NULL)
        {
        FreeH(hpgtbOld);
        }

    /* Printing and non-interactive repagination can't be undone. */
    if (!fConfirm)
        {
        NoUndo();
        }

ErrorLoop:
    /* Delete the array of line descriptors. */
    FreeH(pdb.hrgpld);

    if (fPrint)
        {
        BOOL fResetMode = FALSE;

        /* Delete the descriptors for the header and footer. */
        if (hrgpldHeader != NULL)
            {
            FreeH(hrgpldHeader);
            }
        if (hrgpldFooter != NULL)
            {
            FreeH(hrgpldFooter);
            }

        /* Tell the spooler that we are finished printing. */
        if (!vfPrErr)
            {
            Escape(vhDCPrinter, ENDDOC, 0, (LPSTR)NULL, (LPSTR)NULL);
#ifdef DPRINT
CommSzSz("End doc", "");
#endif
            }

        /* Reset the printer from draft mode if necessary. */
        if (vfDraftMode)
            {
            Escape(vhDCPrinter, DRAFTMODE, sizeof(BOOL), (LPSTR)&fResetMode,
              (LPSTR)NULL);
            }
        }

    /* Reset the value of cpMinCur. */
    cpMinCur = cpMin;

    /* Invalidate the mode and page caches. */
    docMode = vdocPageCache = docNil;

    /* Since this might have changed the page breaks, dirty the windows so that
    UpdateDisplay() will show them. */
    TrashAllWws();

Abort:
    if (fPrint)
    {
    /* Create a new IC for the printer. */
    ResetFont(TRUE);
    FreePrinterDC();
    GetPrinterDC(FALSE);
    }

    /* Enable all other windows. */
    EnableWindow(hParentWw, TRUE);
    EnableOtherModeless(TRUE);

    if (fConfirm)
        {
    /* Let the user know that we are finished repaginating. */
    EndLongOp(vhcIBeam);
    }
    else if (vhWndCancelPrint != NULL)
    {
    /* Get rid of the dialog box telling the user how to cancel printing or
    repagination. */
        DestroyWindow(vhWndCancelPrint);
        vhWndCancelPrint = NULL;
    DispatchPaintMsg();
        }

#ifndef INEFFLOCKDOWN
    if (lpDialogCancelPrint)
        FreeProcInstance(lpDialogCancelPrint);
    if (lpFPrContinue)
        FreeProcInstance(lpFPrContinue);
    lpDialogCancelPrint = lpFPrContinue = NULL;
#endif

    fPrinting = FALSE;

#if defined(OLE)
    UPDATE_INVALID(); /* WM_PAINTS blocked while printing, repaint when done */
#endif

    /* Here is the exit point for this routine. */
    return;

ErrorMsg:
    /* Give the user an error message before aborting the print/repagination. */
    Error(IDPMTPRFAIL);

Error:
    /* Abort the print job if necessary. */
    if (fPrint)
        {
        Escape(vhDCPrinter, ABORTDOC, 0, (LPSTR)NULL, (LPSTR)NULL);
#ifdef DPRINT
CommSzSz("Abort doc", "");
#endif
        }

ErrorNoAbort:
    /* Indicate that an error has occurred.  (Cancellation is an error.) */
    vfPrErr = TRUE;

RestorePgtb:
    /* Reconnect to old page table to the document, and then delete the new
    page table. */
    (**hpdocdod)[doc].hpgtb = hpgtbOld;
    FreeH(pdb.hpgtb);

    goto ErrorLoop;
    }


BOOL far PASCAL FPrContinue(hDC, iCode)
HDC hDC;
int iCode;
    {
    /* This routine returns TRUE if the user has not aborted the print; FALSE
    otherwise. */

    extern CHAR *vpDlgBuf;
    extern HWND vhWndCancelPrint;
    extern BOOL vfPrErr;
    extern int vfOutOfMemory;

    struct PDB *ppdb = (struct PDB *)vpDlgBuf;
    MSG msg;


#if 0
    /* If a printer error has occurred, that is the same as an abort. */
    if (vfPrErr || vfOutOfMemory || (iCode < 0 && iCode != SP_OUTOFDISK))
        {
        return (FALSE);
        }

    /* If we have been called by the spooler then just return TRUE.
       (Calling PeekMessage() at this point might be death.) */

    if (iCode != wNotSpooler)
        {
        Assert(iCode == 0 || iCode == SP_OUTOFDISK);
        if (iCode == 0)
            return (TRUE);
        /* else fall through to wait -- we're getting called by GDI while 
           the spooler frees up some temp files.  this is NOT a genuine
           error yet!  12/20/89 ..pault */
        }
#else
    if (vfPrErr || vfOutOfMemory)
        return FALSE;
#endif

    /* If there are any messages waiting the Cancel Print window, then send them
    to the window messages handling routine. */
    while (!ppdb->fCancel && PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
        if (!IsDialogMessage(vhWndCancelPrint, &msg))
            {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            }
        }

    /* If one of the messages was a cancel print meassge, then the value of
    fCancel has been set. */
    return !(vfPrErr = ppdb->fCancel || vfOutOfMemory);
    }


BOOL far PASCAL DialogCancelPrint(hWnd, message, wParam, lParam)
HWND hWnd;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* This routine is supposed to process messages to the Cancel Print dialog
    box, but, in reality, the sole responsiblity of this routine is to set the
    flag fCancel if the user wishes to cancel printing. */

    extern CHAR *vpDlgBuf;
    extern HWND vhWndMsgBoxParent;

    struct PDB *ppdb = (struct PDB *)vpDlgBuf;

    if ((message == WM_COMMAND && (wParam == idiCancel || wParam == idiOk)) ||
      (message == WM_CLOSE))
        {
        ppdb->fCancel = TRUE;
        return (TRUE);
        }
    if (message == WM_INITDIALOG)
        {
        extern int docCur;
        extern char szUntitled[];
        extern struct DOD (**hpdocdod)[];
        extern char * PchStartBaseNameSz();
        struct DOD *pdod = &(**hpdocdod)[docCur];
        CHAR *psz = &(**(pdod->hszFile))[0];

        SetDlgItemText(hWnd, idiPrCancelName,
                       (LPSTR)(*psz ? PchStartBaseNameSz(psz) : szUntitled));
        return(TRUE);
        }
    if (message == WM_ACTIVATE)
        {
        vhWndMsgBoxParent = wParam == 0 ? (HWND)NULL : hWnd;
        }
    return (FALSE);
    }


DispatchPaintMsg()
    {
    /* This routine looks for and dispatches any outstanding paint messages for
    Write (like after an EndDialog() call). */

    extern int vfOutOfMemory;

    MSG msg;

    while (!vfOutOfMemory && PeekMessage((LPMSG)&msg, NULL, WM_PAINT, WM_PAINT,
      PM_REMOVE))
        {
        DispatchMessage((LPMSG)&msg);
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\printdef.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* printdefs.h */

#ifndef PAGEONLY        /* ifdef for page table declarations only */

#define wNotSpooler	12741	/* an infamous number */

#define cchMaxProfileSz	256
#define cchMaxIDSTR     30

struct PLD
        { /* print line descriptor */
        typeCP cp;
        int ichCp;
        RECT rc;
        BOOL fParaFirst;
        };

#define cwPLD           (sizeof(struct PLD) / sizeof(int))
#define cpldInit        25
#define cpldChunk       10
#define cpldRH          5

#endif  /* PAGEONLY */

#define ipgdMaxFile     2

struct PGD
        {
        int pgn;
        typeCP cpMin;
        };

#define bcpPGD          2
#define cchPGD          (sizeof(struct PGD))
#define cwPGD           (sizeof(struct PGD) / sizeof(int))
#define cpgdChunk       10
#define cwPgtbBase      2

struct PGTB
        { /* Page table */
        int             cpgd;   /* Number of entries (sorted ascending) */
        int             cpgdMax; /* Heap space allocated */
        struct PGD      rgpgd[ipgdMaxFile]; /* Size varies */
        };

struct PDB
        { /* Print dialog buffer */
        struct PLD      (**hrgpld)[];
        int             ipld;
        int             ipldCur;
        struct PGTB     **hpgtb;
        int             ipgd;
        BOOL            fCancel;
        BOOL            fRemove;
        };

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\quit.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Quit.c -- MW quit commands (non-resident) */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
//#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOFONT
#define NOHDC
#define NOMB
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOMINMAX
//#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "str.h"
#include "cmddefs.h"
#define NOKCCODES
#include "ch.h"
#include "docdefs.h"
#include "editdefs.h"
#include "filedefs.h"
#include "wwdefs.h"
#include "propdefs.h"
#include "dlgdefs.h"
#include "commdlg.h"
#if defined(OLE)
#include "obj.h"
#endif

#include "debug.h"

extern PRINTDLG PD;  /* Common print dlg structure, initialized in the init code */
extern struct FCB       (**hpfnfcb)[];
extern int      fnMac;
extern struct WWD rgwwd[];
extern int      wwMac;
extern struct DOD (**hpdocdod)[];
extern int             docCur;     /* Document in current ww */
extern int              vfExtScrap;
extern int              rgval[];
extern int              docMac;
extern int              vfBuffersDirty;
extern int              vdxaPaper;
extern int              vdyaPaper;
extern int              ferror;
extern int              docScrap;
extern struct PAP       vpapAbs;
extern int              vccpFetch;
extern CHAR             *vpchFetch;
extern int              vfScrapIsPic;
extern typeCP           vcpLimParaCache;


FMmwClose( hwnd )
HWND hwnd;
{   /* Handle WM_CLOSE message sent to parent window. Return FALSE if
       the CLOSE should be aborted, TRUE if it is OK to go ahead
       and CLOSE (DestroyWindow is called in this case). */

 extern int vfDead;
 extern VOID (FAR PASCAL *lpfnRegisterPenApp)(WORD, BOOL);
extern WORD fPrintOnly;

 if (fPrintOnly || FConfirmSave())
    {
    extern int vfOwnClipboard;

    FreeMemoryDC( FALSE );   /* To give FRenderAll max memory */

    /* Render Data BEFORE the world collapses around our ears */
    if (vfOwnClipboard)
        {   /* We are the clipboard owner -- render the clipboard contents in
               all datatypes that we know about */
        if (!FRenderAll())
                /* Render failed; abort close */
            return FALSE;
        }

#if defined(OLE)
    if (ObjClosingDoc(docCur,NULL)) // do this *after* call to RenderAll!
        return FALSE;
#endif

    /* pen windows */
    if (lpfnRegisterPenApp)   // global
        (*lpfnRegisterPenApp)((WORD)1, fFalse);   // deregister

    if (PD.hDevMode)
        {
        /* We'd opened a Win3 printer driver before, now discard */
        GlobalFree(PD.hDevMode);
        PD.hDevMode = NULL;
        }
    vfDead = TRUE;  /* So we don't repaint or idle anymore */

    DestroyWindow( hwnd );
    KillTempFiles( FALSE );
    return TRUE;        /* OK to close window */
    }

 return FALSE;  /* ABort the close */
}




MmwDestroy()
{   /* Parent window is being destroyed */
 extern HWND hParentWw;
 extern HWND vhWndPageInfo;
 extern HDC vhDCRuler;
 extern HBRUSH hbrBkgrnd;
 extern HFONT vhfPageInfo;
 extern HBITMAP hbmBtn;
 extern HBITMAP hbmMark;
#ifdef JAPAN 	//01/21/93
 extern HANDLE hszNoMemorySel;
#endif
 extern HANDLE hszNoMemory;
 extern HANDLE hszDirtyDoc;
 extern HANDLE hszCantPrint;
 extern HANDLE hszPRFAIL;

 HBRUSH hbr = GetStockObject( WHITE_BRUSH );
 HDC hDC = GetDC( vhWndPageInfo );

#ifdef WIN30
    {
    /* We use the help engine so advise it we're going far far away */

    CHAR sz[cchMaxFile];
    PchFillPchId(sz, IDSTRHELPF, sizeof(sz));
    WinHelp(hParentWw, (LPSTR)sz, HELP_QUIT, NULL);
    }
#endif

 FreeMemoryDC( TRUE );
 SelectObject( GetDC( hParentWw ), hbr );
 SelectObject( wwdCurrentDoc.hDC, hbr );
 if (vhDCRuler != NULL)
    {
    SelectObject( vhDCRuler, hbr );
    }
 DeleteObject( hbrBkgrnd );

 DeleteObject( SelectObject( hDC, hbr ) );
 if (vhfPageInfo != NULL)
     {
     DeleteObject( SelectObject( hDC, GetStockObject( SYSTEM_FONT ) ) );
     }

 if (hbmBtn != NULL)
     {
     DeleteObject( hbmBtn );
     }
 if (hbmMark != NULL)
     {
     DeleteObject( hbmMark );
     }

#ifdef JAPAN 	//01/21/93
 if (hszNoMemorySel != NULL)
     {
     GlobalFree( hszNoMemorySel );
     }
#endif
 if (hszNoMemory != NULL)
     {
     GlobalFree( hszNoMemory );
     }
 if (hszDirtyDoc != NULL)
     {
     GlobalFree( hszDirtyDoc );
     }
 if (hszCantPrint != NULL)
     {
     GlobalFree( hszCantPrint );
     }
 if (hszPRFAIL != NULL)
     {
     GlobalFree( hszPRFAIL );
     }

#if defined(JAPAN) & defined(DBCS_IME)
 /* Release Ime communication memory */
{
    extern HANDLE   hImeMem;
    extern HANDLE   hImeSetFont;

    if (hImeMem)
        GlobalFree(hImeMem);

    if(hImeSetFont != NULL) {
        HDC hdc;
        HANDLE oldhfont;

        hdc = GetDC(NULL);
        oldhfont = SelectObject(hdc,hImeSetFont);
        SelectObject(hdc,oldhfont);
        DeleteObject(hImeSetFont);
        ReleaseDC(NULL, hdc);
    }
}
#endif

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
//IR_UNDETERMINE
 /* Release Ime Undetermin string & attrib memory */
{
    extern HANDLE   hImeUnAttrib;
    extern HANDLE   hImeUnString;
    extern CHAR     szWriteProduct[];
    extern CHAR     szImeHidden[];
    extern int      vfImeHidden; /*T-HIROYN ImeHidden Mode flag*/

    if (hImeUnAttrib)
        GlobalFree(hImeUnAttrib);

    if (hImeUnString)
        GlobalFree(hImeUnString);

    WriteProfileString((LPSTR)szWriteProduct, (LPSTR)szImeHidden,
                vfImeHidden ? (LPSTR)"1" : (LPSTR)"0" );
}
#endif


#ifdef FONT_KLUDGE
 RemoveFontResource( (LPSTR)"helv.fon" );
#endif /* FONT_KLUDGE */

#if defined(OLE)
    ObjShutDown();
#endif

 PostQuitMessage( 0 );
}




KillTempFiles( fEndSession )
int fEndSession;
{   /* Kill off all of the temp files. MEMO cannot run after this is done */
int f;
int fn, fnT;

CloseEveryRfn( TRUE );

/* Delete all temp files */

/* loop thru the FCB table looking for files that should be deleted before
      we quit. */
for (fn = 0; fn < fnMac; fn++)
        {
        int fpe;
        struct FCB *pfcb = &(**hpfnfcb)[fn];
        if (pfcb->rfn != rfnFree && pfcb->fDelete)
                /* Having found a file that must be deleted, delete it */
                {
                /* This should be FDeleteFile all of the time, but we don't
                   want to add a window enumeration during End Session
                   at this very late stage of the project */

                if (fEndSession)
                    FpeDeleteSzFfname( **pfcb->hszFile );
                else
                    FDeleteFile( **pfcb->hszFile );
                (**hpfnfcb) [fn].rfn = rfnFree;
                }
        }
}






#ifdef ENABLE   /* Part of "Save All", not needed */
int CnfrmSz(sz)
CHAR    *sz;
{
extern   AlertBoxSz2();
int     cch;

cch = CchFillSzId(&stBuf[1], IDPMTSaveChanges);
stBuf[++cch] = chSpace;
cch += CchCopySz(sz, &stBuf[cch+1]);
stBuf[++cch] = chQMark;
stBuf[0] = cch;
return(AlertBoxSz2(stBuf));
}
#endif  /* ENABLE */



#ifdef ENABLE   /* Not needed, only 1 document in MEMO */
int
FAllDocsClean()
{
int     fAllClean = true;
int     dty;
int     doc;

if (vfBuffersDirty)
        return false;

for (doc = 0; doc < docMac; ++doc)
        {
        dty = (**hpdocdod)[doc].dty;
        if ((dty != dtyNormal && dty != dtySsht) ||
                (**hpdocdod)[doc].hpctb == 0  || !(**hpdocdod)[doc].fDirty)
                continue;
        fAllClean = false;
        }
return fAllClean;
}
#endif



#ifdef ENABLE    /* We don't support saving between-session state info */
WriteStateInfo()
{ /* Write out state information into Word resource file */
        struct STATEINFO stiTemp;
        HANDLE           hRes, hData;

        UseResFile(vresSystem);

        SetWords(&stiTemp,0,cwSTATEINFO);

        stiTemp.sf.fScrnDraftStor = vfScrnDraft;
        stiTemp.sf.fPrintModeStor = vfPrintMode;
        stiTemp.sf.fDriverDefaultOK = vfDriverDefaultOK;
        stiTemp.utCurStor = utCur;
        stiTemp.vcDaisyPitchStor = vcDaisyPitch;
        stiTemp.vBaudRateStor =vBaudRate;
        stiTemp.vPortNumStor = vPortNum;
        if (hszPrdFile != 0)
                {/* User has a Word printer driver selected currently */
                int cch = CchCopySz(**hszPrdFile,stiTemp.rgchPrd);
                stiTemp.vdxaPaperStor = vdxaPaper;
                stiTemp.vdyaPaperStor = vdyaPaper;
                stiTemp.sf.fPrintStateOK = true;
                }
        else
                stiTemp.sf.fPrintStateOK = false;
        hRes = GetResource(WINF, 1);
        if (hRes != 0L)
                RmveResource(hRes);
        hData = NewHandle(0);
        if (HandleAppendQ(hData,&stiTemp,sizeof(stiTemp)))
                AddResource(hData, WINF, 1, "");
        }
#endif  /* ENABLE */


fnQuit(hWnd)
/* user has selected Quit menu item... */
HWND hWnd;
{
    SendMessage(hWnd, WM_CLOSE, 0, 0L);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\ruler2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains routines that change dialog boxes or the menu for the
ruler. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOCLIPBOARD
#include <windows.h>
#include "mw.h"
#include "menudefs.h"
#include "str.h"


extern HMENU vhMenu;
extern CHAR stBuf[256];
extern int utCur;

SetRulerMenu(fShowRuler)
BOOL fShowRuler;
    {
    /* This routine puts "Ruler On" into the menu if fShowRuler is true; else,
    "Ruler Off" is put into the menu. */

    FillStId(stBuf, fShowRuler ? IDSTRShowRuler : IDSTRHideRuler, sizeof(stBuf));
    ChangeMenu(vhMenu, imiShowRuler, (LPSTR)&stBuf[1], imiShowRuler, MF_CHANGE);
    }


#ifdef RULERALSO
#include "cmddefs.h"
#include "propdefs.h"
#include "rulerdef.h"
#include "dlgdefs.h"

extern HWND vhDlgIndent;
extern int mprmkdxa[];
extern int vdxaTextRuler;

SetIndentText(rmk, dxa)
int rmk;	/* ruler mark */
unsigned dxa;
    {
    /* This routine reflects the changes made on the ruler in the Indentd dialog
    box. */

    unsigned dxaShow;
    int idi;
    CHAR sz[cchMaxNum];
    CHAR *pch = &sz[0];

    /* Get the dialog item number and the measurement. */
    switch (rmk)
	{
    case rmkLMARG:
	dxaShow = dxa;
	idi = idiParLfIndent;
	break;

    case rmkINDENT:
	dxaShow = dxa - mprmkdxa[rmkLMARG];
	idi = idiParFirst;
	break;

    case rmkRMARG:
	dxaShow = vdxaTextRuler - dxa;
	idi = idiParRtIndent;
	break;
	}
    CchExpZa(&pch, dxaShow, utCur, cchMaxNum);
    SetDlgItemText(vhDlgIndent, idi, (LPSTR)sz);

    if (rmk == rmkLMARG)
	{
	/* If the left indent changes, then we need to update the first line
	indent. */
	dxaShow = mprmkdxa[rmkINDENT] - dxaShow;
	pch = sz;
	CchExpZa(&pch, dxaShow, utCur, cchMaxNum);
	idi = idiParFirst;
	SetDlgItemText(vhDlgIndent, idi, (LPSTR)sz);
	}
    }
#endif /* RULERALSO */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\rare.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This routine sets up the screen position used by Word relative to the
current device. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOCTLMGR
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOATOM
#define NODRAWTEXT
#define NOMSG
#define NOOPENFILE
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "scrndefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "printdef.h"
#include "str.h"
#include "docdefs.h"
#include "propdefs.h"
#include "machdefs.h"
#include "fontdefs.h"
#include "winddefs.h"
#include <commdlg.h>


MmwWinSysChange(wm)
int wm;
    {
    /* This routine processes the WM_SYSCOLORCHANGE, WM_WININICHANGE,
    WM_DEVMODECHANGE, and WM_FONTCHANGE  messages. */

    extern HDC vhDCRuler;
    extern HBRUSH hbrBkgrnd;
    extern long rgbBkgrnd;
    extern long rgbText;
    extern struct WWD rgwwd[];
    extern HDC vhMDC;
    extern BOOL vfMonochrome;
    extern HWND hParentWw;
    extern HWND vhWndPageInfo;
    extern HBITMAP vhbmBitmapCache;
    extern BOOL vfBMBitmapCache;
    extern int vfPrinterValid;
    extern CHAR szWindows[];
    extern CHAR szDevices[];
    extern CHAR (**hszPrinter)[];
    extern CHAR (**hszPrDriver)[];
    extern CHAR (**hszPrPort)[];
    extern CHAR (**hszDevmodeChangeParam)[];
    extern CHAR (**hszWininiChangeParam)[];
    extern HFONT vhfPageInfo;
    extern int docMode;
    extern HWND vhWndCancelPrint;
    extern BOOL vfIconic;
    extern BOOL vfWarnMargins;
    extern int wWininiChange;

    BOOL FSetWindowColors(void);

    CHAR szPrinter[cchMaxProfileSz];
    CHAR (**hszPrinterSave)[];
    CHAR (**hszPrDriverSave)[];
    CHAR (**hszPrPortSave)[];
    BOOL fNotPrinting = (vhWndCancelPrint == NULL);
    RECT rc;

    switch (wm)
        {
    case WM_SYSCOLORCHANGE:
        /* Someone is changing the system colors. */
        if (FSetWindowColors())
            {
            /* Change the colors of the ruler. */
            if (vhDCRuler != NULL)
                {
                HPEN hpen;

                /* Set the background and foreground colors of the ruler. */
                SetBkColor(vhDCRuler, rgbBkgrnd);
                SetTextColor(vhDCRuler, rgbText);

                /* Set the pen for the ruler. */
                if ((hpen = CreatePen(0, 0, rgbText)) == NULL)
                    {
                    hpen = GetStockObject(BLACK_PEN);
                    }
                DeleteObject(SelectObject(vhDCRuler, hpen));

                /* Set the background brush for the ruler. */
                SelectObject(vhDCRuler, hbrBkgrnd);
                }

            if (wwdCurrentDoc.hDC != NULL)
                {
                /* Set the background and foreground colors. */
                SetBkColor(wwdCurrentDoc.hDC, rgbBkgrnd);
                SetTextColor(wwdCurrentDoc.hDC, rgbText);

                /* Set the background brush. */
                SelectObject(wwdCurrentDoc.hDC, hbrBkgrnd);

                if (vhMDC != NULL && vfMonochrome)
                    {
                    /* If the display is a monochrome device, then set the text
                    color for the memory DC.  Monochrome bitmaps will not be
                    converted to the foreground and background colors in this
                    case, we must do the conversion. */
                    SetTextColor(vhMDC, rgbText);
                    }
                }

            if (hParentWw != NULL)
                {
                /* Set the background brush for the parent window. */
                DeleteObject(SelectObject(GetDC(hParentWw), hbrBkgrnd));
                }
            }

        if (vhWndPageInfo != NULL)
            {
            HBRUSH hbr;
            HDC hDC = GetDC(vhWndPageInfo);

            /* Set the colors for the page info window. */
            if ((hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME))) ==
              NULL)
                {
                hbr = GetStockObject(BLACK_BRUSH);
                }
            DeleteObject(SelectObject(hDC, hbr));
#ifdef WIN30
            /* If the user has their colors set with a TextCaption color of
               black then this becomes hard to read!  We just hardcode this
               to be white since the background defaults to being black */
            SetTextColor(hDC, (DWORD) -1);
#else
            SetTextColor(hDC, GetSysColor(COLOR_CAPTIONTEXT));
#endif
            }

#if defined(JAPAN) & defined(IME_HIDDEN) //IME3.1J
        GetImeHiddenTextColors();
#endif

        /* If the bitmap cache is holding a resized metafile, then free the
        cache because the bitmap might contain part of the background that might
        have changed. */
        if (vhbmBitmapCache != NULL && !vfBMBitmapCache)
            {
            FreeBitmapCache();
            }
        break;

    case WM_WININICHANGE:
        /* We only care if the "windows", "devices", or "intl" fields have
           changed -- this has been taken care of already, see mmw.c */

           if (wWininiChange & wWininiChangeToIntl)
           {
                extern HWND vhDlgRunning;
                extern int utCur;
                extern CHAR         vchDecimal;  /* decimal point character */
                CHAR bufT[3];  /* to hold decimal point string */
                extern CHAR         szsDecimal[];
                extern CHAR         szsDecimalDefault[];
                extern CHAR         szIntl[];
                extern HWND vhWndRuler;
                extern int     viDigits;
                extern BOOL    vbLZero;

                if (GetProfileInt((LPSTR)szIntl, (LPSTR)"iMeasure", 1) == 1)
                    utCur = utInch;
                else
                    utCur = utCm;

                viDigits = GetProfileInt((LPSTR)szIntl, (LPSTR)"iDigits", 2);
                vbLZero  = GetProfileInt((LPSTR)szIntl, (LPSTR)"iLZero", 0);

                /* Get the decimal point character from the user profile. */
                GetProfileString((LPSTR)szIntl, (LPSTR)szsDecimal, (LPSTR)szsDecimalDefault,
                    (LPSTR)bufT, 2);
                vchDecimal = *bufT;

                InvalidateRect(vhWndRuler, (LPRECT)NULL, FALSE);
                UpdateRuler();
           }

           if ((wWininiChange & wWininiChangeToDevices) ||
               (wWininiChange & wWininiChangeToWindows))
            {
            /* Reestablish the printer from the profile in case it was the
            printer that was changed. */
            hszPrinterSave = hszPrinter;
            hszPrDriverSave = hszPrDriver;
            hszPrPortSave = hszPrPort;

            if (FGetPrinterFromProfile())
                {
                BOOL fPrChange = FALSE;

                if (hszPrinterSave == NULL || hszPrDriverSave == NULL ||
                  hszPrPortSave == NULL || hszPrinter == NULL || hszPrDriver ==
                  NULL || hszPrPort == NULL || WCompSz(&(**hszPrinter)[0],
                  &(**hszPrinterSave)[0]) != 0 || WCompSz(&(**hszPrDriver)[0],
                  &(**hszPrDriverSave)[0]) != 0 || WCompSz(&(**hszPrPort)[0],
                  &(**hszPrPortSave)[0]) != 0)
                    {
                    /* If we are not printing, then we can reflect the change of
                    the printer on the screen. */
                    if (!(fPrChange = fNotPrinting))
                        {
                        /* We are printing while the printer has changed, set
                        the flags so that the next time we get a printer DC we
                        will assume that it is valid. */
                        Assert(vfPrinterValid);
                        vfWarnMargins = TRUE;
                        }
                    }

                /* Delete the saved copies of the printer strings. */
                if (hszPrinterSave != NULL)
                    {
                    FreeH(hszPrinterSave);
                    }
                if (hszPrDriverSave != NULL)
                    {
                    FreeH(hszPrDriverSave);
                    }
                if (hszPrPortSave != NULL)
                    {
                    FreeH(hszPrPortSave);
                    }

                if (fPrChange)
                    {
                    /* Get the new printer DC and update the world. */
                    goto GetNewPrinter;
                    }
                }
            else
                {
                Error(IDPMTNoMemory);
                hszPrinter = hszPrinterSave;
                hszPrDriver = hszPrDriverSave;
                hszPrPort = hszPrPortSave;
                }
            }
        break;

    case WM_DEVMODECHANGE:
        /* The device mode for some printer has changed; check to see if it was
        our printer. */
        if (fNotPrinting && hszPrinter != NULL &&
            (hszDevmodeChangeParam == NULL ||
                (bltszx(*hszDevmodeChangeParam, (LPSTR)szPrinter ),
                WCompSz(szPrinter, &(**hszPrinter)[0]) == 0)))
            {
            extern PRINTDLG PD;  /* Common print dlg structure, initialized in the init code */
GetNewPrinter:
            if (PD.hDevMode)
                GlobalFree(PD.hDevMode);
            if (PD.hDevNames)
                GlobalFree(PD.hDevNames);
            PD.hDevMode = PD.hDevNames = NULL;

            /* The printer has changed, so get rid of the old one. */
            FreePrinterDC();

            fnPrGetDevmode();

#if defined(OLE)
            ObjSetTargetDevice(TRUE);
#endif

            /* The printer description has changed; assume the new printer is
            valid. */
            vfPrinterValid = vfWarnMargins = TRUE;
            GetPrinterDC(FALSE);
            ResetFontTables();

RedrawWindow:
            /* Everything must be redisplayed because the world may have
            changed. */
            if (!vfIconic)
                {
                InvalidateRect(wwdCurrentDoc.wwptr, (LPRECT)NULL, FALSE);
                }
        }

        if (hszDevmodeChangeParam != NULL)
            FreeH(hszDevmodeChangeParam);
        hszDevmodeChangeParam = NULL;
        break;

    case WM_FONTCHANGE:
        /* The font used to display the page number may have changed. */
        if (vhfPageInfo != NULL)
            {
            DeleteObject(SelectObject(GetDC(vhWndPageInfo),
              GetStockObject(SYSTEM_FONT)));
            vhfPageInfo = NULL;
            }
        docMode = docNil;
        DrawMode();

        ResetFontTables();

        goto RedrawWindow;
        }   /* end switch */
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\ruler3.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* The file contains the message handler for the ruler. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOCLIPBOARD
#define NOMENUS
#define NOCTLMGR
#include <windows.h>

extern HBITMAP hbmNull;

extern HWND vhWndRuler;
extern HDC vhDCRuler;
extern HDC hMDCBitmap;
extern HDC hMDCScreen;
extern HBITMAP hbmBtn;
extern HBITMAP hbmMark;
extern HBITMAP hbmNullRuler;
extern int dxpRuler;
extern int dypRuler;


long FAR PASCAL RulerWndProc(hWnd, message, wParam, lParam)
HWND hWnd;
unsigned message;
WORD wParam;
LONG lParam;
    {
    /* This routine processes the messages sent to the ruler window. */

    extern vfCloseFilesInDialog;

    PAINTSTRUCT ps;

    switch (message)
        {
        case WM_PAINT:
            /* Time for the ruler to draw itself. */
            ResetRuler();
            BeginPaint(hWnd, (LPPAINTSTRUCT)&ps);
            RulerPaint(FALSE, TRUE, TRUE);
            EndPaint(hWnd, (LPPAINTSTRUCT)&ps);
            RulerPaint(TRUE, FALSE, FALSE);
            break;

        case WM_SIZE:
            /* We are saving the length of the ruler; we already know it's
            height. */
            dxpRuler = MAKEPOINT(lParam).x;
            break;

        case WM_DESTROY:
            /* Destroy the ruler window. */
            if (hMDCBitmap != NULL)
                {
                DeleteDC(hMDCBitmap);
                }
            if (hMDCScreen != NULL)
                {
                DeleteObject(SelectObject(hMDCScreen, hbmNull));
                DeleteDC(hMDCScreen);
                }
            if (vhDCRuler != NULL)
                {
                DeleteObject(SelectObject(vhDCRuler,
                  GetStockObject(SYSTEM_FONT)));
                SelectObject(vhDCRuler, GetStockObject(WHITE_BRUSH));
                DeleteObject(SelectObject(vhDCRuler,
                  GetStockObject(BLACK_PEN)));
                ReleaseDC(vhWndRuler, vhDCRuler);
                }
            if (hbmNullRuler != NULL)
                {
                DeleteObject(hbmNullRuler);
                hbmNullRuler = NULL;
                }
            vhDCRuler = hMDCScreen = hMDCBitmap = NULL;
            break;

        case WM_LBUTTONDOWN:
        case WM_LBUTTONDBLCLK:
            /* Process mouse events on the ruler. */
            RulerMouse(MAKEPOINT(lParam));
            break;

#ifdef DEBUG
        case WM_RBUTTONDBLCLK:
            /* This the trap door that displays the "marquee" message. */
            if (wParam & MK_SHIFT && wParam & MK_CONTROL)
                {
                RulerMarquee();
                break;
                }
#endif

        default:
            /* All of the messages we are not interested in. */
            return (DefWindowProc(hWnd, message, wParam, lParam));
            break;
        }

    if (vfCloseFilesInDialog)
        CloseEveryRfn( FALSE );

    /* A window procedure should always return something. */
    return (0L);
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\ruler.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains the routines for creating, displaying, and manipulating
the ruler for Memo. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOATOM
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NOCTLMGR
#define NODRAWTEXT
#define NOMB
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOMSG
#define NOOPENFILE
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "wwdefs.h"
#include "rulerdef.h"
#include "propdefs.h"
#include "prmdefs.h"
#include "docdefs.h"
#include "bitmaps.h"

#define MERGEMARK 0x00990066

extern HWND hParentWw;
extern HANDLE hMmwModInstance;
extern HCURSOR vhcIBeam;
extern struct DOD (**hpdocdod)[];
extern struct WWD *pwwdCur;
extern struct PAP vpapAbs;
extern struct SEP vsepAbs;
extern struct SEL selCur;
extern typeCP cpMacCur;
extern int docCur;
extern int vdocParaCache;
extern int dypRuler;
extern int dxpLogInch;
extern int dypLogInch;
extern int dxpLogCm;
extern int dypLogCm;
extern int xpSelBar;
extern HWND vhWndRuler;
extern int vdxaTextRuler;
extern int mprmkdxa[rmkMARGMAX];
extern int vfTabsChanged;
extern int vfMargChanged;
extern struct WWD rgwwd[];
extern long rgbBkgrnd;
extern long rgbText;
extern HBRUSH hbrBkgrnd;
extern long ropErase;
extern BOOL vfMonochrome;
extern BOOL vfEraseWw;
extern int vfIconic;

#ifdef RULERALSO
extern HWND vhDlgIndent;
#endif /* RULERALSO */

HDC vhDCRuler = NULL;
HDC hMDCBitmap = NULL;
HDC hMDCScreen = NULL;
HBITMAP hbmBtn = NULL;
HBITMAP hbmMark = NULL;
HBITMAP hbmNullRuler = NULL;
int dxpRuler;

int viBmRuler = -1;  /* Index into [CGA/EGA/VGA/8514] bitmaps (see
                        WRITE.RC).  Set appropriately in FCreateRuler(). */

static RECT rgrcRulerBtn[btnMaxUsed];
static int mprlcbtnDown[rlcBTNMAX] = {btnNIL, btnNIL, btnNIL};
static struct TBD rgtbdRuler[itbdMax];
static int xpMinCur;
static int dxpMark;
static int dypMark;
static int btnTabSave = btnLTAB;


near UpdateRulerBtn(int, int);
BOOL near FCreateRuler(void);
int near DestroyRuler(void);
int near RulerStateFromPt(POINT, int *, int *);
int near MergeRulerMark(int, int, BOOL);
BOOL near FPointNear(unsigned, unsigned);
unsigned near XaQuantize(int);
int near DeleteRulerTab(struct TBD *);
int near InsertRulerTab(struct TBD *);
BOOL near FCloseXa(unsigned, unsigned);
#ifdef KINTL
unsigned near XaKickBackXa(unsigned);
near XpKickBackXp(int);
unsigned near XaQuantizeXa(unsigned);
#endif /* KINTL */

fnShowRuler()
    {
    /* This routine toggles the creation and the destruction of the ruler
    window. */

    StartLongOp();
    if (pwwdCur->fRuler)
        {
        /* Take down the existing ruler. */
        DestroyRuler();
        SetRulerMenu(TRUE);
        }
    else
        {
        /* There is no ruler, bring one up. */
        if (FCreateRuler())
            {
            SetRulerMenu(FALSE);
            }
        }
    EndLongOp(vhcIBeam);
    }


BOOL near FCreateRuler()
    {
    /* This routine creates the ruler child window and positions it on the
    screen. */

    extern CHAR szRulerClass[];
    int xpMac = pwwdCur->xpMac;
    int ypMac = pwwdCur->ypMac;
    LOGFONT lf;
    HFONT hf;
    int dyp;
    HPEN hpen;
    RECT rc;
    TEXTMETRIC tmSys;
    HDC hdcSys;


    /* Create the ruler window. */
    if ((vhWndRuler = CreateWindow((LPSTR)szRulerClass, (LPSTR)NULL,
      WS_CHILD | WS_CLIPSIBLINGS, 0, 0, 0, 0, hParentWw, NULL, hMmwModInstance,
      (LPSTR)NULL)) == NULL)
        {
        goto Error2;
        }

    /* Save the DC and the memory DC. */
    if ((vhDCRuler = GetDC(vhWndRuler)) == NULL || (hMDCBitmap =
      CreateCompatibleDC(vhDCRuler)) == NULL || (hMDCScreen =
      CreateCompatibleDC(vhDCRuler)) == NULL)
        {
        goto Error1;
        }

    /* Create a null bitmap for the ruler. */
    if ((hbmNullRuler = CreateBitmap(1, 1, 1, 1, (LPSTR)NULL)) == NULL)
        {
        goto Error1;
        }

    /* New for Write 3.0: we have a variety of bitmaps for the ruler buttons 
       and marks -- loaded depending on the resolution of the user's display.
       All we really want to do here is set viBmRuler, which indexes into the
       appropriate bitmaps (see bitmaps.h) ..pault 7/13/89 */

    if (viBmRuler < 0)
        {
        /* This idea of passing NULL to GetDC borrowed from WinWord ..pt */
        if ((hdcSys = GetDC(NULL)) == NULL) 
            goto Error1;
        else
            {
            int tmHeight;

            GetTextMetrics(hdcSys, (LPTEXTMETRIC) &tmSys);
            tmHeight = tmSys.tmHeight;
            ReleaseDC(NULL, hdcSys);
            
            viBmRuler = 0;
            if (tmHeight > 8)
                viBmRuler++;
            if (tmHeight > 12)
                viBmRuler++;
            if (tmHeight > 16)
                viBmRuler++;
            }
        
        Diag(CommSzNum("FCreateRuler: index into [CGA/EGA/VGA/8514] bitmaps==", viBmRuler));
        Assert(idBmBtns + viBmRuler < idBmBtnsMax);
        Assert(idBmMarks + viBmRuler < idBmMarksMax);
        }

    /* Get the bitmaps for the ruler buttons and the ruler marks. */
    if (hbmBtn == NULL || SelectObject(hMDCBitmap, hbmBtn) == NULL)
        {
        if (NULL == (hbmBtn = LoadBitmap(hMmwModInstance, 
                                         MAKEINTRESOURCE(idBmBtns+viBmRuler))))
            {
            goto Error1;
            }
        }
    if (hbmMark == NULL || SelectObject(hMDCBitmap, hbmMark) == NULL)
        {
        if (NULL == (hbmMark = LoadBitmap(hMmwModInstance, 
                                          MAKEINTRESOURCE(idBmMarks+viBmRuler))))
            {
            goto Error1;
            }
        }

    /* Get the font for labelling the ruler ticks. */
    bltbc(&lf, 0, sizeof(LOGFONT));
    lf.lfHeight = -MultDiv(czaPoint * 8, dypLogInch, czaInch);
    if ((hf = CreateFontIndirect(&lf)) != NULL)
        {
        if (SelectObject(vhDCRuler, hf) == NULL)
            {
            DeleteObject(hf);
            }
        }

    /* If this is the first time the ruler is created, then initialize the
    static variables. */
    if (dypRuler == 0)
        {
        int dxpMajor;
        int dxpMinor;
        BITMAP bm;
        int xp;
        int dxpBtn;
        int btn;
        PRECT prc;
        TEXTMETRIC tm;

        /* Initialize the starting position of the buttons. */
        dxpMinor = (dxpMajor = dxpLogInch >> 1) >> 2;
        xp = xpSelBar + dxpMajor + (dxpMajor >> 1);

        /* Get the width and height of the buttons. */
        GetObject(hbmBtn, sizeof(BITMAP), (LPSTR)&bm);
        /* Factor of 2 since we have positive and negative images 
           of each button embedded in the bitmap now ..pault */
        dxpBtn = bm.bmWidth / (btnMaxReal*2);
        dypRuler = bm.bmHeight;

        /* Position the buttons. */
        for (prc = &rgrcRulerBtn[btn = btnMIN]; btn < btnMaxUsed; btn++, prc++)
            {
            prc->left = xp;
            prc->top = 1;
            prc->right = (xp += dxpBtn);
            prc->bottom = bm.bmHeight + 1;
            xp += (btn == btnTABMAX || btn == btnSPACEMAX) ? dxpMajor :
              dxpMinor;
            }

        /* Get the width and height of the tab marks. */
        GetObject(hbmMark, sizeof(BITMAP), (LPSTR)&bm);
        dxpMark = bm.bmWidth / rmkMAX;
        dypMark = bm.bmHeight;

        /* Lastly, initialize the height of the ruler. (Four is for the two
        lines at the bottom of the ruler plus two blank lines.) */
        GetTextMetrics(vhDCRuler, (LPTEXTMETRIC)&tm);
        dypRuler += dypMark + (tm.tmAscent - tm.tmInternalLeading) + 4;
        }

    /* Move the document window to make room for the ruler. */
    pwwdCur->fRuler = TRUE;
    dyp = dypRuler - (pwwdCur->ypMin - 1);
    MoveWindow(wwdCurrentDoc.wwptr, 0, dyp, xpMac, ypMac - dyp, FALSE);

    /* Erase the top of the document window. */
    PatBlt(wwdCurrentDoc.hDC, 0, 0, xpMac, wwdCurrentDoc.ypMin, ropErase);
    rc.left = rc.top = 0;
    rc.right = xpMac;
    rc.bottom = wwdCurrentDoc.ypMin;
    ValidateRect(wwdCurrentDoc.wwptr, (LPRECT)&rc);
    UpdateWindow(wwdCurrentDoc.wwptr);

    /* Move the ruler into position. */
    MoveWindow(vhWndRuler, 0, 0, xpMac, dypRuler, FALSE);
    BringWindowToTop(vhWndRuler);

    /* Set the DC to transparent mode. */
    SetBkMode(vhDCRuler, TRANSPARENT);

    /* Set the background and foreground colors for the ruler. */
    SetBkColor(vhDCRuler, rgbBkgrnd);
    SetTextColor(vhDCRuler, rgbText);

    /* Set the brush and the pen for the ruler. */
    SelectObject(vhDCRuler, hbrBkgrnd);
    if ((hpen = CreatePen(0, 0, rgbText)) == NULL)
        {
        hpen = GetStockObject(BLACK_PEN);
        }
    SelectObject(vhDCRuler, hpen);

    /* Lastly, ensure that the ruler is painted. */
    ShowWindow(vhWndRuler, SHOW_OPENWINDOW);
    UpdateWindow(vhWndRuler);
    return (TRUE);

Error1:
    DestroyWindow(vhWndRuler);
    vhWndRuler = NULL;
Error2:
    WinFailure();
    return (FALSE);
    }


near DestroyRuler()
    {
    /* This routine destroys the ruler window and refreshes the screen. */

    /* First, erase the ruler. */
    PatBlt(vhDCRuler, 0, 0, dxpRuler, dypRuler, ropErase);

    /* Clean up the ruler window. */
    DestroyWindow(vhWndRuler);
    vhWndRuler = NULL;
    ResetRuler();

    /* Move the document window back to the top of the window. */
    pwwdCur->fRuler = FALSE;
    vfEraseWw = TRUE;
    MoveWindow(wwdCurrentDoc.wwptr, 0, 0, dxpRuler, wwdCurrentDoc.ypMac +
      dypRuler - (wwdCurrentDoc.ypMin - 1), FALSE);
    vfEraseWw = FALSE;

    /* Validate the area in the document window above the text. */
    PatBlt(wwdCurrentDoc.hDC, 0, 0, dxpRuler, wwdCurrentDoc.ypMin, ropErase);
    ValidateRect(hParentWw, (LPRECT)NULL);
    }


UpdateRuler()
    {
    /* This routine will redraw as much of the ruler as necessary to reflect the
    current selection. */

    /* Only repaint the ruler if it exists and it is not currently being
    changed. */
    if (vhWndRuler != NULL)
        {
        RulerPaint(FALSE, FALSE, FALSE);
        }
    }

ReframeRuler()
    {
    /* This routine will cause the ruler window to be redrawn,
       when units change - leave update out, since dialog box
       will repaint */

    /* Only repaint the ruler if it exists . */
    if (vhWndRuler != NULL)
        {
        InvalidateRect(vhWndRuler, (LPRECT)NULL, FALSE);
        }
    }



ResetRuler()
    {
    /* Reset the values of the ruler buttons and the ruler margins and tabs so
    they redrawn during the next paint message. */
    if ((btnTabSave = mprlcbtnDown[rlcTAB]) == btnNIL)
        {
        btnTabSave = btnLTAB;
        }

    /* Reset the buttons. */
    if (vfIconic)
        {
        /* All we have to do is reset our internal state. */
        bltc(mprlcbtnDown, btnNIL, rlcBTNMAX);
        }
    else
        {
        /* We had best reset the buttons on the screen as well. */
        UpdateRulerBtn(rlcTAB, btnNIL);
        UpdateRulerBtn(rlcSPACE, btnNIL);
        UpdateRulerBtn(rlcJUST, btnNIL);
        }

    /* Reset the margins and the tabs. */
    bltc(mprmkdxa, -1, rmkMARGMAX);
    bltc(rgtbdRuler, 0, cwTBD * itbdMax);
    }


ResetTabBtn()
    {
    /* This routine resets the tab button on the ruler to the left tab button.
    */
    if (mprlcbtnDown[rlcTAB] != btnLTAB)
        {
        UpdateRulerBtn(rlcTAB, btnLTAB);
        }
    }


RulerPaint(fContentsOnly, fFrameOnly, fInit)
BOOL fContentsOnly;
BOOL fInit;
    {
    /* This routine draws the ruler in the ruler window.  If fContentsOnly is
    set, then only the tabs as they currently exist in rgtbdRuler, and the
    button settings are drawn.  If fFrameOnly is set, then only the ruler frame
    is redrawn.  If fInit is set, then the portion of the ruler to be redrawn
    (tabs, frame or all) is redrawn from scratch. */


    int xpMin = pwwdCur->xpMin;
    HBITMAP hbm;

    /* If fContentsOnly is set, then skip most of this stuff and draw only the
    tabs and the button settings.  */
    if (!fContentsOnly)
        {
        /* We only need to draw the physical ruler itself when the window has
        scrolled horizontally. */
        if (fInit || xpMinCur != xpMin)
            {
            register int xp;
            TEXTMETRIC tm;
            int dypTick;
            int ypTickEnd;
            int ypTickStart;
            int ypTick;
            int iLevel;
            CHAR rgchInch[3];
            int dxpLogUnitInc;
            int dcNextTick;
            int dxpLine;


            extern int utCur;
#define cDivisionMax 8  /* max divisions per ruler unit. e.g. 8 per inch */
            int rgypTick[cDivisionMax];
            int cxpExtra;
            int cDivision;
            int dxpLogUnit;
            int dxpMeas;
            int ypT;

            /* Initialize the y-coordinate of the ticks. */
            GetTextMetrics(vhDCRuler, (LPTEXTMETRIC)&tm);
            ypTickEnd = dypRuler - dypMark - 2;
            ypTickStart = ypTick = ypTickEnd - (dypTick = tm.tmAscent -
              tm.tmInternalLeading);

            /* set up measurements for the ruler based on current unit -
               note that only inch and cm are handled in this version */

            if (utCur == utInch)
                           {
                           dxpLogUnit = dxpLogUnitInc = dxpLogInch;
                           cDivision = 8;  /* # of divisions */
                           dxpMeas = dxpLogUnit >> 3;  /* 1/8" units */
                         /* get extra pixels to distribute if not even multiple */
                         /* note - mod done by hand */
                           cxpExtra = dxpLogUnit - (dxpMeas << 3);
                           dcNextTick = 1;
                          /* fill table of tick lengths */
                           rgypTick[0] = ypT = ypTick;
                           rgypTick[4] = ypT += (dypTick >> 2);
                           rgypTick[2] = rgypTick[6] = ypT += (dypTick >> 2);
                           rgypTick[1] = rgypTick[3] = rgypTick[5] = rgypTick[7]  =
                           ypT += (dypTick >> 2);
                           }
            else
                /* default to cm */
                           {
                           dxpLogUnit = dxpLogUnitInc = dxpLogCm;
                           cDivision = 2;  /* # of divisions */
                           dxpMeas = dxpLogUnit >> 1;  /* 1/2 cm units */
                         /* get extra pixels to distribute if not even multiple */
                           cxpExtra = dxpLogUnit - (dxpMeas << 1);
                           dcNextTick = 1;
                          /* fill table of tick lengths */
                           rgypTick[0] =  ypTick;
                           rgypTick[1] = ypTick + (dypTick >> 1);
                           }

            if (fInit)
                {
                /* Erase the area where the ruler will be drawn. */
                PatBlt(vhDCRuler, 0, 0, dxpRuler, dypRuler, ropErase);

                /* Draw a line across the bottom of the ruler. */
                MoveTo(vhDCRuler, xpSelBar, dypRuler - 1);
                LineTo(vhDCRuler, dxpRuler, dypRuler - 1);

                /* Draw the base of the ruler. */
                MoveTo(vhDCRuler, xpSelBar, ypTickEnd);
                LineTo(vhDCRuler, dxpRuler, ypTickEnd);
                }
            else
                {
                /* Erase the old tick marks. */
                PatBlt(vhDCRuler, 0, ypTickStart, dxpRuler, ypTickEnd -
                  ypTickStart, ropErase);
                }

            /* Set the clip region to be only the ruler. */
            iLevel = SaveDC(vhDCRuler);
            IntersectClipRect(vhDCRuler, xpSelBar, 0, dxpRuler, dypRuler);

            /* Draw the ticks at the each division mark. */
            /* iDivision is the current division with in a unit. It is
               used to determine when extra pixels are distributed and
               which tick mark to use */
            {
            register int iDivision = 0;

            for (xp = (xpSelBar - xpMin); xp < dxpRuler; xp +=
              dxpMeas)
                {
                  /* distribute extra pixels at front */
                if (iDivision < cxpExtra)
                   xp++;

                MoveTo(vhDCRuler, xp, rgypTick[iDivision]);
                LineTo(vhDCRuler, xp, ypTickEnd);

                if (++iDivision == cDivision)
                   iDivision = 0;
                }
            }


            /* Label the tick marks. */
            dxpLine = GetSystemMetrics(SM_CXBORDER);
            rgchInch[0] = rgchInch[1] = rgchInch[2] = '0';
            for (xp = xpSelBar - xpMin;
                 xp < dxpRuler;
                 xp += dxpLogUnitInc, rgchInch[2] += dcNextTick)
                {
                    int isz;
                    int dxpsz;

                    if (rgchInch[2] > '9')
                        {
                        rgchInch[1]++;
                        rgchInch[2] = '0' + (rgchInch[2] - (CHAR) ('9' + 1));
                        }
                    if (rgchInch[1] > '9')
                        {
                        rgchInch[0]++;
                        rgchInch[1] = '0' + (rgchInch[1] - (CHAR) ('9' + 1));
                        }
                    isz = rgchInch[0] == '0' ?
                                (rgchInch[1] == '0' ? 2 : 1):
                                0;
                    dxpsz = LOWORD(GetTextExtent(vhDCRuler,
                                                 (LPSTR)&rgchInch[isz],
                                                 3 - isz));
                    if (dxpsz + dxpLine >= dxpMeas)
                        {
                            PatBlt(vhDCRuler, xp + dxpLine, ypTickStart,
                                   dxpsz, ypTickEnd - ypTickStart, ropErase);
                        }
                    TextOut(vhDCRuler, xp + dxpLine, ypTickStart -
                            tm.tmInternalLeading, (LPSTR)&rgchInch[isz],
                            3 - isz);
                }


            /* Set the clip region back. */
            RestoreDC(vhDCRuler, iLevel);
            }

        /* Draw the buttons on the ruler. */
        if (fInit)
            {
            register PRECT prc = &rgrcRulerBtn[btnMIN];
            int btn;

            /* Ensure that we have the bitmap for the buttons. */
            if (SelectObject(hMDCBitmap, hbmBtn) == NULL)
                {
                if (NULL == (hbmBtn = LoadBitmap(hMmwModInstance, 
                                                 MAKEINTRESOURCE(idBmBtns+viBmRuler)))
                             || SelectObject(hMDCBitmap, hbmBtn) == NULL)
                    {
                    WinFailure();
                    goto NoBtns;
                    }
                }

            /* Now, draw the buttons. */
            for (btn = btnMIN; btn < btnMaxUsed; btn++)
                {
                int dxpBtn = prc->right - prc->left;

                BitBlt(vhDCRuler, prc->left, prc->top, dxpBtn, prc->bottom -
                  prc->top, hMDCBitmap, (btn - btnMIN) * dxpBtn, 0, vfMonochrome
                  ? MERGEMARK : SRCCOPY);
                prc++;
                }
            SelectObject(hMDCBitmap, hbmNullRuler);
NoBtns:;
            }
        }

    /* If fFrame only is set, then we're finished. */
    if (!fFrameOnly)
        {
        /* Lastly, draw the button settings, the margins and the tabs. */
        TSV rgtsv[itsvparaMax];
        register struct TBD *ptbd1;
        int rmk;
        int xpMarkMin = xpSelBar - (dxpMark >> 1);
        int dxpMarkMax = dxpRuler - xpSelBar - (dxpMark >> 1);
        unsigned dxa;

        if (mprlcbtnDown[rlcTAB] == btnNIL)
            {
            /* Initalize the tab button to be left tab. */
            UpdateRulerBtn(rlcTAB, btnTabSave);
            }

        /* Now for the spacing and justification. */
        GetRgtsvPapSel(rgtsv);
        UpdateRulerBtn(rlcSPACE, (rgtsv[itsvSpacing].fGray != 0) ? btnNIL :
          (rgtsv[itsvSpacing].wTsv - czaLine) / (czaLine / 2) + btnSINGLE);
        UpdateRulerBtn(rlcJUST, (rgtsv[itsvJust].fGray != 0) ? btnNIL :
          (rgtsv[itsvJust].wTsv - jcLeft) + btnLEFT);

        /* The margins and the tabs are based off of the first cp of the
        selection. */
        CacheSect(docCur, selCur.cpFirst);
        CachePara(docCur, selCur.cpFirst);

        /* If the window has scrolled horizontally or become wider, we must
        redraw the margins and the tabs. */
        if (!fInit && xpMinCur == xpMin)
            {
            /* Compare to see if the margins have changed. */
            if (mprmkdxa[rmkINDENT] != vpapAbs.dxaLeft + vpapAbs.dxaLeft1)
                {
                goto DrawMargins;
                }
            if (mprmkdxa[rmkLMARG] != vpapAbs.dxaLeft)
                {
                goto DrawMargins;
                }
            if (mprmkdxa[rmkRMARG] != vsepAbs.dxaText - vpapAbs.dxaRight)
                {
                goto DrawMargins;
                }

            /* Compare to see if the tabs has changed. */
                {
                register struct TBD *ptbd2;

                for (ptbd1 = &rgtbdRuler[0], ptbd2 = &vpapAbs.rgtbd[0];
                  ptbd1->dxa == ptbd2->dxa; ptbd1++, ptbd2++)
                    {
                    /* If the end of the list of tabs, then the lists are equal.
                    */
                    if (ptbd1->dxa == 0)
                        {
                        goto SkipTabs;
                        }

                    /* The justification codes must match if they are decimal
                    tabs (everything else collaspes to left tabs). */
                    if (ptbd1->jc != ptbd2->jc && (ptbd1->jc == (jcTabDecimal
                      - jcTabMin) || (ptbd2->jc == (jcTabDecimal - jcTabMin))))
                        {
                        goto DrawMargins;
                        }
                    }
                }
            }

DrawMargins:
#ifdef KINTL
        /* This is really an extra.  xpMinCur will get updated later on.
           But, we need this variable set up right for the MergeRulerMark()
           to draw a mark at the right place.... Oh well. */
        xpMinCur = xpMin;
#endif /* ifdef KINTL */

        /* Redraw the margins from scratch.  Set up the bitmap for hMDCScreen,
        the ruler bar in monochrome format. */
        if ((hbm = CreateBitmap(dxpRuler + dxpMark, dypMark, 1, 1,
          (LPSTR)NULL)) == NULL)
            {
            WinFailure();
            goto SkipTabs;
            }
        DeleteObject(SelectObject(hMDCScreen, hbm));
        PatBlt(hMDCScreen, 0, 0, dxpRuler + dxpMark, dypMark, vfMonochrome ?
          ropErase : WHITENESS);
        PatBlt(vhDCRuler, 0, dypRuler - dypMark - 1, dxpRuler + dxpMark,
          dypMark, ropErase);

        /* Determine the margin positions. */
        mprmkdxa[rmkINDENT] = vpapAbs.dxaLeft + vpapAbs.dxaLeft1;
        mprmkdxa[rmkLMARG] = vpapAbs.dxaLeft;
        mprmkdxa[rmkRMARG] = (vdxaTextRuler = vsepAbs.dxaText) -
          vpapAbs.dxaRight;

        /* Draw the margins marks. */
        for (rmk = rmkMARGMIN; rmk < rmkMARGMAX; rmk++)
            {
            register int dxp = MultDiv(mprmkdxa[rmk], dxpLogInch, czaInch) -
              xpMin;

            /* If the margin mark would not appear on the ruler, scrolled off to
            either end, then don't try to draw it. */
            if (dxp >= 0 && dxp < dxpMarkMax)
                {
                MergeRulerMark(rmk, xpMarkMin + dxp, FALSE);
                }
            }

        /* Redraw the tabs. */
        ptbd1 = &rgtbdRuler[0];
        if (!fInit)
            {
            /* If fInit is set, then rgtbdRuler is not changed. */
            blt(vpapAbs.rgtbd, ptbd1, cwTBD * itbdMax);
            }
        while ((dxa = ptbd1->dxa) != 0)
            {
            register int dxp = MultDiv(dxa, dxpLogInch, czaInch) - xpMin;

            /* If the tab mark would not appear on the ruler, scrolled off to
            either end, then don't try to draw it. */
            if (dxp >= 0 && dxp < dxpMarkMax)
                {
                MergeRulerMark(ptbd1->jc == (jcTabDecimal - jcTabMin) ? rmkDTAB
                  : rmkLTAB, xpMarkMin + dxp, FALSE);
                }
            ptbd1++;
            }
SkipTabs:;
        }

    /* Record the edges of the current window. */
    xpMinCur = xpMin;
    }


RulerMouse(pt)
POINT pt;
    {
    /* Process all mouse messages from a down-click at point pt until the
    corresponding mouse up-click. */

    int btn;
    int rlc;
    int rlcCur;
    int rmkCur;
    int xp;
    int xpCur;
    unsigned xa;
    struct TBD *ptbd;
    struct TBD tbd;
    BOOL fMarkMove = FALSE;
    BOOL fDeleteMark = FALSE;
    BOOL fBtnChanged = FALSE;

    if (!FWriteOk(fwcNil))
        {
        return;
        }

    /* Translate the point into a button group and a button. */
    RulerStateFromPt(pt, &rlcCur, &btn);

    /* Down clicking on the tab rule is a special case. */
    if (rlcCur == rlcRULER)
        {
        unsigned dxa = MultDiv(pt.x - xpSelBar + xpMinCur, czaInch, dxpLogInch);
        int rmk;
        int itbd;

        /* Have we moused down on a margin? */
        for (rmk = rmkMARGMIN; rmk < rmkMARGMAX; rmk++)
            {
#ifdef KINTL
            if (FPointNear(mprmkdxa[rmk], dxa - XaKickBackXa(dxa)))
#else
            if (FPointNear(mprmkdxa[rmk], dxa))
#endif /* if-else-def KINTL */
                {
                int     xpT;

                /* Remember this mark and its position. */
                rmkCur = rmk;
                xpCur = xpSelBar + MultDiv(mprmkdxa[rmk], dxpLogInch, czaInch) -
                  (dxpMark >> 1) - xpMinCur;

InvertMark:
#ifdef KINTL
                /* Adjust for the kick-backs.  */
                /* But don't modify the xpCur. */
                xpT = xpCur + XpKickBackXp(xpCur);
#else
                xpT = xpCur;
#endif /* if-else-def KINTL */

                /* Time to invert the selected mark. */
                PatBlt(vhDCRuler, xpT, dypRuler - dypMark - 1, dxpMark,
                  dypMark, DSTINVERT);
                goto GotMark;
                }
            }

        /* Have we moused down on an existing tab? */
        for (itbd = 0, ptbd = &rgtbdRuler[0]; ; itbd++, ptbd++)
            {
            /* The end of the tabs have been found. */
            if (ptbd->dxa == 0)
                {
                break;
                }

            /* Have we moused down on this tab? */
#ifdef KINTL
            if (FPointNear(ptbd->dxa, dxa - XaKickBackXa(dxa)))
#else
            if (FPointNear(ptbd->dxa, dxa))
#endif /* if-else-def KANJI */
                {
                /* Save this tab descriptor and its location. */
                tbd = *ptbd;
                rmkCur = (tbd.jc + jcTabMin) == jcTabDecimal ? rmkDTAB :
                  rmkLTAB;
                xpCur = xpSelBar + MultDiv(tbd.dxa, dxpLogInch, czaInch) -
                  (dxpMark >> 1) - xpMinCur;
                goto InvertMark;
                }
            }

        /* If one more tab would be too many, then beep and return. */
        if (itbd >= itbdMax - 1)
            {
            _beep();
            return;
            }

        /* Create a tab descriptor for this new tab. */
        bltc(&tbd, 0, cwTBD);
        tbd.dxa = XaQuantize(pt.x);
        tbd.jc = (mprlcbtnDown[rlcTAB] == btnLTAB ? jcTabLeft : jcTabDecimal) -
          jcTabMin;
        rmkCur = (mprlcbtnDown[rlcTAB] - btnLTAB) + rmkLTAB;

        /* A mark for the new tab needs to be drawn. */
        MergeRulerMark(rmkCur, xpCur = xpSelBar + MultDiv(tbd.dxa, dxpLogInch,
          czaInch) - (dxpMark >> 1) - xpMinCur, TRUE);

        /* Inserting a tab is like moving an existing tab. */
        fMarkMove = TRUE;

GotMark:;

#ifdef RULERALSO
        /* Update dialog box */
        if (vhDlgIndent && rmkCur < rmkMARGMAX)
            {
            SetIndentText(rmkCur, dxa);
            }
#endif /* RULERALSO */

        }
    else if (rlcCur != rlcNIL)
        {
        /* Otherwise, if a button has been selected, the reflect the change on
        the ruler. */
        UpdateRulerBtn(rlcCur, btn);
        }
    else
        {
        /* The user has moused down on nothing of importance. */
        return;
        }

    /* Get all of the mouse events until further notice. */
    SetCapture(vhWndRuler);

    /* Process all of the mouse move messages. */
    while (FStillDown(&pt))
        {
        /* Movement on the tab ruler must be handled special. */
        if (rlcCur == rlcRULER)
            {
#ifdef KINTL
            unsigned xaT;
#endif /* ifdef KINTL */

            /* Guarantee that xp is in the range xpSelBar <= xp <= dxpRuler. */
            if ((xp = pt.x) > dxpRuler)
                {
                xp = dxpRuler;
                }
            else if (xp < xpSelBar)
                {
                xp = xpSelBar;
                }

            /* Convert the mouse position to twips. */
#ifdef KINTL
            if ((xa = XaQuantize(xp)) > (xaT = XaQuantizeXa(vdxaTextRuler))
#else
            if ((xa = XaQuantize(xp)) > vdxaTextRuler
#endif /* if-else-def KINTL */
                && rmkCur < rmkMARGMAX)
                {
                /* Margins are confined to the page. */
#ifdef KINTL
                xa = xaT;
#else
                xa = vdxaTextRuler;
#endif
                }

            /* If the cursor is on the ruler, then we may move a tab, but we
            always move the margins. */
            if ((rmkCur < rmkMARGMAX) || (pt.y >= 0 && pt.y < dypRuler + dypMark
              && xa != 0))
                {
                /* If the current mark has not moved, then there is nothing to
                do.  */
                if (fDeleteMark || xa != XaQuantize(xpCur + (dxpMark >> 1)))
                    {
                    /* Indicate that the mark has moved. */
                    fMarkMove = TRUE;

                    /* Restore the screen under the current mark. */
                    if (!fDeleteMark)
                        {
                        MergeRulerMark(rmkCur, xpCur, FALSE);
                        }

                    /* Draw the mark at the new location. */
                    MergeRulerMark(rmkCur, xpCur = MultDiv(xa, dxpLogInch,
                      czaInch) + xpSelBar - xpMinCur - (dxpMark >> 1), TRUE);

                    /* Show this is a valid mark. */
                    fDeleteMark = FALSE;

#ifdef RULERALSO
                    /* Update dialog box */
                    if (vhDlgIndent && rmkCur < rmkMARGMAX)
                        {
                        SetIndentText(rmkCur, xa);
                        }
#endif /* RULERALSO */

                    }
                }
            else
                {
                /* Restore the screen under the current mark. */
                if (!fDeleteMark)
                    {
                    MergeRulerMark(rmkCur, xpCur, FALSE);
                    }

                /* This mark is being deleted. */
                fDeleteMark = TRUE;
                }
            }
        else
            {
            /* If the mouse is on a button within the same button group, then
            reflect the change. */
            RulerStateFromPt(pt, &rlc, &btn);
            if (rlc == rlcCur)
                {
                UpdateRulerBtn(rlc, btn);
                }
            }
        }

    /* We are capturing all mouse events; we can now release them. */
    ReleaseCapture();

    /* Up-clicking on the tab ruler is a special case. */
    if (rlcCur == rlcRULER)
        {
        if (!fDeleteMark)
            {
            /* Restore the screen under the current mark. */
            MergeRulerMark(rmkCur, xpCur, FALSE);
            }

        if (fMarkMove)
            {
            /* Guarantee that xp is in the range xpSelBar <= xp <= dxpRuler. */
            if ((xp = pt.x) > dxpRuler)
                {
                xp = dxpRuler;
                }
            else if (xp < xpSelBar)
                {
                xp = xpSelBar;
                }
            }
        else
            {
            xp = xpCur + (dxpMark >> 1);
            }

        /* Convert the mouse position to twips. */
        if ((xa = XaQuantize(xp)) > vdxaTextRuler && rmkCur < rmkMARGMAX)
            {
            /* Margins are confined to the page. */
            xa = vdxaTextRuler;
            }

        /* If the cursor is on the ruler then we may insert/move a tab, but we
        always move the margins. */
        if ((rmkCur < rmkMARGMAX) || (pt.y >= 0 && pt.y < dypRuler + dypMark &&
          xa != 0))
            {
            /* Draw the mark at the new location. */
            MergeRulerMark(rmkCur, MultDiv(xa, dxpLogInch, czaInch) + xpSelBar -
              xpMinCur - (dxpMark >> 1), FALSE);

            /* We are moving one of the margins. */
            if (rmkCur < rmkMARGMAX)
                {
                if (vfMargChanged = mprmkdxa[rmkCur] != xa)
                    {
                    mprmkdxa[rmkCur] = xa;
                    }

#ifdef RULERALSO
                /* Update dialog box */
                if (vhDlgIndent)
                    {
                    SetIndentText(rmkCur, xa);
                    }
#endif /* RULERALSO */

                }

            /* It is a tab we are inserting/deleting. */
            else
                {
                tbd.dxa = xa;

                /* Is this a new tab? */
                if (ptbd->dxa == 0)
                    {
                    /* Insert the new tab. */
                    InsertRulerTab(&tbd);
                    }

                /* We are moving a tab; if it hasn't really moved, then do
                nothing.  */
                else if (!FCloseXa(ptbd->dxa, xa))
                    {
                    DeleteRulerTab(ptbd);
                    InsertRulerTab(&tbd);
                    }
                }
            }

        /* We are deleting the tab; if its a new, there's nothing to do. */
        else if (ptbd->dxa != 0)
            {
            DeleteRulerTab(ptbd);
            }
        }
    else
        {
        /* If the mouse is on a button within the same button group, then
        reflect the change. */

        int btnT;

        RulerStateFromPt(pt, &rlc, &btnT);
        if (rlc == rlcCur)
            {
            UpdateRulerBtn(rlc, btn = btnT);
            }
        fBtnChanged = btn != mprlcbtnDown[btn];
        }

    /* Do the format only if a button changed */
    if ((fBtnChanged && rlcCur != rlcTAB) || vfMargChanged || vfTabsChanged)
        {
        struct SEL selSave;
        typeCP dcp;
        typeCP dcp2;
        CHAR rgb[1 + cchINT];
        CHAR *pch;
        int sprm;
        int val;
        struct TBD (**hgtbd)[];

        /* Set the selection to cover all of the paragraphs selected. */
        ExpandCurSel(&selSave);
        dcp2 = (dcp = selCur.cpLim - selCur.cpFirst) - (selCur.cpLim > cpMacCur
          ? ccpEol : 0);
        SetUndo(uacRulerChange, docCur, selCur.cpFirst, (rlcCur != rlcRULER ||
          rmkCur < rmkMARGMAX) ? dcp : dcp2, docNil, cpNil, dcp2, 0);

        /* Set the sprm and it's value for the ruler change. */
        switch (rlcCur)
            {
        case rlcSPACE:
            sprm = sprmPDyaLine;
            val = (mprlcbtnDown[rlcSPACE] - btnSINGLE) * (czaLine / 2) +
              czaLine;
            break;

        case rlcJUST:
            sprm = sprmPJc;
            val = mprlcbtnDown[rlcJUST] - btnLEFT + jcLeft;
            break;

        case rlcRULER:
            switch (rmkCur)
                {
            case rmkINDENT:
                sprm = sprmPFIndent;
                val = mprmkdxa[rmkINDENT] - mprmkdxa[rmkLMARG];
                break;

            case rmkLMARG:
                /* Changing the left margin changes the first indent as well.
                First, the indent... */
                val = mprmkdxa[rmkINDENT] - mprmkdxa[rmkLMARG];
                pch = &rgb[0];
                *pch++ = sprmPFIndent;
                bltbyte(&val, pch, cchINT);
                AddOneSprm(rgb, FALSE);

                /* Now for the left margin... */
                sprm = sprmPLMarg;
                val = mprmkdxa[rmkLMARG];
                break;

            case rmkRMARG:
                sprm = sprmPRMarg;
                val = vdxaTextRuler - mprmkdxa[rmkRMARG];
                break;

            case rmkLTAB:
            case rmkDTAB:
                /* Tabs are different.  The change is made by blting the new tab
                table on top of the old. */
                vfTabsChanged = FALSE;
                if ((hgtbd = (**hpdocdod)[docCur].hgtbd) == NULL)
                    {
                    if (FNoHeap(hgtbd = (struct TBD (**)[])HAllocate(itbdMax *
                      cwTBD)))
                        {
                        return;
                        }
                    (**hpdocdod)[docCur].hgtbd = hgtbd;
                    }
                blt(rgtbdRuler, *hgtbd, itbdMax * cwTBD);

                /* Changing the tabs makes everything dirty. */
                (**hpdocdod)[docCur].fDirty = TRUE;
                vdocParaCache = docNil;
                TrashAllWws();
                goto ChangeMade;
                }

            /* Indicate that the margins have been set. */
            vfMargChanged = FALSE;
            }

        /* Now, lets set the sprm to the new value. */
        pch = &rgb[0];
        *pch++ = sprm;
        bltbyte(&val, pch, cchINT);
        AddOneSprm(rgb, FALSE);

ChangeMade:
        /* Reset the selection to it's old value. */
        EndLookSel(&selSave, TRUE);
        }
    }


near RulerStateFromPt(pt, prlc, pbtn)
POINT pt;
int *prlc;
int *pbtn;
    {
    /* This routine return in *prlc and *pbtn, the button group and the button
    at point pt.  The only button in group rlcRULER is btnNIL. */

    int btn;

    /* First check if the point is in a button. */
    for (btn = btnMIN; btn < btnMaxUsed; btn++)
        {
        if (PtInRect((LPRECT)&rgrcRulerBtn[btn], pt))
            {
            goto ButtonFound;
            }
        }

    /* The point is either on the tab ruler or nowhere of any interest. */
    *prlc = (pt.y >= dypRuler - dypMark - 2 && pt.x > xpSelBar - (dxpMark >> 1)
      && pt.x < dxpRuler + (dxpMark >> 1)) ? rlcRULER : rlcNIL;
    *pbtn = btnNIL;
    return;

ButtonFound:
    /* The point is in a button, we just have to decide which button group. */
    switch (btn)
        {
        case btnLTAB:
        case btnDTAB:
            *prlc = rlcTAB;
            break;

        case btnSINGLE:
        case btnSP15:
        case btnDOUBLE:
            *prlc = rlcSPACE;
            break;

        case btnLEFT:
        case btnCENTER:
        case btnRIGHT:
        case btnJUST:
            *prlc = rlcJUST;
            break;
        }
    *pbtn = btn;
    }


void near HighlightButton(fOn, btn)
BOOL fOn; /* true if we should highlight this button, false = unhighlight */
int btn;
    {
    register PRECT prc = &rgrcRulerBtn[btn];
    int dxpBtn = prc->right - prc->left;
    
    /* If we're highlighting, then get the black-on-white button from
       the right group; otherwise copy the white-on-black button ..pt */
    int btnFromBM = btn - btnMIN + (fOn ? btnMaxReal : 0);

    /* Ensure that we have the bitmap for the buttons. */
    if (SelectObject(hMDCBitmap, hbmBtn) == NULL)
        {
        if ((hbmBtn = LoadBitmap(hMmwModInstance, MAKEINTRESOURCE(idBmBtns+viBmRuler))) ==
          NULL || SelectObject(hMDCBitmap, hbmBtn) == NULL)
            {
            WinFailure();
            goto NoBtns;
            }
        }

    BitBlt(vhDCRuler, prc->left, prc->top, dxpBtn, prc->bottom - prc->top, 
           hMDCBitmap, btnFromBM * dxpBtn, 0, SRCCOPY);
    
    SelectObject(hMDCBitmap, hbmNullRuler);
NoBtns:;
    }


near UpdateRulerBtn(rlc, btn)
int rlc;
int btn;
    {
    /* This routine turns off the currently selected button in button group rlc
    and turns on button btn.  It is assumed that rlc is neither rlcNIL nor
    rlcRULER, since neither group has buttons to update. */

    int *pbtnOld = &mprlcbtnDown[rlc];
    int btnOld = *pbtnOld;

    Assert(rlc != rlcNIL && rlc != rlcRULER);

    /* If the button hasn't changed, then there is nothing to do. */
    if (btn != btnOld)
        {
        if (vhDCRuler != NULL)
            {
            /* Invert the old button (back to normal), and then invert the new
            button. */
            if (btnOld != btnNIL)
                {
                /* If there is no old button, then, of course, we can't invert
                it.  */
                HighlightButton(fFalse, btnOld);
                }

            if (btn != btnNIL)
                {
                /* If the new button is not btnNIL, then invert it. */
                HighlightButton(fTrue, btn);
                }
            }

        /* Record whic button is now set. */
        *pbtnOld = btn;
        }
    }

#ifdef KINTL
/* Given xa for a mouse position in a ruler, return the amount of xa for
   a display adjustment. */
unsigned near XaKickBackXa(xa)
    unsigned        xa;
{
    extern int      utCur;
    extern int      dxaAdjustPerCm;
    int             cCm, cCh;

    switch (utCur) {
        case utCm:
            cCm = xa / czaCm;
            return (dxaAdjustPerCm * cCm);
        case utInch:
            return (0);
        default:
            Assert(FALSE);
            return (0);
        }
}

near XpKickBackXp(xp)
    int xp;
{
    /* Computes the amount of a necessary kick-back in xp, if
       a ruler marker is to be drawn at a given xp. */
    extern int utCur;
    extern int dxaAdjustPerCm;

    int        cCm, cCh;

    switch (utCur) {
        case utInch:
            return 0;
        case utCm:
            /* For every cm, we are off by dxaAdjustPerCm twips. */
            cCm = (xp - xpSelBar + xpMinCur + (dxpMark >> 1)) / dxpLogCm;
            return (MultDiv(dxaAdjustPerCm * cCm, dxpLogInch, czaInch));
        default:
            Assert(FALSE);
            return 0;
        }
}
#endif /* ifdef KINTL */


near MergeRulerMark(rmk, xpMark, fHighlight)
int rmk;
int xpMark;
BOOL fHighlight;
    {
    /* This routine merges the ruler mark, rmk, with the contents of the ruler
    bar at xpMark.  To accomodate color, the merging of the mark with the
    background must be done first in a monochrome memory bitmap, then converted
    back to color.  The mark is highlighed if fHighlight is set. */

    int ypMark = dypRuler - dypMark - 1;

    /* Ensure that we have the bitmap for the ruler marks. */
    if (SelectObject(hMDCBitmap, hbmMark) == NULL)
        {
        if ((hbmMark = LoadBitmap(hMmwModInstance, MAKEINTRESOURCE(idBmMarks+viBmRuler))) == NULL
          || SelectObject(hMDCBitmap, hbmMark) == NULL)
            {
            WinFailure();
            return;
            }
        }

#ifdef KINTL
    /* Adjust for the kick back */
    xpMark += XpKickBackXp(xpMark);
#endif /* ifdef KINTL */

    /* Merge the mark into the monochrome bitmap. */
    BitBlt(hMDCScreen, xpMark, 0, dxpMark, dypMark, hMDCBitmap, (rmk - rmkMIN) *
      dxpMark, 0, MERGEMARK);

    /* Display the bitmap on the ruler bar. */
    BitBlt(vhDCRuler, xpMark, ypMark, dxpMark, dypMark, hMDCScreen, xpMark, 0,
      fHighlight ? NOTSRCCOPY : SRCCOPY);

    SelectObject(hMDCBitmap, hbmNullRuler);
    }


BOOL near FPointNear(xaTarget, xaProbe)
unsigned xaTarget;
unsigned xaProbe;
    {
    /* This routine returns TRUE if and only if xaProbe is sufficiently close to
    xaTarget for selection purposes. */

    int dxa;

    if ((dxa = xaTarget - xaProbe) < 0)
        {
        dxa = -dxa;
        }
    return (dxa < MultDiv(dxpMark, czaInch, dxpLogInch) >> 1);
    }


unsigned near XaQuantize(xp)
int xp;
    {
#ifdef KINTL
     /* This routine converts an x-coordinate from the ruler to twips
        rounding it to the nearest sixteenth of an inch if utCur = utInch,
        or to the nearest eighth of a centimeter if utCur = utCm. */
    unsigned xa = MultDiv(xp - xpSelBar + xpMinCur, czaInch, dxpLogInch);
    return (XaQuantizeXa(xa));
#else
    /* This routine converts an x-coordinate from the ruler to twips rounding it
    to the nearest sixteenth of an inch. */

    unsigned xa = MultDiv(xp - xpSelBar + xpMinCur, czaInch, dxpLogInch);

    /* NOTE: This code has been simplified because we "know" czaInch is a
    multiple of 32. */
    return ((xa + czaInch / 32) / (czaInch / 16) * (czaInch / 16));
#endif /* not KINTL */
    }

#ifdef KINTL
unsigned near XaQuantizeXa(xa)
    unsigned xa;
{
    extern int utCur;
    long    xaL;

    switch (utCur) {
        case utInch:
            /* NOTE: This code has been simplified because we "know" czaInch is a
                     multiple of 32. */
            return ((xa + czaInch / 32) / (czaInch / 16) * (czaInch / 16));
        case utCm:
            /* NOTE: Actually, we are calculating:
                     (xa + czaCm / 16) / (czaCm / 8) * (czaCm / 8)
                     but calculated in 16*twips, so that there will
                     be the least rounding error. */
            xaL = ((long) xa) << 4;
            xaL = (xaL + czaCm) / (czaCm << 1) * (czaCm << 1);
            /* Kick back is adjusted in MergeRulerMark. */
            return ((unsigned) (xaL >> 4));
        default:
            Assert(FALSE);
            return (xa); /* Heck, it's better than nothing. */
        }
}
#endif /* KINTL */


near DeleteRulerTab(ptbd)
struct TBD *ptbd;
    {
    /* This routine removes the tab at ptbd from its table. */

    vfTabsChanged = TRUE;
    do
        {
        *ptbd = *(ptbd + 1);
        }
    while ((ptbd++)->dxa != 0);
    }


near InsertRulerTab(ptbd)
struct TBD *ptbd;
    {
    /* This routine inserts the tab *ptbd into rgtbdRuler unless there is one
    close to it already. */

    register struct TBD *ptbdT;
    unsigned dxa = ptbd->dxa;
    unsigned dxaT;

    /* Search the table for a tab that is close to the tab to be inserted. */
    for (ptbdT = &rgtbdRuler[0]; ptbdT->dxa != 0; ptbdT++)
        {
        if (FCloseXa(ptbdT->dxa, dxa))
            {
            /* Overwrite the old tab iff the tab has changed. */
            if (ptbdT->jc != ptbd->jc)
                {
                *ptbdT = *ptbd;
                vfTabsChanged = TRUE;
                }

            /* Clean up the ruler and exit. */
            RulerPaint(TRUE, FALSE, TRUE);
            return;
            }
        }

    vfTabsChanged = TRUE;

    /* Insert the tab at the correctly sorted place. */
    for (ptbdT = &rgtbdRuler[0]; (dxaT = ptbdT->dxa) != 0; ptbdT++)
        {
        if (dxa <= dxaT)
            {
            /* Insert the tab in front of ptbdT and move the remaining tabs up
            one slot.  The last tab will be overwritten to avoid table overflow.
            */
            blt(ptbdT, ptbdT + 1, ((&rgtbdRuler[0] - ptbdT) + (itbdMax - 2)) *
              cwTBD);
            *ptbdT = *ptbd;
            return;
            }
        }

    /* Insert the tab at the end of the table unless the table is full. */
    if (ptbdT - &rgtbdRuler[0] < itbdMax - 1)
        {
        *ptbdT = *ptbd;
        (ptbdT + 1)->dxa = 0;
        }
    }


BOOL near FCloseXa(xa1, xa2)
unsigned xa1;
unsigned xa2;
    {
#ifdef KINTL
    /* This function returns TRUE if xa1 is "close" to xa2;
       FALSE otherwise.  Threshold is determined by utCur. */
    int dxa;
    int dxaThreshold;

    extern int utCur;

    if ((dxa = xa1 - xa2) < 0)
        {
        dxa = -dxa;
        }
    switch (utCur) {
        case utInch:
            dxaThreshold = czaInch / 16;
            break;
        case utCm:
            dxaThreshold = czaCm / 8;
            break;
        default:
            Assert(FALSE);
            dxaThreshold = 0; /* Heck.  It doesn't matter at this point. */
            break;
        }
    return (dxa < dxaThreshold);
#else /* not KINTL */
    /* This function returns TRUE if xa1 is "close" to xa2; FALSE otherwise. */

    int dxa;

    if ((dxa = xa1 - xa2) < 0)
        {
        dxa = -dxa;
        }
    return (dxa < czaInch / 16);
#endif /* not KINTL */
    }



#ifdef DEBUG
RulerMarquee()
    {
    /* This routine displays and scrolls the "marquee" message in the ruler mark
    area. */

    static CHAR szMarquee[] = "Dz}w|d`3Dazgv3{r`3qvv}3qa|ft{g3g|3j|f3qj3Q|q?3Q|q?3Qajr}?3P{z>P{fv}?3r}w3Crg";
    LOGFONT lf;
    HFONT hf;
    HFONT hfOld;

    /* Decode the marquee message. */
    if (szMarquee[0] == 'D')
        {
        int ich;

        for (ich = 0; ich < sizeof(szMarquee) - 1; ich++)
            {
            szMarquee[ich] ^= 0x13;
            }
        }

    /* Get a logical font that will fit in the ruler mark area. */
    bltbc(&lf, 0, sizeof(LOGFONT));
    lf.lfHeight = -dypMark;
    lf.lfPitchAndFamily = FIXED_PITCH;

    /* Can we create such a font. */
    if ((hf = CreateFontIndirect(&lf)) != NULL)
        {
        if ((hfOld = SelectObject(vhDCRuler, hf)) != NULL)
            {
            int xp;
            int yp = dypRuler - dypMark - 1;
            int dxp = LOWORD(GetTextExtent(vhDCRuler, (LPSTR)szMarquee,
              sizeof(szMarquee) - 1));
            int dxpScroll = MultDiv(GetSystemMetrics(SM_CXSCREEN), dypMark,
              2048);
            int iLevel;
            TEXTMETRIC tm;

            /* Erase what is in the ruler mark area. */
            PatBlt(vhDCRuler, 0, yp, dxpRuler, dypMark, ropErase);

            /* Scroll the marquee across the screen. */
            iLevel = SaveDC(vhDCRuler);
            IntersectClipRect(vhDCRuler, xpSelBar, yp, dxpRuler, dypRuler - 1);
            GetTextMetrics(vhDCRuler, (LPTEXTMETRIC)&tm);
            for (xp = dxpRuler; xp > xpSelBar - dxp; xp -= dxpScroll)
                {
                BitBlt(vhDCRuler, xp, yp, min(dxpRuler - (xp + dxpScroll), dxp),
                  dypMark, vhDCRuler, xp + dxpScroll, yp, SRCCOPY);
                PatBlt(vhDCRuler, min(dxpRuler - dxpScroll, xp + dxp), yp,
                  dxpScroll, dypMark, ropErase);
                if (xp + dxp >= dxpRuler)
                    {
                    int dxpch = (dxpRuler - xp) % tm.tmAveCharWidth;
                    int ich = (dxpRuler - xp) / tm.tmAveCharWidth;

                    if (dxpch == 0 && xp < dxpRuler)
                        {
                        dxpch = tm.tmAveCharWidth;
                        ich--;
                        }
                    TextOut(vhDCRuler, dxpRuler - dxpch, yp -
                      tm.tmInternalLeading, (LPSTR)&szMarquee[ich], 1);
                    }
                }
            RestoreDC(vhDCRuler, iLevel);

            /* Cleanup the font and the screen. */
            SelectObject(vhDCRuler, hfOld);
            RulerPaint(TRUE, FALSE, TRUE);
            }
        DeleteObject(hf);
        }
    }
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\running.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* running.c -- code to handle editing of running header and footer */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
//#define NOATOM
//#define NOGDI
#define NOFONT
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOMETAFILE
#define NOMINMAX
#define NOOPENFILE
#define NOPEN
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "machdefs.h"
#define NOKCCODES
#include "ch.h"
#include "docdefs.h"
#include "cmddefs.h"
#include "editdefs.h"
#include "propdefs.h"
#include "prmdefs.h"
#include "wwdefs.h"
#include "dlgdefs.h"
#include "menudefs.h"
#include "str.h"
#if defined(OLE)
#include "obj.h"
#endif

#ifdef JAPAN //T-HIROYN Win3.1
#include "kanji.h"
#endif

int NEAR EditHeaderFooter();

    /* Current allowable cp range for display/edit/scroll */
extern typeCP cpMinCur;
extern typeCP cpMacCur;

extern struct DOD (**hpdocdod)[];
extern struct WWD rgwwd[];
extern int docCur;
extern int docScrap;
extern int vfSeeSel;
extern struct SEL selCur;
extern struct PAP vpapAbs;
extern struct SEP vsepNormal;
extern HANDLE       vhWnd;
extern HANDLE       hMmwModInstance;
extern HANDLE       hParentWw;
#ifdef INEFFLOCKDOWN
extern FARPROC      lpDialogRunningHead;
#else
BOOL far PASCAL DialogRunningHead(HWND, unsigned, WORD, LONG);
FARPROC lpDialogRunningHead = NULL;
#endif
extern HANDLE       vhDlgRunningHead;
extern CHAR     stBuf[255];
extern int      utCur;
extern int      ferror;
extern int      vccpFetch;
extern int      vcchFetch;
extern CHAR     *vpchFetch;
extern struct CHP   vchpFetch;
extern typeCP       vcpLimParaCache;
extern HWND     vhWndMsgBoxParent;

    /* Min, Max cp's for header, footer */
typeCP cpMinHeader=cp0;
typeCP cpMacHeader=cp0;
typeCP cpMinFooter=cp0;
typeCP cpMacFooter=cp0;

    /* Min cp for document less header, footer */
    /* Header & footer always appear at the beginning */
typeCP cpMinDocument=cp0;

    /* The following variables are used in this module only */

#define cchWinTextSave  80
static CHAR     (**hszWinTextSave)[]=NULL;
static struct PAP   *ppapDefault;

    /* cpFirst and selection are saved in these during header/footer edit */
typeCP       cpFirstDocSave;
struct SEL   selDocSave;


HWND vhDlgRunning;



fnEditRunning(imi)
{   /* Enter mode so that user is editing the current document's
       running header or footer in the same window as he was editing
       the document, with the header/footer info in the dialog box
       NOT currently in focus ..pault */

#ifndef INEFFLOCKDOWN
  if (!lpDialogRunningHead)
    if (!(lpDialogRunningHead = MakeProcInstance(DialogRunningHead, hMmwModInstance)))
      {
      WinFailure();
      return;
      }
#endif

  Assert(imi == imiHeader || imi == imiFooter);

  if (wwdCurrentDoc.fEditHeader || wwdCurrentDoc.fEditFooter)
  {
    SetFocus(vhDlgRunningHead);
    return;
  }

  if (imi == imiHeader)
    wwdCurrentDoc.fEditHeader = TRUE;
  else
    wwdCurrentDoc.fEditFooter = TRUE;

  EditHeaderFooter();
  if (ferror)
    {    /* Not enough memory to stabilize the running head environs */
    if (wwdCurrentDoc.fEditHeader)
      wwdCurrentDoc.fEditHeader = FALSE;
    else
      wwdCurrentDoc.fEditFooter = FALSE;
    return;
    }
  vhDlgRunningHead = CreateDialog(hMmwModInstance,
                                 MAKEINTRESOURCE(wwdCurrentDoc.fEditHeader ?
                                                dlgRunningHead : dlgFooter),
                                 hParentWw, lpDialogRunningHead);
  if (vhDlgRunningHead)
    {
    SetFocus(wwdCurrentDoc.wwptr);
    }
 else
    { /* recover and bail out */
    fnEditDocument();
#ifdef WIN30
    WinFailure();
#else
    Error(IDPMTNoMemory);
#endif
    }
}



int NEAR EditHeaderFooter()
{   /* Setup for edit of header or footer */
 extern HWND hParentWw;

 int fHeader=wwdCurrentDoc.fEditHeader;
 CHAR szWinTextSave[ cchWinTextSave ];
 typeCP cpFirst;
 typeCP cpLim;
#ifdef DEBUG
    /* TEST Assumption: No changes take place in running head/foot cp range
       during an interval in which no head/foot edits take place */
 typeCP cpMinDocT=cpMinDocument;

 ValidateHeaderFooter( docCur );
 Assert( cpMinDocT == cpMinDocument );
#endif

 if (fHeader)
    {
    cpFirst = cpMinHeader;
    cpLim = cpMacHeader;
    }
 else
    {
    cpFirst = cpMinFooter;
    cpLim = cpMacFooter;
    }

 Assert( wwdCurrentDoc.fEditHeader != wwdCurrentDoc.fEditFooter );

    /* Save the cpFirst of the document window so we get a clean
       transition back to where we were in the document*/
 cpFirstDocSave = wwdCurrentDoc.cpFirst;
 selDocSave = selCur;

 TrashCache();
 TrashWw( wwDocument );

 if (!FWriteOk( fwcNil ))
    goto DontEdit;

 if ( cpFirst == cpLim )
    {
    /* If we are editing the header/footer for the first time in this document,
       insert a para end mark to hold the running h/f properties */
    extern struct PAP *vppapNormal;
    struct PAP papT;

    blt( vppapNormal, &papT, cwPAP );
    papT.rhc = (wwdCurrentDoc.fEditHeader) ?
             rhcDefault : rhcDefault + RHC_fBottom;

    InsertEolPap( docCur, cpFirst, &papT );
    if (ferror)
    return;
    ValidateHeaderFooter( docCur );
    cpLim += ccpEol;
    }
 else
    {
    extern int vccpFetch;
    typeCP cp;

    /* Test for a special case: loading a WORD document which has been
       properly set up to have running head/foot under MEMO.  We must
       force the para end mark at the end of the header/footer to be
       a fresh run.  This is so we will see an end mark when editing one
       of these.  FormatLine only checks for cpMacCur at the start of a run. */

    Assert( cpLim - cpFirst >= ccpEol );

    if ( (cp = cpLim - ccpEol) > cpFirst )
    {
    FetchCp( docCur, cp - 1, 0, fcmBoth );

    if ( vccpFetch > 1)
        {   /* char run does not end with char before EOL */
        /* Insert a char, then delete it */
        extern struct CHP vchpNormal;
        CHAR ch='X';

        InsertRgch( docCur, cp, &ch, 1, &vchpNormal, NULL );
        if (ferror)
        return;
        Replace( docCur, cp, (typeCP) 1, fnNil, fc0, fc0 );
        if (ferror)
        return;
        }
    }
    }

DontEdit:

 /* Save current window text; set string */

 GetWindowText( hParentWw, (LPSTR)szWinTextSave, cchWinTextSave );
 if (FNoHeap(hszWinTextSave=HszCreate( (PCH)szWinTextSave )))
    {
    hszWinTextSave = NULL;
    }
  else
    {
    extern CHAR szHeader[];
    extern CHAR szFooter[];

    SetWindowText( hParentWw, fHeader ? (LPSTR)szHeader:(LPSTR)szFooter );
    }

   /* Set editing limits to just the cp range of the header/footer,
       minus the "invisible" terminating EOL */
 wwdCurrentDoc.cpFirst = wwdCurrentDoc.cpMin = cpMinCur = cpFirst;
 wwdCurrentDoc.cpMac = cpMacCur = CpMax( cpMinCur, cpLim - ccpEol );

    /* Leave the cursor at the beginning of the header/footer regardless */
 Select( cpMinCur, cpMinCur );
    /* Show the display here instead of waiting for Idle() because it looks
       better to have the head/foot text come up right away instead of waiting
       for the dialog box to come up */
 UpdateDisplay( FALSE );
 vfSeeSel = TRUE;   /* Tell Idle() to scroll the selection into view */
 NoUndo();
 ferror = FALSE;    /* If we got this far, we want to go into running
               head mode regardless of errors */
}




fnEditDocument()
{   /* Return to editing document after editing header/footer */
 extern HWND hParentWw;

 Assert( wwdCurrentDoc.fEditFooter != wwdCurrentDoc.fEditHeader );

    /* Restore original window name */
 if (hszWinTextSave != NULL)
    {
    SetWindowText( hParentWw, (LPSTR) (**hszWinTextSave) );
    FreeH( hszWinTextSave );
    hszWinTextSave = NULL;
    }

 TrashCache();

 ValidateHeaderFooter( docCur );    /* This will update from the results of
                       the header/footer edit */
 TrashCache();
 wwdCurrentDoc.cpMin = cpMinCur = cpMinDocument;
 wwdCurrentDoc.cpMac = cpMacCur = CpMacText( docCur );

 TrashWw( wwDocument );
 wwdCurrentDoc.fEditHeader = FALSE;
 wwdCurrentDoc.fEditFooter = FALSE;

    /* Restore saved selection, cpFirst for document */
 wwdCurrentDoc.cpFirst = cpFirstDocSave;
 Select( selDocSave.cpFirst, selDocSave.cpLim );

 Assert( wwdCurrentDoc.cpFirst >= cpMinCur &&
     wwdCurrentDoc.cpFirst <= cpMacCur );

 NoUndo();
 vhDlgRunningHead = (HANDLE)NULL;
}




BOOL far PASCAL DialogRunningHead( hDlg, message, wParam, lParam )
HWND    hDlg;           /* Handle to the dialog box */
unsigned message;
WORD wParam;
LONG lParam;
{
    /* This routine handles input to the Header/Footer dialog box. */

    extern BOOL vfPrinterValid;

    RECT rc;
    CHAR *pch = &stBuf[0];
    struct SEP **hsep = (**hpdocdod)[docCur].hsep;
    struct SEP *psep;
    static int fChecked;
    typeCP dcp;

    switch (message)
    {
    case WM_INITDIALOG:
        vhDlgRunning = hDlg;    /* Put dialog handle in a global for
                       ESC key in document functionality */
        CachePara(docCur, selCur.cpFirst);
        ppapDefault = &vpapAbs;

        FreezeHp();
        /* Get a pointer to the section properties. */
        psep = (hsep == NULL) ? &vsepNormal : *hsep;

        CheckDlgButton(hDlg, idiRHFirst, (ppapDefault->rhc & RHC_fFirst));
        if (wwdCurrentDoc.fEditHeader)
        {
        CchExpZa(&pch, psep->yaRH1, utCur, cchMaxNum);
        }
        else /* footer dialog box */
        {
#ifdef  KOREA    /* 91.3.17 want to guarantee Default >= MIN, Sangl */
              if (vfPrinterValid)
                {   extern int dyaPrOffset;
                    extern int dyaPrPage;
                CchExpZa(&pch, imax(psep->yaMac - psep->yaRH2,
            vsepNormal.yaMac - dyaPrOffset -  dyaPrPage),utCur, cchMaxNum);
                 }
              else
                CchExpZa(&pch, psep->yaMac - psep->yaRH2, utCur, cchMaxNum);
#else
        CchExpZa( &pch, psep->yaMac - psep->yaRH2, utCur, cchMaxNum);
#endif
        }
        SetDlgItemText(hDlg, idiRHDx, (LPSTR)stBuf);
        MeltHp();
        break;

    case WM_ACTIVATE:
        if (wParam)
        {
        vhWndMsgBoxParent = hDlg;
        }
    return(FALSE); /* so that we leave the activate message to
    the dialog manager to take care of setting the focus correctly */

    case WM_COMMAND:
            switch (wParam)
        {
        int dya;

        case idiRHFirst:
        CheckDlgButton( hDlg, idiRHFirst, !IsDlgButtonChecked(hDlg, idiRHFirst));
        (**hpdocdod) [docCur].fDirty = TRUE;
        break;
        case idiRHInsertPage:
        if (FWriteOk( fwcInsert ))
            {   /* Insert page # at insertion pt */
            extern struct CHP vchpFetch, vchpSel;
            extern int vfSeeSel;
            CHAR ch=schPage;
            struct CHP chp;

            if (selCur.cpFirst == selCur.cpLim)
            {   /* Sel is insertion point -- get props from
                               the vchpSel kludge */
            blt( &vchpSel, &chp, cwCHP );
            }
            else
            {
            FetchCp( docCur, selCur.cpFirst, 0, fcmProps );
            blt( &vchpFetch, &chp, cwCHP );
            }

            chp.fSpecial = TRUE;

#ifdef JAPAN //T-HIROYN Win3.1
            if(NATIVE_CHARSET != GetCharSetFromChp(&chp)) {
                SetFtcToPchp(&chp, GetKanjiFtc(&chp));
            }
#endif

            SetUndo( uacInsert, docCur, selCur.cpFirst, (typeCP) 1,
             docNil, cpNil, cp0, 0 );
            InsertRgch( docCur, selCur.cpFirst, &ch, 1, &chp, NULL );

            vfSeeSel = TRUE;
            }
        break;

        case idiRHClear:
        /* Clear running head/foot */
        dcp = cpMacCur-cpMinCur;

#if defined(OLE)
        {
            BOOL bIsOK;

            ObjPushParms(docCur);
            Select(cpMinCur,cpMacCur);
            bIsOK = ObjDeletionOK(OBJ_DELETING);
            ObjPopParms(TRUE);

            if (!bIsOK)
                break;
        }
#endif

        if (dcp > 0 && FWriteOk( fwcDelete ))
            {
            NoUndo();
            SetUndo( uacDelNS, docCur, cpMinCur, dcp,
             docNil, cpNil, cp0, 0 );
            Replace( docCur, cpMinCur, dcp, fnNil, fc0, fc0 );
            }
        break;

        case idiOk: /* return to document */
BackToDoc:
        if (!FPdxaPosIt(&dya, hDlg, idiRHDx))
            {
            break;
            }
        else if (vfPrinterValid)
            {
            extern struct SEP vsepNormal;
            extern int dxaPrOffset;
            extern int dyaPrOffset;
            extern int dxaPrPage;
            extern int dyaPrPage;
            extern struct WWD rgwwd[];

            int dyaPrBottom = imax(0, vsepNormal.yaMac - dyaPrOffset -
              dyaPrPage);


            if (FUserZaLessThanZa(dya, (wwdCurrentDoc.fEditHeader ?
              dyaPrOffset : dyaPrBottom)))
            {
            int dxaPrRight = imax(0, vsepNormal.xaMac - dxaPrOffset
              - dxaPrPage);

            EnableExcept(vhDlgRunningHead, FALSE);
            ErrorBadMargins(hDlg, dxaPrOffset, dxaPrRight,
              dyaPrOffset, dyaPrBottom);
            EnableExcept(vhDlgRunningHead, TRUE);
            SelectIdiText(hDlg, idiRHDx);
            SetFocus(GetDlgItem(hDlg, idiRHDx));
            break;
            }
            }


        DoFormatRHText( dya, IsDlgButtonChecked( hDlg, idiRHFirst ) );
        fnEditDocument();
        /* force repaint to the whole client area */
        GetClientRect(vhWnd, (LPRECT)&rc);
        InvalidateRect(vhWnd, (LPRECT)&rc, FALSE);
        vhWndMsgBoxParent = (HWND)NULL;
        DestroyWindow(hDlg);
        break;

        case idiCancel:
        goto BackToDoc;
        default:
        return(FALSE);
        }
        break;

#if WINVER < 0x300
    /* Don't really need to process this */
    case WM_CLOSE:
        goto BackToDoc;
#endif

#ifndef INEFFLOCKDOWN
    case WM_NCDESTROY:
        FreeProcInstance(lpDialogRunningHead);
        lpDialogRunningHead = NULL;
        /* fall through to return false */
#endif

    default:
        return(FALSE);
    }
    return(TRUE);
}
/* end of DialogRunningHead */




DoFormatRHText( dya, fFirstPage)
int dya;
int fFirstPage;
{   /* Format cp range for running head/foot currently being edited
       to have the passed running head properties */
extern typeCP vcpLimParaCache;

CHAR rgb[4];
int fHeader=wwdCurrentDoc.fEditHeader;

    /* Note that the Min value for the part we were editing has not changed
       as a result of the edit, so no ValidateHeaderFooter is required */
typeCP cpMin=fHeader ? cpMinHeader : cpMinFooter;
int rhc;
struct SEP **hsep = (**hpdocdod)[docCur].hsep;
struct SEP *psep;

 if (!FWriteOk( fwcNil ))
    return;

/* Ensure that this document has a valid section property
descriptor. */
if (hsep == NULL)
    {
    if (FNoHeap(hsep = (struct SEP **)HAllocate(cwSEP)))
    {
    return;
    }
    blt(&vsepNormal, *hsep, cwSEP);
    (**hpdocdod)[docCur].hsep = hsep;
    }
psep = *hsep;

/* Set running head distance from top/bottom; this is a Section
   property.  This assumes the MEMO model: one section */
if (fHeader)
    psep->yaRH1 = dya;
else
    psep->yaRH2 = psep->yaMac - dya;

/* For MEMO, running heads appear on both odd and even pages;
   appearance on first page is optional */
rhc = RHC_fOdd + RHC_fEven;
if (fFirstPage)
    rhc += RHC_fFirst;
if (!fHeader)
    rhc += RHC_fBottom;

/* Set running head PARA properties by adding an appropriate sprm */

    /* Set CpMacCur to include the "hidden" Eol; this will prevent
       AddOneSprm from adding an extraneous EOL */
CachePara( docCur, CpMax( cpMinCur, cpMacCur-1 ) );
Assert( vpapAbs.rhc != 0 );
cpMacCur = CpMax( cpMacCur, vcpLimParaCache );

selCur.cpFirst = cpMinCur;  /* Expand selection to entire area so sprm */
selCur.cpLim = cpMacCur;    /* applies to it all */

rgb [0] = sprmPRhc;
rgb [1] = rhc;
AddOneSprm(rgb, FALSE);

} /* end of DoFormatRHText */




MakeRunningCps( doc, cp, dcp )
int doc;
typeCP  cp;
typeCP  dcp;
{   /* Make the cp range suitable for inclusion in a runninng head or foot.
       This means: (1) Apply a Sprm to the whole thing so it is formatted
       as a running head/foot, (2) Remove any chSects, replacing them
       with Eol's */
 extern struct UAB vuab;
 CHAR   rgb [4];
 int    rhc;
 int    fAdjCpMacCur;
 typeCP cpLimPara;
 typeCP cpT;
 struct SEL selSave;

 if (dcp==cp0 || !FWriteOk( fwcNil ))
    return;

 selSave = selCur;

 /* Scan the cp range, replacing chSects with Eols */

 for ( cpT = cp;
       CachePara( doc, cpT ), (cpLimPara=vcpLimParaCache) <= cp + dcp;
       cpT = cpLimPara )
    {
    typeCP cpLastPara=cpLimPara-1;

    Assert( cpLimPara > cpT );  /* Otherwise we are locked in the loop */

    FetchCp( doc, cpLastPara, 0, fcmChars );
    if (*vpchFetch == chSect)
    {
    struct PAP papT;

    CachePara( doc, cpT );
    papT = vpapAbs;

    Replace( doc, cpLastPara+ccpEol, (typeCP)1, fnNil, fc0, fc0 );
    InsertEolPap( doc, cpLastPara, &papT );

    if (ferror)
        {
        NoUndo();
        break;
        }

        /* Adjust Undo count to account for extra insertion */
    vuab.dcp += (typeCP)(ccpEol-1);
    CachePara( doc, cpT );
    cpLimPara = vcpLimParaCache;
    }
    }

 /* Apply a Sprm that makes everything a running head/foot */

 rhc = RHC_fOdd + RHC_fEven;
 if (wwdCurrentDoc.fEditFooter)
    rhc += RHC_fBottom;

 selCur.cpFirst = cp;            /* OK to just assign to selCur */
 selCur.cpLim   = cp + dcp;      /* because AddOneSprm will handle */

 /* We must temporarily set cpMacCur so that it includes the Eol
    at the end of the header/footer range. Otherwise, AddOneSprm
    may decide it needs to insert a superfluous Eol */

 CachePara( docCur, selCur.cpLim-1 );
 if (fAdjCpMacCur = (vcpLimParaCache > cpMacCur))
    cpMacCur += ccpEol;

 rgb [0] = sprmPRhc;
 rgb [1] = rhc;
 AddOneSprm(rgb, FALSE);    /* Do not set UNDO; we want to undo the paste,
                   which will take care of undoing the sprm */
 if (fAdjCpMacCur)
     cpMacCur -= ccpEol;

 Select( selSave.cpFirst, selCur.cpLim );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\rulerdef.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/


/* These statments define indexes into the ruler button table.	They must agree
with the order the bitmaps are read in mmw.c. */

#define btnNIL		(-1)
#define btnMIN		0
#define btnLTAB 	0
#define btnDTAB 	1
#define btnTABMAX	1
#define btnSINGLE	2
#define btnSP15 	3
#define btnDOUBLE	4
#define btnSPACEMAX	4
#define btnLEFT 	5
#define btnCENTER	6
#define btnRIGHT	7
#define btnJUST 	8

/* Whereas Write 2.x inverted the above-mentioned buttons, the Write 3.x
   buttons have been changed to have rounded corners so can't do that.
   Instead we "follow" the first 8 buttons with 8 more that are "filled-in"
   so we blt back and forth between the two ..pault 7/7/89 */

#define btnMaxReal		9
#define btnMaxUsed      9

/* These statements define the different type of places a mouse might button
down on the ruler. */
#define rlcNIL		(-1)
#define rlcTAB		0
#define rlcSPACE	1
#define rlcJUST 	2
#define rlcRULER	3
#define rlcBTNMAX	3
#define rlcMAX		4

/* These statements define the different types of marks that can appear on the
ruler. */
#define rmkMIN		0
#define rmkMARGMIN	0
#define rmkINDENT	0
#define rmkLMARG	1
#define rmkRMARG	2
#define rmkMARGMAX	3
#define rmkLTAB 	3
#define rmkDTAB 	4
#define rmkMAX		5


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\screen.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This routine sets up the screen position used by Word relative to the
current device. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOCTLMGR
#define NOMENUS
/* HEY!  if you change this to wwsmall.h, talk to bobm!
    (see Assert(LF_FACESIZE == LocalFaceSize)) */
#include <windows.h>
#include "mw.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "fontdefs.h"


int viffnDefault = -1;
CHAR rgffnFontFamily[6][ibFfnMax];


struct FFN *PffnDefault(ffid)
/* returns pointer to default font structure for this font family ID, which
   is set up when we started the program */

FFID ffid;
    {
    int iffn;
    struct FFN *pffn;

    if (ffid == FF_DONTCARE)
        {
        Assert(viffnDefault >= 0);
        iffn = viffnDefault;
        }
    else
        iffn = MpFfidIffn(ffid);

    pffn = (struct FFN *)(rgffnFontFamily[iffn]);
    if (pffn->szFfn[0] == 0)
        /* haven't gotten this one yet - must be old word document */
        GetDefaultFonts(TRUE, FALSE);

    Assert(pffn->szFfn[0] != 0);
    return(pffn);
    }



GetDefaultFonts(fExtraFonts, fGetAspect)
/* We set up our table of default fonts in two steps.  First we choose a single
   font, to use as the default font for a new document.  Perhaps later, we
   are asked for a set of default fonts for different families to help
   make sense out of an old, word document.  That case is differentiated
   by fExtraFonts being TRUE */

int fExtraFonts, fGetAspect;

    {
    extern int aspectXFont;
    extern int aspectYFont;
    extern HDC vhDCPrinter;
    struct FFN *pffn;
    CHAR rgb[ibFfnMax];

    Assert(LF_FACESIZE == LocalFaceSize);
#ifndef NEWFONTENUM  
    Assert(vhDCPrinter);
    if (fGetAspect && vhDCPrinter != NULL)
        {
        extern FARPROC lpFontFaceEnum;
        int rgw[6];

        rgw[0] = enumFindAspectRatio;
        rgw[1] = rgw[2] = 0xFFFF;
        rgw[3] = GetDeviceCaps(vhDCPrinter, LOGPIXELSY);
        rgw[4] = GetDeviceCaps(vhDCPrinter, LOGPIXELSX);
        rgw[5] = TRUE;
        
        EnumFonts(vhDCPrinter, 0L, lpFontFaceEnum, (LPSTR)MAKELONG(&rgw[0], 0));
        aspectXFont = rgw[1];
        aspectYFont = rgw[2];
        }
#endif

    if (FInitFontEnum(docNil, fExtraFonts ? 32767 : 1, TRUE))
        {
        pffn = (struct FFN *)rgb;
        while (FEnumFont(pffn))
#ifdef NEWFONTENUM
            DefaultFamilyCheck(pffn->ffid, pffn->szFfn, pffn->chs);
#else
            DefaultFamilyCheck(pffn->ffid, pffn->szFfn);
#endif
        EndFontEnum();
        }

    /* Fill in just in case we missed some.  The order here is important, if
    there are no fonts at all, the default font will be the first one. */
    {
    extern CHAR szModern[];
    extern CHAR szRoman[];
    extern CHAR szSwiss[];
    extern CHAR szScript[];
    extern CHAR szDecorative[];

    DefaultFamilyCheck(FF_MODERN, szModern, NULL);
    if (fExtraFonts)
        {
        DefaultFamilyCheck(FF_ROMAN, szRoman, NULL);
        DefaultFamilyCheck(FF_SWISS, szSwiss, NULL);
        DefaultFamilyCheck(FF_SCRIPT, szScript, NULL);
        DefaultFamilyCheck(FF_DECORATIVE, szDecorative, NULL);
        DefaultFamilyCheck(FF_DONTCARE, szSwiss, NULL);
        }
    }

    }



DefaultFamilyCheck(ffid, sz, chsIfKnown)
FFID ffid;
CHAR *sz;
BYTE chsIfKnown;
    {
    int iffn;
    struct FFN *pffn;

    iffn = MpFfidIffn(ffid);
    pffn = (struct FFN *)(rgffnFontFamily[iffn]);
    if (pffn->szFfn[0] == 0)
        {
#ifdef NEWFONTENUM
        pffn->chs = chsIfKnown;
#endif
        pffn->ffid = ffid;
        bltszLimit(sz, pffn->szFfn, LF_FACESIZE);
        if (viffnDefault < 0)
                /* this font will be chosen for new documents */
                viffnDefault = iffn;
        }
    }


#define iffnSwiss 0
#define iffnRoman 1
#define iffnModern 2
#define iffnScript 3
#define iffnDecorative 4
#define iffnDontCare 5


MpFfidIffn(ffid)
FFID ffid;
    {
    switch (ffid)
        {
        default:
            Assert( FALSE );
            /* FALL THROUGH */
        case FF_DONTCARE:
            return(iffnDontCare);
        case FF_SWISS:
            return(iffnSwiss);
        case FF_ROMAN:
            return(iffnRoman);
        case FF_MODERN:
            return(iffnModern);
        case FF_SCRIPT:
            return(iffnScript);
        case FF_DECORATIVE:
            return(iffnDecorative);
        }
    }


ResetDefaultFonts(fGetAspect)
int fGetAspect;
    {
    /* This routine resets the default mapping from a font family to a font face
    name. */
    bltbc(rgffnFontFamily, 0, 6 * ibFfnMax);
    viffnDefault = -1;
    GetDefaultFonts(FALSE, fGetAspect);
    }




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\scrnchng.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This routine sets up the screen position used by Word relative to the
current device. */

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOCTLMGR
#define NOMENUS
#define NOICON
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOATOM
#define NODRAWTEXT
#define NOMSG
#define NOOPENFILE
#define NOSCROLL
#define NOSOUND
/*#define NOTEXTMETRIC*/
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "ch.h"
#include "cmddefs.h"
#include "scrndefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "printdef.h"
#include "str.h"
#include "docdefs.h"
#include "propdefs.h"
#include "machdefs.h"
#include "fontdefs.h"
#include "commdlg.h"

#ifdef	DBCS
#include "kanji.h"
#endif

unsigned dxaPrOffset;
unsigned dyaPrOffset;
extern HCURSOR vhcIBeam;


BOOL FSetWindowColors()
    {
    /* This routine sets up the global variables rgbBkgrnd, rgbText, hbrBkgrnd,
    and ropErase, depending on what the current system colors are.  hWnd is a
    handle to a window on top. */

    extern long ropErase;
    extern long rgbBkgrnd;
    extern long rgbText;
    extern HBRUSH hbrBkgrnd;

    long rgbWindow;
    long rgbWindowText;
    HDC hDC;

    /* Get the color of the background and the text. */
    rgbWindow = GetSysColor(COLOR_WINDOW);
    rgbWindowText = GetSysColor(COLOR_WINDOWTEXT);

    /* If the colors haven't changed, then there is nothing to do. */
    if (rgbWindow == rgbBkgrnd && rgbWindowText == rgbText)
        {
        return (FALSE);
        }

    /* Convert the window colors into "pure" colors. */
    if ((hDC = GetDC(NULL)) == NULL)
        {
        return (FALSE);
        }
    rgbBkgrnd = GetNearestColor(hDC, rgbWindow);
    rgbText = GetNearestColor(hDC, rgbWindowText);
    ReleaseDC(NULL, hDC);
    Assert((rgbBkgrnd & 0xFF000000) == 0 && (rgbText & 0xFF000000) == 0);

    /* Set up the brush for the background. */
    if ((hbrBkgrnd = CreateSolidBrush(rgbBkgrnd)) == NULL)
        {
        /* Can't make the background brush; use the white brush. */
        hbrBkgrnd = GetStockObject(WHITE_BRUSH);
        rgbBkgrnd = RGB(0xff, 0xff, 0xff);
        }

    /* Compute the raster op to erase the screen. */
    if (rgbBkgrnd == RGB(0xff, 0xff, 0xff))
        {
        /* WHITENESS is faster than copying a white brush. */
        ropErase = WHITENESS;
        }
    else if (rgbBkgrnd == RGB(0, 0, 0))
        {
        /* BLACKNESS is faster than copying a black brush. */
        ropErase = BLACKNESS;
        }
    else
        {
        /* For everything else, we have to copy the brush. */
        ropErase = PATCOPY;
        }
    return (TRUE);
    }


int FSetScreenConstants()
    {
    /* This routine sets the value of a variety of global variables that used to
    be constants in Mac Word, but are now varibles because screen resolution can
    only be determined at run time. */

    extern HWND hParentWw;
    extern HDC vhDCPrinter;
    extern HBITMAP hbmNull;
    extern int dxpLogInch;
    extern int dypLogInch;
    extern int dxpLogCm;
    extern int dypLogCm;
    extern int dypMax;
    extern int xpRightMax;
    extern int xpSelBar;
    extern int xpMinScroll;
    extern int xpRightLim;
    extern int dxpInfoSize;
    extern int ypMaxWwInit;
    extern int ypMaxAll;
    extern int dypMax;
    extern int dypAveInit;
    extern int dypWwInit;
    extern int dypBand;
    extern int ypSubSuper;
#ifdef KINTL
    extern int dxaAdjustPerCm;
#endif /* ifdef KINTL */

    HDC hDC;
#ifdef KINTL
    int xaIn16CmFromA, xaIn16CmFromP;
#endif /* ifdef KINTL */


    /* First, let's create and save an empty bitmap. */
    if ((hbmNull = CreateBitmap(1, 1, 1, 1, (LPSTR)NULL)) == NULL)
        {
        return (FALSE);
        }

    /* Get the DC of the parent window to play with. */
    if ((hDC = GetDC(hParentWw)) == NULL)
        {
        return (FALSE);
        }

    /* Save away the height of the screen. */
    dypMax = GetDeviceCaps(hDC, VERTRES);

    /* determine screen pixel dimensions */
    dxpLogInch = GetDeviceCaps(hDC, LOGPIXELSX);
    dypLogInch = GetDeviceCaps(hDC, LOGPIXELSY);

    /* convert above to centimeters */
    dxpLogCm = MultDiv(dxpLogInch, czaCm, czaInch);
    dypLogCm = MultDiv(dypLogInch, czaCm, czaInch);

#ifdef KINTL
    /* Now, calculate the kick back amount of xa per cm. */
    xaIn16CmFromA  = 16 * czaCm;
    xaIn16CmFromP  = MultDiv(16 * dxpLogCm, czaInch, dxpLogInch);
    dxaAdjustPerCm = (xaIn16CmFromP - xaIn16CmFromA) / 16;
#endif /* ifdef KINTL */

#ifdef SYSENDMARK
        {
        extern HFONT      vhfSystem;
        extern struct FMI vfmiSysScreen;
        extern int       vrgdxpSysScreen[];
        TEXTMETRIC        tm;

        /* The use of height below is OK, because we are
           just trying to get the reference height. */
        GetTextMetrics(hDC, (LPTEXTMETRIC) &tm);
        
        /* Set up the fields in vfmiSysScreen for the later use. */
        vfmiSysScreen.dxpOverhang = tm.tmOverhang;
#if defined(KOREA)
        if ((tm.tmPitchAndFamily & 1) == 0)
               vfmiSysScreen.dxpSpace = tm.tmAveCharWidth;
        else
#endif
        vfmiSysScreen.dxpSpace = LOWORD(GetTextExtent(hDC,
                                        (LPSTR)" ", 1)) - tm.tmOverhang;
        vfmiSysScreen.dypAscent = tm.tmAscent;
        vfmiSysScreen.dypDescent = tm.tmDescent;
        vfmiSysScreen.dypBaseline = tm.tmAscent;
        vfmiSysScreen.dypLeading = tm.tmExternalLeading;

#ifdef	DBCS	/* KenjiK '90-10-29 */
		/* We must setup appended members of structure. */
        vfmiSysScreen.dxpDBCS = dxpNil;
#endif	/* DBCS */

        bltc(vrgdxpSysScreen, dxpNil, chFmiMax - chFmiMin);
        vfmiSysScreen.mpchdxp = vrgdxpSysScreen - chFmiMin;
        
        /* This is as good a place to get a handle to the system font as
           any other for LoadFont().....? */
        /* Throw away the old one first, if applicable. */
        if (vhfSystem != NULL) {
            DeleteObject((HANDLE) vhfSystem);
            }
        vhfSystem = GetStockObject(SYSTEM_FONT);
        Assert(vhfSystem != NULL);
        }
#endif /* SYSENDMARK */

    /* We don't need the DC any more. */
    ReleaseDC(hParentWw, hDC);

    /* Calculate the positions. */
    xpSelBar = MultDiv(xaSelBar, dxpLogInch, czaInch);
    xpRightMax = MultDiv(xaRightMax, dxpLogInch, czaInch);
    xpRightLim = xpRightMax - (GetSystemMetrics(SM_CXFULLSCREEN) - xpSelBar -
      GetSystemMetrics(SM_CXVSCROLL) + GetSystemMetrics(SM_CXBORDER));
    xpMinScroll = ((MultDiv(xaMinScroll, dxpLogInch, czaInch)+7)/8)*8;
    dxpInfoSize = MultDiv(dxaInfoSize, dxpLogInch, czaInch);
    ypMaxWwInit = MultDiv(yaMaxWwInit, dypLogInch, czaInch);
    ypMaxAll = MultDiv(yaMaxAll, dypLogInch, czaInch);
    dypWwInit = MultDiv(dyaWwInit, dypLogInch, czaInch);
    dypBand = MultDiv(dyaBand, dypLogInch, czaInch);
    ypSubSuper = MultDiv(yaSubSuper, dypLogInch, czaInch);

    /* dypAveInit is a very rough guess as to the height + leading of a 12 point
    font. */
    dypAveInit = MultDiv(cya12pt, dypLogInch, czaInch);

    /* Time to search the user profile to find a printer. */
    if (!FGetPrinterFromProfile())
        {
        return (FALSE);
        }
    GetPrinterDC(FALSE);

    return (TRUE);
    }


BOOL FGetPrinterFromProfile()
    {
    /* This routine searches the user profile for the name of a printer to use
    and records the name in the printer heap strings.  FALSE is returned iff a
    memory error is encountered. */

    extern HWND hParentWw;
    extern CHAR szWindows[];
    extern CHAR szDevice[];
    extern CHAR szDevices[];
    extern BOOL vfPrDefault;
    extern CHAR (**hszPrinter)[];
    extern CHAR (**hszPrDriver)[];
    extern CHAR (**hszPrPort)[];

    CHAR *index(CHAR *, int);
    CHAR *bltbyte(CHAR *, CHAR *, int);

    CHAR szPrinter[cchMaxProfileSz];
    CHAR szDevSpec[cchMaxProfileSz];
    CHAR chNull = '\0';
    CHAR *pch;
    CHAR *pchDriver;
    CHAR *pchPort;
    int cwsz;

    if (!vfPrDefault && hszPrinter != NULL && hszPrPort != NULL)
        {
        /* If the user has selected a printer, then look for that printer in the
        user profile. */

        int cPort;
        int iPort;

        bltsz(&(**hszPrinter)[0], szPrinter);
        GetProfileString((LPSTR)szDevices, (LPSTR)szPrinter, (LPSTR)&chNull,
          (LPSTR)szDevSpec, cchMaxProfileSz);
        cPort = ParseDeviceSz(szDevSpec, &pchPort, &pchDriver);

        /* See if we can find the old port in the list. */
        for (iPort = 0, pch = pchPort; iPort < cPort; iPort++)
            {
            if (WCompSz(&(**hszPrPort)[0], pch) == 0)
                {
                pchPort = pch;
                goto GotPrinter;
                }
            pch += CchSz(pch);
            }

        /* If the port for the current printer has changed, then it must have
        been done by the control panel and we haven't the foggiest idea what
        it is, so grab the first port. */
        goto UnknownPort;
        }

    /* Is there a default Windows printer? */
    GetProfileString((LPSTR)szWindows, (LPSTR)szDevice, (LPSTR)&chNull,
      (LPSTR)szPrinter, cchMaxProfileSz);

#ifdef WIN30
    /* Don't make the assumption like Write 2 did and just grab ANY printer.
       I know, I know -- there's unnecessary code left down below but didn't
       want to mess any special case code up ..pault */
    if ((pch = index(szPrinter, ',')) == 0)
        goto BailOut;
#endif

    /* Does this entry contain the port and driver information. */
    if ((pch = index(szPrinter, ',')) != 0)
        {
        /* Remove any trailing spaces from the printer name. */
        CHAR *pchT;

        for (pchT = pch; *pchT == ' ' && pchT > &szPrinter[0]; pchT--);
        *pchT = '\0';

        /* Parse out the port and the driver names. */
        ParseDeviceSz(pch + 1, &pchPort, &pchDriver);
        }
    
    else
        {
        if (szPrinter[0] == '\0')
            {
            /* No default printer; grab the first one in the list. */
            GetProfileString((LPSTR)szDevices, (LPSTR)NULL, (LPSTR)&chNull,
              (LPSTR)szPrinter, cchMaxProfileSz);

            if (szPrinter[0] == '\0')
                {
BailOut:
                hszPrinter = hszPrDriver = hszPrPort = NULL;
                return (TRUE);
                }
            }

UnknownPort:
        /* Find the device driver and the port of the printer. */
        GetProfileString((LPSTR)szDevices, (LPSTR)szPrinter, (LPSTR)&chNull,
          (LPSTR)szDevSpec, cchMaxProfileSz);
        if (szPrinter[0] == '\0')
            {
            goto BailOut;
            }
        ParseDeviceSz(szDevSpec, &pchPort, &pchDriver);
        }

GotPrinter:
    /* Save the names of the printer, printer driver, and the port. */
    if (FNoHeap(hszPrinter = (CHAR (**)[])HAllocate(cwsz =
      CwFromCch(CchSz(szPrinter)))))
        {
        goto NoHszPrinter;
        }
    blt(szPrinter, &(**hszPrinter)[0], cwsz);
    if (FNoHeap(hszPrDriver = (CHAR (**)[])HAllocate(cwsz =
      CwFromCch(CchSz(pchDriver)))))
        {
        goto NoHszPrDriver;
        }
    blt(pchDriver, &(**hszPrDriver)[0], cwsz);
    if (FNoHeap(hszPrPort = (CHAR (**)[])HAllocate(cwsz =
      CwFromCch(CchSz(pchPort)))))
        {
        FreeH(hszPrDriver);
NoHszPrDriver:
        FreeH(hszPrinter);
NoHszPrinter:
        hszPrinter = hszPrDriver = hszPrPort = NULL;
        return (FALSE);
        }
    blt(pchPort, &(**hszPrPort)[0], cwsz);

    return (TRUE);
    }


int ParseDeviceSz(sz, ppchPort, ppchDriver)
CHAR sz[];
CHAR **ppchPort;
CHAR **ppchDriver;
    {
    /* This routine takes a string that came from the "device" entry in the user
    profile and returns in *ppchPort and *ppchDriver pointers to the port and
    driver sutible for a CreateDC() call.  If no port is found in the string,
    *ppchPort will point to a string containing the name of the null device.
    This routine returns the number of ports for this printer (separated by null
    characters in the string pointed at by *ppchPort).  NOTE: sz may be modified
    by this routine, and the string at *ppchPort may not be a substring of sz
    and should not be modified by the caller. */

    extern CHAR stBuf[];
    extern CHAR szNul[];
    CHAR *index(CHAR *, int);
    CHAR *bltbyte(CHAR *, CHAR *, int);

    register CHAR *pch;
    int cPort = 0;

    /* Remove any leading spaces from the string. */
    for (pch = &sz[0]; *pch == ' '; pch++);

    /* The string starts with the driver name. */
    *ppchDriver = pch;

    /* The next space or comma terminates the driver name. */
    for ( ; *pch != ' ' && *pch != ',' && *pch != '\0'; pch++);

    /* If the string does not have a port associated with it, then the port
    must be the null device. */
    if (*pch == '\0')
        {
        /* Set the port name to "None". */
        *ppchPort = &szNul[0];
        cPort = 1;
        }
    else
        {
        /* As far as we can tell, the port name is valid; parse it from the
        driver name. */
        if (*pch == ',')
            {
            *pch++ = '\0';
            }
        else
            {
            /* Find that comma separating the driver and the port. */
            *pch++ = '\0';
            for ( ; *pch != ',' && *pch != '\0'; pch++);
            if (*pch == ',')
                {
                pch++;
                }
            }

        /* Remove any leading spaces from the port name. */
        for ( ; *pch == ' '; pch++);

        /* Check to see if there is really a port name. */
        if (*pch == '\0')
            {
            /* Set the port name to "None". */
            *ppchPort = &szNul[0];
            cPort = 1;
            }
        else
            {
            /* Set the pointer to the port name. */
            *ppchPort = pch;

            while (*pch != '\0')
                {
                register CHAR *pchT = pch;

                /* Increment the number of ports found for this printer. */
                cPort++;

                /* Remove any trailing spaces from the port name. */
                for ( ; *pchT != ' ' && *pchT != ','; pchT++)
                    {
                    if (*pchT == '\0')
                        {
                        goto EndFound;
                        }
                    }
                *pchT++ = '\0';
                pch = pchT;

                /* Remove any leading spaces in the next port name. */
                for ( ; *pchT == ' '; pchT++);

                /* Throw out the leading spaces. */
                bltbyte(pchT, pch, CchSz(pchT));
                }
EndFound:;
            }
        }

    /* Parse the ".drv" out of the driver. */
    {
      extern CHAR  szExtDrv[];
    if ((pch = index(*ppchDriver, '.')) != 0
         && FRgchSame(pch, szExtDrv, CchSz (szExtDrv) - 1))
        {
        *pch = '\0';
        }
    }

    return (cPort);
    }


SetPrintConstants()
    {
    /* This routine sets the scaling/aspect constants for the printer described
    in vhDCPrinter. */

    extern HDC vhDCPrinter;
    extern BOOL vfPrinterValid;
    extern int dxpPrPage;
    extern int dypPrPage;
    extern int dxaPrPage;
    extern int dyaPrPage;
    extern int dxpLogInch;
    extern int dypLogInch;
    extern int ypSubSuperPr;

    if (vfPrinterValid && vhDCPrinter != NULL)
        {
        POINT rgpt[2];

        /* Get the dimensions of the printer in pixels. */
        dxpPrPage = rgpt[1].x = GetDeviceCaps(vhDCPrinter, HORZRES);
        dypPrPage = rgpt[1].y = GetDeviceCaps(vhDCPrinter, VERTRES);

        /* Put the printer in twips mode to find the dimensions in twips. */
        SetMapMode(vhDCPrinter, MM_TWIPS);
        rgpt[0].x = rgpt[0].y = 0;
        DPtoLP(vhDCPrinter, (LPPOINT)rgpt, 2);

#if WINVER >= 0x300
/* Weird Win bug that we can't decide on the corrective action -- sometimes
   DPtoLP returns x8000 here!  What's that mean?  Well it's SUPPOSED to be
   a large negative number ..pault */
        
        if (rgpt[1].x == 0x8000)
            rgpt[1].x = -(0x7fff);
        if (rgpt[1].y == 0x8000)
            rgpt[1].y = -(0x7fff);
#endif
        
        if ((dxaPrPage = rgpt[1].x - rgpt[0].x) < 0)
            {
            dxaPrPage = -dxaPrPage;
            }
        if ((dyaPrPage = rgpt[0].y - rgpt[1].y) < 0)
            {
            dyaPrPage = -dyaPrPage;
            }
        SetMapMode(vhDCPrinter, MM_TEXT);
        }
    else
        {
        /* Pretend the printer is just like the screen. */
        dxaPrPage = dyaPrPage = czaInch;
        dxpPrPage = dxpLogInch;
        dypPrPage = dypLogInch;
        }

    /* ypSubSuperPr is the offset for subscript and supercript font on the
    printer. */
    ypSubSuperPr = MultDiv(yaSubSuper, dypPrPage, dyaPrPage);
    }


GetPrinterDC(fDC)
BOOL fDC;
    {
    /* This routine sets vhDCPrinter to a new printer DC or IC.  If fDC is TRUE,
    a new DC is created; otherwise, a new IC is created.  In addition, all
    global variables dependent on the printer DC are changed. */

    extern HDC vhDCPrinter;
    extern BOOL vfPrinterValid;
    extern CHAR (**hszPrinter)[];
    extern CHAR (**hszPrDriver)[];
    extern CHAR (**hszPrPort)[];
    extern HWND hParentWw;
    extern int docCur;
    extern struct DOD (**hpdocdod)[];
    extern BOOL vfWarnMargins;
    extern BOOL vfInitializing;
    extern PRINTDLG PD;  

    BOOL fCreateError = FALSE;
    
    
    /* We now pass the local PrinterSetup settings to CreateDC/CreateIC
       since Write's settings can differ from the global ones ..pault */
    LPSTR lpDevmodeData=NULL;

    Assert(vhDCPrinter == NULL);

    /* Get a new printer DC. */
#ifdef WIN30
    if (hszPrinter != NULL && hszPrDriver != NULL && hszPrPort != NULL)
        /* We used to only do this check if vfPrinterValid -- don't 
           now because otherwise one has no way to get Write to believe
           it has a valid printer! ..pt */
#else
    if (vfPrinterValid && hszPrinter != NULL && hszPrDriver != NULL && 
        hszPrPort != NULL)
#endif
        {
        HDC (far PASCAL *fnCreate)() = fDC ? CreateDC : CreateIC;

        StartLongOp();

        if (PD.hDevMode == NULL)
            fnPrGetDevmode(); // get PD.hDevMode

        lpDevmodeData = MAKELP(PD.hDevMode,0);

        if ((vhDCPrinter = (*fnCreate)((LPSTR)&(**hszPrDriver)[0],
          (LPSTR)&(**hszPrinter)[0], (LPSTR)&(**hszPrPort)[0], lpDevmodeData)) !=
          NULL)
            {
            EndLongOp(vhcIBeam);
            vfPrinterValid = TRUE;
            }
        else
            {
            /* If we thought the DC was valid, then we better tell the user it
            is not. */
            EndLongOp(vhcIBeam);
            fCreateError = TRUE;
            goto NoDC;
            }
        }
    else
        {
NoDC:
        /* We don't have a printer DC, so use the DC for the screen. */
        vhDCPrinter = GetDC(hParentWw);
        vfPrinterValid = FALSE;

        /* Warn the user if necessary.  This is done after creating the printer
        DC because Error() may force the DC to be created if we had not already
        done so. */
        if (fCreateError)
            {
            BOOL fInit = vfInitializing;

            vfInitializing = FALSE;
#ifdef	DBCS		/* was in JAPAN */
/*	   We have to answer to WM_WININICHANGE immidiately to ReleaseDC with 
**   'dispatch' printer driver.
**      So It's possible for us opening MessageBox deep in SendMessage 
**    call. This code avoid that.. Yutakan.
*/
            if( !InSendMessage() )
#endif
            Error(IDPMTCantPrint);
            vfInitializing = fInit;
            }
        }

    /* Set new values for the "constants" used by this printer. */
    SetPrintConstants();

    /* Set the size of the paper for this printer. */
    SetPageSize();
    vfWarnMargins = FALSE;

    /* The printer may have changed in such a way that it's fonts have changed
    (i.e. portrait to landscape).  We must re-initialize our list of fonts. */
    ResetDefaultFonts(TRUE);
    if (hpdocdod != NULL)
        {
        Assert((**hpdocdod)[docCur].hffntb != NULL);
        (*(**hpdocdod)[docCur].hffntb)->fFontMenuValid = FALSE;
        }
    }


SetPageSize()
    {
    /* Change the size of the paper to the printer described by vhDCPrinter. */

    extern HDC vhDCPrinter;
    extern HWND vhWndMsgBoxParent;
    extern BOOL vfPrinterValid;
    extern typeCP cpMinHeader;
    extern typeCP cpMacHeader;
    extern typeCP cpMinFooter;
    extern typeCP cpMacFooter;
    extern int dxpPrPage;
    extern int dypPrPage;
    extern int dxaPrPage;
    extern int dyaPrPage;
    extern HWND hParentWw;
    extern struct SEP vsepNormal;
    extern struct DOD (**hpdocdod)[];
    extern int docMac;
    extern int docScrap;
    extern int docUndo;
    extern BOOL vfWarnMargins;

    unsigned xaMac;
    unsigned yaMac;
    unsigned dxaRight;
    unsigned dyaBottom;
    unsigned dyaRH2;
    unsigned dxaPrRight = 0;
    unsigned dyaPrBottom = 0;
    BOOL fRH;
    register struct DOD *pdod;
    int doc;
    HWND hWnd;

    if (hpdocdod == NULL || docMac == 0)
        {
        /* Nothing to do if there are no documents. */
        return;
        }

    Assert(vhDCPrinter);
    if (vfPrinterValid && vhDCPrinter != NULL)
        {
        POINT pt;

        /* Get the page size of the printer. */
        if (Escape(vhDCPrinter, GETPHYSPAGESIZE, 0, (LPSTR)NULL, (LPSTR)&pt))
            {
            xaMac = MultDiv(pt.x, dxaPrPage, dxpPrPage);
            yaMac = MultDiv(pt.y, dyaPrPage, dypPrPage);
            }
        else
            {
            /* The printer won't tell us it page size; we'll have to settle
            for the printable area. */
            xaMac = ZaFromMm(GetDeviceCaps(vhDCPrinter, HORZSIZE));
            yaMac = ZaFromMm(GetDeviceCaps(vhDCPrinter, VERTSIZE));
            }

        /* The page size cannot be smaller than the printable area. */
        if (xaMac < dxaPrPage)
            {
            xaMac = dxaPrPage;
            }
        if (yaMac < dyaPrPage)
            {
            yaMac = dyaPrPage;
            }

        /* Determine the offset of the printable area on the page. */
        if (Escape(vhDCPrinter, GETPRINTINGOFFSET, 0, (LPSTR)NULL, (LPSTR)&pt))
            {
            dxaPrOffset = MultDiv(pt.x, dxaPrPage, dxpPrPage);
            dyaPrOffset = MultDiv(pt.y, dyaPrPage, dypPrPage);
            }
        else
            {
            /* The printer won't tell us what the offset is; assume the
            printable area is centered on the page. */
            dxaPrOffset = (xaMac - dxaPrPage) >> 1;
            dyaPrOffset = (yaMac - dyaPrPage) >> 1;
            }
        }
    else
        {
        /* Assume standard page size for now. */
        xaMac = cxaInch * 8 + cxaInch / 2;
        yaMac = cyaInch * 11;
        dxaPrOffset = dyaPrOffset = 0;
        }

    /* Determine the right and bottom margins for the "normal" page. */
    dxaRight = vsepNormal.xaMac - vsepNormal.xaLeft - vsepNormal.dxaText;
    dyaBottom = vsepNormal.yaMac - vsepNormal.yaTop - vsepNormal.dyaText;
    dyaRH2 = vsepNormal.yaMac - vsepNormal.yaRH2;

    /* Determine the minimum dimensions of the printed page. */
    if (vfPrinterValid)
        {
        dxaPrRight = imax(0, xaMac - dxaPrOffset - dxaPrPage);
        dyaPrBottom = imax(0, yaMac - dyaPrOffset - dyaPrPage);

        hWnd = vhWndMsgBoxParent == NULL ? hParentWw : vhWndMsgBoxParent;

#ifdef BOGUS
        /* Check the margins of the "normal" page. */
        fRH = cpMacHeader - cpMacHeader > ccpEol || cpMacFooter - cpMinFooter >
          ccpEol;
        if (vfWarnMargins && (FUserZaLessThanZa(vsepNormal.xaLeft, dxaPrOffset)
          || FUserZaLessThanZa(dxaRight, dxaPrRight) ||
          FUserZaLessThanZa(vsepNormal.yaTop, dyaPrOffset) ||
          FUserZaLessThanZa(dyaBottom, dyaPrBottom) || (fRH &&
          (FUserZaLessThanZa(vsepNormal.yaRH1, dyaPrOffset) ||
          FUserZaLessThanZa(dyaRH2, dyaPrBottom)))))
            {
            /* One of the margins is bad, tell the user about it. */
            ErrorBadMargins(hWnd, dxaPrOffset, dxaPrRight, dyaPrOffset,
              dyaPrBottom);
            vfWarnMargins = FALSE;
            }
#endif /* BOGUS */

        }

    /* Reset the dimensions of the "normal" page. */
    vsepNormal.xaMac = xaMac;
    vsepNormal.dxaText = xaMac - vsepNormal.xaLeft - umax(dxaRight, dxaPrRight);
    vsepNormal.yaMac = yaMac;
    vsepNormal.dyaText = yaMac - vsepNormal.yaTop - umax(dyaBottom,
      dyaPrBottom);
    vsepNormal.yaRH2 = yaMac - umax(dyaRH2, dyaPrBottom);

    /* Reset the page dimensions for all documents. */
    for (doc = 0, pdod = &(**hpdocdod)[0]; doc < docMac; doc++, pdod++)
        {
        if (pdod->hpctb != NULL && pdod->hsep != NULL)
            {
            /* Reset the existing section properties. */
            register struct SEP *psep = *(pdod->hsep);

            /* Determine the right and bottom margins for this page. */
            dxaRight = psep->xaMac - psep->xaLeft - psep->dxaText;
            dyaBottom = psep->yaMac - psep->yaTop - psep->dyaText;
            dyaRH2 = psep->yaMac - psep->yaRH2;

            /* Check the margins for this document. */
            if (vfWarnMargins && vfPrinterValid && doc != docScrap && doc !=
              docUndo && (FUserZaLessThanZa(psep->xaLeft, dxaPrOffset) ||
              FUserZaLessThanZa(dxaRight, dxaPrRight) ||
              FUserZaLessThanZa(psep->yaTop, dyaPrOffset) ||
              FUserZaLessThanZa(dyaBottom, dyaPrBottom) || (fRH &&
              (FUserZaLessThanZa(psep->yaRH1, dyaPrOffset) ||
              FUserZaLessThanZa(dyaRH2, dyaPrBottom)))))
                {
                ErrorBadMargins(hWnd, dxaPrOffset, dxaPrRight, dyaPrOffset,
                  dyaPrBottom);
                vfWarnMargins = FALSE;
                pdod = &(**hpdocdod)[doc];
                psep = *(pdod->hsep);
                }

            /* Set the dimensions of this page. */
            psep->xaMac = xaMac;
            psep->dxaText = xaMac - psep->xaLeft - dxaRight;
            psep->yaMac = yaMac;
            psep->dyaText = yaMac - psep->yaTop - dyaBottom;
            psep->yaRH2 = yaMac - dyaRH2;
            }

        /* Invalidate any caches for this document. */
        InvalidateCaches(doc);
        }
    }



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\select.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* select.c -- MW selection routines */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOPEN
#define NOWNDCLASS
#define NOICON
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOBITMAP
#define NOBRUSH
#define NOCOLOR
#define NODRAWTEXT
#define NOMB
#define NOPOINT
#define NOMSG
#include <windows.h>
#include "mw.h"
#include "toolbox.h"
#include "docdefs.h"
#include "editdefs.h"
#include "dispdefs.h"
#include "cmddefs.h"
#include "wwdefs.h"
#include "ch.h"
#include "fmtdefs.h"
#include "propdefs.h"
#ifdef DBCS
#include "DBCS.h"
#endif

extern int      vfSeeSel;
extern typeCP       vcpFirstParaCache;
extern typeCP       vcpLimParaCache;
extern typeCP       vcpFetch;
extern CHAR     *vpchFetch;
extern int      vccpFetch;
extern typeCP       cpMinCur;
extern typeCP       cpMacCur;
extern struct SEL   selCur;
extern int      docCur;
extern struct FLI   vfli;
extern struct WWD   rgwwd[];
extern int      vfSelHidden;
extern int      wwCur;
extern struct CHP   vchpFetch;
extern struct PAP   vpapAbs;
extern struct WWD   *pwwdCur;
extern int      vfInsEnd;
extern typeCP       CpBeginLine();
extern int      vfPictSel;
extern int      vfSizeMode;
extern struct CHP   vchpNormal;
extern int      vfInsertOn;
extern struct CHP   vchpSel;    /* Holds the props when the selection
                        is an insert point */
extern int vfMakeInsEnd;
extern typeCP vcpSelect;
extern int vfSelAtPara;
/* true iff the last selection was made by an Up/Down cursor key */
extern int vfLastCursor;
extern int vfDidSearch;
extern typeCP cpWall;


/* C P  L I M  S T Y */
typeCP CpLimSty(cp, sty)
typeCP cp;
int sty;
{    /* Return the first cp which is not part of the same sty unit */
    typeCP CpLastStyChar(), CpLimStySpecial();
    int wb, ch, ich;
    struct EDL *pedl;

    if (cp >= cpMacCur)
        { /* Endmark is own unit */
        return cpMacCur;
        }

    if (cp < cpMinCur)
        cp = cpMinCur;

    switch (sty)
        {
        int dl;
    default:
        Assert( FALSE );
    case styNil:
        return cp;

    case styPara:
        CachePara(docCur, cp);
        if (vcpLimParaCache > cpMacCur)
            { /* No EOL at end of doc */
            return cpMacCur;
            }
        return vcpLimParaCache;
    case styChar:
        /* Because CpLastStyChar() could be returning cpMacCur already. */
        cp = CpLastStyChar( cp ) + 1;
        return ((cp <= cpMacCur) ? cp : cpMacCur);
#ifdef BOGUS
        /* This portion never gets executed...  Why is it in here! */
        CachePara(docCur, cp);
        if (vpapAbs.fGraphics /* && cp > vcpFirstParaCache */)
            return vcpLimParaCache;
#ifdef CRLF
        FetchCp(docCur, cp, 0, fcmChars + fcmNoExpand);
        return *vpchFetch == chReturn ? cp + 2 : cp + 1;
#else /* not CRLF */
        return cp + 1;
#endif
#endif

    case styLine:
        CpBeginLine(&dl, cp);   /* Scrolls cp vertically into view */
        pedl = &(**wwdCurrentDoc.hdndl) [dl];
        return CpMin(pedl->cpMin + pedl->dcpMac, cpMacCur);
    case styDoc:
        return cpMacCur;
    case styWord:
    case stySent:
#ifdef DBCS
        return CpLimStySpecial( CpFirstSty(cp, styChar), sty );
#else
        return CpLimStySpecial( cp, sty );
#endif /* DBCS */
        }

    Assert( FALSE );
}




typeCP  CpLastStyChar( cp )
typeCP cp;
{       /* Return the last cp of the styChar containing cp */
        /* This will be == cp except for pictures & CR-LF  */
        /* And the second byte of DBCS char's.             */

#ifdef DBCS
    typeCP  CpFirstSty();
    CHAR    chRetained;
#endif

    if (cp >= cpMacCur)
            /* Endmark is own unit */
        return cpMacCur;

    if (cp < cpMinCur)
        cp = cpMinCur;

        /* Check for picture */
    CachePara(docCur, cp);
    if (vpapAbs.fGraphics)
        return vcpLimParaCache-1;

        /* Check for CR-LF */
        /* This checking for CR-LF first based on the carriage return */
        /* works only becasue the chReturn is outside of the DBCS     */
        /* range.                             */
#ifdef CRLF
        FetchCp(docCur, cp, 0, fcmChars + fcmNoExpand);
#ifdef DBCS
        if ((chRetained = *vpchFetch) == chReturn) {
        return cp + 1;
        }
        else {
        if (CpFirstSty(cp, styChar) != cp) {
            return cp; /* cp is pointing to the second byte of DBCS. */
            }
        else {
            /* First byte of DBCS or a regular ASCII char. */
            return (IsDBCSLeadByte(chRetained) ? cp + 1 : cp);
            }
        }
#else
        return *vpchFetch == chReturn ? cp + 1 : cp;
#endif /* DBCS */
#else
        return cp;
#endif

}



/* C P  F I R S T  S T Y */
typeCP CpFirstSty(cp, sty)
typeCP cp;
int sty;
{ /* Return the first cp of this sty unit. */
    typeCP CpFirstStySpecial();
    typeCP cpBegin;
    int wb, ch, dcpChunk;
    typeCP cpSent;
    CHAR rgch[dcpAvgSent];
    int ich;
    typeCP cpT;

    if (cp <= cpMinCur)
        return cpMinCur;
    else if (cp >= cpMacCur)
        switch(sty)
            {
            case styNil:
            case styChar:
            return cpMacCur; /* Endmark is own unit */
            default:
            break;
            }

    CachePara( docCur, cp );

    switch (sty)
        {
    default:
        Assert( FALSE );
    case styNil:
        return cp;
    case styPara:
        return vcpFirstParaCache;
    case styChar:
        if (vpapAbs.fGraphics)
            return vcpFirstParaCache;
#ifdef CRLF
        {
        typeCP cpCheckReturn;
        typeCP cpMinScan;

        cpCheckReturn = CpMax( cp, (typeCP) 1) - 1;
#ifdef DBCS
        /* Save vcpFirstParaCache, because it could be changed
           by FetchCp() */
        cpMinScan = vcpFirstParaCache;
#endif /* DBCS */
        FetchCp( docCur, cpCheckReturn, 0, fcmChars + fcmNoExpand );
#ifdef DBCS
        /* This works because chReturn is outside of DBCS range. */
        if (*vpchFetch == chReturn) {
            return cpCheckReturn;
            }
        else {
            typeCP  cpT;
            typeCP  cpRgMin;
            int     ichMacRgch;
            BOOL    fBreakFound;
            int     fkCur;

            cpT = cp;
            do {
            cpRgMin = CpMax( cpT - dcpAvgSent, cpMinScan);
            FetchRgch(&ichMacRgch, rgch, docCur, cpRgMin, cpT,
                  dcpAvgSent);
            ich = ichMacRgch - 1;
            fBreakFound = FALSE;
            while (ich >= 0 && !fBreakFound) {
                if (!IsDBCSLeadByte(rgch[ich])) {
                fBreakFound = TRUE;
                }
                else {
                ich--;
                }
                }
            cpT = cpRgMin;
            } while (!fBreakFound && cpRgMin > cpMinScan);
            if (fBreakFound) {
            ich++;
            }
            else {
            ich = 0;
            }
            fkCur = fkNonDBCS;
            cpT = cpRgMin + ichMacRgch;
            do {
            while (ich < ichMacRgch) {
                 if (fkCur == fkDBCS1) {
                /* Last rgch[] ended with the first byte
                   of a DBCS character. */
                fkCur = fkNonDBCS;
                }
                 else if (IsDBCSLeadByte(rgch[ich])) {
                if (ich + 1 < ichMacRgch) {
                    fkCur = fkNonDBCS;
                    ich++;
                    }
                else {
                    fkCur = fkDBCS1;
                    }
                }
                 else {
                fkCur = fkNonDBCS;
                }
                ich++;
                }
            cpRgMin = cpT;
            cpT += dcpAvgSent;
            if (cpT <= cp) { /* Saves some time. */
                FetchRgch(&ichMacRgch, rgch, docCur, cpRgMin, cpT,
                      dcpAvgSent);
                ich = 0;
                }
            } while (cpT <= cp);

            if (fkCur == fkDBCS1) {
            Assert(cp - 1 <= cpMacCur);
            return (cp - 1);
            }
            else {
            Assert(cp <= cpMacCur);
            return (cp);
            }
            }
#else
        return *vpchFetch == chReturn ? cpCheckReturn : cp;
#endif /* DBCS */
        }
#else
        return cp;
#endif
    case styDoc:
        return cpMinCur;
    case styLine:
        {
        int dlJunk;

        return CpBeginLine( &dlJunk, cp );
        }
    case styWord:
    case stySent:
#ifdef DBCS
        return CpFirstStySpecial( CpFirstSty(cp, styChar), sty );
#else
        return CpFirstStySpecial( cp, sty );
#endif /* DBCS */
        }
    Assert( FALSE );
}




/* S E L E C T */
/* used to make a selection from a cp-interval, for example after a find. */
Select(cpFirst, cpLim)
typeCP cpFirst, cpLim;
{ /* Make a selection */
 typeCP cpFirstOld = selCur.cpFirst;
 typeCP cpLimOld = selCur.cpLim;
 int fOldCursorLine;

 if (cpFirst > cpLim)
    /*     The only time this condition should be true is when we have
       run out of memory.  The following is a senario where
       such is the case (and actually, the reason for this code change).
           Let us suppose that we have cut, pasted to the end of the
       document, and are now executing a "command a" (repeat last
       operation).  The procedure CmdAgain is invoked.  CmdAgain first
       calls replace in order to add the text to the document.  Now it
       must position the cursor properly by calling select.
           A SetUndo operation called by the prior paste gave us the
       number of bytes that were added to the document.  In its call
       to Select, CmdAgain assumes that where it wants to position the
       cursor is at the old last char position plus the SetUndo quantity
       mentioned above.  But, if the replace operation failed (due to
       lack of memory), CmdAgain may be trying to place the cursor beyond
       the physical end of the document.
           Other fixes of this problem, at the caller level (CmdAgain)
       instead of within Select, are probably "better" in the sense of
       programming clarity.  The chosen solution has the one advantage
       of programming expediency. */
    cpFirst = cpLim;
    /* This statement replaces "Assert(cpFirst <= cpLim);" */

    vfInsEnd = fFalse;
/* notation:    + add highlight
        - remove highlight
        .. leave alone
        00 common portion
*/
    if (!vfSelHidden)
    {
    if (cpFirst < cpFirstOld)
        { /* +++... */
        if (cpLim <= cpFirstOld)
        { /* +++   --- */
        goto SeparateSels;
        }
        else
        { /* +++000... */
        ToggleSel(cpFirst, cpFirstOld, true);
        if (cpLim < cpLimOld)
            { /* +++000--- */
            ToggleSel(cpLim, cpLimOld, false);
            }
        else if (cpLim > cpLimOld)
            { /* +++000+++ */
            ToggleSel(cpLimOld, cpLim, true);
            }
/* Handle the case when old selection was an insert bar */
        if (cpFirstOld == cpLimOld)
            ToggleSel(cpFirstOld, cpLimOld, false);
        }
        }
    else
        { /* ---... */
        if (cpLimOld <= cpFirst)
        { /* --- +++ */
SeparateSels:
        fOldCursorLine = cpFirstOld == cpLimOld;
/* prevent flashing if insert point which is ON is repeatedly selected */
/* conditions are: not repeated, not insert point, not ON, not at desired end of line */
        vfInsEnd = vfMakeInsEnd;
        if ( cpFirst != cpFirstOld || cpLim != cpLimOld ||
            !fOldCursorLine || !vfInsertOn ||
            selCur.fEndOfLine != vfMakeInsEnd)
            {
            selCur.fEndOfLine = vfMakeInsEnd;
            if (fOldCursorLine)
            ClearInsertLine();
/* old selection is off if it was a cursor line */
            ToggleSel(cpFirst, cpLim, fTrue);
/* otherwise the old selection is turned off AFTER the new one is made to
make it look faster */
            if (!fOldCursorLine)
            ToggleSel(cpFirstOld, cpLimOld, fFalse);
            }
        }
        else
        { /* ---000... */
        if (cpLimOld < cpLim)
            { /* ---000+++ */
            ToggleSel(cpLimOld, cpLim, true);
            }
        else if (cpLimOld > cpLim)
            { /* ---000--- */
            ToggleSel(cpLim, cpLimOld, false);
            }
        ToggleSel(cpFirstOld, cpFirst, false);
        }
        }
    }

 selCur.cpFirst = cpFirst;
 selCur.cpLim = cpLim;
 selCur.fForward = cpFirst != cpMacCur;
 if (cpFirst == cpLim)
    {
    GetInsPtProps(cpFirst);
    vfDidSearch = FALSE; /* reestablish for searching */
    cpWall = cpLim;
    }
 vfLastCursor = vfSizeMode = vfPictSel = vfMakeInsEnd = false;

 /* Set vfPictSel iff the selection is exactly one picture */

 CachePara( docCur, selCur.cpFirst );
 if (vpapAbs.fGraphics && selCur.cpLim == vcpLimParaCache)
    vfPictSel = TRUE;

}




/* G E T  I N S  P T  P R O P S */
GetInsPtProps(cp)
typeCP cp;
{     /* determine properties of the insertion point */

if (cpMacCur != cpMinCur)
    {
    CachePara(docCur, cp);
    if (vcpFirstParaCache == cpMacCur)
        {
            /* cp is in the last para--use preceding para props */
        CachePara(docCur, vcpFirstParaCache - 1);
        if (vpapAbs.fGraphics)
            {   /* Yet another 10 point kludge -- get default props
               when typing after a picture at doc end */

            goto Default;
            }
        }
    if (vpapAbs.fGraphics)
        /* 10 point kludge: make typing before picture non-vchpNormal */
        goto Default;

    FetchCp(docCur, CpMax(vcpFirstParaCache, cp - 1), 0, fcmProps);
    blt(&vchpFetch, &vchpSel, cwCHP);
    if (vchpFetch.fSpecial && vchpFetch.hpsPos != 0)
        { /* if this char is a footnote or page marker, then ignore */
        vchpSel.hpsPos = 0;       /* super/subscript stuff. */
        vchpSel.hps = HpsAlter(vchpSel.hps, 1);
        }
    vchpSel.fSpecial = FALSE;
    }
else
    {
Default:
    /* force default character properties, font size to be 10 point */
    blt(&vchpNormal, &vchpSel, cwCHP);
    vchpSel.hps = hpsDefault;
    }
}




/* C H A N G E  S E L */
ChangeSel(cp, sty)
typeCP cp;
int sty;
{   /* Make selCur move, expand or contract to cp */
    /* sty is unit to keep in case of movement or flipped selection */
    /* styChar is not supported; it is munged to styNil */
    /* This is because the Write/Word user interface never asks us to */
    /* pivot the selection around a single character, we pivot around */
    /* an insertion point ("styNil") instead */
    int     fNullSelection = (selCur.cpFirst == selCur.cpLim);
    typeCP  cpFirst = selCur.cpFirst;
    typeCP  cpLim = selCur.cpLim;
    int     fForward = selCur.fForward;
    typeCP  cpOffFirst, cpOffLim, cpOnFirst, cpOnLim;

    if (sty == styChar)
    sty = styNil;

    if (cp == cpMinCur - 1 || cp > cpMacCur)
    { /* Trying to flip off the beginning or end */
    _beep();
    return;
    }

    cpOffFirst = cpOffLim = cpOnFirst = cpOnLim = cpNil;

    if (cp <= cpFirst)
    { /* Extend backwards */
    if (cp == cpLim)
        return;
    if (fForward && !fNullSelection)
    { /* Selection flipped */
        if (vfPictSel)
        /* stuck this in to 'correct' behaviour when select pict and
           drag up.  Don't want to unselect first pict (4.22.91) v-dougk */
        {
            cpOnFirst = CpFirstSty( cp, sty);
            cpOffFirst = cpOffLim = cpLim;
        }
        else
        {
            cpOffFirst = selCur.cpLim = CpMin(cpLim, CpLimSty(cpFirst, sty));
            cpOnFirst = CpFirstSty( cp, sty);
            cpOffLim = cpLim;
        }
    }
    else
        {
        if ( fNullSelection )
        cpOffLim = cpOffFirst = selCur.cpFirst;
        cpOnFirst = CpFirstSty( cp, styChar );
        if (cpFirst == cpOnFirst)
        return;
        }
    selCur.fForward = false;

    cpOnLim = cpFirst;
    selCur.cpFirst = cpOnFirst;
    }
    else if (cp >= cpLim)
    { /* Extend forwards */
    if (cp == cpFirst)
        return;
    if (!fForward && !fNullSelection)
        { /* Selection flipped */
        cpOffLim = selCur.cpFirst =
        CpMax( cpFirst, CpFirstSty( (sty ==styNil) ? cpLim : cpLim-1,
                         sty ));
        cpOnLim = CpLimSty(cp, sty);
        cpOffFirst = cpFirst;
        }
    else
        {
        if ( fNullSelection )
        cpOffLim = cpOffFirst = selCur.cpFirst;
        cpOnLim = cp;
        if (cpLim == cpOnLim)
        return;
        }
    selCur.fForward = true;

    cpOnFirst = cpLim;
    selCur.cpLim = cpOnLim;
    if (cpOnLim == cpLim && cpOffLim != cpLim)
        cpOnLim = cpNil;
    }
    else if (fForward)
    { /* Shrink a forward selection */
    cpOffFirst = cp;
    if (selCur.cpLim == cpOffFirst)
        return;
    selCur.cpLim = cpOffFirst;
    cpOffLim = cpLim;
    }
    else
    { /* Shrink a backward selection */
    cpOffLim = cp;
    if (selCur.cpFirst == cpOffLim)
        return;
    selCur.cpFirst = cpOffLim;
    cpOffFirst = cpFirst;
    }

    ToggleSel(cpOnFirst, cpOnLim, true);
    ToggleSel(cpOffFirst, cpOffLim, false);

    /* Check for a stray insert point */

    if (selCur.cpFirst != selCur.cpLim)
    ClearInsertLine();

    /* Set vfPictSel iff the selection is exactly one picture */

    CachePara( docCur, selCur.cpFirst );
    vfPictSel = vpapAbs.fGraphics && (selCur.cpLim == vcpLimParaCache);
}




/* S E L E C T  D L  X P */
SelectDlXp(dl, xp, sty, fDrag)
int dl, xp, sty;
int fDrag;
{ /* Move cursor to the nearest valid CP and select unit */
    typeCP cp;
    typeCP cpFirst;
    typeCP cpLim;
    register struct EDL *pedl;
    int xpStart = xpSelBar - wwdCurrentDoc.xpMin;
    int itcMin, itcLim;
    int xpLeft;
    int xpPos;
    int fPictInsertPoint=FALSE; /* Setting an insert point before a pict */

    UpdateWw(wwCur, false);        /* Synchronize cursor & text */

    xp = max(0, xp - xpStart);
    dl = min( wwdCurrentDoc.dlMax - 1, dl );

    pedl = &(**wwdCurrentDoc.hdndl) [dl];
    cp = pedl->cpMin;

    /* At or Below EMark */
    if (cp >= cpMacCur)
        {
        cp = cpMacCur;
        goto FoundCp;
        }

    if (pedl->fGraphics)
        {  /*
        Special kludge for selecting a picture:
            Select the whole picture (if the hit is inside or to the
                   right of the picture)
            Select an insert point just before the picture if the hit
            is to the left of the picture OR in the selection bar
            when the picture is left-justified) */
        if ( (xp < pedl->xpLeft) || (sty == styLine && xp == 0) )
            fPictInsertPoint = TRUE;

        goto FoundCp;
        }

    if (sty >= styPara)
        { /* Selecting a paragraph, line, doc */
        goto FoundCp;
        }

    /* Must Format to figure out the right cp */

    FormatLine(docCur, cp, pedl->ichCpMin, cpMacCur, flmSandMode); /*HM*/

    CachePara(docCur, cp);
    pedl = &(**wwdCurrentDoc.hdndl) [dl];

    if (vfli.fSplat) /* Selecting in division/page break */
        {
        cp = vfli.cpMin;
        goto FoundCp;
        }

    xpLeft = pedl->xpLeft;

    if (vfli.xpLeft != xpLeft)
        /* This indicates that we are in lo memory conditions; in trouble */
        return;
    /* Assert (vfli.xpLeft == xpLeft); May not be true in lo memory */

    if (xp <= xpLeft)
        {
        itcMin = 0;
        goto FoundCp;
        }

    /* Out of bounds right */
    if (xp >= pedl->xpMac)
        {
        itcMin = vfli.cpMac - cp - 1;
        cp = vfli.cpMac - 1;
        goto CheckPastPara;
        }

    /* Search through the line for the cp at position xp */
    xpPos = xpLeft;
    itcMin = 0;
    itcLim = vfli.cpMac - cp;

    while (itcMin < itcLim && xpPos < xp)
        xpPos += vfli.rgdxp[itcMin++];

    if (itcMin >= 1)
        /* This may not be true if we are so low on memory that
           FormatLine could not do its job */
        itcMin--;

    cp += itcMin;

    CachePara(docCur, cp);
    if ((xpPos < xp + vfli.rgdxp[itcMin] / 2) &&
        (sty == styChar /* || !fDrag */) )
        { /* Actually selecting next character */
    CheckPastPara:
        if (cp + 1 == vcpLimParaCache && !vpapAbs.fGraphics &&
                        (vfSelAtPara || vcpSelect == cpNil))
            /* Return insert point before paragraph mark */
            {
            if (vcpSelect == cpNil)
                vfSelAtPara = true;
            goto FoundCp;
            }
        itcMin++;
        cp++;
        }
//T-HIROYN sync win3.0
#ifdef  DBCS
    /* if itcMin point the second char of kanji, increment itcMin */
    if (itcMin < itcLim && vfli.rgdxp[itcMin]==0)
        goto CheckPastPara; /* Select next character */
#endif /* DBCS */

FoundCp:
        /* Set up selection limits */
    cpFirst = CpFirstSty( cp, sty );
    cpLim = CpLimSty( cp, sty );

    if (sty == styChar)
        {
        if ( !pedl->fGraphics || fPictInsertPoint )
          /* In text or before a pic: don't extend to end of styChar */
        cpLim = cpFirst;

        if ( vcpSelect == cpNil )
        {   /* First time through, remember where we started */

        /* Set if we want to kludge the insert point at the end of *pedl */

        vfMakeInsEnd = (cp == pedl->cpMin + pedl->dcpMac &&
                   cp <= cpMacCur &&
                   !pedl->fGraphics &&
                   !pedl->fSplat);
        vcpSelect = cpFirst;
        }
        }

    if (fDrag)
        ChangeSel( selCur.fForward ? cpLim : cpFirst, sty );
    else
        Select( cpFirst, cpLim );
}




typeCP CpEdge()
{ /* Return edge of selection */
    return selCur.fForward ?
        CpMax( CpFirstSty( selCur.cpLim - 1, styChar ), selCur.cpFirst ) :
        selCur.cpFirst;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\scrollvt.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOPEN
#define NOWNDCLASS
#define NOICON
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOBITMAP
#define NOBRUSH
#define NOCOLOR
#define NODRAWTEXT
#define NOMB
#define NOPOINT
#define NOMSG
#include <windows.h>
#include "mw.h"
#include "docdefs.h"
#include "dispdefs.h"
#include "fmtdefs.h"
#include "cmddefs.h"
#include "wwdefs.h"
#include "propdefs.h"

/* Globals used here only */
struct TR  {       /* Text Row info for CtrBackDyp Cache */
        typeCP cp;
        int dcpDepend;  /* dcpDepend for PREVIOUS edl */
        int ichCp;
        int dyp;
        };
struct TR rgtrCache[ itrMaxCache ];
int wwCache=wwNil;


extern struct PAP       vpapAbs;
extern typeCP           vcpFirstParaCache;
extern struct WWD       *pwwdCur;
extern struct SEL       selCur;
extern int              docCur;
extern typeCP           cpCacheHint;
extern typeCP           cpMinCur;
extern typeCP           cpMacCur;
extern struct FLI       vfli;
extern int              wwCur;
extern int              ctrCache;
extern int              itrFirstCache;
extern int              itrLimCache;
extern int              vfOutOfMemory;




/* P U T  C P  I N  W W  V E R T*/
PutCpInWwVert(cp)
typeCP cp;

    {
/* vertical case */
    typeCP cpMac;
    struct EDL (**hdndl) [] = pwwdCur->hdndl;
    int dlMac=pwwdCur->dlMac;
    struct EDL *pedl = &(**hdndl) [dlMac - 1];
    struct EDL *pedlFirst = &(**hdndl) [0];

    if ((pedl->yp > pwwdCur->ypMac) && (pedl > pedlFirst))
            /* Partial line at the bottom of the window -- this doesn't count
               unless it's all we've got */
        {  pedl--;  dlMac--;  }
    if (cp < pwwdCur->cpFirst ||
        cp > (cpMac = pedl->cpMin + pedl->dcpMac) ||
        (cp == cpMac && !pedl->fIchCpIncr) ||
            /* Covers insertion points before pictures reached via curs keys */
        (CachePara( docCur, cp ),
             (vpapAbs.fGraphics &&
              (selCur.cpFirst == selCur.cpLim) &&
              (pedlFirst->cpMin == selCur.cpFirst) &&
              (pedlFirst->ichCpMin > 0))))
        {
        DirtyCache(pwwdCur->cpFirst = cp);
        pwwdCur->ichCpFirst = 0;
        CtrBackDypCtr( 9999, dlMac >> 1 );
        }
    }




SetCurWwVScrollPos( )
{
 typeCP cp;
 int dr;
 struct EDL (**hdndl)[] = pwwdCur->hdndl;

/* calculate desired elevator position dr */

 if ((cp = pwwdCur->cpMac - pwwdCur->cpMin) == (typeCP) 0)
    dr = 0;
 else
    {
    typeCP CpWinGraphic();
    typeCP cpWinFirst = ((**hdndl) [0].fGraphics && !pwwdCur->fDirty) ?
                            CpWinGraphic( pwwdCur ) : pwwdCur->cpFirst;

    dr = min(drMax - 1,
          (int)(((cpWinFirst - pwwdCur->cpMin) * (drMax - 1) + (cp >> 1)) / cp));
    }

/* Contemplating this 'if' statement should elevate one to a higher plane
of existence. */
 if (dr != pwwdCur->drElevator)
            /* reset the value of the vertical scroll bar */
    SetScrollPos( pwwdCur->hVScrBar,
                  pwwdCur->sbVbar,
                  pwwdCur->drElevator = dr,
                  TRUE);
}




/* A D J  W W  V E R T */
/* Scroll a window down vertically so that UpdateWw can re-use the text
that is still visible. Otherwise, UpdateWw would write over the very
lines it will need later on near the bottom of the window.
*/
AdjWwVert(cdl, dyp)
int cdl;
{
#if defined(JAPAN) & defined(DBCS_IME)
extern	void	IMEManage( );
#endif
        struct EDL *pedl;
        int dl;

        if (cdl == 0) return;

        cdl = umin( cdl, pwwdCur->dlMac ); /* ! don't let it run off the end */

        Assert( dyp > 0 );

        ClearInsertLine();
        DypScroll(wwCur, 0, cdl, pwwdCur->ypMin + dyp);
/* invalidate the first cdl dl's */
        pedl = &(**(pwwdCur->hdndl))[0];
        for (dl = 0; dl < cdl; dl++)
                (pedl++)->fValid = FALSE;
        pwwdCur->fDirty = fTrue;
#if defined(JAPAN) & defined(DBCS_IME)
	IMEManage( FALSE );
#endif
}




ScrollDownCtr(ddr)
int ddr;
{ /* Scroll down in the document by ddr text lines (but < 1 screenful) */
        struct EDL *pedl;

        UpdateWw(wwCur, FALSE); /* Dl's must be correct */

        ddr = min(ddr, max(1, pwwdCur->dlMac - 1));

        pedl = &(**(pwwdCur->hdndl))[ddr - 1]; /* pedl is first line above new screen */
        while (ddr > 0 && pedl->cpMin + pedl->dcpMac > cpMacCur)
                { /* Don't scroll the endmark off the screen */
                --pedl;
                --ddr;
                }

        /* Change the cpFirst of the window and dirty it */
        if (ddr > 0)
                {
                struct TR tr;
                int dcpDepend;

                if (wwCur != wwCache)
                    {   /* If window has changed, invalidate cache here
                           so cp's cached below will be used */
                    TrashCacheS();
                    wwCache = wwCur;
                    }

                HideSel(); /* Don't scroll selection if machine can't handle it */
                ClearInsertLine();

                pwwdCur->cpFirst = pedl->cpMin + pedl->dcpMac;
                pwwdCur->ichCpFirst = pedl->fIchCpIncr ? pedl->ichCpMin + 1 : 0;
                pwwdCur->dcpDepend = pedl->dcpDepend; /* Remember hot spot */

                /* Make tr cache entries for the disappearing lines */
                pedl = &(**(pwwdCur->hdndl))[0];
                if (ctrCache == 0) /* We don't have top line yet */
                    {
                    tr.cp =    pedl->cpMin;
                    tr.ichCp = pedl->ichCpMin;
                    tr.dyp =   pedl->dyp;
                    tr.dcpDepend = pwwdCur->dcpDepend;
                    AppendCachePtr( &tr );
                    }

                while ( ddr-- )
                    {
                    tr.cp = pedl->cpMin + pedl->dcpMac;
                    tr.ichCp = pedl->fIchCpIncr ? pedl->ichCpMin + 1 : 0;
                    tr.dcpDepend = pedl->dcpDepend;
                    tr.dyp = (++pedl)->dyp;
                    AppendCachePtr( &tr );
                    }

                pwwdCur->fDirty = true;
                SetCurWwVScrollPos();
                CheckMode();
                }
        else
                {
                _beep();
                }
}




ScrollUpDypWw()
{   /* Scroll up in the document by one screenfull less 1 line */
int dypKeep=8;
struct EDL *pedl = &(**pwwdCur->hdndl) [0];

if (pedl->fValid)
    {
    dypKeep = pedl->dyp;
    }

if (CtrBackDypCtr( pwwdCur->ypMac - pwwdCur->ypMin - dypKeep,9999 ) == 0)
    {
    _beep();
    }
else
    CheckMode();
}



ScrollUpCtr( ctr )
int ctr;
{   /* Scroll Up ctr text rows in the doc (scroll window down) */
 if (CtrBackDypCtr( 9999, ctr ) == 0)
    {
    _beep();
    }
 else
    CheckMode();
}




int CtrBackDypCtr( dypLim, ctrLim )
int dypLim;
int ctrLim;
{   /* Set pwwdCur->cpFirst to the cpFirst of the text line
       dypLim pixels or ctrLim text rows before the value of
       pwwdCur->cpFirst, whichever limit is reached first.
       Adjust the position of the vert scroll bar according to the new cpFirst.
       Return the number of text rows (tr) we went back. */

 int fAdj = ( (pwwdCur->cpFirst == (**(pwwdCur->hdndl))[0].cpMin) ||
              !(**(pwwdCur->hdndl))[0].fValid );
 typeCP cpFirst = pwwdCur->cpFirst;
 int    ichCpFirst = pwwdCur->ichCpFirst;
 int    ctrGrant = 0;      /* ctr we've backed over so far */
 int    dypGrant = 0;      /* dyp we've backed over so far */
 int    ichFake = 0;

 pwwdCur->fCpBad = false;        /* Reset hot spot warning */
 pwwdCur->fDirty = true;

/* Cache is only valid for one ww -- invalidate if ww has changed */
 if (wwCur != wwCache)
    {
    TrashCacheS();
    wwCache = wwCur;
    }

 if (ctrCache == 0)
        /* Don't have cache entry for first line in Ww -- force formatting
           THROUGH first line of Ww instead of TO it. */
    ++ichFake;

 for ( ;; )
    {
    /* If there is no info in the cache, must replenish it. */

    if (ctrCache <= 1) /* <=: also replenish if 1st line of Ww is only entry */
        {
        typeCP cpStart;         /* cp to start formatting from */
        int    dcpDepend;       /* Dependency of line containing cpStart */
        typeCP cp;
        int    ichCp;
        int    itrTempCacheLim = 0;
        struct TR rgtrTempCache[ itrMaxCache ];
        int    fTempCacheOverflow = false;

        if ((cpFirst <= cpMinCur) && (ichCpFirst == 0))
            {      /* Reached top of document */
            if (fAdj)
                AdjWwVert( ctrGrant, dypGrant );
            pwwdCur->cpFirst = cpMinCur;
            pwwdCur->ichCpFirst = 0;
            pwwdCur->dcpDepend = 0;
            goto SetScroll;
            }

        /* Want to go back BEFORE the earliest point we have in the cache */

        if (ichFake > 0)
                /* Force formatting THROUGH { cpFirst, ichCpFirst }
                   instead of TO */
            --ichFake;
        else if (ichCpFirst > 0)
            --ichCpFirst;
        else
            --cpFirst;

        cpStart = CpHintCache( cpFirst );
        if ( ( CachePara( docCur, cpFirst ), vcpFirstParaCache ) >= cpStart )
            {
            cpStart = vcpFirstParaCache;
            dcpDepend = 0;  /* At para start; we know dependency is 0 */
            }
        else
            dcpDepend = cpMaxTl;    /* real value unknown; use max */

        /* Add TR info for lines from { cpStart, 0 } THROUGH
           { cpFirst, ichCpFirst } to temporary cache */

        for ( cp = cpStart, ichCp = 0;
              (cp < cpFirst) || ((cp == cpFirst) && (ichCp <= ichCpFirst)); )
            {
            struct TR *ptr;

            if (itrTempCacheLim == itrMaxCache)
                {   /* Overflowed the temp cache */
                fTempCacheOverflow = fTrue;
                itrTempCacheLim = 0;
                }

            /* Add one tr to the cache */

            FormatLine( docCur, cp, ichCp, cpMacCur, flmSandMode );
            if (vfOutOfMemory)
                return ctrGrant;
            ptr = &rgtrTempCache[ itrTempCacheLim++ ];
            ptr->cp = cp;
            ptr->ichCp = ichCp;
            ptr->dyp = vfli.dypLine;
            ptr->dcpDepend = dcpDepend; /* Save dcpDepend for prev line */
            dcpDepend = vfli.dcpDepend;

            /* Continue with next line */

            cp = vfli.cpMac;
            ichCp = vfli.ichCpMac;
            }   /* end for */

        /* Add our temporary cache in front of the real one */
        PrependCacheRgtr( rgtrTempCache, itrTempCacheLim );
        if (fTempCacheOverflow)
                /* We wrapped around the end of the temp cache; include the
                   rest of the circle */
            PrependCacheRgtr( &rgtrTempCache[ itrTempCacheLim ],
                              itrMaxCache - itrTempCacheLim );
        }   /* end for */

    /* Walk backward in the cache, eliminating entries,
       until: (1) We have run through enough yp's or tr's  (return) OR
              (2) We have exhausted the cache (loop back to refill it)
       NOTE: Case 2 catches the case when we hit the beginning of the doc */

    Assert( ctrCache >= 1 );
    Assert( itrLimCache > 0 );
    for ( ;; )
        {
        struct TR *ptr = &rgtrCache[ itrLimCache - 1 ];

        if (ctrCache == 1)
            {   /* Only one thing left in cache: the 1st line of the Ww */
            cpFirst = ptr->cp;
            ichCpFirst = ptr->ichCp;
            break;  /* Exhausted cache; loop back to refill it */
            }

        if ( (dypGrant >= dypLim) || (ctrGrant >= ctrLim) )
            {   /* Passed through enough yp's or tr's -- we're done */
            if (fAdj)
                AdjWwVert( ctrGrant, dypGrant );
            pwwdCur->cpFirst = ptr->cp;
            pwwdCur->ichCpFirst = ptr->ichCp;
            pwwdCur->dcpDepend = ptr->dcpDepend;
            goto SetScroll;
            }

            /* Remove end entry from the cache */
        if (--itrLimCache <= 0)
            itrLimCache = itrMaxCache;
        ctrCache--;

        /* Update ctrGrant, dypGrant -- we've granted 1 line of scrollback */

        ctrGrant++;
        dypGrant += rgtrCache [itrLimCache - 1].dyp;
        }   /* end for */

    Assert( ctrCache == 1 );
    }   /* end for */

SetScroll:  /* All done; set vert scroll bar according to new cpFirstWw */
 SetCurWwVScrollPos();
 return ctrGrant;
}




/* A P P E N D  C A C H E  P T R */
AppendCachePtr( ptr )
struct TR *ptr;
{   /* Say we are scrolling up a line, append *ptr to tr cache */

        if (++ctrCache > itrMaxCache)
                { /* Have to push one off the top */
                if (++itrFirstCache == itrMaxCache)
                        itrFirstCache = 0;
                --ctrCache;
                }
        /* Now add one onto the end */
        if (itrLimCache++ == itrMaxCache)
                itrLimCache = 1;
        rgtrCache[ itrLimCache - 1 ] = *ptr;
}




/* P R E P E N D  C A C H E  R G T R */
PrependCacheRgtr( rgtr, ctr )
struct TR rgtr[];
int ctr;
{ /* PREPEND one or more lines JUST BEFORE the ones in the cache */
  /* The tr cache is a ring buffer. rgtrCache[ itrLimCache - 1 ] is the
     tr entry describing the cpFirst of wwCur; rgtrCache[ itrFirstCache ]
     is the tr for the earliest line we know of.  All between are
     contiguous.  ctrCache is the number of tr's we have cached. */

 struct TR *ptr = &rgtr[ ctr ];

 ctrCache += (ctr = min(ctr, itrMaxCache - ctrCache));

    /* Compensate for state introduced by TrashCache -- itrLimCache == 0 */
 if (itrLimCache == 0)
    itrLimCache = itrMaxCache;

 while (ctr-- != 0)
    {   /* Now add each tr */
    if (itrFirstCache-- == 0)
        itrFirstCache = itrMaxCache - 1;
    rgtrCache[ itrFirstCache ] = *(--ptr);
    }
}




/* T R A S H  C A C H E s */
TrashCacheS()
{ /* Invalidate scrolling cache */
        ctrCache = 0;
        cpCacheHint = cp0;
        itrFirstCache = itrLimCache = 0;
}





/* C P  H I N T  C A C H E */
typeCP CpHintCache(cp)
typeCP cp;
{ /* Give the latest cp <= arg cp that begins a line */
 return (cpCacheHint <= cp) ? cpCacheHint : cpMinCur;
}




DirtyCache(cp)
typeCP cp;
{ /* Invalidate cache beyond cp */
        while (ctrCache-- > 1)
                {
                typeCP cpT = rgtrCache[itrLimCache - 1].cp;
                if (--itrLimCache == 0)
                        itrLimCache = itrMaxCache;
                if (cpT < cp)
                        { /* Found our hint; dirty one extra line for word wrap */
                        cpCacheHint = rgtrCache [itrLimCache - 1].cp;
                        itrLimCache = itrFirstCache;
                        ctrCache = 0;
                        return;
                        }
                }

        TrashCacheS();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\scrollhz.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOICON
#define NOATOM
#define NOFONT
#define NOBRUSH
#define NOCLIPBOARD
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOMB
#define NOMETAFILE
#define NOOPENFILE
#define NOPEN
#define NOREGION
#define NOSOUND
#define NOWH
#define NOWNDCLASS
#define NOCOMM
#define NOFONT
#define NOBRUSH
#include <windows.h>
#include "mw.h"
#define NOUAC
#include "cmddefs.h"
#include "wwdefs.h"
#include "dispdefs.h"
#include "fmtdefs.h"

extern long             ropErase;
extern struct WWD       *pwwdCur;
extern struct WWD       rgwwd[];
extern int              wwCur;
extern int              docCur;
extern typeCP           cpMacCur;
extern struct FLI       vfli;

int NEAR    FOnScreenRect(RECT *);


/* P U T  C P  I N  W W  H Z */
PutCpInWwHz(cp)
typeCP cp;
 /* Ensure that cp is in wwCur */
 /* Make sure it's not off to left or right, too. */

    { /* Just check for horizontal bounding; vertical is done
        by call to CpBeginLine below. */
    int dxpRoom, xp, xpMin;
    int dlT;
    typeCP cpBegin;

    UpdateWw(wwCur, false);
    cpBegin = CpBeginLine(&dlT, cp);
    FormatLine(docCur, cpBegin, (**(pwwdCur->hdndl))[dlT].ichCpMin, cpMacCur, flmSandMode);
/* xpMin is a dummy here */
    xp = DxpDiff(0, (int)(cp - vfli.cpMin), &xpMin) + vfli.xpLeft;
    xpMin = pwwdCur->xpMin;
/* we have: xp = desired position, xpMin = amount of horizontal scroll */
/* width of space in window for text */
    dxpRoom = (pwwdCur->xpMac - xpSelBar);
    if (xp < xpMin )
        { /* cp is left of screen */
        AdjWwHoriz(max(0, xp - min(dxpRoom - 1, cxpAuto)) - xpMin);
        }
    else if (xp >= xpMin + dxpRoom)
        { /* cp is right of screen */
        register int dxpRoomT = min(xpRightMax, xp + min(dxpRoom - 1, cxpAuto))
          - dxpRoom + 1;

        AdjWwHoriz(max(0, dxpRoomT) - xpMin);
        }
    }


/* A D J  W W  H O R I Z */
AdjWwHoriz(dxpScroll)
int dxpScroll;
    {
    /* Scroll a window horizontally */
    if (dxpScroll != 0)
        {
        RECT rc;

/* Reset the value of the horizontal scroll bar */
        SetScrollPos( pwwdCur->hHScrBar,
                      pwwdCur->sbHbar,
                      pwwdCur->xpMin + dxpScroll,
                      TRUE);

#ifdef ENABLE   /* HideSel() */
        HideSel();
#endif /* ENABLE */

        ClearInsertLine();

        SetRect( (LPRECT)&rc, xpSelBar, 0, pwwdCur->xpMac, pwwdCur->ypMac );
        ScrollCurWw( &rc, -dxpScroll, 0 );
        TrashWw(wwCur);
        pwwdCur->xpMin += dxpScroll;

        if (pwwdCur->fRuler)
            {
            UpdateRuler();
            }

        }
    }




/* Scroll specified subrectangle of current window by specified amount */
#include <stdlib.h>
ScrollCurWw( prc, dxp, dyp )
register RECT    *prc;
int     dxp,dyp;
{

 extern int vfScrollInval;
 RECT rcClear;
 if (dxp && dyp)
    return; /* Scroll in both dimensions is an illegal case */

 if (!(dxp || dyp))
    return; /* no scrolling to do */

#if 1
    /** 
        The previous old, old code was getting flaky. (7.14.91) v-dougk
     **/
    if (ScrollDC(pwwdCur->hDC,dxp,dyp,(LPRECT)prc,(LPRECT)prc,NULL,&rcClear))
    {
        PatBlt( pwwdCur->hDC, rcClear.left, rcClear.top, 
            rcClear.right-rcClear.left+1, rcClear.bottom-rcClear.top+1, ropErase );

        if (dxp)
            vfScrollInval =  FALSE;
        else 
            vfScrollInval =  (rcClear.bottom-rcClear.top+1) > abs(dyp); 

         if (vfScrollInval)
         {
            InvalidateRect(pwwdCur->wwptr,&rcClear,FALSE);
            UpdateInvalid();  
         }
    }
    else
        vfScrollInval = FALSE;
    return;
#else

 int FCheckPopupRect( HWND, LPRECT );
 extern int vfScrollInval;
 HDC hDC;
 int dxpAbs = (dxp < 0) ? -dxp : dxp;
 int dypAbs = (dyp < 0) ? -dyp : dyp;
 struct RS { int left, top, cxp, cyp; }
                     rsSource, rsDest, rsClear;
 /* Set rsSource, rsDest, rsClear == prc */

 if ((rsSource.cxp = imin( prc->right, pwwdCur->xpMac ) -
                     (rsSource.left = imax( 0, prc->left ))) <= 0)
        /* Rectangle is null or illegal in X-dimension */
    return;
 if ((rsSource.cyp = imin( prc->bottom, pwwdCur->ypMac ) -
                (rsSource.top = imax( pwwdCur->ypMin, prc->top ))) <= 0)
        /* Rectangle is null or illegal in Y-dimension */
    return;
 bltbyte( &rsSource, &rsDest, sizeof (struct RS ));
 bltbyte( &rsSource, &rsClear, sizeof (struct RS ));

 hDC = pwwdCur->hDC;

 if ((dxpAbs < rsSource.cxp) && (dypAbs < rsSource.cyp))
     {  /* A Real scroll, not the bogus case when we just clear exposed area */
        /* NOTE: We do not bother to compute rsSource.cxp or rsSource.cyp,
           as they are not needed by BitBlt or PatBlt */

        /* If there are PopUp windows, use ScrollWindow to avoid getting
           bogus bits from some popup. Since this is slow, only do it if there
           is some popup that overlaps the scroll rect */
     if ( AnyPopup() )
        {
        extern HANDLE hMmwModInstance;
        static FARPROC lpFCheckPopupRect = (FARPROC)NULL;

        /* First time through, inz ptr to thunk */

        if (lpFCheckPopupRect == NULL)
            lpFCheckPopupRect = MakeProcInstance( (FARPROC) FCheckPopupRect,
                                                  hMmwModInstance );
        EnumWindows( lpFCheckPopupRect, (LONG) (LPRECT) prc );
        }

        /* Under windows 2.0, must also check for any part of the scroll
           rectangle being off the screen (not possible in tiling environment).
           If so, use ScrollWindow to avoid getting bogus bits from outside
           the screen. */
     if (!FOnScreenRect( prc ))
        vfScrollInval = TRUE;

     if (vfScrollInval)
         {   /* vfScrollInval also tells UpdateWw that invalid region
                may have changed */

         extern BOOL vfEraseWw;

         ScrollWindow( pwwdCur->wwptr, dxp, dyp, (LPRECT)prc, (LPRECT)prc );
         vfEraseWw = TRUE;
         UpdateInvalid();    /* Marks repaint area as invalid in our
                                structures so we don't think bits grabbed
                                from a popup are valid */
         vfEraseWw = FALSE;
         return;
         }

     if (dxp != 0)
        rsDest.cxp -= (rsClear.cxp = dxpAbs);
     else
            /* dxp==dyp==0 case is caught below */
        rsDest.cyp -= (rsClear.cyp = dypAbs);

     if (dxp < 0)
        {
        rsSource.left += dxpAbs;
        rsClear.left += rsDest.cxp;
        }
     else if (dxp > 0)
        {
        rsDest.left += dxpAbs;
        }
     else if (dyp < 0)
        {
        rsSource.top += dypAbs;
        rsClear.top += rsDest.cyp;
        }
     else if (dyp > 0)
        {
        rsDest.top += dypAbs;
        }
     else
        return;

    BitBlt( hDC,
            rsDest.left, rsDest.top,
            rsDest.cxp,  rsDest.cyp,
            hDC,
            rsSource.left, rsSource.top,
            SRCCOPY );
    }


#ifdef SMFONT
 /* Vertical refresh will be so bindingly fast, that we do not need to erase the
 old text. */
 if (dxp != 0)
    {
    PatBlt(hDC, rsClear.left, rsClear.top, rsClear.cxp, rsClear.cyp, ropErase);
    }
#else /* not SMFONT */
 PatBlt( hDC, rsClear.left, rsClear.top, rsClear.cxp, rsClear.cyp, ropErase );
#endif /* SMFONT */
#endif
}



int FCheckPopupRect( hwnd, lprc )
HWND hwnd;
LPRECT lprc;
{   /* If the passed window is not a popup, return TRUE;
       If the passed window is a popup, and its coordinates overlap
       those of the passed rect, set vfScrollInval to TRUE and return FALSE.
       Otherwise, return TRUE.
       This is a window enumeration function: a return of TRUE means
       continue enumerating windows, a return of FALSE means
       stop the enumeration */

 extern int vfScrollInval;
 RECT rc;
 POINT ptTopLeft, ptBottomRight;
 RECT rcResult;

 if ( !(GetWindowLong( hwnd, GWL_STYLE ) & WS_POPUP) )
        /* Window is not a popup */
    return TRUE;

 /* Get popup rectangle in screen coordinates */

 GetWindowRect( hwnd, (LPRECT) &rc );

 /* Convert rc from screen coordinates to current document window coordinates */

 ptTopLeft.x = rc.left;
 ptTopLeft.y = rc.top;
 ptBottomRight.x = rc.right;
 ptBottomRight.y = rc.bottom;

 ScreenToClient( pwwdCur->wwptr, (LPPOINT) &ptTopLeft );
 ScreenToClient( pwwdCur->wwptr, (LPPOINT) &ptBottomRight );

 rc.left = ptTopLeft.x;
 rc.top = ptTopLeft.y;
 rc.right = ptBottomRight.x;
 rc.bottom = ptBottomRight.y;

 IntersectRect( (LPRECT) &rcResult, (LPRECT) &rc, (LPRECT)lprc );
 if ( !IsRectEmpty( (LPRECT) &rcResult ) )
    {   /* Popup overlaps passed rectangle */
    vfScrollInval = TRUE;
    return FALSE;
    }

 return TRUE;
}




/* S C R O L L  L E F T */
ScrollLeft(dxp)
int dxp;
        { /* Scroll current window left dxp pixels */
        if ((dxp = min(xpRightLim - pwwdCur->xpMin, dxp)) >0)
                AdjWwHoriz(dxp);
        else
                _beep();
        }


/* S C R O L L  R I G H T */
ScrollRight(dxp)
int dxp;
        {
        if ((dxp = min(pwwdCur->xpMin, dxp)) > 0)
                AdjWwHoriz(-dxp);
        else
                _beep();
        }






/* F O N S C R E E N R E C T

    Returns TRUE iff the rectangle is entirely within the screen
    boundaries.
    Assumes the rectangle belongs to the current window.

 */

int NEAR
FOnScreenRect(prc)
register RECT *prc;
{

    POINT ptTopLeft, ptBottomRight;
    int cxScreen = GetSystemMetrics( SM_CXSCREEN );
    int cyScreen = GetSystemMetrics( SM_CYSCREEN );

    ptTopLeft.x = prc->left;
    ptTopLeft.y = prc->top;
    ptBottomRight.x = prc->right;
    ptBottomRight.y = prc->bottom;

    ClientToScreen( pwwdCur->wwptr, (LPPOINT) &ptTopLeft );
    ClientToScreen( pwwdCur->wwptr, (LPPOINT) &ptBottomRight );

    if ((ptTopLeft.x <= 0) || (ptTopLeft.y <= 0) ||
        (ptBottomRight.x >= cxScreen) || (ptBottomRight.y >= cyScreen))
        return FALSE;

    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\scrndefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* This file contains definitions for screen dependent positions in twips which
will be converted to pixels later. */

#define cch12pt		80	/* number of "12 pt" chars across the screen */
#define cxa12pt		144	/* width of a 12 pt fixed font in twips */
#define cya12pt		240	/* height of a 12 pt fixed font in twips */

/* size of lines for dnMax estimation purposes */
#define dyaAveInit	240

/* width of the selection bar area to the left of lines */
#define xaSelBar	288

#define dxaScrlBar	270
#define dyaScrlBar	300

#define xaMinScroll	180

/* these define the initial window size and amount of white space above
the first line */
#define yaMaxWwInit	5580

/* should be > than largest window height + height of blank line after
the endmark */
#define yaMaxAll	20000	/* used for invalidation */
#define dyaWwInit	60

#define dyaBand		320	/* formerly dpxyLineSizeMin */

/* height of left portion of a split line */
#define dyaSplitLine	60

#define yaSubSuper	60

#define dxaInfoSize	1800

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\select2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* Select2.c -- Less-frequently-used selection routines */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOSOUND
#define NOCOMM
#define NOPEN
#define NOWNDCLASS
#define NOICON
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NOBITMAP
#define NOBRUSH
#define NOCOLOR
#define NODRAWTEXT
#define NOMB
#define NOPOINT
#define NOMSG
#include <windows.h>
#include "mw.h"
#include "toolbox.h"
#include "docdefs.h"
#include "editdefs.h"
#include "dispdefs.h"
#include "cmddefs.h"
#include "wwdefs.h"
#include "ch.h"
#include "fmtdefs.h"
#include "propdefs.h"

extern int		vfSeeSel;
extern typeCP		vcpFirstParaCache;
extern typeCP		vcpLimParaCache;
extern typeCP		vcpFetch;
extern CHAR		*vpchFetch;
extern int		vccpFetch;
extern typeCP		cpMinCur;
extern typeCP		cpMacCur;
extern struct SEL	selCur;
extern int		docCur;
extern struct FLI	vfli;
extern struct WWD	rgwwd[];
extern int		vfSelHidden;
extern int		wwCur;
extern struct CHP	vchpFetch;
extern struct PAP	vpapAbs;
extern struct WWD	*pwwdCur;
extern int		vfInsEnd;
extern typeCP		CpBeginLine();
extern int		vfPictSel;
extern int		vfSizeMode;
extern struct CHP	vchpNormal;
extern int		vfInsertOn;
extern struct CHP	vchpSel;	/* Holds the props when the selection
						is an insert point */
extern int vfMakeInsEnd;
extern typeCP vcpSelect;
extern int vfSelAtPara;
/* true iff the last selection was made by an Up/Down cursor key */
extern int vfLastCursor;



/* C P	L I M  S T Y  S P E C I A L */
typeCP CpLimStySpecial(cp, sty)
typeCP cp;
int sty;
{    /* Return the first cp which is not part of the same sty unit */
	int wb, ch, ich;
	struct EDL *pedl;

	/* Other cases covered in CpLimSty, our only caller */

	Assert( cp < cpMacCur );
	Assert( cp >= cpMinCur );
	Assert( sty == styWord || sty == stySent );

/* Special kludge for picture paragraphs */
	CachePara(docCur, cp);
	if (vpapAbs.fGraphics)
		return vcpLimParaCache;

	FetchCp(docCur, cp, 0, fcmChars + fcmNoExpand);

	Assert(vccpFetch != 0);

	/* Must be word or sentence */
	wb = WbFromCh(ch = vpchFetch[ich = 0]);
#ifdef CRLF
	if (ch == chReturn)
		return vcpFetch + 2;
#endif
	if (ch == chEol || ch == chSect || ch == chNewLine || ch == chTab)
		/* EOL is its own unit */
		return vcpFetch + 1;

	if (wb == wbWhite && sty == stySent)
		{ /* Might be between sentences; go back to text */
		FetchCp(docCur, CpFirstSty(cp, styWord), 0, fcmChars + fcmNoExpand);
		wb = WbFromCh(ch = vpchFetch[ich = 0]);
		}

	for (;;)
		{
		if (++ich >= vccpFetch)
			{ /* Get next line and set up */
			FetchCp(docNil, cpNil, 0, fcmChars);
			if (vcpFetch == cpMacCur)
				return cpMacCur; /* End of doc */
			ich = 0;
			}
		if (sty == stySent)
			switch (ch)
				{
			case chDot:
			case chBang:
			case chQMark:
				sty = styWord;
				wb = wbPunct;
				}
		switch (ch = vpchFetch[ich])
			{
		case chTab:
		case chEol:
		case chSect:
		case chNewLine:
#ifdef CRLF
		case chReturn:
#endif
			goto BreakFor;
			}
		if (sty == styWord)
			{ /* Word ends after white space or on text/punct break */
			int wbT = WbFromCh(ch);
			if (wb != wbT && (wb = wbT) != wbWhite)
				break;
			}
		}
	BreakFor:
	return vcpFetch + ich;
}



/* C P	F I R S T  S T Y  S P E C I A L */
typeCP CpFirstStySpecial(cp, sty)
typeCP cp;
int sty;
{ /* Return the first cp of this sty unit. */
	typeCP cpBegin;
	int wb, ch, dcpChunk;
	typeCP cpSent;
	CHAR rgch[dcpAvgSent];
	int ich;
	typeCP cpT;

	/* Other cases were covered by CpFirstSty, our only caller */

	Assert( cp > cpMinCur );
	Assert( sty == stySent || sty == styWord );

	if (cp >= cpMacCur)
	    cpT = cp = cpMacCur;
	else
	    cpT = cp++;

	CachePara(docCur, cpT );
	if ((vcpFirstParaCache == cpT) || vpapAbs.fGraphics)
	    return vcpFirstParaCache;

	dcpChunk = (sty == styWord) ? dcpAvgWord : dcpAvgSent;
	cpBegin = (cp > dcpChunk) ? cp - dcpChunk : cp0;

	FetchRgch(&ich, rgch, docCur, cpBegin, cp, dcpChunk);
	wb = WbFromCh(ch = rgch[--ich]);

#ifdef CRLF
	if(cpBegin + ich == 0)
	    return cp0;

	if (ch == chEol && rgch[ich-1] == chReturn) /* EOL is its own unit */
	    return cpBegin + ich - 1;
	if (ch == chEol || ch == chReturn || ch == chSect || ch == chNewLine || ch == chTab)
	    return cpBegin + ich;
#else /* not CRLF */
	if (ch == chEol || ch == chSect || ch == chNewLine || ch == chTab) /* EOL is its own unit */
	    return cpBegin + ich;
#endif /* CRLF */

	if (wb == wbText)
		cpSent = cpBegin + ich;
	else
		cpSent = cpNil;

	for (;;)
		{
		if (ich == 0)
			{
			if (cpBegin == cpMinCur)
				return cpMinCur; /* beginning of doc */
			cpBegin = (cpBegin > dcpChunk) ? cpBegin - dcpChunk : cp0;
			FetchRgch(&ich, rgch, docCur, cpBegin, cp, dcpChunk);
			}
		ch = rgch[--ich];
		CachePara( docCur, cpBegin + ich ); /* Needed for pictures */
		if (ch == chEol || ch == chSect || ch == chNewLine ||
				   ch == chTab || vpapAbs.fGraphics )
			break; /* EOL Always ends a unit */
		if (sty == styWord)
			{
			if (wb != wbWhite)
				{
				if (WbFromCh(ch) != wb)
					break;
				}
			else
				wb = WbFromCh(ch);
			}
		else
			{ /* Test for sentence. */
			switch (ch)
				{
			case chDot:
			case chBang:
			case chQMark:
				if (cpSent != cpNil)
					return cpSent;
				}
			switch (WbFromCh(ch))
				{
			case wbText:
				cpSent = cpBegin + ich;
				wb = wbText;
				break;
			case wbPunct:
				switch (wb)
					{
				case wbWhite:
					wb = wbPunct;
					break;
				case wbText:
					cpSent = cpBegin + ich;
					}
				break;
			case wbWhite:
				if (wb == wbPunct)
					cpSent = cpBegin + ich + 1;
				wb = wbWhite;
				break;
				}
			}
		}
	return cpBegin + ich + 1;
}



/* W B	F R O M  C H */
int WbFromCh(ch)
int ch;
{ /* Return word-breakness of ch */

	switch (ch)
		{
	case chSpace:
	case chEol:
#ifdef CRLF
	case chReturn:
#endif
	case chSect:
	case chTab:
	case chNewLine:
	case chNBSFile:
		return wbWhite;
	case chNRHFile:
		return wbText;
	default: /* we are using the ANSI char set that windows used */
		return ((isalpha(ch) || isdigit(ch))? wbText : wbPunct);
		}
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\selectsp.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/


#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCTLMGR
#define NOWINMESSAGES
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#include "windows.h"

#include "mw.h"
#include "cmddefs.h"
#include "fmtdefs.h"
#include "docdefs.h"
#include "propdefs.h"
#include "prmdefs.h"
#include "editdefs.h"
#include "macro.h"
#include "str.h"
#if defined(OLE)
#include "obj.h"
#endif

/* E X T E R N A L S     */

extern int            vstyCur;
extern int            docCur;
extern typeCP         vcpLimParaCache;
extern struct SEL     selCur;
extern struct PAP     vpapAbs;
extern struct SEL     selPend;
extern struct UAB     vuab;
extern struct CHP     vchpFetch;
extern struct CHP     vchpSel;
extern int            docUndo;
extern int            ferror;
extern typeCP         cpMinCur;
extern typeCP         cpMacCur;
extern int            vfObjSel;




/* L O O K S  M O U S E */
LooksMouse()
{
        int cch;
        char rgb[cchPAP + 2];

        if (vstyCur == styPara || vstyCur == styLine)
                { /* Copy paragraph looks */
                  /* MEMO Version: no effect on tab table */
                int itbd;
                CachePara(docCur, selCur.cpFirst);

#ifdef CASHMERE
                for (itbd = 0; vpapAbs.rgtbd[itbd].dxa != 0; itbd++);
                rgb[1] = (cwPAPBase + (itbd + 1) * cwTBD) * cchINT;
                bltbyte(&vpapAbs, &rgb[2], rgb[1]);
#else
                blt( &vpapAbs, &rgb[2], rgb[1] = cwPAPBase );
#endif
                rgb[0] = sprmPSame;
                Select(selPend.cpFirst, selPend.cpLim);
                AddOneSprm(rgb, fTrue);
                vuab.uac = uacLookParaMouse;
                }
        else
                { /* Copy character looks */
                struct CHP chpT;
                FetchCp(docCur, CpMax(cp0, selCur.cpFirst - 1), 0, fcmProps);
                chpT = vchpFetch;
                Select(selPend.cpFirst, selPend.cpLim);
                vchpSel = chpT;
                if (selPend.cpFirst == selPend.cpLim)
                        return;
                bltbyte(&vchpSel, &rgb[1], cwCHP * cchINT);
                rgb[0] = sprmCSame;
                AddOneSprm(rgb, fTrue);
                vuab.uac = uacLookCharMouse;
                }

        SetUndoMenuStr(IDSTRUndoLook);
}




/* C O P Y  M O U S E */
CopyMouse()
{
        typeCP cpDest, cpSrc, dcp;
        int fKludge = false;

        if (selPend.cpFirst == selPend.cpLim)
                return;

        if (FWriteOk(fwcInsert))
                {
                cpDest = selCur.cpFirst;
                dcp = selPend.cpLim - (cpSrc = selPend.cpFirst);

/*-----         SetUndo(uacInsert, docCur, cpDest, dcp, docNil, cpNil, cp0, 0);--*/
        /* ReplaceCps can't deal with copies from/to the same doc, so use undo
                        buffer as intermediate storage */
                NoUndo();

                ClobberDoc(docUndo, docCur, cpSrc, dcp);
                if (ferror)
                    return;
                else if (!FCheckPicture(&cpDest, dcp, true, docCur))
                    SetUndo(uacInsert, docCur, cpDest, dcp, docNil, cpNil, cp0, 0);

                ReplaceCps(docCur, cpDest, cp0, docUndo, cp0, dcp);
                if (ferror)
                    {
                    NoUndo();
                    return;
                    }
                else 
                {
#if defined(OLE)
                    ObjEnumInRange(docCur,cpDest,cpDest+dcp,ObjCloneObjectInDoc);
#endif
                    if (cpDest >= cpMinCur && cpDest + dcp <= cpMacCur)
                            Select(cpDest, cpDest + dcp);
                }
                }


        SetUndoMenuStr(IDSTRUndoEdit);
}




/* M O V E  M O U S E */
MoveMouse()
{
        typeCP cpSrc, dcp, cpDest;

        if (selPend.cpFirst == selPend.cpLim)
                return;

        if (FWriteOk(fwcInsert))
                {
                cpDest = selCur.cpFirst;
                dcp = selPend.cpLim - (cpSrc = selPend.cpFirst);
                if (FMoveText(docCur, cpSrc, dcp, docCur, &cpDest, fTrue))
                    SetUndoMenuStr(IDSTRUndoEdit);
                }
}





/* F  M O V E  T E X T */
int FMoveText(docSrc, cpSrc, dcp, docDest, pcpDest, fSetUndo)
int docSrc, docDest, fSetUndo;
typeCP cpSrc, dcp, *pcpDest;
{ /* returns true unless moving into yourself */
        int fT;
        typeCP cpT, cpMacT;

        Assert(docSrc == docDest);

            /* Same document; use undo buffer as intermediary */
        if (*pcpDest >= cpSrc && *pcpDest < cpSrc + dcp
#ifdef FOOTNOTES
                || *pcpDest >= CpFirstFtn(docSrc, cpSrc, &fT) &&
                  *pcpDest < CpFirstFtn(docSrc, cpSrc + dcp, &fT)
#endif
           )
                        {
                        Error(IDPMTBadMove);
                        return false;
                        }
        ClobberDoc(docUndo, docSrc, cpSrc, dcp);
        if (ferror)
                return false;

        if (FCheckPicture(pcpDest, dcp, false, docDest))
                if (cpSrc >= *pcpDest)
                        cpSrc += (typeCP)ccpEol;

/* cpMacT will measure the total adjustment incurred by the following replace
as it may be different from dcp-cp0 (e.g. due to Eol inserted in front of
a picture
*/
        cpMacT = cpMacCur;
        ReplaceCps(docDest, *pcpDest, cp0, docUndo, cp0, dcp);
        cpT = *pcpDest;
        if (docDest == docSrc)
                {
                if (cpT < cpSrc)
                        cpSrc += cpMacCur - cpMacT;
                else /* cpT >= cpSrc */
                        cpT -= cpMacCur - cpMacT;
                }
        /* Now delete old text */
        Replace(docSrc, cpSrc, dcp, fnNil, fc0, fc0);

        if (ferror)
            {
            NoUndo();
            return FALSE;
            }
        else
            {
            if (docDest == docCur && cpT >= cpMinCur && cpT + dcp <= cpMacCur)
                Select(cpT, cpT + dcp);
            if (fSetUndo)
                SetUndo(uacMove, docCur, cpSrc, dcp, docCur, cpT, cp0, 0);
            }
        return true;
}




/* F  C H E C K  P I C T U R E */

int FCheckPicture(pcpDest, dcp, fSetUndo, doc)
typeCP *pcpDest, dcp;
int fSetUndo;
int doc;
{
        typeCP cpDest = *pcpDest;
        CachePara(docUndo, cp0);
        if (vpapAbs.fGraphics && cpDest > cp0)
                { /* Special case for inserting a picture paragraph */
                CachePara(doc, cpDest - 1);
                if (vcpLimParaCache == cpDest + 1 && vcpLimParaCache < cpMacCur)
/* this special case is here to move the insertion point from 1 char away
from a para boundary (a common point to select) to the boundary so that
we do not have to insert an ugly extra cr. This does not apply at the
end of the document */
                        {
                        *pcpDest += 1;
                        return fFalse;
                        }
                if (vcpLimParaCache != cpDest)
                        {
                        if (fSetUndo)
                                SetUndo(uacInsert, doc, cpDest, dcp + (typeCP)ccpEol,
                                        docNil, cpNil, cp0, 0);
                        InsertEolPap(doc, cpDest, &vpapAbs);
                        *pcpDest += (typeCP)ccpEol;
                        return true;
                        }
                }
        return false;
}




/* C H E C K  M O V E */
CheckMove()
{
if(vuab.doc == vuab.doc2)
        {
        /* same doc means we might have to worry about shifting cp's */
        if (vuab.cp < vuab.cp2)
                vuab.cp2 -= vuab.dcp;
        else if (vuab.cp > vuab.cp2)
                vuab.cp += vuab.dcp;
#ifdef DEBUG
        else
                Assert(false);
#endif
        }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\search.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* search.c    Search/Replace    */
/*              Brodie Nov 25 83 */
/*              Lipkie Nov 15 83 */
#define NOATOM
#define NOBITMAP
#define NOBRUSH
#define NOCLIPBOARD
#define NOCOLOR
#define NOCOMM
#define NOCREATESTRUCT
#define NODRAWTEXT
#define NOFONT

#ifndef JAPAN
#define NOGDI
#endif

#define NOGDICAPMASKS
#define NOHDC
#define NOICON
#define NOKEYSTATE
#define NOMEMMGR
#define NOMENUS
#define NOMETAFILE
#define NOOPENFILE
#define NOPEN
#define NORASTEROPS
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOSHOWWINDOW
#define NOSOUND
#define NOSYSCOMMANDS
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NOWINSTYLES
#define NOWNDCLASS
#include <windows.h>

#define NOIDISAVEPRINT
#include "mw.h"
#include "dlgdefs.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "str.h"
#define NOKCCODES
#include "ch.h"
#include "editdefs.h"
#include "propdefs.h"
#include "filedefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "fkpdefs.h"
#include "fmtdefs.h"

#if defined(JAPAN) || defined(KOREA) //T-HIROYN Win3.1
#include "kanji.h"
extern int             vcchFetch;
#endif


#ifdef INEFFLOCKDOWN
extern FARPROC lpDialogFind;
extern FARPROC lpDialogChange;
#else
FARPROC lpDialogFind = NULL;
FARPROC lpDialogChange = NULL;
BOOL far PASCAL DialogFind(HWND, unsigned, WORD, LONG);
BOOL far PASCAL DialogChange(HWND, unsigned, WORD, LONG);
#endif

extern HANDLE hMmwModInstance;
extern HWND   vhDlgFind;
extern HWND   vhDlgChange;
extern HANDLE hParentWw;        /* Handle to the parent window */
extern int vfCursorVisible;
extern int vfOutOfMemory;
extern struct WWD rgwwd[];
extern int       wwMac;
#ifdef ENABLE /* no pDialogCur and ActiveWindow */
extern WINDOWPTR windowSearch;
extern WINDOWPTR windowRep;
extern WINDOWPTR pDialogCur;
extern WINDOWPTR ActiveWindow;
extern int       cxEditScroll;/* not sure how cxEditScroll is used */
extern struct SEL      selSearch;
#endif
extern struct FKPD      vfkpdParaIns;
extern struct PAP       *vppapNormal;
extern typeFC           fcMacPapIns;
extern int              wwCur;
extern struct  WWD      *pwwdCur;
extern struct  CHP      vchpInsert;
extern struct  PAP      vpapPrevIns;
extern int              vfSelecting;
extern typeCP           cpMacCur;
extern typeCP           cpMinCur;
extern int              vfSeeSel;
extern int              vfSeeEdgeSel;
extern int              docCur;
extern struct SEL       selCur;
extern typeCP           vcpFetch;
extern int              vccpFetch;
extern CHAR             *vpchFetch;
extern struct UAB       vuab;
extern int              vfSysFull;
extern struct PAP       vpapAbs;
extern struct CHP       vchpFetch;
extern int              ferror;
extern typeCP           cpWall;
/* Globals used to store settings of flags.  Used to propose responses. */
extern BOOL fParaReplace /* = false initially */;
extern BOOL fReplConfirm /* = TRUE initially */;
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
extern BOOL fSearchDist  /* = true initially */;
#endif
extern BOOL fSearchWord /* = false initially */;
extern BOOL fSearchCase /* = false initially */;
extern BOOL fSpecialMatch;
extern BOOL fMatchedWhite /* = false initially */;
extern CHAR (**hszSearch)[];    /* Default search string */
extern CHAR (**hszReplace)[];    /* Default replace string */
extern CHAR (**hszFlatSearch)[]; /* All lower case version of search string */
extern CHAR (**hszRealReplace)[]; /* used for building replacement text */
extern CHAR (**hszCaseReplace)[]; /* used for building replacement text with
                                appropriate capitalization. */
extern typeCP    cpMatchLim;
extern int       vfDidSearch;
extern CHAR      *szSearch;
extern CHAR      (**HszCreate())[];
extern HWND      vhWndMsgBoxParent;
extern HCURSOR   vhcIBeam;
extern HCURSOR   vhcArrow;
#ifdef INTL
extern CHAR  szAppName[];
extern CHAR  szSepName[];
#endif
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
char    DistSearchString[513];
#endif


NEAR DoSearch(void);
NEAR DoReplace(int, int);
typeCP NEAR CpSearchSz(typeCP, typeCP, CHAR *);
NEAR FMakeFlat(int);
NEAR SetSpecialMatch(void);
NEAR FSetParaReplace(int);
NEAR WCaseCp(typeCP, typeCP);
NEAR SetChangeString(HANDLE, int);
NEAR PutCpInWwVertSrch(typeCP);
#ifndef NOLA
BOOL (NEAR FAbort(void));
#endif
BOOL (NEAR FWordCp(typeCP, typeCP));
BOOL (NEAR FChMatch(int, int *, BOOL));
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
BOOL (NEAR J_FChMatch(CHAR, CHAR, int *,int *));
#endif
NEAR InsertPapsForReplace(typeFC);
NEAR DestroyModeless(HWND *);
NEAR FDlgSzTooLong(HWND, int, CHAR *, int);
NEAR idiMsgResponse(HWND, int, int);

BOOL CheckEnableButton(HANDLE, HANDLE);

BOOL bInSearchReplace = FALSE;  // avoid close when we are searching!


#define CmdReplace(fThenFind)   bInSearchReplace = TRUE; \
                DoReplace(false, fThenFind); \
                bInSearchReplace = FALSE

#define CmdReplaceAll()     bInSearchReplace = TRUE; \
                DoReplace(true, false);  \
                bInSearchReplace = FALSE
#ifndef NOLA
static int fAbortSearch = FALSE;
#endif
static int      fChangeSel;
static int      fSelSave = FALSE;
static struct SEL selSave;

#ifdef DBCS
/* Additional variables to handle white-space matching
   for the DBCS space. */

static int      cbLastMatch;

/* Since CpFirstSty(, styChar) calls on FetchCp(), any assumption
   made about the validity of global variables set by FetchCp()
   is no longer valid.  We explicitly save those variables after
   each FetchCp and use those instead. (Used in CpSearchSz().)*/
static typeCP   cpFetchSave;
static int      ccpFetchSave;
static CHAR    *pchFetchSave;

/* Also, we move some of the local variables out from
   CpSearchSz() so that they can be changed by FChMatch(). */
/*
int             ichDoc;
int             cchMatched;
typeCP          cpFetchNext;
*/
#endif


NEAR DoSearch()
{
int cch;
typeCP cpSearch;
typeCP cpSearchLim;
typeCP cpSearchNext;
typeCP cpWallActual;
typeCP cpMatchFirst;
typeCP CpMin();
int     idpmt;
int     fDidSearch;

if (docCur == docNil)
        return;
cch = CchSz(**hszSearch)-1;
if(cch == 0)
    {
    /* this should only occur if the user execute Repeat last find without having
        previously defined a search string. */
    Error(IDPMTNotFound);
    return;
    }

SetSpecialMatch();
if(!FMakeFlat(cch))
    return;

#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
if(!fSpecialMatch && !fSearchDist)
{
    myHantoZen(**hszFlatSearch,DistSearchString,513);
    cch = CchSz(DistSearchString)-1;
}
#endif
fDidSearch = vfDidSearch;
cpWallActual = fDidSearch ? CpMin(cpWall, cpMacCur) : cpMacCur;
cpSearchNext = fDidSearch ? selCur.cpLim : selCur.cpFirst;
cpSearchLim = (cpSearchNext <= cpWallActual) ? cpWallActual : cpMacCur;

    {
    do
        {
ContinueSearch:
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
        if(!fSpecialMatch && !fSearchDist)
            cpSearch = CpSearchSz(cpSearchNext,cpSearchLim,DistSearchString);
        else
            cpSearch = CpSearchSz(cpSearchNext,cpSearchLim,**hszFlatSearch);
#else
        cpSearch=CpSearchSz(cpSearchNext,cpSearchLim,**hszFlatSearch);
#endif
        if (cpSearch == cpNil)
                {
#ifndef NOLA
                if (fAbortSearch)
                    {
                    Error(IDPMTCancelSearch);
                    fAbortSearch = FALSE;
                    vfDidSearch = FALSE;
                    FreeH(hszFlatSearch);
                    return;
                    }
#endif
                if (cpSearchLim == cpWall && fDidSearch)

                        {
SearchFail:             Error(vfDidSearch ? IDPMTSearchDone :
                                                                IDPMTNotFound);
                        if (vfDidSearch)  /* did we previously have a match?*/
                                { /* Yes, do setup for next pass */

                                /* clear flag so we can search some more */
                                vfDidSearch = false;
                                /* set "Wall" to immediately after last match */
                                cpWall = selCur.cpLim;
                                /* ask that selection be displayed */
                                vfSeeSel = vfSeeEdgeSel = TRUE;
                                }

                        FreeH(hszFlatSearch);
                        return;
                        }
                else
                        {
                        cpSearchNext = cpMinCur;
                        cpSearchLim = cpWall;
                        fDidSearch = true;
                        goto ContinueSearch;
                        }
                }
#ifdef  DBCS        /* was in JAPAN */
        cpSearchNext = CpLastStyChar( cpSearch ) + 1;
#else
        cpSearchNext = CpLastStyChar( cpSearch + 1 );
#endif
        }
/*---    while (fSearchWord && !FWordCp(cpSearch, cpMatchLim-cpSearch));--*/
    while (!FCpValid(cpSearch, cpMatchLim - cpSearch));
    }

if (!vfDidSearch)
        {
        cpWall = cpSearch;
        vfDidSearch = true;
        }

/*Select( CpFirstSty( cpSearch, styChar ), CpLastStyChar( cpMatchLim ) );*/
if ( (cpMatchFirst = CpFirstSty( cpSearch, styChar )) != cpMatchLim )
    Select( cpMatchFirst, cpMatchLim );
PutCpInWwVertSrch(selCur.cpFirst);
vfSeeSel = vfSeeEdgeSel = TRUE;
FreeH(hszFlatSearch);
}


NEAR DoReplace(fReplaceAll, fThenFind)
int     fReplaceAll;
int     fThenFind;
{
/* Replace now works as follows:
        if the current selection is the search text, then replace it with
        the replace text and jump to the next occurrence of the search text.
        Otherwise, just jump to the next occurrence of the search text.
        If fReplaceAll is true, then repeat this operation until the end
        of the document. */
int cch;
typeCP cpSearchStart;
typeCP cpSearch;
typeCP cpSearchNext;
typeCP cpSearchLim;
typeCP cpSearchNow;
typeCP cpSearchLimNow;
typeCP dcp;
BOOL f1CharSel;
BOOL fFirstTime;
int ich;
int cchReplace;
int cwReplace;
int iCurCase;
int iLastCase;
typeFC fcCaseSz;
typeCP cpMacTextT;
typeCP cpWallActual;
int     fDidSearch = vfDidSearch;
struct CHP chp;
typeCP cpMacSave;

iLastCase = -1;  /* indicate that the string pointed to by hszCaseReplace
                    has not been given a value yet. */

if (!FWriteOk(fwcNil) || docCur == docNil)
        /* Out of memory, read only document, etc */
    return;

cch = CchSz(**hszSearch)-1;
if(cch == 0)
    {
    Error(IDPMTNotFound);
    return;
    }

SetSpecialMatch();

if(!FMakeFlat(cch))
    return;

#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
if(!fSpecialMatch && !fSearchDist)
{
    myHantoZen(**hszFlatSearch,DistSearchString,513);
    cch = CchSz(DistSearchString)-1;
}
#endif
cwReplace = CwFromCch(cchReplace = CchSz(**hszReplace));
if(FNoHeap(hszRealReplace = (CHAR (**) [])HAllocate(cwReplace)))
    {
    FreeH(hszFlatSearch);
    return;
    }
bltbyte(**hszReplace, **hszRealReplace, cchReplace);

if(FNoHeap(hszCaseReplace = (CHAR (**) [])HAllocate(cwReplace)))
    {
    FreeH(hszFlatSearch);
    FreeH(hszRealReplace);
    return;
    }

if(!FSetParaReplace(cchReplace))
    {
    FreeH(hszFlatSearch);
    FreeH(hszCaseReplace);
    FreeH(hszRealReplace);
    return;
    }

cch = CchSz(**hszRealReplace)-1;
fFirstTime = TRUE;
cpWallActual = fDidSearch ? CpMin(cpWall, cpMacCur) : cpMacCur;

cpSearchNow = cpSearchStart = selCur.cpFirst;
if (fReplaceAll || !fThenFind)
        cpSearchLim = selCur.cpLim;
else
        cpSearchLim = (cpSearchStart < cpWallActual) ? cpWallActual : cpMacCur;
cpSearchLimNow = selCur.cpLim;

if (fReplaceAll)
        {
        cpWallActual = cpSearchLim;
        fDidSearch = true;
        }

NoUndo();   /* Prevent the SetUndo from getting merged with adjacent stuff */
cpMacTextT = CpMacText(docCur);
if(cpSearchLimNow > cpMacTextT)
        SetUndo(uacDelNS, docCur, cp0, cpMacTextT, docNil, cpNil, cp0, 0);
else
        SetUndo(uacDelNS, docCur, cpSearchStart, cpSearchLimNow - cpSearchStart,
                                        docNil, cpNil, cp0, 0);

if (ferror) goto MemoryError;
cpSearchNext = cpSearchStart;
    {
    do
        {
/*      ForcePmt(IDPMTSearching);*/
        do
            {
ContinueSearch:
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
            if(!fSpecialMatch && !fSearchDist)
                cpSearch = CpSearchSz(cpSearchNext,cpSearchLim,DistSearchString);
            else
                cpSearch = CpSearchSz(cpSearchNext,cpSearchLim,**hszFlatSearch);
#else
            cpSearch = CpSearchSz(cpSearchNext,cpSearchLim,**hszFlatSearch);
#endif
            if (cpSearch == cpNil)
                if ((cpSearchLim == cpWallActual && fDidSearch) || fAbortSearch)

DoneReplacingN:
                        {
DoneReplacingP:
                        FreeH(hszFlatSearch);
                        FreeH(hszCaseReplace);
                        FreeH(hszRealReplace);
                        cpMacTextT = CpMacText(docCur);
                        if (fReplaceAll || fFirstTime)
                                {
                                if(cpSearchLimNow > cpMacTextT)
                                        SetUndo(uacInsert,docCur,cp0,
                                                cpMacTextT,docNil,cpNil,cp0,0);
                                else
                                        SetUndo(uacInsert,docCur,cpSearchStart,
                                                cpSearchLimNow - cpSearchStart,
                                                docNil,cpNil,cp0,0);
                                if (ferror) goto MemoryError;
                                vuab.uac = uacReplGlobal;
                                SetUndoMenuStr(IDSTRUndoBase);
                                /*Select( CpFirstSty( cpSearchStart, styChar ),
                                        CpLastStyChar( cpSearchLimNow ) );*/
                                Select( CpFirstSty( cpSearchStart, styChar ),
                                  (fReplaceAll ? cpSearchStart : cpSearchLimNow) );
                                vfSeeSel = fReplaceAll;
                                if (fReplaceAll)
                                    { /* reestablish the search after a changeall in case of a F3 next time */
                                    vfDidSearch = false;
                                    cpWall = selCur.cpLim;
                                    }
                                }
                        else if (!fReplaceAll)
                                {
                                if (cpSearch == cpNil)
                                    /*Select( CpFirstSty( cpSearchStart, styChar ),
                                            CpLastStyChar( cpSearchLimNow ) );*/
                                    Select( CpFirstSty( cpSearchStart, styChar ),
                                            cpSearchLimNow );
                                else if (!fFirstTime)
                                    /*Select( CpFirstSty( cpSearch, styChar ),
                                            CpLastStyChar( cpMatchLim ) );*/
                                    Select( CpFirstSty( cpSearch, styChar ),
                                            cpMatchLim );
                                PutCpInWwVertSrch(selCur.cpFirst);
                                vfSeeSel = vfSeeEdgeSel = TRUE;
                                }

                        if (fAbortSearch)
                            {
                            fAbortSearch = FALSE;
                            Error(IDPMTCancelSearch);
                            }
                        else if (fFirstTime)
                            Error(fReplaceAll ? IDPMTNoReplace : (vfDidSearch ? IDPMTSearchDone : IDPMTNotFound));
                        return;
                        }
                else
                        {
                        cpSearchNext = cpMinCur;
                        cpSearchLim = cpWallActual;
                        fDidSearch = true;
                        goto ContinueSearch;
                        }
#ifdef  DBCS        /* was in JAPAN */
            cpSearchNext = CpLastStyChar( cpSearch ) + 1;
#else
            cpSearchNext = CpLastStyChar( cpSearch + 1 );
#endif
            }
/*      while(fSearchWord && !FWordCp(cpSearch,cpMatchLim - cpSearch));*/
        while(!FCpValid(cpSearch, cpMatchLim - cpSearch));

        if (!fReplaceAll && (cpSearch != cpSearchNow || cpMatchLim != cpSearchLimNow))
                {
                if (fThenFind)
                        { /* Get here if: Did a Change, then Find. Could not
                                do the change, but did find a next occurence */
                        cpSearchNow = cpSearchNext = cpSearchStart = cpSearch;
                        cpSearchLimNow = cpMatchLim;
                        fFirstTime = false;     /* suppress error message */
                        SetUndo(uacInsert, docCur, cpSearchStart,
                         cpSearchLimNow - cpSearchStart, docNil, cpNil, cp0, 0);
                        if (ferror) goto MemoryError;
                        if (!vfDidSearch)
                                {
                                cpWall = cpSearch;
                                vfDidSearch = true;
                                }
/*----                  continue;----*/
                        goto DoneReplacingN;
                        }
                fFirstTime = true; /* Cause error message */
                cpSearchStart = cpSearchNow;
                cpSearchLim = cpSearchLimNow;
                goto DoneReplacingN;
                }

/*----- vfDidSearch = true;----*/

#ifdef FOOTNOTES
        if(FEditFtn(cpSearch, cpMatchLim))
            {
            ferror = false; /* Reset error condition so that we don't
                                deallocate strings twice (KJS) */
            continue;
            }
#endif

        fFirstTime = FALSE;
        if (vfOutOfMemory || vfSysFull)
            { /* Out of memory (heap or disk) */
            Error(IDPMTNoMemory);
            FreeH(hszFlatSearch);
            FreeH(hszRealReplace);
            FreeH(hszCaseReplace);
            cpMacTextT = CpMacText(docCur);
            if(cpSearchLim > cpMacTextT)
                SetUndo(uacInsert,docCur,cp0,cpMacTextT,docNil,cpNil,cp0,0);
            else
                SetUndo(uacInsert,docCur,cpSearchStart,
                        cpSearchLimNow - cpSearchStart,docNil,cpNil,cp0,0);
            if (ferror)
                NoUndo();
            else
                vuab.uac = uacReplGlobal;
            return;
            }
        FetchCp(docCur, cpSearch, 0, fcmProps); /* Get props of first char
                                                that we are replacing */
        blt(&vchpFetch, &chp, cwCHP);
        chp.fSpecial = false;

        iCurCase = 0; /* assume that the replacement string doesn't
                         require special capitalization */

        /* if we're not matching upper/lower case call WCaseCp to determine
            the capitalization pattern of the matched string */
        if (!fSearchCase)
            iCurCase = WCaseCp(cpSearch, cpMatchLim - cpSearch);

        /* if the new capitalization pattern of the matched string
           doesn't match the current contents of hszCaseReplace,
           copy the replacement string to hszCaseReplace and transform
           hszCaseReplace to conform to the new pattern */
        if (iCurCase != iLastCase)
            switch (iCurCase)
                {
                default:
                case 0:   /* no special capitalization required */
                    bltbyte(**hszRealReplace, **hszCaseReplace, cch+1);
                    break;
                case 1:  /* first character of string must be capitalized */
                    bltbyte(**hszRealReplace, **hszCaseReplace, cch+1);
                    ***hszCaseReplace = ChUpper(***hszRealReplace);
                    break;
                case 2:  /* all characters must be capitalized */
#ifdef DBCS //t-Yoshio
                    for (ich = 0; ich < cch;) {
            if(!IsDbcsLeadByte((BYTE)(**hszRealReplace)[ich])) {
                        (**hszCaseReplace)[ich] =
                            ChUpper((**hszRealReplace)[ich]);
                ich++;
            }
            else {
                        (**hszCaseReplace)[ich] = (**hszRealReplace)[ich];
                        (**hszCaseReplace)[ich+1] = (**hszRealReplace)[ich+1];                          ich+=2;
            }
            }
#else
                    for (ich = 0; ich < cch;ich++)
                        (**hszCaseReplace)[ich] = ChUpper((**hszRealReplace)[ich]);
#endif
                    break;
                }

        /* do CachePara to find the current para props. CachePara has the
           side effect of setting vpapAbs     */
        CachePara(docCur, cpSearch);

        /* if the capitalization pattern has changed OR
              the character properties of the replacement text don't match
                 those of the last insert        OR
              the  paragraph properties of the replacement text don't match
                 those of the last insert, THEN

              1) call NewChpIns to write a run describing the character
                 properties of the previous insertion text,
              2) call FcWScratch to write the characters of the replacement
                 string to the scratch file,
              3) if we are replacing paragraph marks, call InsertPapsForReplace
                 to write runs describing each paragraph in the replacement
                 string */
        if (iCurCase != iLastCase ||
            CchDiffer(&vchpInsert,&chp,cchCHP) != 0 ||
            (fParaReplace && CchDiffer(&vpapPrevIns, &vpapAbs, cchPAP) != 0))
                {
                NewChpIns(&chp);
                fcCaseSz = FcWScratch(**hszCaseReplace,cch);
                if (fParaReplace)
                        InsertPapsForReplace(fcCaseSz);
                }

        /* Now since we have written the proper replacement text to
           the scratch file and have setup the character and paragraph runs to
           describe that text, simply do a replace to insert the replacement
           text into the piece table */
        Replace(docCur, cpSearch, cp0, fnScratch, fcCaseSz, (typeFC) cch);
        if (ferror) goto MemoryError;

#ifdef JAPAN //T-HIROYN Win3.1
/* When we replace from ANSI CharSet string to SHIFTJIS CharSet String
   We needs follows */
        {
            struct CHP savechpT;
            typeCP  cpF, cpFirst, cpLim, kcpF, kcpL;
            int     cchF;
            int     kanjiftc;
            CHAR    *rp;
            CHAR    ch, bSet;
            int     cchS, cblen;
            CHAR    rgch[ cchCHP +  1 ];

            rgch [0] = sprmCSame;

            if(NATIVE_CHARSET != GetCharSetFromChp(&chp)) {
                kanjiftc = GetKanjiFtc(&chp);
                savechpT = chp;
                cpFirst = cpSearch;

                do {
                    FetchCp(docCur, cpFirst, 0, fcmChars);
                    cpF = vcpFetch;
                    cchF = vcchFetch;
                    rp = vpchFetch;

                    if ((cpF+cchF) < cpSearch + cch)
                        cpLim = (cpF+cchF);
                    else
                        cpLim = cpSearch + cch;

                    cpFirst = kcpL;

                    cchS = 0;
                    kcpF = cpF;

                    while ( kcpF < cpLim ) {
                        ch = *rp;

                        bSet = FALSE;
                        if( FKana(ch) || IsDBCSLeadByte(ch) ) {
                            cblen = GetKanjiStringLen(cchS, cchF, rp);
                            bSet = TRUE;
                        } else {
                            cblen = GetAlphaStringLen(cchS, cchF, rp);
                        }

                        kcpL = kcpF + cblen;
                        cchS += cblen;
                        rp  += cblen;

                        if(bSet) {
							SetFtcToPchp(&chp, kanjiftc);
                            bltbyte( &chp,      &rgch [1], cchCHP );
                            AddSprmCps(rgch, docCur, kcpF, kcpL);
                        }
                        kcpF = kcpL;
                    }
					cpFirst = kcpF;
					
                } while ((cpF + cchF) < cpSearch + cch );
                chp = savechpT;
            }
        } // END JAPAN
#endif


        iLastCase = iCurCase; /* record new capitalization pattern */

        /* Now delete the found text from the piece table*/

        cpMacSave = cpMacCur;
        Replace(docCur, cpSearch+cch, cpMatchLim - cpSearch, fnNil, fc0, fc0);
        dcp = cpMacSave - cpMacCur; /* Calculate dcp here because picture
                        paragraphs may have interfered with deleting */
        if (ferror) goto MemoryError;
        if (!fReplaceAll)
                {
                SetUndo(uacInsert, docCur, cpSearch, (typeCP) cch,
                                                        docNil, cpNil, cp0, 0);
                if (ferror) goto MemoryError;
                SetUndoMenuStr(IDSTRUndoBase);
                }
        cpSearchLim += cch - dcp;
        cpMatchLim += cch - dcp;
        cpWallActual += cch - dcp;
#ifdef  DBCS                /* was in JAPAN */
        cpSearchNext = cpMatchLim;
#else
        cpSearchNext = CpLastStyChar( cpMatchLim );
#endif
        if (fReplaceAll)
                cpSearchLimNow = cpSearchLim;
        }
    while (fReplaceAll);
    }
if (fThenFind)
        {
        do
                {
ContinueSearch2:
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
                if(!fSpecialMatch && !fSearchDist)
                    cpSearch = CpSearchSz(cpSearchNext,cpSearchLim,DistSearchString);
                else
                    cpSearch = CpSearchSz(cpSearchNext,cpSearchLim,**hszFlatSearch);
                if(cpSearch == cpNil)
#else
                if ((cpSearch = CpSearchSz(cpSearchNext, cpSearchLim,
                                        **hszFlatSearch)) == cpNil)
#endif
                        {
                        if ((cpSearchLim == cpWallActual && fDidSearch) ||
                            fAbortSearch)
                                {
                                fFirstTime = false; /* Supress error message */
                                /*Select( CpFirstSty( cpSearchStart, styChar ),
                                        CpLastStyChar( cpMatchLim ) );*/
                                Select( CpFirstSty( cpSearchStart, styChar ),
                                        cpMatchLim );
                                PutCpInWwVertSrch(selCur.cpFirst);
                                cpSearchLimNow = cpMatchLim;
                                Error(fAbortSearch ?
                                      IDPMTCancelSearch : IDPMTSearchDone);
                                fAbortSearch = FALSE;
                                vfDidSearch = false;
                                cpWall = selCur.cpLim;
                                goto DoneReplacingP;
                                }
                        else
                                {
                                cpSearchNext = cpMinCur;
                                cpSearchLim = cpWallActual;
                                fDidSearch = true;
                                goto ContinueSearch2;
                                }
                        }
#ifdef  DBCS                    /* was in JAPAN */
                cpSearchNext = CpLastStyChar( cpSearch ) + 1;
#else
                cpSearchNext = CpLastStyChar( cpSearch + 1 );
#endif
                }
/*--    while(fSearchWord && !FWordCp(cpSearch,cpMatchLim - cpSearch));*/
        while(!FCpValid(cpSearch, cpMatchLim - cpSearch));
        if (!vfDidSearch)
                {
                cpWall = cpSearch;
                vfDidSearch = true;
                }
        }
goto DoneReplacingP;

MemoryError:
    FreeH(hszFlatSearch);
    FreeH(hszCaseReplace);
    FreeH(hszRealReplace);
    NoUndo();

    /* counter off the losing insertion point after incomplete change all */
    if (fReplaceAll && fSelSave)
        {
        selCur.cpFirst = selSave.cpFirst;
        selCur.cpLim = selSave.cpLim;
        }
}
#ifdef  DBCS
BOOL fDBCS = FALSE;
#endif

typeCP NEAR CpSearchSz(cpFirst, cpMacSearch, sz)
typeCP cpFirst;
typeCP cpMacSearch;
CHAR *sz;
{{     /* Finds first occurrence of sz in docCur starting at cpFirst */
      /* Returns cpNil if not found */
      /* Ignore case of letters if fSearchCase is FALSE.  This assumes that the
        pattern has already been folded to lower case. */

    CHAR ch;
    BOOL fMatched;
    int ichPat = 0;
    int     ichDoc = 0;
    int cchMatched = 0;
    typeCP cpFetchNext;
    /*EVENT event;*/

#ifdef DBCS
    typeCP cpFound;
    CHAR   rgchT[dcpAvgSent];
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
    CHAR chNext;
    CHAR dch[3];
#endif
#endif


    szSearch = sz;
#ifdef DBCS
    /* Initialize those local variables moved out from this
       function. */
    ichDoc = 0;
    cchMatched = 0;
    pchFetchSave = &rgchT[0];

    cbLastMatch = 1;

#endif


#ifdef DBCS
    FetchCp(docCur, cpFirst, 0, fcmChars + fcmNoExpand);
    cpFetchSave  = vcpFetch;
#ifdef JAPAN //raid 4709 bug fix
    bltbyte(vpchFetch, rgchT, ccpFetchSave =
	 ((vccpFetch > (dcpAvgSent-2)) ? (dcpAvgSent-2) : vccpFetch));

	{
        int inc;
		BOOL bDBCSBreak = FALSE;
		typeCP	saveVcpFetch;
        for(inc = 0;inc < ccpFetchSave;inc++) {
        	if(IsDBCSLeadByte((BYTE)rgchT[inc])) {
				inc++;
				if(inc >= ccpFetchSave) {
					bDBCSBreak = TRUE;
					break;
				}
			}
        }
		if(bDBCSBreak) {
			saveVcpFetch = vcpFetch;
            FetchCp(docCur, cpFetchSave + ccpFetchSave,
			 0, fcmChars + fcmNoExpand);
		    bltbyte(vpchFetch, rgchT+ccpFetchSave,1);
	        ccpFetchSave++;
			vcpFetch = saveVcpFetch;
		}
    }
#else //JAPAN
    bltbyte(vpchFetch, rgchT,
            ccpFetchSave = ((vccpFetch > dcpAvgSent) ? dcpAvgSent : vccpFetch));
    if (vccpFetch > dcpAvgSent) {
        int inc;
        fDBCS = 0;
        for(inc = 0;inc < dcpAvgSent;inc++) {
            if(fDBCS)
                fDBCS = 0;
            else
                fDBCS = IsDBCSLeadByte((BYTE)rgchT[inc]);
        }
        if(fDBCS)
            ccpFetchSave--;
        fDBCS = 0;
    }
#endif //JAPAN
    Assert(cpFetchSave == cpFirst);

    cpFetchNext = cpFetchSave + ccpFetchSave;
#else //DBCS
    FetchCp(docCur, cpFirst, 0, fcmChars + fcmNoExpand);
    Assert(vcpFetch == cpFirst);

    cpFetchNext = vcpFetch + vccpFetch;
#endif //DBCS

    fMatchedWhite = false;

    for (; ;)
        {
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
cbLastMatch = 1;
#endif
        if (szSearch[ichPat] == '\0' )
            {{ /* Found it */
#ifdef DBCS
            typeCP cpFound;
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
            if(IsDBCSLeadByte((BYTE)ch))
                cpMatchLim = vcpFetch+ichDoc - (fMatchedWhite ? 2 : 0);
            else
                cpMatchLim = vcpFetch+ichDoc - (fMatchedWhite ? 1 : 0);
#else
            cpMatchLim = vcpFetch+ichDoc - (fMatchedWhite ? 1 : 0);
#endif
            cpFound = cpFetchSave + ichDoc - cchMatched;
            if (CpFirstSty(cpFound, styChar) == cpFound) {
                /* It is on a Kanji boundary.  We really found it. */
                return (cpFound);
                }
            else {
                /* The last character did not match, try again
                   excluding the last byte match. */
                cchMatched -= cbLastMatch;
                cbLastMatch = 1;

                fMatchedWhite = false;
                goto lblNextMatch;
                }
#else
            cpMatchLim = vcpFetch+ichDoc - (fMatchedWhite ? 1 : 0);

            return vcpFetch + ichDoc - cchMatched;
#endif
            }}

#ifdef DBCS
    if (cpFetchSave + ichDoc >= cpMacSearch)
#else
    if (vcpFetch + ichDoc >= cpMacSearch)
#endif
            {{ /* Not found */
            if(fMatchedWhite && szSearch[ichPat+2] == '\0')
                { /* Found it */
#ifdef DBCS
                cpMatchLim = cpFetchSave + ichDoc;
                cpFound = cpFetchSave + ichDoc - cchMatched;
                if (CpFirstSty(cpFound, styChar) == cpFound) {
                    /* It is on a Kanji boundary, We really found it. */
                    return (cpFound);
                    }
                else {
                    /* The last character did not match, try again
                       excluding the last byte match. */
                    cchMatched -= cbLastMatch;
                    cbLastMatch = 1;

                    fMatchedWhite = false;
                    goto lblNextMatch;
                    }
#else
                cpMatchLim = vcpFetch+ichDoc;
                return vcpFetch + ichDoc - cchMatched;
#endif
                }
            else
                return cpNil;
            }}

#if defined(DBCS)
        if (ichDoc + cbLastMatch - 1 >= ccpFetchSave)
#else
        if (ichDoc >= vccpFetch)
#endif
            { /* Need more cp's */
            {{
#ifndef NOLA /* no look ahead */
/* check if abort search */
                if (FAbort())
                        {
                        fAbortSearch = TRUE;
                        return cpNil;
                        }
#endif /* NOLA */

/*            FetchCp(docNil, cpNil, 0, fcmChars + fcmNoExpand); */
/* we changed from a sequential fetch to a random fetch because a resize of the
window may cause another FetchCp before we reach here */
#ifdef DBCS
            FetchCp(docCur, cpFetchNext, 0, fcmChars + fcmNoExpand);
            cpFetchSave  = vcpFetch;

#ifdef JAPAN //raid 4709 bug fix
		    bltbyte(vpchFetch, rgchT, ccpFetchSave =
			 ((vccpFetch > (dcpAvgSent-2)) ? (dcpAvgSent-2) : vccpFetch));

			{
        		int inc;
				BOOL bDBCSBreak = FALSE;
				typeCP	saveVcpFetch;
		        for(inc = 0;inc < ccpFetchSave;inc++) {
        			if(IsDBCSLeadByte((BYTE)rgchT[inc])) {
						inc++;
						if(inc >= ccpFetchSave) {
							bDBCSBreak = TRUE;
							break;
						}
					}
		        }
				if(bDBCSBreak) {
					saveVcpFetch = vcpFetch;
        		    FetchCp(docCur, cpFetchSave + ccpFetchSave,
					 0, fcmChars + fcmNoExpand);
				    bltbyte(vpchFetch, rgchT+ccpFetchSave,1);
			        ccpFetchSave++;
					vcpFetch = saveVcpFetch;
				}
		    }
#else //JAPAN
            bltbyte(vpchFetch, rgchT,
                    ccpFetchSave = ((vccpFetch > dcpAvgSent) ?
                                      dcpAvgSent : vccpFetch));

            if (vccpFetch > dcpAvgSent) {
                int inc;
                fDBCS = 0;
                for(inc = 0;inc < dcpAvgSent;inc++) {
                    if(fDBCS)
                        fDBCS = 0;
                    else
                        fDBCS = IsDBCSLeadByte((BYTE)rgchT[inc]);
                }
                if(fDBCS)
                    ccpFetchSave--;
                fDBCS = 0;
            }
#endif //JAPAN
            cpFetchNext = cpFetchSave + ccpFetchSave;
#else //DBCS
            FetchCp(docCur, cpFetchNext, 0, fcmChars + fcmNoExpand);
            cpFetchNext = vcpFetch + vccpFetch;
#endif //DBCS
            ichDoc = 0;
            }}
            continue;
            }

#ifdef DBCS
        ch = pchFetchSave[ichDoc++];
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
        if(IsDBCSLeadByte((BYTE)ch))
        {
            chNext = pchFetchSave[ichDoc++];
            cbLastMatch = 2;
        }
        else
        {
            chNext = pchFetchSave[ichDoc];
            cbLastMatch = 1;
        }
#else
        cbLastMatch = 1;
#endif /*JAPAN*/
#else
        ch = vpchFetch[ichDoc++];
#endif
        if(!fSpecialMatch)
            {
            /* NOTE: this is just ChLower() brought in-line for speed */
#ifdef DBCS
            if( fDBCS )
#if defined(KOREA)
                {
                    if(!fSearchCase)
                        if(ch >= 'A' && ch <= 'Z') ch += 'a' - 'A';
                        else if (ch == 0xA3 && (chNext >= 0xC1 && chNext <= 0xDA))
                            chNext = 0x20 + chNext;
                    fDBCS = FALSE;
                }
#else
                fDBCS = FALSE;
#endif
             else
                if(!fSearchCase)
#if defined(TAIWAN) || defined(PRC) 
          if ( !(  fDBCS = IsDBCSLeadByte( ch )))
#endif
                    { /* avoid proc call for common cases */
                    if(ch >= 'A' && ch <= 'Z') ch += 'a' - 'A';
#ifdef JAPAN /*t-Yoshio*/
                    if(ch == 0x82 && (chNext >= 0x60 && chNext <= 0x79))
                        chNext = 0x21 + chNext;
#elif defined(KOREA)
                    else if(ch == 0xA3 && (chNext >= 0xC1 && chNext <= 0xDA))
                        chNext = 0x20 + chNext;
#else
                    else if(ch < 'a' || ch > 'z') ch = ChLower(ch);
#endif
                    }
#else
            if(!fSearchCase)
                { /* avoid proc call for common cases */
                if(ch >= 'A' && ch <= 'Z') ch += 'a' - 'A';
                else if(ch < 'a' || ch > 'z') ch = ChLower(ch);
                }
#endif
#ifdef JAPAN /*t-Yoshio*/
            if(!fSearchDist)
            {
                char han_str[3];
                han_str[0] = ch;han_str[1] = '\0';han_str[2] = '\0';
                if(IsDBCSLeadByte((BYTE)ch))
                {
                    if(szSearch[ichPat] == ch && szSearch[ichPat+1] == chNext)
                    {
                        ichPat+=2;
                        fMatched = true;
                    }
                    else
                        fMatched = false;
                }
                else
                {
                    if(ch >= 0xca && ch <= 0xce)
                    {
                        if(!myIsSonant(szSearch[ichPat],szSearch[ichPat+1]))
                            han_str[1] = '\0';
                        else if(chNext == 0xde || chNext == 0xdf )
                        {
                            han_str[1] = chNext;
                            han_str[2] = '\0';
                            cbLastMatch = 2;
                            ichDoc++;
                        }
                        else
                            han_str[1] = '\0';
                    }
                    else if(ch >= 0xa6 && ch <= 0xc4)
                    {
                        if(!myIsSonant(szSearch[ichPat],szSearch[ichPat+1]))
                            han_str[1] = '\0';
                        else if(chNext == 0xde )
                        {
                            han_str[1] = chNext;
                            han_str[2] = '\0';
                            cbLastMatch = 2;
                            ichDoc++;
                        }
                        else
                            han_str[1] = '\0';

                    }
                    else
                        han_str[1] = '\0';

                    myHantoZen(han_str,dch,3);

                    if(szSearch[ichPat] == dch[0] && szSearch[ichPat+1] == dch[1])
                    {
                        ichPat+=2;
                        fMatched = true;
                    }
                    else if(ch == chReturn || ch == chNRHFile)
                        fMatched = true;
                    else
                        fMatched = false;
                }
            }
            else
            {
                if(IsDBCSLeadByte((BYTE)ch))
                {
                    if(szSearch[ichPat] == ch && szSearch[ichPat+1] == chNext)
                    {
                        ichPat+=2;
                        fMatched = true;
                    }
                    else
                        fMatched = false;
                }
                else if(szSearch[ichPat] == ch)
                {
                    ichPat++;
                    fMatched = true;
                }
                else if(ch == chReturn || ch == chNRHFile)
                    fMatched = true;
                else
                    fMatched = false;
            }
#elif defined(KOREA)
            if(!fSearchDist)
            {
                char han_str[3];
                han_str[0] = ch;han_str[1] = '\0';han_str[2] = '\0';
                if(IsDBCSLeadByte((BYTE)ch))
                {
                    if(szSearch[ichPat] == ch && szSearch[ichPat+1] == chNext)
                    {
                        ichPat+=2;
                        fMatched = true;
                    }
                    else
                        fMatched = false;
                }
                else
                {
                    han_str[1] = '\0';

                    myHantoZen(han_str,dch,3);

                    if(szSearch[ichPat] == dch[0] && szSearch[ichPat+1] == dch[1])
                    {
                        ichPat+=2;
                        fMatched = true;
                    }
                    else if(ch == chReturn || ch == chNRHFile)
                        fMatched = true;
                    else
                        fMatched = false;
                }
            }
            else
            {
                if(IsDBCSLeadByte((BYTE)ch))
                {
                    if(szSearch[ichPat] == ch && szSearch[ichPat+1] == chNext)
                    {
                        ichPat+=2;
                        fMatched = true;
                    }
                    else
                        fMatched = false;
                }
                else if(szSearch[ichPat] == ch)
                {
                    ichPat++;
                    fMatched = true;
                }
                else if(ch == chReturn || ch == chNRHFile)
                    fMatched = true;
                else
                    fMatched = false;
            }
#else

            if(szSearch[ichPat] == ch)
                {
                ichPat++;
                fMatched = true;
                }
            else if(ch == chReturn || ch == chNRHFile)
                fMatched = true;
            else
                fMatched = false;
#endif
            }
        else
        {
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
            fMatched = J_FChMatch(ch,chNext,&ichPat,&ichDoc);
#else
            fMatched = FChMatch(ch, &ichPat, true);
#endif
        }

#ifdef DBCS
//#ifndef JAPAN /*t-Yoshio*/
#if !defined(JAPAN) && !defined(KOREA) /*t-Yoshio*/  
        fDBCS = IsDBCSLeadByte( ch );
#endif
#endif

        if(fMatched)
            {
#if defined(DBCS)
            cchMatched += cbLastMatch;
#else
            cchMatched++;
#endif
            }
        else
            { /* No match; try again */
#ifdef DBCS
lblNextMatch:
#endif
            if ((ichDoc -= cchMatched) < 0) /* Go back # of matched chars */
                {{ /* Overshot the mark */
#ifdef DBCS
                FetchCp(docCur, cpFetchSave + ichDoc, 0, fcmChars + fcmNoExpand);
                cpFetchSave  = vcpFetch;
#ifdef JAPAN //raid 4709 bug fix
			    bltbyte(vpchFetch, rgchT, ccpFetchSave =
				 ((vccpFetch > (dcpAvgSent-2)) ? (dcpAvgSent-2) : vccpFetch));

				{
			        int inc;
					BOOL bDBCSBreak = FALSE;
					typeCP	saveVcpFetch;
			        for(inc = 0;inc < ccpFetchSave;inc++) {
        				if(IsDBCSLeadByte((BYTE)rgchT[inc])) {
							inc++;
							if(inc >= ccpFetchSave) {
								bDBCSBreak = TRUE;
								break;
							}
						}
			        }
					if(bDBCSBreak) {
						saveVcpFetch = vcpFetch;
            			FetchCp(docCur, cpFetchSave + ccpFetchSave,
						 0, fcmChars + fcmNoExpand);
		    			bltbyte(vpchFetch, rgchT+ccpFetchSave,1);
				        ccpFetchSave++;
						vcpFetch = saveVcpFetch;
					}
			    }
#else //JAPAN
                bltbyte(vpchFetch, rgchT,
                        ccpFetchSave = ((vccpFetch > dcpAvgSent) ?
                                          dcpAvgSent : vccpFetch));

                if (vccpFetch > dcpAvgSent) {
                    int inc;
                    fDBCS = 0;
                    for(inc = 0;inc < dcpAvgSent;inc++) {
                        if(fDBCS)
                            fDBCS = 0;
                        else
                            fDBCS = IsDBCSLeadByte((BYTE)rgchT[inc]);
                    }
                    if(fDBCS)
                        ccpFetchSave--;
                    fDBCS = 0;
                }
#endif //JAPAN
                cpFetchNext = cpFetchSave + ccpFetchSave;
#else //DBCS
                FetchCp(docCur, vcpFetch + ichDoc, 0, fcmChars + fcmNoExpand);

/* this is for the next FetchCp in this forever loop that used to depend
on a sequential fetch */
                cpFetchNext = vcpFetch + vccpFetch;
#endif //DBCS
                ichDoc = 0;
                }}
            ichPat = 0;
            cchMatched = 0;
            }
        }
}}


/* set up in hszFlatSearch a copy of hszSearch that is all lower case.
    Note that we assume the old contents of hszFlatSearch were freed.
    Return True if success, False if out of memory.
*/
NEAR FMakeFlat(cch)
int cch; /*CchSz(**hszSearch)-1*/
{
    CHAR *pch1;
    CHAR *pch2;

    hszFlatSearch = (CHAR (**) [])HAllocate(CwFromCch(cch+1));
    if(FNoHeap(hszFlatSearch))
        return(FALSE);

    if(!fSearchCase)
        {
#ifdef DBCS
        for(pch1= **hszSearch, pch2 = **hszFlatSearch;*pch1!='\0';)
            if( IsDBCSLeadByte(*pch1) ) {
#ifdef JAPAN /*t-Yoshio*/
                if(*pch1 == 0x82 && (*(pch1+1) >= 0x60 && *(pch1+1) <= 0x79 ))
                {
                    *pch2++ = *pch1++;
                    *pch2++ = 0x21 + *pch1++;
                }
                else
                {
                    *pch2++ = *pch1++;
                    *pch2++ = *pch1++;
                }
#elif defined(KOREA)
               if(*pch1 == 0xA3 && (*(pch1+1) >= 0xC1 && *(pch1+1) <= 0xDA))
                {
                    *pch2++ = *pch1++;
                    *pch2++ = 0x20 + *pch1++;
                }
                else
                {
                    *pch2++ = *pch1++;
                    *pch2++ = *pch1++;
                }
#else
                *pch2++ = *pch1++;
                *pch2++ = *pch1++;
#endif
            } else
            {
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
                if(*pch1 >= 'A' && *pch1 <= 'Z')
                {
                    *pch2 = *pch1 + 0x20; pch1++; pch2++;
                }
                else
                    *pch2++ = *pch1++;
#else
                *pch2++ = ChLower(*pch1++);
#endif
            }
#else
        for(pch1= **hszSearch, pch2 = **hszFlatSearch;*pch1!='\0';pch1++,pch2++)
            *pch2 = ChLower(*pch1);
#endif
        *pch2 = '\0';
        }
    else
        bltbyte(**hszSearch, **hszFlatSearch, cch+1);
    return(TRUE);
}


/* sets the global fSpecialMatch if the more complicated character matching
    code is needed */
NEAR SetSpecialMatch()
{
    CHAR *pch = **hszSearch;
    CHAR ch;

#ifdef DBCS
    for( ch = *pch ; ch != '\0'; pch = AnsiNext(pch), ch = *pch )
#else
    while((ch = *pch++) != '\0')
#endif
        {
        switch(ch)
            {
            default:
                continue;
            case chMatchAny:
            case chPrefixMatch:
            case chSpace:
            case chHyphen:
                fSpecialMatch = true;
                return;
            }
        }
    fSpecialMatch = false;
    return;
}

/* Sets the global fParaReplace if the user wants to insert Paragraph breaks
    (since special insertion code must be run).  Also sets up the global
    hszRealReplace to reflect any meta characters in hszReplace */
NEAR FSetParaReplace(cch)
int cch; /*CchSz(**hszReplace)*/
{
    CHAR *rgch = **hszRealReplace;
    int ich = 0;
    CHAR ch;
    CHAR chNew;

    fParaReplace = false;

    while((ch = rgch[ich]) != '\0')
        {
#ifdef DBCS
        if(IsDBCSLeadByte(ch)){
            ich +=2;
            continue;
        }
#endif
        switch(ch)
            {
            default:
                break;
            case chPrefixMatch:
                switch(rgch[ich+1])
                    {
                    default:
                        /* just escaping the next char */
                        if(rgch[ich+1] == '\0')
                            chNew = chPrefixMatch;
                        else
                            chNew = rgch[ich+1];
                        break;
                    case chMatchNBSFile:
                        chNew = chNBSFile;
                        break;
                    case chMatchTab:
                        chNew = chTab;
                        break;
                    case chMatchNewLine:
                        chNew = chNewLine;
                        break;
                    case chMatchNRHFile:
                        chNew = chNRHFile;
                        break;
                    case chMatchSect:
                        chNew = chSect;
                        break;
                    case chMatchEol:
                        chNew = chEol;
                        break;
                    }
#ifdef CRLF
                if(chNew != chEol)
                    bltbyte(&(rgch[ich+1]),&(rgch[ich]), cch-ich-1);
#else
                bltbyte(&(rgch[ich+1]),&(rgch[ich]), cch-ich-1);
#endif /*CRLF*/
                if(chNew == chEol)
                    {
                    fParaReplace = true;
#ifdef CRLF
                    rgch[ich++] = chReturn;
#endif /*CRLF*/
                    }
                rgch[ich] = chNew;
                break;
            case chEol:
#ifdef CRLF
                if(ich == 0 || rgch[ich-1] != chReturn)
                    /* they didn't put in a return! */
                    {
                    CHAR (**hsz)[];

                    hsz = (CHAR (**) [])HAllocate(CwFromCch(cch+1));
                    if(FNoHeap(hsz))
                        {
                        return false;
                        }
                    bltbyte(**hszRealReplace, **hsz, ich);
                    (**hsz)[ich] = chReturn;
                    bltbyte((**hszRealReplace)+ich, (**hsz)+ich+1,
                                cch - ich);
                    FreeH(hszRealReplace);
                    hszRealReplace = hsz;
                    rgch = **hszRealReplace;
                    cch++;
                    ich++;
                    }
#endif /*CRLF*/
                fParaReplace = true;
                break;
            }
        ich++;
        }
    return true;
}

NEAR WCaseCp(cp,dcp)
typeCP  cp;
typeCP dcp;
{
    /* Determines capitalization pattern in a piece of text.  Used when doing
        replace to match existing pattern.  returns an int which is one of:
            0 - Not initial capital
            1 - Initial Capital but lower case appears later
            2 - Initial Capital and no lower case in the string
        Assumes a valid cp, dcp pair.
    */
    int ichDoc;

    FetchCp(docCur, cp, 0, fcmChars + fcmNoExpand);
    if(!isupper(vpchFetch[0]))
        return(0);

    /* we now know there is an initial cap.  Are there any lower case chars? */
    for(ichDoc=1; vcpFetch+ichDoc < cp + dcp;)
        {
        if(ichDoc >= vccpFetch)
            {
            FetchCp(docNil, cpNil, 0, fcmChars + fcmNoExpand);
            ichDoc = 0;
            continue;
            }
        if(islower(vpchFetch[ichDoc++]))
            return(1);
        }

    /* No lower case letters were found. */
    return(2);
}

int
FCpValid(cp, dcp)
typeCP cp, dcp;
{
CachePara(docCur, cp);
if (vpapAbs.fGraphics)
        return false;
#ifdef JAPAN  /*t-Yoshio*/
if (0)
#else
if (fSearchWord)
#endif
        return FWordCp(cp, dcp);
return true;
}

NEAR DestroyModeless(phDlg)
HWND * phDlg;
{
        HWND hDlg = *phDlg;

        *phDlg = (HWND)NULL;
        vhWndMsgBoxParent = (HANDLE)NULL;
        DestroyWindow(hDlg);
} /* end of DestroyModeless */


BOOL far PASCAL DialogFind( hDlg, message, wParam, lParam )
HWND    hDlg;                   /* Handle to the dialog box */
unsigned message;
WORD wParam;
LONG lParam;
{
CHAR szBuf[257];
int  cch = 0;
HANDLE hCtlFindNext = GetDlgItem(hDlg, idiFindNext);

/* This routine handles input to the Find dialog box. */
switch (message)
    {
    case WM_INITDIALOG:
#ifdef ENABLE /* not sure how cxEditScroll is used */
        cxEditScroll = 0;
#endif
#ifdef JAPAN /*t-Yoshio*/
        CheckDlgButton(hDlg,  idiDistinguishDandS, fSearchDist);
#elif defined(KOREA)
//bklee CheckDlgButton(hDlg,  idiDistinguishDandS, fSearchDist);
        CheckDlgButton(hDlg,  idiWholeWord, fSearchWord);
#else
        CheckDlgButton(hDlg,  idiWholeWord, fSearchWord);
#endif
        CheckDlgButton(hDlg, idiMatchCase, fSearchCase);
        cch = CchCopySz(**hszSearch, szBuf);
        if (cch == 0)
            {
            EnableWindow(hCtlFindNext, false);
            }
        else
            {
            SetDlgItemText(hDlg, idiFind, (LPSTR)szBuf);
            SelectIdiText(hDlg, idiFind);
            }
        vfDidSearch = false;
        cpWall = selCur.cpLim;
        return( TRUE ); /* ask windows to set focus to the first item also */

    case WM_ACTIVATE:
        if (wParam) /* turns active */
            {
            vhWndMsgBoxParent = hDlg;
            }
        if (vfCursorVisible)
            ShowCursor(wParam);
        return(FALSE); /* so that we leave the activate message to
        the dialog manager to take care of setting the focus correctly */

    case WM_COMMAND:
        switch (wParam)
            {
            case idiFind:
                if (HIWORD(lParam) == EN_CHANGE)
                    {
                    vfDidSearch = false;
                    cpWall = selCur.cpLim;
                    CheckEnableButton(LOWORD(lParam), hCtlFindNext);
                    }
                break;

#ifdef JAPAN /*t-Yoshio*/
            case idiDistinguishDandS :
#elif defined(KOREA)
            case idiDistinguishDandS :
            case idiWholeWord:
#else
            case idiWholeWord:
#endif
            case idiMatchCase:
                CheckDlgButton(hDlg, wParam, !IsDlgButtonChecked(hDlg, wParam));
                break;
            case idiFindNext:
                if (IsWindowEnabled(hCtlFindNext))
                    {
                    CHAR (**hszSearchT)[] ;

                    if (FDlgSzTooLong(hDlg, idiFind, szBuf, 257))
                        {
                        switch (idiMsgResponse(hDlg, idiFind, IDPMTTruncateSz))
                            {
                            case idiOk:
                                /* show truncated text to user */
                                SetDlgItemText(hDlg, idiFind, (LPSTR)szBuf);
                                break;
                            case idiCancel:
                            default:
                                return(TRUE);
                            }
                        }
                    if (FNoHeap(hszSearchT = HszCreate(szBuf)))
                        break;
                    /* fSearchForward = 1; search direction -- always forward */
                    PostStatusInCaption(IDSTRSearching);
                    StartLongOp();
                    FreeH(hszSearch);
                    hszSearch = hszSearchT;
                    fSearchCase = IsDlgButtonChecked(hDlg, idiMatchCase);
#ifdef JAPAN  /*t-Yoshio*/
                    fSearchWord = 0;
                    fSearchDist = IsDlgButtonChecked(hDlg, idiDistinguishDandS);
#elif defined(KOREA)
//bklee             fSearchDist = IsDlgButtonChecked(hDlg, idiDistinguishDandS);
                    fSearchDist = 1;
                    fSearchWord = IsDlgButtonChecked(hDlg, idiWholeWord);
#else
                    fSearchWord = IsDlgButtonChecked(hDlg, idiWholeWord);
#endif
                    EnableExcept(vhDlgFind, FALSE);
                    DoSearch();
                    EnableExcept(vhDlgFind, TRUE);
                    EndLongOp(vhcIBeam);
                    PostStatusInCaption(NULL);
                    }
                break;
            case idiCancel:
LCancelFind:
                DestroyModeless(&vhDlgFind);
                break;
            default:
                return(FALSE);
            }
        break;

    case WM_CLOSE:
        if (bInSearchReplace)
        return TRUE;

    goto LCancelFind;

#ifndef INEFFLOCKDOWN
    case WM_NCDESTROY:
        FreeProcInstance(lpDialogFind);
        lpDialogFind = NULL;
        /* fall through to return false */
#endif

    default:
        return(FALSE);
    }
return(TRUE);
} /* end of DialogFind */


BOOL far PASCAL DialogChange( hDlg, message, wParam, lParam )
HWND    hDlg;                   /* Handle to the dialog box */
unsigned message;
WORD wParam;
LONG lParam;
{
CHAR szBuf[257]; /* max 255 char + '\0' + 1 so as to detact too long string  */
int  cch = 0;
HANDLE hCtlFindNext = GetDlgItem(hDlg, idiFindNext);
CHAR (**hszSearchT)[];
CHAR (**hszReplaceT)[];

/* This routine handles input to the Change dialog box. */

switch (message)
    {
    case WM_INITDIALOG:
#ifdef ENABLE /* not sure how cxEditScroll is used */
        cxEditScroll = 0;
#endif
        szBuf[0] = '\0';
#ifdef JAPAN  /*t-Yoshio*/
        CheckDlgButton(hDlg, idiDistinguishDandS, fSearchDist);
#elif defined(KOREA)
//bklee CheckDlgButton(hDlg, idiDistinguishDandS, fSearchDist);
        CheckDlgButton(hDlg, idiWholeWord, fSearchWord);
#else
        CheckDlgButton(hDlg, idiWholeWord, fSearchWord);
#endif
        CheckDlgButton(hDlg, idiMatchCase, fSearchCase);
        cch = CchCopySz(**hszSearch, szBuf);
        SetDlgItemText(hDlg, idiFind, (LPSTR)szBuf);
        if (cch > 0)
            {
            SelectIdiText(hDlg, idiFind);
            }
        else
            {
            EnableWindow(hCtlFindNext, false);
            EnableWindow(GetDlgItem(hDlg, idiChangeThenFind), false);
            //EnableWindow(GetDlgItem(hDlg, idiChange), false);
            EnableWindow(GetDlgItem(hDlg, idiChangeAll), false);
            }
        cch = CchCopySz(**hszReplace, szBuf);
        SetDlgItemText(hDlg, idiChangeTo, (LPSTR)szBuf);
        fChangeSel = false;
        vfDidSearch = false;
        SetChangeString(hDlg, selCur.cpFirst == selCur.cpLim);
        cpWall = selCur.cpLim;
        return( TRUE ); /* ask windows to set focus to the first item also */

    case WM_ACTIVATE:
        if (wParam)
            {
            vhWndMsgBoxParent = hDlg;
            SetChangeString(hDlg, (selCur.cpFirst == selCur.cpLim) || vfDidSearch);
            }
        if (vfCursorVisible)
            ShowCursor(wParam);
        return(FALSE); /* so that we leave the activate message to
        the dialog manager to take care of setting the focus correctly */

    case WM_COMMAND:
        switch (wParam)
            {
            case idiFind: /* edittext */
                if (HIWORD(lParam) == EN_CHANGE)
                    {
                    vfDidSearch = false;
                    cpWall = selCur.cpLim;
                    if (!CheckEnableButton(LOWORD(lParam), hCtlFindNext))
                        {
                        EnableWindow(GetDlgItem(hDlg, idiChangeThenFind), false);
                        //EnableWindow(GetDlgItem(hDlg, idiChange), false);
                        EnableWindow(GetDlgItem(hDlg, idiChangeAll), false);
                        }
                    else
                        {
                        EnableWindow(GetDlgItem(hDlg, idiChangeThenFind), true);
                        //EnableWindow(GetDlgItem(hDlg, idiChange), true);
                        EnableWindow(GetDlgItem(hDlg, idiChangeAll), true);
                        }
                    return(TRUE);
                    }
                else
                    return(FALSE);

            case idiChangeTo: /* edittext */
                return(FALSE);

            case idiFindNext: /* Button for Find Next */
                /* Windows did not check if the default button is disabled
                   or not, so we have to check that! */
                if (!IsWindowEnabled(hCtlFindNext))
                    break;
            //case idiChange: /* Change, and stay put */
            case idiChangeThenFind: /* Change, then Find button */
            case idiChangeAll: /* Button for Replace All */
                if (wwCur < 0)
                    break;
                if (FDlgSzTooLong(hDlg, idiFind, szBuf, 257))
                    {
                    switch (idiMsgResponse(hDlg, idiFind, IDPMTTruncateSz))
                        {
                        case idiOk:
                            /* show truncated text to user */
                            SetDlgItemText(hDlg, idiFind, (LPSTR)szBuf);
                            break;
                        case idiCancel:
                        default:
                            return(TRUE);
                        }
                    }
                if (FNoHeap(hszSearchT = HszCreate(szBuf)))
                    break;
                if (FDlgSzTooLong(hDlg, idiChangeTo, szBuf, 257))
                    {
                    switch (idiMsgResponse(hDlg, idiChangeTo, IDPMTTruncateSz))
                        {
                        case idiOk:
                            /* show truncated text to user */
                            SetDlgItemText(hDlg, idiChangeTo, (LPSTR)szBuf);
                            break;
                        case idiCancel:
                        default:
                            return(TRUE);
                        }
                    }
                if (FNoHeap(hszReplaceT = HszCreate(szBuf)))
                    break;
                PostStatusInCaption(IDSTRSearching);
                StartLongOp();
                FreeH(hszSearch);
                hszSearch = hszSearchT;
                FreeH(hszReplace);
                hszReplace = hszReplaceT;
                /* fReplConfirm = 1;*/
                fSearchCase = IsDlgButtonChecked(hDlg, idiMatchCase);
#ifdef JAPAN   /*t-Yoshio*/
                fSearchWord = 0;
                fSearchDist = IsDlgButtonChecked(hDlg, idiDistinguishDandS);
#elif defined(KOREA)
//bklee         fSearchDist = IsDlgButtonChecked(hDlg, idiDistinguishDandS);
                fSearchDist = 1;
                fSearchWord = IsDlgButtonChecked(hDlg, idiWholeWord);
#else
                fSearchWord = IsDlgButtonChecked(hDlg, idiWholeWord);
#endif
                EnableExcept(vhDlgChange, FALSE);
                switch (wParam)
                    {
                    case idiFindNext:
                        DoSearch();
                        break;
                    //case idiChange:
                    case idiChangeThenFind:
                        CmdReplace(wParam == idiChangeThenFind);
                        break;
                    case idiChangeAll:
                        TurnOffSel();
                        if (!fChangeSel)
                            {
                            fSelSave = TRUE;
                            selSave.cpFirst = selCur.cpFirst;
                            selSave.cpLim = selCur.cpLim;
                            selCur.cpFirst = cpMinCur;
                            selCur.cpLim = cpMacCur;
                            }
                        CmdReplaceAll();
                        fSelSave = FALSE; /* reset */
                        break;
                    default:
                        Assert(FALSE);
                        break;
                    }
                EnableExcept(vhDlgChange, TRUE);
                SetChangeString(hDlg, vfDidSearch ? true : selCur.cpFirst == selCur.cpLim);
                EndLongOp(vhcIBeam);
                PostStatusInCaption(NULL);
                break;

#ifdef JAPAN /*t-Yoshio*/
            case idiDistinguishDandS:
#elif defined(KOREA)
            case idiDistinguishDandS:
            case idiWholeWord:
#else
            case idiWholeWord:
#endif
            case idiMatchCase:
                CheckDlgButton(hDlg, wParam, !IsDlgButtonChecked(hDlg, wParam));
                break;

            case idiCancel:
LCancelChange:
                DestroyModeless(&vhDlgChange);
                break;

            default:
                return(FALSE);
            }
        break;

#if WINVER < 0x300
    /* Don't really need to process this */
    case WM_CLOSE:
        goto LCancelChange;
#endif

#ifndef INEFFLOCKDOWN
    case WM_NCDESTROY:
        FreeProcInstance(lpDialogChange);
        lpDialogChange = NULL;
        /* fall through to return false */
#endif
    default:
        return(FALSE);
    }
return(TRUE);
} /* end of DialogChange */


NEAR SetChangeString(hDlg, fAll)
HANDLE hDlg;
int    fAll;
{ /* set the last control button in CHANGE to "Change All" or "Change Selection" */
CHAR    sz[256];

if (fAll == fChangeSel)
        {
        PchFillPchId(sz, (fAll ? IDSTRChangeAll : IDSTRChangeSel), sizeof(sz));
        SetDlgItemText(hDlg, idiChangeAll, (LPSTR)sz);
        fChangeSel = !fAll;
        }
}


fnFindText()
    {/* create dialog window only when it is not already created. */
    if (!IsWindow(vhDlgFind))
        {
#ifndef INEFFLOCKDOWN
        if (!lpDialogFind)
            if (!(lpDialogFind = MakeProcInstance(DialogFind, hMmwModInstance)))
                {
                WinFailure();
                return;
                }
#endif
        vhDlgFind = CreateDialog(hMmwModInstance, MAKEINTRESOURCE(dlgFind),
                                 hParentWw, lpDialogFind);
        if (!vhDlgFind)
#ifdef WIN30
            WinFailure();
#else
            Error(IDPMTNoMemory);
#endif
        }
    else
        {
        SendMessage(vhDlgFind, WM_ACTIVATE, true, (LONG)NULL);
        }
    }


fnFindAgain()
{
register HWND hDlg = wwdCurrentDoc.wwptr;
register HWND hWndFrom;

    hWndFrom = GetActiveWindow();

/* Find out where the F3 was executed from */
/* assemble hszSearch if called from Find or Change dialog box */
    if (vhDlgFind || vhDlgChange)
        {
        if (((hDlg = vhDlgFind) && (vhDlgFind == hWndFrom ||
            vhDlgFind == (HANDLE)GetWindowWord(hWndFrom, GWW_HWNDPARENT)))
            ||
            ((hDlg = vhDlgChange) && (vhDlgChange == hWndFrom ||
             vhDlgChange == (HANDLE)GetWindowWord(hWndFrom, GWW_HWNDPARENT))))
            {
            SendMessage(hDlg, WM_COMMAND, idiFindNext, (LONG)0);
            goto Out;
            }
        }
    PostStatusInCaption(IDSTRSearching);
    StartLongOp();
    DoSearch();
    EndLongOp(vhcIBeam);
    PostStatusInCaption(NULL);
Out:
    if (!IsWindowEnabled(wwdCurrentDoc.wwptr))
       EnableWindow(wwdCurrentDoc.wwptr, true);
    if (!IsWindowEnabled(hParentWw))
       EnableWindow(hParentWw, true);
    SendMessage(hParentWw, WM_ACTIVATE, true, (LONG)NULL);
} /* end of fnFindAgain */


fnReplaceText()
{/* create dialog window only when it is not already created. */
    if (!IsWindow(vhDlgChange))
        {
#ifndef INEFFLOCKDOWN
        if (!lpDialogChange)
            if (!(lpDialogChange = MakeProcInstance(DialogChange, hMmwModInstance)))
                {
                WinFailure();
                return;
                }
#endif
        vhDlgChange = CreateDialog(hMmwModInstance, MAKEINTRESOURCE(dlgChange),
                                   hParentWw, lpDialogChange);
        if (!vhDlgChange)
#ifdef WIN30
            WinFailure();
#else
            Error(IDPMTNoMemory);
#endif
        }
    else
        {
        SendMessage(vhDlgChange, WM_ACTIVATE, true, (LONG)NULL);
        }
}


/* P U T  C P  I N  W W  V E R T  S R C H*/
NEAR PutCpInWwVertSrch(cp)
typeCP cp;

        {
/* vertical case */
        typeCP cpMac;
        int    ypMac;
        struct EDL *pedl;
        int dl;
        int dlMac;

        UpdateWw(wwCur, false);
        dlMac = pwwdCur->dlMac - (vfSelecting ? 0 : 1);
        if (dlMac <= 0)
                return;
        pedl = &(**(pwwdCur->hdndl))[dlMac - 1];
        if (cp < pwwdCur->cpFirst ||
                cp > (cpMac = pedl->cpMin + pedl->dcpMac) ||
                cp == cpMac && pedl->fIchCpIncr)
                {
                DirtyCache(pwwdCur->cpFirst = cp);
                pwwdCur->ichCpFirst = 0;
                    /* This call places the search cp vertically on the screen
                       by scrolling. */
                CtrBackDypCtr( (pwwdCur->ypMac - pwwdCur->ypMin) >> 1, 2 );

#ifdef ENABLE /* no ActiveWindow concept yet */
                if (pwwdCur->wwptr != ActiveWindow)
#endif
                        TrashWw(wwCur);
                }
        else
                {
                ypMac = pwwdCur->ypMac / 2;

/* Make sure that cp is still visible (scrolling if neccesary) */
                pedl = &(**(pwwdCur->hdndl))[dl = DlFromYp(ypMac, pwwdCur)];
                if (cp >= pedl->cpMin + pedl->dcpMac)
                        {
                        ScrollDownCtr( max( 1, dl ) );
                        TrashWw(wwCur);
                        UpdateWw(wwCur, false);
                        }
       /* If cp is on bottom dl of the window and the dl is split by the
          split bar, scroll down in doc by one line, to make insertion point
          completely visible  */
                else if (cp >= pedl->cpMin & pedl->yp > ypMac)
                        {
                        ScrollDownCtr( 1 );
                        TrashWw(wwCur);
                        UpdateWw(wwCur,false);
                        }
                }
        }


#ifndef NOLA /* no look ahead */
BOOL (NEAR FAbort())
{
MSG msg;
register WORD vk_key;
register HANDLE hwndMsg;
HANDLE hwndPeek = (vhWndMsgBoxParent) ? vhWndMsgBoxParent : hParentWw;

if (PeekMessage((LPMSG)&msg, (HANDLE)NULL, WM_KEYFIRST, WM_KEYLAST, PM_NOREMOVE))
    {
    hwndMsg = msg.hwnd;
    if ((hwndPeek == (HANDLE)GetWindowWord(hwndMsg, GWW_HWNDPARENT)) ||
        (hwndMsg == hwndPeek))
        {
#ifdef DBCS
// It can be true at DBCS that WM_CHAR is the last message.
//
    PeekMessage((LPMSG)&msg, hwndMsg, WM_KEYFIRST,WM_KEYLAST,PM_REMOVE);
#else
        GetMessage((LPMSG)&msg, hwndMsg, WM_KEYFIRST, WM_KEYLAST);
#endif
        if (msg.message == WM_KEYDOWN &&
            (((vk_key = msg.wParam) == VK_ESCAPE) || (vk_key == VK_CANCEL)))
            {
            while (true)
                {
                GetMessage((LPMSG)&msg, hwndMsg, WM_KEYFIRST, WM_KEYLAST);
                if (msg.message == WM_KEYUP && msg.wParam == vk_key)
                    return(TRUE);
                }
            }
        else if (msg.message >= WM_SYSKEYDOWN && msg.message <= WM_SYSDEADCHAR)
            DispatchMessage((LPMSG)&msg);
        }
    }
return(FALSE);
} /* end of FAbort */
#endif /* NOLA */


BOOL (NEAR FWordCp(cp, dcp))
typeCP cp;
typeCP dcp;
    {
    /* sees if the word starting at cp (with dcp chars) is a separate
        word. */
    int ich;


    /* check the start of the word */
    if(cp != cp0)
        {
        int wbPrev;
        int wbStart;
        FetchCp(docCur,cp-1,0,fcmChars + fcmNoExpand);
        ich = 0;
        wbPrev = WbFromCh(vpchFetch[ich]);
        if(vcpFetch+vccpFetch <= cp)
            {
            FetchCp(docCur,cp,0,fcmChars + fcmNoExpand);
            ich = 0;
            }
        else
            ich++;
#ifdef  DBCS    /* was in JAPAN; KenjiK '90-12-20 */
#ifndef KOREA  
    /* word break is meanless. */
    if(!IsDBCSLeadByte(vpchFetch[ich]))
#endif
#endif
        if(wbPrev == (wbStart = WbFromCh(vpchFetch[ich])))
            {
            if (wbPrev != wbWhite && wbStart != wbWhite)
                return(false);
            }
        }

    /* check the end of the word */
    if(cp+dcp-1 != cp0)
        {
        int wbEnd;
        int wbLim;

        if(vcpFetch+vccpFetch <= cp+dcp-1 || vcpFetch > cp+dcp-1)
            {
            FetchCp(docCur,cp+dcp-1,0,fcmChars + fcmNoExpand);
            ich = 0;
            }
        else
            ich =  (dcp-1) - (vcpFetch-cp);
        wbEnd = WbFromCh(vpchFetch[ich]);
        if(vcpFetch+vccpFetch <= cp+dcp)
            {
            FetchCp(docCur,cp+dcp,0,fcmChars + fcmNoExpand);
            ich = 0;
            }
        else
            ich++;
#ifdef  DBCS    /* was in JAPAN; KenjiK '90-12-20 */
#ifndef KOREA 
    /* word break is meanless. */
    if(!IsDBCSLeadByte(vpchFetch[ich]))
#endif
#endif
        if(vccpFetch != 0 && (wbEnd == (wbLim = WbFromCh(vpchFetch[ich]))))
            {
            if (wbEnd != wbWhite && wbLim != wbWhite)
                return(false);
            }
        }

    return(true);
    }


BOOL (NEAR FChMatch(ch, pichPat, fFwd))
int ch;
int *pichPat;
BOOL fFwd;
    {
    int ich = *pichPat;
    int chSearch = szSearch[ich];
    BOOL fPrefixed = false;
    BOOL fMatched = false;

#ifdef DEBUG
    Assert(fSpecialMatch);
#endif /*DEBUG*/
#ifdef DBCS
    Assert(fFwd);
    cbLastMatch = 1; /* Unless DBCS space. */

#endif

    /* NOTE: this is just ChLower() brought in-line for speed */
#ifdef DBCS
//       No need to make lower char for DBCS second byte
    if(!fDBCS && !fSearchCase && ch >= 'A' && ch <= 'Z' )
#else
    if(!fSearchCase && ch >= 'A' && ch <= 'Z' )
#endif
            ch += 'a' - 'A';
    if(!fFwd && ich > 0 && szSearch[ich-1] == chPrefixMatch)
        /* see if the char is prefixed by a chPrefixMatch */
        {
        chSearch = chPrefixMatch;
        --ich;
        }

    for(;;)
        {
        switch(chSearch)
            {
            default:

//#ifdef JAPAN
#if defined(JAPAN) || defined(KOREA)
                if(IsDBCSLeadByte(chSearch))
                    cbLastMatch = 2;
#endif
                if(ch == chSearch)
                    goto GoodMatch;
                else if(ch == chReturn || ch == chNRHFile)
                    goto EasyMatch;
                break;
            case chSpace:
                if(ch == chSpace || ch == chNBSFile)
                    goto GoodMatch;
                break;
            case chHyphen:
                if(ch == chHyphen || ch == chNRHFile || ch == chNBH)
                    goto GoodMatch;
                break;
            case chMatchAny:
                if(ch == chReturn || ch == chNRHFile)
                    goto EasyMatch;
                if(!fPrefixed || ch == chMatchAny)
                    goto GoodMatch;
                break;
            case chPrefixMatch:
                if(fPrefixed)
                    {
                    if(ch == chPrefixMatch)
                        goto GoodMatch;
                    else
                        break;
                    }
                else
                    {
                    chSearch = szSearch[ich+1];
                    if(fFwd)
                        ++ich;
                    fPrefixed = true;
                    switch(chSearch)
                        {
                        default:
                            continue;
                        case chMatchEol:
                            chSearch = chEol;
                            continue;
                        case chMatchTab:
                            chSearch = chTab;
                            continue;
                        case chMatchWhite:
                            switch(ch)
                                {
                                default:
#ifdef DBCS
lblNonWhite:
#endif
                                    if(fMatchedWhite)
                                        {
                                        if(fFwd)
                                            {
                                            if(szSearch[++ich] =='\0')
                                                {
                                                *pichPat = ich;
                                                goto EasyMatch;
                                                }
                                            }
                                        else
                                            {
                                            ich -= 1;
                                            if(ich < 0)
                                                {
                                                *pichPat = ich;
                                                goto EasyMatch;
                                                }
                                            }
                                        *pichPat = ich;
                                        fMatchedWhite = false;
                                        chSearch = szSearch[ich];
                                        continue;
                                        }
                                    break;
                                case chSpace:
                                case chReturn:
                                case chEol:
                                case chTab:
                                case chNBSFile:
                                case chNewLine:
                                case chSect:
                                    fMatchedWhite = true;
                                    goto EasyMatch;
                                }
                            break;
                        case chMatchNBSFile:
                            chSearch = chNBSFile;
                            continue;
                        case chMatchNewLine:
                            chSearch = chNewLine;
                            continue;
                        case chMatchNRHFile:
                            chSearch = chNRHFile;
                            continue;
                        case chMatchSect:
                            chSearch = chSect;
                            continue;
                        }
                    }
                break;
            }
        fMatchedWhite = false;
        return false;
        }
GoodMatch:
    *pichPat = ich + ((fFwd) ? 1 : (-1));
EasyMatch:
    return true;
    }

/* I N S E R T  P A P S  F O R  R E P L A C E */
/* do AddRunScratch for every distinct paragraph in hszCaseReplace  */
/* This is only needed when hszCaseReplace contains one or more chEols */
NEAR InsertPapsForReplace(fc)
typeFC fc;
        {
        int cchInsTotal = 0;
        CHAR *pchTail;
        CHAR *pchHead;

        for(;;)
                {
                int cch;

                pchHead = **hszCaseReplace + cchInsTotal;
                pchTail = (CHAR *)index(pchHead, chEol);
                if (pchTail == 0) return;
                cch = pchTail - pchHead + 1; /* cch is count including chEol */

                fc += cch;
                cchInsTotal += cch;
                AddRunScratch(&vfkpdParaIns, &vpapAbs, vppapNormal,
                        FParaEq(&vpapAbs, &vpapPrevIns) && vfkpdParaIns.brun != 0 ? -cchPAP : cchPAP,
                        fcMacPapIns = fc);
                blt(&vpapAbs, &vpapPrevIns, cwPAP);
                }
        }


NEAR FDlgSzTooLong(hDlg, idi, pch, cchMax)
HWND hDlg;
int idi;
CHAR *pch;
int cchMax;
{
int cchGet = GetDlgItemText(hDlg, idi, (LPSTR)pch, cchMax);

*(pch+cchMax-2) = '\0'; /* just in case the string is too long */
if (cchGet > (cchMax - 2))
    return(TRUE);
else
    return(FALSE);
}


NEAR idiMsgResponse(hDlg, idi, idpmt)
HWND hDlg;
int idi;
int idpmt;
{
CHAR szT[cchMaxSz];

PchFillPchId(szT, idpmt, sizeof(szT));
SetFocus(GetDlgItem(hDlg, idi));
SendDlgItemMessage(hDlg, idi, EM_SETSEL, (WORD)NULL, MAKELONG(255, 32767));
return(IdPromptBoxSz(hDlg, szT, MB_OKCANCEL | MB_ICONASTERISK));
}


PostStatusInCaption(idstr)
int idstr;
{

extern HWND hParentWw;
extern CHAR szCaptionSave[];

CHAR *pchCaption = &szCaptionSave[0];
CHAR *pchLast;
int  cch;
CHAR szT[256];

if (idstr == NULL)
    {
    /* restore the caption */
    SetWindowText(hParentWw, (LPSTR)pchCaption);
    }
else
    {
    /* save caption */
    GetWindowText(hParentWw, (LPSTR)pchCaption, cchMaxFile);

    /* append status message after app name */
#ifndef INTL
    pchLast = pchCaption + CchSz(pchCaption) - 1;
    while (pchLast-- > pchCaption)
        {
        if (*pchLast == ' ')
            break;
        }
    PchFillPchId(bltbyte(pchCaption, szT, (cch = pchLast - pchCaption + 1)),
                 IDSTRSearching, 13);
#else
    pchLast = pchCaption + CchSz(szAppName) + CchSz(szSepName) - 2;
    PchFillPchId(bltbyte(pchCaption, szT, (cch = pchLast - pchCaption)),
                 IDSTRSearching, 13);
#endif
    SetWindowText(hParentWw, (LPSTR)szT);
    }
}
#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
BOOL (NEAR J_FChMatch(ch, chNext, pichPat, pichDoc))
CHAR ch;
CHAR chNext;
int *pichPat;
int *pichDoc;
{
    int ich = *pichPat;
    CHAR chSearch = szSearch[ich];
    CHAR chSearchNext = szSearch[ich+1];
    WORD dchSearch;
    BOOL fPrefixed = false;

    if(!fSearchCase ) {
#ifdef JANPAN
        if(ch == 0x82 && chNext >= 0x60 && chNext <= 0x79 )
            chNext = 0x21 + chNext;
#else
        if(ch == 0xA3 && (chNext >= 0xC1 && chNext <= 0xDA))
            chNext = 0x20 + chNext;
#endif
        else if( ch >= 'A' && ch <= 'Z' )
            ch += 'a' - 'A';
    }

    for(;;) {
        if( chSearch == chPrefixMatch ) {
            if(fPrefixed) {
                if(ch == chPrefixMatch) {
                    *pichPat = ich + 1;
                    return true;
                }
                break;
            }
            chSearch = chSearchNext;
            ich++;
            if(IsDBCSLeadByte(chSearch)) {
                chSearchNext = szSearch[ich+1];
                continue;
            }
            fPrefixed = true;
            switch(chSearch)
            {
                default:
                    continue;
                case chMatchEol:
                    chSearch = chEol;
                    break;
                case chMatchTab:
                    chSearch = chTab;
                    break;
                case chMatchNBSFile:
                    chSearch = chNBSFile;
                    break;
                case chMatchNewLine:
                    chSearch = chNewLine;
                    break;
                case chMatchNRHFile:
                    chSearch = chNRHFile;
                    break;
                case chMatchSect:
                    chSearch = chSect;
                    break;
                case chMatchWhite:
                    if(IsDBCSLeadByte((BYTE)ch)) {
#if defined(JAPAN)
                        if(ch == 0x81 && chNext == 0x40) {
#else
                        if(!fSearchDist && (ch == 0xA1 && chNext == 0xA1)) {
#endif
                            fMatchedWhite = true;
                            return true;
                        }
                    }
                    else if( ch == chSpace || ch == chReturn || ch == chEol ||
                            ch == chNBSFile || ch == chTab || ch == chNewLine || ch == chSect )
                    {
                        fMatchedWhite = true;
                        return true;
                    }
                    if(fMatchedWhite) {
                        if(szSearch[ich+1] =='\0') {
                            *pichPat = ich + 1;
                            return true;
                        }
                        *pichPat = ich++;
                        fMatchedWhite = false;
                        chSearch = szSearch[ich];
                        chSearchNext = szSearch[ich+1];
                        break;
                    }
#ifdef KOREA
                        fMatchedWhite = false;
			return false;
#else
                break;
#endif
            }
        }
        if( chSearch == chMatchAny ) {
            if(ch == chReturn || ch == chNRHFile)
                return true;
            if(!fPrefixed || ch == chMatchAny) {
                *pichPat = ich + 1;
                return true;
            }
            break;
        }
        if(chSearch == chSpace ) {
            if(ch == chSpace || ch == chNBSFile || (ch == 0x81 && chNext == 0x40)) {
                *pichPat = ich + 1;
                return true;
            }
            break;
        }
        if(chSearch == chHyphen ) {
            if(ch == chHyphen || ch == chNRHFile || ch == chNBH) {
                *pichPat = ich + 1;
                return true;
            }
            break;
        }
        if(!fSearchDist)
        {
            CHAR Doc[3];
            CHAR Pat[3];
            CHAR tmp[3];
            Doc[0] = Doc[1] = Doc[2] = '\0';
            Pat[0] = Pat[1] = Pat[2] = '\0';
            if(IsDBCSLeadByte((WORD)chSearch)) {
                Pat[0] = chSearch;
                Pat[1] = chSearchNext;
                ich += 2;
            }
            else {
                tmp[0] = chSearch;
                tmp[1] = tmp[2] = '\0';
                if(chSearch >= 0xca && chSearch <= 0xce) {
                    if(chSearchNext == 0xde || chSearchNext == 0xdf ) {
                        tmp[1] = chNext;
                        ich += 1;
                    }
                }
                else if(chSearch >= 0xa6 && chSearch <= 0xc4) {
                    if(chSearchNext == 0xde ) {
                        tmp[1] = chNext;
                        ich += 1;
                    }
                }
                ich += 1;
                myHantoZen(tmp,Pat,3);
            }
            if(IsDBCSLeadByte((BYTE)ch))
            {
                if(Pat[0] == ch && Pat[1] == chNext)
                {
                    *pichPat = ich;
                    return  true;
                }
                else
                    return false;
            }
            else {
                tmp[0] = ch;
                if(ch >= 0xca && ch <= 0xce) {
                    if(myIsSonant(Pat[0],Pat[1]) && chNext == 0xde || chNext == 0xdf ) {
                        tmp[1] = chNext;
                        cbLastMatch = 2;
                        *pichDoc++;
                    }
                }
                else if(ch >= 0xa6 && ch <= 0xc4) {
                    if(!myIsSonant(Pat[0],Pat[1]) && chNext == 0xde ) {
                        tmp[1] = chNext;
                        cbLastMatch = 2;
                        *pichDoc++;
                    }
                }
                myHantoZen(tmp,Doc,3);

                if(Pat[0] == Doc[0] && Pat[1] == Doc[1])
                {
                    *pichPat = ich;
                    return true;
                }
                else if(ch == chReturn || ch == chNRHFile)
                    return true;
                else
                    return  false;
            }
            return false;
        }
        if( chSearch == ch) {
            if(IsDBCSLeadByte((BYTE)ch)) {
                if(chSearchNext == chNext) {
                    *pichPat = ich + 2;
                    return true;
                }
                else
                    return false;
            }
            *pichPat = ich + 1;
            return true;
        }
        else if(ch == chReturn || ch == chNRHFile)
            return true;
        break;
    }
        /*UnMatched*/
        fMatchedWhite = false;
        return false;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\stcdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* stcdefs.h -- definitions of styles */

#define usgCharMin      0
#define usgParaMin      11
#define usgSectMin      26
#define usgMax          33
#define usgCharNormal   0

#define stcNormal       0
#define stcParaMin      30
#define stcSectMin      105
#define stcMax          128

#define stcFtnRef       13
#define stcFolio	19
#define stcFtnText      39
#define stcRunningHead  93

#define cchMaxRemark    28
#define ccpSshtEntry    (1 + 2 + cchMaxRemark + 1)
#define cchMaxStc       40      /* Length of longest usage-variant pair */

/* Fetch Style Modes */
#define fsmDiffer       0
#define fsmSame         1
#define fsmAny          2

struct CHP *PchpFromStc();
struct PAP *PpapFromStc();
struct SEP *PsepFromStc();


struct SYTB
	{ /* Style table */
	int             mpstcbchFprop[stcMax];
	CHAR            grpchFprop[2]; /* Variable size */
	};

#define cwSYTBBase      stcMax

struct SYTB **HsytbCreate();


struct AKD
	{ /* ALT-Key Descriptor */
	CHAR            ch;
	unsigned             fMore : 1;
	unsigned             ustciakd : 7;
	};

#define cchAKD  (sizeof (struct AKD))
#define cwAKD   (cchAKD / sizeof (int))

/* max length of strings used in usages and font names */
#define cchIdstrMax	32

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\str.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* IDSTRs and IDPMTs are in 5 different groups,
   the high byte is for masking, see MB_ERRxxxx definitions */

#define MB_ERRMASK               0xf000
#define MB_ERRASTR               0x1000
#define MB_ERREXCL               0x2000
#define MB_ERRQUES               0x3000
#define MB_ERRHAND               0x4000

#ifndef NOSTRUNDO
/* NONERROR group, from 0x0001 -- 0x0fff */
/*    Menu and Undo strings */
#define IDSTRUndoBase            0x0001
#define IDSTRUndoEdit            0x0002
#define IDSTRUndoLook            0x0003
#define IDSTRUndoTyping          0x0004
#define IDSTRShowRuler           0x0005
#define IDSTRHideRuler           0x0006
#define IDSTRAbout               0x0007
#define IDSTREdit                0x0008
#define IDSTRCancel              0x0009
#define IDSTRPopupVerbs          0x000A
#define IDSTRSingleVerb          0x0010

    /* UNDO menu string lengths, including terminator */
#define cchSzUndo   (25)

#endif  /* NOSTRUNDO */



#define IDSTRHELPF               0x000b
#define IDSTRChangeSel           0x000c
#define IDSTRChangeAll           0x000d

#define IDSTRChPage              0x000e
#define IDSTRLoading             0x000f

#define IDSTROn                  0x0013
#define IDSTRReplaceFile         0x0016
#define IDSTRChars               0x0017
#define IDSTRSearching           0x0018

#define IDS_MERGE1               0x0019

#define IDSTRConvertText         0x001a
#define IDSTRConvertWord         0x001b

/* OLE strings */
#if defined(OLE)
#define IDSTRMenuVerb   0x0020
#define IDSTRLinkProperties     0x0021
#define IDSTRAuto               0x0022
#define IDSTRManual             0x0023
#define IDSTRFrozen             0x0024
#define IDSTREmbedded           0x0025
#define IDSTRFilter             0x0026
#define IDSTRExtension          0x0027
#define IDSTRAllFilter          0x0028
#define IDSTRRename             0x0029
#define IDSTRServer             0x002A
#define IDSTRInsertfile         0x0032
#define IDSTRChangelink         0x0033
#define IDSTRUpdate             0x0034
#define IDSTRMenuVerbP  0x0035
#endif

/* commdlg strings */
#define IDSTROpenfile           0x0060
#define IDSTRSavefile           0x0061
#define IDSTRDefWriExtension    0x0062
#define IDSTRDefDocExtension    0x0063
#define IDSTRDefTxtExtension    0x0064
#define IDSTRTxtDescr           0x0065
#define IDSTRWriDescr           0x0066
#define IDSTRDocDescr           0x0067
#define IDSTRDocTextDescr       0x0068
#define IDSTROldWriteDescr      0x0069
#define IDSTRAllFilesDescr      0x006a


#define IDSTRBitmap             0x006b
#define IDSTRPicture            0x006c
#define IDSTRDIB                0x006d
#define IDSTRText               0x006e
#define IDSTRBackup             0x006f
#define IDSTRObject             0x0070

#if defined(JAPAN) || defined(KOREA) /*t-Yoshio*/
#define IDSTRZen1               0x0071
#define IDSTRZen2               0x0072
#endif

/* See ErrorLevel() -- error messages are grouped as follows and then
                       we can quickly determine the severity of an error */

/***** FOLLOWING MESSAGES ARE "*" LEVEL MESSAGES */
/* MB_ERRASTR group, from 0x1000 -- 0x1fff */

#define IDPMTSearchDone          0x1000
#define IDPMTNotFound            0x1001
#define IDPMTNoReplace           0x1002
#define IDPMTCancelSearch        0x1003


/***** FOLLOWING MESSAGES ARE "?" LEVEL MESSAGES */
/* MB_ERRQUES group, from 0x3000 -- 0x3fff */

#define IDPMTAddFont             0x3000
#define IDPMTTruncateSz          0x3001
#define IDPMTConvert             0x3002

#if defined(JAPAN) || defined(KOREA)                  // added  09 Jun. 1992  by Hiraisi
#define IDPMTFontChange          0x3003
#endif

/***** FOLLOWING MESSAGES ARE "!" LEVEL MESSAGES */
/* MB_ERREXCL group, from 0x2000 -- 0x2fff */

#ifndef NOSTRERRORS
#define IDPMTBadFileName         0x202c
#define IDPMTRottenFile          0x202b
#define IDPMTBadFile             0x2006
#define IDPMTCantOpen            0x2019
#define IDPMTDirtyDoc            0x201a
#define IDPMTCantRunM            0x201b
#define IDPMTCantRunF            0x2021
#define IDPMTNoPath              0x201c
#define IDPMTFileNotFound        0x201f
#define IDPMTReadOnly            0x2020
#define IDPMTCantRead            0x202d
#define IDPMTDelObjects          0x2029
#define IDPMTDelPicture          0x202a
#define IDPMTRenameFail          0x2023
#define IDPMTOverwrite           0x2026
#define IDPMTCantShare           0x2027
#if defined(OLE)
#define IDPMTGetFromClipboardFailed         0x2102
#define IDPMTFailedToFreeze                 0x2103
#define IDPMTFailedToLaunchServer           0x2104
#define IDPMTFailedToActivate               0x2105
#define IDPMTFailedToUpdate                 0x2106
#define IDPMTFailedToDeleteObject               0x2108
#define IDPMTServerBusy                         0x2109
#define IDPMTFailedToUpdateLink             0x210b
#define IDPMTImproperLinkOptionsError       0x210c
#define IDPMTFailedToCommWithServer         0x210d
#define IDPMTFailedToReadObject             0x210e
#define IDPMTFailedToCreateObject               0x210f
#define IDPMTFailedToDraw                   0x2110
#define IDPMTInsufficientResources          0x2111
#define IDPMTOLEError                       0x2112
#define IDPMTFileContainsObjects            0x2113
#define IDPMTFailedToLoadObject             0x2114
#define IDSTRFinishObject                   0x2115
#define IDPMTLinkUnavailable                 0x2116
#define IDPMTFormat                         0x2117
#define IDPMTStatic                         0x2118
#define IDSTRUpdateObject                   0x2119
#define IDPMTLinksUnavailable               0x211b
#define IDPMTCutOpenEmb                     0x211c
#define IDPMTExitOpenEmb                    0x211d
#define IDPMTSaveOpenEmb                    0x211e
#define IDPMTDeleteOpenEmb                  0x211f
#define IDPMTInsertOpenEmb                  0x2120
#endif

/*    Dialog field errors */

#define IDPMTNoPage              0x2007
#define IDPMTNOTNUM              0x2008
#define IDPMTBFS                 0x2009
#define IDPMTNPI                 0x200a
#define IDPMTNOTDXA              0x200b
#define IDPMTNPDXA               0x200c
#define IDPMTMTL                 0x200d
#define IDPMTBadFilename         0x200e

#define IDPMT2Complex            0x200f
#define IDPMTBadMove             0x2010
#define IDPMTDFULL               0x2012
#define IDPMTPRFAIL              0x2013
#define IDPMTClipLarge           0x2017
#define IDPMTClipQuest           0x201e
#define IDPMTBadPrinter          0x2018
#define IDPMTCantPrint           0x2022
#define IDPMTPrPictErr           0x2024
#define IDPMTPrDiskErr           0x2025
#define IDPMTDFULLScratch        0x2028

/***** FOLLOWING MESSAGES ARE "<hand>" LEVEL MESSAGES */
/* MB_ERRHAND group, from 0x4000 -- 0x4fff */

#define IDPMTSDE                 0x4000
#define IDPMTSDN                 0x4001
#define IDPMTNoMemory            0x4002
#define IDPMTSFER                0x4003
#define IDPMTMEM                 0x4004
#define IDPMTWinFailure          0x4005
#define IDPMTSDE2                0x4006
#define IDPMTFloppyback          0x4007
#define IDPMTFileback            0x4008
#if defined(JAPAN)               // added  01/21/93 T-HIROYN
#define IDPMTNoMemorySel         0x4009
#endif
#endif        /* NOSTRERRORS */


/***** FOLLOWING MESSAGES ARE EX-GLOBDEFS.H MESSAGES */

#define IDSTRModeDef                        0x7000

#define IDSTRWriteDocPromptDef              0x7001
#define IDSTRScratchFilePromptDef           0x7002
#define IDSTRSaveFilePromptDef              0x7003
#define IDSTRAppNameDef                     0x7004
#define IDSTRUntitledDef                    0x7005

#define IDSTRiCountryDefaultDef             0x7006

#define IDSTRWRITETextDef                   0x7007

#define IDSTRFreeDef                        0x7008

#define IDSTRNoneDef                        0x7009

#define IDSTRHeaderDef                      0x700a
#define IDSTRFooterDef                      0x700b

#define IDSTRLoadFileDef                    0x700c
#define IDSTRCvtLoadFileDef                 0x700d

#define IDSTRInchDef                        0x700e
#define IDSTRCmDef                          0x700f
#define IDSTRP10Def                         0x7010
#define IDSTRP12Def                         0x7011
#define IDSTRPointDef                       0x7012
#define IDSTRLineDef                        0x7013
#define IDSTRAltBSDef                       0x7014

#if defined(JAPAN) || defined(KOREA) //T-HIROYN Win3.1
/* default FontFaceName we use FInitFontEnum() */
#define IDSdefaultFFN0                      0x7091
#define IDSdefaultFFN1                      0x7092
#define IDPMTNotKanjiFont                   0x7093
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\toolbox.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* extracted from original toolbox.h */

#define srcCopy         0       /* Destination = Source                 */
#define srcOr           1       /* Destination = Source OR Destination  */
#define srcXor          2       /* Destination = Source XOR Destination */
#define srcBic          3       /* Destination = Source BIC Destination */
#define notSrcCopy      4       /* Destination = NOT(Source)            */
#define notSrcOr        5       /* Destination = NOT(Source) OR Dest    */
#define notSrcXor       6       /* Destination = NOT(Source) XOR Dest   */
#define notSrcBic       7       /* Destination = NOT(Source) BIC Dest   */
#define patCopy         8       /* Destination = Pattern                */
#define patOr           9       /* Destination = Pattern OR Dest        */
#define patXor          10      /* Destination = Pattern XOR Dest       */
#define patBic          11      /* Destination = Pattern BIC Dest       */
#define notPatCopy      12      /* Destination = NOT(Pattern)           */
#define notPatOr        13      /* Destination = NOT(Pattern) OR Dest   */
#define notPatXor       14      /* Destination = NOT(Pattern) XOR Dest  */
#define notPatBic       15      /* Destination = NOT(Pattern) BIC Dest  */

typedef int *WORDPTR;
typedef WORDPTR WINDOWPTR;
typedef WORDPTR MENUHANDLE;
typedef HANDLE RGNHANDLE;
typedef HANDLE CTRLHANDLE;

typedef struct {
	int ascent;
	int descent;
	int widMax;
	int leading;
} FONTINFO;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\transbuf.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOGDI
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NORECT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "code.h"
#include "txb.h"
#include "str.h"
#include "docdefs.h"
#include "cmddefs.h"
#include "filedefs.h"
#include "ch.h"
#include "propdefs.h"
#include "fmtdefs.h"
#include "dispdefs.h"
#include "stcdefs.h"
/*#include "toolbox.h"*/
#include "wwdefs.h"

/* New functionality for Sand:  Jan 17, 1984
        Kenneth J. Shapiro                      */

/*---------------------------------------------------------------------------
The following routines form the interface between the buffer code and the
rest of multi-word:
    CmdXfBufClear()     - used by "Transfer Buffer Clear"
    CmdXfBufLoad()      - used by "Transfer Buffer Load"
    CmdXfBufSave()      - used by "Transfer Buffer Save"
----------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
External global references:
----------------------------------------------------------------------------*/
extern int vfSeeSel;
extern struct DOD (**hpdocdod)[];
extern VAL rgval[];
extern int docCur;
extern struct SEL selCur;
extern int YCOCMD;
extern typeCP cpMacCur;
extern int      docScrap;
/*extern WINDOWPTR  ActiveWindow;
extern WINDOWPTR  windowGlos;
*/
extern CHAR       stBuf[];
extern struct WWD *pwwdCur;

extern struct   TXB     (**hgtxb)[]; /* array of txbs.  Sorted for binary search */
extern short    itxbMac;  /* indicates current size of hgtxb */
extern int      docBuffer; /* doc containing all buffer text */
extern int      vfBuffersDirty;
extern int      rfnMac;
extern struct   ERFN     dnrfn[];

#ifdef ENABLE
/*---------------------------------------------------------------------------
-- Routine: CmdXfBufClear()
-- Description and Usage:
    Called by the menu routines to execute "Transfer Buffer Clear"
    rgval[0] contains a list of buffer names, stored in an hsz.
        The list is just as the user typed it.
    Makes the user confirm the action, and then removes all of the named
        buffers.  If no buffers are named, it clear ALL buffers.
-- Arguments: none
-- Returns: nothing
-- Side-effects:
    Clears some subset of the named buffers.
-- Bugs:
-- History:
    3/25/83     - created (tsr)
    4/27/83     - modified to handle list of names (tsr)
----------------------------------------------------------------------------*/
CmdXfBufClear()
    {
#ifdef DEMOA
        DemoErr();
#else
    int ich;
    int itxb;

    if(!cnfrm(IDPMTBufCnfrm))
        return;
    NoUndo();
    if(CchSz(**(CHAR(**)[])rgval[0])==1)
        {
        for(itxb=0; itxb < itxbMac ; itxb++)
            {
            FreeH((**hgtxb)[itxb].hszName);
            }
        FreeH(hgtxb);
        hgtxb = HAllocate(cwTxb);
#ifdef DEBUG
        /* We just freed the space, so it shouldn't be bad now */
        Assert(!FNoHeap(hgtxb));
#endif /*DEBUG*/
        (**hgtxb)[0].hszName = hszNil;
        itxbMac = 0;
        KillDoc(docBuffer);
        docBuffer = DocCreate(fnNil, (CHAR (**)[]) 0, dtyBuffer);
        }
    else
        FClearBuffers(**(CHAR(**)[])rgval[0], CchSz(**(CHAR(**)[])rgval[0])-1,
                    TRUE, &ich);
#endif /* DEMOA */
    }
#endif      /* ENABLE */

#ifdef ENABLE
/*---------------------------------------------------------------------------
-- Routine: CmdXfBufLoad()
-- Description and Usage:
    Called by the menu routines to execute "Transfer Buffer Load"
    rgval[0] contains the name of the file to load.
    Merges references to the loaded buffers into the buffer list stored in
        hgtxb.  Requires additions to docBuffer for each newly one.
-- Arguments: none
-- Returns: nothing
-- Side-effects:
    Can define/clobber many buffers.
-- Bugs:
-- History:
    3/22/83     - created (tsr)
----------------------------------------------------------------------------*/
CmdXfBufLoad()
    {
#ifdef DEMOA
        DemoErr();
#else
    extern CHAR (**hszGlosFile)[];
    /* for each buffer definition in the file:
        a) add the related text to the end of docBuffer
        b) insert or replace the reference for that buffer name
    */
    CHAR (**hszFile)[] = (CHAR (**)[]) rgval[0];
    int fn;
    if ((fn = FnOpenSz(**hszFile, dtyBuffer, TRUE)) == fnNil)
        {
        Error(IDPMTBadFile);
        return;
        }
    NoUndo();
    MergeTxbsFn(fn);
    if ((**hszGlosFile)[0] == 0)
        {
        FreeH(hszGlosFile);
        hszGlosFile = hszFile;
        }
    vfBuffersDirty = true;
#endif /* DEMOA */
    }
#endif  /* ENABLE */


#ifdef ENABLE
/*---------------------------------------------------------------------------
-- Routine: MergeTxbsFn(fn)
-- Description and Usage:
    Given an fn which contains a buffer document, this function reads in
        the text of the file, appending it to docBuffer.  It also reads
        the Bftb from the file in order to build the appropriate mapping
        from buffer name to text.
-- Arguments:
    fn  - file containing buffer definitions.
-- Returns:
    nothing
-- Side-effects:
    builds new buffers onto docBuffer and hgtxb
-- Bugs:
-- History:
    3/24/83     - created (tsr)
----------------------------------------------------------------------------*/
MergeTxbsFn(fn)
int     fn;
    {
    extern struct FCB (**hpfnfcb)[];
    extern short ItxbFromHsz();
    unsigned pbftbFile;
    typePN pn;
    int cchT;
    CHAR (**hbftb)[];
    int *pwBftb;
    int cw;
    int ich;
    short itxbNew;
    struct TXB *ptxbNew;
    typeCP cp, dcp;
    typeCP cpBufMac;
    CHAR(**hszNew)[];
    int docNew;

    CHAR sz[cchMaxSz];

#ifdef DEBUG
    Assert(fn != fnNil && (**hpfnfcb)[fn].fFormatted);
#endif
    if ((pn = (**hpfnfcb)[fn].pnBftb) ==(**hpfnfcb)[fn].pnFfntb)
            return;
    pbftbFile = (unsigned) PchGetPn(fn, pn, &cchT, false);

    hbftb = (CHAR (**) []) HAllocate(cw=((**hpfnfcb)[fn].pnFfntb - (**hpfnfcb)[fn].pnBftb)*cwSector);
    if (FNoHeap((int)hbftb))
        return;
    pwBftb =  *(int **)hbftb;

    blt(pbftbFile, pwBftb, min(cwSector, cw));

    while ((cw -= cwSector) > 0)
            { /* Copy the records to heap */
            blt(PchGetPn(fn, ++pn, &cchT, false), pwBftb += cwSector,
                min(cwSector, cw));
            }

    ich = 0;
    cp = cp0;
    cpBufMac = CpMacText(docBuffer);
    bltsz(**(**hpfnfcb)[fn].hszFile, sz);
    docNew = DocCreate(fn, HszCreate(sz), dtyBuffer); /* HEAP MOVES */
    while((**hbftb)[ich] != '\0')
        {
        bltsz(&(**hbftb)[ich], sz);
        sz[cchMaxSz - 1] = 0;
        hszNew = (CHAR(**)[]) HszCreate(sz); /*** HEAP MOVES ***/
        ich += CchSz(sz);
        bltbyte(&(**hbftb)[ich], &dcp, sizeof(typeCP));
        ich += sizeof(typeCP);
        itxbNew = ItxbFromHsz(hszNew);
#ifdef DEBUG
        Assert(itxbNew >= 0);
#endif /* DEBUG */
        ReplaceCps(docBuffer, cpBufMac, cp0, docNew, cp, dcp); /*HEAP MOVES*/
        ptxbNew = &(**hgtxb)[itxbNew];
        ptxbNew->cp=cpBufMac;
        ptxbNew->dcp=dcp;
        cpBufMac += dcp;
        cp += dcp;
        }
    KillDoc(docNew);
    FreeH((int **)hbftb);
    }
#endif  /* ENABLE */

#ifdef ENABLE
/*---------------------------------------------------------------------------
-- Routine: CmdXfBufSave()
-- Description and Usage:
    Called by the menu routines to execute "Transfer Buffer Save"
    rgval[0] contains the name of the file to save the buffers in.
    Creates a single doc to contain all of the buffers and updates
        hgtxb to reference that doc, cleaning up all of the temporary
        docs that were around.
    Stores that doc in the file, putting a table at the end of the file
        which maps buffer names to locations within the file.
-- Arguments: none
-- Returns: nothing
-- Side-effects:
-- Bugs:
-- History:
    3/22/83     - created (tsr)
----------------------------------------------------------------------------*/
CmdXfBufSave(szFile)
CHAR szFile[];
{
#ifndef WDEMO
        CHAR (**hszFile)[];
        CHAR szBak[cchMaxFile];
        long ltype;

    /* Move file name to local */
/*    bltbyte(**hszFile, szFile, cchMaxFile);*/

    BackupSzFile(szFile, true, szBak, &ltype);
/*    ForcePmt(IDPMTSaving);*/
    NoUndo();
#ifdef STYLES
    (**hpdocdod)[docBuffer].docSsht = (**hpdocdod)[docCur].docSsht;
#endif
    CachePara(docBuffer, cp0);
    CleanDoc(docBuffer, szFile, true, true);
    (**hpdocdod)[docBuffer].docSsht = docNil;
    if (!FNoHeap(hszFile = HszCreate(szFile)))
        {
        FreeH(hszGlosFile);
        hszGlosFile = hszFile;
        }

    vfBuffersDirty = false;
#endif /* not WDEMO */
}
#endif  /* ENABLE */


#ifdef ENABLE
/*---------------------------------------------------------------------------
-- Routine: CleanBuffers()
-- Description and Usage:
    Creates a new docBuffer containing only currently referenced buffer text.
        This is to keep old buffer values from lying around through
        eternity.
-- Arguments: none
-- Returns: nothing
-- Side-effects:
    creates a new doc for docBuffer.
    kills old docBuffer.
-- Bugs:
-- History:
    3/24/83     - create (tsr)
----------------------------------------------------------------------------*/
CleanBuffers()
    {
#ifdef DEMOA

#else
    int docNew;
    short itxb;
    struct TXB *ptxb;
    typeCP cp, cpOld;
    typeCP dcp;


    docNew = DocCreate(fnNil, (CHAR (**)[]) 0, dtyBuffer);
    for(cp=0, itxb=0;itxb<itxbMac;itxb++, cp+=dcp)
        {
        ptxb = &(**hgtxb)[itxb];
        cpOld = ptxb->cp;
        ptxb->cp = cp;
        /* HEAP MOVEMENT */
        ReplaceCps(docNew, cp, cp0, docBuffer, cpOld, dcp = ptxb->dcp);
        }
    KillDoc(docBuffer);
    docBuffer = docNew;
    NoUndo();
#endif /* DEMOA */
    }
#endif  /* ENABLE    */


/*---------------------------------------------------------------------------
-- Routine: WriteBftb(fn)
-- Description and Usage:
    Given an fn for a buffer file that is being written, this routine
        actually writes out the Bftb which maps buffer names to pieces of
        text stored in the file.
-- Arguments:
    fn  - file being written.
-- Returns: nothing
-- Side-effects:
    Writes to the file described by fn.
-- Bugs:
-- History:
    3/24/83     - created (tsr)
----------------------------------------------------------------------------*/
WriteBftb(fn)
int     fn;
    {
#ifdef DEMOA

#else
    short       itxb;
    struct TXB *ptxb;

    for(itxb = 0 ; itxb < itxbMac ; itxb ++ )
        {
        ptxb = &(**hgtxb)[itxb];
        WriteRgch(fn, &(**(ptxb->hszName))[0], CchSz(**(ptxb->hszName)));
        ptxb = &(**hgtxb)[itxb];
        WriteRgch(fn, (CHAR *)&(ptxb->dcp), sizeof(typeCP));
        }
    WriteRgch(fn, "", sizeof(CHAR));
#endif /* DEMOA */
    }

#ifdef ENABLE
int CchCurGlosFile(pfld, pch, fNew, ival)
struct fld *pfld;
CHAR *pch;
int fNew, ival;
{
int cch;
extern CHAR (**hszGlosFile)[];

CleanBuffers();
CloseEveryRfnTB(true);
if((cch = CchSz(**hszGlosFile)-1) == 0)
        cch = CchFillSzId(pch, IDSTRGLYN);
else
        bltbyte(**hszGlosFile, pch, cch);
return(cch);
}
#endif  /* ENABLE */

#ifdef ENABLE
/* F N  N E W  F I L E */
ClearGlosBuf ()
{

                rgval[0] = HszCreate("");
                CmdXfBufClear();
                RecreateListbox(cidstrRsvd + itxbMac);
                return;
}
#endif      /* ENABLE */

#ifdef ENABLE
CloseEveryRfnTB(fRetry)
int fRetry;
    {
    int rfn;

    for(rfn = 0; rfn < rfnMac; rfn++)
        {
        if(dnrfn[rfn].fn != fnNil)
            CloseRfn( rfn );
        }
    }
#endif      /* ENABLE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\txb.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/*---------------------------------------------------------------------------
-- Structure: TXB
-- Description and Usage:
    Describes a buffer.  
    Maps the name of a buffer to the associated text, which is stored in 
	docBuffer.
-- Fields:
    hszName	- pointer to a null terminated string in the heap which is
		    the name of this buffer.
    cp		- location in docBuffer
    dcp		- amount of interest in docBuffer
----------------------------------------------------------------------------*/
struct TXB
    {
    CHAR (**hszName)[];
    typeCP	cp;
    typeCP	dcp;
    };


#define cbTxb (sizeof(struct TXB))
#define cwTxb (cbTxb / sizeof(int))
#define hszNil	(0)
#define cidstrRsvd (2)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\trans3.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* trans3.c: more save routines, moved here from trans2.c because of compiler
 heap space errors */

#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOMSG
#define NOKEYSTATE
#define NOSHOWWINDOW
//#define NOGDI
#define NOFONT
#define NOBRUSH
#define NOBITMAP
//#define NOATOM
#define NOMETAFILE
#define NOPEN
#define NOPOINT
#define NORECT
#define NOREGION
#define NOHRGN
#define NOCOLOR
#define NODRAWTEXT
//#define NOTEXTMETRIC
#define NOWINOFFSETS
#define NOCREATESTRUCT
#define NOWH
#define NOSOUND
#define NOSCROLL
#define NOCOMM
#define NOWNDCLASS
/* need memmgr, mb */
#include <windows.h>

#include "mw.h"
#include "doslib.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "editdefs.h"
#include "printdef.h"
#define NOSTRUNDO
#include "str.h"
#include "debug.h"
#include "fontdefs.h"
#include "dlgdefs.h"
#include "winddefs.h"
#include "macro.h"
#include "preload.h"
#include "io.h"
#if defined(OLE)
#include "obj.h"
#endif

#define WRITE_PERMISSION 02 /* flag to access() */

CHAR    *index( CHAR *, CHAR );
CHAR    *PchGetPn();
CHAR    *PchFromFc();
static int fOpenedFormatted = TRUE;
int   vfOldWriteFmt=FALSE;  /* delete objects before saving */
DoFileOpen( LPSTR );

BOOL CheckEnableButton(HANDLE, HANDLE);
BOOL NEAR PASCAL CanReadEveryFile(char *szFilename);

extern CHAR    szExtSearch[]; /* store default search spec */
extern CHAR szWriteProduct[];
extern CHAR szBackup[];
extern int vfTextOnlySave;

extern int         vfCursorVisible;
extern int         vfDiskError;
extern int         vfSysFull;
extern HWND        vhWndMsgBoxParent;
extern int         vfnWriting;
extern CHAR        (**vhrgbSave)[];
extern struct DOD      (**hpdocdod)[];
extern int         docCur;
extern int         docScrap;
extern int         docUndo;
extern struct FCB      (**hpfnfcb)[];
extern int         vfBuffersDirty;
extern int         vfDiskFull;
extern typeCP          vcpFetch;
extern CHAR        *vpchFetch;
extern int         vccpFetch;
extern typeCP          vcpLimParaCache;
extern int         vfDeactByOtherApp;
extern BOOL        vfWarnMargins;

#ifdef INTL /* International version */
extern int         vWordFmtMode;
#ifdef INEFFLOCKDOWN
extern FARPROC lpDialogWordCvt;
#else
extern BOOL far PASCAL DialogWordCvt(HWND, unsigned, WORD, LONG);
#endif
#endif  /* International version */

static unsigned wMerge;  /* for message merge code */

extern int         vfBackupSave;

extern int      ferror;
extern CHAR     szExtBackup[];
extern CHAR     (**hszTemp)[];
#ifdef INEFFLOCKDOWN
extern FARPROC lpDialogOpen;
extern FARPROC lpDialogSaveAs;
#endif


extern HANDLE  hMmwModInstance;
extern HANDLE  hParentWw;
extern HCURSOR vhcHourGlass;
extern HCURSOR vhcIBeam;
extern HCURSOR vhcArrow;

    /* Used in this module only */
static CHAR *pchSet;
static CHAR szUser[ cchMaxFile ]; /* store whatever is in idiOpenFile (ANSI) */

#define SF_OLDWRITE 0
#define SF_WORD     1
BOOL WannaDeletePictures(int doc, int fWhichFormat);
BOOL DocHasPictures(int doc);
NEAR DlgAddCorrectExtension(CHAR *, int);
BOOL  (NEAR FSearchSpec(CHAR *));
BOOL far PASCAL DialogOpen(HWND, unsigned, WORD, LONG);
BOOL far PASCAL DialogSaveAs(HWND, unsigned, WORD, LONG);


#ifdef INTL /* International version */
BOOL  FInWordFormat(int);
void ConvertFromWord();
#endif  /* International version */


fnOpenFile(LPSTR lpstrFileName) // filename may be NULL
{
 extern int vfCloseFilesInDialog;
 extern int docCur;
 extern HANDLE hMmwModInstance;
 extern HANDLE hParentWw;
 extern struct SEL selCur;
 extern typeCP cpMinDocument;

 /* Close all files on removable media for every message we get */
 vfCloseFilesInDialog = TRUE;

 /* Close all files on removable media so changing disks is safe */
 CloseEveryRfn( TRUE );

 /* test for dirty file and offer opportunity to save */

 if (FConfirmSave())
    DoFileOpen(lpstrFileName);

 vfCloseFilesInDialog = FALSE;
}

DoFileOpen( LPSTR lpstrFileName ) // filename may be NULL )
{
    /* return whether error.  Use CommDlg for open dialog (3.8.91) D. Kent */
    /* ********* International version changes bz 2/21/86 *************
    For files opened in Word format and converted to Write format
    the following changes are made:
       the vWordFmtMode flag is left set to CONVFROMWORD. The file is
       saved, effecting the change to Word format, but the original
       Word file in not renamed, so it is left untouched, with no need to
       make a backup. On the next save, we ask if the file with that name
       (the Word document) should be replaced, so any file with that
       name that existed will be protected.
    *************************************************************** */

    extern int vfDiskError;
    int fn=fnNil;
    int doc;
    CHAR (**hsz)[] = NULL;
    int nRetval=FALSE;
    CHAR rgch[cchMaxFile];
    extern DoOpenFilenameGet(LPSTR);
    BOOL bOpened=TRUE,      // ObjOpenedDoc has succeeded
         bCancelled=FALSE;

#ifdef INTL /* International version */
int fWordDoc;
#endif  /* International version */

    EnableOtherModeless(FALSE);

    /* prevent WM_PAINT from painting a doc that isn't defined */

    while(1)
    {
        bCancelled = FALSE;

        if (lpstrFileName)
            lstrcpy(rgch,lpstrFileName);
        else if (!DoOpenFilenameGet(rgch))
        {
            bCancelled = TRUE;
            goto KeepTrying;
        }
        else if (rgch[0] == '\0')
        {
            bCancelled = TRUE;
            goto KeepTrying;
        }

#if defined(OLE)
        if (bOpened) 
            if (ObjClosingDoc(docCur,rgch))
            /*  
                If this failed, then we could't close this document, much less
                open a new one.
            */
                break; // from while
            else
            /**
                At this point, docCur is OLE-closed!!!  Gotta be sure we
                open a new one!!! 
            **/
                bOpened = FALSE;
#endif


        if ((fn = FnOpenSz( rgch, dtyNormNoExt, FALSE)) == fnNil)
        /* this has side effect of setting &(**(**hpfnfcb) [fn].hszFile) [0] 
        to "normalized" filename. */
        {
            /* Open failed */
            goto KeepTrying;
        }
        else
        {   /* Opened file OK */
            /* Set caption to "Loading file..." */

            extern CHAR szLoadFile[];
            extern CHAR szCvtLoadFile[];

#ifdef INTL /* International version */
            /* **************************************
            * added check for international version to
                    do Word format conversion. If Word format,
                    bring up another dialog box.
            * ************************************** */

            /* TestWordCvt return values:

            -1 means dialog box failed (error already sent)
            -2 means cancel without conversion.
            FALSE means not a word document.
            TRUE means convert this word document.
            *** as of 2/14/86, we changed the conversion
            to not make a backup, but to save the file
            in write format without renaming the Word
            file, so the word file is effectively
            backed up under its original name. See
            CleanDoc in trans2.c for explanations.
            */

            switch ((fWordDoc = TestWordCvt (fn, hParentWw)))
            {
                case -2: // CANCEL
                    bCancelled = TRUE;
                    // fall through..

                case -1: // ERROR
                    /* Release this fn! */
                    FreeFn(fn);
                    CloseEveryRfn( TRUE );
                    goto KeepTrying;
            }

            /* if true, will convert soon */
            if (fWordDoc)
                {
                SetWindowText(hParentWw, (LPSTR)szCvtLoadFile);
                }
            else
#endif  /* International version */
                SetWindowText(hParentWw, (LPSTR)szLoadFile);

            StartLongOp();

            ReadFilePages( fn );
        }

        Assert( fn != fnNil );
        bltsz( &(**(**hpfnfcb) [fn].hszFile) [0], rgch );

        CchCopySz(rgch, szUser);

        hsz=NULL;

        if ( !FNoHeap(hsz = HszCreate( (PCH) rgch )) )
        {
            if ((doc = DocCreate( fn, hsz, dtyNormal )) != docNil)
            {   /* Succeeded in creating document */

                KillDoc( docCur );
                docCur = doc;
                hsz = NULL; // don't free cause used by doc

#ifdef INTL /* International version */
            /* if a word document to be converted, save it doing conversion. */
                if (fWordDoc)
                {
                    /* save file in write format. */
                    ConvertFromWord();
                    vfTextOnlySave = FALSE;
                    (**hpdocdod)[docCur].fDirty = TRUE;
                }
#endif  /* International version */

                ChangeWwDoc( szUser );
                /* Ensure that the margins of this document is right
                for the printer. */
                vfWarnMargins = TRUE;
                SetPageSize();
                vfWarnMargins = FALSE;
#if defined(OLE)
                if (ObjOpenedDoc(docCur)) 
                /* Couldn't open.  Must try to open a new one */
                    goto KeepTrying;
                else
                {
                    bOpened = TRUE;
                    break; // from while loop 'cause we're done
                }
#endif
            }
#if defined(JAPAN) || defined(KOREA)                  //  added  10 Jun. 1992  by Hiraisi
           else{
               bCancelled = TRUE;
               goto KeepTrying;
           }
#endif
        }

        KeepTrying:
        /* get to here either because error or cancelled */

        vfDiskError = ferror = FALSE;
        SetTitle( **(**hpdocdod)[ docCur ].hszFile );

        if (hsz)
        {
            FreeH( hsz );
            hsz=NULL;
        }

        CloseEveryRfn( TRUE );

        EndLongOp(vhcArrow);

        if (bCancelled)
        /* can't cancel unless we have an opened document */
        {
            if (!bOpened) // currently no open doc
            {
                if (bOpened = !ObjOpenedDoc(docCur)) // returns FALSE if success
                    break;
            }
            else
                break;
        }

    }  // end of while(1)


#if WINVER >= 0x300
    FreeUnreferencedFns();
#endif

    EndLongOp(vhcArrow);
    EnableOtherModeless(TRUE);
    return !bOpened;

} /* end of DoFileOpen */




fnSave()
{   /* Entry point for the "Save" command */
    extern int vfCloseFilesInDialog;
    extern int vfOutOfMemory;
    extern HANDLE vhReservedSpace;
                        
    struct DOD *pdod = &(**hpdocdod)[docCur];
    CHAR *psz = &(**(pdod->hszFile))[0];

    if (!CanReadEveryFile(psz))
        return;

#if WINVER >= 0x300
    if (pdod->fReadOnly)
        {
        /* Read-only doc: tell the user to save under a different name */

        Error( IDPMTReadOnly );
        ferror = FALSE; /* Not really an error */
        
        fnSaveAs();  /* May as well take them there now! ..pault 10/20/89 */
        }
    else if (psz [0] == '\0' || vWordFmtMode == CONVFROMWORD)
        /* Any time the user has converted the current Write document
           from a Word or Text document, we force them through the 
           FileSaveAs dlg box when Saving.  In this way we remind them
           that they might want to change the name -- but if they don't
           want to, that's ok and we'll not bother them any more about it
           (fnSaveAs dialog box will reset vWordFmtMode) ..pault 9/18/89 */
#else /* old windows */
    else if (psz [0] == '\0')
#endif
        fnSaveAs();
    else
        {

        if (vfOldWriteFmt || (vWordFmtMode & ~CONVFROMWORD) || vfTextOnlySave)
        /* then deleting pictures */
        {
            if (vfOldWriteFmt || vfTextOnlySave)
                vcObjects = ObjEnumInDoc(docCur,NULL);
            if (!WannaDeletePictures(docCur,vfOldWriteFmt ? SF_OLDWRITE : SF_WORD))
                return;
        }

        vfCloseFilesInDialog = TRUE;

        /* Close all files on removable media so changing disks is safe */

        CloseEveryRfn( TRUE );

        /* Free the reserved block, to give us memory for the save dialog box
           and for CmdXfSave */
        if (vhReservedSpace != NULL)
            {
            LocalFree(vhReservedSpace);
            vhReservedSpace = NULL;
            }

        PreloadSaveSegs();  /* Advance loading of code to avoid disk swaps */

        CmdXfSave(psz, pdod->fFormatted, pdod->fBackup, vhcIBeam);

        if (vfDiskFull || vfSysFull)
            ferror = FALSE;
#if defined(OLE)
        else
            ObjSavedDoc();
#endif

        if ((vhReservedSpace = LocalAlloc( LHND, cbReserve )) == NULL)
        /* we were unable to re-establish our block of reserved space. */
            Error(IDPMTNoMemory);

        vfCloseFilesInDialog = FALSE;
        }
}


fnSaveAs()
{   /* Entry point for the "Save As..." command */
extern int vfCloseFilesInDialog;
extern int vfOutOfMemory;
extern HANDLE vhReservedSpace;

    if (!CanReadEveryFile((**((**hpdocdod)[docCur].hszFile))))
        return;

    vfCloseFilesInDialog = TRUE;

    /* Close all files on removable media so changing disks is safe */
    CloseEveryRfn( TRUE );

    /* Free the reserved block, to give us memory for the save dialog box
       and for CmdXfSave */
    if (vhReservedSpace != NULL)
        {
        LocalFree(vhReservedSpace);
        vhReservedSpace = NULL;
        }

    PreloadSaveSegs();  /* Advance loading of code to avoid disk swaps */

    DoFileSaveAs();

     if ((vhReservedSpace = LocalAlloc( LHND, cbReserve )) == NULL)
        {   /* Either we were unable to bring up the save dialog
               box, or we were unable to re-establish our
               block of reserved space. */

#if WINVER >= 0x300
                    WinFailure();
#else
                    Error(IDPMTNoMemory);
#endif
        }

    UpdateInvalid();    /* Assure screen gets updated */

    vfCloseFilesInDialog = FALSE;
}


DoFileSaveAs(void)
{
    /* This routine handles input to the Save dialog box. */
    static CHAR szDefault[ cchMaxFile ];
    extern int vfTextOnlySave;
    extern DoSaveAsFilenameGet(LPSTR,LPSTR,int *,int *,int * ,int *);
    BOOL bDontDelPictures=FALSE;
    int fWordFmt, fTextOnly, fBackup, fOldWrite;
    CHAR szFullNameNewDoc[ cchMaxFile ];      // full name of selection
    CHAR szShortNameNewDoc[ cchMaxFile ];      // file name of selection
    CHAR szDocName[ cchMaxFile ];   // file name of current
    #define szFullNameCurDoc (**((**hpdocdod)[docCur].hszFile))  // full name of current
    #define pDod  ((struct DOD *)&(**hpdocdod)[docCur])

    {
        int cch = 0;
        CHAR szDOSPath[ cchMaxFile ];
        if (FNormSzFile( szDOSPath, "", dtyNormal ))
        {
            if ((cch=CchSz( szDOSPath )-2) > 2)
            {
                Assert( szDOSPath[ cch ] == '\\');
                szDOSPath [cch] = '\0';
            }

#if 0
            if (cch > 3)
                szDOSPath [cch] = '\\';
#endif
        }
        else
            szDOSPath[0] = '\0';

        if (szFullNameCurDoc [0] != '\0')
        {       /* Set default string for filename edit area */
            CHAR szDocPath[ cchMaxFile ];   // path to current

            FreezeHp();
            SplitSzFilename( szFullNameCurDoc, szDocPath, szDocName );

            /* Default filename does not include the document's path if
                it is == the current directory path */
            if (WCompSz( szDOSPath, szDocPath ) == 0)
                bltsz(szDocName, szDefault);
            else
                bltsz(szFullNameCurDoc, szDefault);

            MeltHp();
        }
        else
        {
            szDefault[0] = szDocName[0] = '\0';
        }
    }

    fTextOnly = vfTextOnlySave;
    fBackup = vfBackupSave;
    fWordFmt = vWordFmtMode & ~CONVFROMWORD;
    fOldWrite = vfOldWriteFmt;

    EnableOtherModeless(FALSE);

    while(1)
    {
    if (!DoSaveAsFilenameGet(szDefault,szFullNameNewDoc,&fBackup,&fTextOnly,&fWordFmt,&fOldWrite))
        goto end;
    else
    {
        int dty;

        if (szFullNameNewDoc[0] == '\0')
            goto end;

        if (fOldWrite || fWordFmt || fTextOnly)
        {
            if (!WannaDeletePictures(docCur,fOldWrite ? SF_OLDWRITE : SF_WORD))
                continue;
        }

        StartLongOp();

        szFileExtract(szFullNameNewDoc, szShortNameNewDoc);

#ifdef INTL /* International version */
        /* Read the "Microsoft Word Format" button */

        /* vWordFmtMode is used in WriteFn. If true, will convert
            to Word format, if false, no conversion is done.
            Another value, CONVFROMWORD, can be given during an open
            to allow saving a Word document in Write format. */

        if (fWordFmt)
        /* if set, make the default extension be doc instead of
            wri for word docs */

            dty = dtyWordDoc;
        else
#endif  /* International version */

        dty = dtyNormal;

#if WINVER >= 0x300            
/* Currently: FNormSzFile  *TAKES*   an OEM sz, and
                        *RETURNS*  an ANSI sz ..pault */
#endif
        if ( pDod->fReadOnly &&
                WCompSz( szFullNameNewDoc, szFullNameCurDoc ) == 0)
            {   /* Must save read-only file under a different name */
            Error( IDPMTReadOnly );
            goto NSerious;  /* Error not serious, stay in dialog */
            }
#if WINVER >= 0x300
        else if (WCompSz(szFullNameCurDoc, szFullNameNewDoc) == 0 &&
                    vWordFmtMode == CONVFROMWORD &&
                    vfTextOnlySave == fTextOnly)
            /* User has loaded a text file and is going
                to save under the same name without changing
                formats, *OR* has loaded a Word document and
                is going to save in the same format -- don't
                prompt "replace file?" ..pault 1/17/90 */
            ;
#endif
        else if ((WCompSz(szFullNameCurDoc, szFullNameNewDoc) != 0
#ifdef INTL /* International version */
                /* vWordFmtMode hasn't be reset yet */
                || ( vWordFmtMode == CONVFROMWORD)
#endif  /* International version */
                )
                && FExistsSzFile( dtyNormal, szFullNameNewDoc ) )
        {
            /* User changed the default string and specified
                a filename for which the file already exists.
                Or, we did a Word format conversion, forcing the .WRI
                extension on the file, and a file with that name
                exists.(International version only).o

                Note that vfWordFmtMode will be set to True or False
                below, so this check is made only on the first save
                after a Word conversion.

                Prompt to make sure it's ok to trash the existing one */

            CHAR szFileUp[ cchMaxFile  ];
            CHAR szUserOEM[cchMaxFile]; /* ..converted to OEM */
            CHAR szT[ cchMaxSz ];

            CchCopyUpperSz( szShortNameNewDoc, szFileUp );
            MergeStrings (IDSTRReplaceFile, szFileUp, szT);

#if WINVER >= 0x300
            /* access() expects OEM! */
            AnsiToOem((LPSTR) szFullNameNewDoc, (LPSTR) szUserOEM);

            /* Make sure we don't let someone try to save to 
                a file to which we do not have r/w permission */
            Diag(CommSzNum("fnSaveAs: access(write_perm)==", access(szUserOEM, WRITE_PERMISSION)));
            Diag(CommSzNum("          szExists()==", FExistsSzFile( dtyNormal, szFullNameNewDoc )));
            if (access(szUserOEM, WRITE_PERMISSION) == -1)
                {
                /* THIS COULD BE A CASE OF WRITING TO A FILE
                    WITH R/O ATTRIBUTE, *OR* A SHARING ERROR!
                    IMPROVE ERROR MESSAGE HERE ..pault 11/2/89 */                                
                //Error( IDPMTSDE2 );
                Error( IDPMTReadOnly );
                goto NSerious;  /* Error not serious, stay in dialog */
                }
#endif
            }

            vfTextOnlySave = fTextOnly;
            vfBackupSave = fBackup;
            vfOldWriteFmt = fOldWrite;

#ifdef INTL /* International version */
        /* vWordFmtMode is used in WriteFn. If true, will convert
            to Word format, if false, no conversion is done.
            Another value, CONVFROMWORD, can be given during an open
            to allow saving a Word document in Write format. */

            vWordFmtMode = fWordFmt;

#endif  /* International version */

        /* Record whether a backup was made or not. */

        WriteProfileString( (LPSTR)szWriteProduct, (LPSTR)szBackup,
                vfBackupSave ? (LPSTR)"1" : (LPSTR)"0" );

        /* Save the document */

        CmdXfSave( szFullNameNewDoc,!vfTextOnlySave, vfBackupSave, vhcArrow);

        if (vfDiskFull || vfSysFull)
            goto NSerious;

        /* Case 1: Serious error. Leave the dialog. */
        if (vfDiskError)
        {
            EndLongOp( vhcArrow );
            goto end;
        }

        /* Case 2: Saved OK: set the new title, leave the dialog. */
        else if (!WCompSz( szFullNameNewDoc, szFullNameCurDoc ))
            {
#if defined(OLE)
            ObjRenamedDoc(szFullNameNewDoc);
            ObjSavedDoc();
#endif

            SetTitle(szShortNameNewDoc);
#if WINVER >= 0x300
            FreeUnreferencedFns();
#endif

            /* Update the fReadOnly attribute (9.10.91) v-dougk */
            pDod->fReadOnly = FALSE; // can't be readonly if just saved

            EndLongOp( vhcArrow );
            goto end;
            }

        /* Case 3: Nonserious error (disk full, bad path, etc.).
                stay in dialog. */
        else
            {
NSerious:
            ferror = FALSE;
            EndLongOp( vhcArrow );
StayInDialog:
            CloseEveryRfn( TRUE );
            }
    }
    } // end of while(1)


    end:
    EnableOtherModeless(FALSE);


} /* end of DoFileSaveAs */


#ifdef INTL /* International version */

BOOL far PASCAL DialogWordCvt( hDlg, code, wParam, lParam )
HWND    hDlg;           /* Handle to the dialog box */
unsigned code;
WORD wParam;
LONG lParam;
{

    /* This routine handles input to the Convert From Word Format dialog box. */

 switch (code) {

 case WM_INITDIALOG:
     {
     char szFileDescrip[cchMaxSz];
     char szPrompt[cchMaxSz];

       /* do not allow no convert for formatted file */
     if (fOpenedFormatted)
         {
         //EnableWindow(GetDlgItem(hDlg, idiNo), false);
         PchFillPchId(szFileDescrip, IDSTRConvertWord, sizeof(szFileDescrip));
         }
     else
         PchFillPchId(szFileDescrip, IDSTRConvertText, sizeof(szFileDescrip));
         
     MergeStrings(IDPMTConvert, szFileDescrip, szPrompt);
     SetDlgItemText(hDlg, idiConvertPrompt, (LPSTR)szPrompt);
     EnableOtherModeless(FALSE);
     break;
     }

 case WM_SETVISIBLE:
    if (wParam)
        EndLongOp(vhcArrow);
    return(FALSE);

 case WM_ACTIVATE:
    if (wParam)
        vhWndMsgBoxParent = hDlg;
    if (vfCursorVisible)
        ShowCursor(wParam);
    return(FALSE); /* so that we leave the activate message to the dialog
              manager to take care of setting the focus correctly */

 case WM_COMMAND:
    switch (wParam) {

              /* return one of these values:
                 idiOk - convert
                 idiCancel - cancel, no conversion
                 idiNo - read in without conversion */

        case idiNo: /* User hit the "No Conversion" button */
            if (!IsWindowEnabled(GetDlgItem(hDlg, idiNo)))
        /* No convert is grayed -- ignore */
                return(TRUE);
             /* fall in */
    case idiOk:     /* User hit the "Convert" button */
    case idiCancel:
            break;
    default:
            return(FALSE);
    }
      /* here after ok, cancel, no */
     OurEndDialog(hDlg, wParam);
     break;

 default:
    return(FALSE);
 }
 return(TRUE);
} /* end of DialogWordCvt */

/* International version */
#else
BOOL far PASCAL DialogWordCvt( hDlg, code, wParam, lParam )
HWND    hDlg;           /* Handle to the dialog box */
unsigned code;
WORD wParam;
LONG lParam;
{
    Assert(FALSE);
} /* end of DialogWordCvt */
#endif /* Non Iternational version */




IdConfirmDirty()
{   /* Put up a message box saying docCur "Has changed. Save changes?
       Yes/No/Cancel". Return IDYES, IDNO, or IDCANCEL. */
 extern HWND vhWnd;
 extern CHAR szUntitled[];
 extern HANDLE   hszDirtyDoc;
 LPSTR szTmp = MAKELP(hszDirtyDoc,0);
 CHAR szPath[ cchMaxFile ];
 CHAR szName[ cchMaxFile ];
 CHAR szMsg[ cchMaxSz ];
 CHAR (**hszFile)[]=(**hpdocdod)[docCur].hszFile;

 if ((**hszFile)[0] == '\0')
    CchCopySz( szUntitled, szName );
 else
    SplitSzFilename( *hszFile, szPath, szName );

 wsprintf(szMsg,szTmp,(LPSTR)szName);

 return IdPromptBoxSz( vhWnd, szMsg, MB_YESNOCANCEL | MB_ICONEXCLAMATION );
}




SplitSzFilename( szFile, szPath, szName )
CHAR *szFile;
CHAR *szPath;
CHAR *szName;
{   /* Split a normalized filename into path and bare name components.
       By the rules of normalized filenames, the path will have a drive
       letter, and the name will have an extension. If the name is null,
       we provide the default DOS path and a null szName */

 szPath [0] = '\0';
 szName [0] = '\0';

 if (szFile[0] == '\0')
    {
#if WINVER >= 0x300
    /* Currently: FNormSzFile  *TAKES*   an OEM sz, and
                              *RETURNS*  an ANSI sz ..pault */
#endif
    FNormSzFile( szPath, "", dtyNormal ); /* Use default DOS drive & path */
    }
 else
    {
    CHAR *pch;
    int cch;

    lstrcpy(szPath,(LPSTR)szFile);

    pch = szPath + lstrlen(szPath) - 1; // point to last character

#ifdef	DBCS
    while (pch != szPath) {
        CHAR    *szptr;
        szptr = (CHAR near *)AnsiPrev(szPath,pch);
        if (*szptr == '\\')
            break;
        else
                pch = szptr;
    }
#else   /* DBCS */
    while (pch != szPath)
        if (*(pch-1) == '\\')
            break;
        else
            --pch;

#endif

    lstrcpy(szName,(LPSTR)pch);

#ifdef DBCS
#if !defined(TAIWAN) &&  !defined(PRC)
    pch=(CHAR near *)AnsiPrev(szPath,pch);
    *pch = '\0';
#endif
#else
    *(pch-1) = '\0';
#endif

    }
}


BOOL CheckEnableButton(hCtlEdit, hCtlEnable)
HANDLE hCtlEdit;   /* handle to edit item */
HANDLE hCtlEnable; /* handle to control which is to enable or disable */
{
register BOOL fEnable = SendMessage(hCtlEdit, WM_GETTEXTLENGTH, 0, 0L);

    EnableWindow(hCtlEnable, fEnable);
    return(fEnable);
} /* end of CheckEnableButton */




/***        FDeleteFn - Delete a file
 *
 *
 *
 */

int FDeleteFn(fn)
int fn;
{   /* Delete a file & free its fn slot */
    /* Returns TRUE if the file was successfully deleted or if it was not
       found in the first place; FALSE if the file exists but
       cannot be deleted */

int f = FALSE;

if (FEnsureOnLineFn( fn ))  /* Ensure disk w/ file is in drive */
    {
    CloseFn( fn );  /* Ensure file closed */

    f = FDeleteFile( &(**(**hpfnfcb) [fn].hszFile) [0] );
    }

FreeFn( fn );   /* We free the fn even if the file delete failed */

return f;
}



FDeleteFile( szFileName )
CHAR szFileName[];
{   /* Delete szFilename. Return TRUE if the file was deleted,
       or there was no file by that name; FALSE otherwise.
       Before deleting the file, we ask all other WRITE instances whether
       they need it; if one does, we do not delete and return FALSE */

HANDLE HszGlobalCreate( CHAR * );
int fpe=0;
int fOk;
ATOM a;

if ((a = GlobalAddAtom( szFileName )) != NULL)
    {
    fOk = WBroadcastMsg( wWndMsgDeleteFile, a, (LONG) 0, FALSE );
    if (fOk)
    {   /* Ok to delete, no other instance needs it */
    fpe = FpeDeleteSzFfname( szFileName );
    }
#ifdef DEBUG
     else
     Assert( !FIsErrFpe( fpe ) );
#endif
    GlobalDeleteAtom( a );
    }

    /* OK if: (1) Deleted OK  (2) Error was "File not found" */
return (!FIsErrFpe(fpe)) || fpe == fpeFnfError;
}




FDeleteFileMessage( a )
ATOM a;
{   /* We are being notified that the file hName is being deleted.
       a is a global atom.  (Was global handle before fixing for NT 3.5)
       Return TRUE = Ok to delete; FALSE = Don't delete, this instance
        needs the file */

 LPCH lpch;
 CHAR sz[ cchMaxFile ];

 Scribble( 5, 'D' );

 if (GlobalGetAtomName( a, sz, sizeof(sz)) != 0)
    {
    if (FnFromSz( sz ) != fnNil)
       {
       Scribble( 4, 'F' );
       return FALSE;
       }
    }

 Scribble( 4, 'T' );
 return TRUE;
}




/***        FpeRenameFile - rename a file
 *
 */

int FpeRenameFile(szFileCur, szFileNew) /* Both filenames expected in ANSI */
CHAR *szFileCur, *szFileNew;
{
   /* Rename a file.  Return fpeNoErr if successful; error code if not. */
int fn = FnFromSz( szFileCur );
int fpe;
CHAR (**hsz)[];
HANDLE hName;
HANDLE hNewName;

#if WINVER >= 0x300
/* The szPathName field in rgbOpenFileBuf is now treated as OEM
   as opposed to ANSI, so we must do a conversion.  12/5/89..pault */
CHAR szFileOem[cchMaxFile];
AnsiToOem((LPSTR)szFileNew, (LPSTR)szFileOem);
#define sz4OpenFile szFileOem
#else
#define sz4OpenFile szFileNew
#endif

/* If this is a file we know about, try to make sure it's on line */

if (fn != fnNil)
    if (FEnsureOnLineFn( fn ))
    {
    FFlushFn( fn ); /* just in case */
    CloseFn( fn );
    }
    else
    return fpeHardError;

/* if the file exists on disk then try to rename it */
if (szFileCur[0] != 0 && FExistsSzFile(dtyAny, szFileCur))
    {
    int fpe=FpeRenameSzFfname( szFileCur, szFileNew );

    if ( FIsErrFpe( fpe ) )
        /* Rename failed -- return error code */
        return fpe;
    }
else
    return fpeNoErr;

    /* Inform other instances of WRITE */
if ((hName = HszGlobalCreate( szFileCur )) != NULL)
    {
    if ((hNewName = HszGlobalCreate( szFileNew )) != NULL)
    {
    WBroadcastMsg( wWndMsgRenameFile, hName, (LONG)hNewName, -1 );
    GlobalFree( hNewName );
    }
    GlobalFree( hName );
    }

if (fn != fnNil)
    { /* Rename current FCB for file if there is one */
    struct FCB *pfcb;

    FreeH((**hpfnfcb)[fn].hszFile);
    hsz = HszCreate((PCH)szFileNew);
    pfcb = &(**hpfnfcb) [fn];
    pfcb->hszFile = hsz;

    bltbyte( sz4OpenFile, ((POFSTRUCT)pfcb->rgbOpenFileBuf)->szPathName,
         umin( CchSz( sz4OpenFile ), cchMaxFile ) );

#ifdef DFILE
CommSzSz("FpeRenameFile  szFileNew==",szFileNew);
CommSzSz("               szFileCur==",szFileCur);
CommSzSz("               szFileNewOem==",szFileOem);
#endif

#ifdef ENABLE
    pfcb->fOpened = FALSE;  /* Signal OpenFile that it must open
                   from scratch, not OF_REOPEN */
#endif
    }

return fpeNoErr;
}




RenameFileMessage( hName, hNewName )
HANDLE hName;
HANDLE hNewName;
{   /* We are being notified by another instance of WRITE that the name
       of file hName is being changed to hNewName.  hName and hNewName
       are WINDOWS global handles */

 LPCH lpchName;
 LPCH lpchNewName;

 Scribble( 5, 'R' );
 Scribble( 4, ' ' );

 if ((lpchName = GlobalLock( hName )) != NULL)
    {
    if ((lpchNewName = GlobalLock( hNewName )) != NULL)
    {
    CHAR (**hsz) [];
    CHAR szName[ cchMaxFile ];
    CHAR szNewName[ cchMaxFile ];
    int fn;

    bltszx( lpchName, (LPCH) szName );
    bltszx( lpchNewName, (LPCH) szNewName );

    if ((fn=FnFromSz( szName )) != fnNil &&
        !FNoHeap(hsz = HszCreate( szNewName )))
        {
#if WINVER >= 0x300
        /* The szPathName field in rgbOpenFileBuf is now treated as OEM
           as opposed to ANSI, so we must do a conversion.  12/5/89..pault */
        CHAR szNewOem[cchMaxFile];
        AnsiToOem((LPSTR)szNewName, (LPSTR)szNewOem);
        bltsz( szNewOem, ((POFSTRUCT)((**hpfnfcb) [fn].rgbOpenFileBuf))->szPathName );
#else
        bltsz( szNewName, ((POFSTRUCT)((**hpfnfcb) [fn].rgbOpenFileBuf))->szPathName );
#endif

#ifdef ENABLE
        (**hpfnfcb) [fn].fOpened = FALSE;
#endif
        FreeH( (**hpfnfcb) [fn].hszFile );
        (**hpfnfcb) [fn].hszFile = hsz;
        }
    GlobalUnlock( hNewName );
    }
    GlobalUnlock( hName );
    }
}




#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif

STATIC int messageBR;
STATIC WORD wParamBR;
STATIC LONG lParamBR;
STATIC int wStopBR;

STATIC int wResponseBR;

STATIC FARPROC lpEnumAll=NULL;
STATIC FARPROC lpEnumChild=NULL;


WBroadcastMsg( message, wParam, lParam, wStop )
int message;
WORD wParam;
LONG lParam;
WORD wStop;
{   /* Send a message to the document child windows (MDOC) of all
       currently active instances of WRITE (except ourselves).
       Continue sending until all instances have been notified, or until
       one returns the value wStop as a response to the message.
       Return the response given by the last window notified, or
       -1 if no other instances of WRITE were found */

extern HANDLE hMmwModInstance;
int FAR PASCAL BroadcastAllEnum( HWND, LONG );
int FAR PASCAL BroadcastChildEnum( HWND, LONG );

 messageBR = message;
 wParamBR = wParam;
 lParamBR = lParam;
 wStopBR = wStop;
 wResponseBR = -1;

 if (lpEnumAll == NULL)
    {
    lpEnumAll = MakeProcInstance( (FARPROC) BroadcastAllEnum, hMmwModInstance );
    lpEnumChild = MakeProcInstance( (FARPROC) BroadcastChildEnum, hMmwModInstance );
    }

 EnumWindows( lpEnumAll, (LONG)0 );
 return wResponseBR;
}



int FAR PASCAL BroadcastAllEnum( hwnd, lParam )
HWND hwnd;
LONG lParam;
{   /* If hwnd has the class of a WRITE parent (menu) window, call
       (*lpEnumChild)() for each of its children and return
       the value returned by EnumChildWindows
       If the window does not have the class of a WRITE parent, do nothing
       and return TRUE */
 extern CHAR szParentClass[];
 extern HWND hParentWw;

 if ( (hwnd != hParentWw) && FSameClassHwndSz( hwnd, szParentClass ) )
    return EnumChildWindows( hwnd, lpEnumChild, (LONG) 0 );
 else
    return TRUE;
}



int FAR PASCAL BroadcastChildEnum( hwnd, lParam )
HWND hwnd;
LONG lParam;
{   /* If hwnd is of the same class as a WRITE child (document) window,
       send the message { messageBR, wParamBR, lParamBR } to it, else
       return TRUE;
       If the message is sent, return FALSE if the message return value
       matched wStopBR; TRUE if it did not match.
       Set wMessageBR to the message return value.
    */
 extern CHAR szDocClass[];
 extern HWND vhWnd;

 Assert( hwnd != vhWnd );

 if (FSameClassHwndSz( hwnd, szDocClass ))
    {   /* WRITE DOCUMENT WINDOW: pass message along */
    wResponseBR = SendMessage( hwnd, messageBR, wParamBR, lParamBR );
    return wResponseBR != wStopBR;
    }
 else
    return TRUE;
}



FSameClassHwndSz( hwnd, szClass )
HWND hwnd;
CHAR szClass[];
{   /* Compare the Class name of hWnd with szClass; return TRUE
       if they match, FALSE otherwise. */

#define cchClassMax 40  /* longest class name (for compare purposes) */

 CHAR rgchWndClass[ cchClassMax ];
 int cbCopied;

    /* Count returned by GetClassName does not include terminator */
    /* But, the count passed in to it does. */
 cbCopied = GetClassName( hwnd, (LPSTR) rgchWndClass, cchClassMax ) + 1;
 if (cbCopied <= 1)
    return FALSE;

 rgchWndClass[ cbCopied - 1 ] = '\0';

 return WCompSz( rgchWndClass, szClass ) == 0;
}


FConfirmSave()
{   /* Give the user the opportunity to save docCur, if it is dirty.
       Return 1 - Document Saved OR user elected not to save changes
              OR document was not dirty
          0 - User selected "Cancel" or Error during SAVE */
extern HANDLE hMmwModInstance;
extern HANDLE hParentWw;
extern int vfTextOnlySave, vfBackupSave;
struct DOD *pdod=&(**hpdocdod)[docCur];

#if defined(OLE)
    if (CloseUnfinishedObjects(FALSE) == FALSE)
        return FALSE;
#endif

 if (pdod->fDirty)
    {   /* doc has been edited, offer confirm/save before quitting */
    switch ( IdConfirmDirty() )
    {
    case IDYES:
        {
#if 0
#if defined(OLE)
    if (CloseUnfinishedObjects(TRUE) == FALSE)
        return FALSE;
#endif
#endif

        if ( (**(pdod->hszFile))[0] == '\0' )
        goto SaveAs;

#ifdef INTL /* International version */
         /* if saving after a Word conversion, bring up dialog
        box to allow backup/ rename. */

        else if ( vWordFmtMode == CONVFROMWORD)
        goto SaveAs;
#endif /* International version */

        else if (pdod->fReadOnly)
        {
        extern int ferror;

        /* Read-only doc: tell the user to save under a different name */

        Error( IDPMTReadOnly );
        ferror = FALSE; /* Not really an error */

SaveAs:
        fnSaveAs(); /* Bring up "save as" dialog box */
        pdod = &(**hpdocdod)[docCur];
        if (pdod->fDirty)
            /* Save failed or was aborted */
            return FALSE;
        }
        else
        {
            CmdXfSave( *pdod->hszFile, !vfTextOnlySave, vfBackupSave, vhcArrow);

#if defined(OLE)
            if (!ferror)
                ObjSavedDoc();
#endif
        }
        if (ferror)
            /* Don't quit if we got a disk full error */
            return FALSE;
        }
        break;

    case IDNO:
#if 0
#if defined(OLE)
        if (CloseUnfinishedObjects(FALSE) == FALSE)
            return FALSE;
#endif
#endif
        break;

    case IDCANCEL:
    default:
        return FALSE;
    }
    }
#if 0
#if defined(OLE)
 else /* not dirty */
    if (CloseUnfinishedObjects(FALSE) == FALSE)
        return FALSE;
#endif
#endif

 return TRUE;
}




PreloadSaveSegs()
{
#ifdef GREGC /* kludge to get around the windows kernel bug for now */
    LoadF( PurgeTemps );      /* TRANS4 */
    LoadF( IbpEnsureValid );  /* FILE (includes doslib) */
    LoadF( FnCreateSz );      /* CREATEWW */
    LoadF( ClobberDoc );      /* EDIT */
    LoadF( FNormSzFile );     /* FILEUTIL */
    LoadF( CmdXfSave );   /* TRANS2 */
#endif
}




int CchCopyUpperSz(pch1, pch2)
register PCH pch1;
register PCH pch2;
{
int cch = 0;
while ((*pch2 = ChUpper(*pch1++)) != 0)
    {
#ifdef  DBCS    /* KenjiK '90-11-20 */
        if(IsDBCSLeadByte(*pch2))
        {
                pch2++;
                *pch2 = *pch1++;
                cch++;
        }
#endif
    pch2++;
    cch++;
    }
return cch;
} /* end of  C c h C o p y U p p e r S z  */

#ifdef DBCS     // AnsiNext for near call.
static  char NEAR *MyAnsiNext(char *sz)
{
        if(!*sz)                                return sz;

        sz++;
        if(IsDBCSLeadByte(*sz)) return (sz+1);
        else                                    return sz;
}
#endif

#if 0
/* ** Given filename or partial filename or search spec or partial
      search spec, add appropriate extension. */

/*
   fSearching is true when we want to add \*.DOC to the string -
   i.e., we are seeing if string szEdit is a directory. If the string
   is .. or ends in: or \, we know we have a directory name, not a file
   name, and so add \*.DOC or *.DOC to the string. Otherwise, if
   fSearching is true ans szEdit has no wildcard characters,
   add \*.DOC to the string, even if the string contains a period
   (directories can have extensions). If fSearching is false, we will
   add .DOC to the string if no period is found in the last file/directory
   name.

   Note the implicit assumption here that \ and not / will be used as the
   path character. It is held in the defined variable PATHCHAR, but we
   don't handle DOS setups where the / is path and - is the switch character.
*/

#define PATHCHAR ('\\')

NEAR DlgAddCorrectExtension(szEdit, fSearching)
CHAR    *szEdit;
BOOL    fSearching;
{
    register CHAR *pchLast;
    register CHAR *pchT;
    int ichExt;
    BOOL    fDone = FALSE;
    int     cchEdit;

    pchT = pchLast = (szEdit + (cchEdit = CchSz(szEdit) - 1) - 1);

    /* Is szEdit a drive letter followed by a colon (not a filename) ? */
    if (cchEdit == 2
         && *pchLast == ':')
        /* don't use 0 or will interpret "z:" incorrectly as "z:\" ..pault */
        ichExt = 1;
    /* how about ".." (also not a file name)? */
    else if (cchEdit == 2
         && (*pchLast == '.' && *(pchLast-1) == '.'))
        ichExt = 0;
    else if (*pchLast == PATHCHAR)  /* path character */
    ichExt = 1;
    else
    {
        if (fSearching)
            {
             /* any wild card chars? if so, is really a file name */
            if (FSearchSpec(szEdit))
                return;
            ichExt = 0;
            }
        else
            {
            ichExt = 2;
            for (; pchT > szEdit; pchT--) {
                if (*pchT == '.') {
                return;
                }
                if (*pchT == PATHCHAR) {
                /* path character */
                break;
                }
                }
            }

    }
    if (CchSz(szExtSearch+ichExt) + cchEdit > cchMaxFile)
        Error(IDPMTBadFilename);
    else
#ifdef DBCS
        CchCopySz((szExtSearch+ichExt), AnsiNext(pchLast));
#else
        CchCopySz((szExtSearch+ichExt), (pchLast+1));
#endif
}


/* ** return TRUE iff 0 terminated string contains a '*' or '\' */
BOOL  (NEAR FSearchSpec(sz))
register CHAR *sz;
{

#ifdef DBCS
    for (; *sz;sz=AnsiNext(sz)) {
#else
    for (; *sz;sz++) {
#endif
    if (*sz == '*' || *sz == '?')
        return TRUE;
    }
    return FALSE;
}

#endif

szFileExtract(szNormFileName, szExtFileName)
CHAR *szNormFileName; /* input: normalized file name */
CHAR *szExtFileName;  /* output: simple file name with extension added to */
{
    CHAR *pchLast, *pchT;
#ifdef  DBCS    /* KenjiK(MSKK) '90-11-20 */
        for(pchT=szNormFileName;*pchT;pchT++);
        pchLast = pchT;
        do {
                pchT = AnsiPrev(szNormFileName,pchT);
                if (*pchT == '\\')
                        break;
        } while(pchT > szNormFileName);

#else   /* not DBCS */

    pchLast = pchT = szNormFileName + CchSz(szNormFileName) - 1;

    while (pchT > szNormFileName)
    {
    if (*pchT == '\\')
        break;
    pchT --;
    }
#endif

    bltbyte(pchT + 1, szExtFileName, pchLast - pchT);
    //DlgAddCorrectExtension(szExtFileName, FALSE);
}




#ifdef INTL /* International version */

/* ** return TRUE if file opened is in Microsoft Word format */
BOOL  FInWordFormat(fn)
int fn;
{
register struct FCB *pfcb;
int cchT;
       /* Assumption: this routine has been called after FnOpenSz, which
      has already determined whether the file is formatted,
      and if the pnMac entry was 0, it set pnMac to be the same
      as pnFfntb in the file's fcb. So a Word file is a formatted
      file whose pnMac and pnFfntb are the same.

      We are also pretending that unformatted files are word format files
      so we will bring up a dialog box allowing character set conversion. */

    pfcb = &(**hpfnfcb)[fn];
    if (pfcb->fFormatted == false)  /* unformatted treated as a word file */
    return (true);

    return (pfcb->pnMac == pfcb->pnFfntb);
}
#endif  /* International version */


#ifdef INTL /* International version */
void ConvertFromWord ()
{

    /* vWordFmtMode is used by FnWriteFile to translate the
       Word file character set to ANSI. We leave it set to
       CONVFROMWORD so that the next save can check if there was a
       file with extension of szExtDoc.If there is no such file,
       vWordFmtMode is set to true or false by the save dialog code.

       *** as of 2/14/86, no backup is made, but code in CleanDoc checks for
       vWordFmtMode=CONVFROMWORD, and saves without renaming the word
       file instead of making an optional backup

       *** as of 12/3/89, FreeUnreferencedFns() is removing the
       lock on files not referenced by pieces in any documents, so
       the word doc or text file being converted FROM is not being
       "locked" and another app can grab it!  I'm correcting this
       in FreeUnreferencedFns() ..pault
     */

    extern CHAR szExtDoc[];
    struct DOD *pdod=&(**hpdocdod)[docCur];

    vWordFmtMode = CONVFROMWORD;  /* will stay this value until save */
    vfBackupSave = 1;  /* force next save to default to backing up */
      /* always a formatted save, no backup. */
    CmdXfSave( *pdod->hszFile, true, false, vhcArrow);

#if defined(OLE)
    if (!ferror)
        ObjSavedDoc();
#endif
}
#endif  /* International version */


#ifdef INTL /* International version */
TestWordCvt (fn, hWnd)
int fn;
HWND   hWnd;
{
int wordVal;
#ifndef INEFFLOCKDOWN
FARPROC lpDialogWordCvt = MakeProcInstance(DialogWordCvt, hMmwModInstance);
    if (!lpDialogWordCvt)
        {
        WinFailure();
        return(fFalse);
        }
#endif

/* This routine returns the following values:
-1 means dialog box failed (error already sent)
-2 means cancel without conversion.
FALSE means not a word document.
TRUE means convert this word document.
Its parent may change depending on the caller.
*/

if (!(wordVal = FInWordFormat (fn)))
return (FALSE);   /* not a word doc */

/* in word format - ask for conversion */
/* the cvt to word dialog returns 3 values
  other than -1:
     idiOk - convert
     idiCancel - cancel, no conversion
     idiNo - read in without conversion
     vfBackupSave set to reflect whether backup is made */
  /* Note it is a child of this dialog */

fOpenedFormatted = (**hpfnfcb)[fn].fFormatted;  /* used in dialog func */

#ifdef DBCS             /* was in KKBUGFIX */
// [yutakan:05/17/91] (I don't know why) sometimes hWnd would be invalid.
if (!IsWindow(hWnd))    hWnd = hParentWw;
#endif

if ((wordVal = (OurDialogBox( hMmwModInstance,
    MAKEINTRESOURCE(dlgWordCvt), hWnd,
    lpDialogWordCvt))) == -1)
    {
#if WINVER >= 0x300
    WinFailure();
#else
    Error(IDPMTNoMemory);
#endif
        }

#ifndef INEFFLOCKDOWN
    FreeProcInstance(lpDialogWordCvt);
#endif

      /* return -1 if either out of memory or no conversion desired */
      /* will convert an unformatted file if No is the dialog response */
    switch (wordVal)

        {
        case idiNo: /* User hit the "No Conversion" button */
            return(FALSE);  /* treat as non-word file */
        case idiOk: /* User hit the "Convert" button */
            return(TRUE);

        case idiCancel:
            return (-2);

        case -1:
        default:
            return (-1);
        }

}
#endif  /* Kanji / International version */


/* ********** routines for doing message relocation ******* */

VOID MergeInit()
/* get merge spec, guaranteed to be 2 characters, into variable wMerge */
{
char sz[10];

        PchFillPchId( sz, IDS_MERGE1, sizeof(sz) );
        wMerge = *(unsigned *)sz;
}


BOOL MergeStrings (idSrc, szMerge, szDst)
IDPMT idSrc;
CHAR *szMerge;
CHAR *szDst;
{
/* get message from idSrc. Scan it for merge spec. If found, insert string
   szMerge at that point, then append the rest of the message. NOTE!
   merge spec guaranteed to be 2 characters. wMerge loaded at init by
   MergeInit. Returns true if merge done, false otherwise.
*/

CHAR szSrc[cchMaxSz];
register CHAR *pchSrc;
register CHAR *pchDst;

/* get message from resource file */

    PchFillPchId( szSrc, idSrc, sizeof(szSrc) );
    pchSrc = szSrc;
    pchDst = szDst;

    /* find merge spec if any */

    while (*(unsigned *)pchSrc != wMerge)
    {
    *pchDst++ = *pchSrc;

    /* if we reach the end of string before merge spec, just return false */

    if (!*pchSrc++)
        return FALSE;
    }


     /* if merge spec found, insert szMerge there. (check for null merge str */

     if (szMerge)
     while (*szMerge)
         *pchDst++ = *szMerge++;

    /* jump over merge spec */
     pchSrc++;
     pchSrc++;

     /* append rest of string */

     while (*pchDst++ = *pchSrc++)
     ;
     return TRUE;

}

#include "propdefs.h"
BOOL DocHasPictures(int doc)
{
    extern struct PAP      vpapAbs;
    typeCP cpMac = CpMacText(doc),cpNow;
    for ( cpNow = cp0; cpNow < cpMac; cpNow = vcpLimParaCache )
    {
        CachePara( doc, cpNow );
        if (vpapAbs.fGraphics)
            return TRUE;
    }
    return FALSE;
}

BOOL WannaDeletePictures(int doc, int fWhichFormat)
/* assume if SF_OLDWRITE that vcObjects is set */
{
    CHAR szBuf[cchMaxSz];
    BOOL bDoPrompt;

    if (fWhichFormat == SF_OLDWRITE)
    /* warn that OLE pictures will be deleted */
    {
        if (bDoPrompt = (vcObjects > 0))
            PchFillPchId( szBuf, IDPMTDelObjects, sizeof(szBuf) );
    }
    else if (fWhichFormat == SF_WORD)
    /* warn that all pictures will be deleted */
    {
        if (bDoPrompt = DocHasPictures(docCur))
            PchFillPchId( szBuf, IDPMTDelPicture, sizeof(szBuf) );
    }
    else
        return TRUE;

    if (bDoPrompt)
        return (IdPromptBoxSz( vhWnd, szBuf, MB_YESNO | MB_ICONEXCLAMATION ) == IDYES);
    else
        return TRUE;
}

BOOL NEAR PASCAL CanReadEveryFile(char *szFilename)
{
    extern int fnMac;
    int fn;
    BOOL bRetval=TRUE;

    FreezeHp();
    for (fn = 0; fn < fnMac; fn++)
    {
        if ((**hpfnfcb)[fn].fDisableRead)
        {
            /* see if still can't read */
            if (!FAccessFn( fn, dtyNormal ))
            {
                char szMsg[cchMaxSz];
                ferror = FALSE;
                MergeStrings (IDPMTCantRead, szFilename, szMsg);
                IdPromptBoxSz(vhWndMsgBoxParent ? vhWndMsgBoxParent : hParentWw,
                                szMsg, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
                {
                    bRetval = FALSE;
                    break;
                }
            }
        }
    }

    MeltHp();
    return bRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\trans4.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* trans4.c -- routines brought from trans2.c due to compiler stack overflow */

#define NOWINMESSAGES
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOGDI
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "doslib.h"
#include "propdefs.h"
#define NOUAC
#include "cmddefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "fkpdefs.h"
#include "editdefs.h"
#include "printdef.h"
#define NOKCCODES
#include "ch.h"
#define NOSTRUNDO
#define NOSTRERRORS
#include "str.h"
#include "debug.h"
#include "fontdefs.h"


CHAR    *PchGetPn();
CHAR    *PchFromFc();
typePN  PnAllocT2();
struct  PGTB **HpgtbGet();


extern int             vfnWriting;
extern struct BPS      *mpibpbps;
extern typeTS          tsMruBps;
extern int             vibpWriting;
extern CHAR            (**vhrgbSave)[];
extern struct DOD      (**hpdocdod)[];
extern int             docCur;
extern int             docMac;
extern int             docScrap;
extern int             docUndo;
extern struct FCB      (**hpfnfcb)[];
extern int             fnMac;
extern int             wwMac;
extern int             vfBuffersDirty;
extern int             vfDiskFull;
extern int             vfDiskError;
extern typeCP          vcpFetch;
extern CHAR            *vpchFetch;
extern int             vccpFetch;
extern typeFC          fcMacPapIns;
extern typeFC          fcMacChpIns;
extern typeCP          vcpLimParaCache;
extern struct FKPD     vfkpdCharIns;
extern struct FKPD     vfkpdParaIns;
extern struct PAP      vpapPrevIns;
extern struct PAP      vpapAbs;
extern struct PAP      *vppapNormal;
extern struct CHP      vchpNormal;
extern struct CHP      vchpInsert;
extern struct CHP      vchpFetch;
extern unsigned        cwHeapFree;
extern struct FPRM     fprmCache;

extern int              ferror;
extern CHAR             szExtBackup[];
extern CHAR             (**hszTemp)[];

#ifdef INTL /* International version */

extern int  vWordFmtMode; /* used during saves. If false, no conversion is
			      done. True is convert to Word format,CVTFROMWORD
			      is translate chars from Word character set at
			      save */
#endif  /* International version */


/***        WriteUnformatted - Write unformatted document to file
 *
 *
 *
 */


WriteUnformatted(fn, doc)
int fn;
int doc;
{
 extern typeCP vcpLimParaCache;
 extern typeCP cpMinCur, cpMacCur;
 typeCP cpMinCurT = cpMinCur;
 typeCP cpMacCurT = cpMacCur;
 typeCP cpNow;
 typeCP cpLimPara;
 typeCP cpMac = (**hpdocdod) [doc].cpMac;

 /* Expand range of interest to whole document (for CachePara) */

 cpMinCur = cp0;
 cpMacCur = cpMac;

 /* Loop on paras */

 cpNow = cp0;
 for ( cpNow = cp0; cpNow < cpMac; cpNow = cpLimPara )
    {
LRestart:    
    CachePara( doc, cpNow );
    cpLimPara = vcpLimParaCache;
    if (vpapAbs.fGraphics)
        continue;

    /* Now write out the para, a run at a time */

                
    while ((cpNow < cpLimPara && cpNow < cpMacCur) 
		   && !(vfDiskFull || vfDiskError))
        {
		extern typeCP CpMin();
        extern int vccpFetch;
        int ccpAccept;
		CHAR bufT[cbSector + 1];
		CHAR *pch;

        FetchCp( doc, cpNow, 0, fcmChars + fcmNoExpand );
		Assert (vccpFetch <= cbSector);
#ifdef WINVER >= 0x300        
        if (vccpFetch == 0)
            {
            /* In this case we've had an error with a "hole" in the
               the piece table due to hitting a mem-alloc error -- we 
               won't ever advance cpNow!  To get around this we bump 
               cpNow to the cpMin of the next piece and continue by 
               doing a CachePara on the next piece  3/14/90..pault */

            struct PCTB *ppctb = *(**hpdocdod)[doc].hpctb;
            int ipcd = IpcdFromCp(ppctb, cpNow);
            struct PCD *ppcd = &ppctb->rgpcd[ipcd + 1]; /* NEXT piece */

            cpNow = ppcd->cpMin;
            goto LRestart;
            }
#endif
        ccpAccept = (int) CpMin( (typeCP)vccpFetch, (cpLimPara - cpNow));

#ifdef INTL /* International version */
		if (vWordFmtMode != TRUE)  /* no character set conversion */
#endif  /* International version */

			WriteRgch( fn, vpchFetch, ccpAccept );

#ifdef INTL /* International version */
        else   /* convert to OEM set */
			{
			 /* convert ANSI chars to OEM for Word format file */
			/* load chars into bufT and translate to OEM
			 chars, and write out */
			pch = (CHAR *) bltbyte(vpchFetch, bufT, 
			  (int)ccpAccept);
			*pch = '\0';
			AnsiToOem((LPSTR)bufT, (LPSTR)bufT);
			WriteRgch(fn, bufT, (int)ccpAccept);
		   }
#endif  /* International version */

        cpNow += ccpAccept;
        }
        if ((vfDiskFull || vfDiskError))
                break;

    }

 /* Restore cpMinCur, cpMacCur */

 cpMinCur = cpMinCurT;
 cpMacCur = cpMacCurT;
}




/***        PurgeTemps - Delete all temporary files not referenced in any doc
 *
 */

PurgeTemps()
{ /* Delete all temporary files not referenced in any doc */
int fn;
struct FCB *pfcb, *mpfnfcb;
struct DOD *pdod;
struct PCD *ppcd;
int doc;

Assert(fnScratch == 0);
FreezeHp();
mpfnfcb = &(**hpfnfcb)[0];

#ifdef DFILE
    CommSz("PurgeTemps:\n\r");
#endif

/* Prime the doc/piece table loop */
/* Find the first valid doc (there is guaranteed to be one) */
/* Set up doc, pdod, ppcd */
for (doc = 0, pdod = &(**hpdocdod)[0]; pdod->hpctb == 0; doc++, pdod++)
        continue;
ppcd = &(**pdod->hpctb).rgpcd[0];

/* Now go through the deletable files, looking for references */
for (fn = fnScratch + 1, pfcb = &mpfnfcb[fnScratch + 1];
    fn < fnMac; fn++, pfcb++)
        { /* For each file (don't bother with scratch file) */
        /* Fn must be valid, deletable, and not previously referenced */
        /* if (pfcb->rfn != rfnFree && pfcb->fDelete && !pfcb->fReferenced &&
            fn != fnPrint) */
        if (pfcb->rfn != rfnFree && pfcb->fDelete && !pfcb->fReferenced)
                { /* For each deletable fn */
                int fnT;

                for (;;)
                        { /* Until we determine there is or isn't a ref */
                        if (doc >= docMac)
                                goto OutOfDocs;
                        while ((fnT = ppcd->fn) == fnNil)
                                { /* End of pctb */
#ifdef CASHMERE
                                struct SETB **hsetb = pdod->hsetb;
                                if (hsetb != 0)
                                        { /* Check section table. Doesn't need to be quite
                                                as smart as piece table checker; smaller. */
                                        int csed = (**hsetb).csed;
                                        struct SED *psed = &(**hsetb).rgsed[0];
                                        while (csed--)
                                                {
                                                fnT = psed->fn;
                                                if (fnT == fn) /* Referenced. */
                                                        goto NextFn;
                                                if (fnT > fn) /* Future fn referenced */
                                                        mpfnfcb[fnT].fReferenced = true;
                                                psed++;
                                                }
                                        }
#endif
                                while (++doc < docMac && (++pdod)->hpctb == 0)
                                        continue;
                                if (doc >= docMac)
                                    {
OutOfDocs:                            /* No references to this fn, delete it */
                                    MeltHp();
#ifdef DFILE
        {
        char rgch[200];
        wsprintf(rgch,"    fn %d, %s \n\r", fn,(LPSTR)(**pfcb->hszFile));
        CommSz(rgch);
        }
#endif        
                                    FDeleteFn(fn);    /* HEAP MOVEMENT */
                                    FreezeHp();

                                    /* NOTE: Once we get here, there is no   */
                                    /* further use of pdod or ppcd; we zip   */
                                    /* through the remaining fn's and just   */
                                    /* test fcb fields.  Therefore, pdod     */
                                    /* and ppcd are not updated although     */
                                    /* there was (maybe) heap movement above */

                                    mpfnfcb = &(**hpfnfcb)[0];
                                    pfcb = &mpfnfcb[fn];

                                    goto NextFn;
                                    }
                                ppcd = &(**pdod->hpctb).rgpcd[0];
                                }
                        if (fnT == fn) /* A reference to this fn */
                                goto NextFn;
                        if (fnT > fn) /* Ref to a future fn */
                                mpfnfcb[fnT].fReferenced = true;
                        ++ppcd;
                        }
                }
        else
                pfcb->fReferenced = false;
NextFn: ;
        }
MeltHp();
}


#if WINVER >= 0x300
/* We only use one document at a time, thus in general we won't have
   doc's referencing pieces from multiple fns (unless they've been 
   pasted and reference docscrap or something).  

   In any case we want to free up these files esp. for network user 
   convenience.  The dilemma in particular is when someone's opened
   a file on the net and then does a File.New, File.SaveAs, or File.Open
   and is using another file -- we don't release the previous one so
   another user will get a sharing error even though it seems that file
   should be free!

   Modeled after PurgeTemps() above  ..pault 10/23/89 */

void FreeUnreferencedFns()
    {
    int fn;
    struct FCB *pfcb, *mpfnfcb;
    struct DOD *pdod;
    struct PCD *ppcd;
    int doc;

    Assert(fnScratch == 0);
    FreezeHp();
    mpfnfcb = &(**hpfnfcb)[0];
    
    /* Prime the doc/piece table loop */
    /* Find the first valid doc (there is guaranteed to be one) */
    /* Set up doc, pdod, ppcd */
    for (doc = 0, pdod = &(**hpdocdod)[0]; pdod->hpctb == 0; doc++, pdod++)
        continue;
    ppcd = &(**pdod->hpctb).rgpcd[0];
#ifdef DFILE
    CommSz("FreeUnreferencedFns: \n\r");
#endif

    for (fn = fnScratch + 1, pfcb = &mpfnfcb[fnScratch + 1]; fn < fnMac; fn++, pfcb++)
        { /* For each file (don't bother with scratch file) */
        
#ifdef DFILE
        {
        char rgch[200];
        wsprintf(rgch,"    fn %d, %s \trfnFree %d fRefd %d fDelete %d  ",
                fn,(LPSTR)(**pfcb->hszFile),pfcb->rfn==rfnFree,pfcb->fReferenced,pfcb->fDelete);
        CommSz(rgch);
        }
#endif        
        /* For each unreferenced fn, we ask: is this file the current
           document being edited?  If so then we definitely don't want
           to free up the file.  However PREVIOUS documents that were
           being edited can now "be free".  Temp files are not freed
           here because we want them to be remembered so they are deleted
           at the end of the Write session 2/1/90 ..pault */
        
        if ((WCompSz(*(**hpdocdod)[ docCur ].hszFile,**pfcb->hszFile)==0)
            || pfcb->fDelete)
            goto LRefd;
        else if (pfcb->rfn != rfnFree && !pfcb->fReferenced)
            {
            int fnT;

            for (;;)
                { /* Until we determine there is or isn't a ref */
                if (doc >= docMac)
                    {
                    goto OutOfDocs;
                    }
                while ((fnT = ppcd->fn) == fnNil)
                    { /* End of pctb */
                    while (++doc < docMac && (++pdod)->hpctb == 0)
                        continue;
                    if (doc >= docMac)
                        {
OutOfDocs:              /* No references to this fn, delete it */

                        MeltHp();
#ifdef DFILE
                        CommSz(" FREEING!");
#endif                        
                        FreeFn(fn);    /* HEAP MOVEMENT */
                        FreezeHp();

                        /* NOTE: Once we get here, there is no   */
                        /* further use of pdod or ppcd; we zip   */
                        /* through the remaining fn's and just   */
                        /* test fcb fields.  Therefore, pdod     */
                        /* and ppcd are not updated although     */
                        /* there was (maybe) heap movement above */

                        mpfnfcb = &(**hpfnfcb)[0];
                        pfcb = &mpfnfcb[fn];

                        goto NextFn;
                        }
                    ppcd = &(**pdod->hpctb).rgpcd[0];
                    }
                if (fnT == fn) /* A reference to this fn */
                    {
                    goto NextFn;
                    }
                if (fnT > fn) /* Ref to a future fn */
                    {
                    mpfnfcb[fnT].fReferenced = true;
                    }
                ++ppcd;
                }
            }
        else
            {
LRefd:
            pfcb->fReferenced = false;
            }
NextFn: ;
#ifdef DFILE
        CommSz("\n\r");
#endif        
        }
    MeltHp();
    }
#endif /* WIN30 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\trans2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* trans2.c -- Save routines for WRITE (also see trans4.c; routines were
   moved because of compiler heap overflows) */

#define NOWINMESSAGES
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
//#define NOATOM
#define NOCREATESTRUCT
#define NODRAWTEXT
//#define NOGDI
//#define NOMETAFILE
#define NOBRUSH
#define NOPEN
#define NOFONT
#define NOWNDCLASS
#define NOWH
#define NOWINOFFSETS
#define NOICON
#define NOCOMM
#define NOSOUND
#include <windows.h>

#include "mw.h"
#include "doslib.h"
#include "propdefs.h"
#define NOUAC
#include "cmddefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "fkpdefs.h"
#include "printdef.h"
#include "code.h"
#include "heapdefs.h"
#include "heapdata.h"
#define NOSTRUNDO
#include "str.h"
#include "debug.h"
#include "fontdefs.h"
#include "obj.h"
#include "winddefs.h"

CHAR    *PchGetPn();
CHAR    *PchFromFc();
typePN  PnAlloc();
struct  PGTB **HpgtbGet();

#ifdef DEBUG
    /* Make these variables during debug so testers can force limits */
typeFC          fcBound = (pnMaxScratch >> 2) * ((typeFC)cbSector);
int             cpBound = 512;
#else
#define fcBound     ((typeFC) ((pnMaxScratch >> 2) * ((typeFC)cbSector)))
#define cpBound     (512)
#endif

extern  CHAR *PchFillPchId();

extern int             vfOldWriteFmt;  /* delete objects before saving */
extern HANDLE  hParentWw;
extern int             vfnWriting;
extern struct BPS      *mpibpbps;
extern typeTS          tsMruBps;
extern int             vibpWriting;
extern CHAR            (**vhrgbSave)[];
extern struct DOD      (**hpdocdod)[];
extern int             docCur;
extern int             docMac;
extern int             docScrap;
extern int             docUndo;
extern struct FCB      (**hpfnfcb)[];
extern int             fnMac;
extern int             wwMac;
/* extern ENV             vEnvMainLoop; */
extern int             vfBuffersDirty;
extern int             vfDiskFull;
extern int             vfDiskError;
extern typeCP          vcpFetch;
extern CHAR            *vpchFetch;
extern int             vccpFetch;
extern typeFC          fcMacPapIns;
extern typeFC          fcMacChpIns;
extern typeCP          vcpLimParaCache;
extern struct FKPD     vfkpdCharIns;
extern struct FKPD     vfkpdParaIns;
extern struct PAP      vpapPrevIns;
extern struct PAP      vpapAbs;
extern struct PAP      *vppapNormal;
extern struct CHP      vchpNormal;
extern struct CHP      vchpInsert;
extern struct CHP      vchpFetch;
extern struct FPRM     fprmCache;
extern HCURSOR vhcIBeam;

extern int              ferror;
extern CHAR             szExtBackup[];  /* extension for Write backup files */
extern CHAR             szExtWordBak[];  /* extension for Word backup files */
extern CHAR             (**hszTemp)[];
extern CHAR             szExtDoc[];


#ifdef INTL /* International version */

extern int vfTextOnlySave;
extern int  vWordFmtMode; /* used during saves. If false, no conversion is
                              done. True is convert to Word format,CVTFROMWORD
                              is translate chars from Word character set at
                              save */
#endif  /* International version */




/***         CmdXfSave - Save document to passed filename (TRANSFER SAVE)
 *
 *      ENTRY:  szFile - a normalized filename
 *              fFormatted - TRUE  = save as formatted file
 *                           FALSE = save as unformatted file
 *              fBackup    - TRUE = keep a backup copy of the file
 *                           FALSE = don't (but see below)
 *
 *      EXIT:
 *
 *      NOTE: A backup file may be kept even if fBackup is FALSE.
 *            This is because piece tables in documents other than docCur
 *            may refer to the information.  If a backup file is kept for
 *            this reason, the following holds: (1) The file has an fn,
 *            (2) the file's hpfnfcb entry has its fDelete field set to TRUE,
 *            indicating that the file should be deleted when WORD exits,
 *            (3) the file is, in fact, referenced in some document
 *            (PurgeTemps assures that unreferenced files are deleted)
 *
 *      Note 2: Non-formatted save code modified (bz 12/2/85) to allow
 *            similar saving in Word format. The calls to FnCreate and
 *            FWriteFn were changed to allow for formatted saving, but
 *            FWriteFn is changed to convert text from ANSI to OEM character
 *            sets, to not put out the font table and to mark
 *            the file header (fib) so the file will be treated as a Word
 *            file, but, like a non-formatted save, the piece table is not
 *            cleaned up. Note that the backup file is saved  in the original,
 *            Write format.
 *
 */

CmdXfSave(szFile, fFormatted, fBackup, hcAfterward)
CHAR szFile[];
int fFormatted;
int fBackup;
HCURSOR hcAfterward;    /* handle to cursor to display after hourglass */
{
 extern int vfnSaving;   /* Set this so we prompt for "Write Save File"
                            if disk change is necessary */
 extern int vfDiskError;
 extern int vfSysFull;
 extern int vfOutOfMemory;

 int     fSave = vfDiskError;
 int     fDidBackup;
 CHAR    szFileT [cchMaxFile];
 int     fOutOfMemory=vfOutOfMemory;
 int     docTemp;

 /* Make a local copy of string parm in case it is in the heap */

#ifdef DFILE
 CommSzSz("CmdXfSave----szFile (presumed ANSI) ", szFile);
#endif
 StartLongOp();
 bltsz( szFile, szFileT );
 szFileT[ cchMaxFile - 1] = '\0';

 /* Reset error conditions to give us a chance */

 vfOutOfMemory = vfDiskFull = vfSysFull = vfDiskError = ferror = FALSE;

 SetRfnMac( rfnMacSave );    /* Increase # of DOS handles used to speed save */

 /* Memory kludge: To assure that we can actually save this file under low
        memory conditions, free the bogus heap block */
 if (vhrgbSave != 0)
    {
    FreeH(vhrgbSave);        /* Return this memory to free pool. */
    vhrgbSave = 0;
    }
 /* In-Line version of FreeBitmapCache (so we don't have to swap in
   picture.c) */

 /*FreeBitmapCache(); */              /* Give us even more memory */

 {
 extern int vdocBitmapCache;
 extern HBITMAP vhbmBitmapCache;

 vdocBitmapCache = docNil;
 if (vhbmBitmapCache != NULL)
    {
    DeleteObject( vhbmBitmapCache );
    vhbmBitmapCache = NULL;
    }
 }


 /* Can't undo save -- set "Can't Undo"; also clear out docUndo
    for heap space reclamation and to aid PurgeTemps */

 ClobberDoc(docUndo, docNil, cp0, cp0);
 NoUndo();

 (**hpdocdod)[docCur].fBackup = fBackup;

 /*      Note: Non-formatted save code modified (bz 12/2/85) to allow
 *            similar saving in Word format. The calls to FnCreate and
 *            FWriteFn were changed to allow for formatted saving, but
 *            FWriteFn is changed to convert text from ANSI to OEM character
 *            sets, to not put out the font table and to mark
 *            the file header (fib) so the file will be treated as a Word
 *            file, but, like a non-formatted save, the piece table is not
 *            cleaned up. Note that the backup file is saved  in the original,
 *            Write format.
 *            Note that a file CAN be saved both unformatted and in Word format
 *            - in that case, Word format means convert to OEM character set.
 */

#if defined(OLE)
    ObjSavingDoc(fFormatted);
#endif

 if (((**hpdocdod)[docCur].fFormatted && !fFormatted)
#ifdef INTL /* International version */
      || (vWordFmtMode == TRUE) /* convert To Word format? */
#endif  /* International version */
      || (vfOldWriteFmt))
    {

    int fn;
    CHAR (**hsz)[];
    CHAR szT [cchMaxFile];
    CHAR szWriteFile [cchMaxFile];
    CHAR szBak [cchMaxFile];

        /* Set szFileT's path name into szWriteFile, so the temp file
           gets created in the right place when we call FnCreateSz */
    SplitSzFilename( szFileT, szWriteFile, szT );

        /* Create szWrite: a new, uniquely named file */
     if ((fn=FnCreateSz( szWriteFile,
                     fFormatted?(**hpdocdod)[docCur].cpMac:cpNil,
                     dtyNetwork ))==fnNil)
            /* Couldn't create the write file */
        goto SaveDone;
    /* Make backup of szFileT (if it exists); purge all unneeded backups
       which were kept for their pieces but are no longer referenced */
    fDidBackup = FBackupSzFile( szFileT, fBackup, szBak );
    if (ferror)
        goto LXFRet;     /* Backup failed */

    PurgeTemps();

    vfnSaving = fn;

    /* ForcePmt(IDPMTSaving);*/

#ifdef INTL /* International version */

    if ((vWordFmtMode == TRUE)  /* converting To Word format? */
     || (vfTextOnlySave == TRUE)  /* converting To Text format? */
     || (vfOldWriteFmt))
    /* Delete all pictures. To do this, make a copy
      of docCur in docTemp, the go through docTemp, deleting all picture
      paragraphs. Write out this document, then kill it. */
    {
    extern typeCP vcpLimParaCache, vcpFirstParaCache;
    extern typeCP cpMinCur, cpMacCur, cpMinDocument;
    typeCP cpMinCurT = cpMinCur;
    typeCP cpMacCurT = cpMacCur;
    typeCP cpMinDocumentT = cpMinDocument;
    typeCP cpNow;
    typeCP cpLimPara, dcp;
    typeCP cpMac = (**hpdocdod) [docCur].cpMac;

    /* Create copy of document */
    docTemp = DocCreate(fnNil, HszCreate(""), dtyNormal);
    if (docTemp == docNil)
        goto SaveDone; /* Out of memory */
    ClobberDoc(docTemp, docCur, cp0, CpMacText(docCur));
    if (ferror)
        return TRUE;

    /* Expand range of interest to whole document (for CachePara) */

    cpMinCur = cp0;
    cpMacCur = cpMac;

    /* Loop on paras */

    for ( cpNow = cp0; cpNow < cpMac; cpNow = cpLimPara )
        {
        CachePara( docTemp, cpNow );
        if (!vpapAbs.fGraphics)
            /* update to next cplim only if not deleting. If deleting,
                next time will be at same cp */
            {
            cpLimPara = vcpLimParaCache;
            continue;
            }

        /* Now delete graphics paragraph */
        Replace(docTemp, vcpFirstParaCache,
                dcp = (vcpLimParaCache - vcpFirstParaCache),
                fnNil, fc0, fc0);
        cpMac -= dcp;  /* size of doc has been reduced */
        }

    /* Restore cpMinCur, cpMacCur */

    cpMinCur = cpMinCurT;
    cpMacCur = cpMacCurT;
                                    /* destroyed possibly by DocCreate */
    cpMinDocument = cpMinDocumentT;
    vcObjects = 0; // OLE object count
    }
    else
#endif  /* International version */

        {
            docTemp = docCur; // note the else, above #endif (2.7.91) D. Kent
        }

    if (FWriteFn(fn, docTemp, fFormatted))
        {
        int fpe = FpeRenameFile( szWriteFile, szFileT );

        if ( FIsErrFpe( fpe ) )
            {   /* Rename failed -- might be nonexistent path */
            Error( (fpe == fpeBadPathError) ? IDPMTNoPath : IDPMTSDE2 );
            }
        else
            OutSaved(docTemp);

        }
    else
        {       /* Write failed */
        if (fDidBackup && !FIsErrFpe(FpeRenameFile(szBak, szFileT)))
            {
            int fn = FnFromSz(szFileT);
            struct FCB      *pfcb;
            if (fn != fnNil)
                {
                (pfcb = &(**hpfnfcb)[fn])->fDelete = false;
                }
            }
        FDeleteFn( fn );
        }


#ifdef INTL /* International version */
    if (vWordFmtMode == TRUE)  /* converting To Word format? */
        KillDoc (docTemp);
#endif  /* International version */


    (**hpdocdod)[docCur].fDirty = false;  /* document should not
                                                 be dirty after T-S.*/
    FreeH((**hpdocdod)[docCur].hszFile);
    hsz = HszCreate((PCH)szFileT);
    (**hpdocdod)[docCur].hszFile = hsz;
    }
else
    {   /* Save Formatted document */
    CleanDoc( docCur, (**hpdocdod)[docCur].dty, szFileT, fFormatted, fBackup );
    }

 OpenEveryHardFn(); /* Reopen files on nonremoveable media so other net
                       users can't steal them away */

SaveDone:

 SetRfnMac( rfnMacEdit );      /* Reduce # of file handles used */
 vfnSaving = fnNil;

#ifdef NEVER
 /* It doesn't do us much good to Assert here that an error didn't happen.
    After-the-fact checking doesn't make up for ignoring real-time errors.
    ..pault 10/31/89 */

 Assert( !vfOutOfMemory );      /* Our reserved space block was sufficient
                                   to get us through the save */
#endif
 vfOutOfMemory = fOutOfMemory;

/* vhrgbSave is a pointer a clump on the heap used during the save operation.
   By freeing it in the beginning of the save operation, we are assured
   that we will have enough memory to actually do the save.
   At the present point
   in the code, we are finished with the save and wish to reclaim vhrgbSave
   so the next Save operation may perform properly.  The net memory usage
   caused by a save should be minimal.  It only temporarily requires a
   significant chunk of memory. */
 vhrgbSave = (CHAR (**)[]) HAllocate( cwSaveAlloc +
                                     ( (wwMac-1) * cwHeapMinPerWindow ));

/* Restore previous disk err state */

#if WINVER >= 0x300
 /* We currently have no way to FORGET they had a disk error.
    So if this whole operation did not have an error and we
    felt there was one beforehand, we do it now ..pault */
 vfDiskError = (!vfDiskError && fSave) ? fFalse : fSave;
#else
 vfDiskError = fSave;
#endif

LXFRet:
 EndLongOp(hcAfterward);
}




CleanDoc(doc, dty, szFile, fFormatted, fBackup )
int doc, fFormatted;
int dty;
CHAR szFile[];
int     fBackup;
{ /* Write the contents of doc into szFile and clean up piece table */
  /* if dty == dtyNetwork, writes the doc to a unique file & returns the */
  /* filename through szFile */
  /* Returns the fn of the file it wrote to */

/* *************************************
  In the normal backup processing, we rename the existing file. When
  saving in CONVFROMWORD mode, we want to keep the original Word file around,
  so we bypass the backup phase and then skip the renaming phase below.
  This leaves the original file around. At save time we may write over it
  or rename the saving file, as we wish, but this way we have the Word file
  around in case we don't save out of Write.
************************************** */

extern int vdocParaCache;
extern int vfnSaving;   /* Set this so we prompt for "Save" disk if disk
                           changes are necessary */
int fDidBackup=FALSE;
int fn;
CHAR (**hsz)[];

CHAR szBak [cchMaxFile];
CHAR szWrite [cchMaxFile];
int fDummy;

#if WINVER >= 0x300
/* I don't understand WHY the following resets to ROOT directory, but 
   changing it causes problems -- so I'm leaving it!  Obviously code 
   somewhere else expects file to be there and I don't see it ..pault */
#endif
    /* Set path name of szFile into szWrite so the temp file gets created
       in the right place */
 if (dty == dtyNetwork)
    {
    szWrite [0] = '\0'; /* Create temp file on Temp drive in the root */
    }
 else
    {
    CHAR szT [cchMaxFile];

    SplitSzFilename( szFile, szWrite, szT );
    }

    /* Create szWrite: a new, uniquely named file */
 if ((fn=FnCreateSz( szWrite, fFormatted ? (**hpdocdod)[doc].cpMac : cpNil,
                     dtyNetwork )) == fnNil)
        /* Couldn't create the write file */
    return fnNil;

 vfnSaving = fn;

/* *************************************
  In the normal backup processing, we rename the existing file. When
  saving in CONVFROMWORD mode, we want to keep the original Word file around,
  so we bypass the backup phase and then skip the renaming phase below.
  This leaves the original file around. At save time we may write over it
  or rename the saving file, as we wish, but this way we have the Word file
  around in case we don't save out of Write.
************************************** */

 if (doc != docScrap)
    {
    /* Make a backup of szFile (if szFile exists) */

#ifdef INTL /* International version */
    if (vWordFmtMode == CONVFROMWORD) /* converting from a Word document */
        fDidBackup = false;
    else
#endif  /* International version */
        {
        fDidBackup = FBackupSzFile( szFile, fBackup, szBak );
        if (ferror)
            return;     /* Backup failed */
        }

    PurgeTemps();

    }

 if ( dty == dtyNetwork )
    bltsz( szWrite, szFile );

 if (!FWriteFn(fn, doc, fFormatted))
        {   /* Save failed; rename backup file back to original */
            /* note in intl CONVFROMWORD case, fDidBackup will be false
               and this renaming won't happen, which is ok */
        if (fDidBackup && !FIsErrFpe(FpeRenameFile(szBak, szFile)))
                {
                int fn = FnFromSz(szFile);
                struct FCB      *pfcb;
                if (fn != fnNil)
                        {
                        (pfcb = &(**hpfnfcb)[fn])->fDelete = false;
                        }
                }
        FDeleteFn( fn );
        return fnNil;         /* Disk full or write error */
        }

/* *************************************
  Here we rename our temp file szWrite to have the name of the "save as"
  file. In FBackupSzFile, the fdelete flag for the fn of szfile was set
  on so we don't have to explicitly delete the original file.

  When a CONVFROMWORD save is done, we do not rename and did not go
  through the backup procedure, so the original Word file is still
  out there with its original name. We do, however, set the delete bit to
  true, so the file will get deleted after the next save, when a true rename
  will be done.
************************************** */

 if ( dty != dtyNetwork )

#ifdef INTL /* International version */
    if (vWordFmtMode == CONVFROMWORD) /* converting from a Word document */
        {
        (**hpfnfcb)[fn].fDelete = true;
        }
    else
#endif  /* International version */

        {
        int fpe=FpeRenameFile( szWrite, szFile );

        if (FIsErrFpe( fpe ))
            {
            Error( (fpe == fpeBadPathError) ? IDPMTNoPath : IDPMTSDE2 );
            return fnNil;
            }
        }

if (doc == docScrap)
    (**hpfnfcb)[fn].fDelete = true;
else
    OutSaved(doc);

FreeH((**hpdocdod)[doc].hpctb); /* Free old piece table */
FInitPctb(doc, fn);
(**hpdocdod)[doc].fFormatted = fFormatted;
FreeH((**hpdocdod)[doc].hszFile);
hsz = HszCreate((PCH)szFile);
(**hpdocdod)[doc].hszFile = hsz;

if (fFormatted)
    {
    /* reload font table, which may have changed */

    SmashDocFce(doc);
    FreeFfntb(HffntbGet(doc));
    (**hpdocdod)[doc].hffntb = HffntbCreateForFn(fn, &fDummy);
    //SaveFontProfile(doc);
    ResetDefaultFonts(FALSE);
    }

 /* By diddling the document attributes on save, we have invalidated caches */

 InvalidateCaches( doc );
 vdocParaCache = docNil;

 if (!ferror && !vfBuffersDirty && doc != docScrap)
        ReduceFnScratchFn( fn );

 if (fFormatted)
    {  /* Readjust the running head margins.  We munged them back to the
       paper-relative measurements in FWriteFn, so we'll remunge them
       to margin-relative here. */

 /* With the test for doc != docScrap we fix a major bug, and knowingly at the
    last minute introduce a minor one. The old problem was that we would apply
    a sprm to docScrap, then mash the scratch file in ReduceFnScratch, our
    caller, rendering the bfprm bogus, causing rare crashes.  The new problem
    will be that running head text in the scrap will have incorrect margins
    after a save. */

   if (doc != docScrap)
        ApplyRHMarginSprm( doc );
    InvalidateCaches( doc );
    vdocParaCache = docNil;
    }

 return fn;
}





/***        FWriteFn - write a file
 *
 *      Note: Modified (bz 12/2/85) to allow saving in Word format.
 *            FWriteFn is changed to convert text from ANSI to OEM character
 *            sets, to not put out the font table and to mark
 *            the file header (fib) so the file will be treated as a Word
 *            file.
 *
 */

int FWriteFn(fn, doc, fFormatted)
int fn, doc, fFormatted;
{ /* Write characters from a doc to fn */
/* Return true if successful */
#ifdef CASHMERE
extern int docBuffer;
#endif

typeCP cpMac;
CHAR    *pchFprop;
struct RUN *prun;
struct FIB *pfib;
struct FCB *pfcb;
int     cchT;
struct FNTB **hfntb;
struct FFNTB **hffntb=(struct FFNTB **)NULL;

#ifdef CASHMERE
struct SETB **hsetb = 0, **hsetbT;
#else
struct SEP **hsep;
#endif

struct PGTB **hpgtb;
int ised, csed;
struct SED *psed, *psedT;
int cw;
int fFileFlushed;
int rfn;
CHAR mpftcftc[iffnMax];

struct PAP pap;
struct CHP chp;
struct FKP fkp;

vfnWriting = fn;
vibpWriting = IbpEnsureValid(fn, (typePN)0);

cpMac = (**hpdocdod)[doc].cpMac;

/* FIB has already been written. */
if (fFormatted)
        {

/* KLUDGE: If the doc does not contain at least one complete para,
                   and it has a nonnull tab table,
                   add an Eol to its end to hold the tabs in a FPAP */

        CachePara( doc, cp0 );
        if (vcpLimParaCache > cpMac && (doc != docScrap) &&
            (**hpdocdod) [doc].hgtbd != NULL )
            {
            extern int vdocParaCache;

            InsertEolInsert( doc, cpMac );
            vdocParaCache = docNil;
            cpMac = (**hpdocdod) [doc].cpMac;
            }

                /* Write characters */
                /* Modified to handle ANSI to OEM conversion for Word docs */
        FetchCp(doc, cp0, 0, fcmChars + fcmNoExpand);

                {
                Scribble(4, 'T');

                while (vcpFetch < cpMac && !(vfDiskFull || vfDiskError))
                                        {
#ifdef INTL /* International version */

                if (vWordFmtMode == FALSE) /* no conversion */
#endif  /* International version */

                    WriteRgch(fn, vpchFetch, (int)vccpFetch);

#ifdef INTL /* International version */
                else
                   {
                         /* bufT is a buffer for translating from ANSI to
                         OEM chars.  The amount of data from FetchCp
                         must be no > than a disk page, which is
                         cfcFetch, which is itself cbSector. We use
                         bufT to hold the translated chars, then write
                         them out with WriteRgch. */

                    CHAR bufT[cbSector + 1];
                    CHAR *pch;

                    Assert ((int)vccpFetch <= cbSector);
                      /* load chars into bufT and translate to OEM
                         chars, and write out */
                    pch = (CHAR *) bltbyte(vpchFetch, bufT,
                                           (int)vccpFetch);
                    *pch = '\0';
                    if (vWordFmtMode == TRUE)
                     /* from Write/ANSI to Word/OEM */
                        AnsiToOem((LPSTR)bufT, (LPSTR)bufT);
                    else
                         /* from Word/OEM to Write/ANSI */
                        OemToAnsi((LPSTR)bufT, (LPSTR)bufT);
                    WriteRgch(fn, bufT, (int)vccpFetch);
                   }
#endif  /* International version */


                FetchCp(docNil, cpNil, 0, fcmChars + fcmNoExpand);
                                        }
                Scribble(4,' ');
                }

        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;

        /* Go to beginning of next page */
        AlignFn(fn, cbSector, false);
        (**hpfnfcb)[fn].pnChar = (**hpfnfcb)[fn].pnMac;

        /* Now write char props */
        Scribble(4, 'C');
        fkp.fcFirst = cfcPage; /* first fkp starts with first valid fc */
        fkp.crun = 0;
        prun = (struct RUN *) fkp.rgb;
        pchFprop = &fkp.rgb[cbFkp];
        CachePara(doc, cp0);

        /* set up font mapping and new font table */
        if (!FInitMapSave(doc, &hffntb, mpftcftc))
                goto AbortWrite;

        FetchCp(doc, cp0, 0, fcmProps);
        if (!FMapFtcSave(doc, hffntb, &vchpFetch, mpftcftc))
                goto AbortWrite;

        blt(&vchpFetch, &chp, cwCHP);

        while (vcpFetch < cpMac && !(vfDiskFull || vfDiskError))
                { /* This could be optimized by allowing multiple runs to point */
                    /* to one fchp. */

                if (CchDiffer(&vchpFetch, &chp, cchCHP) != 0)
                        {
                        FAddRun(fn, &fkp, &pchFprop, &prun, &chp,
                            &vchpNormal, cchCHP, vcpFetch + cfcPage);
                        blt(&vchpFetch, &chp, cwCHP);
                        }
                FetchCp(docNil, cpNil, 0, fcmProps);
                if (!FMapFtcSave(doc, hffntb, &vchpFetch, mpftcftc))
                        goto AbortWrite;
                }
        Scribble(4,' ');

        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;

        /* Write out last char run. */
        FAddRun(fn, &fkp, &pchFprop, &prun, &chp, &vchpNormal,
            cchCHP, cpMac + cfcPage);
        WriteRgch(fn, &fkp, cbSector);

        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;

        /* Now write para runs; one for every para */
        Scribble(4,'C');
        (**hpfnfcb)[fn].pnPara = (**hpfnfcb)[fn].pnMac;
        fkp.fcFirst = cfcPage; /* first fkp starts with first valid fc */
        fkp.crun = 0;
        prun = (struct RUN *) fkp.rgb;
        pchFprop = &fkp.rgb[cbFkp];
        CachePara(doc, cp0);

        /* KLUDGE: We have running head indents relative to the
                   margins -- subtract out the margins now, because
                   our (WORD-compatible) file format is PAPER-relative */

        if (vpapAbs.rhc)
            {
            struct SEP *psep = *(**hpdocdod)[ doc ].hsep;

            vpapAbs.dxaLeft += psep->xaLeft;
            vpapAbs.dxaRight += psep->xaMac -
                                        (psep->xaLeft + psep->dxaText);
            }

#ifdef INTL
        /* Ensure no pictures in Word documents. This is necessary
           because Word 4.0 uses the fGraphics bit as part of the
           new border type code (btc) property. */
        if (vWordFmtMode == CONVFROMWORD)
            vpapAbs.fGraphics = FALSE;
#endif
        FAddRun(fn, &fkp, &pchFprop, &prun, &vpapAbs, vppapNormal,
            cchPAP, vcpLimParaCache + cfcPage);
        blt(&vpapAbs, &pap, cwPAP);

        while (vcpLimParaCache <= cpMac && !(vfDiskFull || vfDiskError))
                {
                CachePara(doc, vcpLimParaCache);

                /* KLUDGE: We have running head indents relative to the
                   margins -- subtract out the margins now, because
                   our (WORD-compatible) file format is PAPER-relative */

                if (vpapAbs.rhc)
                    {
                    struct SEP *psep = *(**hpdocdod)[ doc ].hsep;

                    vpapAbs.dxaLeft += psep->xaLeft;
                    vpapAbs.dxaRight += psep->xaMac -
                                        (psep->xaLeft + psep->dxaText);
                    }
#ifdef INTL
                /* Ensure no pictures in Word documents. This is necessary
                   because Word 4.0 uses the fGraphics bit as part of the
                   new border type code (btc) property. */
                if (vWordFmtMode == CONVFROMWORD)
                    vpapAbs.fGraphics = FALSE;
#endif
#ifdef BOGUS
 /* this would have erased all tab setting if saving back a Word document */

                /* For MEMO: the only tabs we write are in the first para run;
                   override all other tab tables to keep files compact */
                if (vpapAbs.rgtbd [0].dxa != 0)
                    bltc( vpapAbs.rgtbd, 0, cwTBD * itbdMax );
#endif
                FAddRun(fn, &fkp, &pchFprop, &prun, &vpapAbs, vppapNormal,
                    FParaEq( &vpapAbs, &pap ) ? -cchPAP : cchPAP,
                      vcpLimParaCache + cfcPage);
                blt(&vpapAbs, &pap, cwPAP);
                }
        WriteRgch(fn, &fkp, cbSector);
        Scribble(4,' ');

        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;

        /* Output footnote table */
        Scribble(4,'F');
        (**hpfnfcb)[fn].pnFntb = (**hpfnfcb)[fn].pnMac;

#ifdef FOOTNOTES   /* In MEMO, we NEVER write a footnote table */
        if ((hfntb = HfntbGet(doc)) != 0)
                {
                WriteRgch(fn, *hfntb,
                    ((**hfntb).cfnd * cwFND + cwFNTBBase) * sizeof (int));
                AlignFn(fn, cbSector, false);
                }

        Scribble(4,' ');
        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;
#endif  /* FOOTNOTES */

#ifdef CASHMERE     /* Output section properties, table from hsetb */
        /* Output section properties */
        Scribble(4,'S');
        (**hpfnfcb)[fn].pnSep = (**hpfnfcb)[fn].pnMac;
        if ((hsetb = HsetbGet(doc)) != 0)
                { /* Write out section props */
                cw = cwSETBBase + (**hsetb).csedMax * cwSED;
                csed = (**hsetb).csed;
                hsetbT = (struct SETB **) HAllocate(cw);
                if (FNoHeap(hsetbT))
                        return false;   /* SHOULD REALLY GOTO ABORTWRITE */
                blt(*hsetb, *hsetbT, cw);
                FreezeHp();
                for (psed = &(**hsetb).rgsed[0], psedT = &(**hsetbT).rgsed[0],
                  ised = 0;
                    ised < csed; psed++, psedT++, ised++)
                        if (psed->fc != fcNil)
                                { /* Copy props to file and update setb */
                                int cch;
                                pchFprop = PchFromFc(psed->fn, psed->fc, &cch);
                                Assert(cch >= *pchFprop + 1);
                                psedT->fn = fn;
                                AlignFn(fn, cch = *pchFprop + 1, false);
                                psedT->fc = (**hpfnfcb)[fn].fcMac;
                                WriteRgch(fn, pchFprop, cch);
                                }
                MeltHp();
                AlignFn(fn, cbSector, false);
                }

        Scribble(4,' ');
        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;

        /* Output section table */
        (**hpfnfcb)[fn].pnSetb = (**hpfnfcb)[fn].pnMac;
        if (hsetb != 0)
            {
            if (csed != 1 || (**hsetb).rgsed[0].fc != fcNil)
                {
                WriteRgch(fn, *hsetbT,
                    ((**hsetb).csed * cwSED + cwSETBBase) * sizeof (int));
                AlignFn(fn, cbSector, false);
                }
            }
#else       /* MEMO VERSION: Write out a section table, 1 element long,
                             if we had nonstandard section properties */
        {
        typeFC fcSect;

            /* Output section properties */
        fcSect = (long)( cfcPage *
                         ((**hpfnfcb)[fn].pnSep = (**hpfnfcb)[fn].pnMac));

        if ((hsep = (**hpdocdod)[doc].hsep) != 0)
            {
            struct  {
                CHAR cch;
                struct SEP sep;
                }  fsep;
            fsep.cch = cchSEP;
            blt( *hsep, &fsep.sep, cwSEP );
            WriteRgch( fn, &fsep, sizeof( fsep ) );
            AlignFn( fn, cbSector, false );
            }

        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;

            /* Output section table */
        (**hpfnfcb)[fn].pnSetb = (**hpfnfcb)[fn].pnMac;
        if (hsep != 0)
            {   /* Section table has 1 real + 1 dummy entry with cp==cpMac+1
                   This duplicates the output of PC Word 1.15 */
            struct {
                int csed;
                int csedMax;
                struct SED rgsed [2];
                } setb;

            setb.csed = setb.csedMax = 2;
            setb.rgsed [1].cp = 1 +
                               (setb.rgsed [0].cp = (**hpdocdod)[doc].cpMac);
            setb.rgsed [0].fn = fn;
            setb.rgsed [0].fc = fcSect;
            setb.rgsed [1].fn = fnNil;
            setb.rgsed [1].fc = fcNil;

            WriteRgch( fn, &setb, sizeof( setb ) );
            AlignFn( fn, cbSector, false );
            }
        }
#endif  /* not CASHMERE */

        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;

        /* Output buffer or page table */
        (**hpfnfcb)[fn].pnBftb = (**hpfnfcb)[fn].pnMac;

#ifdef CASHMERE /* No docBuffer in WRITE */
        if(doc == docBuffer)
                {
                WriteBftb(fn);
                AlignFn(fn, cbSector, false);
                }
        else
#endif
        if ((hpgtb = HpgtbGet(doc)) != 0)
                {
                WriteRgch(fn, *hpgtb,
                    ((**hpgtb).cpgd * cwPGD + cwPgtbBase) * sizeof (int));
                AlignFn(fn, cbSector, false);
                }

        if ((vfDiskFull || vfDiskError))
                goto AbortWrite;

        /* Output font table */

#ifdef INTL /* International version */

        /* no font table if saving in Word format */
        if (vWordFmtMode != TRUE) /* no conv or conv from word */
#endif  /* International version */

            {
            Scribble(4,'N');
            (**hpfnfcb)[fn].pnFfntb = (**hpfnfcb)[fn].pnMac;
            WriteFfntb(fn, hffntb);         /* hffntb gets freed below */
            AlignFn(fn, cbSector, false);

            Scribble(4,' ');
            if ((vfDiskFull || vfDiskError))
                    goto AbortWrite;
            }

        /* Now update FIB at beginning of file */
        pfib = (struct FIB *) PchGetPn(fn, pn0, &cchT, true);
        pfib->pnPara = (pfcb = &(**hpfnfcb)[fn])->pnPara;
        pfib->pnFntb = pfcb->pnFntb;
        pfib->pnSep = pfcb->pnSep;
        pfib->pnSetb = pfcb->pnSetb;
        pfib->pnBftb = pfcb->pnBftb;

        /* mark file type if objects are in there */
        if (vcObjects)
            pfib->wIdent = wOleMagic;
        else
            pfib->wIdent = wMagic;

#ifdef INTL /* International version */

        if (vWordFmtMode != TRUE)  /* saving in Write format */
#endif  /* International version */

            {
            pfib->pnFfntb = pfcb->pnFfntb;
            pfib->pnMac = pfcb->pnMac;
            }

#ifdef INTL /* International version */

        else
            {
             /* in Word format there is no font table. pnFfntb is the
                end of the file,so is set to pnMac. The Write pnMac field
                is not used in Word and is set to 0. */
            pfib->pnFfntb = pfcb->pnMac;
            pfib->pnMac = 0;
            }
#endif  /* International version */

        pfib->fcMac = pfcb->fcMac = cpMac + cfcPage;
        if ((**hpdocdod)[doc].dty == dtyNormal)
                {
                CHAR (**hszSsht)[];
#ifdef STYLES
#ifdef DEBUG
                Assert((**hpdocdod)[doc].docSsht != docNil);
#endif
                hszSsht = (**hpdocdod)[(**hpdocdod)[doc].docSsht].hszFile;
#else
                hszSsht = HszCreate((PCH)"");
#endif /* STYLES */
                if (!FNoHeap(hszSsht))
                        {
                        bltbyte(**hszSsht, pfib->szSsht, CchSz(**hszSsht));
#ifndef STYLES
#if WINVER >= 0x300
                        /* Here we WERE allowing the hszSsht from just above
                           to be overwritten by another alloc!  This code
                           really shouldn't even be here because Write knows
                           nothing about style sheets but we want to make as
                           few changes now as possible ..pault 2/12/90 */
                        FreeH(hszSsht);
#endif
#endif
                        hszSsht = HszCreate((PCH)pfib->szSsht); /* HEAP MOVES */
#if WINVER >= 0x300
                        /* Just in case hszSsht has already been assigned
                           here, we'll free it up ..pault 2/12/90 */
                        if ((**hpfnfcb)[fn].hszSsht != NULL)
                            FreeH((**hpfnfcb)[fn].hszSsht);
#endif
                        (**hpfnfcb)[fn].hszSsht = hszSsht;
                        }
                else
                        (**hpfnfcb)[fn].hszSsht = 0;
                }

AbortWrite:
        vfnWriting = fnNil;

        FreeFfntb(hffntb);

        if (vfDiskFull || vfDiskError)
            fFileFlushed = FALSE;
        else
            fFileFlushed = FFlushFn(fn);
        CloseEveryRfn( TRUE );

        if (!fFileFlushed)  /* Writing the file has failed due to disk full */
                {
#ifdef CASHMERE
                if (hsetb != 0)
                        FreeH(hsetbT);
#endif
LFlushFailed:
                FUndirtyFn(fn);  /* Undirty all of the buffer pages
                                    holding parts of the unsuccessfully
                                    written file. */
                return false;
                }

        if (!FMakeRunTables(fn)) /* HM */
                (**hpfnfcb)[fn].fFormatted = false;

        /* Success! */
#ifdef CASHMERE
        if (hsetb != 0)
                { /* HM */
                FreeH(hsetb);
                (**hpdocdod)[doc].hsetb = hsetbT;
                }
#endif
        }
else
        {
        WriteUnformatted(fn, doc);
        vfnWriting = fnNil;
        if (vfDiskFull || vfDiskError)
            fFileFlushed = FALSE;
        else
            fFileFlushed = FFlushFn(fn);
        CloseEveryRfn( TRUE );

        if (!fFileFlushed)
            goto LFlushFailed;
        }
CloseEveryRfn( TRUE );  /* Be real sure the save file is closed */
                        /* This fixes the "pasting between Write
                           instances with the sharer loaded" bug */


return true;
}





/*----------------------------------------------------------------------------
-- Routine: ReduceFnScratchFn
-- Description: this routine is called after successful TS, TGS, GTS and
    !vfBuffersDirty.  Its purpose is to make sure that no doc has pointers
    to fnScratch and that we can empty fnScratch so as to reduce program
    disk space
-- Arguments: none
-- Returns: none
-- Side Effects: docScrap is cleaned up and becomes a new doc that has no
    pointers into fnScratch.  FnScratch is emptied, all global variables
    associated with this new fnScratch are initialized.
-- Bugs:
-- History:
     Apr 16 '84 -- created (chic)
     Aug 9  '85 -- modified it so it puts the scratch file on the same disk
                   as the passed fn to reduce disk swapping on floppy
                   systems.
----------------------------------------------------------------------------*/

ReduceFnScratchFn( fn )
{
int        doc;
struct DOD *pdod;

CHAR       sz[cchMaxFile];

int        cchT;
struct FCB *pfcb;

#ifdef BOGUSBL  /* Because of disk switching, always worth doing */
if ((**hpfnfcb)[fnScratch].fcMac > fcBound)  /* worth doing */
#endif

    {
    for (pdod = &(**hpdocdod)[0],doc = 0; doc < docMac; pdod++,doc++)
        {
        /* don't do anything if any of the allocated doc (hpctb != 0)
           except docScrap is dirty */
        /* docUndo may be dirty, but it also should be empty */

        if (doc != docScrap && pdod->hpctb != 0 && pdod->fDirty &&
            doc != docUndo)
            {
            Assert(0);
            return;
            }
        } /* end of for loop */

    Assert( (**hpdocdod) [docUndo].cpMac == cp0 );

    /* now no doc can possibly has pointers to fnScratch except docScrap */
    pdod = &(**hpdocdod)[docScrap];


#if 0
        This check was only for speed considerations.  With the 64K
        transcendence we *must* clean docScrap no matter what.
        (7.10.91) v-dougk

    if (pdod->cpMac > cpBound) /* too big to be cleaned up */
    {
        Assert(0);
        /**
            But we don't know if docScrap points into fnScratch.  We only need
            to clear docScrap if it points into fnScratch.  We shouldn't
            abort here unless we know that docScrap does indeed point into
            fnScratch.  If it doesn't then we needn't clear it and can proceed
            to clear fnScratch.

            We know that docScratch will not point to any large
            OLE object data in fnScratch because object data is never put
            into fnScratch at a time that the user could select it.
            That is, it is unlikely that the size of docScratch will
            exceed cpBound on account of object data alone.

            Only the presence of large textual data in docScratch
            is likely to cause this failure.
            (7.10.91) v-dougk
         **/
        return;
    }
    else    /* small enough to be cleaned up */
#endif
        {
        if (pdod->cpMac > cp0)
            {
#ifdef STYLES
            /* doc has to have a valid style sheet before CleanDoc */
            pdod->docSsht = (**hpdocdod)[docCur].docSsht;
#endif /* STYLES */
            CachePara(docScrap,cp0);

                /* Save docScrap to new, unique file; name in sz */
            CleanDoc( docScrap, dtyNetwork, sz, true, false );
#ifdef STYLES
            (**hpdocdod)[docScrap].docSsht = docNil;
#endif /* STYLES */
            }
        if (!ferror)  /* in case something went wrong in rename or make backup file in CleanDoc */
            {
            typePN pnMacScratch;

            pfcb = &(**hpfnfcb)[fnScratch];
            pnMacScratch = pfcb->pnMac;
            ResetFn(fnScratch); /* empty FnScratch */

#ifdef DEBUG
            OutputDebugString("*** Reduced scratch file ***\n\r");
#endif

            /* Put the scratch file on the same disk as the save file,
               to reduce disk swapping in floppy environments */

            if ( (fn != fnNil) &&
             !((POFSTRUCT)(**hpfnfcb) [fnScratch].rgbOpenFileBuf)->fFixedDisk )
                {   /* fnScratch is on removable media */
                extern CHAR szExtDoc[];
                CHAR szNewScratch[ cchMaxFile ];
                CHAR (**hszScratch)[] = (**hpfnfcb) [fnScratch].hszFile;
                CHAR chDrive = (**(**hpfnfcb) [fn].hszFile) [0];

                Assert( fn != fnScratch );
                if (FEnsureOnLineFn( fn ))
                    if (GetTempFileName( TF_FORCEDRIVE | chDrive,
                               (LPSTR)(szExtDoc+1), 0, (LPSTR) szNewScratch))
                        {   /* Created new file on same disk as fn */
                        CHAR (**hsz)[];
                        CHAR szNew [cchMaxFile];

#if WINVER >= 0x300
            /* Currently: FNormSzFile  *TAKES*   an OEM sz, and
                                      *RETURNS*  an ANSI sz ..pault */
#endif
                        FNormSzFile( szNew, szNewScratch, dtyNormal );
                        if (!FNoHeap( hsz = HszCreate(szNew)))
                            {
                            struct FCB *pfcb = &(**hpfnfcb)[fnScratch];

                            /* Delete old scratch file */

                            if (FEnsureOnLineFn( fnScratch ))
                                FDeleteFile( &(**hszScratch)[0] );

                            /* Put new scratch file back on line and
                               open it, so OpenFile gets its buffer info */

                            pfcb->hszFile = hsz;
                            pfcb->fOpened = FALSE;

                            FEnsureOnLineFn( fn );
                            FAccessFn( fnScratch, dtyNormal);
                            }
                        }
                }

            pfcb->pnMac = pnMacScratch;
            /* reset all global varibales associated with an empty fnScratch */
            fprmCache.cch = 0;
            fcMacPapIns = 0;
            fcMacChpIns = 0;
            /* just in case */
            pfcb->pnChar = pfcb->pnPara = pfcb->pnFntb = pfcb->pnSep = pfcb->pnSetb = pfcb->pnBftb = pn0;
            vfkpdParaIns.brun = vfkpdCharIns.brun = 0;
            vfkpdParaIns.bchFprop = vfkpdCharIns.bchFprop = cbFkp;
            vfkpdParaIns.pn = PnAlloc(fnScratch);
            ((struct FKP *)PchGetPn(fnScratch, vfkpdParaIns.pn,
                                    &cchT, true))->fcFirst = fc0;
            vfkpdCharIns.pn = PnAlloc(fnScratch);
            ((struct FKP *)PchGetPn(fnScratch, vfkpdCharIns.pn,
                                    &cchT, true))->fcFirst = fc0;
            vfkpdParaIns.ibteMac = vfkpdCharIns.ibteMac = 0;
            blt(&vchpNormal, &vchpInsert, cwCHP);
            blt(vppapNormal, &vpapPrevIns, cwPAPBase + cwTBD);
            } /* end of ferror */
            else
                Assert(0);
        } /* end of small enough to be cleaned up */
    } /* end of worth doing */
} /* end of ReduceFnScratchFn */






ResetFn(fn)
{ /* make fn look as if no characters have been written */
  /* but don't try to reuse fn (in that case, must rehash) */
int ibp;
register struct BPS *pbps;
struct FCB *pfcb;

Assert( fn != fnNil );
(pfcb = &(**hpfnfcb)[fn])->fcMac = fc0;
pfcb->pnMac = pn0;
for (ibp = 0, pbps = &mpibpbps [0]; ibp < ibpMax; ++ibp, ++pbps)
        {    /* find all buffer pages and "clear" them */
        if (pbps->fn == fn)
                {
#ifdef CKSM
#ifdef DEBUG
                extern unsigned (**hpibpcksm) [];

                if (!pbps->fDirty)
                    Assert( (**hpibpcksm) [ibp] == CksmFromIbp( ibp ) );
#endif
#endif
                pbps->fDirty = false;
                pbps->cch = 0;
#ifdef CKSM
#ifdef DEBUG
                    /* Recompute checksum to account for cch change */
                (**hpibpcksm) [ibp] = CksmFromIbp( ibp );
#endif
#endif
                }
        }
}



/***        FBackupSzFile - Make a backup copy of the passed szFile
 *
 *  ENTRY:  szFile - the (assumed normalized) name of the
 *                   file to back up
 *          fBackup - whether the user is interested in seeing
 *                    a backup copy of szFile
 *  EXIT:   szBak - the (normalized) name of the backup
 *                  file is returned through here
 *  RETURNS:    TRUE=We made a backup copy, szBak of szFile
 *              FALSE=We didn't/couldn't make a backup copy
 *
 *  NOTE: We try to put the backup file into the directory used
 *        as the default by GetTempFileName; in general, this
 *        effort will succeed if the directory is on the same
 *        physical drive as the original.
 *  NOTE: we may keep around a backup copy regardless of the
 *  setting of fBackup, to have access to pieces in it.
 *  However, the file's fDelete flag will be set to TRUE, marking
 *  it for eventual deletion
 */

FBackupSzFile( szFile, fBackup, szBak )    /* filenames taken as ANSI */
CHAR szFile[];
int     fBackup;
CHAR szBak[];
{ /* Copy szFile into a backup copy, and give backup old fn. */
  /* Also, return name of backup file */
int fnOld;
int f;
int fDelete = false;
int rfn;
int fTryAgain=FALSE;
CHAR chDriveTempFile;
int fn;
CHAR rgbBuf[ cbOpenFileBuf ];

#ifdef ENABLE
 if ((fn = FnFromSz( szFile )) != fnNil)
        /* Avoid share violations while checking for existence */
    CloseFn( fn );
 if (OpenFile( (LPSTR) szFile, (LPOFSTRUCT) rgbBuf, OF_EXIST ) != -1)
#endif

 if (FExistsSzFile( dtyAny, szFile ))
    {   /* File exists; make backup (even if it's on another floppy) */
    int fSame;

        /* szBak <-- backup file name (it'll be normalized since szFile is) */
    bltsz( szFile, szBak );

#ifdef INTL /* International version */
     /* if file has .WRI extension, put Write .BKP extension on,
        otherwise put Word backup extension (.BAK) on instead. */

    AppendSzExt( szBak, szExtDoc, TRUE );
    fSame = FSzSame( szFile, szBak );   /* Whether file is .WRI */
    AppendSzExt( szBak, (fSame ? szExtBackup : szExtWordBak),
                TRUE );
#else
    AppendSzExt( szBak, szExtBackup, TRUE );
#endif  /* International version */


    fSame = FSzSame( szFile, szBak );   /* Whether file is .BAK already */

    Assert( szBak [1] == ':' );
    chDriveTempFile = szBak[0];    /* Drive on which to create temp file */

    for( ;; )
        {

        if (!fBackup || fSame )
            {    /* This is just being kept for its pieces OR the file
                    happens to be .BAK already: give backup a unique name */
            CHAR szBakT [cchMaxFile];

            if (!fTryAgain)
                {   /* First time through; try not forcing the drive
                       letter to see how we fare.  The advantage is that
                       if we succeed, the temp file is in a more standard
                       place. If the rename fails, we end up at the
                       branch below. */

                fTryAgain = TRUE;       /* Try a second time if we fail */
                if (!GetTempFileName( chDriveTempFile,
                                      (LPSTR)(szExtDoc+1), 0, (LPSTR)szBakT))
                    continue;
                }
            else
                {   /* Second time through -- try forcing the drive */
                    /* Grab a temp file on the same drive as the original */

                fTryAgain = FALSE;  /* No more tries */
                if (!GetTempFileName( chDriveTempFile | TF_FORCEDRIVE,
                                      (LPSTR)(szExtDoc+1), 0, (LPSTR) szBakT))
                    {
                    Error( IDPMTSDE2 ); /* should probably GOTO HARDCORE instead */
                    return FALSE;
                    }
                }

                /* szBakT <-- Temp name in OEM */
                /* szBak  <-- Normalized temporary name in ANSI */
            FNormSzFile( szBak, szBakT, dtyNormal );
            fDelete = TRUE;
            }

        if ((fnOld = FnFromSz(szBak)) != fnNil)
            { /* We have backup open */
            CHAR szT[cchMaxFile];

            FBackupSzFile( szBak, false, szT );
            }

        if ((fnOld = FnFromSz(szFile)) != fnNil)
            { /* We have file open */
/* ? */     FFlushFn(fnOld);
            CloseFn( fnOld );
            }

        /* Rename szFile to be temp name (must delete the empty temp file) */

        if (!FDeleteFile( szBak ) || FIsErrFpe(FpeRenameFile( szFile, szBak )))
            {
            extern HWND vhWnd;
            CHAR szT [cchMaxSz];
            CHAR *pchSrc;

            if (fTryAgain)
                    /* Failed with temp name on the default drive; try again */
                continue;

            /* HARDCORE FAILURE: Could not rename file */
HardCore:
            /* pchSrc <-- ptr to start of filename (sans path) */
#ifdef DBCS //T-HIROYN 1992.07.13
            pchSrc = &szFile [CchSz( szFile )];
            while (pchSrc > szFile) {
                pchSrc = AnsiPrev(szFile,pchSrc);
                if (*pchSrc == '\\')
                    {
                    pchSrc++;
                    break;
                    }
            }
#else
            pchSrc = &szFile [CchSz( szFile ) - 1];
            while (pchSrc > szFile)
                if (*(--pchSrc) == '\\')
                    {
                    pchSrc++;
                    break;
                    }
#endif
            Assert( pchSrc > szFile );  /* Always "X:\" in normalized name */

            MergeStrings (IDPMTRenameFail, pchSrc, szT);
            IdPromptBoxSz( vhWnd, szT, ErrorLevel( IDPMTRenameFail ) );

            return FALSE;  /* We couldn't rename this file to the backup name */
            }

        if (fnOld != fnNil)
            {   /* We had an fn for the renamed file; must update fcb */
            CHAR (**hszBak)[];
            struct FCB *pfcb;

            FreeH((**hpfnfcb)[fnOld].hszFile);  /* HM */
            hszBak = HszCreate((PCH)szBak);

            pfcb = &(**hpfnfcb)[fnOld];
            pfcb->hszFile = hszBak;
            pfcb->fDelete = fDelete;
            }

        else if (!fBackup)
            {   /* Delete this NOW. (!fBackup indicates that the user
                   doesn't care about the backup copy, and Word can't care
                   about its pieces since it doesn't have an fn. So nobody
                   wants it, so we get rid of it) */
            FDeleteFile( szBak );
            return false;
            }

        return true;
        }   /* end   for( ;; ) */
    }   /* end if (FExists... */


return false;   /* file did not exist; make no backup */
}





int FExistsSzFile(dty, szFile)
int dty;
CHAR szFile[];
{ /* Return true iff file exists */
CHAR rgbBuf[ 128 ];     /* Buffer used by OpenFile */
int bRetval;

#ifdef DEBUG
    {
    int junk;
    Assert(FValidFile(szFile, CchSz(szFile)-1, &junk));
    }
#endif /*DEBUG*/

/* Use FnFromSz to avoid share violations on files we have open */

    if (FnFromSz( szFile ) != fnNil)
        return TRUE;

    SetErrorMode(1);
    bRetval = OpenFile( (LPSTR) szFile, (LPOFSTRUCT) rgbBuf, OF_EXIST ) != -1;
    SetErrorMode(0);
    return bRetval;
}





struct PGTB **HpgtbGet(doc)
int doc;
{ /* Return hpgtb if doc has one, 0 if none  */
struct DOD *pdod;

if ((pdod = &(**hpdocdod)[doc])->dty != dtyNormal)
        return 0;
else
        return pdod->hpgtb;
}





FreeFn( fn )
int fn;
{   /* Forget about the existence of file fn.  Assumes no document holds
       pieces from fn.  Frees all heap items in (**hpfnfcb) [fn] and
       marks the fcb as free (rfn == rfnNil).
      */
#define IibpHash(fn,pn) ((int) ((fn + 1) * (pn + 1)) & 077777) % iibpHashMax

 extern int iibpHashMax;
 extern CHAR *rgibpHash;
 extern struct BPS *mpibpbps;

 register struct BPS *pbps;
 int pn;

 extern CHAR (**hszTemp)[];

 register struct FCB *pfcb = &(**hpfnfcb)[fn];
 CHAR (**hsz)[] = pfcb->hszFile;
 CHAR (**hszSsht)[] = pfcb->hszSsht;
 typeFC (**hgfcChp)[]=pfcb->hgfcChp;
 typeFC (**hgfcPap)[]=pfcb->hgfcPap;

 FreezeHp();

 CloseFn( fn );

/* Purge buffer slots holding pages of fn; maintain integrity of hash chains */

 for ( pn = 0; pn < pfcb->pnMac; pn++ )
    FreeBufferPage( fn, pn );

#ifdef DEBUG
 CheckIbp();
#endif

 pfcb->fDelete = FALSE;
 pfcb->hszFile = hszTemp;
 pfcb->rfn = rfnFree;
 MeltHp();

 if ( hsz != hszTemp )
    FreeH( hsz );
#if WINVER >= 0x300
 /* Previously we allocated a small block ("") for the
    style sheet but never freed it!  ..pault 2/12/90 */
 if (hszSsht != NULL)
    FreeH(hszSsht);
#endif
 if (hgfcChp)
    FreeH( hgfcChp );
 if (hgfcPap)
    FreeH( hgfcPap );
}




/***          FUndirtyFn
 *
 *
 */

FUndirtyFn(fn)
int fn;
/*
        Description:    Mark all buffer pages holding parts of this file
                        as non-dirty.
                        Called after a disk full caused writing a file
                        to fail (in FWriteFn).
        Returns:        nothing.
*/
{
#ifdef CKSM
#ifdef DEBUG
        extern unsigned (**hpibpcksm) [];
#endif
#endif
        int ibp;
        struct BPS *pbps;
        for (ibp = 0, pbps = mpibpbps; ibp < ibpMax; ibp++,
                                                     pbps++)
                {
                if (pbps->fn == fn)
                    {
                    pbps->fDirty = FALSE;
#ifdef CKSM
#ifdef DEBUG
                    /* Update checksum */
                    (**hpibpcksm) [ibp] = CksmFromIbp( ibp );
#endif
#endif
                    }
                }

}




/***        IbpWriting - Find buffer page while writing file
 *
 *
 *
 */

IbpWriting(fn)
int fn;
/* called when trying to find a slot in the file page "cache" buffer and */
/* vfnWriting != fnNil (currently in the process of writing some file) */
{
        typeTS dTs;
        int ibp;

        if (fn == vfnWriting)
                {       /* writing a piece of the vfnWriting file */
                /* vibpWriting is the previous slot used to hold file */
                /* contents.  Keep slots contiguous and in the first */
                /* (upper) half of the buffer area. */
                if (vibpWriting > 0)
                    {   /* We may have read multiple pages last time */
                        /* Advance past all slots holding contiguous pages */
                    struct BPS *pbps=&mpibpbps[ vibpWriting ];
                    int pn=(pbps-1)->pn;

                    while ( pbps->fn == fn && pbps->pn == ++pn )
                        {
                        pbps++;
                        vibpWriting++;
                        }
                    vibpWriting--;
                    }

                if (++vibpWriting >= (ibpMax >> 1))
                        vibpWriting = 0;

                /* We must abide by the restriction that */
                /* we do not clobber the cbpMustKeep most recently used */
                /* slots in the process. */
                dTs = tsMruBps - mpibpbps[vibpWriting].ts;
                dTs = ((dTs & 0x8000) ? (~dTs + 1) : dTs);/* absolute value */
                if (dTs < cbpMustKeep)
                        vibpWriting = ibp = IbpLru(0);
                else    /* adjacent slot is o.k. - not too recently used */
                        ibp = vibpWriting;
                }
        else
                /* If currently writing a file (but the current page is */
                /* not part of it), try to find a slot in the lower half */
                /* of the buffer.  This decreases the possibility that the */
                /* adjacent slot to vibpWriting will be too recently used. */
                ibp = IbpLru(ibpMax >> 1);
        return(ibp);
}




WriteFfntb(fn, hffntb)
int fn;
struct FFNTB **hffntb;
{       /* Append a font table (ffntb) to fn */
struct FFNTB *pffntb;
struct FFN *pffn;
int iffn, cbffn;
int cchPageSpace = cbSector;
int cchWrite;
int wEndOfPage = -1;
int wEndOfTable = 0;
int cbT;

pffntb = *hffntb;
cbT = pffntb->iffnMac;
WriteRgch( fn, &cbT, sizeof (int) );
cchPageSpace = cbSector - sizeof (int);

for (iffn = 0; iffn < pffntb->iffnMac; iffn++)
    {
    pffn = *pffntb->mpftchffn[iffn];
    cchWrite = (cbffn = CbFfn(CchSz(pffn->szFfn))) + (2 * sizeof(int));

    if (cchWrite > cchPageSpace)
        {   /* This entry will not fit on the page; start new page */

        Assert( cchPageSpace >= sizeof (int ));
        WriteRgch( fn, &wEndOfPage, sizeof (int) );
        AlignFn( fn, cbSector, false );
        cchPageSpace = cbSector;
        }

    Assert( cchWrite <= cchPageSpace );

#ifdef NEWFONTENUM
    /* let's just pretend we never added a charset field... pault */
    cbffn -= sizeof(BYTE);
    WriteRgch( fn, &cbffn, sizeof (int) );  /* Write entry size in bytes */
    WriteRgch( fn, &pffn->ffid, cbffn );    /* Write the entry */
#else
    WriteRgch( fn, &cbffn, sizeof (int) );  /* Write entry size in bytes */
    WriteRgch( fn, pffn, cbffn );           /* Write the entry */
#endif
    cchPageSpace -= cbffn + sizeof (int);
    }

Assert( cchPageSpace >= sizeof (int) );
WriteRgch( fn, &wEndOfTable, sizeof(int) ); /* Table is terminated with 0000 */
}



FMapFtcSave(doc, hffntb, pchp, mpftcftc)
/* attempt to map the ftc for this chp into it's new ftc in hffntb, according
   to the mapping in mpftcftc.  If there's no entry yet for this ftc, then
   add it to the table.  Returns FALSE if there was some problem */

int doc;
struct FFNTB **hffntb;
struct CHP *pchp;
CHAR *mpftcftc;
{
int ftc, ftcNew;
struct FFN *pffn;
CHAR rgbFfn[ibFfnMax];

ftc = pchp->ftc + (pchp->ftcXtra << 6);
ftcNew = mpftcftc[ftc];
if (ftcNew == ftcNil)
        {
        /* haven't encountered this font yet - add it to hffntb and mpftcftc */
        pffn = *(*HffntbGet(doc))->mpftchffn[ftc];
        bltbyte(pffn, rgbFfn, CbFromPffn(pffn));
        ftcNew = FtcAddFfn(hffntb, pffn);
        if (ftcNew == ftcNil)
                /* some problem adding the font */
                return(FALSE);
        mpftcftc[ftc] = ftcNew;
        }

pchp->ftc = ftcNew & 0x003f;
pchp->ftcXtra = (ftcNew & 0x00c0) >> 6;
return(TRUE);
}



FInitMapSave(doc, phffntb, mpftcftc)
/* sets up for ftc mapping */

int doc;
struct FFNTB ***phffntb;
CHAR *mpftcftc;
{
bltbc( mpftcftc, ftcNil, iffnMax );
return(FNoHeap(*phffntb = HffntbAlloc()) == FALSE);
}




/* O U T  S A V E D */
OutSaved(doc)
int doc;
{
 extern int docMode;
 extern CHAR szMode[];
 int NEAR CchExpCp( CHAR *, typeCP );
 char szTmp[cchMaxSz];

 LoadString(hINSTANCE, IDSTRChars, szTmp, sizeof(szTmp));
 wsprintf(szMode,szTmp,(DWORD)(**hpdocdod)[doc].cpMac);
 docMode = docNil;
 DrawMode();
}




/* C C H  E X P  C P */
int NEAR CchExpCp(pch, cp)
CHAR *pch;
typeCP cp;
{
        int cch = 0;

        if (cp >= 10)
                {
                cch = CchExpCp(pch, cp / 10);
                pch += cch;
                cp %= 10;
                }
        *pch = '0' + cp;
        return cch + 1;
}



#if 0

SaveFontProfile(doc)
/* updates our mru font entries in win.ini */

int doc;
    {
    extern CHAR szWriteProduct[];
    extern CHAR szFontEntry[];
    int iffn;
    struct FFN *pffn;
    CHAR *pchFontNumber, *pchT;
    CHAR rgbProf[LF_FACESIZE + 10]; /* for good measure */
    CHAR rgbFfn[ibFfnMax];

    if (FInitFontEnum(doc, iffnProfMax, FALSE))
        {
        pffn = (struct FFN *)rgbFfn;
        pchFontNumber = szFontEntry + CchSz(szFontEntry) - 2;
        for (iffn = 0; iffn < iffnProfMax; iffn++)
            {
            if (!FEnumFont(pffn))
                break;
#ifdef NEWFONTENUM
#endif
            pchT = (CHAR *)bltbyte(pffn->szFfn, rgbProf, CchSz(pffn->szFfn))-1;
            *pchT++ = ',';
            ncvtu(pffn->ffid, &pchT);
#ifdef NEWFONTENUM
            /* Save the font's charset value as well */
            *pchT++ = ',';
            ncvtu(pffn->chs, &pchT);
#endif
            *pchT = '\0';

            *pchFontNumber = '1' + iffn;
            WriteProfileString((LPSTR)szWriteProduct, (LPSTR)szFontEntry,
                (LPSTR)rgbProf);
            }
        EndFontEnum();
        }
    }

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\transfer.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#include <windows.h>
#include "mw.h"
#include "doslib.h"
#include "cmddefs.h"
#include "docdefs.h"
#include "filedefs.h"
#include "str.h"
#include "debug.h"

extern int  vfnWriting;


#define IibpHash(fn,pn) ((int) ((fn + 1) * (pn + 1)) & 077777) % iibpHashMax

#define FcMin(a,b) CpMin(a,b)

extern CHAR *rgibpHash;
extern int vfSysFull;
extern struct BPS      *mpibpbps;
extern struct FCB      (**hpfnfcb)[];
extern typeTS tsMruBps;
extern CHAR                     (*rgbp)[cbSector];
#ifdef CKSM
#ifdef DEBUG
extern unsigned (**hpibpcksm) [];
#endif
#endif

/* WriteDirtyPages kicks out of memory as much of the previous files as it can
    in order to fill the page buffers with a new file.  This is called on
    every transfer load of a file. */
WriteDirtyPages()
{/*
    Description: Cleans the buffer pool of all dirty pages by writing them
                 out to disk.  If a disk full condition is reached, only
                 pages which actually made it to disk are marked as non
                 dirty.
    Returns:     nothing.
 */
    int ibp;
    struct BPS *pbps = &mpibpbps [0];

    for (ibp = 0; ibp < ibpMax; ++ibp, ++pbps)
            {
#ifdef CKSM
#ifdef DEBUG
            if (pbps->fn != fnNil && !pbps->fDirty)
                Assert( (**hpibpcksm) [ibp] == CksmFromIbp( ibp ) );
#endif
#endif
            if (pbps->fn != fnNil && pbps->fDirty)
                    {
                    FFlushFn(pbps->fn);
                         /* keep on flushing if failure ? */
                    }
            }
}


ReadFilePages(fn)
int fn;
    {
/*
        Description: ReadFilePages tries to read in as much of a file as
                it can. The idea is to fill the page buffers in anticipation of
                much access.  This is called on every Transfer Load of a file.
                If fn == fnNil or there are no characters in the file, ReadFilePages
                simply returns.
        Returns: nothing
 */
    int ibp;
    int cfcRead;
    int cpnRead;
    int dfcMac;
    typeFC fcMac;
    int ibpReadMax;
    int cfcLastPage;
    int iibp;
    struct FCB *pfcb;
        typeTS ts;

    if (fn == fnNil)
            return;

    /* Write ALL dirty pages to disk */
    WriteDirtyPages(); /* Just in case */

    pfcb = &(**hpfnfcb)[fn];

    /* we read as much of the file as will fit in the page buffers */
    /* Note that we assume that fcMax is coercable to an integer.  This
        is valid as long as ibpMax*cbSector < 32k */
    dfcMac = (int) FcMin(pfcb->fcMac, (typeFC) (ibpMax * cbSector));
    if (dfcMac == 0)
        return;
    if (vfSysFull) /* call to FFlushFn in WriteDirtyPages failed.
                      the buffer algorithm assures us that the first
                      cbpMustKeep ibp's do not contain scratch file
                      information.  Thus, there is no danger in overwriting
                      these ibps. */
        dfcMac = imin( dfcMac, (cbpMustKeep * cbSector) );

    Assert( ((int)dfcMac) >= 0 );

    /* Read pages from the file */

    cfcRead = CchReadAtPage( fn, (typePN) 0, rgbp [0], (int) dfcMac, FALSE );

    /* cfcRead contains a count of bytes read from the file */
    ibpReadMax = ((cfcRead-1) / cbSector) + 1;
    cfcLastPage = cfcRead - (ibpReadMax-1)*cbSector;
    ts = ibpMax;

    /* order time stamps so the beginning slots have the greatest ts.
    Lru allocation will start at the end of the buffer table and work
    backward.  Thus, the first page of the current file is considered
    the most recently used item.
    */

    /* describe the newly filled pages */
    for(ibp = 0; ibp < ibpReadMax; ++ibp)
        {
        struct BPS *pbps = &mpibpbps[ibp];
        pbps->fn = fn;
        pbps->pn = ibp;
        pbps->ts = --ts;
        pbps->fDirty = false;
        pbps->cch = cbSector;
        pbps->ibpHashNext = ibpNil;
        }

#ifdef CKSM
#ifdef DEBUG
    {
    int ibpT;

    for ( ibpT = 0; ibpT < ibpReadMax; ibpT++ )
        (**hpibpcksm) [ibpT] = CksmFromIbp( ibpT );
    }
#endif
#endif

    /* fix some boundary conditions */
    mpibpbps[ibpReadMax-1].cch = cfcLastPage; /* ?????? */
#ifdef CKSM
#ifdef DEBUG
    (**hpibpcksm) [ibpReadMax - 1] = CksmFromIbp( ibpReadMax - 1 );
#endif
#endif

    /* update descriptions of untouched page buffers */
    for (ibp=ibpReadMax; ibp < ibpMax; ibp++)
        {
        struct BPS *pbps = &mpibpbps[ibp];
        pbps->ts = --ts;
        pbps->fDirty = false;
        pbps->ibpHashNext = ibpNil;

#ifdef CKSM
#ifdef DEBUG
        if (pbps->fn != fnNil)
            (**hpibpcksm) [ibp] = CksmFromIbp( ibp );
#endif
#endif
        }

        tsMruBps = ibpMax - 1;

    /* recalculate the hash table */
    RehashRgibpHash();

} /* end of  R e a d F i l e P a g e s  */


RehashRgibpHash()
{
int iibp;
register struct BPS *pbps;
struct BPS *pbpsMax = &mpibpbps[ibpMax];
int iibpHash;
int ibpT;
int ibpPrev;
int ibp;

    for (iibp = 0; iibp < iibpHashMax; iibp++)
        rgibpHash[iibp] = ibpNil;

    for (ibp = 0, pbps = &mpibpbps[0]; pbps < pbpsMax; pbps++, ibp++)
        {
        if (pbps->fn == fnNil)
            continue;
        iibpHash = IibpHash(pbps->fn, pbps->pn);
        ibpT = rgibpHash[iibpHash];
        ibpPrev = ibpNil;
        while (ibpT != ibpNil)
            {
            ibpPrev = ibpT;
            ibpT = mpibpbps[ibpT].ibpHashNext;
            }
        if (ibpPrev == ibpNil)
            rgibpHash[iibpHash] = ibp;
        else
            mpibpbps[ibpPrev].ibpHashNext = ibp;
        }
#ifdef DEBUG
    CheckIbp();
#endif
} /* end of RehashRgibpHash */



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\undo.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* NOTE: the routines in this file are not written in a manner which minimizes
            code space.  It is anticipated that these routines will be swappable
            and that a reasonable optimizer will be used when compiling the code        */

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOKEYSTATE
//#define NOGDI
#define NORASTEROPS
#define NOSYSCOMMANDS
#define NOSHOWWINDOW
#define NOCOLOR
//#define NOATOM
#define NOBITMAP
#define NOICON
#define NOBRUSH
#define NOCREATESTRUCT
#define NOMB
#define NOFONT
#define NOMSG
#define NOOPENFILE
#define NOPEN
#define NOPOINT
#define NOREGION
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOWINOFFSETS
#define NOWNDCLASS
#define NOCOMM
#include <windows.h>

#include "mw.h"
#include "docdefs.h"
#include "editdefs.h"
#include "cmddefs.h"
#include "str.h"
#include "txb.h"
#include "ch.h"
#include "code.h"
#include "wwdefs.h"
#include "printdef.h"
#if defined(OLE)
#include "obj.h"
#endif

#ifndef CASHMERE
#include "propdefs.h"
#endif /* not CASHMERE */

struct UAB      vuab;

#ifdef ENABLE
VAL rgvalAgain[ivalMax];
#endif

extern struct WWD *pwwdCur;
extern typeCP   cpMacCur;
extern typeCP   cpMinCur;
extern int      vfSeeSel;
extern int      docMac;
extern int      docCur;
extern int      docScrap;
extern int      docUndo;
extern int      docBuffer;
extern int      vdocPageCache;
extern struct DOD (**hpdocdod)[];
extern struct SEL selCur;
extern CHAR (**hszReplace)[];
extern struct TXB (**hgtxb)[];
/*extern int      idstrUndoBase;*/
extern int      vfPictSel;
extern int      ferror;
extern int      docMode;
extern int      vfOwnClipboard; /* Whether this instance owns the clip contents */

#ifndef CASHMERE
extern int      vdocSectCache;
#endif /* not CASHMERE */


fnUndoEdit()
    {
    extern HCURSOR vhcIBeam;
    StartLongOp();
    CmdUndo();
    EndLongOp(vhcIBeam);
    }


/*
The routines in this file implement the "undo" and "again" features in
Multi-Tool Word.  The basic idea is that whenever an editing operation is
about to be done, the global structure "vuab" will be updated to contain
information sufficient to undo or repeat that operation.  The structure
(defined in editdefs.h, declared in this file) looks like this:
    struct UAB
            { UNDO Action Block
            int             uac;     UNDO Action Code (see cmddefs.h)
            int             doc;
            typeCP          cp;
            typeCP          dcp;
            int             doc2;
            typeCP          cp2;
            typeCP          dcp2;
            short               itxb;
            };
Setting up this structure is taken care of by "SetUndo()" which does a lot
of plugging in of values and a couple pseudo-smart things.  These smartish
things are:
    a) If an insert is made and the last operation was a delete
        the two are combined into one "replace" operation.
        This means that undo-ing and again-ing apply to the replace and
        not just the insertion.

    b) When needed (see the code for details) the undo buffer (docUndo)
        is filled with any text that needs preservation for future
        undo-ing or again-ing.  The main example of this is storing away
        the old value of the scrap when an operation is about to clobber
        the scrap.

Here is a list of the various uac values and what info is stored
    other info may be clobbered by the process.
    are defined in cmddefs.h.  Note that none of the "undo" codes
    (those starting with "uacU...") should be set outside of CmdUndo(),
    since they may assume things like contents of docUndo which could
    be wrong.
Note: This list store information used by the again and undo commands.
    Other info may be clobbered by the process.

uacNil          No action stored.
uacInsert
    doc = document text was inserted into
    cp = location at which text was inserted
    dcp = length of inserted text
uacUInsert
    doc = document from which text was removed (un-inserted)
    cp = location at which text was removed
    docUndo = text which was removed
uacReplNS
    doc = document in which replacement occurred
    cp = location at which replacement occurred
    dcp = length of inserted text
    dcp2 = length of deleted text
    docUndo = deleted text
uacUReplNS
    doc = document in which replace occrred
    cp = location of the replace
    dcp = length of re-inserted text
    dcp2 = length of un-inserted text
    docUndo = un-inserted text
uacReplGlobal
uacChLook
uacChLookSect
uacFormatChar
uacFormatPara
uacFormatSection
uacGalFormatChar
uacGalFormatPara
uacGalFormatSection
uacFormatCStyle
uacFormatPStyle
uacFormatSStyle
uacFormatRHText
uacLookCharMouse
uacLookParaMouse
uacClearAllTab
uacFormatTabs
uacClearTab
uacOvertype
    Similar to uacReplNS except that they are agained differently.
uacDelNS
    doc = document from which text was deleted
    cp = location at which text was deleted
    dcp = length of deleted text
    docUndo = deleted text
uacUDelNS
    doc = document in which text was re-inserted
    cp = location at which text was re-inserted
    dcp = length of re-inserted text
uacMove
    doc = document from which text was deleted
    cp = location at which text was deleted
    dcp = length of deleted text
            (also serves as length of inserted text)
    doc2 = document in which text was inserted
    cp2 = location at which text was inserted
uacDelScrap
    doc = document from which text was deleted
    cp = location at which text was deleted
    dcp = length of deleted text
    docUndo = old contents of scrap
uacUDelScrap
    doc = document in which text was re-inserted
    cp = location at which text was re-inserted
    dcp = length of re-inserted text
uacReplScrap
    doc = document in which replacement occurred
    cp = location at which replacement occurred
    dcp = length of inserted text
    docUndo = old contents of scrap
uacUReplScrap
    doc = document in which replacement was undone
    cp = location at which replacement was undone
    dcp = length of re-inserted text
    docUndo = deleted text (was originally inserted)
uacDelBuf
    doc = document from which text was deleted
    cp = location at which text was deleted
    cp2 = location in docBuffer of old contents of buffer
    dcp2 = size of old contents of buffer
    itxb = index of buffer in question
uacUDelBuf
    doc = document in which text was re-inserted
    cp = location of re-insertion
    dcp = amount of text re-inserted
    itxb = index of buffer involved
uacReplBuf
    doc = document in which replace took place
    cp = location of replace
    dcp = length of inserted text
    cp2 = location of old buffer contents in docBuffer
    dcp2 = length of old buffer contents
    itxb = index of buffer involved
uacUReplBuf
    doc = document in which original replace took place
    cp = location of replace
    dcp = length of text which was restored in document
    itxb = index of buffer involved
    docUndo = un-inserted text
uacCopyBuf
    cp = location of old buffer contents in docBuffer
    dcp = length of old buffer contents
    itxb = index of buffer involved
uacUCopyBuf
    cp = location of undone buffer contents in docBuffer
    dcp = length of undone buffer contents
    itxb = index of buffer involved
*/


CmdUndo()
{ /* UNDO */
    typeCP dcpT,cpT,dcpT2;
    int docT;
    int f;
    struct DOD *pdod, *pdodUndo;
    int uac;

#ifndef CASHMERE
    struct SEP **hsep;
    struct TBD (**hgtbd)[];
    struct PGTB **hpgtb;
    struct PGTB **hpgtbUndo;
    struct PGTB **hpgtbT;

    BOOL near FCopyPgtb(int, struct PGTB ***);
#endif /* not CASHMERE */

    TurnOffSel();
    ClearInsertLine();
    switch (uac = vuab.uac)
        {
        struct TXB *ptxb;
        default:/* case uacNil: */
            Assert(false);  /* Won't get here cause menu should be greyed */
            return;
        case uacInsert:
        case uacInsertFtn:
        case uacUDelNS:
            ClobberDoc(docUndo, vuab.doc, vuab.cp, vuab.dcp);
            Replace(vuab.doc, vuab.cp, vuab.dcp, fnNil, fc0, fc0);
            dcpT = cp0;
            vuab.uac = (uac == uacUDelNS) ? uacDelNS : uacUInsert;
/*          idstrUndoBase = uac == uacUDelNS ? IDSTRUndoBase : IDSTRUndoRedo;*/
            SetUndoMenuStr(IDSTRUndoBase);
            if (uac == uacInsertFtn)
                TrashAllWws();  /* Simple, but effective */
            break;
        case uacUInsert:
        case uacDelNS:
            ReplaceCps(vuab.doc, vuab.cp, cp0, docUndo, cp0, dcpT = vuab.dcp);
            vuab.uac = (uac == uacUInsert) ? uacInsert : uacUDelNS;
/*          idstrUndoBase = uac == uacUInsert ? IDSTRUndoBase : IDSTRUndoRedo;*/
            SetUndoMenuStr(IDSTRUndoBase);
            break;

        case uacDelScrap:   /* UNDO CUT */
            if ( !vfOwnClipboard )
                ferror = TRUE;
            else
                {
                ReplaceCps(vuab.doc, vuab.cp, cp0, docScrap, cp0,
                                                dcpT = CpMacText(docScrap));
                vuab.uac = uacUDelScrap;
/*              idstrUndoBase = IDSTRUndoRedo;*/
                SetUndoMenuStr(IDSTRUndoBase);
                ClobberDoc( docScrap, docUndo, cp0, CpMacText( docUndo ) );
                ChangeClipboard();
                }
            break;

        case uacUDelScrap:  /* REDO CUT */
            ClobberDoc( docUndo, docScrap, cp0, CpMacText( docScrap ) );
/*          idstrUndoBase = IDSTRUndoBase;*/
            SetUndoMenuStr(IDSTRUndoBase);
            vuab.uac = uacDelScrap;

            ClobberDoc(docScrap, vuab.doc, vuab.cp, vuab.dcp);
            Replace(vuab.doc, vuab.cp, vuab.dcp, fnNil, fc0, fc0);
            ChangeClipboard();

            dcpT = 0;
            break;
        case uacReplScrap:      /* UNDO COPY */
            if (!vfOwnClipboard)
                ferror = TRUE;
            else
                {
                dcpT = CpMacText(docScrap);
                ReplaceCps(vuab.doc, vuab.cp + vuab.dcp, cp0,
                           docScrap, cp0, dcpT);

                ClobberDoc( docScrap, docUndo, cp0, CpMacText( docUndo ) );

/*              idstrUndoBase = IDSTRUndoRedo;*/
                SetUndoMenuStr(IDSTRUndoBase);
                vuab.uac = uacUReplScrap;

                ClobberDoc(docUndo, vuab.doc, vuab.cp, vuab.dcp);
                Replace(vuab.doc, vuab.cp, vuab.dcp, fnNil, fc0, fc0);
                vuab.dcp = dcpT;
                ChangeClipboard();
                }
            break;
        case uacUReplScrap:      /* REDO COPY */
            dcpT = CpMacText(docUndo);
            ReplaceCps(vuab.doc, vuab.cp + vuab.dcp, cp0,
                       docUndo, cp0, dcpT);

            ClobberDoc( docUndo, docScrap, cp0, CpMacText( docScrap ));
/*          idstrUndoBase = IDSTRUndoBase;*/
            SetUndoMenuStr(IDSTRUndoBase);
            vuab.uac = uacReplScrap;

            ClobberDoc(docScrap, vuab.doc, vuab.cp, vuab.dcp);
            Replace(vuab.doc, vuab.cp, vuab.dcp, fnNil, fc0, fc0);
            vuab.dcp = dcpT;

            ChangeClipboard();
            break;
#ifdef DEBUG
        case uacUCopyBuf:
        case uacCopyBuf:
        case uacUReplBuf:
        case uacReplBuf:
        case uacUDelBuf:
        case uacDelBuf:

            Assert( FALSE );    /* No buffers in MEMO */
#ifdef ENABLE
            DoUndoTxb(); /* Moved to txb.c */
#endif
            break;
#endif  /* DEBUG */
        case uacMove:
            if (!FMoveText(vuab.doc2, vuab.cp2, vuab.dcp, vuab.doc, &vuab.cp, fFalse))
                return;
            dcpT = vuab.dcp;
            cpT = vuab.cp;
            vuab.cp = vuab.cp2;
            vuab.cp2 = cpT;
            docT = vuab.doc;
            vuab.doc = vuab.doc2;
            vuab.doc2 = docT;
            CheckMove();
            break;
        case uacUReplNS:
        case uacChLook:
        case uacChLookSect:
        case uacReplNS:
        case uacFormatChar:
        case uacFormatPara:
        case uacGalFormatChar:
        case uacGalFormatPara:
        case uacGalFormatSection:
        case uacReplGlobal:
        case uacFormatCStyle:
        case uacFormatPStyle:
        case uacFormatSStyle:
        case uacFormatRHText:
        case uacLookCharMouse:
        case uacLookParaMouse:
        case uacClearAllTab:
        case uacClearTab:
        case uacOvertype:

#ifdef CASHMERE
        case uacFormatTabs:
        case uacFormatSection:
#endif /* CASHMERE */

#ifdef BOGUS
            /* Must do insertion first, in front, in case footnote */
/*          if (uac == uacOvertype)
                vuab.dcp2 = CpMin(vuab.dcp, vuab.dcp2);*/
            dcpT = vuab.dcp2;
            ReplaceCps(vuab.doc, vuab.cp, cp0, docUndo, cp0, dcpT);
            ClobberDoc(docUndo, vuab.doc, vuab.cp + dcpT, vuab.dcp);
            Replace(vuab.doc, vuab.cp + dcpT, vuab.dcp, fnNil, fc0, fc0);
            vuab.dcp2 = vuab.dcp;
            vuab.dcp = dcpT;
            if(uac == uacReplNS)
                vuab.uac = uacUReplNS;
            else if(uac == uacUReplNS)
                vuab.uac = uacReplNS;
/*          idstrUndoBase = uac != uacUReplNS ? IDSTRUndoRedo : IDSTRUndoBase;*/
            SetUndoMenuStr(IDSTRUndoBase);
            break;
#endif
        case uacReplPic:
        case uacUReplPic:
        case uacPictSel:
            dcpT = uac != uacPictSel ? vuab.dcp2 : vuab.dcp;
            ReplaceCps(docUndo, dcpT, cp0, vuab.doc, vuab.cp, vuab.dcp);
            ReplaceCps(vuab.doc, vuab.cp, vuab.dcp, docUndo, cp0, dcpT);
            Replace(docUndo, cp0, dcpT, fnNil, fc0, fc0);
            if (uac != uacPictSel)
                {
                vuab.dcp2 = vuab.dcp;
                vuab.dcp = dcpT;
                }
            if (uac == uacPictSel)
                {
                dcpT = (**hpdocdod)[vuab.doc].cpMac - vuab.cp;
                AdjustCp(vuab.doc, vuab.cp, dcpT, dcpT);
                }
            if(uac == uacReplPic)
                vuab.uac = uacUReplPic;
            else if(uac == uacUReplPic)
                vuab.uac = uacReplPic;
            else if(uac == uacReplNS)
                vuab.uac = uacUReplNS;
            else if(uac == uacUReplNS)
                vuab.uac = uacReplNS;
/*          switch(uac)                                          */
/*          {                                                    */
/*          case uacUReplPic:                                    */
/*          case uacUReplNS:                                     */
/*              idstrUndoBase = IDSTRUndoBase;                   */
/*              break;                                           */
/*          case uacReplPic:                                     */
/*          case uacReplNS:                                      */
/*              idstrUndoBase = IDSTRUndoRedo;                   */
/*              break;                                           */
/*          default:                                             */
/*              idstrUndoBase = (idstrUndoBase ==                */
/*                IDSTRUndoRedo) ? IDSTRUndoBase : IDSTRUndoRedo;*/
/*              break;                                           */
/*          }                                                    */
/*---       idstrUndoBase = (uac != uacUReplPic && uac != uacUReplNS) ?
                                                IDSTRUndoRedo : IDSTRUndoBase;---*/
            SetUndoMenuStr(IDSTRUndoBase);
            Select( CpFirstSty( selCur.cpFirst, styChar ),
                    CpLastStyChar( selCur.cpLim ) );
            break;

#ifndef CASHMERE
        case uacRepaginate:
            /* Make a copy of the document's page table. */
            if (!FCopyPgtb(vuab.doc, &hpgtb) || !FCopyPgtb(docUndo, &hpgtbUndo))
                {
                break;
                }

            /* Swap the contents of the entire document with docUndo. */
            dcpT = CpMacText(vuab.doc);
            dcpT2 = CpMacText(docUndo);
            ReplaceCps(docUndo, dcpT2, cp0, vuab.doc, cp0, dcpT);
            ReplaceCps(vuab.doc, cp0, dcpT, docUndo, cp0, dcpT2);
            Replace(docUndo, cp0, dcpT2, fnNil, fc0, fc0);

            /* Swap the page tables of the two documents. */
            if ((hpgtbT = (**hpdocdod)[vuab.doc].hpgtb) != NULL)
                {
                FreeH(hpgtbT);
                }
            (**hpdocdod)[vuab.doc].hpgtb = hpgtbUndo;
            if ((hpgtbT = (**hpdocdod)[docUndo].hpgtb) != NULL)
                {
                FreeH(hpgtbT);
                }
            (**hpdocdod)[docUndo].hpgtb = hpgtb;
            vdocPageCache = docNil;
            break;
        case uacFormatSection:
            pdod = &(**hpdocdod)[vuab.doc];
            pdodUndo = &(**hpdocdod)[docUndo];
            hsep = pdod->hsep;
            pdod->hsep = pdodUndo->hsep;
            pdodUndo->hsep = hsep;
            hpgtb = pdod->hpgtb;
            pdod->hpgtb = pdodUndo->hpgtb;
            pdodUndo->hpgtb = hpgtb;
/*          idstrUndoBase = (idstrUndoBase == IDSTRUndoRedo) ? IDSTRUndoBase :*/
/*            IDSTRUndoRedo;*/
            SetUndoMenuStr(IDSTRUndoBase);
            vdocSectCache = vdocPageCache = docMode = docNil;
            TrashAllWws();
            break;
        case uacRulerChange:
            ReplaceCps(docUndo, vuab.dcp2, cp0, vuab.doc, vuab.cp, vuab.dcp);
            ReplaceCps(vuab.doc, vuab.cp, vuab.dcp, docUndo, cp0, vuab.dcp2);
            Replace(docUndo, cp0, vuab.dcp2, fnNil, fc0, fc0);
            dcpT = vuab.dcp;
            vuab.dcp = vuab.dcp2;
            vuab.dcp2 = dcpT;

            /* This is a kludge to indicate that this is an undone ruler change.
            */
            vuab.itxb = 1 - vuab.itxb;
        case uacFormatTabs:
            pdod = &(**hpdocdod)[vuab.doc];
            pdodUndo = &(**hpdocdod)[docUndo];
            hgtbd = pdod->hgtbd;
            pdod->hgtbd = pdodUndo->hgtbd;
            pdodUndo->hgtbd = hgtbd;
/*          idstrUndoBase = (idstrUndoBase == IDSTRUndoRedo) ? IDSTRUndoBase :*/
/*            IDSTRUndoRedo;*/
            SetUndoMenuStr(IDSTRUndoBase);
            TrashAllWws();
            break;
#endif /* not CASHMERE */

#if UPDATE_UNDO
#if defined(OLE)
        case uacObjUpdate:
        case uacUObjUpdate:
            ObjDoUpdateUndo(vuab.doc,vuab.cp);
            if (uac == uacObjUpdate)
            {
                vuab.uac = uacUObjUpdate;
                SetUndoMenuStr(IDSTRUndoBase);
            }
        break;
#endif
#endif
        }
    if (ferror)
        NoUndo();
    pdod = &(**hpdocdod)[vuab.doc];
    pdodUndo = &(**hpdocdod)[docUndo];
    f = pdod->fDirty;
    pdod->fDirty = pdodUndo->fDirty;
    pdodUndo->fDirty = f;
    f = pdod->fFormatted;
    pdod->fFormatted = pdodUndo->fFormatted;
    pdodUndo->fFormatted = f;

#ifdef CASHMERE
    if (uac != uacMove
#else /* not CASHMERE */
    if (uac != uacMove && uac != uacFormatTabs && uac != uacFormatSection &&
      uac != uacRulerChange
#endif /* not CASHMERE */

      && docCur != docNil && vuab.doc == docCur && vuab.cp >= cpMinCur &&
      vuab.cp + dcpT <= cpMacCur)
        {
        if (uac == uacPictSel)
                {
                Select(vuab.cp, CpLimSty(vuab.cp, styPara));
                vfPictSel = true;
                }
        else
#ifdef BOGUS
                Select( vuab.cp,
                        (dcpT == cp0) ? CpLastStyChar( vuab.cp ) :
                                        vuab.cp + dcpT );
#endif
                Select( vuab.cp, vuab.cp + dcpT );
        vfSeeSel = true;
        }
}


BOOL near FCopyPgtb(doc, phpgtb)
int doc;
struct PGTB ***phpgtb;
    {
    /* This sets *phpgtb to a copy of the page table associated with doc.  FALSE
    is returned iff an error occurs in creating the copy of the page table. */

    struct PGTB **hpgtbT;

    if ((hpgtbT = (**hpdocdod)[doc].hpgtb) == NULL)
        {
        *phpgtb = NULL;
        }
    else
        {
        int cwpgtb = cwPgtbBase + (**hpgtbT).cpgdMax * cwPGD;

        if (FNoHeap(*phpgtb = (struct PGTB **)HAllocate(cwpgtb)))
            {
            return (FALSE);
            }
        blt(*hpgtbT, **phpgtb, cwpgtb);
        }
    return (TRUE);
    }


#ifdef CASHMERE     /* No Repeat-last-command in MEMO */
CmdAgain()
{ /* use the undo action block to repeat a command */
    int uac;
    typeCP dcpT;
    typeCP cpFirst;
    typeCP cpLim;
    typeCP dcp;
    struct DOD *pdod, *pdodUndo;

    /* First check error conditions; this may change selCur */
    switch (uac = vuab.uac)
        {
        case uacReplBuf:
        case uacUReplBuf:
        case uacDelBuf:
        case uacUDelBuf:
        case uacUDelNS:
        case uacDelNS:
        case uacUDelScrap:
        case uacDelScrap:
        case uacUReplNS:
        case uacOvertype:
        case uacReplNS:
        case uacReplGlobal:
        case uacReplScrap:
        case uacUReplScrap:
            /* Ensure OK to delete here */
            if (!FWriteOk(fwcDelete))
                return;
            break;
        case uacUCopyBuf:
        case uacCopyBuf:
            if (false)
                return;
            break;
        case uacUInsert:
        case uacInsert:
            if (!FWriteOk(fwcInsert))
                    return;
            break;
        case uacMove:
            /* Ensure OK to edit here */
            if (!FWriteOk(fwcInsert))
                return;
            break;
        default:
            break;
        }

    /* Now set up cp's and dispatch */
    cpFirst = selCur.cpFirst;
    cpLim = selCur.cpLim;
    dcp = cpLim - cpFirst;
    switch (uac = vuab.uac)
        {
        struct TXB *ptxb;
        default:
        /* case uacNil: */
            _beep();
            return;
#ifdef ENABLE       /* NO GLOSSARY IN MEMO */
        case uacReplBuf:
        case uacUReplBuf:
        case uacDelBuf:
        case uacUDelBuf:
        case uacUCopyBuf:
        case uacCopyBuf:
            DoAgainTxb(dcp, cpFirst);
            break;
#endif  /* ENABLE */
        case uacUInsert:
            ReplaceCps(docCur, cpFirst, cp0, docUndo, cp0, vuab.dcp);
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            Select(cpFirst+vuab.dcp, CpLastStyChar(cpFirst+vuab.dcp));
            vuab.uac = uacInsert;
            break;
        case uacInsert:
            ClobberDoc(docUndo, vuab.doc, vuab.cp, vuab.dcp);
            ReplaceCps(docCur, cpFirst, cp0, docUndo, cp0, vuab.dcp);
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            Select(cpFirst+vuab.dcp, CpLastStyChar(cpFirst+vuab.dcp));
            break;
        case uacUDelNS:
        case uacDelNS:
            ClobberDoc(docUndo, docCur, cpFirst, dcp);
            Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            vuab.dcp = dcp;
            vuab.uac = uacDelNS;
            Select(cpFirst,CpLastStyChar(cpFirst));
            break;
        case uacUDelScrap:
        case uacDelScrap:
            ClobberDoc(docUndo,docScrap,cp0,CpMacText(docScrap));
            ClobberDoc(docScrap, docCur, cpFirst, dcp);
            Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            vuab.dcp = dcp;
            vuab.uac = uacDelScrap;
            Select(cpFirst, CpLastStyChar(cpFirst));
            break;
        case uacUReplNS:
            vuab.dcp2 = vuab.dcp;
            ReplaceCps(docCur, cpLim, cp0, docUndo, cp0,
                        vuab.dcp = CpMacText(docUndo));
            ClobberDoc(docUndo, docCur, cpFirst, dcp);
            Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            Select(cpFirst+vuab.dcp, CpLastStyChar(cpFirst + vuab.dcp));
            vuab.uac = uacReplNS;
            break;
        case uacOvertype:
            /* for this one vuab.cp2 is the DCP of how much was actually
                inserted */
            vuab.dcp = vuab.cp2;
            /* fall through...*/
        case uacReplNS:
            ClobberDoc(docUndo, vuab.doc, vuab.cp, vuab.dcp);
            ReplaceCps(docCur, cpLim, cp0, docUndo, cp0, vuab.dcp);
            ClobberDoc(docUndo, docCur, cpFirst, dcp);
            Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
            dcpT = vuab.dcp;
            vuab.dcp2 = dcp;
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            vuab.uac = uacReplNS;
            if (ferror) /* the operation (cmd "a") could not be completed
                           due to out of memory */
                NoUndo();
            else
                Select(cpFirst+vuab.dcp, CpLastStyChar(cpFirst + dcpT));
            break;
        case uacChLook:
        case uacChLookSect:
#ifdef ENABLE   /* ChLook stuff is not hooked up yet */

            DoChLook(chAgain,0);
#endif
            break;
        case uacReplGlobal:
            ClobberDoc(docUndo, docCur, cpFirst, dcp);
            Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
            vuab.dcp2 = dcp;
            dcp = (typeCP)(CchSz(**hszReplace) - 1);
            InsertRgch(docCur, cpFirst, **hszReplace, dcp, 0, 0);
            vuab.dcp = dcp;
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            Select(cpFirst+vuab.dcp, CpLastStyChar(cpFirst + vuab.dcp));
            vuab.uac = uacReplNS;
            break;
        case uacReplScrap:
            ClobberDoc(docUndo, vuab.doc, vuab.cp, vuab.dcp);
            ReplaceCps(docCur, cpLim, cp0, docUndo, cp0, vuab.dcp);
            ClobberDoc(docUndo,docScrap,cp0,CpMacText(docScrap));
            ClobberDoc(docScrap, docCur, cpFirst, dcp);
            Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            Select(cpFirst+vuab.dcp, CpLastStyChar(cpFirst + vuab.dcp));
            break;
#ifdef ENABLE   /* Not used in SAND */
        case uacFormatCStyle:
            DoFormatCStyle(rgvalAgain);
            break;
        case uacFormatPStyle:
            DoFormatPStyle(rgvalAgain);
            break;
        case uacFormatSStyle:
            DoFormatSStyle(rgvalAgain);
            break;
#endif /* ENABLE */
#ifdef ENABLE   /* Not hooked up yet */
        case uacLookCharMouse:
            AgainLookCharMouse();
            break;
        case uacLookParaMouse:
            AgainLookParaMouse();
            break;
#endif /* ENABLE */
#ifdef ENABLE   /* Not used in SAND */
        case uacClearTab:
            DoClearTab(true);
            vuab.uac = uac;
            break;
        case uacClearAllTab:
            CmdClearAllTab();
            vuab.uac = uac;
            break;
#endif /* ENABLE */
#ifdef ENABLE       /* Formatting menu stuff is not hooked up yet */
        case uacFormatTabs:
            DoFormatTabs(true);
            vuab.uac = uac;
            break;
        case uacFormatRHText:
            DoFormatRHText(rgvalAgain);
            break;
        case uacFormatChar:
            DoFormatChar(rgvalAgain);
            break;
        case uacFormatPara:
            DoFormatPara(rgvalAgain);
            break;
        case uacFormatSection:
            DoFormatSection(rgvalAgain);
            break;
#endif  /* ENABLE */
#ifdef STYLES
        case uacGalFormatChar:
            DoGalFormatChar(rgvalAgain);
            break;
        case uacGalFormatPara:
            DoGalFormatPara(rgvalAgain);
            break;
        case uacGalFormatSection:
            DoGalFormatSection(rgvalAgain);
            break;
#endif /* STYLES */
        case uacUReplScrap:
            ReplaceCps(docCur, cpLim, cp0, docUndo, cp0,
                        vuab.dcp = CpMacText(docUndo));
            ClobberDoc(docUndo,docScrap,cp0,CpMacText(docScrap));
            ClobberDoc(docScrap, docCur, cpFirst, dcp);
            Replace(docCur, cpFirst, dcp, fnNil, fc0, fc0);
            vuab.doc = docCur;
            vuab.cp = cpFirst;
            Select(cpFirst+vuab.dcp, CpLastStyChar(cpFirst + vuab.dcp));
            vuab.uac = uacReplScrap;
            break;
        case uacMove:
            if (!FMoveText(vuab.doc2, vuab.cp2, vuab.dcp, docCur, &cpFirst, fFalse))
                return;
            vuab.cp = vuab.cp2;
            vuab.cp2 = cpFirst;
            vuab.doc = vuab.doc2;
            vuab.doc2 = docCur;
            CheckMove();
            break;
        }
    vfSeeSel = true;
}
#endif  /* CASHMERE */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\util.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* util.c -- more frequently used utility routines */
#define NOCOLOR
#define NOCOMM
#define NOCLIPBOARD
#define NOCTLMGR
#define NOGDICAPMASKS
#define NOMENUS
#define NOSOUND
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#include <windows.h>

#if WINVER < 0x300
#define SM_CURSORLEVEL 25
#endif

#include "mw.h"
#include "doslib.h"
#include "str.h"
#include "machdefs.h"
#include "cmddefs.h"
#include "propdefs.h"
#include "fkpdefs.h"
#include "docdefs.h"
#include "debug.h"
#include "editdefs.h"
#include "wwdefs.h"
#define NOKCCODES
#include "ch.h"

extern struct DOD   (**hpdocdod)[];
extern HANDLE       hMmwModInstance;

CHAR *PchFillPchId(PCH, int);

typeCP CpMax(cp1, cp2)
typeCP cp1, cp2;
{{ /* return larger of two cps */
    return((cp1 > cp2) ? cp1 : cp2);
}} /* end of C p M a x  */


typeCP CpMin(cp1, cp2)
typeCP cp1, cp2;
{{ /* return smaller of two cps */
    return((cp1 < cp2) ? cp1 : cp2);
}} /* end of C p M i n  */


unsigned umin( w1, w2 )
register unsigned w1, w2;
{  return (w1 < w2) ? w1 : w2;  }


unsigned umax( w1, w2 )
register unsigned w1, w2;
{  return (w1 > w2) ? w1 : w2;  }


int imin( i1, i2 )
register int i1, i2;
{  return (i1 < i2) ? i1 : i2;  }


int imax( i1, i2 )
register int i1, i2;
{  return (i1 > i2) ? i1 : i2;  }


#define BZNATIVE
#ifndef BZNATIVE
/* C C H  D I F F E R */
/* commented out, moved to native code in lib.asm bz 6/20/85 */
int CchDiffer(rgch1, rgch2, cch)
register CHAR *rgch1, *rgch2;
int cch;
{{ /* Return cch of shortest prefix leaving a common remainder */
int ich;

for (ich = cch - 1; ich >= 0; ich--)
    if (rgch1[ich] != rgch2[ich])
        break;
return ich + 1;
}}
#endif


int CchSz(sz)
register CHAR  sz[];
{ /* Returns length of string in bytes, including trailing 0 */
    register int cch = 1;
    while (*sz++ != 0)
        cch++;
    return cch;
} /* end of  C c h S z */



typeCP CpMacText(doc)
register int doc;
{
#ifdef FOOTNOTES
    struct FNTB **hfntb;
    if ((hfntb = HfntbGet(doc)) != 0)
        return((**hfntb).rgfnd[0].cpFtn - ccpEol);
    else
#endif /* FOOTNOTES */
        return((**hpdocdod)[doc].cpMac);

} /* end of C p M a c T e x t */


struct FNTB **HfntbGet(doc)
register int doc;
{ /* Return hfntb if doc has one, 0 if none or style sheet */
#ifdef STYLES
    register struct DOD *pdod;

    if ((pdod = &(**hpdocdod)[doc])->dty == dtySsht)
        return 0;
    else
#endif
        return (**hpdocdod)[doc].hfntb;
} /* end of  H F n t b G e t  */


/* N O  U N D O */
NoUndo()
{
    extern struct UAB vuab;
    vuab.uac = uacNil;
    SetUndoMenuStr(IDSTRUndoBase);
} /* end of  N o U n d o  */




SetUndoMenuStr(idstr)
int idstr;
{
    extern int idstrCurrentUndo;

    idstrCurrentUndo = idstr;
}


/* Returns number chars copied EXCLUDING zero terminator */

int CchCopySz(pchFrom, pchTo)
register PCH pchFrom;
register PCH pchTo;
{
int cch = 0;
while ((*pchTo = *pchFrom++) != 0)
    {
    pchTo++;
    cch++;
    }
return cch;
} /* end of  C c h C o p y S z  */




/*---------------------------------------------------------------------------
-- Routine: WCompSz(psz1,psz2)
-- Description and Usage:
    Alphabetically compares the two null-terminated strings lpsz1 and lpsz2.
    Upper case alpha characters are mapped to lower case.
    Comparison of non-alpha characters is by ascii code.
    Returns 0 if they are equal, a negative number if lpsz1 precedes lpsz2, and
    a non-zero positive number if lpsz2 precedes lpsz1.
-- Arguments:
    psz1, psz2  - pointers to two null-terminated strings to compare
-- Returns:
    a short - 0 if strings are equal, negative number if lpsz1 precedes lpsz2,
    and non-zero positive number if psz2 precedes psz1.
-- Side-effects: none
-- Bugs:
-- History:
    3/14/83 - created (tsr)
    6/12/86 - Kanji Version (yxy)
----------------------------------------------------------------------------*/
short

WCompSz(psz1,psz2)
register PCH psz1;
register PCH psz2;
{
    int ch1;
    int ch2;

    for(ch1=ChLower(*psz1++),ch2=ChLower(*psz2++);
      ch1==ch2;
    ch1=ChLower(*psz1++),ch2=ChLower(*psz2++))
    {
    if(ch1 == '\0')
        return(0);
    }
    return(ch1-ch2);
} /* end of  W C o m p S z   */


/*---------------------------------------------------------------------------
-- Routine: ChLower(ch)
-- Description and Usage:
    Converts its argument to lower case iff its argument is upper case.
    Returns the de-capitalized character or the initial char if it wasn't caps.
-- Arguments:
    ch      - character to be de-capitalized
-- Returns:
    a character - initial character, de-capitalized if needed.
-- Side-effects:
-- Bugs:
-- History:
    3/14/83 - created (tsr)
----------------------------------------------------------------------------*/
int
ChLower(ch)
register CHAR    ch;
{ /* use Windows' ANSI char set, the difference of upper/lower case
     is also 20 (HEX) for foreign chars */
#ifdef JAPAN
// check for half-size katakana.
    extern struct WWD       rgwwd[];
    extern BOOL IsKanaInDBCS(int);
    static TEXTMETRIC   tm;


/**/
    BOOL ret1;
    BOOL ret2;
#if 0 //T-HIROYN
    ret1 = IsWindow(wwdCurrentDoc.wwptr);
    ret2 = GetTextMetrics(wwdCurrentDoc.hDC,(LPTEXTMETRIC)&tm);
    if(ret1 && ret2)
    {
        if(tm.tmCharSet == SHIFTJIS_CHARSET && IsKanaInDBCS((int)ch))
            return (int)(0x00ff&ch);
    }
#else
    ret1 = IsWindow(wwdCurrentDoc.wwptr);
    if (ret1)
    {
        ret2 = GetTextMetrics(wwdCurrentDoc.hDC,(LPTEXTMETRIC)&tm);
        if(ret2)
        {
            if(tm.tmCharSet == SHIFTJIS_CHARSET && IsKanaInDBCS((int)ch))
                return (int)(0x00ff&ch);
        }
    }
#endif
#if 0
    if(IsWindow(wwdCurrentDoc.wwptr)
        && GetTextMetrics(wwdCurrentDoc.hDC,(LPTEXTMETRIC)&tm)){
        if(tm.tmCharSet == SHIFTJIS_CHARSET && IsKanaInDBCS((int)ch))
            return (int)(0x00ff&ch);
    }
#endif
#endif

#ifdef  KOREA
    if(isupper(ch) && !((ch > 0xa1) && (ch < 0xfe)))
#else
    if(isupper(ch))
#endif

    return(ch + ('a' - 'A')); /* foreign is taken care of */
    else
    return ch;
} /* end of  C h L o w e r  */



static int cLongOpCount = 0; /* to ensure we don't do too much hide cursor */

StartLongOp()
{
extern int vfInLongOperation;
extern int vfCursorVisible;
extern int vfMouseExist;
extern HCURSOR vhcHourGlass;

int cursorlevel;

if (cLongOpCount++ == 0)
    {
    vfInLongOperation = TRUE;
    vfCursorVisible = TRUE;

    if (!vfMouseExist)
    { /* in a mouseless system, set the cursor to middle of window */
    extern HWND vhWndMsgBoxParent;
    extern HWND hParentWw;
    extern int  vfInitializing;
    RECT  rect;
    POINT pt;
    HWND  hWnd = vhWndMsgBoxParent;

    if (vhWndMsgBoxParent == NULL)
        hWnd = hParentWw; /* next choice */
    if (!vfInitializing && hWnd != NULL && IsWindow(hWnd))
        { /* we have a good window to put in */
        GetClientRect(hWnd, (LPRECT)&rect);
        pt.x = (rect.right - rect.left) / 2;
        pt.y = (rect.bottom - rect.top) / 2;
        ClientToScreen(hWnd, (LPPOINT)&pt);
        }
    else
        { /* put in the middle of screen */
        HDC hDCScreen = GetDC(NULL);
        if (hDCScreen == NULL)
        goto Out; /* the worst, setcursor only */
        pt.x = GetDeviceCaps(hDCScreen, HORZRES) / 2;
        pt.y = GetDeviceCaps(hDCScreen, VERTRES) / 2;
        ReleaseDC(NULL, hDCScreen);
        }
    SetCursorPos(pt.x, pt.y);
    }
Out:
    SetCursor(vhcHourGlass);
#if WINVER < 0x300
    ShowCursor(TRUE);

    /* precaution - make sure the cusor is visible */
    cursorlevel = GetSystemMetrics(SM_CURSORLEVEL);
#else
    /* use a supported method to get cursor level! ..pault 2/6/90 */
    cursorlevel = ShowCursor(TRUE);
#endif
    while (cursorlevel++ < 0)
        ShowCursor(TRUE);
    }
}


EndLongOp(hc)
HCURSOR hc; /* cursor to be changed to */
{
extern int vfInLongOperation;
extern int vfCursorVisible;
extern int vfMouseExist;
extern int          vfDeactByOtherApp;

int cursorlevel;

#ifdef JAPAN   // added by Hiraisi (BUG#3628/WIN31)
{
   RECT rc;
   POINT pt;
   extern int xpSelBar, dxpScrlBar, dypScrlBar;
   extern HWND hParentWw;
   extern HCURSOR vhcArrow, vhcBarCur;

   GetClientRect(hParentWw, (LPRECT)&rc);
   rc.right -= dxpScrlBar;
   rc.bottom -= dypScrlBar;
   GetCursorPos((LPPOINT)&pt);
   ScreenToClient(hParentWw,(LPPOINT)&pt);
   if( !PtInRect((LPRECT)&rc, pt) )     // out of edit area
      hc = vhcArrow;
   else
      if( pt.x <= xpSelBar )            // within selection bar
         hc = vhcBarCur;
}
#endif

if (cLongOpCount > 0)
    {
    if (vfDeactByOtherApp && (cLongOpCount == 1)) // OLE presents this case
    {
        vfInLongOperation = FALSE;
        vfCursorVisible = FALSE;
        SetCursor(vfMouseExist ? hc : NULL);
    }
    else if (--cLongOpCount == 0)
    {
    vfInLongOperation = FALSE;
    vfCursorVisible = FALSE;
#if WINVER < 0x300
    ShowCursor(FALSE);
    SetCursor(vfMouseExist ? hc : NULL);

    /* make sure the cursor is still visible in a mouse system
    and invisible in a mouseless system */
    cursorlevel = GetSystemMetrics(SM_CURSORLEVEL);
#else
    /* use a supported method to get cursor level! ..pault 2/6/90 */
    cursorlevel = ShowCursor(FALSE);
    SetCursor(vfMouseExist ? hc : NULL);
#endif
    if (vfMouseExist)
        {
        while (cursorlevel++ < 0)
        ShowCursor(TRUE);
        }
    else /* no mouse */
        {
        while (cursorlevel-- >= 0)
            ShowCursor(FALSE);
        }
    }
    }
}


/* String utility functions - moved here from string.c */

/* I N D E X */
/* ** Returns pointer to first occurrence of character ch found in null-
      terminated string pch, or 0 if ch does not appear.  If ch==0, we
      return a pointer to the null terminator. */
/*    In Kanji version, a kanji character is excluded from the search. */

CHAR *index(pch, ch)
REG1 CHAR *pch;
REG2 CHAR ch;  // fixed bug, previously int (2.11.91) D. Kent
    {
    while (low(*pch)!=ch)
        {
#ifdef  DBCS    /* KenjiK '90-11-20 */
        if (*pch=='\0')
#else
        if (*pch++=='\0')
#endif
            return(NULL);
#ifdef  DBCS    /* KenjiK '90-11-20 */
        pch = AnsiNext(pch);
#endif
        }
    return(pch);
    }

/* We may want to make these 'type' functions into macros */
/* These are designed for ANSI character set (used by windows) only */

/* I S  A L P H A */
/* ** TRUE if ch is a letter, FALSE otherwise */

isalpha(ch)
REG1 CHAR ch;
    {/* Note: even though DF and FF are lowercase, they have no
           corresponding uppercase, so they are excluded from the
           lowercase class, and simply mapped to themselves */
    return(islower(ch) || isupper(ch) || ch == 0x00FF || ch == 0x00DF);
    }


/* ** TRUE if ch is a lowercase letter, FALSE otherwise */

/* I S  L O W E R */
islower(ch)
REG1 CHAR ch;
    {/* Note: even though DF and FF are lowercase, they have no
           corresponding uppercase, so they are excluded from the
           lowercase class, and simply mapped to themselves */
    return((ch >= 'a' && ch <= 'z') ||
        /* foreign */
        (ch >= 0x00E0 && ch <= 0x00F6) ||
        (ch >= 0x00F8 && ch <= 0x00FE) );
    }

/* ** TRUE if ch is an uppercase letter, FALSE otherwise */

isupper(ch)
REG1 CHAR ch;
    {
    return((ch >= 'A' && ch <= 'Z') ||
        /* foreign */
        (ch >= 0x00C0 && ch <= 0x00D6) ||
        (ch >= 0x00D8 && ch <= 0x00DE));
    }

/* ** TRUE if ch is a digit, FALSE otherwise */

isdigit(ch)
REG1 CHAR ch;
    {
    return(ch>='0' && ch<='9');
    }


#ifdef ENABLE
/* ** TRUE if ch is a character or a digit, FALSE otherwise */

isalnum(ch)
REG1 CHAR ch;
    {
    return(isalpha(ch) || isdigit(ch));
    }
#endif



int ChUpper(ch)
REG1 CHAR ch;
{
#ifdef DBCS
  return AnsiUpper( ch );
#else
#ifdef BOGUS
return (ch >= 'a' && ch <= 'z') ? ch + ('A' - 'a') : ch;
#endif
/* use Windows' ANSI char set, the difference of upper/lower case
     is also 20 (HEX) for foreign chars */

    if (islower(ch))
    return(ch + ('A' - 'a')); /* foreign is taken care of */
    else return(ch);
#endif
}




/* similar to blcomp except compares by bytes and is not case sensitive */
BOOL FRgchSame(rgch1, rgch2, cch)
CHAR rgch1[], rgch2[];
int cch;
    {
    short ich;

    for(ich = 0; ich < cch; ich++)
    {
    if(ChLower(rgch1[ich]) != ChLower(rgch2[ich]))
        return(FALSE);
    }
    return(TRUE);
    }

/* PchStartBaseNameSz() ---- returns a character pointer to the
                 beginning of a base file name.  If
                 the name only consists of a base
                 name, sz is returned.

   Note: If sz ends with a back-slash or a colon, pch returned
     is pointing to the null terminator of the given string. */

CHAR *PchStartBaseNameSz(sz)
    CHAR    *sz;
{
    CHAR *pchBS, *pchC, *pchLast;
    CHAR *PchLastSzCh();

    pchBS = PchLastSzCh(sz, '\\');
    pchC  = PchLastSzCh(sz, ':');
    pchLast = (pchBS > pchC) ? pchBS : pchC;
    if (pchLast == NULL) {
    pchLast = sz;
    }
    else {
    pchLast++;
    }
    return (pchLast);
}

/* PchLastSzCh() ----- returns a pointer to the last occurrence of a given
               character in a given string.  If it does not occur
               in the string, it returns NULL.  If the given
               character is '\0', it returns sz itself.
   Note: All kanji characters are excluded from the search.        */

CHAR *PchLastSzCh(sz, ch)
    CHAR    *sz;
    CHAR    ch;
{
    if (ch == '\0') {
    return (sz);
    }
    else {
    CHAR    *pchCur, *pchLast;

#ifdef  DBCS
    for (pchLast = pchCur = sz; *pchCur != '\0'; pchCur = AnsiNext(pchCur))
#else
    for (pchLast = pchCur = sz; *pchCur != '\0'; pchCur++)
#endif
    {
             {
        if (low(*pchCur) == ch) {
            pchLast = pchCur;
            }
        }
        }
    return ((pchLast == sz) ? NULL : pchLast);
    }
}

#ifdef DEBUG
_Assert(pch, line, f)
PCH pch;
int line;
BOOL f;
    {
    if (!f)
    Do_Assert(pch, line, f);
    }
#endif

#ifdef JAPAN /*t-Yoshio*/
myHantoZen(char *han_str,char *zen_str,int buffsize)
{
    extern CHAR Zenstr1[256];
    extern CHAR Zenstr2[256];
    CHAR far    *ZenTbl;
    int length = 0;
    int sub;

    while((CHAR)*han_str) {
        if(length+3 > buffsize)
            break;

        if((CHAR)*han_str >= 0x20 && (CHAR)*han_str < 0x7f) {
            ZenTbl = Zenstr1;
            sub = ((CHAR)*han_str-0x20)*2;
            han_str++;
            *zen_str = ZenTbl[sub];
            *(zen_str+1) = ZenTbl[sub+1];
            zen_str+=2;
            length+=2;
            continue;
        }
        else if((CHAR)*han_str >= 0xa1 && (CHAR)*han_str <= 0xdd) {
            ZenTbl = Zenstr2;
            if((CHAR)*han_str >= 0xca && (CHAR)*han_str <= 0xce) {
                if((CHAR)*(han_str+1) == 0xde ) {
                    sub = ((CHAR)*han_str-0xa1+35)*2;
                    han_str+=2;
                }
                else if((CHAR)*(han_str+1) == 0xdf ) {
                    sub = ((CHAR)*han_str-0xa1+40)*2;
                    han_str+=2;
                }
                else {
                    sub = ((CHAR)*han_str-0xa1)*2;
                    han_str++;
                }
            }
            else if((CHAR)*han_str >= 0xa6 && (CHAR)*han_str <= 0xc4) {
                if((CHAR)*(han_str+1) == 0xde ) {
                    sub = ((CHAR)*han_str-0xa1+40)*2;
                    han_str+=2;
                }
                else {
                    sub = ((CHAR)*han_str-0xa1)*2;
                    han_str++;
                }
            }
            else {
                sub = ((CHAR)*han_str-0xa1)*2;
                han_str++;
            }

            *zen_str = ZenTbl[sub];
            *(zen_str+1) = ZenTbl[sub+1];
            zen_str+=2;
            length+=2;
            continue;
        }
        else {
            if(IsDBCSLeadByte((BYTE)(*han_str))) {
                *zen_str = *han_str;
                *(zen_str+1) = (CHAR)*(han_str+1);
                zen_str+=2;
                length+=2;
                han_str+=2;
            }
            else {
                *zen_str = *han_str;
                *zen_str++;length++;han_str++;
            }
            continue;
        }
    }
    *zen_str = '\0';
}
myIsSonant(BYTE dbcshi,BYTE dbcslow)
{
    static unsigned short hanzen[] = {
    0x834b, 0x834d, 0x834f, 0x8351, 0x8353,
    0x8355, 0x8357, 0x8359, 0x835b, 0x835d,
    0x835f, 0x8361, 0x8364, 0x8366, 0x8368,
    0x836f, 0x8370, 0x8372, 0x8373, 0x8375,
    0x8376, 0x8378, 0x8379, 0x837b, 0x837c
    };
    unsigned int dbyte;
    int i;

    dbyte = (((WORD)(dbcshi) << 8) | ((WORD)(dbcslow) & 0x00ff));
    for(i = 0;i < 25;i++)
    {
        if(dbyte == hanzen[i])
            return TRUE;
    }
    return FALSE;
}
#elif defined(KOREA)
myHantoZen(char *han_str,char *zen_str,int buffsize)
{
    extern CHAR Zenstr1[256];
    CHAR far    *ZenTbl;
    int length = 0;
    int sub;

    while((CHAR)*han_str) {
        if(length+3 > buffsize)
            break;

        if((CHAR)*han_str >= 0x20 && (CHAR)*han_str < 0x7f) {
            ZenTbl = Zenstr1;
            sub = ((CHAR)*han_str-0x20)*2;
            han_str++;
            *zen_str = ZenTbl[sub];
            *(zen_str+1) = ZenTbl[sub+1];
            zen_str+=2;
            length+=2;
            continue;
        }
        else {
            if(IsDBCSLeadByte((BYTE)(*han_str))) {
                *zen_str = *han_str;
                *(zen_str+1) = (CHAR)*(han_str+1);
                zen_str+=2;
                length+=2;
                han_str+=2;
            }
            else {
                *zen_str = *han_str;
                *zen_str++;length++;han_str++;
            }
            continue;
        }
    }
    *zen_str = '\0';
}
myIsSonant(BYTE dbcshi,BYTE dbcslow)
{
    static unsigned short hanzen[] = {
    0x834b, 0x834d, 0x834f, 0x8351, 0x8353,
    0x8355, 0x8357, 0x8359, 0x835b, 0x835d,
    0x835f, 0x8361, 0x8364, 0x8366, 0x8368,
    0x836f, 0x8370, 0x8372, 0x8373, 0x8375,
    0x8376, 0x8378, 0x8379, 0x837b, 0x837c
    };
    unsigned int dbyte;
    int i;

    dbyte = (((WORD)(dbcshi) << 8) | ((WORD)(dbcslow) & 0x00ff));
    for(i = 0;i < 25;i++)
    {
        if(dbyte == hanzen[i])
            return TRUE;
    }
    return FALSE;
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\util2.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* util2.c -- less frequently used utility routines */
#define NOVIRTUALKEYCODES
#define NOCTLMGR
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NOMENUS
#define NOCOMM
#define NOSOUND
#include <windows.h>

#include "mw.h"
#include "doslib.h"
#include "str.h"
#include "machdefs.h"
#include "cmddefs.h"
#include "propdefs.h"
#include "fkpdefs.h"
#include "docdefs.h"
#include "debug.h"
#include "editdefs.h"
#include "wwdefs.h"
#define NOKCCODES
#include "ch.h"

extern struct DOD	(**hpdocdod)[];
extern HANDLE		hMmwModInstance;
extern CHAR		vchDecimal;  /* "decimal point" character */
extern int     viDigits;
extern BOOL    vbLZero;
CHAR *PchFillPchId(PCH, int, int);



FillStId(st, idpmt, cchIn)
CHAR *st;
IDPMT idpmt;
int  cchIn;
{ /* load string from resource file to buffer, the string is zero
     terminated, make it into a st, i.e. cch (excluding '\0' is stored
     in the 1st byte of the string) */

	int cch = LoadString(hMmwModInstance, idpmt, (LPSTR)&st[1], cchIn-1);
	Assert(cch != 0);
	st[0] = cch;
} /* FillStId */


CHAR *PchFillPchId(sz, idstr, cchIn)
register CHAR * sz;
register int idstr;
int cchIn;
{ /*
     Description: load string from resource file to buffer, the
		  string loaded is zero terminated
     Returns:	  pointer to '\0' last loaded
*/
	int cch = LoadString(hMmwModInstance, idstr, (LPSTR)sz, cchIn);
 /* Note: cch does not include the '\0' */
{
    char msg[80];
    if (cch == 0)
    {
        wsprintf(msg,"bad resource id: 0x%x\n\r",idstr);
        OutputDebugString(msg);
    }
	Assert(cch != 0);
}
	return(sz + cch);
} /* end of PchFillPchId */


int FDirtyDoc(doc)
register int doc;
{ /* Return true if killing this doc would lose editing */
	register struct DOD *pdod;
	return ((pdod = &(**hpdocdod)[doc])->fDirty && pdod->cref == 1);
} /* end of  F D i r t y D o c */


int ncvtu(n, ppch)
register int n;
CHAR **ppch;
{
	register int cch = 0;

	if (n < 0)
		{
		*(*ppch)++ = '-';
		n = -n;
		++cch;
		}

	if (n >= 10)
		{
		cch += ncvtu(n / 10, ppch);
		n %= 10;
		}
    else if ((n == 0) && !vbLZero) // then no leading zero
	    return 0;

	*(*ppch)++ = '0' + n;
	return cch + 1;
} /* end of n c v t uR */


HANDLE HszGlobalCreate( sz )
CHAR *sz;
{   /* Create handle for string in global windows heap. return the handle. */
 HANDLE h;
 LPCH lpch;
 int cch=CchSz( sz );

 if ((h=GlobalAlloc( GMEM_MOVEABLE, (LONG)cch )) != NULL)
    {
    if ((lpch = GlobalLock( h )) != NULL )
	{
	bltbx( (LPSTR) sz, lpch, cch );
	GlobalUnlock( h );
	}
    else
	{
	GlobalFree( h );
	return NULL;
	}
    }
 return h;
}




#ifdef DEBUG
fnScribble( dchPos, ch )
int dchPos;
CHAR ch;
{    /* Scribble a char dchPos char positions from the UR screen corner */
     /* We create a special device context to avoid interfering with the */
     /* ones MEMO uses */
 extern struct WWD rgwwd[];

 static unsigned dxpScribbleChar=0;
 static unsigned dypScribbleChar;
 static unsigned ypScribble;

 int xp = wwdCurrentDoc.xpMac - (dxpScribbleChar * (dchPos+1));
 int ilevel = SaveDC( wwdCurrentDoc.hDC );

 SelectObject( wwdCurrentDoc.hDC, GetStockObject(ANSI_FIXED_FONT) );

 if ( dxpScribbleChar == 0 )
    {	/* First time through */
    TEXTMETRIC tm;

    GetTextMetrics( wwdCurrentDoc.hDC, (LPTEXTMETRIC)&tm );
    dxpScribbleChar = tm.tmAveCharWidth;
    dypScribbleChar = tm.tmHeight + tm.tmInternalLeading;
    ypScribble = (dypScribbleChar >> 2) + wwdCurrentDoc.ypMin;
    }
 PatBlt( wwdCurrentDoc.hDC, xp, ypScribble, dxpScribbleChar, dypScribbleChar,
	 WHITENESS );
 TextOut( wwdCurrentDoc.hDC, xp, ypScribble, (LPSTR) &ch, 1 );
 RestoreDC( wwdCurrentDoc.hDC, ilevel );
}
#endif	/* DEBUG */


/* original util3.c  starts from here */

#define iMaxOver10    3276
extern int	utCur;

/* Must agree with cmddefs.h */
extern CHAR    *mputsz[];

/* Must agree with cmddefs.h */
unsigned mputczaUt[utMax] =
	{
	czaInch,	czaCm,	      czaP10,	     czaP12,	  czaPoint,
	czaLine
	};



int FZaFromSs(pza, ss, cch, ut)
int	*pza;
CHAR	ss[];
int	cch,
	ut;
{ /* Return za in *pza from string representation in ss.  True if valid za */
long	lza	 = 0;
register CHAR	 *pch	 = ss;
register CHAR  *pchMac = &ss[cch];
int	ch;
unsigned czaUt;
int	fNeg;

if (cch <= 0)
	return false;

switch (*--pchMac)
	{ /* Check for units */
case 'n': /* inch */
	if (*--pchMac != 'i')
		goto NoUnits;
case '"': /* inch */
	ut = utInch;
	break;

#ifdef CASHMERE /* units such as pt, pt12, pt10 */
case '0': /* pt10 */
	if (*--pchMac != '1' || *--pchMac != 'p')
		goto NoUnits;
	ut = utP10;
	break;
case '2': /* pt12 */
	if (*--pchMac != '1' || *--pchMac != 'p')
		goto NoUnits;
	ut = utP12;
	break;
case 'i': /* line */
	if (*--pchMac != 'l')
		goto NoUnits;
	ut = utLine;
	break;
case 't': /* pt */
	if (*--pchMac != 'p')
		goto NoUnits;
	ut = utPoint;
	break;
#endif /* CASHMERE */

case 'm': /* cm */
	if (*--pchMac != 'c')
		goto NoUnits;
	ut = utCm;
	break;
default:
	++pchMac;
	break;
NoUnits:
	pchMac = &ss[cch];
	}

while (pch < pchMac && *(pchMac - 1) == chSpace)
	--pchMac;

czaUt = mputczaUt[ut];

/* extract leading blanks */
while (*pch == ' ')
    pch++;

fNeg = *pch == '-';
if (fNeg) ++pch;	/* skip past minus sign */
while ((ch = *pch++) != vchDecimal)
	{
	if ((ch < '0' || ch > '9') || lza >= iMaxOver10)
		return false;
	lza = lza * 10 + (ch - '0') * czaUt;
	if (pch >= pchMac)
		goto GotNum;
	}

while (pch < pchMac)
	{
	ch = *pch++;
	if (ch < '0' || ch > '9')
		return false;
	lza += ((ch - '0') * czaUt + 5) / 10;
	czaUt = (czaUt + 5) / 10;
	}

GotNum:
if (lza > ((long) (22 * czaInch)))
	return false;

*pza = fNeg ? (int) -lza : (int) lza;
return true;
}



int
CchExpZa(ppch, za, ut, cchMax)
CHAR **ppch;
int ut, cchMax;
register int za;
{ /* Stuff the expansion of linear measure za in unit ut into pch.
	Return # of chars stuffed.  Don't exceed cchMax. */
register int cch = 0;
unsigned czaUt;
int zu;

/* If not in point mode and even half line, display as half lines v. points */
if (ut == utPoint && utCur != utPoint &&
    (za / (czaLine / 2) * (czaLine / 2)) == za)
	ut = utLine;


czaUt = mputczaUt[ut];
if (cchMax < cchMaxNum)
	return 0;

if (za < 0)
	{ /* Output minus sign and make positive */
	*(*ppch)++ = '-';
	za = -za;
	cch++;
	}

/* round off to two decimal places */
za += czaUt / 200;

zu = za / czaUt;	/* Get integral part */

cch += ncvtu(zu, ppch); /* Expand integral part */

za -= zu * czaUt; /* Retain fraction part */

if (((za *= 10) >= czaUt || za * 10 >= czaUt) && (viDigits > 0))
	{ /* Check *10 first because of possible overflow */
	zu = za / czaUt;

    *(*ppch)++ = vchDecimal;
    cch++;

	*(*ppch)++ = '0' + zu;
	cch++;
	zu = ((za - zu * czaUt) * 10) / czaUt;
	if ((zu != 0) && (viDigits > 1))
		{
		*(*ppch)++ = '0' + zu;
		cch++;
		}
	}

if (cch <= 1)
/* force zeroes */
{
    if ((cch == 0) && vbLZero) // then no leading zero
    {
	    *(*ppch)++ = '0';
        cch++;
    }
    *(*ppch)++ = vchDecimal;
	cch++;
    if (viDigits > 0)
    {
	    *(*ppch)++ = '0';
		cch++;
    }
    if (viDigits > 1)
    {
	    *(*ppch)++ = '0';
		cch++;
    }
}

cch += CchStuff(ppch, mputsz[ut], cchMax - cch);

return cch;
}


#ifdef KEEPALL /* Use FPdxaFromItDxa2Id */
int DxaFromSt(st, ut)
register CHAR	 *st;
int	ut;
{
int	za;

if (*st > 0 && FZaFromSs(&za, st+1, *st, ut))  /* see util.c */
	return za;
else
	return valNil;
}

int DxaFromItem(it)
int	it;
{
int	za;
register CHAR	 stBuf[32];

GetItTextValue(it, stBuf);

if (*stBuf > 0 && FZaFromSs(&za, stBuf+1, *stBuf, utCur))  /* see util.c */
	return (za == valNil) ? 0 : za;
else
	return valNil;
}
#endif

int CchStuff(ppch, sz, cchMax)
CHAR **ppch, sz[];
int cchMax;
{
register int cch = 0;
register CHAR *pch = *ppch;

while (cchMax-- > 0 && (*pch = *sz++) != 0)
	{
	cch++;
	pch++;
	}

if (cchMax < 0)
	bltbyte("...", pch - 3, 3);

*ppch = pch;
return cch;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\wwactde.c ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#define NOCLIPBOARD
#define NOGDICAPMASKS
#define NOCTLMGR
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#include <windows.h>

#include "mw.h"
#include "cmddefs.h"
#include "dispdefs.h"
#include "wwdefs.h"
#include "docdefs.h"
#include "propdefs.h"
#include "fmtdefs.h"
#include "printdef.h"   /* printdefs.h */

/*         E X T E R N A L S        */

extern int wwCur;
extern struct WWD rgwwd[];
extern struct DOD (**hpdocdod)[];
extern struct SEL selCur;
extern int docCur;
extern int    vdocPageCache;
extern typeCP vcpMinPageCache;
extern typeCP vcpMacPageCache;
extern int    vipgd;
extern struct WWD *pwwdCur;
extern typeCP cpMinCur;
extern typeCP cpMacCur;
extern int docMode;
extern int vfPictSel;
extern int vfSizeMode;
extern struct PAP vpapAbs;
extern typeCP vcpLimParaCache;
extern struct CHP vchpFetch;
extern struct CHP vchpSel;
extern struct FLI vfli;
extern int ichpMacFormat;
extern struct CHP (**vhgchpFormat)[];
extern int wwMac;
extern int docScrap;
extern int docUndo;

extern  CHAR (**vhrgbSave)[];




/* N E W  C U R  W W */
NewCurWw(ww, fHighlight)
int ww, fHighlight;
        {
        extern HWND vhWnd;
        struct   PGTB  **hpgtb;

        Assert( (ww >= 0) && (ww < wwMac) );

        if ( wwCur != wwNil )
            {   /* Clean up from old window */
            /* Discard the screen fonts. */
            FreeFonts( TRUE, FALSE );
            pwwdCur->sel = selCur;
            }

        if (ww >= 0)
                {
                docCur = (pwwdCur = &rgwwd[wwCur = ww])->doc;

                vhWnd = pwwdCur->wwptr;

/* If the new current document has no page table or has no page descriptors */
/*  in its page table, all text in the document is considered to be on */
/*  page 1 of the document. In this case, preload the cache used by    */
/*  procedure CachePage.                                               */
                hpgtb = (**hpdocdod)[docCur].hpgtb;
                if (hpgtb == 0 || (**hpgtb).cpgd == 0)
                        {
                        vdocPageCache = docCur;
                        vcpMinPageCache = cp0;
                        vcpMacPageCache = cpMax;
                        vipgd = -1;
                        }

#ifdef ENABLE /* we now do if in ChangeWwDoc where it is more appropriate */
/* Since we are changing windows, ensure that we don't use parameters
                set by a search in a previous window by setting flag false */
                vfDidSearch = false;
                cpWall = selCur.cpLim;
#endif

/* active bit is valid only in upper panes. Means when window is active
upper pane is active. False means lower pane is active */
#ifdef SPLITTERS
                if (pwwdCur->fLower)
                        rgwwd[pwwdCur->ww].fActive = fFalse;
                else
#endif
                        pwwdCur->fActive = fTrue;

                selCur = pwwdCur->sel;
#ifdef ENABLE
                if (pwwdCur->fFtn)
                        { /* It's a footnote window */
                        cpMinCur = pwwdCur->cpMin;
                        cpMacCur = pwwdCur->cpMac;
                        if (fHighlight &&
                           ((selCur.cpFirst < cpMinCur) ||
                            (selCur.cpLim > cpMacCur)))
                            {
                            Select(cpMinCur, CpLastStyChar(cpMinCur));
                            }
                        }
                else
#endif
#ifdef ONLINEHELP
                if (ww == wwHelp)
                        {   /* It's the help document window */
                            /* Limit cp range to the current help topic */
                        cpMinCur = pwwdCur->cpMin;
                        cpMacCur = pwwdCur->cpMac;
                        }
                else
#endif

                if (ww == wwClipboard)
                        {   /* Displaying the clipboard contents */
                        cpMinCur = cp0;
                        cpMacCur = CpMacText( docScrap );
                        Assert( docCur == docScrap );
                        goto SetWwCps;
                        }
                else
                        { /* Normal window -- editing document, header, or footer */
                        Assert( !(pwwdCur->fEditFooter && pwwdCur->fEditHeader) );
                        ValidateHeaderFooter( docCur );

                        if (pwwdCur->fEditHeader)
                            {
                            extern typeCP cpMinHeader, cpMacHeader;

                            cpMinCur = cpMinHeader;
                            cpMacCur = cpMacHeader - ccpEol;
                            }
                        else if (pwwdCur->fEditFooter)
                            {
                            extern typeCP cpMinFooter, cpMacFooter;

                            cpMinCur = cpMinFooter;
                            cpMacCur = cpMacFooter - ccpEol;
                            }
                        else
                            {   /* Editing document */
                            extern typeCP cpMinDocument;

                            cpMinCur = cpMinDocument;
                            cpMacCur = CpMacText( docCur );
                            }
 SetWwCps:
                        cpMacCur = CpMax( cpMacCur, cpMinCur );
                        pwwdCur->cpMin = cpMinCur;
                        pwwdCur->cpMac = cpMacCur;
                        }
                }
#ifdef ENABLE   /* wwCur change is sensed in CtrBackTrs so we don't
                   trash the cache until we really have to */
        TrashCache();           /* Cache valid for wwCur only */
#endif
#ifdef ENABLE   /* We only switch among doc, clipbrd, help - no need */
        docMode = docNil;       /* Invalidate page display */
#endif
        vfSizeMode = false;

        if (selCur.cpFirst >= cp0)
                {
                if ((selCur.cpFirst == selCur.cpLim) && (docCur != docScrap) )
                        GetInsPtProps(selCur.cpFirst);
                CachePara(docCur, selCur.cpFirst);
                vfPictSel = vpapAbs.fGraphics &&
                                    (selCur.cpLim == vcpLimParaCache);
                }
#ifdef ENABLE
        if (fHighlight)
                { /* Shrink heap blocks for FormatLine.  Call this when it's
                possible that the contents of the screen have gotten less complex */
                if (ichpMacFormat > 2 * ichpMacInitFormat)
                        { /* If it's not that big, don't worry about it */
                        vfli.doc = docNil;
                        ichpMacFormat = ichpMacInitFormat;
                        FChngSizeH(vhgchpFormat, ichpMacInitFormat * cwCHP, true);
                        }
                }
#endif /* ENABLE */
        }




WwAlloc( hWnd, doc )
HWND hWnd;
int   doc;
{       /* Allocate a new ww entry. This is used in MEMO for the clipboard
           and for the HELP document window. Some of the code is specific
           to these windows (e.g. "style" scroll bars used instead of controls)
           WARNING: The caller must set the scroll bar range 0-drMax;
           MEMO does NOT use the windows default values and we don't set them
           here because of the clipboard */

#define dlMaxGuess  10

 extern int wwMac;
 extern int wwCur;
 extern struct WWD rgwwd[];
 extern struct WWD *pwwdCur;
 extern int docScrap;
 int ww;
 register struct WWD *pwwd;

 if (wwMac >= wwMax)
    {
    Assert( FALSE );
    return wwNil;
    }
 pwwd = &rgwwd[ ww = wwMac ];

        /* Start with all fields == 0 */
 bltc( pwwd, 0, cwWWDclr );

 pwwd->doc = doc;

    /* Set the remaining fields as in [CREATEWW] WwNew */
 if (FNoHeap( pwwd->hdndl=(struct EDL (**)[])HAllocate(dlMaxGuess * cwEDL) ))
        return wwNil;
 bltc( *(pwwd->hdndl), 0, dlMaxGuess * cwEDL );
 pwwd->dlMac = pwwd->dlMax = dlMaxGuess;
 pwwd->hHScrBar = pwwd->hVScrBar = pwwd->wwptr = hWnd;
 pwwd->sbHbar = SB_HORZ;
 pwwd->sbVbar = SB_VERT;
 pwwd->fDirty = TRUE;
 pwwd->fActive = TRUE;
 pwwd->sel.fForward = TRUE;
 pwwd->cpMac = CpMacText( pwwd->doc );
 pwwd->ypFirstInval = ypMaxAll;        /* See WwNew() */

 wwMac++;

 return ww;
}



FreeWw( ww )
register int ww;
{       /* Free the wwd entry for the clipboard or help window. Close up
           rgwwd & null out wwClipboard or wwHelp, as appropriate */
 if (ww == wwDocument)
    {
    Assert( FALSE );
    return;
    }

 FreeH( rgwwd [ww].hdndl );
 if (ww == wwClipboard)
    wwClipboard = wwNil;
#ifdef ONLINEHELP
 else if (ww == wwHelp)
    wwHelp = wwNil;
#endif
 else
    Assert( FALSE );


 if (ww < --wwMac)
    {   /* Left hole in wwd structure, close it up */
    bltbyte( &rgwwd[ ww + 1], &rgwwd[ ww ],
             sizeof( struct WWD ) * (wwMac - ww) );

    if (wwClipboard > ww)
        wwClipboard--;
#ifdef ONLINEHELP
    else if (wwHelp > ww)
        wwHelp--;
#endif
    else
        Assert( FALSE );
    }
}





#ifdef CASHMERE
/* C L O S E  W W */
CloseWw(ww)
int     ww;
{       /* Close a window */
        struct WWD      *pwwd, *pwwdT;
        int wwCurNew = wwCur;
        int wwT;
        int cdl;
/* note ww and wwCur are not necessarily the same because of the scrap */
        if (wwCur > 0)
                blt(&selCur, &(rgwwd[wwCur].sel), cwSEL);
        pwwd = &rgwwd[ww];
        --wwMac;
        if (!pwwd->fLower && !pwwd->fSplit)
                {
                KillDoc(pwwd->doc);
                if (wwCurNew >= wwMac)
                        wwCurNew = wwMac - 1;
                }
        else
                { /* split or lower */
                wwCurNew = pwwd->ww;
                }

/* Free up the space that was used by this window */
        FreeH(pwwd->hdndl);
        /* Deallocate part of the emergency space reserved for save operations
                since we now have one less window and thus one less potential
                save to do. */
        FChngSizeH(vhrgbSave, max((cwSaveAlloc+(wwMac-1)*cwHeapMinPerWindow),
                                                                cwSaveAlloc), true);


/* Close up the gap in wwd's */
        if (ww != wwMac && wwMac > 0)
                blt(pwwd + 1, pwwd, cwWWD * (wwMac - ww));
        else
                rgwwd[wwMac].wwptr = 0l;

        if (wwCurNew > ww)
                --wwCurNew;

        /* Update links to windows above the closure */
        for (pwwd = &rgwwd[0], wwT = 0; wwT < wwMac; pwwd++, wwT++)
                {
                if ((pwwd->fSplit || pwwd->fLower) && pwwd->ww > ww)
                        pwwd->ww--;
                }

/* Don't make the Clipboard window into the current window */
        if (wwCurNew >= 0)
                {
                if (rgwwd[wwCurNew].doc == docScrap)
                        {
                        if (wwCurNew > 0) /* Try the one before this */
                                wwCurNew--;
                        else if (wwMac > 1) /* 0 is scrap, try higher one */
                                wwCurNew++;
                        else
                                goto NoWw;
                        }
                NewCurWw(wwCurNew, true);
                }
        else
                {
NoWw:           wwCur = -1;
                }
        /* Really stomp this! */
        ClobberDoc(docUndo, docNil, cp0, cp0);
        NoUndo();
}
#endif      /* CASHMERE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\wwdefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

#ifdef ONLINEHELP
#define wwMax           3
#else
#define wwMax           2
#endif

#define wwNil           (15)

#define itrMaxCache     32

/* Window create modes */
#define wcmHoriz        0
#define wcmVert         1
#define wcmFtn          2

typeCP CpSelectCursor(), CpGetCache(), CpHintCache(), CpParaBounds();
typeCP CpFirstSty(), CpLimSty(), CpBeginLine(), CpFromDlTc();
typeCP CpFromCursor(), CpEdge(), CpInsPoint();
typeCP CpFirstFtn(), CpMacText();

/* WWD reorg. CS Sept 1 */
struct WWD
        { /* Window descriptor */
        unsigned char fDirty : 1; /* ww needs updating */
        unsigned char fCpBad : 1; /* cpFirst needs updating */
        unsigned char fWrite : 1; /* Can edit this window */
/* true iff lower of a split pair. False means window is not split */
        unsigned char fLower : 1;
/* true means window is split and this is the upper pane */
        unsigned char fSplit : 1;
/* in the top window false means the bottom half has the active selection */
/* used for window activation. remembered at deactivation */
        unsigned char fActive : 1;
        unsigned char fFtn : 1; /* This is a footnote window */
        unsigned char fRuler : 1; /* Draw tab and margin ruler */
#ifdef SPLITTERS    /* Only if we have split windows */
/* points to lower ww if fSplit, to upper ww if fLower */
        unsigned char ww;
#endif
        unsigned char fEditHeader: 1;   /* We are editing the running head */
        unsigned char fEditFooter: 1;   /* We are editing the running foot */

        unsigned char dcpDepend;  /* hot spot for first line */
        unsigned char dlMac;      /* number of actual dls for this ww */
        unsigned char dlMax;      /* number of allocated dls for this ww */
        unsigned char doc;

        int xpMac; /* window rel position of last displayable pixel +1 */
/* note: area starts at: xpSelBar, see dispdefs */
        int ichCpFirst; /* ich within cpFirst */

/* first pixel pos to display; determines horizontal scroll */
        int xpMin;
/* these will be changed to yp's later */
        int ypMac; /* pos of bottom of window */
        int ypMin; /* pos of top of writeable area of window */

/* invalid band in the window */
        int ypFirstInval;
        int ypLastInval;

        typeCP cpFirst; /* First cp in ww */
        typeCP cpMin; /* Min cp for this ww if fFtn */
        typeCP cpMac; /* Mac cp for this ww if fFtn */
        unsigned char drElevator; /* dr where elevator is currently */
        unsigned char fScrap : 1; /* on for scrap window */
/* new fields, consolidating various arrays */
        struct SEL sel; /* current selection in ww */
/* must be at end of struct, see cwWWDclr kludge below */

#ifndef SAND        /* MEMO fields */
        HWND wwptr;                 /* window handle */
        HWND hHScrBar;              /* Handle to horiz scroll bar */
        HWND hVScrBar;              /* Handle to vert scroll bar */
        HDC  hDC;                   /* Handle to device context */
        unsigned char sbHbar;       /* Type of horiz scroll bar (SB_CTL or SB_HORIZ) */
        unsigned char sbVbar;       /* Type of vert scroll bar (SB_CTL or SB_VERT) */
#else
        WINDOWPTR wwptr; /* Sand window handle */
#endif
/* heap pointer to array of edl's. */
        struct EDL (**hdndl)[];
        };

#define cwWWD   (sizeof(struct WWD) / sizeof(int))
#define cwWWDclr  ((sizeof(struct WWD) - (4*sizeof(HANDLE)) - (2*sizeof(char)) - sizeof(int)) / sizeof(int))

/* These macros will gain code size advantage from the fixed usage
   of rgwwd in MEMO, while permitting easy conversion to multiple
   document windows in CASHMERE. Only code that does not have to support both
   the clipboard and the document should use these macros */

extern int wwClipboard;

#ifdef ONLINEHELP
extern int wwHelp;
#define wwdHelp         (rgwwd [ wwHelp ])
#endif

#define wwDocument      0

#define wwdCurrentDoc   (rgwwd [wwDocument])
#define wwdClipboard    (rgwwd [wwClipboard])

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\fastwow.h ===
/*++ BUILD Version: 0003
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, 1992, 1993 Microsoft Corporation
 *
 *  FASTWOW.H
 *  WOW32 x86 fast callback/API support
 *
 *  History:
 *  Created 4-Dec-1992  by barry bradie (barryb)
--*/

#if defined(i386) && !defined(DEBUG_OR_WOWPROFILE)

#define FASTBOPPING     1

#else

#define FASTBOPPING     0

#endif

#if FASTBOPPING
extern BYTE fKernelCSIPFixed;
// Used by the monitor to dispatch interupts. Updated for callbacks and bops
extern DECLSPEC_IMPORT PVOID CurrentMonitorTeb;
#endif

#if FASTBOPPING
VOID    WOWBopEntry(VOID);
VPVOID  FastBopVDMStack(void);
VOID    FastBopSetVDMStack(VPVOID vp);
VOID    FastWOWCallbackCall(VOID);
VOID    FastWOWCallbackRet(VOID);
#define FASTVDMSTACK()      FastBopVDMStack()
#define SETFASTVDMSTACK(vp) FastBopSetVDMStack(vp)
#endif

//#if FASTBOPPING
//
// Used to put lock prefixes in appropriate places for MP machines
//
extern VOID FastWowFirstCode(VOID);
extern VOID FixLocks(VOID);
//#endif

#if 0

How to set a 16-bit register from the 32-bit side:

WOW16Call is called by all API thunks.  this routine sets up a stack
frame (the VDMFRAME) before getting over to WOW32.  the VDMFRAME is where
all the registers are stored - whenever a task has crossed over to WOW32
either via an API call or by returning from a callback, it saves
its registers in the frame.  immediately upon returning from WOW32
it pops the stuff off the stack back into the registers.  the way
to get a value into a specific register when the task starts executing
16-bit code again is to put it in the frame.

 ***   do not use the setAX(), setDX(), etc.  functions for this purpose  ***

those routines update a context block.  when the app re-enters 16-bit
code the registers will have the requested values but will be
immediately overwritten by the values on the stack.

similarly, to retrieve a value that was in a register at the time
of the API call you should fetch it out of the frame.
note that this is only valid for a few registers, because the
validation layer may modify the general-purpose registers.

upon returning from a callback everything on the 16-bit stack
should be valid.  to get the value that was in a register
after a callback, pull it out of the callback frame.  note that
there are general-purpose words in the callback frame for passing
extra data from the 16-bit callback routine to WOW32.


  ***  do not use the getAX(), getDX(), etc. functions for this purpose ***

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\write\winddefs.h ===
/************************************************************/
/* Windows Write, Copyright 1985-1992 Microsoft Corporation */
/************************************************************/

/* MS-Windows specific definitions */

#define tidCaret            7734    /* Timer ID for caret blink (stand on your
				    head to read it) */

/*  dwHsecKeyDawdle is the number of hundredths of seconds that we loop,
    waiting for keys, before we update the display. See insert.c */

#define dwHsecKeyDawdle     35

/* File rename/deletion coordination messages sent btwn WRITE instances */

#define wWndMsgDeleteFile   (WM_USER + 36)
#define wWndMsgRenameFile   (WM_USER + 37)

/* System information message posted to self */

#define wWndMsgSysChange    (WM_USER + 38)

#define wWininiChangeToWindows  1   /* used in posting above message */
#define wWininiChangeToDevices  2
#define wWininiChangeToIntl     4
#define wWininiChangeMax        ((1|2|4) + 1)

#ifndef NOMETAFILE
/*              *** PICTURE THINGS ***                          */

#define dypPicSizeMin       16  /* Smallest y-extent of a picture, in pixels */
                                /* Also the dl height in a picture */

#define MM_NIL          -1
#define MM_BITMAP       99      /* A Phony mapping mode code used within MEMO */
                                /* xExt, yExt must be filled out as for MM_TEXT */
#define MM_OLE          100     /* Another phony mapping mode code used 
                                   with Objects/Links */

#define MM_EXTENDED     0x80    /* Bit set for New file format */

/* A Bitmap or Picture appears in a file as a PICINFO or PICINFOX
   + an Array of Bits,
   if it's a bitmap, or the contents of a memory metafile, if it's a picture.
   This all appears in the cp stream
   A PICINFO is a PICINFOX without the extended format fields.
   a PICINFO has the mfp.mm MM_EXTENDED bit cleared
   a PICINFOX has the mfp.mm MM_EXTENDED bit set
*/

/* If you change this, you must change "cchOldPICINFO" */

struct PICINFOX {
 METAFILEPICT mfp;
 int  dxaOffset;
 int  dxaSize;
 int  dyaSize;
 unsigned  cbOldSize;      /* For old file support only */
 BITMAP bm;                /* Additional info for bitmaps only */

 /* Extended format -- add these fields */

 unsigned cbHeader;        /* Size of this header (sizeof (struct PICINFOX)) */
 unsigned long  cbSize;    /* This field replaces cbOldSize on new files */

 unsigned mx, my;               /* Multiplier for scaled bitmap */
};

#define mxMultByOne     1000    /* mx == 1 implies same size; 2 doubles, etc. */
#define myMultByOne     1000


#define cchOldPICINFO   (sizeof(struct PICINFOX) - sizeof(long) - \
                         sizeof(unsigned) - 2 * sizeof (int))

#define cchPICINFOX     (sizeof(struct PICINFOX))
#endif /* ifndef NOMETAFILE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\intthunk.h ===
/*++
 *  intthunk.h
 *
 *  WOW v5.0
 *
 *  Copyright 1996, Microsoft Corporation.  All Rights Reserved.
 *
 *  WOW32.C
 *  WOW32 16-bit API support
 *
 *  History:
 *  Created 7-Dec-96 DaveHart
 *
--*/

ULONG FASTCALL InterpretThunk(PVDMFRAME pFrame, DWORD dwIntThunkID);

//
// Win32 "APIs" which aren't in any headers.
//

BOOL APIENTRY SetMagicColors(HDC,PALETTEENTRY,ULONG);   // from ntgdi\inc\ntgdi.h
int APIENTRY GetRelAbs(HDC,INT);
int APIENTRY SetRelAbs(HDC,INT);

//
// IT() Macro for use in WOW thunk tables (w?tbl2.h)
//

#define IT(Name)        ((LPFNW32) ITID_##Name )

typedef struct _INT_THUNK_TABLEENTRY {
    FARPROC pfnAPI;
    CONST BYTE *pbInstr;
} INT_THUNK_TABLEENTRY;
typedef CONST INT_THUNK_TABLEENTRY * PINT_THUNK_TABLEENTRY;

#ifndef WOWIT_C
extern CONST INT_THUNK_TABLEENTRY IntThunkTable[];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\genwowit.c ===
/* generate wowit.h and wowit.c from wow.it
 *
 *   20-Feb-1997 DaveHart created
 */

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <sys\stat.h>
#include <fcntl.h>
#include <windows.h>


VOID ErrorAbort(PSZ pszMsg);
BYTE GetReturnOpcode(PSZ *ppsz);
PSZ GetApiName(PSZ *ppsz);
PSZ GetApi32Name(PSZ *ppsz, PSZ pszApi16);
BYTE GetArgOpcode(PSZ *ppsz);
PSZ GetOpcodeName(BYTE bInstr);
PSZ GetLine(PSZ pszBuf, int cbBuf, FILE *fp);
VOID ReadTypeNames(FILE *fIn, PSZ szTypesPrefix, PSZ *OpcodeNamesArray, int *pnOpcodeNames);
PSZ DateTimeString(VOID);

#define IS_RET_OPCODE(b) (b & 0x80)

#define MAX_IT_INSTR 16

typedef struct tagITINSTR {
    int  cbInstr;
    int  offSwamp;
    BYTE Instr[MAX_IT_INSTR];
} ITINSTR;

#define MAX_INSTR_TABLE_SIZE 512
ITINSTR InstrTable[MAX_INSTR_TABLE_SIZE];
int     iNextInstrSlot = 0;

typedef struct tagTHUNKTABLESLOT {
    PSZ   pszAPI;
    PSZ   pszAPI32;                 // if Win32 routine name doesn't match pszAPI
    int   iInstrSlot;
    int   cbInstr;                  // how much of this slot we're using
} THUNKTABLESLOT;

#define MAX_THUNK_TABLE_SIZE 1024
THUNKTABLESLOT ThunkTable[MAX_THUNK_TABLE_SIZE];
int iNextThunkSlot = 0;

#define MAX_ARG_OPCODE_NAMES 32
PSZ ArgOpcodeNames[MAX_ARG_OPCODE_NAMES];
int nArgOpcodeNames;

#define MAX_RET_OPCODE_NAMES 32
PSZ RetOpcodeNames[MAX_RET_OPCODE_NAMES];
int nRetOpcodeNames;

static char szArgumentTypes[] = "Argument Types:";
static char szReturnTypes[] = "Return Types:";

int __cdecl main(int argc, char **argv)
{
    FILE *fIn, *fOutH, *fOutC;
    char szBuf[256], szOff1[32], szOff2[32];
    PSZ psz, pszAPI, pszAPI32;
    ITINSTR ThisInstr;
    BYTE bRetInstr;
    BYTE *pbInstr;
    int i, iSwampOffset;
    int iMaxArgs = 0;
    int cbDiff;

    if (argc != 2) {
        ErrorAbort("Usage:\n  genwowit <inputfile>\n");
    }

    if (!(fIn = fopen(argv[1], "rt"))) {
        ErrorAbort("Unable to open input file\n");
    }

    //
    // The input file (wow.it) uses # to begin comment lines.
    // Aside from comments, it must begin with two special lines
    // to define the available type names for arguments and
    // function return values.
    //
    // They look like:
    //
    // Argument Types: WORD, INT, DWORD, LPDWORD, PTR, PTRORATOM, HGDI, HUSER, COLOR, HINST, HICON, POINT, 16ONLY, 32ONLY;
    // Return Types: DWORD, WORD, INT, HGDI, HUSER, ZERO, HICON, ONE, HPRNDWP;
    //
    // Read these lines into the ArgOpcodeNames and RetOpcodeNames arrays.
    //

    ReadTypeNames(fIn, szArgumentTypes, ArgOpcodeNames, &nArgOpcodeNames);
    ReadTypeNames(fIn, szReturnTypes, RetOpcodeNames, &nRetOpcodeNames);

    //
    // Each input line in the main part has a very restricted syntax:
    //
    // RETTYPE Api16[=Api32](TYPE1, TYPE2, ... TYPEn);  # comment
    //
    // If Api32 isn't specified it's the same as Api16.
    // The types come from the set above only.
    //
    // Actually everything following the ) is ignored now.
    //

    while (GetLine(szBuf, sizeof szBuf, fIn)) {

        psz = szBuf;

        //
        // Pick up the return type, space-delimited
        //

        bRetInstr = GetReturnOpcode(&psz);

        //
        // Pick up the API name, leaving psz pointing past the open-paren
        //

        pszAPI = GetApiName(&psz);

        //
        // Pick up the 32-bit name if it exists
        //

        pszAPI32 = GetApi32Name(&psz, pszAPI);

        //
        // Pick up the arg types into Instr array
        //

        memset(&ThisInstr, 0, sizeof ThisInstr);
        pbInstr = ThisInstr.Instr;

        while (*psz && *psz != ')') {
            *pbInstr++ = GetArgOpcode(&psz);
        }

        //
        // Keep track of the max used args
        //

        iMaxArgs = max(iMaxArgs, (pbInstr - ThisInstr.Instr));

        //
        // Tack on the return opcode
        //

        *pbInstr++ = bRetInstr;

        //
        // Record instruction bytes used for this one.
        //

        ThisInstr.cbInstr = (pbInstr - ThisInstr.Instr);

        //
        // Make sure we haven't overrun
        //

        if ( ThisInstr.cbInstr > MAX_IT_INSTR ) {
            printf("Thunk for %s too many args (%d) increase MAX_IT_INSTR beyond %d.\n",
                   pszAPI, ThisInstr.cbInstr, MAX_IT_INSTR);
            ErrorAbort("Increase MAX_IT_INSTR in intthunk.h\n");
        }

        //
        // Now we have a fully-formed opcode stream, see if we can pack it
        // in with any previously recorded ones.  Walk through the table
        // from the start looking for any entry which already contains this
        // opcode sequence (possibly as part of a longer sequence) or which
        // is itself contained by this opcode sequence.  If we find one,
        // change it to be the longer sequence if needed and use it.  We'll
        // distinguish later between the multiple uses using the cbInstr in
        // each thunk table entry.  The logic here assumes the matches will
        // always be at the end, since ret opcodes always have 0x80 bit set
        // and no others do, and each sequence ends with one.
        //

        for (i = 0; i < iNextInstrSlot; i++) {
            //if (0 == memcmp(Instr, InstrTable[i], sizeof Instr)) {
            //    break;
            //}

            //
            // Is ThisInstr a subsequence of this table entry?
            //

            if (ThisInstr.cbInstr <= InstrTable[i].cbInstr &&
                0 == memcmp(ThisInstr.Instr,
                            InstrTable[i].Instr + (InstrTable[i].cbInstr -
                                                   ThisInstr.cbInstr),
                            ThisInstr.cbInstr)) {

                break;
            }

            //
            // Is this table entry a subsequence of ThisInstr?
            //

            if (InstrTable[i].cbInstr < ThisInstr.cbInstr &&
                0 == memcmp(InstrTable[i].Instr,
                            ThisInstr.Instr + (ThisInstr.cbInstr -
                                               InstrTable[i].cbInstr),
                            InstrTable[i].cbInstr)) {

                //
                // Blast the longer ThisInstr over the existing shorter
                // instruction.
                //

                memcpy(&InstrTable[i], &ThisInstr, sizeof InstrTable[i]);
                break;
            }

            //
            // Check the next instruction table entry.
            //
        }

        //
        // If we didn't find a match, add to the end.
        //

        if (i == iNextInstrSlot) {
            memcpy(&InstrTable[i], &ThisInstr, sizeof InstrTable[i]);
            iNextInstrSlot++;

            if (iNextInstrSlot == MAX_INSTR_TABLE_SIZE) {
                ErrorAbort("Increase MAX_INSTR_TABLE_SIZE in genwowit.c\n");
            }
        }

        //
        // Add this one to the thunk table.
        //

        ThunkTable[iNextThunkSlot].pszAPI = pszAPI;
        ThunkTable[iNextThunkSlot].pszAPI32 = pszAPI32;
        ThunkTable[iNextThunkSlot].iInstrSlot = i;
        ThunkTable[iNextThunkSlot].cbInstr = ThisInstr.cbInstr;
        iNextThunkSlot++;

        if (iNextThunkSlot == MAX_THUNK_TABLE_SIZE) {
            ErrorAbort("Increase MAX_THUNK_TABLE_SIZE in genwowit.c\n");
        }
    }

    fclose(fIn);

    //
    // Now we're ready to output the results.
    //

    if (!(fOutH = fopen("wowit.h", "wt"))) {
        ErrorAbort("Cannot open wowit.h output file\n");
    }

    fprintf(fOutH,
            "//\n"
            "// DO NOT EDIT.\n"
            "//\n"
            "// wowit.h generated by genwowit.exe from wow.it on\n"
            "//\n"
            "//   %s\n"
            "//\n\n", DateTimeString());

    fprintf(fOutH, "#include \"intthunk.h\"\n\n");

    fprintf(fOutH, "#define MAX_IT_ARGS  %d\n\n", iMaxArgs);

    //
    // Spit out the two types of opcode manifests.
    //

    for (i = 0; i < nArgOpcodeNames; i++) {
        fprintf(fOutH, "#define IT_%-20s ( (UCHAR) 0x%x )\n", ArgOpcodeNames[i], i);
    }

    fprintf(fOutH, "\n#define IT_RETMASK              ( (UCHAR) 0x80 )\n");

    for (i = 0; i < nRetOpcodeNames; i++) {
        sprintf(szBuf, "%sRET", RetOpcodeNames[i]);
        fprintf(fOutH, "#define IT_%-20s ( IT_RETMASK | (UCHAR) 0x%x )\n", szBuf, i);
    }

    fprintf(fOutH, "\n");

    //
    // ITID_ manifests map an API name to its slot
    // in the thunk table.  Each one looks like:
    //
    // #define ITID_ApiName               0
    //

    for (i = 0; i < iNextThunkSlot; i++) {
        fprintf(fOutH, "#define ITID_%-40s %d\n", ThunkTable[i].pszAPI, i);
    }

    fprintf(fOutH, "\n#define ITID_MAX %d\n", i-1);

    fclose(fOutH);


    //
    // wowit.c has two tables, the instruction table and
    // the thunk table.
    //

    if (!(fOutC = fopen("wowit.c", "wt"))) {
        ErrorAbort("Cannot open wowit.c output file\n");
    }

    fprintf(fOutC,
            "//\n"
            "// DO NOT EDIT.\n"
            "//\n"
            "// wowit.c generated by genwowit.exe from wow.it on\n"
            "//\n"
            "//   %s\n"
            "//\n\n", DateTimeString());


    fprintf(fOutC, "#include \"precomp.h\"\n");
    fprintf(fOutC, "#pragma hdrstop\n");
    fprintf(fOutC, "#define WOWIT_C\n");
    fprintf(fOutC, "#include \"wowit.h\"\n\n");

    //
    // Spit out the instruction table, packing bytes in the process
    // and filling in the aoffInstrTable array with offsets for each
    // entry in this program's InstrTable.  Those offsets are used
    // in writing the final thunk table.
    //

    iSwampOffset = 0;

    fprintf(fOutC, "CONST BYTE InstrSwamp[] = {\n");

    for (i = 0; i < iNextInstrSlot; i++) {

        fprintf(fOutC, "    /* %3d  0x%-3x */ ", i, iSwampOffset);

        pbInstr = InstrTable[i].Instr;
        InstrTable[i].offSwamp = iSwampOffset;

        do {
            fprintf(fOutC, "%s, ", GetOpcodeName(*pbInstr));
            iSwampOffset++;
        } while (!IS_RET_OPCODE(*pbInstr++));

        fprintf(fOutC, "\n");

    }

    fprintf(fOutC, "};\n\n");

    fprintf(fOutC, "CONST INT_THUNK_TABLEENTRY IntThunkTable[] = {\n");

    for (i = 0; i < iNextThunkSlot; i++) {

        //
        // Concatenate the API name followed by a comma into
        // szBuf, so the combination can be left-justified in the output.
        //

        sprintf(szBuf, "%s,", ThunkTable[i].pszAPI32);

        //
        // cbDiff is the offset into the instruction stream where
        // this thunks instruction stream begins.
        //

        cbDiff = InstrTable[ ThunkTable[i].iInstrSlot ].cbInstr -
                 ThunkTable[i].cbInstr;

        //
        // Format the swamp offset so it can be left-justified in the output.
        //

        sprintf(szOff1, "%x",
                InstrTable[ ThunkTable[i].iInstrSlot ].offSwamp + cbDiff);

        //
        // If this thunk table entry will point past the start of
        // an instruction (because of sharing), format the offset
        // past the start of the instruction into szOff2
        //

        if (cbDiff) {
            sprintf(szOff2, "+ %d ", cbDiff);
        } else {
            szOff2[0] = '\0';
        }

        fprintf(fOutC,
                "    /* %3d */ { (FARPROC) %-32s InstrSwamp + 0x%-4s },  /* %d %s*/ \n",
                i,
                szBuf,
                szOff1,
                ThunkTable[i].iInstrSlot,
                szOff2);
    }

    fprintf(fOutC, "};\n\n");

    fclose(fOutC);

    printf("Generated wowit.h and wowit.c from wow.it\n"
           "%d thunks, %d unique instruction streams, %d instruction bytes, %d max args.\n",
           iNextThunkSlot, iNextInstrSlot, iSwampOffset, iMaxArgs);

    return 0;
}



BYTE GetReturnOpcode(PSZ *ppsz)
{
    int i;
    char szBuf[32];
    PSZ psz;

    //
    // Copy the name up to the first space to szBuf,
    // then skip any remaining spaces leaving caller's
    // pointer pointing at API name.
    //

    psz = szBuf;
    while (**ppsz != ' ') {
        *psz++ = *((*ppsz)++);
    };

    *psz = 0;

    while (**ppsz == ' ') {
        (*ppsz)++;
    };

    i = 0;
    while (i < nRetOpcodeNames &&
           strcmp(szBuf, RetOpcodeNames[i])) {
        i++;
    }

    if (i == nRetOpcodeNames) {
        printf("%s is not a valid return type.\n", szBuf);
        ErrorAbort("Invalid return type.\n");
    }

    return (BYTE)i | 0x80;
}



PSZ GetApiName(PSZ *ppsz)
{
    char szBuf[128];
    PSZ psz;

    //
    // Copy the name up to the first space or open-paren or equals sign
    // to szBuf, then skip any remaining spaces and open-parens leaving caller's
    // pointer pointing at first arg type or equals sign
    //

    psz = szBuf;
    while (**ppsz != ' ' && **ppsz != '(' && **ppsz != '=') {
        *psz++ = *((*ppsz)++);
    };

    *psz = 0;

    while (**ppsz == ' ' || **ppsz == '(') {
        (*ppsz)++;
    };

    if (!strlen(szBuf)) {
        ErrorAbort("Empty API name\n");
    }

    return _strdup(szBuf);
}



PSZ GetApi32Name(PSZ *ppsz, PSZ pszApi16)
{
    char szBuf[128];
    PSZ psz;

    if (**ppsz != '=') {
        return pszApi16;
    }

    (*ppsz)++;  // skip =

    //
    // Copy the name up to the first space or open-paren
    // to szBuf, then skip any remaining spaces and open-parens leaving caller's
    // pointer pointing at first arg type
    //

    psz = szBuf;
    while (**ppsz != ' ' && **ppsz != '(') {
        *psz++ = *((*ppsz)++);
    };

    *psz = 0;

    while (**ppsz == ' ' || **ppsz == '(') {
        (*ppsz)++;
    };

    if (!strlen(szBuf)) {
        ErrorAbort("Empty API32 name\n");
    }

    return _strdup(szBuf);
}




BYTE GetArgOpcode(PSZ *ppsz)
{
    char szBuf[32];
    PSZ psz;
    int i;

    //
    // Copy the name up to the first space or comma close-paren
    // to szBuf, then skip any remaining spaces and commas,
    // leaving caller's pointer pointing at next arg type
    // or close-paren.
    //

    psz = szBuf;
    while (**ppsz != ' ' && **ppsz != ',' && **ppsz != ')') {
        *psz++ = *((*ppsz)++);
    };

    *psz = 0;

    while (**ppsz == ' ' || **ppsz == ',') {
        (*ppsz)++;
    };

    //
    // szBuf has the type name, find it in the table.
    //

    i = 0;
    while (i < nArgOpcodeNames &&
           strcmp(szBuf, ArgOpcodeNames[i])) {
        i++;
    }

    if (i == nArgOpcodeNames) {
        printf("%s is not a valid arg type.\n", szBuf);
        ErrorAbort("Invalid arg type.\n");
    }

    return (BYTE)i;
}



PSZ GetOpcodeName(BYTE bInstr)
{
    char szBuf[64];

    if (!IS_RET_OPCODE(bInstr)) {
        sprintf(szBuf, "IT_%s", ArgOpcodeNames[bInstr]);
    } else {
        sprintf(szBuf, "IT_%sRET", RetOpcodeNames[bInstr & 0x7f]);
    }

    return _strdup(szBuf);
}



VOID ErrorAbort(PSZ pszMsg)
{
    printf("GENWOWIT : fatal error GWI0001: Unable to process wow.it: %s\n", pszMsg);
    exit(1);
}


//
// Read a line from the input file skipping
// comment lines with '#' in the first column.
//

PSZ GetLine(PSZ pszBuf, int cbBuf, FILE *fp)
{
    do {

        pszBuf = fgets(pszBuf, cbBuf, fp);

    } while (pszBuf && '#' == *pszBuf);

    return pszBuf;
}


//
// Read one of the two special lines at the start that
// define the available types.
//


VOID ReadTypeNames(FILE *fIn, PSZ pszTypesPrefix, PSZ *OpcodeNamesArray, int *pnOpcodeNames)
{
    char chSave, szBuf[512];
    PSZ psz, pszType;

    if ( ! GetLine(szBuf, sizeof szBuf, fIn) ||
         _memicmp(szBuf, pszTypesPrefix, strlen(pszTypesPrefix)) ) {

        ErrorAbort("First line of input file must be 'Argument Types:', second 'Return Types:' ...\n");
    }

    psz = szBuf + strlen(pszTypesPrefix);

    //
    // Skip whitespace and commas
    //

    while (' ' == *psz || '\t' == *psz) {
        psz++;
    }

    if ( ! *psz) {
        ErrorAbort("No types found.\n");
    }

    do {
        //
        // Now we're looking at the first character of the type name.
        //

        pszType = psz;

        //
        // Find next whitespace, comma, semi, or null and turn it into a null.
        // This turns this type name into a zero-terminated string.
        //

        while (*psz && ' ' != *psz && '\t' != *psz && ',' != *psz && ';' != *psz) {
            psz++;
        }

        chSave = *psz;
        *psz = 0;

        OpcodeNamesArray[*pnOpcodeNames] = _strdup(pszType);
        (*pnOpcodeNames)++;

        *psz = chSave;

        //
        // Skip whitespace and commas
        //

        while (' ' == *psz || '\t' == *psz || ',' == *psz) {
            psz++;
        }

    } while (*psz && ';' != *psz);

    if ( ! *pnOpcodeNames) {
        ErrorAbort("No types found.\n");
    }
}

//
// Return a formatted date/time string for now.
// Only checks system time once so that wowit.c and wowit.h
// will have same date/time string.
//

PSZ DateTimeString(VOID)
{
    static char sz[256];
    static int fSetupAlready;

    if (!fSetupAlready) {
        time_t UnixTimeNow;
        struct tm *ptmNow;

        fSetupAlready = TRUE;

        _tzset();

        time(&UnixTimeNow);

        ptmNow = localtime(&UnixTimeNow);

        strftime(sz, sizeof sz, "%#c", ptmNow);

        strcat(sz, " (");
        strcat(sz, _strupr(_tzname[0]));   // naughty me
        strcat(sz, ")");
    }

    return sz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\intthunk.c ===
/*++
 *  intthunk.c
 *
 *  WOW v5.0
 *
 *  Copyright 1996, Microsoft Corporation.  All Rights Reserved.
 *
 *  WOW32.C
 *  WOW32 16-bit API support
 *
 *  History:
 *  Created 7-Dec-96 DaveHart
 *
--*/

#include "precomp.h"
#pragma hdrstop
#include "wowit.h"

MODNAME(intthunk.c);

extern DWORD WK32ICallProc32MakeCall(DWORD pfn, DWORD cbArgs, VOID *pArgs);

//
// On x86 we don't bother aligning pointers to DWORDs
// passed to APIs.  Perhaps we shouldn't for Alpha?
//

#ifdef _X86_
    #define ALIGNDWORDS 0
#else
    #define ALIGNDWORDS 1
#endif

ULONG FASTCALL InterpretThunk(PVDMFRAME pFrame, DWORD dwIntThunkID)
{
    PINT_THUNK_TABLEENTRY pit = &IntThunkTable[ dwIntThunkID ];
    CONST BYTE * pbInstr = pit->pbInstr;
    DWORD dwArgs32[MAX_IT_ARGS];
    PDWORD pdwArg32 = dwArgs32;
    #if ALIGNDWORDS
        BOOL fAlignedUsed = FALSE;
        DWORD adwAligned[MAX_IT_ARGS];
        PDWORD pdwAligned = adwAligned;
        DWORD avpAligned[MAX_IT_ARGS];
        PDWORD pvpAligned = avpAligned;
    #endif
    WORD UNALIGNED *pwArg16 = (WORD UNALIGNED *) ((PBYTE)&pFrame->bArgs + pFrame->cbArgs - 2);
    DWORD dwReturn;
    DWORD dw;

    WOW32ASSERTMSGF(dwIntThunkID <= ITID_MAX,
                    ("WOW32 InterpretThunk error ID %d out of range (%d max).\n",
                     dwIntThunkID, ITID_MAX));

    while ( ! (*pbInstr & IT_RETMASK)) {
        switch (*pbInstr) {

        case IT_WORD:
            *pdwArg32 = *pwArg16;
            break;

        case IT_INT:
            *pdwArg32 = INT32(*pwArg16);
            break;

        case IT_DWORD:
            *pdwArg32 = *(DWORD UNALIGNED *) --pwArg16;
            break;

        case IT_LPDWORD:
            #if ALIGNDWORDS
                if (! fAlignedUsed) {
                    fAlignedUsed = TRUE;
                    RtlZeroMemory(avpAligned, sizeof avpAligned);
                }
                *pvpAligned = *(DWORD UNALIGNED *) --pwArg16;
                if (*pvpAligned) {
                    *pdwArg32 = (DWORD) pdwAligned;
                    *pdwAligned = *(DWORD UNALIGNED *) GetPModeVDMPointer(*pvpAligned, 4);
                } else {
                    *pdwArg32 = 0;
                }
                break;
            #else
                //
                // If we aren't aligning DWORDs use the generic
                // pointer code.
                //

                /* FALL THROUGH TO IT_PTR */
            #endif

        case IT_PTR:
            dw = *(DWORD UNALIGNED *) --pwArg16;
        do_IT_PTR_with_dw:
            *pdwArg32 = (DWORD) GetPModeVDMPointer(dw, 0);
            break;

        case IT_PTRORATOM:
            dw = *(DWORD UNALIGNED *) --pwArg16;
            if (HIWORD(dw)) {
                goto do_IT_PTR_with_dw;
            }
            *pdwArg32 = dw;    // atom
            break;

        case IT_HGDI:
            *pdwArg32 = (DWORD) GDI32( (HAND16) *pwArg16 );
            break;

        case IT_HUSER:
            *pdwArg32 = (DWORD) USER32( (HAND16) *pwArg16 );
            break;

        case IT_COLOR:
            dw = *(DWORD UNALIGNED *) --pwArg16;
            *pdwArg32 = COLOR32(dw);
            break;

        case IT_HINST:
            *pdwArg32 = (DWORD) HINSTRES32( (HAND16) *pwArg16 );
            break;

        case IT_HICON:
            *pdwArg32 = (DWORD) HICON32( (HAND16) *pwArg16 );
            break;

        case IT_HCURS:
            *pdwArg32 = (DWORD) HCURSOR32( (HAND16) *pwArg16 );
            break;

        case IT_16ONLY:
            //
            // This is for params that appear on 16-bit side but not 32-bit side,
            // for example the hinstOwner passed to CopyImage in Win16 but not in Win32.
            //
            pdwArg32--;
            break;

        case IT_32ONLY:
            //
            // This is for params that appear on 32-bit side but not 16-bit side,
            // we pass zero for the 32-bit argument.
            //
            *pdwArg32 = 0;
            pwArg16++;
            break;

        default:
            WOW32ASSERTMSGF(FALSE, ("WOW32 InterpretThunk error unknown opcode 0x%x.\n", *pbInstr));
        }

        pwArg16--;
        pdwArg32++;
        pbInstr++;
        #if ALIGNDWORDS
            pdwAligned++;
            pvpAligned++;
        #endif

        WOW32ASSERT((pbInstr - pit->pbInstr) <= (MAX_IT_ARGS + 1));
    }

    //
    // Call API
    //

    dwReturn = WK32ICallProc32MakeCall(
                   (DWORD) pit->pfnAPI,
                   (PBYTE) pdwArg32 - (PBYTE) dwArgs32,
                   dwArgs32
                   );

    #ifdef DEBUG
        pFrame = NULL;         // Memory movement may have occurred.
    #endif

    //
    // If we passed aligned DWORD pointers, copy the values back.
    //

    #if ALIGNDWORDS
        if (fAlignedUsed) {
            pdwAligned = adwAligned;
            pvpAligned = avpAligned;

            while (pvpAligned < (PDWORD)((PBYTE)avpAligned + sizeof avpAligned)) {
                if (*pvpAligned) {
                    *(DWORD UNALIGNED *) GetPModeVDMPointer(*pvpAligned, 4) = *pdwAligned;
                }

                pdwAligned++;
                pvpAligned++;
            }
        }
    #endif

    //
    // Thunk return value using last instruction opcode
    //

    WOW32ASSERT(*pbInstr & IT_RETMASK);

    switch (*pbInstr) {

    case IT_DWORDRET:
        // dwReturn is correct
        break;

    case IT_WORDRET:
        dwReturn = GETWORD16(dwReturn);
        break;

    case IT_INTRET:
        dwReturn = (DWORD) GETINT16(dwReturn);
        break;

    case IT_HGDIRET:
        dwReturn = GDI16( (HAND32) dwReturn );
        break;

    case IT_HUSERRET:
        dwReturn = USER16( (HAND32) dwReturn );
        break;

    case IT_ZERORET:
        dwReturn = 0;
        break;

    case IT_HICONRET:
        dwReturn = GETHICON16( (HAND32) dwReturn );
        break;

    case IT_HCURSRET:
        dwReturn = GETHCURSOR16( (HAND32) dwReturn );
        break;

    case IT_ONERET:
        dwReturn = 1;
        break;

    case IT_HPRNDWPRET:
        dwReturn = GetPrn16( (HAND32) dwReturn );
        break;

    default:
        WOW32ASSERTMSGF(FALSE, ("WOW32 InterpretThunk error unknown return opcode 0x%x.\n", *pbInstr));
    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\makefile.inc ===
$(O)\wowit.c $(O)\wowit.h: ..\genwowit.c ..\wow.it
    -erase wow.it
    -erase $(WINDIR)\idw\genwowit.exe
    -erase $(O)\genwowit.obj
    -erase $(O)\genwowit.exe
    set PASS0ONLY=
    set MAKEDLL=
    nmake $(O)\genwowit.obj USE_MSVCRT=1 MAKE_GENWOWIT=1
    nmake $(O)\genwowit.res USE_MSVCRT=1 MAKE_GENWOWIT=1
    $(LINK_NAME) -out:$(O)\genwowit.exe @<<
-STACK:262144,4096
-MERGE:_PAGE=PAGE
-MERGE:_TEXT=.text
-SECTION:INIT,d
-OPT:REF
-OPT:ICF
-INCREMENTAL:NO
-RELEASE
-FULLBUILD
-FORCE:MULTIPLE
-IGNORE:4001,4037,4039,4065,4070,4078,4087,4089
-NODEFAULTLIB
-debug
-version:5.00
-osversion:5.00
-subsystem:console,4.00
-base:@$(COFFBASE_TXT_FILE),usermode
-entry:mainCRTStartup
$(O)\genwowit.obj
$(O)\genwowit.res
$(SDK_LIB_PATH)\msvcrt.lib
$(SDK_LIB_PATH)\kernel32.lib
<<
    cd $(O)
    genwowit.exe $(MAKEDIR)\..\wow.it
    cd $(MAKEDIR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\isvwow.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  ISVWOW.H
 *  WOW32 ISV Support. Public Functions and Macros for Multi-Media extensions
 *  to the WOW thunking mechanism.
 *
 *  History:
 *  Created 18-Feb-1992 by Stephen Estrop (StephenE)
--*/


/*
** Public functions that allow for extensions to the WOW thunking
** system.  These two functions enable extension thunk dlls such as
** Multi-Media video recording to callback into 16 bit code to simulate
** a hardware interrupt callback and to use the same handle mapping that
** WOW uses.
*/
LPVOID
WOW32ResolveMemory(
    VPVOID  vp
    );

BOOL APIENTRY
WOW32DriverCallback(
    DWORD dwCallback,
    DWORD dwFlags,
    WORD wID,
    WORD wMsg,
    DWORD dwUser,
    DWORD dw1,
    DWORD dw2
    );

BOOL APIENTRY
WOW32ResolveHandle(
    UINT uHandleType,
    UINT uMappingDirection,
    WORD wHandle16_In,
    LPWORD lpwHandle16_Out,
    DWORD dwHandle32_In,
    LPDWORD lpdwHandle32_Out
    );


/*
** Constants for use with WOW32ResolveHandle
*/

#define WOW32_DIR_16IN_32OUT        0x0001
#define WOW32_DIR_32IN_16OUT        0x0002

#define WOW32_USER_HANDLE           0x0001  // Generic user handle
#define WOW32_GDI_HANDLE            0x0002  // Generic gdi handle
                                            // Kernel handles are not mapped

#define WOW32_WAVEIN_HANDLE         0x0003
#define WOW32_WAVEOUT_HANDLE        0x0004
#define WOW32_MIDIOUT_HANDLE        0x0005
#define WOW32_MIDIIN_HANDLE         0x0006



/*
** These MultiMedia messages expect dwParam1 to be a generic pointer and
** dwParam2 to be a generic DWORD.  auxOutMessage, waveInMessage,
** waveOutMessage, midiInMessage and midiOutMessage all respect this
** convention and are thunked accordingly on WOW.
*/
#define DRV_BUFFER_LOW      (DRV_USER - 0x1000)     // 0x3000
#define DRV_BUFFER_USER     (DRV_USER - 0x0800)     // 0x3800
#define DRV_BUFFER_HIGH     (DRV_USER - 0x0001)     // 0x3FFF


/*
** The flags are extensions to those normally used with GetWindowFlags,
** they allow 16 bit applications to detect if they are running on NT
** and if the Intel cpu is being emulated.
*/
#define WF1_WINNT   0x40    // You are running on NT WOW
#define WF1_CPUEM   0x01    // NT WOW on MIPS or Alpha
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\isz.h ===
//---------------------------------------------------------------------------
// Isz.h : String resource IDs for WOW32
//
// Copyright (c) Microsoft Corporation, 1990-1995
//---------------------------------------------------------------------------

#define CCH_MAX_STRING_RESOURCE 512

//
// String resource IDs must start at 0 and continue consecutively until
// the the last critical string, so that they can be used to index
// aszCriticalStrings in the most straightforward fashion.
//

#define iszApplicationError        0x0
#define iszTheWin16Subsystem       0x1
#define iszChooseClose             0x2
#define iszChooseCancel            0x3
#define iszChooseIgnore            0x4
#define iszCausedException         0x5
#define iszCausedAV                0x6
#define iszCausedStackOverflow     0x7
#define iszCausedAlignmentFault    0x8
#define iszCausedIllegalInstr      0x9
#define iszCausedInPageError       0xa
#define iszCausedIntDivideZero     0xb
#define iszCausedFloatException    0xc
#define iszChooseIgnoreAlignment   0xd

#define CRITICAL_STRING_COUNT      0xe

#define iszWIN16InternalError      0x100
#define iszSystemError             0x101
#define iszCantEndTask             0x102
#define iszUnableToEndSelTask      0x103
#define iszNotResponding           0x104
#define iszEventHook               0x105
#define iszApplication             0x106
#define iszStartupFailed           0x107
#define iszOLEMemAllocFailedFatal  0x108
#define iszOLEMemAllocFailed       0x109

#define iszWowFaxLocalPort         0x10a

#define iszMisMatchedBinary        0x10b
#define iszMisMatchedBinaryTitle   0x10c
#define iszExceedGDIHandleLimit    0x10d

//
// Macro to fetch critical string pointer based on name without preceeding isz
//

#define CRITSTR(name)      (aszCriticalStrings[isz##name])

#ifndef WOW32_C
extern LPSTR aszCriticalStrings[];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\mapembed.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    mapembed.c

Abstract:

    This module contains the functions that perform the mapping
    between the "embedding" section of win.ini, and the subkeys
    of HKEY_CLASSES_ROOT.

    This mapping is a hack implemented on Win3.1, that must also
    exist on NT.
    It is implemnted in the WOW layer, since only some win16 apps
    that read or write to the "embedding" section ( WinWord and
    MsMail) depend on it.



Author:


    Jaime F. Sasson (jaimes) 25-Nov-1992



--*/

#include "precomp.h"
#pragma hdrstop

MODNAME(mapembed.c);


#define WININITIMEOUT   2000
#define BUFFER_SIZE     128

#define EMPTY_STRING        ""

DWORD   _LastTimeUpdated = 0;



BOOL
IsWinIniHelper(
    IN LPSTR    FileName
    )


/*++

Routine Description:

    Determine if the name passed as argument refers to the file win.ini.
    Used by IS_WIN_INI macro, which assures the argument is non-null and
    deals with exact match of "win.ini".

Arguments:

    FileName -  File name to be examined.


Return Value:

    BOOL - Returns TRUE if 'Name' refers to win.ini.
              Otherwise, returns FALSE.

--*/

{
    CHAR    BufferForFullPath[MAX_PATH];
    PSTR    PointerToName;
    DWORD   SizeOfFullPath;

    BOOL    Result;

#ifdef DEBUG
    //
    // Filename argument must already be lowercase.  Be sure.
    //

    {
        char Lowercase[MAX_PATH];

        WOW32ASSERT(strlen(FileName) < MAX_PATH-1);
        strcpy(Lowercase, FileName);
        WOW32_strlwr(Lowercase);
        WOW32ASSERT(!WOW32_strcmp(FileName, Lowercase));
    }
#endif

    if (!WOW32_strcmp(FileName, szWinDotIni)) {
        Result = TRUE;
        goto Done;
    }

    SizeOfFullPath = GetFullPathName( FileName,
                                      sizeof BufferForFullPath,
                                      BufferForFullPath,
                                      &PointerToName );

    if (SizeOfFullPath == 0) {
        Result = FALSE;
        goto Done;
    }

    WOW32ASSERT( (SizeOfFullPath + 1) <= sizeof BufferForFullPath );

    WOW32ASSERTMSG(pszWinIniFullPath && pszWinIniFullPath[0],
                   "WOW32 ERROR pszWinIniFullPath not initialized.\n");

    Result = !WOW32_stricmp( pszWinIniFullPath, BufferForFullPath );

Done:
    return Result;
}



VOID
UpdateEmbeddingAllKeys(
        )

/*++

Routine Description:

    Update the "embedding" section of win.ini based on the information
    stored on the subkeys of HKEY_CLASSES_ROOT.

Arguments:

    None.


Return Value:

    None.

--*/

{
    LONG iClass;
    CHAR szClass[MAX_PATH + 1];
    LONG Status;

    for (iClass = 0;
        (Status = RegEnumKey(HKEY_CLASSES_ROOT,iClass,szClass,sizeof( szClass ))) != ERROR_NO_MORE_ITEMS;
        iClass++)
      {
        if( Status == ERROR_SUCCESS ) {
            UpdateEmbeddingKey( szClass );
        }
      }
}




VOID
UpdateEmbeddingKey(
    IN  LPSTR   KeyName
    )


/*++

Routine Description:

    Update one key of the "embedding" section of win.ini based on the
    information stored on the correspondent subkey of HKEY_CLASSES_ROOT.

    The code below is an improved version of the function
    "UpdateWinIni" extracted from Win 3.1 (shell\library\dbf.c).

Arguments:

    KeyName - Name of the key to be updated.


Return Value:

    None.

--*/

{
    LONG    Status;
    HKEY    Key;
    PSTR    szClass;

    LPSTR   szClassName;
    CHAR    BufferForClassName[BUFFER_SIZE];
//    char szClassName[60];

    LPSTR   szServer;
    CHAR    BufferForServer[BUFFER_SIZE];
//    char szServer[64];

    LPSTR   szLine;
    CHAR    BufferForLine[2*BUFFER_SIZE];
//    char szLine[128];

    char szOldLine[2*BUFFER_SIZE];
//    char szOldLine[128];
    LPSTR lpDesc, lpForms;
    int nCommas;

    LONG cchClassNameSize;
    LONG cchServerSize;
    LONG cchLineSize;


    if( KeyName == NULL ) {
        return;
    }

    szClass = KeyName;
    Key = NULL;

    szClassName = BufferForClassName;
    cchClassNameSize = sizeof( BufferForClassName );

    szServer = BufferForServer;
    cchServerSize = sizeof( BufferForServer );

    szLine = BufferForLine;


    if( RegOpenKey( HKEY_CLASSES_ROOT, szClass, &Key ) != ERROR_SUCCESS )
        goto NukeClass;

    Status = RegQueryValue(Key,NULL,szClassName,&cchClassNameSize);
    if( ( Status != ERROR_SUCCESS ) &&
        ( Status != ERROR_MORE_DATA ) )
        goto NukeClass;

    if( Status == ERROR_MORE_DATA ) {
        cchClassNameSize++;
        szClassName = ( PSTR )malloc_w( cchClassNameSize );
        if( szClassName == NULL )
            goto NukeClass;

        Status = RegQueryValue(Key,NULL,szClassName,&cchClassNameSize);
        if( Status != ERROR_SUCCESS )
            goto NukeClass;
    }

    if (!*szClassName)
        goto NukeClass;


    Status = RegQueryValue(Key,szServerKey,szServer,&cchServerSize);
    if( ( Status != ERROR_SUCCESS ) &&
        ( Status != ERROR_MORE_DATA ) )
        goto NukeClass;

    if( Status == ERROR_MORE_DATA ) {
        cchServerSize++;
        szServer = malloc_w( cchServerSize );
        if( szServer == NULL )
            goto NukeClass;

        Status = RegQueryValue(Key,szServerKey,szServer,&cchServerSize);
        if( Status != ERROR_SUCCESS )
            goto NukeClass;
    }

    if (!*szServer)
        goto NukeClass;


    if (GetProfileString(szEmbedding, szClass, EMPTY_STRING,
          szOldLine, sizeof(szOldLine)))
      {
        for (lpForms=szOldLine, nCommas=0; ; lpForms=AnsiNext(lpForms))
          {
            while (*lpForms == ',')
              {
                *lpForms++ = '\0';
                if (++nCommas == 3)
                    goto FoundForms;
              }
            if (!*lpForms)
                goto DoDefaults;
          }
FoundForms:
        lpDesc = szOldLine;
      }
    else
      {
DoDefaults:
        lpDesc = szClassName;
        lpForms = szPicture;
      }

    // we have a class, a classname, and a server, so its an le class

    cchLineSize = strlen( lpDesc ) +
                  strlen( szClassName ) +
                  strlen( szServer ) +
                  strlen( lpForms ) +
                  3 +
                  1;

    if( cchLineSize > sizeof( BufferForLine ) ) {
        szLine = malloc_w( cchLineSize );
        if( szLine == NULL )
            goto NukeClass;
    }
    wsprintf(szLine, "%s,%s,%s,%s",
             lpDesc, (LPSTR)szClassName, (LPSTR)szServer, lpForms);

    WriteProfileString(szEmbedding, szClass, szLine);
    if( Key != NULL ) {
        RegCloseKey( Key );
    }
    if( szClassName != BufferForClassName ) {
        free_w( szClassName );
    }
    if( szServer != BufferForServer ) {
        free_w( szServer );
    }
    if( szLine != BufferForLine ) {
        free_w( szLine );
    }
    return;

NukeClass:
/*
    Don't nuke the class because someone else may use it!

*/
    if( Key != NULL ) {
        RegCloseKey( Key );
    }
    if( szClassName != BufferForClassName ) {
        free_w( szClassName );
    }
    if( szServer != BufferForServer ) {
        free_w( szServer );
    }
    if( szLine != BufferForLine ) {
        free_w( szLine );
    }
    WriteProfileString(szEmbedding,szClass,NULL);
}



VOID
UpdateClassesRootSubKey(
    IN  LPSTR   KeyName,
    IN  LPSTR   Value
    )

/*++

Routine Description:

    Update a subkeys of HKEY_CLASSES_ROOT, based on the corresponding
    key in the "embedding" section of win.ini.

    The code below is an improved version of the function
    "UpdateFromWinIni" extracted from Win 3.1 (shell\library\dbf.c).

Arguments:

    KeyName - Name of the subkey to be updated

    Value - The value associated to the key, that was already written
            to the "embedding" section of win.ini.


Return Value:

    None.

--*/

{
    LPSTR   szLine;
    LPSTR lpClass,lpServer,lpClassName;
    LPSTR lpT;
    HKEY key = NULL;
    HKEY key1 = NULL;

    if( ( KeyName == NULL ) || ( Value == NULL ) ) {
        return;
    }

    lpClass = KeyName;
    szLine = Value;

    if (!(lpClassName=WOW32_strchr(szLine, ',')))
        return;
    // get the server name and null terminate the class name
    if (!(lpServer=WOW32_strchr(++lpClassName, ','))) {
        return;
    }
    *lpServer++ = '\0';

    // null terminate the server
    if (!(lpT=WOW32_strchr(lpServer, ','))) {
        return;
    }
    *lpT++ = '\0';

    // make sure the classname is nonblank
    while (*lpClassName == ' ')
            lpClassName++;
    if (!*lpClassName)
        return;

    // make sure the server name is nonblank
    while (*lpServer == ' ')
        lpServer++;
    if (!*lpServer)
        return;

    // we now have a valid entry
    key = NULL;
    if( ( RegCreateKey( HKEY_CLASSES_ROOT, lpClass, &key ) != ERROR_SUCCESS ) ||
        ( RegSetValue( key, NULL, REG_SZ, lpClassName, strlen( lpClassName ) ) != ERROR_SUCCESS ) ) {
        if( key != NULL ) {
            RegCloseKey( key );
        }
        return;
    }
    if( ( RegCreateKey( key, szServerKey, &key1 ) != ERROR_SUCCESS ) ||
        ( RegSetValue( key1, NULL, REG_SZ, lpServer, strlen( lpServer ) ) != ERROR_SUCCESS ) ) {
        if( key != NULL ) {
            RegCloseKey( key );
        }
        if( key1 != NULL ) {
            RegCloseKey( key1 );
        }
        return;
    }
    RegCloseKey( key );
    RegCloseKey( key1 );
}



VOID
SetLastTimeUpdated(
    )

/*++

Routine Description:

    Set the variable that contains the information of when the "embedding"
    section of win.ini was last updated.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _LastTimeUpdated = GetTickCount();
}



BOOL
WasSectionRecentlyUpdated(
    )

/*++

Routine Description:

    Inform the caller whether the "embedding" section of win.ini
    was recently updated ( less than 2 seconds ).

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if the "embedding" section was updated less than
              2 seconds ago.

--*/

{
    DWORD   Now;

    Now = GetTickCount();
    return( ( ( Now - _LastTimeUpdated ) < WININITIMEOUT ) ? TRUE : FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\mapembed.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    mapembed.c

Abstract:

    This module contains the the prototypes of the functions that
    perform the mapping between the "embedding" section of win.ini,
    and the subkeys of HKEY_CLASSES_ROOT.

    This mapping is a hack implemented on Win3.1, that must also
    exist on NT.
    It is implemnted in the WOW layer, since only some win16 apps
    that read or write to the "embedding" section ( Excel and
    MsMail) depend on it.



Author:


    Jaime F. Sasson (jaimes) 25-Nov-1992



--*/

#if !defined( _MAP_EMBEDDING_SECTION_ )

#define _MAP_EMBEDDING_SECTION_

#define IS_EMBEDDING_SECTION(pszSection)                                     \
    ( ! (pszSection == NULL || WOW32_stricmp( pszSection, szEmbedding )) )

BOOL
IsWinIniHelper(
    IN  LPSTR   Filename
    );

//
// WARNING Filename argument to IS_WIN_INI must already be lowercase.
//

#define IS_WIN_INI(Filename) (                                               \
    (Filename)                                                               \
    ? (WOW32_strstr((Filename), szWinDotIni)                                 \
          ? IsWinIniHelper((Filename))                                       \
          : FALSE)                                                           \
     : FALSE)

VOID
UpdateEmbeddingAllKeys( VOID );

VOID
SetLastTimeUpdated( VOID );

VOID
UpdateEmbeddingKey(
    IN  LPSTR   KeyName
    );

VOID
UpdateClassesRootSubKey(
    IN  LPSTR   KeyName,
    IN  LPSTR   Value
    );

BOOL
WasSectionRecentlyUpdated( VOID );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\precomp.h ===
/*++ BUILD Version: 0001
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  precomp.h
 *  Combined precompiled header source
 *
 *  This file is a collection of all the common .h files used by the
 *  various source files in this directory. It is precompiled by the
 *  build process to speed up the overall build time.
 *
 *  Put new .h files in here if it has to be seen by multiple source files.
 *  Keep in mind that the definitions in these .h files are potentially
 *  visible to all source files in this project.
 *
 *  History:
 *  Created 19-Oct-1993 by Neil Sandlin (neilsa)
--*/

#include <stddef.h>
#include <nt.h>
#include "wow32.h"
#include "wowtbl.h"
#include "doswow.h"
#include "wdos.h"
#include "wmdisp32.h"
#include "mapembed.h"
#include "wowusr.h"
#include "waccel.h"
#include "wcall16.h"
#include "wuclass.h"
#include "wsubcls.h"
#include <mmsystem.h>
#include "wkman.h"
#include "fastwow.h"
#include "wcall32.h"
#include "wudlg.h"
#include "tdb16.h"
#include "wcntl32.h"
#include "wcuricon.h"
#include "wmsg16.h"
#include "wmsgbm.h"
#include "wmtbl32.h"
#include "wcommdlg.h"
#include "wowcmdlg.h"
#include <commdlg.h>
#include "wres16.h"
#include "wres32.h"
#include "wowkrn.h"
#include "wdde.h"
#include <dde.h>
#include "wuclip.h"
#include "wgmeta.h"
#include "wowgdi.h"
#include "wgdi.h"
#include "wgprnset.h"
#include "wgfont.h"
#include "wgdi31.h"
#include "wgman.h"
#include "wgpal.h"
#include "wgtext.h"
#include "wheap.h"
#include "wowkbd.h"
#include "wkbman.h"
#include "wkernel.h"
#include "wkfileio.h"
#include <winbase.h>
#include "oemuni.h"
#include "vrnmpipe.h"
#include "wkgthunk.h"
#include "wklocal.h"
#include "wowhooks.h"
#include "wutmr.h"
#include "wreldc.h"
#include "vdmapi.h"
#include "wowinfo.h"
#include "dbgexp.h"
#include "wucomm.h"
#include "wowmmcb.h"
#include "isz.h"
#include "wkmem.h"
#include <mmddk.h>
#include "wowmmed.h"
#include "wmmstruc.h"
#include "wmmedia.h"
#include "isvwow.h"
#include <string.h>
#include <digitalv.h>
#include "wmsgcb.h"
#include "wmsgem.h"
#include "wmsglb.h"
#include "wmsgsbm.h"
#include "wumsg.h"
#include "wuman.h"
#include "vdm.h"
#include "wucaret.h"
#include "wucursor.h"
#include "wuhook.h"
#include "wumenu.h"
#include "wuser.h"
#include "wutext.h"
#include "wuwind.h"
#include "wuser31.h"
#include "wulang.h"
#include "winsockp.h"
#include "wowsnd.h"
#include "wsman.h"
#include "wowshell.h"
#include "wshell.h"
#include "wowth.h"
#include "wthman.h"
#include "wusercli.h"
#include "wole2.h"
#include "win95.h"
#include "wparam.h"
#include <limits.h>
#include <commctrl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\sources.inc ===
INDENTED_DIRECTIVES=1

DLLORDER=..\wow32.prf

!if "$(ALT_PROJECT)" == "NEC_98"
ALT_PROJECT_FE=NEC_98
!else
!if "$(ALT_PROJECT)" == "DAYTONA"
ALT_PROJECT_FE=daytona
!else
ALT_PROJECT_FE=fe
!endif
!endif

MVDM_TREE=$(PROJECT_ROOT)\mvdm

TARGETNAME=wow32
TARGETTYPE=DYNLINK
TARGETPATH=obj

!if "$(ALT_PROJECT)" == "DAYTONA"
PASS1_PUBLISH={$(O)\wow32.lib=$(SDK_LIB_PATH)\wow32.lib}
!endif

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernl32p.lib \
    $(WINDOWS_LIB_PATH)\gdi32p.lib \
    $(WINDOWS_LIB_PATH)\user32p.lib \
    $(WINDOWS_LIB_PATH)\apphelp.lib \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\shell32.lib \
    $(SDK_LIB_PATH)\ntvdm.lib \
    $(MVDM_TREE)\oemuni\$(ALT_PROJECT_FE)\$(O)\oemuni.lib     \
    $(SDK_LIB_PATH)\comdlg32.lib \
    $(SDK_LIB_PATH)\version.lib \
    $(SDK_LIB_PATH)\userenv.lib

DLLENTRY=W32DllInitialize
DLLBASE=0xffb0000
DLLDEF=$(O)\wow32.def

NTTARGETFILES=
NTTARGETFILE0=$(O)\wowit.h $(O)\wowit.c

INCLUDES=\
    $(O);\
    ..;\
    ..\..\inc;\
    $(SHELL_INC_PATH);\
    $(WINDOWS_INC_PATH);\
    $(TERMSRV_INC_PATH);\
    ..\..\vdd\h

USE_NTDLL = 1

SOURCES= \
    ..\wow32.c     \
    ..\wowtbl.c    \
    ..\intthunk.c  \
    $(O)\wowit.c   \
    ..\win95.c     \
    ..\mapembed.c  \
    ..\walias.c    \
    ..\wstruc.c    \
    ..\wcall16.c   \
    ..\wcall32.c   \
    ..\wcntl32.c   \
    ..\wdde.c      \
    ..\wres16.c    \
    ..\wres32.c    \
    ..\wmsg16.c    \
    ..\wmdisp32.c  \
    ..\wmsgbm.c    \
    ..\wmsgcb.c    \
    ..\wmsgem.c    \
    ..\wmsglb.c    \
    ..\wmsgsbm.c   \
    ..\wmtbl32.c   \
    ..\wgdi31.c    \
    ..\wgman.c     \
    ..\wgdi.c      \
    ..\wgfont.c    \
    ..\wgmeta.c    \
    ..\wgpal.c     \
    ..\wgprnset.c  \
    ..\wgtext.c    \
    ..\wkbman.c    \
    ..\wkmem.c     \
    ..\wkgthunk.c  \
    ..\wkman.c     \
    ..\wkfileio.c  \
    ..\wkernel.c   \
    ..\wow32fax.c  \
    ..\wsman.c     \
    ..\wshell.c    \
    ..\wuser31.c   \
    ..\wuman.c     \
    ..\wucaret.c   \
    ..\wuclass.c   \
    ..\wuclip.c    \
    ..\wucomm.c    \
    ..\wucursor.c  \
    ..\wudlg.c     \
    ..\wuhook.c    \
    ..\wulang.c    \
    ..\wumenu.c    \
    ..\wumsg.c     \
    ..\wuser.c     \
    ..\wutext.c    \
    ..\wutmr.c     \
    ..\wuwind.c    \
    ..\wowhooks.c  \
    ..\wdos.c      \
    ..\wreldc.c    \
    ..\wcuricon.c  \
    ..\wsubcls.c   \
    ..\wmmedia.c   \
    ..\wmmedia1.c  \
    ..\wmmedia2.c  \
    ..\wmmstruc.c  \
    ..\wmmstru1.c  \
    ..\wmmstru2.c  \
    ..\wmmalias.c  \
    ..\walloc16.c  \
    ..\waccel.c    \
    ..\wsdata.c    \
    ..\wsext.c     \
    ..\wsraw.c     \
    ..\wthman.c    \
    ..\wcommdlg.c  \
    ..\wheap.c     \
    ..\wspool.c    \
    ..\wusercli.c  \
    ..\wdib.c      \
    ..\wole2.c     \
    ..\wparam.c    \
    ..\wnman.c     \
    ..\wwmman.c    \
    ..\wow32.rc    \
    ..\wshimdb.c

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!IF "$(WOWPROFILE)" == ""
C_DEFINES=-DWIN_32
ASM_DEFINES=-DWIN_32
!ELSE
C_DEFINES=-DWIN_32 -DWOWPROFILE
ASM_DEFINES=-DWIN_32 -DWOWPROFILE
!ENDIF

UMTYPE=windows

!IFNDEF MAKE_GENWOWIT
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
!ENDIF

# Let build.exe know that subwtype.h is included under #ifdef (by d3dtypes.h)
# so it won't complain if it can't be found.

CONDITIONAL_INCLUDES=subwtype.h

W32_SB=1

SOURCES_USED=..\sources.inc


!if "$(ALT_PROJECT)" != "DAYTONA"
LINKER_FLAGS=$(LINKER_FLAGS) /pdb:$(O)\wow32_$(ALT_PROJECT).pdb
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\waccel.c ===
//*****************************************************************************
//
// LoadAccelerator - compatibility support.
//     So much code for such a thing.
//
// 23-Jul-92  NanduriR   Created.
//*****************************************************************************

#include "precomp.h"
#pragma hdrstop

MODNAME(waccel.c);

extern ULONG SetCursorIconFlag(HAND16 hAccel16, BOOL bFlag);

LPACCELALIAS lpAccelAlias = NULL;


//*****************************************************************************
// WU32LoadAccelerators -
//   This gets called from WU32NotifyWow. I use the familiar name WU32...
//   because this gets called indirectly in response to LoadAccelerator
//
//   returs TRUE for success.
//*****************************************************************************


ULONG FASTCALL WU32LoadAccelerators(VPVOID vpData)
{
    PLOADACCEL16 ploadaccel16;
    HACCEL  hAccel;
    BOOL    fReturn = (BOOL)FALSE;


    GETVDMPTR(vpData, sizeof(LOADACCEL16), ploadaccel16);

    if (FindAccelAlias((HANDLE)FETCHWORD(ploadaccel16->hAccel),
                                                              HANDLE_16BIT)) {
        LOGDEBUG(0, ("AccelAlias already exists\n"));
        return (ULONG)TRUE;
    }

    if (hAccel = CreateAccel32(ploadaccel16->pAccel, ploadaccel16->cbAccel)) {
        fReturn =  (BOOL)SetupAccelAlias(FETCHWORD(ploadaccel16->hInst),
                                         FETCHWORD(ploadaccel16->hAccel),
                                         hAccel, TRUE);
    }


    FREEVDMPTR(ploadaccel16);
    return (ULONG)fReturn;
}


//*****************************************************************************
// SetupAccelAlias -
//    sets up the alias. the alias list is doubly linked. nothing fancy.
//
//    returns pointer to the alias.
//*****************************************************************************

LPACCELALIAS SetupAccelAlias(
    HAND16 hInstance,
    HAND16 hAccel16,
    HAND32 hAccel32,
    BOOL   f16
) {
    LPACCELALIAS lpT;
    WORD         hTask16;

    hTask16 = CURRENTPTD()->htask16;
    lpT = FindAccelAlias((HANDLE)hAccel16, HANDLE_16BIT);
    if (lpT == (LPACCELALIAS)NULL) {
        lpT = malloc_w_small(sizeof(ACCELALIAS));
        if (lpT) {
            lpT->lpNext = lpAccelAlias;
            lpT->lpPrev = (LPACCELALIAS)NULL;

            if (lpAccelAlias)
                lpAccelAlias->lpPrev = lpT;

            lpAccelAlias = lpT;
        }
    }
    else {
        LOGDEBUG(0, ("SetupAccelAlias: Alias Already exists. how & why?\n"));
        WOW32ASSERT(FALSE);
    }

    if (lpT) {
        lpT->hInst   = hInstance;
        lpT->hTask16 = CURRENTPTD()->htask16;
        lpT->h16     = hAccel16;
        lpT->h32     = hAccel32;
        lpT->f16     = (WORD)f16;

        // mark this so we can remove it from the alias list when
        // FreeResource() (in user.exe) calls GlobalFree() (in krnl386)
        SetCursorIconFlag(hAccel16, TRUE);
    }
    else {
        WOW32ASSERT(FALSE);
    }


    return (LPACCELALIAS)lpT;
}


//*****************************************************************************
// DestroyAccelAlias -
//    Deletes the 32bit table and Frees the memory
//
//    returns TRUE for success
//*****************************************************************************

BOOL  DestroyAccelAlias(WORD hTask16)
{
    WORD hCurTask16;
    LPACCELALIAS lpT;
    LPACCELALIAS lpTFree;

    hCurTask16 = CURRENTPTD()->htask16;
    lpT = lpAccelAlias;
    while (lpT) {
         if (lpT->hTask16 == hCurTask16) {
             if (lpT->lpPrev)
                 lpT->lpPrev->lpNext = lpT->lpNext;

             if (lpT->lpNext)
                 lpT->lpNext->lpPrev = lpT->lpPrev;

             if ( lpT->f16 ) {
                 DestroyAcceleratorTable(lpT->h32);
             } else {
                 // this function - DestroyAccelAlias- gets called during
                 // taskexit time and the 16bit task cleanup code has already
                 // freed this memory handle. so this callback is not needed.
                 //                                                - nanduri
                 // WOWGlobalFree16( lpT->h16 );
             }

             lpTFree = lpT;
             lpT = lpT->lpNext;
             if (lpTFree == lpAccelAlias)
                 lpAccelAlias = lpT;

             free_w_small(lpTFree);
         }
         else
             lpT = lpT->lpNext;
    }


    return TRUE;
}


//*****************************************************************************
// FindAccelAlias -
//    maps 16 bit handle to 32bit handle and vice versa
//
//    returns TRUE for success
//*****************************************************************************

LPACCELALIAS FindAccelAlias(HANDLE hAccel, UINT fSize)
{
    WORD hCurTask16;
    LPACCELALIAS lpT;

    hCurTask16 = CURRENTPTD()->htask16;
    lpT = lpAccelAlias;
    while (lpT) {
        if (lpT->hTask16 == hCurTask16) {
            if (fSize & HANDLE_16BIT) {
                if (lpT->h16 == (HAND16)hAccel)
                    return lpT;
            }
            else {
                if (lpT->h32 == (HAND32)hAccel)
                    return lpT;
            }
        }

        lpT = lpT->lpNext;
    }

    return NULL;
}


//*****************************************************************************
// GetAccelHandle32 -
//    Returns h32, given h16.
//
//*****************************************************************************

HAND32 GetAccelHandle32(HAND16 h16)
{
  LPACCELALIAS lpT;

  if (!(lpT = FindAccelAlias((HANDLE)(h16), HANDLE_16BIT))) {
      DWORD cbAccel16;
      VPVOID vpAccel16;
      HACCEL hAccel;

      if (vpAccel16 = RealLockResource16(h16, &cbAccel16)) {
          if (hAccel = CreateAccel32(vpAccel16, cbAccel16)) {
              lpT = SetupAccelAlias(CURRENTPTD()->hInst16,  h16,  hAccel, TRUE);
          }
          GlobalUnlock16(h16);
      }
  }
  return  (lpT) ? lpT->h32 : (HAND32)NULL;

}

//*****************************************************************************
// GetAccelHandle16 -
//    Returns h16, given h32.
//
//*****************************************************************************

HAND16 GetAccelHandle16(HAND32 h32)
{
    LPACCELALIAS lpT;
    HAND16  hAccel16;

    if (!(lpT = FindAccelAlias((HANDLE)(h32), HANDLE_32BIT))) {
        //
        // There isn't a corresponding 16-bit accelerator table handle already
        // so create one.
        //
        if ( (hAccel16 = CreateAccel16(h32)) != 0 ) {
            lpT = SetupAccelAlias(CURRENTPTD()->hInst16, hAccel16, h32, FALSE );
        }
    }

    return  (lpT) ? lpT->h16 : (HAND16)NULL;
}

//*****************************************************************************
// CreateAccel32 -
//   This gets called from WU32NotifyWow.
//
//   returs TRUE for success.
//*****************************************************************************


HACCEL CreateAccel32(VPVOID vpAccel16, DWORD cbAccel16)
{
    PSZ          pAccel16;
    DWORD        nElem16;

    LPACCEL lpAccel;
    HACCEL  hAccel = (HACCEL)NULL;
    UINT    i;
#if DBG
    UINT    LastKeyIndex = 0xffffffff;
#endif

    //
    // pAccel16 is pointer to an array of records of length:
    //    (BYTE+WORD+WORD)
    //

    GETVDMPTR(vpAccel16 , cbAccel16, pAccel16);
    if (pAccel16) {

        //
        // convert the 16bit accel table to 32bit format and create it.
        //

        nElem16 = cbAccel16 / (sizeof(BYTE) + 2 * sizeof(WORD));
        lpAccel = (LPACCEL)malloc_w(nElem16 * sizeof(ACCEL));
        if (lpAccel) {
            for (i=0; i<nElem16; ++i) {
                 lpAccel[i].fVirt = *(LPBYTE)(pAccel16);
#if DBG
                 if ((lpAccel[i].fVirt & 0x80) && i < LastKeyIndex) {
                    LastKeyIndex = i;
                 }
#endif
                 ((LPBYTE)pAccel16)++;
                 lpAccel[i].key   = FETCHWORD(*(LPWORD)pAccel16);
                 ((LPWORD)pAccel16)++;
                 lpAccel[i].cmd   = FETCHWORD(*(LPWORD)pAccel16);
                 ((LPWORD)pAccel16)++;
            }

#if DBG
            if (LastKeyIndex == 0xffffffff) {
                LOGDEBUG(LOG_ALWAYS, ("WOW::CreateAccel32 : no LastKey found in 16-bit haccel\n"));
            } else if (LastKeyIndex < nElem16-1) {
                LOGDEBUG(LOG_ALWAYS, ("WOW::CreateAccel32 : bogus LastKey flags ignored in 16-bit haccel\n"));
            }
#endif
            hAccel = CreateAcceleratorTable(lpAccel, i);
            free_w(lpAccel);
        }
        FREEVDMPTR(pAccel16);
    }

    return hAccel;
}

//*****************************************************************************
// CreateAccel16 -
//   This gets called from WU32NotifyWow.
//
//   returns HACCEL16 for success.
//*****************************************************************************

HAND16 CreateAccel16(HACCEL hAccel32)
{
    UINT    iEntries;
    UINT    cbSize;
    LPACCEL lpAccel32;
    HAND16  hAccel16;
    VPVOID  vpAccel16;
    LPBYTE  lpAccel16;
    LPBYTE  lpAccel16Original;
    UINT    i;

    iEntries = CopyAcceleratorTable( hAccel32, NULL, 0 );

    if ( iEntries == 0 ) {      // Invalid hAccel32
        return( 0 );
    }

    lpAccel32 = (LPACCEL)malloc_w(iEntries * sizeof(ACCEL));
    if ( lpAccel32 == NULL ) {
        LOGDEBUG(LOG_ERROR, ("WOW::CreateAccel16 : Failed to alloc memory for 32-bit accel\n"));
        return( 0 );
    }

    iEntries = CopyAcceleratorTable( hAccel32, lpAccel32, iEntries );

    cbSize = iEntries * (sizeof(BYTE) + 2 * sizeof(WORD));

    vpAccel16 = GlobalAllocLock16( GMEM_MOVEABLE, cbSize, &hAccel16 );

    if ( vpAccel16 == 0 ) {     // Out of 16-bit memory
        LOGDEBUG(LOG_ERROR, ("WOW::CreateAccel16 : Failed to alloc memory for 16-bit haccel\n"));
        free_w( lpAccel32 );
        return( 0 );
    }

    GETVDMPTR(vpAccel16, cbSize, lpAccel16 );

    WOW32ASSERT( lpAccel16 != NULL );

    lpAccel16Original = lpAccel16;

    //
    // Now iterate through the entries changing them and moving them into
    // the 16-bit memory.
    //

    i = 0;

    while ( i < iEntries ) {
        if ( i == iEntries-1 ) {
            // Last one, set the last bit
            *lpAccel16++ = lpAccel32[i].fVirt | 0x80;
        } else {
            *lpAccel16++ = lpAccel32[i].fVirt;
        }
        *((PWORD16)lpAccel16) = lpAccel32[i].key;
        lpAccel16 += sizeof(WORD);
        *((PWORD16)lpAccel16) = lpAccel32[i].cmd;
        lpAccel16 += sizeof(WORD);

        i++;
    }

    FLUSHVDMPTR(vpAccel16, cbSize, lpAccel16Original);
    FREEVDMPTR(lpAccel16Original);

    GlobalUnlock16( hAccel16 );

    return( hAccel16 );
}



// this gets called indirectly from GlobalFree() in krnl386.exe
// via WK32WowCursorIconOp() in wcuricon.c
void FreeAccelAliasEntry(LPACCELALIAS lpT) {

    if (lpT == lpAccelAlias)
        lpAccelAlias = lpT->lpNext;

    if (lpT->lpPrev)
        lpT->lpPrev->lpNext = lpT->lpNext;

    if (lpT->lpNext)
        lpT->lpNext->lpPrev = lpT->lpPrev;

    if ( lpT->f16 ) {
        DestroyAcceleratorTable(lpT->h32);
    } else {
         // this function - FreeAccelAliasEntry -- is being called
         // indirectly from GlobalFree() in krnl386.  GlobalFree()
         // takes care of freeing h16 so this callback is not needed.
         //                                                - a-craigj
         // WOWGlobalFree16( lpT->h16 );
    }

    free_w_small(lpT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\waccel.h ===
//*****************************************************************************
//
// LoadAccelerator - compatibility support.
//
//
// 23-Jul-92  NanduriR   Created.
//*****************************************************************************


typedef struct _ACCELALIAS {
    struct _ACCELALIAS FAR *lpNext;
    struct _ACCELALIAS FAR *lpPrev;
    HAND16  hInst;
    HTASK16 hTask16;
    WORD    f16;            // WORD only for padding, could be BOOL,DWORD
    HAND16  h16;
    HAND32  h32;
} ACCELALIAS, FAR *LPACCELALIAS;


ULONG FASTCALL WU32LoadAccelerators(VPVOID vpData);
LPACCELALIAS SetupAccelAlias(HAND16 hInstance, HAND16 hAccel16, HAND32 hAccel32, BOOL f16);
BOOL  DestroyAccelAlias(WORD hTask16);
LPACCELALIAS FindAccelAlias(HANDLE hAccel, UINT fSize);
HAND32 GetAccelHandle32(HAND16 h16);
HAND16 GetAccelHandle16(HAND32 h32);
HACCEL CreateAccel32(VPVOID vpAccel16, DWORD cbAccel16);
HAND16 CreateAccel16(HACCEL hAccel32);


#define HANDLE_16BIT       0x01
#define HANDLE_32BIT       0x02
#define HACCEL32(h16)      GetAccelHandle32(h16)
#define GETHACCEL16(h32)   GetAccelHandle16(h32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\walias.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WALIAS.C
 *  WOW32 16-bit handle alias support
 *
 *  History:
 *  Created 27-Jan-1991 by Jeff Parsons (jeffpar)
 *  Modified 12-May-1992 by Mike Tricker (miketri) to add MultiMedia support
--*/

#include "precomp.h"
#pragma hdrstop

MODNAME(walias.c);

extern CRITICAL_SECTION gcsWOW;
extern PTD gptdTaskHead;

//BUGBUG - this must be removed once MM_MCISYSTEM_STRING is defined in MMSYSTEM.H.
#ifndef MM_MCISYSTEM_STRING
    #define MM_MCISYSTEM_STRING 0x3CA
#endif

#ifdef  DEBUG
extern  BOOL fSkipLog;          // TRUE to temporarily skip certain logging
#endif

typedef struct _stdclass {
    LPSTR   lpszClassName;
    ATOM    aClassAtom;
    WNDPROC lpfnWndProc;
    INT     iOrdinal;
    DWORD   vpfnWndProc;
} STDCLASS;

// Some cool defines stolen from USERSRV.H
#define MENUCLASS       MAKEINTATOM(0x8000)
#define DESKTOPCLASS    MAKEINTATOM(0x8001)
#define DIALOGCLASS     MAKEINTATOM(0x8002)
#define SWITCHWNDCLASS  MAKEINTATOM(0x8003)
#define ICONTITLECLASS  MAKEINTATOM(0x8004)

// See WARNING below!
STDCLASS stdClasses[] = {
    NULL,           0,                      NULL,   0,                      0,  // WOWCLASS_UNKNOWN
    NULL,           0,                      NULL,   0,                      0,  // WOWCLASS_WIN16
    "BUTTON",       0,                      NULL,   FUN_BUTTONWNDPROC,      0,  // WOWCLASS_BUTTON,
    "COMBOBOX",     0,                      NULL,   FUN_COMBOBOXCTLWNDPROC, 0,  // WOWCLASS_COMBOBOX,
    "EDIT",         0,                      NULL,   FUN_EDITWNDPROC,        0,  // WOWCLASS_EDIT,
    "LISTBOX",      0,                      NULL,   FUN_LBOXCTLWNDPROC,     0,  // WOWCLASS_LISTBOX,
    "MDICLIENT",    0,                      NULL,   FUN_MDICLIENTWNDPROC,   0,  // WOWCLASS_MDICLIENT,
    "SCROLLBAR",    0,                      NULL,   FUN_SBWNDPROC,          0,  // WOWCLASS_SCROLLBAR,
    "STATIC",       0,                      NULL,   FUN_STATICWNDPROC,      0,  // WOWCLASS_STATIC,
    "#32769",       (WORD)DESKTOPCLASS,     NULL,   FUN_DESKTOPWNDPROC,     0,  // WOWCLASS_DESKTOP,
    "#32770",       (WORD)DIALOGCLASS,      NULL,   FUN_DEFDLGPROCTHUNK,    0,  // WOWCLASS_DIALOG,
    "#32772",       (WORD)ICONTITLECLASS,   NULL,   FUN_TITLEWNDPROC,       0,  // WOWCLASS_ICONTITLE,
    "#32768",       (WORD)MENUCLASS,        NULL,   FUN_MENUWNDPROC,        0,  // WOWCLASS_MENU,
    "#32771",       (WORD)SWITCHWNDCLASS,   NULL,   0,                      0,  // WOWCLASS_SWITCHWND,
    "COMBOLBOX",    0,                      NULL,   FUN_LBOXCTLWNDPROC,     0,  // WOWCLASS_COMBOLBOX
};
//
// WARNING! The above sequence and values must be maintained otherwise the
// table in WMSG16.C for message thunking must be changed.  Same goes for
// the #define's in WALIAS.H
//
// The above COMBOLBOX case is special because it is class that is
// almost identical to a listbox.  Therefore we lie about it.

INT GetStdClassNumber(
    PSZ pszClass
) {
    INT     i;

    if ( HIWORD(pszClass) ) {

        // They passed us a string

        for ( i = WOWCLASS_BUTTON; i < NUMEL(stdClasses); i++ ) {
            if ( WOW32_stricmp(pszClass, stdClasses[i].lpszClassName) == 0 ) {
                return( i );
            }
        }
    } else {

        // They passed us an atom

        for ( i = WOWCLASS_BUTTON; i < NUMEL(stdClasses); i++ ) {
            if ( stdClasses[i].aClassAtom == 0 ) {
                // RegisterWindowMessage is an undocumented way of determining
                // an atom value in the context of the server-side heap.
                stdClasses[i].aClassAtom = (ATOM)RegisterWindowMessage(stdClasses[i].lpszClassName);
            }
            if ( (ATOM)LOWORD(pszClass) == stdClasses[i].aClassAtom ) {
                return( i );
            }
        }
    }
    return( WOWCLASS_WIN16 );  // private 16-bit class created by the app
}

// Returns a 32 window proc given a class index

WNDPROC GetStdClassWndProc(
    DWORD   iClass
) {
    WNDPROC lpfn32;

    if ( iClass < WOWCLASS_WIN16 || iClass > WOWCLASS_MAX ) {
        WOW32ASSERT(FALSE);
        return( NULL );
    }

    lpfn32 = stdClasses[iClass].lpfnWndProc;

    if ( lpfn32 == NULL ) {
        WNDCLASS    wc;
        BOOL        f;

        f = GetClassInfo( NULL, stdClasses[iClass].lpszClassName, &wc );

        if ( f ) {
            VPVOID  vp;
       DWORD UNALIGNED * lpdw;

            lpfn32 = wc.lpfnWndProc;
            stdClasses[iClass].lpfnWndProc = lpfn32;

            vp = GetStdClassThunkProc(iClass);
            vp = (VPVOID)((DWORD)vp - sizeof(DWORD)*3);

            GETVDMPTR( vp, sizeof(DWORD)*3, lpdw );

            WOW32ASSERT(*lpdw == SUBCLASS_MAGIC);   // Are we editing the right stuff?

            if (!lpdw)
                *(lpdw+2) = (DWORD)lpfn32;

            FLUSHVDMCODEPTR( vp, sizeof(DWORD)*3, lpdw );
            FREEVDMPTR( lpdw );

        }
    }
    return( lpfn32 );
}

// Returns a 16 window proc thunk given a class index

DWORD GetStdClassThunkProc(
    INT     iClass
) {
    DWORD   dwResult;
    SHORT   iOrdinal;
    PARM16  Parm16;

    if ( iClass < WOWCLASS_WIN16 || iClass > WOWCLASS_MAX ) {
        WOW32ASSERT(FALSE);
        return( 0 );
    }

    iOrdinal = (SHORT)stdClasses[iClass].iOrdinal;

    if ( iOrdinal == 0 ) {
        return( (DWORD)NULL );
    }

    // If we've already gotten this proc, then don't bother calling into 16-bit
    dwResult = stdClasses[iClass].vpfnWndProc;

    if ( dwResult == (DWORD)NULL ) {

        // Callback into the 16-bit world asking for the 16:16 address

        Parm16.SubClassProc.iOrdinal = iOrdinal;

        if (!CallBack16(RET_SUBCLASSPROC, &Parm16, (VPPROC)NULL,
                          (PVPVOID)&dwResult)) {
            WOW32ASSERT(FALSE);
            return( 0 );
        }
        // Save it since it is a constant.
        stdClasses[iClass].vpfnWndProc = dwResult;
    }
    return( dwResult );
}

/*
 * PWC GetClassWOWWords(hInst, pszClass)
 *   is a ***private*** API for WOW only. It returns a pointer to the
 *   WOW Class structure in the server's window class structure.
 *   This is similar to GetClassLong(hwnd32, GCL_WOWWORDS) (see FindPWC),
 *   but in this case we don't have a hwnd32, we have the class name
 *   and instance handle.
 */

PWC FindClass16(LPCSTR pszClass, HAND16 hInst)
{
    register PWC pwc;

    pwc = (PWC)(pfnOut.pfnGetClassWOWWords)(HMODINST32(hInst), pszClass);
    WOW32WARNMSGF(
        pwc,
        ("WOW32 warning: GetClassWOWWords('%s', %04x) returned NULL\n", pszClass, hInst)
        );

    return (pwc);
}



#ifdef DEBUG

INT nAliases;
INT iLargestListSlot;

PSZ apszHandleClasses[] = {
    "Unknown",      // WOWCLASS_UNKNOWN
    "Window",       // WOWCLASS_WIN16
    "Button",       // WOWCLASS_BUTTON
    "ComboBox",     // WOWCLASS_COMBOBOX
    "Edit",         // WOWCLASS_EDIT
    "ListBox",      // WOWCLASS_LISTBOX
    "MDIClient",    // WOWCLASS_MDICLIENT
    "Scrollbar",    // WOWCLASS_SCROLLBAR
    "Static",       // WOWCLASS_STATIC
    "Desktop",      // WOWCLASS_DESKTOP
    "Dialog",       // WOWCLASS_DIALOG
    "Menu",         // WOWCLASS_MENU
    "IconTitle",    // WOWCLASS_ICONTITLE
    "Accel",        // WOWCLASS_ACCEL
    "Cursor",       // WOWCLASS_CURSOR
    "Icon",         // WOWCLASS_ICON
    "DC",           // WOWCLASS_DC
    "Font",         // WOWCLASS_FONT
    "MetaFile",     // WOWCLASS_METAFILE
    "Region",       // WOWCLASS_RGN
    "Bitmap",       // WOWCLASS_BITMAP
    "Brush",        // WOWCLASS_BRUSH
    "Palette",      // WOWCLASS_PALETTE
    "Pen",          // WOWCLASS_PEN
    "Object"        // WOWCLASS_OBJECT
};


BOOL MessageNeedsThunking(UINT uMsg)
{
    switch (uMsg) {
        case WM_CREATE:
        case WM_ACTIVATE:
        case WM_SETFOCUS:
        case WM_KILLFOCUS:
        case WM_SETTEXT:
        case WM_GETTEXT:
        case WM_ERASEBKGND:
        case WM_WININICHANGE:
        case WM_DEVMODECHANGE:
        case WM_ACTIVATEAPP:
        case WM_SETCURSOR:
        case WM_MOUSEACTIVATE:
        case WM_GETMINMAXINFO:
        case WM_ICONERASEBKGND:
        case WM_NEXTDLGCTL:
        case WM_DRAWITEM:
        case WM_MEASUREITEM:
        case WM_DELETEITEM:
        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
        case WM_SETFONT:
        case WM_GETFONT:
        case WM_QUERYDRAGICON:
        case WM_COMPAREITEM:
        case WM_OTHERWINDOWCREATED:
        case WM_OTHERWINDOWDESTROYED:
        case WM_COMMNOTIFY:
        case WM_WINDOWPOSCHANGING:
        case WM_WINDOWPOSCHANGED:
        case WM_NCCREATE:
        case WM_NCCALCSIZE:
        case WM_COMMAND:
        case WM_HSCROLL:
        case WM_VSCROLL:
        case WM_INITMENU:
        case WM_INITMENUPOPUP:
        case WM_MENUSELECT:
        case WM_MENUCHAR:
        case WM_ENTERIDLE:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
        case WM_PARENTNOTIFY:
        case WM_MDICREATE:
        case WM_MDIDESTROY:
        case WM_MDIACTIVATE:
        case WM_MDIGETACTIVE:
        case WM_MDISETMENU:
        case WM_RENDERFORMAT:
        case WM_PAINTCLIPBOARD:
        case WM_VSCROLLCLIPBOARD:
        case WM_SIZECLIPBOARD:
        case WM_ASKCBFORMATNAME:
        case WM_CHANGECBCHAIN:
        case WM_HSCROLLCLIPBOARD:
        case WM_PALETTEISCHANGING:
        case WM_PALETTECHANGED:
        case MM_JOY1MOVE:
        case MM_JOY2MOVE:
        case MM_JOY1ZMOVE:
        case MM_JOY2ZMOVE:
        case MM_JOY1BUTTONDOWN:
        case MM_JOY2BUTTONDOWN:
        case MM_JOY1BUTTONUP:
        case MM_JOY2BUTTONUP:
        case MM_MCINOTIFY:
        case MM_MCISYSTEM_STRING:
        case MM_WOM_OPEN:
        case MM_WOM_CLOSE:
        case MM_WOM_DONE:
        case MM_WIM_OPEN:
        case MM_WIM_CLOSE:
        case MM_WIM_DATA:
        case MM_MIM_OPEN:
        case MM_MIM_CLOSE:
        case MM_MIM_DATA:
        case MM_MIM_LONGDATA:
        case MM_MIM_ERROR:
        case MM_MIM_LONGERROR:
        case MM_MOM_OPEN:
        case MM_MOM_CLOSE:
        case MM_MOM_DONE:
            LOGDEBUG(LOG_IMPORTANT,
                ("MessageNeedsThunking: WM_msg %04x is not thunked\n", uMsg));
            return TRUE;

        default:
            return FALSE;

    }
}

#endif


PTD ThreadProcID32toPTD(DWORD dwThreadID, DWORD dwProcessID)
{
    PTD ptd, ptdThis;
    PWOAINST pWOA;

    //
    // If we have active child instances of WinOldAp,
    // try to map the process ID of a child Win32 app
    // to the corresponding WinOldAp PTD.
    //

    ptdThis = CURRENTPTD();

    EnterCriticalSection(&ptdThis->csTD);

    pWOA = ptdThis->pWOAList;

    while (pWOA && pWOA->dwChildProcessID != dwProcessID) {
        pWOA = pWOA->pNext;
    }

    if (pWOA) {

        ptd = pWOA->ptdWOA;

        LeaveCriticalSection(&ptdThis->csTD);

    } else {

        LeaveCriticalSection(&ptdThis->csTD);

        //
        // We didn't find a WinOldAp PTD to return, see
        // if the thread ID matches one of our app threads.
        //

        EnterCriticalSection(&gcsWOW);

        ptd = gptdTaskHead;

        while (ptd && ptd->dwThreadID != dwThreadID) {
            ptd = ptd->ptdNext;
        }

        LeaveCriticalSection(&gcsWOW);
    }

    return ptd;

}

PTD Htask16toPTD(
    HTASK16 htask16
) {
    PTD  ptd;

    EnterCriticalSection(&gcsWOW);

    ptd = gptdTaskHead;

    while(ptd) {

        if ( ptd->htask16 == htask16 ) {
            break;
        }
        ptd = ptd->ptdNext;
    }

    LeaveCriticalSection(&gcsWOW);

    return ptd;
}


HTASK16 ThreadID32toHtask16(
    DWORD   ThreadID32
) {
    PTD ptd;
    HTASK16 htask16;


    if ( ThreadID32 == 0 ) {
        WOW32ASSERTMSG(ThreadID32, "WOW::ThreadID32tohTask16: Thread ID is 0\n");
        htask16 = 0;
    } else {

        ptd = ThreadProcID32toPTD( ThreadID32, (DWORD)-1 );
        if ( ptd ) {
            // Good, its one of our wow threads.
            htask16 = ptd->htask16;
        } else {
            // Nope, its is some other 32-bit thread
            htask16 = FindHtaskAlias( ThreadID32 );
            if ( htask16 == 0 ) {
                //
                // See the comment in WOLE2.C for a nice description
                //
                htask16 = AddHtaskAlias( ThreadID32 );
            }
        }
    }

    return htask16;
}

DWORD Htask16toThreadID32(
    HTASK16 htask16
) {
    if ( htask16 == 0 ) {
        return( 0 );
    }

    if ( ISTASKALIAS(htask16) ) {
        return( GetHtaskAlias(htask16,NULL) );
    } else {
        return( THREADID32(htask16) );
    }
}

//***************************************************************************
// GetGCL_HMODULE - returns the valid hmodule if the window corresponds to
//                  a 16bit class else returns the hmodule of 16bit user.exe
//                  if the window is of a standard class.
//
// These cases are required for compatibility sake.
//         apps like VirtualMonitor, hDC etc depend on such behaviour.
//                                                              - Nanduri
//***************************************************************************
WORD gUser16hInstance = 0;

ULONG GetGCL_HMODULE(HWND hwnd)
{
    ULONG    ul;
    PTD      ptd;
    PWOAINST pWOA;
    DWORD    dwProcessID;

    ul = (ULONG)GetClassLong(hwnd, GCL_HMODULE);

    //
    // hMod32 = 0xZZZZ0000
    //

    if (ul != 0 && LOWORD(ul) == 0) {

        //
        // If we have active WinOldAp children, see if this window
        // belongs to a Win32 process spawned by one of the
        // active winoldap's.  If it is, return the hmodule
        // of the corresponding winoldap.  Otherwise we
        // return user.exe's hinstance (why not hmodule?)
        //

        dwProcessID = (DWORD)-1;
        GetWindowThreadProcessId(hwnd, &dwProcessID);

        ptd = CURRENTPTD();

        EnterCriticalSection(&ptd->csTD);

        pWOA = ptd->pWOAList;
        while (pWOA && pWOA->dwChildProcessID != dwProcessID) {
            pWOA = pWOA->pNext;
        }

        if (pWOA) {
            ul = pWOA->ptdWOA->hMod16;
            LOGDEBUG(LOG_ALWAYS, ("WOW32 GetClassLong(0x%x, GWW_HMODULE) returning 0x%04x\n",
                                  hwnd, ul));
        } else {
            ul = (ULONG) gUser16hInstance;
            WOW32ASSERT(ul);
        }

        LeaveCriticalSection(&ptd->csTD);
    }
    else {
        ul = (ULONG)GETHMOD16(ul);      // 32-bit hmod is HMODINST32
    }

    return ul;
}

//
// EXPORTED handle mapping functions.  WOW32 code should use the
// macros defined in walias.h -- these functions are for use by
// third-party 32-bit code running in WOW, for example called
// using generic thunks from WOW-specific 16-bit code.
//

HANDLE WOWHandle32 (WORD h16, WOW_HANDLE_TYPE htype)
{
    switch (htype) {
        case WOW_TYPE_HWND:
            return HWND32(h16);
        case WOW_TYPE_HMENU:
            return HMENU32(h16);
        case WOW_TYPE_HDWP:
            return HDWP32(h16);
        case WOW_TYPE_HDROP:
            return HDROP32(h16);
        case WOW_TYPE_HDC:
            return HDC32(h16);
        case WOW_TYPE_HFONT:
            return HFONT32(h16);
        case WOW_TYPE_HMETAFILE:
            return HMETA32(h16);
        case WOW_TYPE_HRGN:
            return HRGN32(h16);
        case WOW_TYPE_HBITMAP:
            return HBITMAP32(h16);
        case WOW_TYPE_HBRUSH:
            return HBRUSH32(h16);
        case WOW_TYPE_HPALETTE:
            return HPALETTE32(h16);
        case WOW_TYPE_HPEN:
            return HPEN32(h16);
        case WOW_TYPE_HACCEL:
            return HACCEL32(h16);
        case WOW_TYPE_HTASK:
            return (HANDLE)HTASK32(h16);
        case WOW_TYPE_FULLHWND:
            return (HANDLE)FULLHWND32(h16);
        default:
            return(INVALID_HANDLE_VALUE);
    }
}

WORD WOWHandle16 (HANDLE h32, WOW_HANDLE_TYPE htype)
{
    switch (htype) {
        case WOW_TYPE_HWND:
            return GETHWND16(h32);
        case WOW_TYPE_HMENU:
            return GETHMENU16(h32);
        case WOW_TYPE_HDWP:
            return GETHDWP16(h32);
        case WOW_TYPE_HDROP:
            return GETHDROP16(h32);
        case WOW_TYPE_HDC:
            return GETHDC16(h32);
        case WOW_TYPE_HFONT:
            return GETHFONT16(h32);
        case WOW_TYPE_HMETAFILE:
            return GETHMETA16(h32);
        case WOW_TYPE_HRGN:
            return GETHRGN16(h32);
        case WOW_TYPE_HBITMAP:
            return GETHBITMAP16(h32);
        case WOW_TYPE_HBRUSH:
            return GETHBRUSH16(h32);
        case WOW_TYPE_HPALETTE:
            return GETHPALETTE16(h32);
        case WOW_TYPE_HPEN:
            return GETHPEN16(h32);
        case WOW_TYPE_HACCEL:
            return GETHACCEL16(h32);
        case WOW_TYPE_HTASK:
            return GETHTASK16(h32);
        default:
            return(0xffff);
    }
}

PVOID gpGdiHandleInfo = (PVOID)-1;

//WARNING: This structure must match ENTRY in ntgdi\inc\hmgshare.h

typedef struct _ENTRYWOW
{
    LONG   l1;
    LONG   l2;
    USHORT FullUnique;
    USHORT us1;
    LONG   l3;
} ENTRYWOW, *PENTRYWOW;

//
// this routine converts a 16bit GDI handle to a 32bit handle.  There
// is no need to do any validation on the handle since the 14bit space
// for handles ignoring the low two bits is completely contained in the
// valid 32bit handle space.
//

HANDLE hConvert16to32(int h16)
{
    ULONG h32;
    int i = h16 >> 2;

    h32 = i | (ULONG)(((PENTRYWOW)gpGdiHandleInfo)[i].FullUnique) << 16;

    return((HANDLE)h32);
}


// Implemented as temporary fix for Whistler Bug #435401
// Should be fixed for Blackcomb or sooner
extern HANDLE hmodWOW32;

HAND16 hConvert32to16(DWORD h32)
{
    PARM16 Parm16;
    VPVOID vp = 0;    

    // see if handle is over 14-bits
    if(LOWORD(h32) > 0x00003FFF) {
       char szErrorMessage[512];
       char szTitle[512];
       char szModName[9];
       PTDB pTDB;

       pTDB = (PVOID)SEGPTR(CURRENTPTD()->htask16,0);

       RtlCopyMemory(szModName, pTDB->TDB_ModName, sizeof(szModName)-1);
       szModName[sizeof(szModName)-1] = 0;
       if (!LoadString(hmodWOW32, iszApplication,
               szTitle, sizeof(szTitle)/sizeof(CHAR)))
       {
           szTitle[0] = 0;
       }
       strcat(szTitle, szModName);

       LoadString(hmodWOW32,
                  iszExceedGDIHandleLimit,
                  szErrorMessage,
                  sizeof szErrorMessage);

       // The GDI32 handle allocation has gone over the 16K threshhold
       // This thread is toast.
       WOWSysErrorBox(szTitle, szErrorMessage, SEB_OK | SEB_DEFBUTTON, 0, 0);

       LOGDEBUG(LOG_ALWAYS,
                ("GDI32 handle limit exceeded for Task %04X \n",
                CURRENTPTD()->htask16));

       CallBack16(RET_FORCETASKEXIT, &Parm16, 0, &vp);

       // this should never return
       return(0);
    }

    // everything is hunky dory
    return((HAND16)(((DWORD) (h32)) << 2));
}

// We probably don't need to worry about this buffer being too small since we're
// really only interested in the predefined standard classes which tend to
// be rather short-named.
#define MAX_CLASSNAME_LEN  64

// There is a time frame (from when an app calls CreateWindow until USER32 gets
// a message at one of its WndProc's for the window - see FritzS) during which
// the fnid (class type) can't be set officially for the window.  If the
// GETICLASS macro is invoked during this period, it will be unable to find the
// iClass for windows created on any of the standard control classes using the
// fast fnid index method (see walias.h).  Once the time frame is passed, the
// fast fnid method will work fine for these windows.
//
// This is manifested in apps that set CBT hooks and try to subclass the
// standard classes while in their hook proc.  See bug #143811.

INT GetIClass(PWW pww, HWND hwnd)
{
    INT   iClass;
    DWORD dwClassAtom;

    // if it is a standard class
    if(((pww->fnid & 0xfff) >= FNID_START) &&
                 ((pww->fnid & 0xfff) <= FNID_END)) {

        // return the class id for this initialized window
        iClass = pfnOut.aiWowClass[( pww->fnid & 0xfff) - FNID_START];

    }

    else {

       iClass = WOWCLASS_WIN16;       // default return: app private class           
   
       dwClassAtom = GetClassLong(hwnd, GCW_ATOM);
   
       if(dwClassAtom) {
           iClass = GetStdClassNumber((PSZ)dwClassAtom);
       }
    }

    return(iClass);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\walias.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WALIAS.H
 *  WOW32 16-bit handle alias support
 *
 *  History:
 *  Created 27-Jan-1991 by Jeff Parsons (jeffpar)
 *  Modified 12-May-1992 by Mike Tricker (miketri) to add MultiMedia support
--*/

typedef HANDLE HAND32;

#define _WALIAS_
#include "wspool.h"
#include "wowuserp.h"


//
//
// The WC structure is present in every CLS structure in the system,
// although USER32 defines it as an array of 2 DWORDs.  FindPWC(hwnd)
// returns a read-only pointer to the WC structure for a given window's
// class.  Note that only classes registered by Win16 applications will
// have meaningful values in the structure.  To change elements of the
// structure, use SETWC (== SetClassLong) with the appropriate GCL_WOW*
// offset defined below.
//

#define SETWC(hwnd, nIndex, l)  SetClassLong(hwnd, nIndex, l)

#define SETWL(hwnd, nIndex, l)          SetWindowLong(hwnd, nIndex, l)

typedef struct _HDW {
    struct _HDW *Next;      // pointer to next hDDE alias
    HANDLE  hdwp32;         // handle of WOW allocated 32 bit object
} HDW, *PHDW;


/* Handle mapping macros
 */

//
//  The 32-bit hInstance for a 16-bit task will be hMod / hInst.
//  The hModule/hInstnace for a 32-bit entity will be xxxx / 0000.
//
//    FritzS  8/13/92
//

#define HINSTRES32(h16)            ((h16)?HMODINST32(h16):(HANDLE)NULL)

//
// The THREADID32 and HTASK32 macros are nearly equivalent, but the
// WOWHandle mapping uses the one which will detect aliases (see WOLE2.C).
// Most other functions don't need alias detection and it is too late
// to test with the more general.
//

#ifdef DEBUG

//
// Check for task aliases that will cause us to fault if we dereference the NULL
// pointer returned by SEGPTR(htask16,0).
//

#define THREADID32(htask16)                                                   \
        ((htask16)                                                            \
             ? (ISTASKALIAS(htask16)                                          \
                    ? (WOW32ASSERTMSGF(FALSE,                                 \
                           ("WOW32 ERROR %s line %d Task alias "              \
                            "to THREADID32, use HTASK32 instead.\n",          \
                            szModule, __LINE__)), 0)                          \
                    : ((PTDB)SEGPTR((htask16),0))->TDB_ThreadID)              \
             : 0)
#else
#define THREADID32(htask16)  ((htask16)                                       \
                                  ? ((PTDB)SEGPTR((htask16),0))->TDB_ThreadID \
                                  : 0)
#endif

#define HTASK32(htask16)           (Htask16toThreadID32(htask16))
#define GETHTASK16(htask32)        (ThreadID32toHtask16((DWORD)htask32))

#define ISINST16(h32)              (((INT)(h32) & 0x0000fffe) != 0)
#define HMODINST32(h16)            ((HANDLE) MAKELONG(h16, GetExePtr16(h16)))
#define GETHINST16(h32)            ((HAND16)(INT)(h32))
#define GETHMOD16(h32)             ((HAND16)(INT)(HIWORD(h32)))

#define ISMEM16(h32)               (((INT)(h32) & 0xFFFF0000) == 0)
#define HMEM32(h16)                ((HANDLE)(INT)(h16))
#define GETHMEM16(h32)             ((HMEM16)(INT)(h32))

#define ISRES16(h32)               ((INT)(h32)&1)
#define HRES32(p)                  ((p)?(HANDLE)((INT)(p)|1):(HANDLE)NULL)
#define GETHRES16(h32)             ((PRES)((INT)(h32)&~1))

#define USER32(h16)                ((HAND32)(INT)(SHORT)(h16))
#define USER16(h32)                ((HAND16)h32)

#define HWND32(h16)                USER32(h16)
#define FULLHWND32(h16)            (pfnOut.pfnGetFullUserHandle)(h16)
#define GETHWND16(h32)             USER16(h32)
#define GETHWNDIA16(h32)           GETHWND16(h32)
#define HWNDIA32(h16)              HWND32(h16)

#define HMENU32(h16)               USER32(h16)
#define GETHMENU16(h32)            USER16(h32)


#define SERVERHANDLE(h)            (HIWORD(h))

#define GDI32(h16)                 (HANDLE) hConvert16to32(h16)
#define GDI16(h32)                 ((HAND16) hConvert32to16((DWORD)h32))

#define HGDI16(hobj32)             GDI16((HAND32)(hobj32))

#define HDC32(hdc16)               GDI32((HAND16)(hdc16))
#define GETHDC16(hdc32)            GDI16((HAND32)(hdc32))

#define HFONT32(hobj16)            GDI32((HAND16)(hobj16))
#define GETHFONT16(hobj32)         GDI16((HAND32)(hobj32))

#define HMETA32(hobj16)            ((HANDLE)HMFFromWinMetaFile((HAND16)(hobj16),FALSE))
#define GETHMETA16(hobj32)         ((HAND16)WinMetaFileFromHMF((HMETAFILE)(hobj32),FALSE))

#define HRGN32(hobj16)             GDI32((HAND16)(hobj16))
#define GETHRGN16(hobj32)          GDI16((HAND32)(hobj32))

#define HBITMAP32(hobj16)          GDI32((HAND16)(hobj16))
#define GETHBITMAP16(hobj32)       GDI16((HAND32)(hobj32))

#define HBRUSH32(hobj16)           GDI32((HAND16)(hobj16))
#define GETHBRUSH16(hobj32)        GDI16((HAND32)(hobj32))

#define HPALETTE32(hobj16)         GDI32((HAND16)(hobj16))
#define GETHPALETTE16(hobj32)      GDI16((HAND32)(hobj32))

#define HPEN32(hobj16)             GDI32((HAND16)(hobj16))
#define GETHPEN16(hobj32)          GDI16((HAND32)(hobj32))

#define HOBJ32(hobj16)             GDI32((HAND16)(hobj16))
#define GETHOBJ16(hobj32)          GDI16((HAND32)(hobj32))

#define HDROP32(hobj16)            (HDROP)DropFilesHandler((HAND16)(hobj16), 0, HDROP_H16 | HDROP_ALLOCALIAS)
#define GETHDROP16(hobj32)         (HAND16)DropFilesHandler(0, (HAND32)(hobj32), HDROP_H32 | HDROP_ALLOCALIAS)
#define FREEHDROP16(hobj16)        (HDROP)DropFilesHandler((HAND16)(hobj16), 0,  HDROP_H16 | HDROP_FREEALIAS)

#define HMODULE32(h16)             ((HANDLE)(h16))     // bogus
#define GETHMODULE16(h32)          ((HAND16)(h32))     // bogus

#define HLOCAL32(h16)              ((HANDLE)(h16))     // bogus
#define GETHLOCAL16(h32)           ((HAND16)(h32))     // bogus

#define HANDLE32(h16)              ((HANDLE)(h16))     // bogus (used in wucomm.c)
#define GETHANDLE16(h32)           ((HAND16)(h32))     // bogus (used in wucomm.c)

#define BOGUSHANDLE32(h16)         ((DWORD)(h16))      // bogus

#define HDWP32(hdwp16)             Prn32((HAND16)(hdwp16))
#define GETHDWP16(hdwp32)          GetPrn16((HAND32)(hdwp32))
#define FREEHDWP16(h16)            FreePrn((HAND16)(h16))

#define COLOR32(clr)               (COLORREF)( ( ((DWORD)(clr) >= 0x03000000) &&  \
                                                 (HIWORD(clr) != 0x10ff) )        \
                                               ? ((clr) & 0xffffff) : (clr) )

/*
 * MultiMedia handle mappings - MikeTri 12-May-1992
 *
 * change WOWCLASS_UNKNOWN to WOWCLASS_WIN16 MikeTri 210292
 */

#define HDRVR32(hdrvr16)           GetMMedia32((HAND16)(hdrvr16))
#define GETHDRVR16(hdrvr32)        GetMMedia16((HAND32)(hdrvr32), WOWCLASS_WIN16)
#define FREEHDRVR16(hdrvr16)       FreeMMedia16((HAND16)(hdrvr16))

#define HMMIO32(hmmio16)           GetMMedia32((HAND16)(hmmio16))
#define GETHMMIO16(hmmio32)        GetMMedia16((HAND32)(hmmio32), WOWCLASS_WIN16)
#define FREEHMMIO16(hmmio16)       FreeMMedia16((HAND16)(hmmio16))

#define HMIDIIN32(hmidiin16)       GetMMedia32((HAND16)(hmidiin16))
#define GETHMIDIIN16(hmidiin32)    GetMMedia16((HAND32)(hmidiin32), WOWCLASS_WIN16)
#define FREEHMIDIIN16(hmidiin16)   FreeMMedia16((HAND16)(hmidiin16))

#define HMIDIOUT32(hmidiout16)     GetMMedia32((HAND16)(hmidiout16))
#define GETHMIDIOUT16(hmidiout32)  GetMMedia16((HAND32)(hmidiout32), WOWCLASS_WIN16)
#define FREEHMIDIOUT16(hmidiout16) FreeMMedia16((HAND16)(hmidiout16))

#define HWAVEIN32(hwavein16)       GetMMedia32((HAND16)(hwavein16))
#define GETHWAVEIN16(hwavein32)    GetMMedia16((HAND32)(hwavein32), WOWCLASS_WIN16)
#define FREEHWAVEIN16(hwavein16)   FreeMMedia16((HAND16)(hwavein16))

#define HWAVEOUT32(hwaveout16)     GetMMedia32((HAND16)(hwaveout16))
#define GETHWAVEOUT16(hwaveout32)  GetMMedia16((HAND32)(hwaveout32), WOWCLASS_WIN16)
#define FREEHWAVEOUT16(hwaveout16) FreeMMedia16((HAND16)(hwaveout16))

/* Function prototypes
 */

INT     GetStdClassNumber(PSZ pszClass);
WNDPROC GetStdClassWndProc(DWORD iClass);
DWORD   GetStdClassThunkProc(INT iClass);

PWC     FindClass16 (LPCSTR pszClass, HINST16 hInst16);
#define FindPWC(h32) (PWC) GetClassLong((h32), GCL_WOWWORDS)
#define FindPWW(h32) (PWW) GetWindowLong((h32), GWL_WOWWORDS)

HAND16  GetMMedia16 (HANDLE h32, INT iClass);  //MultiMedia additions - MikeTri 12-May-1992
HANDLE  GetMMedia32 (HAND16 h16);
VOID    FreeMMedia16 (HAND16 h16);

HAND16  GetWinsock16 (INT h32, INT iClass);  //Winsock additions - DavidTr 4-Oct-1992
DWORD   GetWinsock32 (HAND16 h16);
VOID    FreeWinsock16 (HAND16 h16);

BOOL    MessageNeedsThunking (UINT uMsg);

DWORD   Htask16toThreadID32(HTASK16 htask16);

/* Data structure used in thunking LB_GETTEXT special case
 */

typedef struct _THUNKTEXTDWORD  {
    BOOL               fDWORD;     // dword used or text
    DWORD              dwDataItem; // dword 
} THUNKTEXTDWORD, *PTHUNKTEXTDWORD;

typedef union _MSGTHUNKBUFFER {
    MSG                msg;
    DRAWITEMSTRUCT     ditem;
    MEASUREITEMSTRUCT  mitem;
    DELETEITEMSTRUCT   delitem;
    COMPAREITEMSTRUCT  cmpitem;
    RECT               rect;
    CREATESTRUCT       cstruct;
    WINDOWPOS          winpos;
    CLIENTCREATESTRUCT clcstruct;
    MDINEXTMENU        mnm;
    MDICREATESTRUCT    mdis;
    DROPSTRUCT         dps;
    POINT              pt[5];                               // WM_GETMINMAXINFO
    UINT               uinteger[2];                         // SBM_GETRANGE
    BYTE               cmdichild[sizeof(CREATESTRUCT) +
                                  sizeof(MDICREATESTRUCT)]; // FinishThunking...
    BYTE               cmdiclient[sizeof(CREATESTRUCT) +
                               sizeof(CLIENTCREATESTRUCT)]; // FinishThunking...
    BYTE               calcsz[sizeof(NCCALCSIZE_PARAMS) +
                                        sizeof(WINDOWPOS)];
    THUNKTEXTDWORD     thkdword;                            // LB_GETTEXT w/no HASSTRINGS
} MSGTHUNKBUFFER, *LPMSGTHUNKBUFFER;

typedef struct _MSGPARAMEX *LPMSGPARAMEX;
typedef BOOL   (FASTCALL *LPFNTHUNKMSG16)(LPMSGPARAMEX lpmpex);
typedef VOID   (FASTCALL *LPFNUNTHUNKMSG16)(LPMSGPARAMEX lpmpex);

typedef struct _MSGPARAMEX {
    PARM16 Parm16;
    HWND hwnd;
    UINT uMsg;
    UINT uParam;
    LONG lParam;
    LONG   lReturn;
    LPFNUNTHUNKMSG16 lpfnUnThunk16;
    PWW            pww;
    INT            iMsgThunkClass;          // thunking aid
    INT            iClass;
    MSGTHUNKBUFFER MsgBuffer[1];
} MSGPARAMEX;

#define MSG16NEEDSTHUNKING(lpmpex) ((lpmpex)->iClass != WOWCLASS_NOTHUNK)

// Used for compatibility sake. If app gets The hInstance of a 32bit window
// (the loword of 32bit hinstance is zero) then return a bogus gdt.
//
// Subsequently, if the app does a getmodulefilename on it we will return a
// a fake 32bit modulename.
//
// This is required for a couple of HDC apps and 16bit recorder.
//
//                                                       - Nanduri
//

#define BOGUSGDT 0xfff0
#define VALIDHMOD(h32) (((h32) && !(WORD)(h32)) ? BOGUSGDT : (WORD)(h32))



// For DEVMODE struct handling
// We add a little extra to devmode sizes that we return to 16-bit apps
// including a signature "DM31" at the end of the driver extra stuff
// See notes in wstruc.c

typedef struct _WOWDM31 {
    DWORD dwWOWSig;
    WORD  dmSpecVersion;
    WORD  dmSize;
    WORD  dmDriverExtra;
    WORD  reserved;        // pad to even DWORD (required for ptr arithmetic)
} WOWDM31;
typedef WOWDM31 UNALIGNED *PWOWDM31;

// WOW DEVMODE magic signature
#define WOW_DEVMODE31SIG 0x444d3331   // "DM31"

// Win3.1 DEVMODE spec
#define WOW_DEVMODE31SPEC  0x30A

// Constant we add to Win3.1 DevMode->DriverExtra to account for the NT Devmode
// fields not in the Win3.1 devmode & the WOW thunk info we add to the end
#define WOW_DEVMODEEXTRA  ((sizeof(DEVMODE)-sizeof(DEVMODE31))+sizeof(WOWDM31))



extern WORD gUser16hInstance;
ULONG GetGCL_HMODULE(HWND hwnd);

#define ISFUNCID(dwcallid)  (!((DWORD)(dwcallid) & 0xffff0000))
#define POSTMSG(dwLocal)    (ISFUNCID(dwLocal =  \
                                      FRAMEPTR(CURRENTPTD()->vpStack)->wCallID) ?         \
                                        (aw32WOW[dwLocal].lpfnW32 == WU32PostMessage) :   \
                                        (dwLocal == (DWORD) WU32PostMessage))

ULONG WOW32FaxHandler(UINT iFun, LPSTR lpIn);


INT GetIClass(PWW pww, HWND hwnd);

/*
//
// if it's a standard class (fast method) ? 
//    return it :
// else if the window is initialized ?
//    we know it's a private app class : else get the class the hard way
//
// Note: GetiClassTheHardWay() may stiil return a standard class.  See walias.c
//

#define GETICLASS(pww, hwnd) (                                                 \
(((((PWW)pww)->fnid & 0xfff) >= FNID_START) &&                                 \
                                   ((((PWW)pww)->fnid & 0xfff) <= FNID_END)) ? \
    (pfnOut.aiWowClass[(((PWW)pww)->fnid & 0xfff) - FNID_START]) :             \
((((PWW)pww)->state2 & WINDOW_IS_INITIALIZED) ?                                \
    WOWCLASS_WIN16 : GetiClassTheHardWay(hwnd)) )
*/
#define GETICLASS(pww, hwnd) GetIClass(pww, hwnd)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wcall16.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WCALL16.H
 *  WOW32 16-bit message/callback support
 *
 *  History:
 *  Created 11-Mar-1991 by Jeff Parsons (jeffpar)
 *  Changed 18-Aug-1992 by Mike Tricker (MikeTri) Added DOS PDB and SFT prototypes
--*/


/* Function prototypes
 */
HANDLE  LocalAlloc16(WORD wFlags, INT cb, HANDLE hInstance);
HANDLE  LocalReAlloc16(HANDLE hMem, INT cb, WORD wFlags);
VPVOID  LocalLock16(HANDLE hMem);
BOOL    LocalUnlock16(HANDLE hMem);
WORD    LocalSize16(HANDLE hMem);
HANDLE  LocalFree16(HANDLE hMem);
BOOL    LockSegment16(WORD wSeg);
BOOL    UnlockSegment16(WORD wSeg);
HAND16  GetExePtr16( HAND16 hInstance );
WORD    ChangeSelector16( WORD wSeg );
VPVOID  RealLockResource16( HMEM16 hMem, PINT pcb );
WORD    GetModuleFileName16( HAND16 hInst, VPVOID lpszModuleName, WORD cchModuleName );

BOOL CallBack16(INT iRetID, PPARM16 pParms, VPPROC vpfnProc, PVPVOID pvpReturn);


VPVOID FASTCALL malloc16(UINT cb);
BOOL   FASTCALL free16(VPVOID vp);
VPVOID FASTCALL stackalloc16(UINT cb);

#ifdef DEBUG
VOID   FASTCALL StackFree16(VPVOID vp, UINT cb);
#define stackfree16(vp,cb) StackFree16(vp,cb)
#else
VOID   FASTCALL StackFree16(UINT cb);
#define stackfree16(vp,cb) StackFree16(cb)
#endif

ULONG  GetDosPDB16(VOID);
ULONG  GetDosSFT16(VOID);
int WINAPI WOWlstrcmp16(LPCWSTR lpString1, LPCWSTR lpString2);

/* Function prototypes for 16-bit Global memory functions are now in
 * \nt\public\sdk\inc\winntwow.h with slightly different names.  The
 * old names are supported by the following defines:
 */

#define GlobalAllocLock16  WOWGlobalAllocLock16
#define GlobalLock16       WOWGlobalLockSize16
#define GlobalUnlock16     WOWGlobalUnlock16
#define GlobalUnlockFree16 WOWGlobalUnlockFree16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wcall32.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WCALL32.C
 *  WOW32 16-bit resource support
 *
 *  History:
 *  Created 11-Mar-1991 by Jeff Parsons (jeffpar)
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wcall32.c);

//
// the 16-bit local handles are treated as 32-bit quantities.
// the low word contains the 16-bit handle and the high word
// contains the data segment for the block.
// when we do a callback to WOW16LocalAlloc it will
// return the DS in the high word (which is normally unused).
// on subsequent callbacks to realloc/lock/unlock/size/free
// the 16-bit code sets the DS to this value.
//


HANDLE APIENTRY W32LocalAlloc(UINT dwFlags, UINT dwBytes, HANDLE hInstance)
{

    //
    // If hInstance is not ours, then make Win32 call and return the
    // result to USER.
    //

    if (LOWORD (hInstance) == 0) {
        return (LocalAlloc(dwFlags, dwBytes));
    }


#if !defined(i386)
    if (dwBytes != 0)
        dwBytes += 4;
#endif

    return LocalAlloc16((WORD)dwFlags, (INT)dwBytes, hInstance);
}

// This api takes an extra pointer which is optional
// In case of an edit control reallocating the memory inside apps memory 
// space it is used to update the thunk data (see wparam.c)

HANDLE APIENTRY W32LocalReAlloc(
    HANDLE hMem,        // memory to be reallocated
    UINT dwBytes,       // size to reallocate to
    UINT dwFlags,       // reallocation flags
    HANDLE hInstance,   // Instance to identify ptr
    PVOID* ppv)         // Pointer to the pointer that needs an update
{
    //
    // If hInstance is not ours, then make Win32 call and return the
    // result to USER.
    //

    if (LOWORD (hInstance) == 0) {
        return (LocalReAlloc(hMem, dwBytes, dwFlags));
    }



#if !defined(i386)
    if (dwBytes != 0)
        dwBytes += 4;
#endif

    hMem = LocalReAlloc16(hMem, (INT)dwBytes, (WORD)dwFlags);

    // this code is used in User/Client (edit control) to realloc 
    // memory for text storage
    // update what ppv points to using wparam.c 

    if (NULL != ppv && NULL != *ppv) {
        *ppv = ParamMapUpdateNode((DWORD)*ppv, PARAM_32, NULL);
    }

    return hMem;
}

LPSTR  APIENTRY W32LocalLock(HANDLE hMem, HANDLE hInstance)
{
    VPVOID vp;

    //
    // If hInstance is not ours, then make Win32 call and return the
    // result to USER.
    //

    if (LOWORD (hInstance) == 0) {
        return (LocalLock(hMem));
    }

    if (vp = LocalLock16(hMem)) {
        return (LPSTR)VDMPTR(vp, 0);
    }
    else
        return NULL;
}




BOOL APIENTRY W32LocalUnlock(HANDLE hMem, HANDLE hInstance)
{

    //
    // If hInstance is not ours, then make Win32 call and return the
    // result to USER.
    //

    if (LOWORD (hInstance) == 0) {
        return (LocalUnlock(hMem));
    }


    return LocalUnlock16(hMem);
}


DWORD  APIENTRY W32LocalSize(HANDLE hMem, HANDLE hInstance)
{
    DWORD   dwSize;



    //
    // If hInstance is not ours, then make Win32 call and return the
    // result to USER.
    //

    if (LOWORD (hInstance) == 0) {
        return (LocalSize(hMem));
    }



    dwSize = LocalSize16(hMem);

#if !defined(i386)
    if (dwSize >= 4)
        dwSize -= 4;
#endif

    return dwSize;
}


HANDLE APIENTRY W32LocalFree(HANDLE hMem, HANDLE hInstance)
{

    //
    // If hInstance is not ours, then make Win32 call and return the
    // result to USER.
    //

    if (LOWORD (hInstance) == 0) {
        return (LocalFree(hMem));
    }

    return LocalFree16(hMem);
}

ULONG APIENTRY W32GetExpWinVer(HANDLE hInst)
{
    PARM16 Parm16;
    ULONG ul;

    // makes a direct call to krnl286:GetExpWinVer
    //

    if (LOWORD((DWORD)hInst) == (WORD) NULL) {

        //
        // Window is created by a 32 bit DLL, which is
        // linked to NTVDM process. So, we should not
        // passs it to the 16 bit kernel.
        //

        return (WOWRtlGetExpWinVer(hInst));
    }
    else {
        LPBYTE lpNewExeHdr;
        VPVOID vp = (DWORD)hInst & 0xffff0000;

        GETMISCPTR(vp, lpNewExeHdr);
        if (lpNewExeHdr) {
            ul = MAKELONG(*(PWORD16)&lpNewExeHdr[NE_LOWINVER_OFFSET],
                          (*(PWORD16)&lpNewExeHdr[NE_HIWINVER_OFFSET] &
                                                           FLAG_NE_PROPFONT));
        }
        else {
            Parm16.WndProc.wParam = LOWORD(hInst);
            CallBack16(RET_GETEXPWINVER, &Parm16, 0, &ul );
        }
        return ul;
    }


}


WORD    APIENTRY W32GlobalAlloc16(UINT uFlags, DWORD dwBytes)
{
    return HIWORD(GlobalAllocLock16((WORD)uFlags, dwBytes, NULL));
}


VOID    APIENTRY W32GlobalFree16(WORD selector)
{
    GlobalUnlockFree16(MAKELONG(0, selector));
    return;
}



int     APIENTRY W32EditNextWord (LPSZ lpszEditText, int ichCurrentWord,
                                  int cbEditText, int action, DWORD dwProc16)
{
    PARM16  Parm16;
    ULONG   lReturn = 0;
    PBYTE   lpstr16;
    VPVOID  vpstr16;
    VPVOID  vpfn;

    if (vpstr16 = malloc16 (cbEditText)) {
        GETMISCPTR (vpstr16, lpstr16);
        if (lpstr16) {
            lstrcpy (lpstr16, lpszEditText);

            // take out the marker bits and fix the RPL bits
            UnMarkWOWProc (dwProc16, vpfn);

            Parm16.WordBreakProc.action = GETINT16(action);
            Parm16.WordBreakProc.cbEditText = GETINT16(cbEditText);
            Parm16.WordBreakProc.ichCurrentWord = GETINT16(ichCurrentWord);
            Parm16.WordBreakProc.lpszEditText = vpstr16;

            CallBack16(RET_SETWORDBREAKPROC, &Parm16, vpfn, (PVPVOID)&lReturn);

            FREEMISCPTR (lpstr16);
        }

        free16(vpstr16);
    }

    return (INT32(LOWORD(lReturn)));
}


/***************************************************************************\
* WOWRtlGetExpWinVer
*
* Returns the expected windows version, in the same format as Win3.1's
* GetExpWinVer(). This takes it out of the module header.
*
* 09-9-92 ChandanC       Created.
\***************************************************************************/

DWORD WOWRtlGetExpWinVer(
    HANDLE hmod)
{
    PIMAGE_NT_HEADERS pnthdr;
    DWORD dwMajor = 3;
    DWORD dwMinor = 0xA;

    if (hmod != NULL) {
        try {
            pnthdr = (PIMAGE_NT_HEADERS)RtlImageNtHeader((PVOID)hmod);
            dwMajor = pnthdr->OptionalHeader.MajorSubsystemVersion;
            dwMinor = pnthdr->OptionalHeader.MinorSubsystemVersion;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            dwMajor = 3;        // just to be safe
            dwMinor = 0xA;
        }
    }

// !!! HACK until linker is fixed!!! 05-Aug-1992 Bug #3211
if (((dwMajor == 3) && (dwMinor == 1)) || (dwMajor == 1)) {
    dwMajor = 0x3;
    dwMinor = 0xA;
}
#ifdef FE_SB
    if (GetSystemDefaultLangID() == 0x411 &&
        CURRENTPTD()->dwWOWCompatFlagsFE & WOWCF_FE_BCW45J_COMMDLG &&
        dwMajor >= 4) {
        // When application display win3.x style DialogBox,
        // System requires return value of version 3.10
        dwMajor = 0x3;
        dwMinor = 0xA;
    }
#endif // FE_SB


    /*
     * Return this is a win3.1 compatible format:
     *
     * 0x030A == win3.1
     * 0x0300 == win3.0
     * 0x0200 == win2.0, etc.
     *
     */

    return (DWORD)MAKELONG(MAKEWORD((BYTE)dwMinor, (BYTE)dwMajor), 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wcall16.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WCALL16.C
 *  WOW32 16-bit message/callback support
 *
 *  History:
 *  Created 11-Mar-1991 by Jeff Parsons (jeffpar)
 *  Changed 18-Aug-1992 by Mike Tricker (MikeTri) Added DOS PDB and SFT functions
--*/


#include "precomp.h"
#pragma hdrstop


MODNAME(wcall16.c);

#define WOWFASTEDIT

#ifdef WOWFASTEDIT

typedef struct _LOCALHANDLEENTRY {
    WORD    lhe_address;    // actual address of object
    BYTE    lhe_flags;      // flags and priority level
    BYTE    lhe_count;      // lock count
} LOCALHANDLEENTRY, *PLOCALHANDLEENTRY;

#define LA_MOVEABLE     0x0002      // moveable or fixed?

#define LHE_DISCARDED   0x0040      // Marks objects that have been discarded.

#endif

/* Common callback functions
 */
HANDLE LocalAlloc16(WORD wFlags, INT cb, HANDLE hInstance)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    if (LOWORD(hInstance) == 0 ) {     /* if lo word == 0, then this is a 32-bit
					   hInstance, which makes no sense */
	WOW32ASSERT(LOWORD(hInstance));
        return (HANDLE)0;
    }

    if (cb < 0 || cb > 0xFFFF) {
        WOW32ASSERT(cb > 0 && cb <= 0xFFFF);
        return (HANDLE)0;
    }

    Parm16.WndProc.wMsg = LOWORD(hInstance) | 1;

    Parm16.WndProc.wParam = wFlags;
    Parm16.WndProc.lParam = cb;
    CallBack16(RET_LOCALALLOC, &Parm16, 0, &vp);

    if (LOWORD(vp) == 0)
        vp = 0;

    return (HANDLE)vp;
}


HANDLE LocalReAlloc16(HANDLE hMem, INT cb, WORD wFlags)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    if (HIWORD(hMem) == 0 || cb < 0 || cb > 0xFFFF) {
        WOW32ASSERT(HIWORD(hMem) && cb >= 0 && cb <= 0xFFFF);
        return (HANDLE)0;
    }

    LOGDEBUG(4,("LocalRealloc DS = %x, hMem = %x, bytes = %x, flags = %x\n",HIWORD(hMem),LOWORD(hMem),cb,wFlags));
    Parm16.WndProc.lParam = (LONG)hMem;
    Parm16.WndProc.wParam = wFlags;
    Parm16.WndProc.wMsg = (WORD)cb;
    CallBack16(RET_LOCALREALLOC, &Parm16, 0, &vp);

    if (LOWORD(vp) == 0)
        vp = 0;

    return (HANDLE)vp;
}

#ifndef WOWFASTEDIT

VPVOID LocalLock16(HANDLE hMem)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    if (HIWORD(hMem) == 0) {
        WOW32ASSERT(HIWORD(hMem) != 0);
        return (VPVOID)0;
    }

    Parm16.WndProc.lParam = (LONG)hMem;
    CallBack16(RET_LOCALLOCK, &Parm16, 0, &vp);

    return vp;
}

BOOL LocalUnlock16(HANDLE hMem)
{
    PARM16 Parm16;
    VPVOID vp = FALSE;

    if (HIWORD(hMem) == 0) {
        WOW32ASSERT(HIWORD(hMem));
        return FALSE;
    }

    Parm16.WndProc.lParam = (LONG)hMem;
    CallBack16(RET_LOCALUNLOCK, &Parm16, 0, &vp);

    return (BOOL)vp;
}

#else

VPVOID LocalLock16(HANDLE hMem)
{
    WORD    h16;
    LONG    retval;

    if (HIWORD(hMem) == 0) {
        WOW32ASSERT(HIWORD(hMem) != 0);
        return (VPVOID)0;
    }

    h16 = LOWORD(hMem);
    retval = (VPVOID)hMem;

    if (h16 & LA_MOVEABLE) {
        PLOCALHANDLEENTRY plhe;

        GETVDMPTR(hMem, sizeof(*plhe), plhe);

        if (plhe->lhe_flags & LHE_DISCARDED) {
            goto LOCK1;
        }

        plhe->lhe_count++;
        if (!plhe->lhe_count)
            plhe->lhe_count--;

LOCK1:
        LOW(retval) = plhe->lhe_address;
        FLUSHVDMPTR((ULONG)hMem, sizeof(*plhe), plhe);
        FREEVDMPTR(plhe);
    }

    if (LOWORD(retval) == 0)
        retval = 0;

    return retval;
}

BOOL LocalUnlock16(HANDLE hMem)
{
    WORD    h16;
    BOOL    rc;
    PLOCALHANDLEENTRY plhe;
    BYTE    count;

    if (HIWORD(hMem) == 0) {
        WOW32ASSERT(HIWORD(hMem));
        return FALSE;
    }

    rc = FALSE;
    h16 = LOWORD(hMem);

    if (!(h16 & LA_MOVEABLE)) {
        goto UNLOCK2;
    }

    GETVDMPTR(hMem, sizeof(*plhe), plhe);

    if (plhe->lhe_flags & LHE_DISCARDED)
        goto UNLOCK1;

    count = plhe->lhe_count;
    count--;

    if (count >= (BYTE)(0xff-1))
        goto UNLOCK1;

    plhe->lhe_count = count;
    rc = (BOOL)((SHORT)count);

    FLUSHVDMPTR((ULONG)hMem, sizeof(*plhe), plhe);

UNLOCK1:
    FREEVDMPTR(plhe);

UNLOCK2:
    return rc;
}

#endif  // WOWFASTEDIT


WORD LocalSize16(HANDLE hMem)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    if (HIWORD(hMem) == 0) {
        WOW32ASSERT(HIWORD(hMem));
        return FALSE;
    }

    Parm16.WndProc.lParam = (LONG)hMem;
    CallBack16(RET_LOCALSIZE, &Parm16, 0, &vp);

    return (WORD)vp;
}


HANDLE LocalFree16(HANDLE hMem)
{
    PARM16 Parm16;
    VPVOID vp = FALSE;

    if (HIWORD(hMem) == 0) {
        WOW32ASSERT(HIWORD(hMem));
        return (HANDLE)0;
    }

    Parm16.WndProc.lParam = (LONG)hMem;
    CallBack16(RET_LOCALFREE, &Parm16, 0, &vp);

    if (LOWORD(vp) == 0) {
        vp = 0;
    } else {
        WOW32ASSERT(LOWORD(vp) == LOWORD(hMem));
        vp = (VPVOID)hMem;
    }

    return (HANDLE)vp;
}


BOOL LockSegment16(WORD wSeg)
{
    PARM16 Parm16;
    VPVOID vp = FALSE;

    Parm16.WndProc.wParam = wSeg;
    CallBack16(RET_LOCKSEGMENT, &Parm16, 0, &vp);

    return (BOOL)vp;
}


BOOL UnlockSegment16(WORD wSeg)
{
    PARM16 Parm16;
    VPVOID vp = FALSE;

    Parm16.WndProc.wParam = wSeg;
    CallBack16(RET_UNLOCKSEGMENT, &Parm16, 0, &vp);

    return (BOOL)vp;
}


VPVOID  WOWGlobalAllocLock16(WORD wFlags, DWORD cb, HMEM16 *phMem)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    Parm16.WndProc.wParam = wFlags;
    Parm16.WndProc.lParam = cb;
    CallBack16(RET_GLOBALALLOCLOCK, &Parm16, 0, &vp);

    if (vp) {

        // Get handle of 16-bit object
        if (phMem) {
            *phMem = Parm16.WndProc.wParam;
        }
    }
    return vp;
}


HMEM16 WOWGlobalAlloc16(WORD wFlags, DWORD cb)
{
    HMEM16 hMem;
    VPVOID vp;

    if (vp = WOWGlobalAllocLock16(wFlags, cb, &hMem)) {
        WOWGlobalUnlock16(hMem);
    } else {
        hMem = 0;
    }

    return hMem;
}


VPVOID  WOWGlobalLockSize16(HMEM16 hMem, PDWORD pcb)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    Parm16.WndProc.wParam = hMem;
    CallBack16(RET_GLOBALLOCK, &Parm16, 0, &vp);

    // Get size of 16-bit object    (will be 0 if lock failed)
    if (pcb) {
        *pcb = Parm16.WndProc.lParam;
    }

    return vp;
}


VPVOID WOWGlobalLock16(HMEM16 hMem)
{
    return WOWGlobalLockSize16(hMem, NULL);
}


BOOL WOWGlobalUnlock16(HMEM16 hMem)
{
    PARM16 Parm16;
    VPVOID vp = FALSE;

    Parm16.WndProc.wParam = hMem;
    CallBack16(RET_GLOBALUNLOCK, &Parm16, 0, &vp);

    return (BOOL)vp;
}


HMEM16 WOWGlobalUnlockFree16(VPVOID vpMem)
{
    PARM16 Parm16;
    VPVOID vp = FALSE;

    Parm16.WndProc.lParam = vpMem;
    CallBack16(RET_GLOBALUNLOCKFREE, &Parm16, 0, &vp);

    return (HMEM16)vp;
}


HMEM16 WOWGlobalFree16(HMEM16 hMem)
{
    VPVOID vp;

    if (vp = WOWGlobalLock16(hMem)) {
        hMem = WOWGlobalUnlockFree16(vp);
    } else {
        // On failure we return the passed-in handle,
        // so there's nothing to do.
    }

    return hMem;
}


HAND16 GetExePtr16( HAND16 hInst )
{
    PARM16 Parm16;
    ULONG ul;
    PTD ptd;
    INT i;

    if (hInst == 0) return (HAND16)0;

    //
    // see if this is the hInst for the current task
    //

    ptd = CURRENTPTD();

    if (hInst == ptd->hInst16) {
        return ptd->hMod16;
    }

    //
    // check the cache
    //

    for (i = 0; i < CHMODCACHE; i++) {
        if (ghModCache[i].hInst16 == hInst)
            return ghModCache[i].hMod16;
    }

    /*
    ** Function returns a hModule, given an hInstance
    */
    Parm16.WndProc.wParam = hInst;
    CallBack16(RET_GETEXEPTR, &Parm16, 0, &ul);


    //
    // GetExePtr(hmod) returns hmod, don't cache these.
    //

    if (hInst != (HAND16)LOWORD(ul)) {

        //
        // update the cache
        // slide everybody down 1 entry, put this new guy at the top
        //

        RtlMoveMemory(ghModCache+1, ghModCache, sizeof(HMODCACHE)*(CHMODCACHE-1));
        ghModCache[0].hInst16 = hInst;
        ghModCache[0].hMod16 = (HAND16)LOWORD(ul);
    }

    return (HAND16)LOWORD(ul);
}


WORD GetModuleFileName16( HAND16 hInst, VPVOID lpszModuleName, WORD cchModuleName )
{
    PARM16 Parm16;
    ULONG ul;


    if (hInst == 0) return 0;

    Parm16.WndProc.wParam = hInst;
    Parm16.WndProc.lParam = lpszModuleName;
    Parm16.WndProc.wMsg   = cchModuleName;
    CallBack16(RET_GETMODULEFILENAME, &Parm16, 0, &ul );

    return( LOWORD(ul) );
}


ULONG GetDosPDB16(VOID)
{
    PARM16 Parm16;
    DWORD dwReturn = 0;

    CallBack16(RET_GETDOSPDB, &Parm16, 0, &dwReturn);

    return (ULONG)dwReturn;
}


ULONG GetDosSFT16(VOID)
{
    PARM16 Parm16;
    DWORD dwReturn = 0;

    CallBack16(RET_GETDOSSFT, &Parm16, 0, &dwReturn);

    return (ULONG)dwReturn;
}

// Given a data selector change it into a code selector

WORD ChangeSelector16(WORD wSeg)
{
    PARM16 Parm16;
    VPVOID vp = FALSE;

    Parm16.WndProc.wParam = wSeg;
    CallBack16(RET_CHANGESELECTOR, &Parm16, 0, &vp);

    return LOWORD(vp);
}

VPVOID RealLockResource16(HMEM16 hMem, PINT pcb)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    Parm16.WndProc.wParam = hMem;
    CallBack16(RET_LOCKRESOURCE, &Parm16, 0, &vp);

    // Get size of 16-bit object    (will be 0 if lock failed)
    if (pcb) {
        *pcb = Parm16.WndProc.lParam;
    }

    return vp;
}

int WINAPI WOWlstrcmp16(LPCWSTR lpString1, LPCWSTR lpString2)
{
    PARM16 Parm16;
    DWORD dwReturn = 0;
    DWORD cb1, cb2;
    VPSTR vp1, vp2;
    LPSTR p1, p2;

    //
    // to handle DBCS correctly allocate enough room
    // for two DBCS bytes for every unicode char.
    //

    cb1 = sizeof(WCHAR) * (wcslen(lpString1) + 1);
    cb2 = sizeof(WCHAR) * (wcslen(lpString2) + 1);

    // be sure allocation size matches stackfree16() size below
    vp1 = stackalloc16(cb1 + cb2);
    vp2 = vp1 + cb1;

    p1 = VDMPTR(vp1, cb1);
    p2 = p1 + cb1;

    RtlUnicodeToMultiByteN(
        p1,
        cb1,
        NULL,
        (LPWSTR) lpString1,   // cast because arg isn't declared const
        cb1
        );

    RtlUnicodeToMultiByteN(
        p2,
        cb2,
        NULL,
        (LPWSTR) lpString2,   // cast because arg isn't declared const
        cb2
        );

    FREEVDMPTR(p1);

    Parm16.lstrcmpParms.lpstr1 = vp1;
    Parm16.lstrcmpParms.lpstr2 = vp2;

    CallBack16(RET_LSTRCMP, &Parm16, 0, &dwReturn);

    stackfree16(vp1, (cb1 + cb2));

    return (int)(short int)LOWORD(dwReturn);
}


DWORD WOWCallback16(DWORD vpFn, DWORD dwParam)
{
    PARM16 Parm16;
    VPVOID vp;

    //
    // Copy DWORD parameter to PARM16 structure.
    //

    RtlCopyMemory(&Parm16.WOWCallback16.wArgs, &dwParam, sizeof(dwParam));

    //
    // Use semi-slimy method to pass argument size to CallBack16.
    //

    vp = (VPVOID) sizeof(dwParam);

    CallBack16(RET_WOWCALLBACK16, &Parm16, (VPPROC)vpFn, &vp);

    return (DWORD)vp;
}


BOOL WOWCallback16Ex(
         DWORD vpFn,
         DWORD dwFlags,
         DWORD cbArgs,
         PVOID pArgs,
         PDWORD pdwRetCode
         )
{
#ifdef DEBUG
    static BOOL fFirstTime = TRUE;

    if (fFirstTime) {

        //
        // Ensure that wownt32.h's definition of WCB16_MAX_CBARGS
        // matches wow.h's definition of PARMWCB16.
        //

        WOW32ASSERT( WCB16_MAX_CBARGS == sizeof(PARMWCB16) );

        //
        // If the PARMWCB16 structure is smaller than the PARM16
        // union, we should increase the size of PARMWCB16 and
        // WCB16_MAX_CBARG to allow the use of the extra bytes.
        //

        WOW32ASSERT( sizeof(PARMWCB16) == sizeof(PARM16) );

        fFirstTime = FALSE;
    }
#endif // DEBUG

    if (cbArgs > sizeof(PARM16)) {
        LOGDEBUG(LOG_ALWAYS, ("WOWCallback16V: cbArgs = %u, must be <= %u",
                              cbArgs, (unsigned) sizeof(PARM16)));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // For cdecl functions we don't want to "sub SP, cbArgs" after calling
    // the function, so we pass 0 as cbArgs to the 16-bit side.
    //

    if (dwFlags & WCB16_CDECL) {
        cbArgs = 0;
    }

    //
    // Use semi-slimy method to pass argument size to CallBack16.
    //

    *pdwRetCode = cbArgs;

    CallBack16(RET_WOWCALLBACK16, (PPARM16)pArgs, (VPPROC)vpFn, (PVPVOID)pdwRetCode);

    return TRUE;
}


BOOL CallBack16(INT iRetID, PPARM16 pParm16, VPPROC vpfnProc, PVPVOID pvpReturn)
{
#ifdef DEBUG
    static PSZ apszCallBacks[] = {
    "ERROR:RETURN",         // RET_RETURN       (not a callback!)
    "ERROR:DEBUGRETURN",    // RET_DEBUGRETURN  (not a callback!)
    "DEBUG",                // RET_DEBUG
    "WNDPROC",              // RET_WNDPROC
    "ENUMFONTPROC",         // RET_ENUMFONTPROC
    "ENUMWINDOWPROC",       // RET_ENUMWINDOWPROC
    "LOCALALLOC",           // RET_LOCALALLOC
    "LOCALREALLOC",         // RET_LOCALREALLOC
    "LOCALLOCK",            // RET_LOCALLOCK
    "LOCALUNLOCK",          // RET_LOCALUNLOCK
    "LOCALSIZE",            // RET_LOCALSIZE
    "LOCALFREE",            // RET_LOCALFREE
    "GLOBALALLOCLOCK",      // RET_GLOBALALLOCLOCK
    "GLOBALLOCK",           // RET_GLOBALLOCK
    "GLOBALUNLOCK",         // RET_GLOBALUNLOCK
    "GLOBALUNLOCKFREE",     // RET_GLOBALUNLOCKFREE
    "FINDRESOURCE",         // RET_FINDRESOURCE
    "LOADRESOURCE",         // RET_LOADRESOURCE
    "FREERESOURCE",         // RET_FREERESOURCE
    "LOCKRESOURCE",         // RET_LOCKRESOURCE
    "UNLOCKRESOURCE",       // RET_UNLOCKRESOURCE
    "SIZEOFRESOURCE",       // RET_SIZEOFRESOURCE
    "LOCKSEGMENT",          // RET_LOCKSEGMENT
    "UNLOCKSEGMENT",        // RET_UNLOCKSEGMENT
    "ENUMMETAFILEPROC",     // RET_ENUMMETAFILEPROC
    "TASKSTARTED    ",      // RET_TASKSTARTED
    "HOOKPROC",             // RET_HOOKPROC
    "SUBCLASSPROC",         // RET_SUBCLASSPROC
    "LINEDDAPROC",          // RET_LINEDDAPROC
    "GRAYSTRINGPROC",       // RET_GRAYSTRINGPROC
    "FORCETASKEXIT",        // RET_FORCETASKEXIT
    "SETCURDIR",            // RET_SETCURDIR
    "ENUMOBJPROC",          // RET_ENUMOBJPROC
    "SETCURSORICONFLAG",    // RET_SETCURSORICONFLAG
    "SETABORTPROC",         // RET_SETABORTPROC
    "ENUMPROPSPROC",        // RET_ENUMPROPSPROC
    "FORCESEGMENTFAULT",    // RET_FORCESEGMENTFAULT
    "LSTRCMP",              // RET_LSTRCMP
    "UNUSEDFUNC",           // 
    "UNUSEDFUNC",           // 
    "UNUSEDFUNC",           // 
    "UNUSEDFUNC",           // 
    "GETEXEPTR",            // RET_GETEXEPTR
    "UNUSEDFUNC",           // 
    "FORCETASKFAULT",       // RET_FORCETASKFAULT
    "GETEXPWINVER",         // RET_GETEXPWINVER
    "GETCURDIR",            // RET_GETCURDIR
    "GETDOSPDB",            // RET_GETDOSPDB
    "GETDOSSFT",            // RET_GETDOSSFT
    "FOREGROUNDIDLE",       // RET_FOREGROUNDIDLE
    "WINSOCKBLOCKHOOK",     // RET_WINSOCKBLOCKHOOK
    "WOWDDEFREEHANDLE",     // RET_WOWDDEFREEHANDLE
    "CHANGESELECTOR",       // RET_CHANGESELECTOR
    "GETMODULEFILENAME",    // RET_GETMODULEFILENAME
    "WORDBREAKPROC",        // RET_WORDBREAKPROC
    "WINEXEC",              // RET_WINEXEC
    "WOWCALLBACK16",        // RET_WOWCALLBACK16
    "GETDIBSIZE",           // RET_GETDIBSIZE
    "GETDIBFLAGS",          // RET_GETDIBFLAGS
    "SETDIBSEL",            // RET_SETDIBSEL
    "FREEDIBSEL",           // RET_FREEDIBSEL
    };
#endif
    register PTD ptd;
    register PVDMFRAME pFrame;
    register PCBVDMFRAME pCBFrame;
    WORD wAX;
    BOOL fComDlgSync = FALSE;
    INT  cStackAlloc16;
    VPVOID   vpCBStack;  // See NOTES in walloc16.c\stackalloc16()

#if FASTBOPPING
#else
    USHORT SaveIp;
#endif
#ifdef DEBUG
    VPVOID   vpStackT;
#endif

    WOW32ASSERT(iRetID != RET_RETURN && iRetID != RET_DEBUGRETURN);

    ptd = CURRENTPTD();

    // ssync 16-bit & 32-bit common dialog structs (see wcommdlg.c)
    if(ptd->CommDlgTd) {

        // only ssync for stuff that might actually callback into the app
        // ie. we don't need to ssync every time wow32 calls GlobalLock16
        switch(iRetID) {
            case RET_WNDPROC:           // try to get these in a most frequently
            case RET_HOOKPROC:          // used order
            case RET_WINSOCKBLOCKHOOK:
            case RET_ENUMFONTPROC:
            case RET_ENUMWINDOWPROC:
            case RET_ENUMOBJPROC:
            case RET_ENUMPROPSPROC:
            case RET_LINEDDAPROC:
            case RET_GRAYSTRINGPROC:
            case RET_SETWORDBREAKPROC:
            case RET_SETABORTPROC:
                // Note: This call can invalidate flat ptrs to 16-bit mem
                Ssync_WOW_CommDlg_Structs(ptd->CommDlgTd, w32to16, 0);
                fComDlgSync = TRUE;   // set this for return ssync
                break;
            default:
                break;
        }
    }

    GETFRAMEPTR(ptd->vpStack, pFrame);

    // Just making sure that this thread matches the current 16-bit task

    WOW32ASSERT((pFrame->wTDB == ptd->htask16) ||
                (ptd->dwFlags & TDF_IGNOREINPUT) ||
                (ptd->htask16 == 0));


    // set up the callback stack frame from the correct location
    // & make it word aligned.
    // if stackalloc16() hasn't been called since the app called into wow32
    if (ptd->cStackAlloc16 == 0) {
        vpCBStack = ptd->vpStack;
        ptd->vpCBStack = (ptd->vpStack - sizeof(CBVDMFRAME)) & (~0x1);
    }
    else {
        vpCBStack = ptd->vpCBStack;
        ptd->vpCBStack = (ptd->vpCBStack - sizeof(CBVDMFRAME)) & (~0x1);
    }

    GETFRAMEPTR(ptd->vpCBStack, (PVDMFRAME)pCBFrame);
    pCBFrame->vpStack    = ptd->vpStack;
    pCBFrame->wRetID     = (WORD)iRetID;
    pCBFrame->wTDB       = pFrame->wTDB;
    pCBFrame->wLocalBP   = pFrame->wLocalBP;

    // save the current context stackalloc16() count and set the count to
    // 0 for the next context.  This will force ptd->vpCBStack to be calc'd
    // correctly in any future calls to stackalloc16() if the app callsback
    // into WOW
    cStackAlloc16      = ptd->cStackAlloc16;
    ptd->cStackAlloc16 = 0;

#ifdef DEBUG
    // Save

    vpStackT = ptd->vpStack;
#endif

    if (pParm16)
        RtlCopyMemory(&pCBFrame->Parm16, pParm16, sizeof(PARM16));

    //if (vpfnProc)     // cheaper to just do it
        STOREDWORD(pCBFrame->vpfnProc, vpfnProc);

    wAX = HIWORD(ptd->vpStack);         // Put SS in AX register for callback

    if ( iRetID == RET_WNDPROC ) {
        if ( pParm16->WndProc.hInst )
            wAX = pParm16->WndProc.hInst | 1;
    }

    pCBFrame->wAX = wAX;                // Use this AX for the callback

    //
    // Semi-slimy way we pass byte count of arguments into this function
    // for generic callbacks (WOWCallback16).
    //

    if (RET_WOWCALLBACK16 == iRetID) {
        pCBFrame->wGenUse1 = (WORD)(DWORD)*pvpReturn;
    }

#ifdef DEBUG
    if (iRetID == RET_WNDPROC) {
        LOGDEBUG(9,("%04X          Calling WIN16 WNDPROC(%08lx:%04x,%04x,%04x,%04x,%04x)\n",
            pFrame->wTDB,
            vpfnProc,
            pParm16->WndProc.hwnd,
            pParm16->WndProc.wMsg,
            pParm16->WndProc.wParam,
            HIWORD(pParm16->WndProc.lParam),
            LOWORD(pParm16->WndProc.lParam)
           )
        );

    } else if (iRetID == RET_HOOKPROC) {
        LOGDEBUG(9,("%04X         Calling WIN16 HOOKPROC(%08lx: %04x,%04x,%04x,%04x)\n",
            pFrame->wTDB,
            vpfnProc,
            pParm16->HookProc.nCode,
            pParm16->HookProc.wParam,
            HIWORD(pParm16->HookProc.lParam),
            LOWORD(pParm16->HookProc.lParam)
            )
        );


    } else {
        LOGDEBUG(9,("%04X         Calling WIN16 %s(%04x,%04x,%04x)\n",
            pFrame->wTDB,
            apszCallBacks[iRetID],
            pParm16->WndProc.wParam,
            HIWORD(pParm16->WndProc.lParam),
            LOWORD(pParm16->WndProc.lParam)
           )
        );
    }
#endif

    FREEVDMPTR(pFrame);
    FLUSHVDMPTR(ptd->vpCBStack, sizeof(CBVDMFRAME), pCBFrame);
    FREEVDMPTR(pCBFrame);

    // Set up to use the right 16-bit stack for this thread

#if FASTBOPPING
    SETFASTVDMSTACK(ptd->vpCBStack);
#else
    SETVDMSTACK(ptd->vpCBStack);
#endif

    //
    // do the callback!
    //

#if FASTBOPPING
    CurrentMonitorTeb = NtCurrentTeb();
    FastWOWCallbackCall();
    // fastbop code refreshes ptd->vpStack
#else
    // Time to get the IEU running task-time code again
    SaveIp = getIP();
    host_simulate();
    setIP(SaveIp);
    ptd->vpStack = VDMSTACK();
#endif

    // after return from callback ptd->vpStack will point to PCBVDMFRAME
    ptd->vpCBStack = ptd->vpStack;

    // reset the stackalloc16() count back to this context
    ptd->cStackAlloc16 = cStackAlloc16;

    GETFRAMEPTR(ptd->vpCBStack, (PVDMFRAME)pCBFrame);

    // Just making sure that this thread matches the current 16-bit task

    WOW32ASSERT((pCBFrame->wTDB == ptd->htask16) ||
        (ptd->htask16 == 0));

    if (pvpReturn) {
        LOW(*pvpReturn) = pCBFrame->wAX;
        HIW(*pvpReturn) = pCBFrame->wDX;
    } 

    switch(iRetID) {

        case RET_GLOBALLOCK: 
        case RET_LOCKRESOURCE:
            if(pParm16) {
                pParm16->WndProc.lParam = 
                            pCBFrame->wGenUse2 | (LONG)pCBFrame->wGenUse1 << 16;
            }
            break;

        case RET_GLOBALALLOCLOCK:
            if(pParm16) {
                    pParm16->WndProc.wParam = pCBFrame->wGenUse1;
                }
            break;

        case RET_FINDRESOURCE:
            if(pParm16) {
                pParm16->WndProc.lParam = (ULONG)pCBFrame->wGenUse1;
            }
            break;

    } // end switch

    LOGDEBUG(9,("%04X          WIN16 %s returning: %lx\n",
        pCBFrame->wTDB, apszCallBacks[iRetID], (pvpReturn) ? *pvpReturn : 0));

    // restore the stack to its original value.
    // ie. fake the 'pop' of callback stack by resetting the vpStack
    // to its original value. The ss:sp will actually be updated when
    // the 'api thunk' returns.

    // consistency check
    WOW32ASSERT(pCBFrame->vpStack == vpStackT);

    // restore the stack & callback frame ptrs to original values
    ptd->vpStack = pCBFrame->vpStack;
    ptd->vpCBStack = vpCBStack;

    // ssync 16-bit & 32-bit common dialog structs (see wcommdlg.c)
    if(fComDlgSync) {
        // Note: This call can invalidate flat ptrs to 16-bit mem
        Ssync_WOW_CommDlg_Structs(ptd->CommDlgTd, w16to32, 0);
    }

    FREEVDMPTR(pCBFrame);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\walloc16.c ===
//*****************************************************************************
//
// MESSAGE HEAP 16 -
//
//     Heap allocation functions for 32-16 message thunks.
//
//     NOTE: these are NOT general purpose heap managment routines.
//
//
// 07-17-92  NanduriR   Created.
//
//*****************************************************************************

#include "precomp.h"
#pragma hdrstop

MODNAME(walloc16.c);

//*****************************************************************************
// General Notes:
//
// This heap maanger is for specific 'performance gains' and is thus not
// intended for general purpose use and therfore much of the overhead has
// been eliminated.
//
// This heap manager is intended mainly for thunks - where we are sure that
// an alloced block will definitely be freed. Thus it is meant for our use.
//
// The heap is conceptually an array  of constant-size blocks. The size of the
// block is predefined. The code is optimized for allocation requests of one
// blocksize or less. It is slower if the allocation request needs more than
// one block.
//
// The heap header is a static array. The header has two flags. One to note
// that a particular heapblock is in use and the other to note whether the
// block forms a part of a linked/chained set of contiguous blocks. The blocks
// are linked when the allocation request is for more than the predefined
// block size.
//
//*****************************************************************************


#define HEAP16_TOTALSIZE  0x2000
#define HEAP16_BLOCKSIZE  0x100    // We should set it to an optimum value
#define HEAP16_BLOCKCOUNT (HEAP16_TOTALSIZE/HEAP16_BLOCKSIZE)

#define HHDR16_FINUSE     0x01
#define HHDR16_FLINKED    0x02

#define ISBLOCKINUSE(block)    ((block) & HHDR16_FINUSE)
#define ISBLOCKLINKED(block) ((block) & HHDR16_FLINKED)


//*****************************************************************************
//
// Globals -
//
// vahdr - is the heap header. This header is 32bit memory and not part of the
//         16bit heap - this is so that the 16bit heap is put to maximum use.
//
// vpHeap16 - far pointer to the start of 16bit heap
//
// viFreeIndex - the index from which we start searching for a freeblock.
//               Normally this is set to the memoryblock that was most
//               recently freed, thus increasing the chances of finding
//               a freeblock instantly.
//*****************************************************************************

BYTE    vahdr[HEAP16_BLOCKCOUNT];
LPBYTE  vpHeap16 = (LPBYTE)NULL;
UINT    viFreeIndex = 0;            // First look for Free block here.



//*****************************************************************************
//
// malloc16 -
//
//      Allocs memory from 16bit block.
//      If heap is full, does normal GlobalAlloc
//
//      Returns farpointer to memoryblock;
//
//*****************************************************************************

VPVOID FASTCALL malloc16(UINT cb)
{
    INT i, j;
    INT cBlocksRequired;
    INT fContiguousFreeBlocks;
    INT vpT;

    if (vpHeap16 == (LPBYTE)NULL) {
        vpHeap16 = (LPBYTE)GlobalAllocLock16(GMEM_MOVEABLE | GMEM_SHARE, HEAP16_TOTALSIZE,
                                                                         NULL);
        if (vpHeap16 != NULL) {

            //
            // Initialize heap header.
            // LATER: is this necessary?. Heaphdr is a static array so
            //        is it already intialized to ZERO?
            //

            for(i = 0; i < HEAP16_BLOCKCOUNT ; i++) {
                vahdr[i] = 0;
            }

        }

    }

    if (vpHeap16 != (LPBYTE)NULL) {
        if (cb <= HEAP16_BLOCKSIZE && !ISBLOCKINUSE(vahdr[viFreeIndex])) {

            //
            // If 'single' block and the 'current' index is free.
            //

            vahdr[viFreeIndex] = HHDR16_FINUSE;
            i = viFreeIndex++;
            if (viFreeIndex == HEAP16_BLOCKCOUNT)
                viFreeIndex = 0;
            return (VPVOID)((LPBYTE)vpHeap16 + i * HEAP16_BLOCKSIZE);
        }
        else {

            //
            // if the 'current' index is not free or if 'multiple' blocks
            //

            cBlocksRequired = (cb / HEAP16_BLOCKSIZE) + 1;
            for (i = 0; i < HEAP16_BLOCKCOUNT ; i++ ) {
                 if ((viFreeIndex + i + cBlocksRequired) <=
                                                          HEAP16_BLOCKCOUNT) {
                     fContiguousFreeBlocks = TRUE;
                     for (j = 0; j < cBlocksRequired; j++) {
                         if (ISBLOCKINUSE(vahdr[viFreeIndex + i + j])) {
                             fContiguousFreeBlocks = FALSE;
                             i += j;
                             break;
                         }
                     }

                     if (fContiguousFreeBlocks) {
                         for (j = 0; j < (cBlocksRequired - 1); j++) {
                              vahdr[viFreeIndex + i + j] =
                                             (HHDR16_FINUSE |  HHDR16_FLINKED);
                         }
                         vahdr[viFreeIndex + i + j] = HHDR16_FINUSE;

                         i += viFreeIndex;
                         viFreeIndex = i + cBlocksRequired;
                         if (viFreeIndex == HEAP16_BLOCKCOUNT)
                             viFreeIndex = 0;
                         return (VPVOID)((LPBYTE)vpHeap16 + i * HEAP16_BLOCKSIZE);
                     }
                 }
                 else {

                     //
                     // Outside the heaphdr range. Reset viFreeIndex, so that
                     // we search from the start of heaphdr.
                     //

                     viFreeIndex = -(i+1);
                 }
            }
            viFreeIndex = 0;
        }

    }

    //
    // Here - if allocation from heap failed
    //

    vpT = (VPVOID)GlobalAllocLock16(GMEM_MOVEABLE, cb, NULL);
    if (vpT) {
        return vpT;
    }
    else {
        LOGDEBUG(0,("malloc16: failed\n"));
        return (VPVOID)NULL;
    }
}



//*****************************************************************************
//
// free16 -
//
//      frees 16bit memory block.
//      If the block is not part of the 16bit heap, does GlobalFree.
//
//      Returns TRUE;
//
//*****************************************************************************

BOOL FASTCALL free16(VPVOID vp)
{
    INT iStartIndex;
    BOOL fLinked;

    iStartIndex = ((LPBYTE)vp - (LPBYTE)vpHeap16) / HEAP16_BLOCKSIZE;

    //
    // Invalid iStartIndex implies that the block was GlobalAlloced
    //

    if (iStartIndex >= 0 && iStartIndex < HEAP16_BLOCKCOUNT) {

        //
        // If   'single'   block: get out fast
        // else 'multiple' block: loop for all the blocks
        //

        viFreeIndex = iStartIndex;
        if (!ISBLOCKLINKED(vahdr[iStartIndex])) {
            WOW32ASSERT(ISBLOCKINUSE(vahdr[iStartIndex]));
            vahdr[iStartIndex] = 0;
        }
        else {
            while (ISBLOCKINUSE(vahdr[iStartIndex])) {
                fLinked = ISBLOCKLINKED(vahdr[iStartIndex]);
                vahdr[iStartIndex] = 0;
                if (fLinked)
                    iStartIndex++;
                else
                    break;
            }
        }
    }
    else {
        WOW32ASSERT(LOWORD(vp)==0);  // GlobalAlloced pointers have offset = 0
        GlobalUnlockFree16(vp);
    }
    return (BOOL)TRUE;
}


//*****************************************************************************
//
// stackalloc16 -
//
//      Allocs memory from current task's 16bit stack.
//      Returns farpointer to memoryblock;
//
// NOTES!!!!!:
// - This is not intended to be a full blown memory manager. It is intended to 
//   replace the TDF_INITCALLBACKSTACKFLAG to avoid problems with ptd->vpCBStack
//   getting hosed by multiple stackalloc16 calls. (See bug #393267 et al)
// - All calls to stackalloc16() and stackfree16() must be properly nested.
//   If you can't assure that your usage is properly nested, you'd better use
//   GlobalAllocLock16() & GlobalUnlockFree16() instead.
//   Beware individual message thunks may have calls to stackalloc16() that
//   aren't readily apparent.
// - The request size passed to stackfree16() needs to be the same as the size
//   of the corresponding stackalloc16() call.
// - Run your changes involving stackalloc16() under debug WOW32.DLL.  The
//   built-in sanity checking will help you catch any gotcha's
// - ptd->vpCBStack *SHOULD NOT* be referenced or used outside of stackalloc16()
//   stackfree16(), and callback16().
// - If this mechanism gets out of whack, chances are the symptom will be
//   a 16-bit stack fault message.
//*****************************************************************************
VPVOID FASTCALL stackalloc16(UINT cb)
{
#ifdef DEBUG
    VPVOID   vp;
    DWORD   *psig, cb16;
#endif
    register PTD ptd;


    // get current task's 16bit stack
    ptd = CURRENTPTD();

#ifdef DEBUG
    // Save requested allocation size. Assume it will always be less than 64K
    cb16 = (DWORD)cb;      

    // Add a dword (for signature) to the requested size
    cb += sizeof(DWORD);   

    // Get the current callback sp
    if (ptd->cStackAlloc16 == 0) {
        vp = ptd->vpStack;
    } else {
        vp = ptd->vpCBStack;
    }
#endif

    // grow ss:sp and return this imaginary pointer.
    if (ptd->cStackAlloc16 == 0) {
        ptd->vpCBStack = ptd->vpStack - cb;
    }
    else {
        ptd->vpCBStack -= cb;
    }

#ifdef DEBUG
        // Slide our DWORD signature in after the allocated request
        vp -= sizeof(DWORD);
        GETVDMPTR(vp, sizeof(DWORD), psig);

        // The signature hiword is the offset (sp) we're returning.
        // The signature loword is the requested size.
        *psig = ((ptd->vpCBStack & 0x0000FFFF) << 16) | cb16;
        FLUSHVDMPTR(vp, sizeof(DWORD), psig);
        FREEVDMPTR(psig);
#endif

    ptd->cStackAlloc16++;
    WOW32ASSERT((ptd->cStackAlloc16 >= 1));

    return (VPVOID)ptd->vpCBStack;
}





//*****************************************************************************
//
// StackFree16 -
//
//  Decrements count of memory alloc'd by stackalloc16 
//
//  NOTES:  
//  - This is #define'd as stackfree16(vp,cb) StackFree16(cb) in free builds
//    and stackfree16(vp,cb) StackFree16(vp, cb) in DEBUG builds (wcall16.h)
//  - See stackalloc16() NOTES above
//
//*****************************************************************************
#ifdef DEBUG
VOID FASTCALL StackFree16(VPVOID vp, UINT cb)
#else
VOID FASTCALL StackFree16(UINT cb)
#endif
{
    register PTD ptd;
#ifdef DEBUG
    DWORD  *psig, sig;

    // reconstruct what our signature should be 
    sig = ((vp & 0x0000FFFFF) << 16) | cb;
#endif

    ptd = CURRENTPTD();

    ptd->vpCBStack += cb;

#ifdef DEBUG
    // vpCBStack should now be pointing at our signature.
    GETVDMPTR(ptd->vpCBStack, sizeof(DWORD), psig);

    // you are hitting this assertion for one of the following reasons:
    //  - calls to stackalloc16() & stackfree16() are not properly nested
    //  - the signature got overwritten
    //  - somebody changed ptd->vpCBStack incorrectly
    WOW32ASSERTMSG((*psig == sig), ("WOW::StackFree16 out of synch!!\n"));

    // adjust for the signature DWORD we added to the request
    ptd->vpCBStack += sizeof(DWORD);
#endif

    if(ptd->cStackAlloc16 > 0) {
        ptd->cStackAlloc16--;
    } else { 
        WOW32ASSERTMSG((FALSE), ("WOW::StackFree16:cStackAlloc16 <= 0!\n"));
        ptd->cStackAlloc16 = 0;  // if it was less than 0 somehow
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wcmdgtbl.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1993, Microsoft Corporation
 *
 *  WCMDGTBL.h
 *  WOW32 16-bit Commdlg tables
 *
 *  History:
 *      John Vert (jvert) 31-Dec-1992 - created
 *
 *  This file is included into the master thunk table.
 *
--*/

    {W32FUN(UNIMPLEMENTEDAPI,              "DUMMYENTRY",           MOD_COMMDLG,    0)},
    {W32FUN(WCD32GetOpenFileName,          "GETOPENFILENAME",      MOD_COMMDLG,    sizeof(GETOPENFILENAME16))},
    {W32FUN(WCD32GetSaveFileName,          "GETSAVEFILENAME",      MOD_COMMDLG,    sizeof(GETSAVEFILENAME16))},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(WCD32ChooseColor,              "CHOOSECOLOR",          MOD_COMMDLG,    sizeof(CHOOSECOLOR16))},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},

  /*** 0010 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(WCD32FindText,                 "FINDTEXT",             MOD_COMMDLG,    sizeof(FINDREPLACE16))},
    {W32FUN(WCD32ReplaceText,              "REPLACETEXT",          MOD_COMMDLG,    sizeof(FINDREPLACE16))},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(WCD32ChooseFont,               "CHOOSEFONT",           MOD_COMMDLG,    sizeof(CHOOSEFONT16))},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},

  /*** 0020 ***/
    {W32FUN(WCD32PrintDlg,                 "PRINTDLG",             MOD_COMMDLG,    sizeof(PRINTDLG16))},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_COMMDLG,    0)},
    {W32FUN(WCD32ExtendedError,            "COMMDLGEXTENDEDERROR", MOD_COMMDLG,    0)},

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wcall32.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WCALL32.H
 *  WOW32 16-bit resource support
 *
 *  History:
 *  Created 11-Mar-1991 by Jeff Parsons (jeffpar)
--*/


/* Function prototypes
 */
HANDLE  APIENTRY W32LocalAlloc(UINT dwFlags, UINT dwBytes, HANDLE hInstance);
HANDLE	APIENTRY W32LocalReAlloc(HANDLE hMem, UINT dwBytes, UINT dwFlags, HANDLE hInstance, PVOID* ppv);
LPSTR	APIENTRY W32LocalLock(HANDLE hMem, HANDLE hInstance);
BOOL	APIENTRY W32LocalUnlock(HANDLE hMem, HANDLE hInstance);
DWORD	APIENTRY W32LocalSize(HANDLE hMem, HANDLE hInstance);
HANDLE	APIENTRY W32LocalFree(HANDLE hMem, HANDLE hInstance);
ULONG   APIENTRY W32GetExpWinVer(HANDLE Inst);
DWORD   APIENTRY W32InitDlg(HWND hDlg, LONG lParam);
WORD    APIENTRY W32GlobalAlloc16(UINT uFlags, DWORD dwBytes);
VOID	APIENTRY W32GlobalFree16(WORD selector);
DWORD	WOWRtlGetExpWinVer(HANDLE hmod);
int     APIENTRY W32EditNextWord (LPSZ lpszEditText, int ichCurrentWord,
                                  int cbEditText, int action, DWORD dwProc16);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wcntl32.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WCNTL32.H
 *  WOW32 32-bit message thunks
 *
 *  History:
 *  Created 19-Feb-1992 by ChandanC (ChandanC)
--*/


LPFNM32PROTO WM32BMControl;
LPFNM32PROTO WM32BMClick;
LPFNM32PROTO WM32EMControl;
LPFNM32PROTO WM32EMSetSel;
LPFNM32PROTO WM32EMGetRect;
LPFNM32PROTO WM32EMSetRect;
LPFNM32PROTO WM32EMSetRectNP;
LPFNM32PROTO WM32EMScroll;
LPFNM32PROTO WM32EMLineScroll;
LPFNM32PROTO WM32EMSetHandle;
LPFNM32PROTO WM32EMGetHandle;
LPFNM32PROTO WM32EMGetThumb;
LPFNM32PROTO WM32EMReplaceSel;
LPFNM32PROTO WM32EMSetFont;
LPFNM32PROTO WM32EMGetLine;
LPFNM32PROTO WM32EMSetWordBreak;
LPFNM32PROTO WM32EMSetWordBreakProc;
LPFNM32PROTO WM32EMGetWordBreakProc;
LPFNM32PROTO WM32EMSetTabStops;
LPFNM32PROTO WM32CBControl;
LPFNM32PROTO WM32CBAddString;
LPFNM32PROTO WM32CBDir;
LPFNM32PROTO WM32CBGetLBText;
LPFNM32PROTO WM32CBResetContent;
LPFNM32PROTO WM32CBGetDropDownControlRect;
LPFNM32PROTO WM32CBComboFocus;
LPFNM32PROTO WM32LBControl;
LPFNM32PROTO WM32LBGetText;
LPFNM32PROTO WM32LBGetTextLen;
LPFNM32PROTO WM32LBDir;
LPFNM32PROTO WM32LBGetSelItems;
LPFNM32PROTO WM32LBSetTabStops;
LPFNM32PROTO WM32LBGetItemRect;
LPFNM32PROTO WM32LBAddString;
LPFNM32PROTO WM32SBMControl;
LPFNM32PROTO WM32SBMGetRange;
LPFNM32PROTO WM32SBMSetRange;
LPFNM32PROTO WM32LBSetSel;
LPFNM32PROTO WM32STMControl;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wcommdlg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    wcomdlg.c

Abstract:

    32-bit support for thunking COMMDLG in WOW

Author:

    John Vert (jvert) 31-Dec-1992

Revision History:

    John Vert (jvert) 31-Dec-1992
        created

--*/
#include "precomp.h"
#pragma   hdrstop
#include <cderr.h>
#include <dlgs.h>
#include <wowcmndg.h>

MODNAME(wcommdlg.c);

//
// Debugging stuff...
//
#if DEBUG
void WCDDumpCHOOSECOLORData16(PCHOOSECOLORDATA16 p16);
void WCDDumpCHOOSECOLORData32(CHOOSECOLOR *p32);
void WCDDumpCHOOSEFONTData16(PCHOOSEFONTDATA16 p16);
void WCDDumpCHOOSEFONTData32(CHOOSEFONT *p32);
void WCDDumpFINDREPLACE16(PFINDREPLACE16 p16);
void WCDDumpFINDREPLACE32(FINDREPLACE *p32);
void WCDDumpOPENFILENAME16(POPENFILENAME16 p16);
void WCDDumpOPENFILENAME32(OPENFILENAME *p32);
void WCDDumpPRINTDLGData16(PPRINTDLGDATA16 p16);
void WCDDumpPRINTDLGData32(PRINTDLG *p32);

// macros to dump the 16 & 32 bit structs
#define WCDDUMPCHOOSECOLORDATA16(p16)  WCDDumpCHOOSECOLORData16(p16)

#define WCDDUMPCHOOSECOLORDATA32(p32)  WCDDumpCHOOSECOLORData32(p32)

#define WCDDUMPCHOOSEFONTDATA16(p16)   WCDDumpCHOOSEFONTData16(p16)

#define WCDDUMPCHOOSEFONTDATA32(p32)   WCDDumpCHOOSEFONTData32(p32)

#define WCDDUMPFINDREPLACE16(p16)      WCDDumpFINDREPLACE16(p16)

#define WCDDUMPFINDREPLACE32(p32)      WCDDumpFINDREPLACE32(p32)

#define WCDDUMPOPENFILENAME16(p16)     WCDDumpOPENFILENAME16(p16)

#define WCDDUMPOPENFILENAME32(p32)     WCDDumpOPENFILENAME32(p32)

#define WCDDUMPPRINTDLGDATA16(p16)     WCDDumpPRINTDLGData16(p16)

#define WCDDUMPPRINTDLGDATA32(p32)     WCDDumpPRINTDLGData32(p32)

#else // !DEBUG

#define WCDDUMPCHOOSECOLORDATA16(p16)
#define WCDDUMPCHOOSECOLORDATA32(p32)
#define WCDDUMPCHOOSEFONTDATA16(p16)
#define WCDDUMPCHOOSEFONTDATA32(p32)
#define WCDDUMPOPENFILENAME16(p16)
#define WCDDUMPOPENFILENAME32(p32)
#define WCDDUMPPRINTDLGDATA16(p16)
#define WCDDUMPPRINTDLGDATA32(p32)
#define WCDDUMPFINDREPLACE16(p16)
#define WCDDUMPFINDREPLACE32(p32)

#endif  // !DEBUG




// global data
WORD msgCOLOROK        = 0;
WORD msgFILEOK         = 0;
WORD msgWOWLFCHANGE    = 0;
WORD msgWOWDIRCHANGE   = 0;
WORD msgWOWCHOOSEFONT  = 0;
WORD msgSHAREVIOLATION = 0;
WORD msgFINDREPLACE    = 0;

/* external global stuff */
extern WORD gwKrnl386CodeSeg1;
extern WORD gwKrnl386CodeSeg2;
extern WORD gwKrnl386CodeSeg3;
extern WORD gwKrnl386DataSeg1;


ULONG dwExtError = 0;
#define SETEXTENDEDERROR(Code) (dwExtError=Code)

/*+++ For reference only -- which flags are set on output
#define FR_OUTPUTFLAGS (FR_DOWN          | FR_WHOLEWORD     | FR_MATCHCASE  | \
                        FR_FINDNEXT      | FR_REPLACE       | FR_REPLACEALL | \
                        FR_DIALOGTERM    | FR_SHOWHELP      | FR_NOUPDOWN   | \
                        FR_NOMATCHCASE   | FR_NOWHOLEWORD   | FR_HIDEUPDOWN | \
                        FR_HIDEMATCHCASE | FR_HIDEWHOLEWORD)

#define PD_OUTPUTFLAGS (PD_ALLPAGES    | PD_COLLATE    | PD_PAGENUMS | \
                        PD_PRINTTOFILE | PD_SELECTION)

#define FO_OUTPUTFLAGS (OFN_READONLY | OFN_EXTENSIONDIFFERENT)

#define CF_OUTPUTFLAGS (CF_NOFACESEL | CF_NOSIZESEL | CF_NOSTYLESEL)
---*/


// private typedefs and structs
typedef BOOL (APIENTRY* FILENAMEPROC)(LPOPENFILENAME);
typedef HWND (APIENTRY* FINDREPLACEPROC)(LPFINDREPLACE);


// exported by comdlg32.dll to allow us to ultimately keep 16-bit common dialog
// structs in sync with the UNICODE version maintained by comdlg32.
extern VOID Ssync_ANSI_UNICODE_Struct_For_WOW(HWND  hDlg,
                                              BOOL  fANSI_To_UNICODE,
                                              DWORD dwID);

// private function prototypes
VOID
Thunk_OFNstrs16to32(IN OPENFILENAME    *pOFN32,
                    IN POPENFILENAME16  pOFN16);

BOOL
Alloc_OFN32_strs(IN OPENFILENAME    *pOFN32,
                 IN POPENFILENAME16  pOFN16);

VOID
Free_OFN32_strs(IN OPENFILENAME *pOFN32);

PCOMMDLGTD
GetCommdlgTd(IN HWND Hwnd32);

HINSTANCE
ThunkCDTemplate16to32(IN     HAND16  hInst16,
                      IN     DWORD   hPrintTemp16,
                      IN     VPVOID  vpTemplateName,
                      IN     DWORD   dwFlags16,
                      IN OUT DWORD  *pFlags,
                      IN     DWORD   ETFlag,
                      IN     DWORD   ETHFlag,
                      OUT    PPRES   pRes,
                      OUT    PBOOL   fError);

VOID
FreeCDTemplate32(IN PRES      pRes,
                 IN HINSTANCE hInst,
                 IN BOOL      bETFlag,
                 IN BOOL      bETHFlag);

PRES
GetTemplate16(IN HAND16  hInstance,
              IN VPCSTR  TemplateName,
              IN BOOLEAN UseHandle);


HGLOBAL
ThunkhDevMode16to32(IN HAND16 hDevMode16);

VOID
ThunkhDevMode32to16(IN OUT HAND16 *phDevMode16,
                    IN     HANDLE  hDevMode32);

HANDLE
ThunkhDevNames16to32(IN HAND16 hDevNames16);

VOID
ThunkhDevNames32to16(IN OUT HAND16 *phDevNames16,
                     IN     HANDLE  hDevNames);

VOID
ThunkCHOOSECOLOR16to32(OUT CHOOSECOLOR         *pCC32,
                       IN  PCHOOSECOLORDATA16   pCC16);

VOID
ThunkCHOOSECOLOR32to16(OUT PCHOOSECOLORDATA16  pCC16,
                       IN  CHOOSECOLOR        *pCC32);

VOID
ThunkCHOOSEFONT16to32(OUT CHOOSEFONT        *pCF32,
                      IN  PCHOOSEFONTDATA16  pCF16);

VOID
ThunkCHOOSEFONT32to16(OUT PCHOOSEFONTDATA16  pCF16,
                      IN  CHOOSEFONT        *pCF32);

VOID
ThunkFINDREPLACE16to32(OUT FINDREPLACE    *pFR32,
                       IN  PFINDREPLACE16  pFR16);

VOID
ThunkFINDREPLACE32to16(OUT PFINDREPLACE16  pFR16,
                       IN  FINDREPLACE    *pFR32);

BOOL
ThunkOPENFILENAME16to32(OUT OPENFILENAME    *pOFN32,
                        IN  POPENFILENAME16  pOFN16);

VOID
ThunkOPENFILENAME32to16(OUT POPENFILENAME16  pOFN16,
                        IN  OPENFILENAME    *pOFN32,
                        IN  BOOLEAN          bUpperStrings);

VOID
ThunkPRINTDLG16to32(OUT PRINTDLG        *pPD32,
                    IN  PPRINTDLGDATA16  pPD16);

VOID
ThunkPRINTDLG32to16(IN  VPVOID    vppd,
                    OUT PRINTDLG *pPD32);

VOID
ThunkCDStruct16to32(IN HWND         hDlg,
                    IN CHOOSECOLOR *pCC,
                    IN VPVOID       vp);

VOID
ThunkCDStruct32to16(IN HWND         hDlg,
                    IN VPVOID       vp,
                    IN CHOOSECOLOR *pCC);

UINT APIENTRY
WCD32CommonDialogProc(HWND       hdlg,
                      UINT       uMsg,
                      WPARAM     uParam,
                      LPARAM     lParam,
                      PCOMMDLGTD pCTD,
                      VPVOID     vpfnHook);

UINT APIENTRY
WCD32PrintSetupDialogProc(HWND   hdlg,
                          UINT   uMsg,
                          WPARAM uParam,
                          LPARAM lParam);

UINT APIENTRY
WCD32DialogProc(HWND   hdlg,
                UINT   uMsg,
                WPARAM uParam,
                LPARAM lParam);

ULONG
WCD32GetFileName(IN PVDMFRAME    pFrame,
                 IN FILENAMEPROC Function);

ULONG
WCD32FindReplaceText(IN PVDMFRAME       pFrame,
                     IN FINDREPLACEPROC Function);

UINT APIENTRY
WCD32FindReplaceDialogProc(HWND   hdlg,
                           UINT   uMsg,
                           WPARAM uParam,
                           LPARAM lParam);

#define VALID_OFN16_FLAGS (OFN_READONLY              | \
                           OFN_OVERWRITEPROMPT       | \
                           OFN_HIDEREADONLY          | \
                           OFN_NOCHANGEDIR           | \
                           OFN_SHOWHELP              | \
                           OFN_ENABLEHOOK            | \
                           OFN_ENABLETEMPLATE        | \
                           OFN_ENABLETEMPLATEHANDLE  | \
                           OFN_NOVALIDATE            | \
                           OFN_ALLOWMULTISELECT      | \
                           OFN_EXTENSIONDIFFERENT    | \
                           OFN_PATHMUSTEXIST         | \
                           OFN_FILEMUSTEXIST         | \
                           OFN_CREATEPROMPT          | \
                           OFN_SHAREAWARE            | \
                           OFN_NOREADONLYRETURN      | \
                           OFN_NOTESTFILECREATE)

//
// unique message thunks
//

// This function thunks the private messages
//      msgCOLOROK
BOOL FASTCALL
WM32msgCOLOROK(LPWM32MSGPARAMEX lpwm32mpex)
{
    LPCHOOSECOLOR       pCC32;
    PCHOOSECOLORDATA16  pCC16;

    GETVDMPTR((VPVOID)lpwm32mpex->Parm16.WndProc.lParam,
              sizeof(CHOOSECOLORDATA16),
              pCC16);

    pCC32 = (LPCHOOSECOLOR)lpwm32mpex->lParam;

    if(pCC16 && pCC32) {

        if(lpwm32mpex->fThunk) {
            ThunkCHOOSECOLOR32to16(pCC16, pCC32);
        }
        else {
            ThunkCHOOSECOLOR16to32(pCC32, pCC16);
        }
    }
    else {
        return(FALSE);
    }

    FREEVDMPTR(pCC16);

    return (TRUE);
}




// This function thunks the private messages
//      msgFILEOK
BOOL FASTCALL
WM32msgFILEOK(LPWM32MSGPARAMEX lpwm32mpex)
{
    VPOPENFILENAME   vpof;
    POPENFILENAME16  pOFN16;
    OPENFILENAME    *pOFN32;


    vpof = (VPOPENFILENAME)(GetCommdlgTd(lpwm32mpex->hwnd)->vpData);

    pOFN32 = (OPENFILENAME *)lpwm32mpex->lParam;
    //
    // Approach sends its own fileok message when you click on its
    // secret listbox that it displays over lst1 sometimes.  It
    // sends NULL for the LPARAM instead of the address of the
    // openfilename structure.
    if(pOFN32 == NULL) {
        lpwm32mpex->Parm16.WndProc.lParam = (LPARAM)NULL;
        return(TRUE);
    }

    GETVDMPTR(vpof, sizeof(OPENFILENAME16), pOFN16);

    if (lpwm32mpex->fThunk) {
        UpdateDosCurrentDirectory(DIR_NT_TO_DOS);
        lpwm32mpex->Parm16.WndProc.lParam = (LPARAM)vpof;

        // sudeepb 12-Mar-1996
        //
        // The selected file name needs to be uppercased for
        // apps like symanatec QA 4.0. So changed the following parameter
        // in ThunkOpenFileName from FALSE to TRUE.
        ThunkOPENFILENAME32to16(pOFN16, pOFN32, TRUE);

    } else {
        ThunkOPENFILENAME16to32(pOFN32, pOFN16);
    }

    FREEVDMPTR(pOFN16);

    return (TRUE);
}




// This function thunks the private messages
//      msgWOWDIRCHANGE
BOOL FASTCALL
WM32msgWOWDIRCHANGE(LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        UpdateDosCurrentDirectory(DIR_NT_TO_DOS);
    }

    return (TRUE);
}





// This function thunks the private message
//      msgWOWLFCHANGE
BOOL FASTCALL
WM32msgWOWLFCHANGE(LPWM32MSGPARAMEX lpwm32mpex)
{
    VPCHOOSEFONTDATA  vpcf;
    PCHOOSEFONTDATA16 pCF16;


    vpcf = (VPCHOOSEFONTDATA)(GetCommdlgTd(lpwm32mpex->hwnd)->vpData);

    GETVDMPTR(vpcf, sizeof(CHOOSEFONTDATA16), pCF16);
    WOW32ASSERT(pCF16);

    if (lpwm32mpex->fThunk) {
        PUTLOGFONT16(DWORD32(pCF16->lpLogFont),
                     sizeof(LOGFONT),
                     (LPLOGFONT)lpwm32mpex->lParam);
    }

    FREEVDMPTR(pCF16);

    return(TRUE);
}





// This function thunks the private message
//      msgSHAREVIOLATION
BOOL FASTCALL
WM32msgSHAREVIOLATION(LPWM32MSGPARAMEX lpwm32mpex)
{
    INT cb;
    PLONG plParamNew = &lpwm32mpex->Parm16.WndProc.lParam;


    if (lpwm32mpex->fThunk) {
        if (lpwm32mpex->lParam) {
            cb = strlen((LPSZ)lpwm32mpex->lParam)+1;
            if (!(*plParamNew = malloc16(cb))) {
                return(FALSE);
            }
            putstr16((VPSZ)*plParamNew, (LPSZ)lpwm32mpex->lParam, cb);
        }
    } else {
        if (*plParamNew) {
            free16((VPVOID) *plParamNew);
        }
    }

    return (TRUE);
}





// This function thunks the private messages
//      WM_CHOOSEFONT_GETLOGFONT
BOOL FASTCALL
WM32msgCHOOSEFONTGETLOGFONT(LPWM32MSGPARAMEX lpwm32mpex)
{
    LOGFONT LogFont32;

    // The mere fact that we access the buffer after allowing the 16-bit
    // hook proc to step in breaks Serif PagePlus app which wants it's
    // hook proc to always have a shot and commdlg to check the return value.

    // If hook proc returns TRUE, no further action is taken
    //
    // This is the message an app sends the dialog if it wants to find
    // out what font is currently selected.
    //
    // We thunk this by sending yet another hackorama message to comdlg32,
    // who will then fill in the 32-bit structure we pass in so we can
    // thunk it back to the 16-bit structure.  Then we return TRUE so
    // comdlg32 doesn't reference the 16-bit logfont.
    //
    if (!lpwm32mpex->fThunk && !lpwm32mpex->lReturn) {
        SendMessage(lpwm32mpex->hwnd, msgWOWCHOOSEFONT, 0, (LPARAM)&LogFont32);

        PUTLOGFONT16(lpwm32mpex->lParam, sizeof(LOGFONT), &LogFont32);

        lpwm32mpex->lReturn = TRUE;
    }

    return (TRUE);
}






//
// Dialog callback hook thunks
//
UINT APIENTRY
WCD32DialogProc(HWND hdlg,
                UINT uMsg,
                WPARAM uParam,
                LPARAM lParam)
/*++

Routine Description:

    This is the hook proc used by ChooseColor, ChooseFont, GetOpenFileName,
    GetSaveFileName, and PrintDlg.  It pulls the 16-bit callback
    out of the thread data and calls the common dialog proc to do
    the rest of the work.

--*/
{
    PCOMMDLGTD Td;

    Td = GetCommdlgTd(hdlg);
    if(Td) {
        return(WCD32CommonDialogProc(hdlg,
                                     uMsg,
                                     uParam,
                                     lParam,
                                     Td,
                                     Td->vpfnHook));
    } else {
        return(0);
    }
}




UINT APIENTRY
WCD32PrintSetupDialogProc(HWND hdlg,
                          UINT uMsg,
                          WPARAM uParam,
                          LPARAM lParam)
/*++

Routine Description:

    This is the hook proc used by PrintSetup.  It is only used when
    the Setup button on the Print dialog directly creates the PrintSetup
    dialog.  We find the correct TD by looking for the TD of our owner
    window (which is the print dialog)

    It calls the common dialog proc to do the rest of the work.

--*/

{
    PCOMMDLGTD pTD;

    pTD = CURRENTPTD()->CommDlgTd;
    if(pTD) {
        while (pTD->SetupHwnd != GETHWND16(hdlg)) {
            pTD = pTD->Previous;
            if(!pTD) {
                WOW32ASSERT(FALSE);
                return(0);
            }
        }

        return(WCD32CommonDialogProc(hdlg,
                                     uMsg,
                                     uParam,
                                     lParam,
                                     pTD,
                                     pTD->vpfnSetupHook));
    } else {
        return(0);
    }

}




UINT APIENTRY
WCD32FindReplaceDialogProc(HWND hdlg,
                           UINT uMsg,
                           WPARAM uParam,
                           LPARAM lParam)
/*++

Routine Description:

    This is the hook proc used by FindText and ReplaceText. It does cleanup
    on WM_DESTROY and calls WCD32CommonDialogProc to handle the 16-bit
    dialog hook callback on all messages, if needed.

--*/

{
    PFINDREPLACE16 pFR16;
    VPFINDREPLACE  vpfr;
    LPFINDREPLACE  pFR32;
    PCOMMDLGTD     ptdDlg;
    PCOMMDLGTD     ptdOwner;
    UINT           uRet = FALSE;

    // If the ptdDlg is invalid, do nothing.
    ptdDlg = GetCommdlgTd(hdlg);
    if (ptdDlg == NULL) {
        return(uRet);
    }

    if (uMsg != WM_DESTROY) {

        // this will be FALSE if the app didn't specify a 16-bit hookproc
        // we always set the 32-bit hookproc in ThunkFINDREPLACE16to32()
        if (ptdDlg->vpfnHook) {

           uRet = WCD32CommonDialogProc(hdlg,
                                        uMsg,
                                        uParam,
                                        lParam,
                                        ptdDlg,
                                        ptdDlg->vpfnHook);
        }
    }
    else {

        pFR32 = (LPFINDREPLACE)ptdDlg->pData32;

        // UnLink both per thread data structs from the list.
        ptdOwner = GetCommdlgTd(pFR32->hwndOwner);
        CURRENTPTD()->CommDlgTd = ptdDlg->Previous;
        WOW32ASSERT(ptdOwner->Previous == ptdDlg);

        vpfr = ptdDlg->vpData;

        GETVDMPTR(vpfr, sizeof(FINDREPLACE16), pFR16);

        // CleanUp template if used.
        FreeCDTemplate32((PRES)ptdDlg->pRes,
                         pFR32->hInstance,
                         DWORD32(pFR16->Flags) & FR_ENABLETEMPLATE,
                         DWORD32(pFR16->Flags) & FR_ENABLETEMPLATEHANDLE);


        FREEVDMPTR(pFR16);

        // Free the per thread data structs.
        free_w(ptdDlg);
        free_w(ptdOwner);

        // Free the 32-bit FINDREPLACE structure.
        free_w(pFR32->lpstrFindWhat);
        free_w(pFR32->lpstrReplaceWith);
        free_w(pFR32);
    }

    if (uMsg == WM_INITDIALOG) {
        // Force COMDLG32!FindReplaceDialogProc to handle WM_INITDIALOG.
        uRet = TRUE;
    }

    return(uRet);
}





UINT APIENTRY
WCD32CommonDialogProc(HWND hdlg,
                      UINT uMsg,
                      WPARAM uParam,
                      LPARAM lParam,
                      PCOMMDLGTD pCTD,
                      VPVOID vpfnHook)
/*++

Routine Description:

    This thunks the 32-bit dialog callback into a 16-bit callback
    This is the common code used by all the dialog callback thunks that
    actually calls the 16-bit callback.

--*/

{
    BOOL            fSuccess;
    LPFNM32         pfnThunkMsg;
    WM32MSGPARAMEX  wm32mpex;
    BOOL            fMessageNeedsThunking;

    // If the app has GP Faulted we don't want to pass it any more input
    // This should be removed when USER32 does clean up on task death so
    // it doesn't call us - mattfe june 24 92

    // LOGDEBUG(10, ("CommonDialogProc In: %lX %X %X %lX\n",
    //         (DWORD)hdlg,
    //         uMsg,
    //         uParam,
    //         lParam));

    if(CURRENTPTD()->dwFlags & TDF_IGNOREINPUT) {

        LOGDEBUG(6,
                 ("    WCD32OpenFileDialog Ignoring Input Messsage %04X\n",
                 uMsg));

        WOW32ASSERTMSG(gfIgnoreInputAssertGiven,
         "WCD32CommonDialogProc: TDF_IGNOREINPUT hack was used, shouldn't be, "
         "please email DaveHart with repro instructions.  Hit 'g' to ignore "
         "this and suppress this assertion from now on.\n");

        gfIgnoreInputAssertGiven = TRUE;
        goto SilentError;
    }

#if DBG
    if(pCTD==NULL) {
        LOGDEBUG(0,("    WCD32OpenFileDialog ERROR: pCTD==NULL\n"));
        goto Error;
    }

    // If pCTD->vpfnHook is NULL, then something is broken;  we
    // certainly can't continue because we don't know what 16-bit func to call
    if(!vpfnHook) {
        LOGDEBUG(0,("    WCD32OpenFileDialog ERROR: no hook proc for message %04x Dlg = %08lx\n", uMsg, hdlg ));
        goto Error;
    }
#endif

    wm32mpex.Parm16.WndProc.hwnd   = GETHWND16(hdlg);
    wm32mpex.Parm16.WndProc.wMsg   = (WORD)uMsg;
    wm32mpex.Parm16.WndProc.wParam = (WORD)uParam;
    wm32mpex.Parm16.WndProc.lParam = (LONG)lParam;
    wm32mpex.Parm16.WndProc.hInst  = (WORD)GetWindowLong(hdlg, GWL_HINSTANCE);

    // On Win3.1, the app & the system share the ptr to the same structure that
    // the app passed to the common dialog API.  Therefore, when one side makes
    // a change to the struct, the other is aware of the change.  This is not
    // the case on NT since we thunk the struct into a 32-bit ANSI struct which
    // is then thunked into a 32-bit UNICODE struct in the comdlg32 code.  We
    // attempt to synchronize all these structs by rethunking them for every
    // message sent to the 16-bit side & for every API call the app makes.
    // See sync code in callback16(), fastwow bopping code, and w32Dispatch().
    // ComDlg32 thunks UNICODEtoANSI before calling us & ASNItoUNICODE when we
    // return.  Ug!!!  Apparently a fair number of apps depend on this
    // behavior since we've debugged this problem about 6 times to date and
    // each time we have put in special hacks for each case.  With any luck
    // this should be a general fix.   08/97   CMJones

    if(uMsg < 0x400) {

        LOGDEBUG(3,
                 ("%04X (%s)\n",
                 CURRENTPTD()->htask16,
                 (aw32Msg[uMsg].lpszW32)));

        pfnThunkMsg = aw32Msg[uMsg].lpfnM32;

        if(uMsg == WM_INITDIALOG) {

            // The address of the 16-bit structure that the app passed to the
            // original common dialog API is passed in lParam in WM_INITDIALOG
            // messages in Win 3.1
            wm32mpex.Parm16.WndProc.lParam = lParam = (LPARAM)pCTD->vpData;
        }

    // Check for unique messages
    } else if(uMsg >= 0x400) {
        if (uMsg == msgFILEOK) {
            pfnThunkMsg = WM32msgFILEOK;
        } else if(uMsg == msgCOLOROK) {
            wm32mpex.Parm16.WndProc.lParam = (LPARAM)pCTD->vpData;
            pfnThunkMsg = WM32msgCOLOROK;
        } else if(uMsg == msgSHAREVIOLATION) {
            pfnThunkMsg = WM32msgSHAREVIOLATION;
        } else if(uMsg == msgWOWDIRCHANGE) {
            pfnThunkMsg = WM32msgWOWDIRCHANGE;
        } else if(uMsg == msgWOWLFCHANGE) {
            pfnThunkMsg = WM32msgWOWLFCHANGE;
        } else if(pCTD->Flags & WOWCD_ISCHOOSEFONT) {

            // special ChooseFont thunks to handle goofy GETLOGFONT message
            if(uMsg == WM_CHOOSEFONT_GETLOGFONT) {

                pfnThunkMsg = WM32msgCHOOSEFONTGETLOGFONT;

            } else if(uMsg == msgWOWCHOOSEFONT) {
                //
                // no wow app will expect this, so don't send it.
                //
                return(FALSE);
            } else {
                pfnThunkMsg = WM32NoThunking;
            }
        } else {
            pfnThunkMsg = WM32NoThunking;
        }
    }

    fMessageNeedsThunking = (pfnThunkMsg != WM32NoThunking);
    if(fMessageNeedsThunking) {
        wm32mpex.fThunk = THUNKMSG;
        wm32mpex.hwnd = hdlg;
        wm32mpex.uMsg = uMsg;
        wm32mpex.uParam = uParam;
        wm32mpex.lParam = lParam;
        wm32mpex.pww = NULL;
        wm32mpex.lpfnM32 = pfnThunkMsg;

        if(!(pfnThunkMsg)(&wm32mpex)) {
            LOGDEBUG(LOG_ERROR,("    WCD32OpenFileDialog ERROR: cannot thunk 32-bit message %04x\n", uMsg));
            goto Error;
        }
    } else {
        LOGDEBUG(6,("WCD32CommonDialogProc, No Thunking was required for the 32-bit message %s(%04x)\n", (LPSZ)GetWMMsgName(uMsg), uMsg));
    }

    // this call may cause 16-bit memory to move
    // this call will call 32->16 sync code before the callback & the 16->32
    // sync upon return from the callback
    fSuccess = CallBack16(RET_WNDPROC,
                          &wm32mpex.Parm16,
                          vpfnHook,
                          (PVPVOID)&wm32mpex.lReturn);

    // flat ptrs to 16-bit mem are now invalid due to possible memory movement

    // the callback function of a dialog is of type FARPROC whose return value
    // is of type 'int'. Since dx:ax is copied into lReturn in the above
    // CallBack16 call, we need to zero out the hiword, otherwise we will be
    // returning an erroneous value.
    wm32mpex.lReturn = (LONG)LOWORD(wm32mpex.lReturn);

    if(fMessageNeedsThunking) {
        wm32mpex.fThunk = UNTHUNKMSG;
        (pfnThunkMsg)(&wm32mpex);
    }

    if(!fSuccess)
        goto Error;

Done:
    // Uncomment this to receive message on exit
    // LOGDEBUG(10, ("CommonDialogProc Out: Return %lX\n", wm32mpex.lReturn));

    return wm32mpex.lReturn;

Error:
    LOGDEBUG(5,("    WCD32OpenFileDialog WARNING: cannot call back, using default message handling\n"));
SilentError:
    wm32mpex.lReturn = 0;
    goto Done;
}






ULONG FASTCALL
WCD32ExtendedError( IN PVDMFRAME pFrame )
/*++

Routine Description:

    32-bit thunk for CommDlgExtendedError()

Arguments:

    pFrame - Supplies 16-bit argument frame

Return Value:

    error code to be returned

--*/
{
    if (dwExtError != 0) {
        return(dwExtError);
    }
    return(CommDlgExtendedError());
}







ULONG FASTCALL
WCD32ChooseColor(PVDMFRAME pFrame)
/*++

Routine Description:

    This routine thunks the 16-bit ChooseColor common dialog to the 32-bit
    side.

Arguments:

    pFrame - Supplies 16-bit argument frame

Return Value:

    16-bit BOOLEAN to be returned.

--*/
{
    ULONG                   ul = GETBOOL16(FALSE);
    register PCHOOSECOLOR16 parg16;
    VPCHOOSECOLORDATA       vpcc;
    CHOOSECOLOR             CC32;
    PCHOOSECOLORDATA16      pCC16;
    PRES                    pRes = NULL;
    COMMDLGTD               ThreadData;
    COLORREF                CustColors32[16];  // on stack for DWORD alignment
    DWORD                   dwFlags16;
    BOOL                    fError = FALSE;


    GETARGPTR(pFrame, sizeof(CHOOSECOLOR16), parg16);
    vpcc = parg16->lpcc;

    SETEXTENDEDERROR( 0 );

    // invalidate this now
    FREEVDMPTR( parg16 );

    // initialize unique window message
    if (msgCOLOROK == 0) {
        if(!(msgCOLOROK = (WORD)RegisterWindowMessage(COLOROKSTRING))) {
            SETEXTENDEDERROR( CDERR_REGISTERMSGFAIL );
            LOGDEBUG(2,("WCD32ChooseColor:RegisterWindowMessage failed\n"));
            return(0);
        }
    }

    GETVDMPTR(vpcc, sizeof(CHOOSECOLORDATA16), pCC16);

    WCDDUMPCHOOSECOLORDATA16(pCC16);

    if(DWORD32(pCC16->lStructSize) != sizeof(CHOOSECOLORDATA16)) {
        SETEXTENDEDERROR( CDERR_STRUCTSIZE );
        FREEVDMPTR(pCC16);
        return(0);
    }

    RtlZeroMemory(&ThreadData, sizeof(COMMDLGTD));
    ThreadData.Previous = CURRENTPTD()->CommDlgTd;
    ThreadData.hdlg     = (HWND16)-1;
    ThreadData.pData32  = &CC32;
    ThreadData.Flags    = 0;
    if(DWORD32(pCC16->Flags) & CC_ENABLEHOOK) {
        ThreadData.vpfnHook = DWORD32(pCC16->lpfnHook);
        if(!ThreadData.vpfnHook) {
            SETEXTENDEDERROR(CDERR_NOHOOK);
            FREEVDMPTR(pCC16);
            return(0);
        }
        ThreadData.vpData   = vpcc;
    }
    else {
        STOREDWORD(pCC16->lpfnHook, 0);
    }

    RtlZeroMemory(&CC32, sizeof(CHOOSECOLOR));
    CC32.lpCustColors = CustColors32;
    ThunkCHOOSECOLOR16to32(&CC32, pCC16);
    dwFlags16 = DWORD32(pCC16->Flags);

    // this call invalidates flat ptrs to 16-bit memory
    CC32.hInstance = (HWND)ThunkCDTemplate16to32(WORD32(pCC16->hInstance),
                                                 0,
                                                 DWORD32(pCC16->lpTemplateName),
                                                 dwFlags16,
                                                 &(CC32.Flags),
                                                 CC_ENABLETEMPLATE,
                                                 CC_ENABLETEMPLATEHANDLE,
                                                 &pRes,
                                                 &fError);

    if(fError) {
        goto ChooseColorExit;
    }

    // invalidate flat ptrs to 16-bit memory
    FREEVDMPTR(pCC16);

    WCDDUMPCHOOSECOLORDATA32(&CC32);

    // Set this just before the calling into comdlg32.  This prevents the
    // synchronization stuff from firing until we actually need it.
    CURRENTPTD()->CommDlgTd = &ThreadData;

    // this call invalidates flat ptrs to 16-bit memory
    ul = GETBOOL16(ChooseColor(&CC32));

    CURRENTPTD()->CommDlgTd = ThreadData.Previous;

    if (ul) {

        WCDDUMPCHOOSECOLORDATA32(&CC32);

        GETVDMPTR(vpcc, sizeof(CHOOSECOLOR16), pCC16);
        ThunkCHOOSECOLOR32to16(pCC16, &CC32);

        WCDDUMPCHOOSECOLORDATA16(pCC16);
        FREEVDMPTR(pCC16);

    }

ChooseColorExit:

    FreeCDTemplate32(pRes,
                     (HINSTANCE)CC32.hInstance,
                     dwFlags16 & CC_ENABLETEMPLATE,
                     dwFlags16 & CC_ENABLETEMPLATEHANDLE);

    FREEVDMPTR(pCC16);

    return(ul);
}




VOID
ThunkCHOOSECOLOR16to32(OUT CHOOSECOLOR        *pCC32,
                       IN  PCHOOSECOLORDATA16  pCC16)
{
    COLORREF *pCustColors16;
    DWORD     Flags;


    if(pCC16 && pCC32) {

        pCC32->lStructSize = sizeof(CHOOSECOLOR);
        pCC32->hwndOwner   = HWND32(pCC16->hwndOwner);

        // hInstance thunked separately

        pCC32->rgbResult   = DWORD32(pCC16->rgbResult);

        if(pCC32->lpCustColors) {
            GETVDMPTR(pCC16->lpCustColors, 16*sizeof(COLORREF), pCustColors16);
            if(pCustColors16) {
                RtlCopyMemory(pCC32->lpCustColors,
                              pCustColors16,
                              16*sizeof(COLORREF));
            }
            FREEVDMPTR(pCustColors16);
        }

        // preserve the template flag state while copying flags
        // 1. save template flag state
        //     note: we never will have a 32-bit CC_ENABLETEMPLATE flag
        // 2. copy flags from 16-bit struct (add the WOWAPP flag)
        // 3. turn off all template flags
        // 4. restore original template flag state
        Flags         = pCC32->Flags & CC_ENABLETEMPLATEHANDLE;
        pCC32->Flags  = DWORD32(pCC16->Flags) | CD_WOWAPP;
        pCC32->Flags &= ~(CC_ENABLETEMPLATE | CC_ENABLETEMPLATEHANDLE);
        pCC32->Flags |= Flags;

        pCC32->lCustData   = DWORD32(pCC16->lCustData);

        if((DWORD32(pCC16->Flags) & CC_ENABLEHOOK) && DWORD32(pCC16->lpfnHook)){
            pCC32->lpfnHook = WCD32DialogProc;
        }

        // lpTemplateName32 is thunked separately
    }
}




VOID
ThunkCHOOSECOLOR32to16(OUT PCHOOSECOLORDATA16  pCC16,
                       IN  CHOOSECOLOR        *pCC32)
{
    COLORREF *pCustColors16;
    DWORD     Flags, Flags32;


    if(pCC16 && pCC32) {

        STOREDWORD(pCC16->rgbResult, pCC32->rgbResult);

        // preserve the template flag state while copying flags
        // 1. save template flag state
        // 2. copy flags from 32-bit struct
        // 3. turn off all template flags and the WOWAPP flag
        // 4. restore original template flag state
        Flags    = DWORD32(pCC16->Flags) & (CC_ENABLETEMPLATE |
                                            CC_ENABLETEMPLATEHANDLE);
        Flags32  = pCC32->Flags;
        Flags32 &= ~(CC_ENABLETEMPLATE | CC_ENABLETEMPLATEHANDLE | CD_WOWAPP);
        Flags32 |= Flags;
        STOREDWORD(pCC16->Flags, Flags32);

        GETVDMPTR(pCC16->lpCustColors, 16*sizeof(COLORREF), pCustColors16);
        if(pCustColors16) {
            RtlCopyMemory(pCustColors16,
                          pCC32->lpCustColors,
                          16*sizeof(COLORREF));
            FREEVDMPTR(pCustColors16);
        }
    }
}





ULONG FASTCALL
WCD32ChooseFont( PVDMFRAME pFrame )
/*++

Routine Description:

    This routine thunks the 16-bit ChooseFont common dialog to the 32-bit
    side.

Arguments:

    pFrame - Supplies 16-bit argument frame

Return Value:

    16-bit BOOLEAN to be returned.

--*/
{
    ULONG                   ul = GETBOOL16(FALSE);
    register PCHOOSEFONT16  parg16;
    VPCHOOSEFONTDATA        vpcf;
    CHOOSEFONT              CF32;
    LOGFONT                 LogFont32;
    PCHOOSEFONTDATA16       pCF16;
    PRES                    pRes = NULL;
    COMMDLGTD               ThreadData;
    DWORD                   dwFlags16;
    CHAR                    sStyle[2 * LF_FACESIZE];
    BOOL                    fError = FALSE;


    GETARGPTR(pFrame, sizeof(CHOOSEFONT16), parg16);
    vpcf = parg16->lpcf;

    SETEXTENDEDERROR( 0 );

    // invalidate this now
    FREEVDMPTR( parg16 );

    // initialize unique window messages
    if (msgWOWCHOOSEFONT == 0) {

        // private WOW<->comdlg32 message for handling WM_CHOOSEFONT_GETLOGFONT
        if(!(msgWOWCHOOSEFONT  =
                     (WORD)RegisterWindowMessage("WOWCHOOSEFONT_GETLOGFONT"))) {
            SETEXTENDEDERROR( CDERR_REGISTERMSGFAIL );
            LOGDEBUG(2,("WCD32ChooseFont:RegisterWindowMessage failed\n"));
            return(0);
        }
    }
    if (msgWOWLFCHANGE == 0) {

        // private message for thunking logfont changes
        if(!(msgWOWLFCHANGE = (WORD)RegisterWindowMessage("WOWLFChange"))) {
            SETEXTENDEDERROR( CDERR_REGISTERMSGFAIL );
            LOGDEBUG(2,("WCD32ChooseFont:RegisterWindowMessage 2 failed\n"));
            return(0);
        }
    }

    GETVDMPTR(vpcf, sizeof(CHOOSEFONTDATA16), pCF16);

    WCDDUMPCHOOSEFONTDATA16(pCF16);

    if(DWORD32(pCF16->lStructSize) != sizeof(CHOOSEFONTDATA16)) {
        SETEXTENDEDERROR( CDERR_STRUCTSIZE );
        FREEVDMPTR(pCF16);
        return(0);
    }

    RtlZeroMemory(&ThreadData, sizeof(COMMDLGTD));
    ThreadData.Previous = CURRENTPTD()->CommDlgTd;
    ThreadData.hdlg     = (HWND16)-1;
    ThreadData.pData32  = &CF32;
    ThreadData.Flags    = WOWCD_ISCHOOSEFONT;
    if(DWORD32(pCF16->Flags) & CF_ENABLEHOOK) {
        ThreadData.vpfnHook = DWORD32(pCF16->lpfnHook);
        if(!ThreadData.vpfnHook) {
            SETEXTENDEDERROR(CDERR_NOHOOK);
            FREEVDMPTR(pCF16);
            return(0);
        }
        ThreadData.vpData   = vpcf;
    }
    else {
        STOREDWORD(pCF16->lpfnHook, 0);
    }

    RtlZeroMemory(&CF32, sizeof(CHOOSEFONT));
    CF32.lpLogFont = &LogFont32;
    CF32.lpszStyle = sStyle;
    sStyle[0] = '\0';
    ThunkCHOOSEFONT16to32(&CF32, pCF16);
    dwFlags16 = DWORD32(pCF16->Flags);

    // this call invalidates flat ptrs to 16-bit memory
    CF32.hInstance = ThunkCDTemplate16to32(WORD32(pCF16->hInstance),
                                           0,
                                           DWORD32(pCF16->lpTemplateName),
                                           dwFlags16,
                                           &(CF32.Flags),
                                           CF_ENABLETEMPLATE,
                                           CF_ENABLETEMPLATEHANDLE,
                                           &pRes,
                                           &fError);

    if(fError) {
        goto ChooseFontExit;
    }

    // invalidate flat ptrs to 16-bit memory
    FREEVDMPTR(pCF16);

    WCDDUMPCHOOSEFONTDATA32(&CF32);

    // Set this just before the calling into comdlg32.  This prevents the
    // synchronization stuff from firing until we actually need it.
    CURRENTPTD()->CommDlgTd = &ThreadData;

    // this call invalidates flat ptrs to 16-bit memory
    ul = GETBOOL16(ChooseFont(&CF32));

    CURRENTPTD()->CommDlgTd = ThreadData.Previous;

    if (ul) {

        WCDDUMPCHOOSEFONTDATA32(&CF32);

        GETVDMPTR(vpcf, sizeof(CHOOSEFONT16), pCF16);
        ThunkCHOOSEFONT32to16(pCF16, &CF32);

        WCDDUMPCHOOSEFONTDATA16(pCF16);

    }

ChooseFontExit:

    FreeCDTemplate32(pRes,
                     CF32.hInstance,
                     dwFlags16 & CF_ENABLETEMPLATE,
                     dwFlags16 & CF_ENABLETEMPLATEHANDLE);

    FREEVDMPTR(pCF16);

    return(ul);
}





VOID
ThunkCHOOSEFONT16to32(OUT CHOOSEFONT        *pCF32,
                      IN  PCHOOSEFONTDATA16  pCF16)
{
    LPSTR lpstr;
    DWORD Flags;


    if(pCF16 && pCF32) {

        pCF32->lStructSize = sizeof(CHOOSEFONT);
        pCF32->hwndOwner   = HWND32(pCF16->hwndOwner);

        if(DWORD32(pCF16->Flags) & CF_PRINTERFONTS) {
            pCF32->hDC = HDC32(pCF16->hDC);
        }

        if(DWORD32(pCF16->lpLogFont) && pCF32->lpLogFont) {
            GETLOGFONT16(DWORD32(pCF16->lpLogFont), pCF32->lpLogFont);
        }

        pCF32->iPointSize  = INT32(pCF16->iPointSize);

        // preserve the template flag state while copying flags
        // 1. save template flag state
        //     note: we never will have a 32-bit CF_ENABLETEMPLATE flag
        // 2. copy flags from 16-bit struct (add the WOWAPP flag)
        // 3. turn off all template flags
        // 4. restore original template flag state
        Flags         = pCF32->Flags & CF_ENABLETEMPLATEHANDLE;
        pCF32->Flags  = DWORD32(pCF16->Flags) | CD_WOWAPP;
        pCF32->Flags &= ~(CF_ENABLETEMPLATE | CF_ENABLETEMPLATEHANDLE);
        pCF32->Flags |= Flags;

        pCF32->rgbColors   = DWORD32(pCF16->rgbColors);
        pCF32->lCustData   = DWORD32(pCF16->lCustData);

        if((DWORD32(pCF16->Flags) & CF_ENABLEHOOK) && pCF16->lpfnHook) {
            pCF32->lpfnHook = WCD32DialogProc;
        }

        // lpTemplateName32 is thunked separately
        // hInstance thunked separately

        // Note: we shouldn't have to free or re-alloc this since they
        //       will only need LF_FACESIZE bytes to handle the string
        GETPSZPTR(pCF16->lpszStyle, lpstr);
        if(lpstr && pCF32->lpszStyle) {
            if(DWORD32(pCF16->Flags) & CF_USESTYLE) {
                strcpy(pCF32->lpszStyle, lpstr);
            }
            FREEPSZPTR(lpstr);
        }

        pCF32->nFontType   = WORD32(pCF16->nFontType);
        pCF32->nSizeMin    = INT32(pCF16->nSizeMin);
        pCF32->nSizeMax    = INT32(pCF16->nSizeMax);
    }
}





VOID
ThunkCHOOSEFONT32to16(OUT PCHOOSEFONTDATA16  pCF16,
                      IN  CHOOSEFONT        *pCF32)
{
    LPSTR lpstr;
    DWORD Flags, Flags32;


    if(pCF16 && pCF32) {

        STOREWORD(pCF16->iPointSize, pCF32->iPointSize);
        STOREDWORD(pCF16->rgbColors, pCF32->rgbColors);
        STOREWORD(pCF16->nFontType,  pCF32->nFontType);

        // preserve the template flag state while copying flags
        // 1. save template flag state
        // 2. copy flags from 32-bit struct
        // 3. turn off all template flags and the WOWAPP flag
        // 4. restore original template flag state
        Flags    = DWORD32(pCF16->Flags) & (CF_ENABLETEMPLATE |
                                            CF_ENABLETEMPLATEHANDLE);
        Flags32  = pCF32->Flags;
        Flags32 &= ~(CF_ENABLETEMPLATE | CF_ENABLETEMPLATEHANDLE | CD_WOWAPP);
        Flags32 |= Flags;
        STOREDWORD(pCF16->Flags, Flags32);

        if(DWORD32(pCF16->lpLogFont) && pCF32->lpLogFont) {
            PUTLOGFONT16(DWORD32(pCF16->lpLogFont),
                         sizeof(LOGFONT),
                         pCF32->lpLogFont);
        }

        GETPSZPTR(pCF16->lpszStyle, lpstr);
        if(lpstr && pCF32->lpszStyle) {
            if(DWORD32(pCF16->Flags) & CF_USESTYLE) {
                strcpy(lpstr, pCF32->lpszStyle);
            }
            FREEPSZPTR(lpstr);
        }
    }
}







ULONG FASTCALL
WCD32PrintDlg(IN PVDMFRAME pFrame)
/*++

Routine Description:

    This routine thunks the 16-bit PrintDlg common dialog to the 32-bit
    side.

Arguments:

    pFrame - Supplies 16-bit argument frame

Return Value:

    16-bit BOOLEAN to be returned

--*/
{
    ULONG                  ul = GETBOOL16(FALSE);
    register PPRINTDLG16   parg16;
    VPPRINTDLGDATA         vppd;
    PRINTDLG               PD32;
    PPRINTDLGDATA16        pPD16;
    PRES                   hSetupRes = NULL;
    PRES                   hPrintRes = NULL;
    COMMDLGTD              ThreadData;
    DWORD                  dwFlags16;
    HMEM16                 hDM16;
    HMEM16                 hDN16;
    BOOL                   fError = FALSE;


    GETARGPTR(pFrame, sizeof(PRINTDLG16), parg16);
    vppd = parg16->lppd;

    // invalidate this now
    FREEARGPTR(parg16);

    SETEXTENDEDERROR(0);

    GETVDMPTR(vppd, sizeof(PRINTDLGDATA16), pPD16);

    WCDDUMPPRINTDLGDATA16(pPD16);

    if(DWORD32(pPD16->lStructSize) != sizeof(PRINTDLGDATA16)) {
        SETEXTENDEDERROR( CDERR_STRUCTSIZE );
        FREEVDMPTR(pPD16);
        return(0);
    }

    if(DWORD32(pPD16->Flags) & PD_RETURNDEFAULT) {
        // spec says these must be NULL
        if(WORD32(pPD16->hDevMode) || WORD32(pPD16->hDevNames)) {
            SETEXTENDEDERROR(PDERR_RETDEFFAILURE);
            FREEVDMPTR(pPD16);
            return(0);
        }
    }

    RtlZeroMemory((PVOID)&PD32, sizeof(PRINTDLG));
    RtlZeroMemory((PVOID)&ThreadData, sizeof(COMMDLGTD));
    ThreadData.Previous = CURRENTPTD()->CommDlgTd;
    ThreadData.hdlg     = (HWND16)-1;
    ThreadData.pData32  = (PVOID)&PD32;
    ThreadData.Flags    = 0;

    // this flag causes the system to put up the setup dialog rather
    // than the print dialog
    if(DWORD32(pPD16->Flags) & PD_PRINTSETUP) {
        if(DWORD32(pPD16->Flags) & PD_ENABLESETUPHOOK) {
            ThreadData.vpfnHook = DWORD32(pPD16->lpfnSetupHook);
            if(!ThreadData.vpfnHook) {
                SETEXTENDEDERROR(CDERR_NOHOOK);
                FREEVDMPTR(pPD16);
                return(0);
            }
            ThreadData.vpData = vppd;
            PD32.lpfnSetupHook = WCD32DialogProc;
        }
    } else {
        if (DWORD32(pPD16->Flags) & PD_ENABLEPRINTHOOK) {
            ThreadData.vpfnHook = DWORD32(pPD16->lpfnPrintHook);
            if(!ThreadData.vpfnHook) {
                SETEXTENDEDERROR(CDERR_NOHOOK);
                FREEVDMPTR(pPD16);
                return(0);
            }
            ThreadData.vpData = vppd;
            PD32.lpfnPrintHook = WCD32DialogProc;
        }
        if (DWORD32(pPD16->Flags) & PD_ENABLESETUPHOOK) {
            ThreadData.vpfnSetupHook = DWORD32(pPD16->lpfnSetupHook);
            if(!ThreadData.vpfnSetupHook) {
                SETEXTENDEDERROR(CDERR_NOHOOK);
                FREEVDMPTR(pPD16);
                return(0);
            }
            ThreadData.vpData    = vppd;
            ThreadData.SetupHwnd = (HWND16)1;
            PD32.lpfnSetupHook   = WCD32PrintSetupDialogProc;
        }
    }

    // lock the original 16-bit hDevMode & hDevNames so they won't get thrown
    // out by our thunking.  (we need to restore them to the original handles
    // if there is an error in PrintDlg() ).
    hDM16 = WORD32(pPD16->hDevMode);
    hDN16 = WORD32(pPD16->hDevNames);
    WOWGlobalLock16(hDM16);
    WOWGlobalLock16(hDN16);

    dwFlags16 = DWORD32(pPD16->Flags);

    // get a new 32-bit devmode struct
    PD32.hDevMode  = ThunkhDevMode16to32(WORD32(pPD16->hDevMode));

    // get a new 32-bit devnames struct
    PD32.hDevNames = ThunkhDevNames16to32(WORD32(pPD16->hDevNames));

    ThunkPRINTDLG16to32(&PD32, pPD16);

    GETVDMPTR(vppd, sizeof(PRINTDLGDATA16), pPD16);

    // this call invalidates flat ptrs to 16-bit memory
    PD32.hPrintTemplate
              = ThunkCDTemplate16to32(WORD32(pPD16->hInstance),
                                      MAKELONG(WORD32(pPD16->hPrintTemplate),1),
                                      DWORD32(pPD16->lpPrintTemplateName),
                                      dwFlags16,
                                      &(PD32.Flags),
                                      PD_ENABLEPRINTTEMPLATE,
                                      PD_ENABLEPRINTTEMPLATEHANDLE,
                                      &hPrintRes,
                                      &fError);

    if(fError) {
        goto PrintDlgError;
    }

    // memory may have moved - invalidate flat pointers now
    FREEVDMPTR(pPD16);

    GETVDMPTR(vppd, sizeof(PRINTDLGDATA16), pPD16);

    // this call invalidates flat ptrs to 16-bit memory
    PD32.hSetupTemplate
              = ThunkCDTemplate16to32(WORD32(pPD16->hInstance),
                                      MAKELONG(WORD32(pPD16->hSetupTemplate),1),
                                      DWORD32(pPD16->lpSetupTemplateName),
                                      dwFlags16,
                                      &(PD32.Flags),
                                      PD_ENABLESETUPTEMPLATE,
                                      PD_ENABLESETUPTEMPLATEHANDLE,
                                      &hSetupRes,
                                      &fError);

PrintDlgError:
    if(fError) {
        WOWGlobalUnlock16(hDM16);
        WOWGlobalUnlock16(hDN16);
        goto PrintDlgExit;
    }

    // memory may have moved - invalidate flat pointers now
    FREEVDMPTR(pPD16);

    WCDDUMPPRINTDLGDATA32(&PD32);

    // Set this just before the calling into comdlg32.  This prevents the
    // synchronization stuff from firing until we actually need it.
    CURRENTPTD()->CommDlgTd = &ThreadData;

    ul = GETBOOL16(PrintDlg(&PD32));

    CURRENTPTD()->CommDlgTd = ThreadData.Previous;

    // blow away our locks so these really can be free'd if needed
    WOWGlobalUnlock16(hDM16);
    WOWGlobalUnlock16(hDN16);

    if(ul) {

        WCDDUMPPRINTDLGDATA32(&PD32);

        // this call invalidates flat ptrs to 16-bit mem
        ThunkPRINTDLG32to16(vppd, &PD32);

        GETVDMPTR(vppd, sizeof(PRINTDLGDATA16), pPD16);

        WCDDUMPPRINTDLGDATA16(pPD16);

        // throw out the old ones if the structs were updated
        if(WORD32(pPD16->hDevMode) != hDM16) {
            WOWGlobalFree16(hDM16);
        }
        if(WORD32(pPD16->hDevNames) != hDN16) {
            WOWGlobalFree16(hDN16);
        }

    } else {

        // throw away any new hDevMode's & hDevNames that we might have created
        // as a result of our thunking & restore the originals
        GETVDMPTR(vppd, sizeof(PRINTDLGDATA16), pPD16);
        if(WORD32(pPD16->hDevMode) != hDM16) {
            WOWGlobalFree16(WORD32(pPD16->hDevMode));
            STOREWORD(pPD16->hDevMode, hDM16);
        }
        if(WORD32(pPD16->hDevNames) != hDN16) {
            WOWGlobalFree16(WORD32(pPD16->hDevNames));
            STOREWORD(pPD16->hDevNames, hDN16);
        }
    }

PrintDlgExit:

    WOWGLOBALFREE(PD32.hDevMode);
    WOWGLOBALFREE(PD32.hDevNames);

    if(PD32.hPrintTemplate) {
        FreeCDTemplate32(hPrintRes,
                         PD32.hPrintTemplate,
                         dwFlags16 & PD_ENABLEPRINTTEMPLATE,
                         dwFlags16 & PD_ENABLEPRINTTEMPLATEHANDLE);
    }

    if(PD32.hSetupTemplate) {
        FreeCDTemplate32(hSetupRes,
                         PD32.hSetupTemplate,
                         dwFlags16 & PD_ENABLESETUPTEMPLATE,
                         dwFlags16 & PD_ENABLESETUPTEMPLATEHANDLE);
    }

    FREEVDMPTR(pPD16);

    return(ul);
}


#define PD_TEMPLATEMASK32        (PD_ENABLEPRINTTEMPLATE         | \
                                  PD_ENABLESETUPTEMPLATE)

#define PD_TEMPLATEHANDLEMASK32  (PD_ENABLEPRINTTEMPLATEHANDLE   | \
                                  PD_ENABLESETUPTEMPLATEHANDLE)



VOID
ThunkPRINTDLG16to32(OUT PRINTDLG        *pPD32,
                    IN  PPRINTDLGDATA16  pPD16)
{
    DWORD  Flags;
    HANDLE h32New;
    LPVOID lp32New;
    LPVOID lp32Cur;

    if(pPD16 && pPD32) {

        pPD32->lStructSize = sizeof(PRINTDLG);
        pPD32->hwndOwner   = HWND32(pPD16->hwndOwner);

        // get a new 32-bit devmode thunked from the 16-bit one...
        if(h32New = ThunkhDevMode16to32(WORD32(pPD16->hDevMode))) {
            lp32New = GlobalLock(h32New);
            lp32Cur = GlobalLock(pPD32->hDevMode);

            // ...and copy it over the current 32-bit devmode struct
            if(lp32New && lp32Cur) {
                RtlCopyMemory(lp32Cur,
                              lp32New,
                              ((LPDEVMODE)lp32New)->dmSize);
                GlobalUnlock(pPD32->hDevMode);
                GlobalUnlock(h32New);
            }
            WOWGLOBALFREE(h32New);
        }

        // we assume that the DEVNAMES struct will never change

        // hDC filled on output only

        // preserve the template flag state while copying flags
        // 1. save original template flags
        //     note: we never set the 32-bit PD_ENABLExxxxTEMPLATE flags
        // 2. copy flags from 16-bit struct (and add WOWAPP flag)
        // 3. turn off all template flags
        // 4. restore original template flag state
        Flags         = pPD32->Flags & PD_TEMPLATEHANDLEMASK32;
        pPD32->Flags  = DWORD32(pPD16->Flags) | CD_WOWAPP;
        pPD32->Flags &= ~(PD_TEMPLATEMASK32 | PD_TEMPLATEHANDLEMASK32);
        pPD32->Flags |= Flags;

        pPD32->nFromPage   = WORD32(pPD16->nFromPage);
        pPD32->nToPage     = WORD32(pPD16->nToPage);
        pPD32->nMinPage    = WORD32(pPD16->nMinPage);
        pPD32->nMaxPage    = WORD32(pPD16->nMaxPage);
        pPD32->nCopies     = WORD32(pPD16->nCopies);
        pPD32->lCustData   = DWORD32(pPD16->lCustData);

        // hInstance thunked separately

        // hPrintTemplate & hSetupTemplate thunked separately
    }

}



#define PD_TEMPLATEMASK16  (PD_ENABLEPRINTTEMPLATE         | \
                            PD_ENABLESETUPTEMPLATE         | \
                            PD_ENABLEPRINTTEMPLATEHANDLE   | \
                            PD_ENABLESETUPTEMPLATEHANDLE)

VOID
ThunkPRINTDLG32to16(IN  VPVOID    vppd,
                    OUT PRINTDLG *pPD32)
{
    HAND16           hDevMode16;
    HAND16           hDevNames16;
    PPRINTDLGDATA16  pPD16;
    DWORD            Flags, Flags16;


    GETVDMPTR(vppd, sizeof(PRINTDLGDATA16), pPD16);

    if(pPD16 && pPD32) {

        if(pPD32->Flags & (PD_RETURNIC | PD_RETURNDC)) {
            STOREWORD(pPD16->hDC, GETHDC16(pPD32->hDC));
        }

        // thunk 32-bit DEVMODE structure back to 16-bit
        // hDevXXXX16 take care of RISC alignment problems
        hDevMode16  = WORD32(pPD16->hDevMode);
        hDevNames16 = WORD32(pPD16->hDevNames);

        // this call invalidates flat ptrs to 16-bit mem
        ThunkhDevMode32to16(&hDevMode16, pPD32->hDevMode);
        FREEVDMPTR(pPD16);

        GETVDMPTR(vppd, sizeof(PRINTDLGDATA16), pPD16);

        // this call invalidates flat ptrs to 16-bit mem
        ThunkhDevNames32to16(&hDevNames16, pPD32->hDevNames);
        FREEVDMPTR(pPD16);

        GETVDMPTR(vppd, sizeof(PRINTDLGDATA16), pPD16);

        STOREWORD(pPD16->hDevMode, hDevMode16);
        STOREWORD(pPD16->hDevNames, hDevNames16);

        // preserve the template flag state while copying flags
        // 1. save original template flags
        // 2. copy flags from 32-bit struct
        // 3. turn off all template flags and WOWAPP flag
        // 4. restore original template flag state
        Flags    = DWORD32(pPD16->Flags) & PD_TEMPLATEMASK16;
        Flags16  = pPD32->Flags;
        Flags16 &= ~(PD_TEMPLATEMASK16 | CD_WOWAPP);
        Flags16 |= Flags;
        STOREDWORD(pPD16->Flags, Flags16);

        STOREWORD(pPD16->nFromPage, GETUINT16(pPD32->nFromPage));
        STOREWORD(pPD16->nToPage,   GETUINT16(pPD32->nToPage));
        STOREWORD(pPD16->nMinPage,  GETUINT16(pPD32->nMinPage));
        STOREWORD(pPD16->nMaxPage,  GETUINT16(pPD32->nMaxPage));
        STOREWORD(pPD16->nCopies,   GETUINT16(pPD32->nCopies));
        FREEVDMPTR(pPD16);
    }
}





HGLOBAL
ThunkhDevMode16to32(IN HAND16 hDevMode16)
{
    INT         nSize;
    LPDEVMODE   lpdm32, pdm32;
    HGLOBAL     hDevMode32 = NULL;
    VPDEVMODE31 vpDevMode16;


    if (hDevMode16) {

        vpDevMode16 = GlobalLock16(hDevMode16, NULL);

        if(FETCHDWORD(vpDevMode16)) {

            if(pdm32 = ThunkDevMode16to32(vpDevMode16)) {

                nSize = FETCHWORD(pdm32->dmSize) +
                        FETCHWORD(pdm32->dmDriverExtra);

                hDevMode32 = WOWGLOBALALLOC(GMEM_MOVEABLE, nSize);

                if(lpdm32 = GlobalLock(hDevMode32)) {
                    RtlCopyMemory((PVOID)lpdm32, (PVOID)pdm32, nSize);
                    GlobalUnlock(hDevMode32);
                }

                free_w(pdm32);
            }
            GlobalUnlock16(hDevMode16);
        }
    }

    return(hDevMode32);
}





VOID
ThunkhDevMode32to16(IN OUT HAND16 *phDevMode16,
                    IN     HANDLE  hDevMode32)
/*++

Routine Description:

    This routine thunks a 32-bit DevMode structure back into the 16-bit one.
    It will reallocate the 16-bit global memory block as necessary.

    WARNING: This may cause 16-bit memory to move, invalidating flat pointers.

Arguments:

    hDevMode    - Supplies a handle to a movable global memory object that
                  contains a 32-bit DEVMODE structure

    phDevMode16 - Supplies a pointer to a 16-bit handle to a movable global
                  memory object that will return the 16-bit DEVMODE structure.
                  If the handle is NULL, the object will be allocated.  It
                  may also be reallocated if its current size is not enough.

Return Value:

    None

--*/
{
    UINT        CurrentSize;
    UINT        RequiredSize;
    VPDEVMODE31 vpDevMode16;
    LPDEVMODE   lpDevMode32;

    if (hDevMode32 == NULL) {
        *phDevMode16 = (HAND16)NULL;
        return;
    }

    lpDevMode32 = GlobalLock(hDevMode32);
    if (lpDevMode32==NULL) {
        *phDevMode16 = (HAND16)NULL;
        return;
    }

    RequiredSize = lpDevMode32->dmSize        +
                   lpDevMode32->dmDriverExtra +
                   sizeof(WOWDM31);  // see notes in wstruc.c

    if (*phDevMode16 == (HAND16)NULL) {
        vpDevMode16 = GlobalAllocLock16(GMEM_MOVEABLE,
                                        RequiredSize,
                                        phDevMode16);
    } else {
        vpDevMode16 = GlobalLock16(*phDevMode16, &CurrentSize);

        if (CurrentSize < RequiredSize) {
            GlobalUnlockFree16(vpDevMode16);
            vpDevMode16 = GlobalAllocLock16(GMEM_MOVEABLE,
                                            RequiredSize,
                                            phDevMode16);
        }
    }

    if(ThunkDevMode32to16(vpDevMode16, lpDevMode32, RequiredSize)) {
        GlobalUnlock16(*phDevMode16);
    }
    else {
        *phDevMode16 = (HAND16)NULL;
    }

    GlobalUnlock(hDevMode32);
}




HANDLE
ThunkhDevNames16to32(IN HAND16 hDevNames16)
{
    INT         nSize;
    HANDLE      hDN32 = NULL;
    LPDEVNAMES  pdn32;
    PDEVNAMES16 pdn16;


    if(FETCHDWORD(hDevNames16)) {

        VPDEVNAMES vpDevNames;

        vpDevNames = GlobalLock16(hDevNames16, &nSize);

        if(nSize) {

            GETVDMPTR(vpDevNames, sizeof(DEVNAMES16), pdn16);

            if(pdn16) {

                hDN32 = WOWGLOBALALLOC(GMEM_MOVEABLE, nSize);

                if(pdn32 = GlobalLock(hDN32)) {
                    RtlCopyMemory((PVOID)pdn32, (PVOID)pdn16, nSize);
                    GlobalUnlock(hDN32);
                } else {
                    LOGDEBUG(0, ("ThunkhDEVNAMES16to32, 32-bit allocation(s) failed!\n"));
                }

                FREEVDMPTR(pdn16);
            }
            GlobalUnlock16(hDevNames16);
        }

    }

    return(hDN32);
}




VOID
ThunkhDevNames32to16(IN OUT HAND16 *phDevNames16,
                     IN     HANDLE  hDevNames)
/*++

Routine Description:

    This routine thunks a 32-bit DevNames structure back into the 16-bit one.
    It will reallocate the 16-bit global memory block as necessary.

    WARNING: This may cause 16-bit memory to move, invalidating flat pointers.

Arguments:

    hDevNames - Supplies a handle to a movable global memory object that
               contains a 32-bit DEVNAMES structure

    phDevNames16 - Supplies a pointer to a 16-bit handle to a movable global
               memory object that will return the 16-bit DEVNAMES structure.
               If the handle is NULL, the object will be allocated.  It
               may also be reallocated if its current size is not enough.

Return Value:

    None

--*/
{
    UINT CurrentSize;
    UINT RequiredSize;
    UINT CopySize;
    UINT MaxOffset;
    PDEVNAMES16 pdn16;
    VPDEVNAMES DevNames16;
    LPDEVNAMES DevNames32;


    if (hDevNames==NULL) {
        *phDevNames16=(HAND16)NULL;
        return;
    }

    DevNames32 = GlobalLock(hDevNames);
    if (DevNames32==NULL) {
        *phDevNames16=(HAND16)NULL;
    }
    MaxOffset = max(max(DevNames32->wDriverOffset,DevNames32->wDeviceOffset),
                    DevNames32->wOutputOffset);

    // ProComm Plus copies 0x48 constant bytes after Print Setup.
    CopySize = MaxOffset + strlen((PCHAR)DevNames32+MaxOffset) + 1;
    RequiredSize = max(CopySize, 0x48);

    if (*phDevNames16==(HAND16)NULL) {
        DevNames16 = GlobalAllocLock16(GMEM_MOVEABLE,
                                       RequiredSize,
                                       phDevNames16);
    } else {
        DevNames16 = GlobalLock16(*phDevNames16, &CurrentSize);
        if (CurrentSize < RequiredSize) {
            GlobalUnlockFree16(DevNames16);
            DevNames16 = GlobalAllocLock16(GMEM_MOVEABLE,
                                           RequiredSize,
                                           phDevNames16);
        }
    }

    GETVDMPTR(DevNames16, RequiredSize, pdn16);
    if (pdn16==NULL) {
        *phDevNames16=(HAND16)NULL;
        GlobalUnlock(hDevNames);
        return;
    }
    RtlCopyMemory(pdn16,DevNames32,CopySize);
    FREEVDMPTR(pdn16);
    GlobalUnlock16(*phDevNames16);
    GlobalUnlock(hDevNames);
}






ULONG FASTCALL
WCD32GetOpenFileName( PVDMFRAME pFrame )
/*++

Routine Description:

    This routine thunks the 16-bit GetOpenFileName common dialog to the
    32-bit side.

Arguments:

    pFrame - Supplies 16-bit argument frame

Return Value:

    16-bit BOOLEAN to be returned.

--*/
{
    return(WCD32GetFileName(pFrame,GetOpenFileName));
}




ULONG FASTCALL
WCD32GetSaveFileName( PVDMFRAME pFrame )
/*++

Routine Description:

    This routine thunks the 16-bit GetOpenFileName common dialog to the
    32-bit side.

Arguments:

    pFrame - Supplies 16-bit argument frame

Return Value:

    16-bit BOOLEAN to be returned.

--*/
{
    return(WCD32GetFileName(pFrame,GetSaveFileName));
}





ULONG
WCD32GetFileName(IN PVDMFRAME pFrame,
                 IN FILENAMEPROC Function)
/*++

Routine Description:

    This routine is called by WCD32GetOpenFileName and WCD32GetSaveFileName.
    It does all the real thunking work.

Arguments:

    pFrame - Supplies 16-bit argument frame

    Function - supplies a pointer to the 32-bit function to call (either
               GetOpenFileName or GetSaveFileName)

Return Value:

    16-bit BOOLEAN to be returned.

--*/
{
    ULONG                       ul = 0;
    register PGETOPENFILENAME16 parg16;
    VPOPENFILENAME              vpof;
    OPENFILENAME                OFN32;
    POPENFILENAME16             pOFN16;
    COMMDLGTD                   ThreadData;
    PRES                        pRes = NULL;
    DWORD                       dwFlags16 = 0;
    USHORT                      cb;
    PBYTE                       lpcb;
    BOOL                        fError = FALSE;


    GETARGPTR(pFrame, sizeof(GETOPENFILENAME16), parg16);
    vpof = parg16->lpof;

    SETEXTENDEDERROR(0);

    // invalidate this now
    FREEARGPTR(parg16);

    // initialize unique window messages
    if (msgFILEOK == 0) {

        if(!(msgSHAREVIOLATION = (WORD)RegisterWindowMessage(SHAREVISTRING))) {
            SETEXTENDEDERROR( CDERR_REGISTERMSGFAIL );
            LOGDEBUG(2,("WCD32GetFileName:RegisterWindowMessage failed\n"));
            return(0);
        }
        if(!(msgFILEOK = (WORD)RegisterWindowMessage(FILEOKSTRING))) {
            SETEXTENDEDERROR( CDERR_REGISTERMSGFAIL );
            LOGDEBUG(2,("WCD32GetFileName:RegisterWindowMessage 2 failed\n"));
            return(0);
        }

        // initialize private WOW-comdlg32 message
        msgWOWDIRCHANGE = (WORD)RegisterWindowMessage("WOWDirChange");
    }

    GETVDMPTR(vpof, sizeof(OPENFILENAME16), pOFN16);

    WCDDUMPOPENFILENAME16(pOFN16);

    if(DWORD32(pOFN16->lStructSize) != sizeof(OPENFILENAME16)) {
        SETEXTENDEDERROR( CDERR_STRUCTSIZE );
        FREEVDMPTR(pOFN16);
        return(0);
    }

    RtlZeroMemory(&ThreadData, sizeof(COMMDLGTD));
    ThreadData.Previous = CURRENTPTD()->CommDlgTd;
    ThreadData.hdlg     = (HWND16)-1;
    ThreadData.pData32  = (PVOID)&OFN32;
    ThreadData.Flags    = WOWCD_ISOPENFILE;
    if(DWORD32(pOFN16->Flags) & OFN_ENABLEHOOK) {
        ThreadData.vpfnHook = DWORD32(pOFN16->lpfnHook);
        if(!ThreadData.vpfnHook) {
            SETEXTENDEDERROR(CDERR_NOHOOK);
            FREEVDMPTR(pOFN16);
            return(0);
        }
        ThreadData.vpData   = vpof;
    }
    RtlZeroMemory(&OFN32, sizeof(OPENFILENAME));

    if(!Alloc_OFN32_strs(&OFN32, pOFN16)) {
        SETEXTENDEDERROR(CDERR_MEMALLOCFAILURE);
        goto GetFileNameExit;
    }

    // On Win3.1, the system sets these flags in the app's struct under the
    // shown conditions so we need to update the 16-bit struct too.
    dwFlags16 = DWORD32(pOFN16->Flags);
    if(dwFlags16 & OFN_CREATEPROMPT) {
        dwFlags16 |= OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
    }
    else if(dwFlags16 & OFN_FILEMUSTEXIST) {
        dwFlags16 |= OFN_PATHMUSTEXIST;
    }

    // A bug in Serif PagePlus 3.0 sets the high word to 0xFFFF which causes
    // the new moniker stuff in comdlg32 to break. #148137 - cmjones
    // VadimB: the mask below causes apps that do want lfn to break, so check
    // for those apps via the compat flag and let them go unpunished

    if ((dwFlags16 & OFN_LONGNAMES) &&
        (CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_ALLOWLFNDIALOGS)) {
          dwFlags16 = (dwFlags16 & VALID_OFN16_FLAGS) | OFN_LONGNAMES;
    }
    else {
          dwFlags16 &= VALID_OFN16_FLAGS;
    }

    STOREDWORD(pOFN16->Flags, dwFlags16);

    if(!ThunkOPENFILENAME16to32(&OFN32, pOFN16)) {
        SETEXTENDEDERROR(CDERR_MEMALLOCFAILURE);
        goto GetFileNameExit;
    }

    dwFlags16 = DWORD32(pOFN16->Flags);  // get updated flags

    // make sure the current directory is up to date
    UpdateDosCurrentDirectory(DIR_DOS_TO_NT);

    // this call invalidates flat ptrs to 16-bit memory
    OFN32.hInstance = ThunkCDTemplate16to32(WORD32(pOFN16->hInstance),
                                            0,
                                            DWORD32(pOFN16->lpTemplateName),
                                            dwFlags16,
                                            &(OFN32.Flags),
                                            OFN_ENABLETEMPLATE,
                                            OFN_ENABLETEMPLATEHANDLE,
                                            &pRes,
                                            &fError);

    if(fError) {
        goto GetFileNameExit;
    }

    // memory may move - free flat pointers now
    FREEVDMPTR(pOFN16);

    WCDDUMPOPENFILENAME32(&OFN32);

    // Set this just before the calling into comdlg32.  This prevents the
    // synchronization stuff from firing until we actually need it.
    CURRENTPTD()->CommDlgTd = &ThreadData;

    // this call invalidates flat ptrs to 16-bit memory
    ul = GETBOOL16((*Function)(&OFN32));

    CURRENTPTD()->CommDlgTd = ThreadData.Previous;

    WCDDUMPOPENFILENAME32(&OFN32);

    UpdateDosCurrentDirectory(DIR_NT_TO_DOS);

    GETVDMPTR(vpof, sizeof(OPENFILENAME16), pOFN16);

    if (ul) {
        ThunkOPENFILENAME32to16(pOFN16, &OFN32, TRUE);

    }

    // else if the buffer is too small, lpstrFile contains the required buffer
    // size for the specified file
    else if (CommDlgExtendedError() == FNERR_BUFFERTOOSMALL) {

        SETEXTENDEDERROR(FNERR_BUFFERTOOSMALL);

        if(OFN32.lpstrFile && pOFN16->lpstrFile) {

            cb = *((PUSHORT)(OFN32.lpstrFile));  // is a WORD for comdlg32 too

            // 3 is the documented minimum size of the lpstrFile buffer
            GETVDMPTR(pOFN16->lpstrFile, 3, lpcb);

            // Win3.1 assumes that lpstrFile buffer is at least 3 bytes long
            // we'll try to be a little smarter than that...
            if(lpcb && (cb > pOFN16->nMaxFile)) {

                if(pOFN16->nMaxFile)
                    lpcb[0] = LOBYTE(cb);
                if(pOFN16->nMaxFile > 1)
                    lpcb[1] = HIBYTE(cb);
                if(pOFN16->nMaxFile > 2)
                    lpcb[2] = 0;  // Win3.1 appends a NULL

                FREEVDMPTR(lpcb);
            }
        }
    }

    WCDDUMPOPENFILENAME16(pOFN16);

GetFileNameExit:

    FreeCDTemplate32(pRes,
                     OFN32.hInstance,
                     dwFlags16 & OFN_ENABLETEMPLATE,
                     dwFlags16 & OFN_ENABLETEMPLATEHANDLE);

    Free_OFN32_strs(&OFN32);

    FREEVDMPTR(pOFN16);

    return(ul);
}




BOOL
ThunkOPENFILENAME16to32(OUT OPENFILENAME    *pOFN32,
                        IN  POPENFILENAME16  pOFN16)
/*++

Routine Description:

    This routine thunks a 16-bit OPENFILENAME structure to the 32-bit
    OPENFILENAME structure

Arguments:

    pOFN16 - Supplies a flat pointer to the 16-bit OPENFILENAME structure.

    pOFN32 - Supplies a pointer to the 32-bit OPENFILENAME structure.

Return Value:

    None.

--*/
{
    DWORD Flags;

    if(pOFN16 && pOFN32) {

        // Re-thunk all of the strings!!!
        // Persuasion 3.0 changes the various ptrs to strings depending on which
        // dialog buttons are pushed so we might have to dynamically re-alloc
        // some of the 32-bit string buffers.
        Thunk_OFNstrs16to32(pOFN32, pOFN16);

        pOFN32->lStructSize    = sizeof(OPENFILENAME);
        pOFN32->hwndOwner      = HWND32(pOFN16->hwndOwner);
        // hInstance thunked separately
        pOFN32->nMaxCustFilter = DWORD32(pOFN16->nMaxCustFilter);
        pOFN32->nFilterIndex   = DWORD32(pOFN16->nFilterIndex);
        pOFN32->nMaxFile       = DWORD32(pOFN16->nMaxFile);
        pOFN32->nMaxFileTitle  = DWORD32(pOFN16->nMaxFileTitle);

        // preserve the template flag state while copying flags
        // 1. save template flag state
        //     note: we never will have a 32-bit OFN_ENABLETEMPLATE flag
        //           we may or may not have a OFN_ENABLETEMPLATEHANDLE flag
        // 2. copy flags from 16-bit struct
        // 3. turn off all template flags
        // 4. restore original template flag state
        // 5. add the WOWAPP and no-long-names flags
        Flags          = pOFN32->Flags & OFN_ENABLETEMPLATEHANDLE;
        pOFN32->Flags  = DWORD32(pOFN16->Flags);
        pOFN32->Flags &= ~(OFN_ENABLETEMPLATE | OFN_ENABLETEMPLATEHANDLE);
        pOFN32->Flags |= Flags;

        if ((pOFN32->Flags & OFN_LONGNAMES) &&
            (CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_ALLOWLFNDIALOGS)) {
            pOFN32->Flags |= CD_WOWAPP;
        }
        else {
            pOFN32->Flags |= (OFN_NOLONGNAMES | CD_WOWAPP);
        }

        pOFN32->nFileOffset    = WORD32(pOFN16->nFileOffset);
        pOFN32->nFileExtension = WORD32(pOFN16->nFileExtension);
        pOFN32->lCustData      = DWORD32(pOFN16->lCustData);
        if(DWORD32(pOFN16->Flags) & OFN_ENABLEHOOK) {
            pOFN32->lpfnHook   = WCD32DialogProc;
        }
        // lpTemplateName32 is thunked separately

        // This is a hack to fix a bug in Win3.1 commdlg.dll.
        // Win3.1 doesn't check nMaxFileTitle before copying the FileTitle str.
        // (see Win3.1 src's \\pucus\win31aro\src\sdk\commdlg\fileopen.c)
        // TaxCut'95 depends on the title string being returned.
        if(pOFN32->lpstrFileTitle) {

            // if nMaxFileTitle > 0, NT will copy lpstrFileTitle
            if(pOFN32->nMaxFileTitle == 0) {
                pOFN32->nMaxFileTitle = 13;  // 8.3 filename + NULL
            }
        }

        return(TRUE);
    }

    return(FALSE);
}





VOID
ThunkOPENFILENAME32to16(OUT POPENFILENAME16  pOFN16,
                        IN  OPENFILENAME    *pOFN32,
                        IN  BOOLEAN          bUpperStrings)
/*++

Routine Description:

    This routine thunks a 32-bit OPENFILENAME structure back to a 16-bit
    OPENFILENAME structure.

Arguments:

    pOFN32 - Supplies a pointer to the 32-bit OPENFILENAME struct.

    pOFN16 - Supplies a flat pointer to the 16-bit OPENFILENAME struct

Return Value:

    None.

--*/
{
    LPSTR lpstr;
    DWORD Flags, Flags32;


    if(pOFN16 && pOFN32) {

        STOREWORD(pOFN16->nFileOffset,    pOFN32->nFileOffset);
        STOREWORD(pOFN16->nFileExtension, pOFN32->nFileExtension);
        STOREDWORD(pOFN16->nFilterIndex,  pOFN32->nFilterIndex);

        // preserve the template flag state while copying flags
        // 1. save template flag state
        // 2. copy flags from 32-bit struct
        // 3. turn off all template flags and the WOWAPP flag
        // 4. restore original template flag state
        Flags    = DWORD32(pOFN16->Flags) & (OFN_ENABLETEMPLATE |
                                             OFN_ENABLETEMPLATEHANDLE);
        Flags32  = pOFN32->Flags;
        Flags32 &= ~(OFN_ENABLETEMPLATE | OFN_ENABLETEMPLATEHANDLE | CD_WOWAPP);
        Flags32 |= Flags;
        STOREDWORD(pOFN16->Flags, Flags32);

        if(bUpperStrings && pOFN32->lpstrFile) {

            // Note we have to upcase the pOFN32 here because some apps
            // (notably QC/Win) do case-sensitive compares on the extension.
            // In Win3.1, the upcasing happens as a side-effect of the
            // OpenFile call.  Here we do it explicitly.
            CharUpperBuff(pOFN32->lpstrFile, strlen(pOFN32->lpstrFile));
        }
        GETPSZPTR(pOFN16->lpstrFile, lpstr);
        if(lpstr && pOFN32->lpstrFile) {
            strcpy(lpstr,  pOFN32->lpstrFile);
            FREEPSZPTR(lpstr);
        }

        GETPSZPTR(pOFN16->lpstrFilter, lpstr);
        if(lpstr && pOFN32->lpstrFilter) {
            Multi_strcpy(lpstr, pOFN32->lpstrFilter);
            FREEPSZPTR(lpstr);
        }

        GETPSZPTR(pOFN16->lpstrCustomFilter, lpstr);
        if(lpstr && pOFN32->lpstrCustomFilter) {
            Multi_strcpy(lpstr, pOFN32->lpstrCustomFilter);
            FREEPSZPTR(lpstr);
        }

        if(bUpperStrings && (pOFN32->lpstrFileTitle)) {

            // Not sure if we really need to upcase this or not, but I figure
            // somewhere there is an app that depends on this being uppercased
            // like Win3.1
            CharUpperBuff(pOFN32->lpstrFileTitle,
                          strlen(pOFN32->lpstrFileTitle));
        }
        GETPSZPTR(pOFN16->lpstrFileTitle , lpstr);
        if(lpstr && pOFN32->lpstrFileTitle) {
            strcpy(lpstr, pOFN32->lpstrFileTitle);
            FREEPSZPTR(lpstr);
        }

        // even though this is doc'd as being filled by the app only, Adobe
        // distiller depends on it being copied back to the app
        GETPSZPTR(pOFN16->lpstrInitialDir , lpstr);
        if(lpstr && pOFN32->lpstrInitialDir) {
            strcpy(lpstr, pOFN32->lpstrInitialDir);
            FREEPSZPTR(lpstr);
        }

        // who knows who depends on this
        GETPSZPTR(pOFN16->lpstrTitle, lpstr);
        if(lpstr && pOFN32->lpstrTitle) {
            strcpy(lpstr, pOFN32->lpstrTitle);
            FREEPSZPTR(lpstr);
        }
    }
}




BOOL
Alloc_OFN32_strs(IN OPENFILENAME    *pOFN32,
                 IN POPENFILENAME16  pOFN16)
{

    if(DWORD32(pOFN16->lpstrFilter)) {
        if(!(pOFN32->lpstrFilter =
                malloc_w_strcpy_vp16to32(DWORD32(pOFN16->lpstrFilter),
                                         TRUE,
                                         0))) {
            goto ErrorExit;
        }
    }

    if(DWORD32(pOFN16->lpstrCustomFilter)) {
        if(!(pOFN32->lpstrCustomFilter =
                malloc_w_strcpy_vp16to32(DWORD32(pOFN16->lpstrCustomFilter),
                                         TRUE,
                                         DWORD32(pOFN16->nMaxCustFilter) ))) {
            goto ErrorExit;
        }
    }

    if(DWORD32(pOFN16->lpstrFile)) {
        if(!(pOFN32->lpstrFile =
                malloc_w_strcpy_vp16to32(DWORD32(pOFN16->lpstrFile),
                                         FALSE,
                                         DWORD32(pOFN16->nMaxFile) ))) {
            goto ErrorExit;
        }
    }

    if(DWORD32(pOFN16->lpstrFileTitle)) {
        if(!(pOFN32->lpstrFileTitle =
                malloc_w_strcpy_vp16to32(DWORD32(pOFN16->lpstrFileTitle),
                                         FALSE,
                                         DWORD32(pOFN16->nMaxFileTitle) ))) {
            goto ErrorExit;
        }
    }

    if(DWORD32(pOFN16->lpstrInitialDir)) {
        if(!(pOFN32->lpstrInitialDir =
                malloc_w_strcpy_vp16to32(DWORD32(pOFN16->lpstrInitialDir),
                                         FALSE,
                                         0))) {
            goto ErrorExit;
        }
    }

    if(DWORD32(pOFN16->lpstrTitle)) {
        if(!(pOFN32->lpstrTitle =
                malloc_w_strcpy_vp16to32(DWORD32(pOFN16->lpstrTitle),
                                         FALSE,
                                         0))) {
            goto ErrorExit;
        }
    }

    if(DWORD32(pOFN16->lpstrDefExt)) {
        if(!(pOFN32->lpstrDefExt =
                malloc_w_strcpy_vp16to32(DWORD32(pOFN16->lpstrDefExt),
                                         FALSE,
                                         0))) {
            goto ErrorExit;
        }
    }

    return(TRUE);

ErrorExit:
    LOGDEBUG(0, ("Alloc_OFN32_strs, 32-bit allocation(s) failed!\n"));
    Free_OFN32_strs(pOFN32);
    return(FALSE);

}





VOID
Free_OFN32_strs(IN OPENFILENAME *pOFN32)
{
    if(pOFN32->lpstrFilter) {
        free_w((PVOID)pOFN32->lpstrFilter);
        pOFN32->lpstrFilter = NULL;
    }

    if(pOFN32->lpstrCustomFilter) {
        free_w((PVOID)pOFN32->lpstrCustomFilter);
        pOFN32->lpstrCustomFilter = NULL;
    }

    if(pOFN32->lpstrFile) {
        free_w((PVOID)pOFN32->lpstrFile);
        pOFN32->lpstrFile = NULL;
    }

    if(pOFN32->lpstrFileTitle) {
        free_w((PVOID)pOFN32->lpstrFileTitle);
        pOFN32->lpstrFileTitle = NULL;
    }

    if(pOFN32->lpstrInitialDir) {
        free_w((PVOID)pOFN32->lpstrInitialDir);
        pOFN32->lpstrInitialDir = NULL;
    }

    if(pOFN32->lpstrTitle) {
        free_w((PVOID)pOFN32->lpstrTitle);
        pOFN32->lpstrTitle = NULL;
    }

    if(pOFN32->lpstrDefExt) {
        free_w((PVOID)pOFN32->lpstrDefExt);
        pOFN32->lpstrDefExt = NULL;
    }
}




VOID
Thunk_OFNstrs16to32(IN OPENFILENAME    *pOFN32,
                    IN POPENFILENAME16  pOFN16)
{
   pOFN32->lpstrFilter
                  = ThunkStr16toStr32((LPSTR)pOFN32->lpstrFilter,
                                      DWORD32(pOFN16->lpstrFilter),
                                      MAX_PATH,
                                      TRUE);

   pOFN32->lpstrCustomFilter
                  = ThunkStr16toStr32(pOFN32->lpstrCustomFilter,
                                      DWORD32(pOFN16->lpstrCustomFilter),
                                      DWORD32(pOFN16->nMaxCustFilter),
                                      TRUE);

   pOFN32->lpstrFile
                  = ThunkStr16toStr32(pOFN32->lpstrFile,
                                      DWORD32(pOFN16->lpstrFile),
                                      DWORD32(pOFN16->nMaxFile),
                                      FALSE);

   pOFN32->lpstrFileTitle
                  = ThunkStr16toStr32(pOFN32->lpstrFileTitle,
                                      DWORD32(pOFN16->lpstrFileTitle),
                                      DWORD32(pOFN16->nMaxFileTitle),
                                      FALSE);

   pOFN32->lpstrInitialDir
                  = ThunkStr16toStr32((LPSTR)pOFN32->lpstrInitialDir,
                                      DWORD32(pOFN16->lpstrInitialDir),
                                      MAX_PATH,
                                      FALSE);

   pOFN32->lpstrTitle
                  = ThunkStr16toStr32((LPSTR)pOFN32->lpstrTitle,
                                      DWORD32(pOFN16->lpstrTitle),
                                      MAX_PATH,
                                      FALSE);

   pOFN32->lpstrDefExt
                  = ThunkStr16toStr32((LPSTR)pOFN32->lpstrDefExt,
                                      DWORD32(pOFN16->lpstrDefExt),
                                      10,
                                      FALSE);
}




ULONG FASTCALL
WCD32FindText(PVDMFRAME pFrame)
/*++

Routine Description:

    This routine thunks the 16-bit FindText common dialog to the
    32-bit side.

Arguments:

    pFrame - Supplies 16-bit argument frame

Return Value:

    16-bit BOOLEAN to be returned.

--*/
{
    return(WCD32FindReplaceText(pFrame, FindText));
}





ULONG FASTCALL
WCD32ReplaceText(PVDMFRAME pFrame)
/*++

Routine Description:

    This routine thunks the 16-bit ReplaceText common dialog to the
    32-bit side.

Arguments:

    pFrame - Supplies 16-bit argument frame

Return Value:

    16-bit BOOLEAN to be returned.

--*/
{
    return(WCD32FindReplaceText(pFrame, ReplaceText));
}




ULONG
WCD32FindReplaceText(IN PVDMFRAME       pFrame,
                     IN FINDREPLACEPROC Function)
/*++

Routine Description:

    This routine is called by WCD32FindText and WCD32RepalceText.
    It copies a 16-bit FINDREPLACE structure to a 32-bit structure.
    Two per thread data entries are maintained. One is indexed by the
    owner hwnd, the other is indexed by the dialog hwnd. The dialog is
    always hooked by WCD32FindReplaceDialogProc, which dispatches to the
    16-bit hookproc, and takes care of clean-up on  WM_DESTROY, with dialog
    per thread data providing context. WCD32UpdateFindReplaceTextAndFlags
    updates the 16-bit FINDREPLACE structure when called by the WOW message
    dispatching logic upon reciept of a WM_NOTIFYWOW message from COMDLG32.
    The owner per thread data provides context for this operation.

Arguments:

    pFrame - Supplies 16-bit argument frame

    Function - supplies a pointer to the 32-bit function to call (either
               FindText or RepalceText)

Return Value:

    16-bit BOOLEAN to be returned.

--*/
{
    register PFINDTEXT16  parg16;
    VPFINDREPLACE         vpfr;
    FINDREPLACE          *pFR32;
    PFINDREPLACE16        pFR16;
    PCOMMDLGTD            pTDDlg;
    PCOMMDLGTD            pTDOwner;
    HWND                  hwndDlg = NULL;
    DWORD                 dwFlags16 = 0;
    BOOL                  fError = FALSE;


    GETARGPTR(pFrame, sizeof(FINDREPLACE16), parg16);
    vpfr = parg16->lpfr;

    SETEXTENDEDERROR(0);

    // invalidate this now
    FREEVDMPTR( parg16 );

    GETVDMPTR(vpfr, sizeof(FINDREPLACE16), pFR16);

    WCDDUMPFINDREPLACE16(pFR16);

    if(DWORD32(pFR16->lStructSize) != sizeof(FINDREPLACE16)) {
        SETEXTENDEDERROR( CDERR_STRUCTSIZE );
        FREEVDMPTR(pFR16);
        return(0);
    }

    if(!DWORD32(pFR16->lpstrFindWhat) ||
       !WORD32(pFR16->wFindWhatLen) ||
       !IsWindow(HWND32(pFR16->hwndOwner))) {
        SETEXTENDEDERROR(FRERR_BUFFERLENGTHZERO);
        FREEVDMPTR(pFR16);
        return(0);
    }

    // check the hook proc
    if(DWORD32(pFR16->Flags) & FR_ENABLEHOOK) {
        if(!DWORD32(pFR16->lpfnHook)) {
            SETEXTENDEDERROR(CDERR_NOHOOK);
            FREEVDMPTR(pFR16);
            return(0);
        }
    }
    else {
        STOREDWORD(pFR16->lpfnHook, 0);
    }

    // WCD32UpdateFindReplaceTextAndFlags will update the 16-bit FINDREPLACE
    // struct and help thunk the WM_NOTIFYWOW message to the
    // "commdlg_FindReplace" registered message.
    if (msgFINDREPLACE == 0) {
        if(!(msgFINDREPLACE = (WORD)RegisterWindowMessage(FINDMSGSTRING))) {
            LOGDEBUG(2,("WCD32FindReplaceText:RegisterWindowMessage failed\n"));
            SETEXTENDEDERROR( CDERR_REGISTERMSGFAIL );
            FREEVDMPTR(pFR16);
            return(0);
        }
    }

    // Allocate the required memory
    // Note: these can't be alloc'd off our stack since FindText & ReplaceText
    //       eventually call CreateDialogIndirectParam which returns immediately
    //       after displaying the dialog box.
    pFR32 = (FINDREPLACE *)malloc_w_zero(sizeof(FINDREPLACE));
    if(pFR32) {
        pFR32->lpstrFindWhat = (LPTSTR)malloc_w(WORD32(pFR16->wFindWhatLen));
        pFR32->lpstrReplaceWith
                             = (LPTSTR)malloc_w(WORD32(pFR16->wReplaceWithLen));
        pTDDlg   = malloc_w_zero(sizeof(COMMDLGTD));
        pTDOwner = malloc_w_zero(sizeof(COMMDLGTD));
    }

    if(  (pFR32                    &&
          pFR32->lpstrFindWhat     &&
          pFR32->lpstrReplaceWith  &&
          pTDDlg                   &&
          pTDOwner) == FALSE) {

        LOGDEBUG(0, ("WCD32FindReplaceText, 32-bit allocation(s) failed!\n"));
        SETEXTENDEDERROR(CDERR_MEMALLOCFAILURE);
        goto FindReplaceError;
    }

    pTDDlg->pData32 = pTDOwner->pData32 = (PVOID)pFR32;
    pTDDlg->vpData  = pTDOwner->vpData  = vpfr;

    // Set the per thread data indicies
    pTDDlg->hdlg   = (HWND16)-1;
    pTDOwner->hdlg = GETHWND16(pFR16->hwndOwner);

    // save the hook proc if any
    if(DWORD32(pFR16->Flags) & FR_ENABLEHOOK) {
        pTDDlg->vpfnHook = pTDOwner->vpfnHook = DWORD32(pFR16->lpfnHook);
    }

    ThunkFINDREPLACE16to32(pFR32, pFR16);
    dwFlags16 = DWORD32(pFR16->Flags);

    // this call invalidates flat ptrs to 16-bit memory
    pFR32->hInstance = ThunkCDTemplate16to32(WORD32(pFR16->hInstance),
                                             0,
                                             DWORD32(pFR16->lpTemplateName),
                                             dwFlags16,
                                             &(pFR32->Flags),
                                             FR_ENABLETEMPLATE,
                                             FR_ENABLETEMPLATEHANDLE,
                                             &(PRES)(pTDDlg->pRes),
                                             &fError);

    if(fError) {
        goto FindReplaceError;
    }

    // invalidate flat ptrs to 16-bit memory
    FREEVDMPTR(pFR16);

    WCDDUMPFINDREPLACE32(pFR32);

    // Link both per thread data structs into the list
    // do this just before calling into comdlg32
    pTDDlg->Previous        = CURRENTPTD()->CommDlgTd;
    pTDOwner->Previous      = pTDDlg;
    CURRENTPTD()->CommDlgTd = pTDOwner;

    // this call invalidates flat ptrs to 16-bit memory
    hwndDlg = (*Function)(pFR32);

    if (hwndDlg) {
        pTDDlg->hdlg = (HWND16)hwndDlg;
    } else {

FindReplaceError:
        LOGDEBUG(0, ("WCD32FindReplaceText, Failed!\n"));
        if(pTDDlg) {

            CURRENTPTD()->CommDlgTd = pTDDlg->Previous;

            FreeCDTemplate32(pTDDlg->pRes,
                             pFR32->hInstance,
                             dwFlags16 & FR_ENABLETEMPLATE,
                             dwFlags16 & FR_ENABLETEMPLATEHANDLE);
            free_w(pTDDlg);
        }

        if(pFR32) {

            if(pFR32->lpstrFindWhat)
                free_w(pFR32->lpstrFindWhat);

            if(pFR32->lpstrReplaceWith)
                free_w(pFR32->lpstrReplaceWith);

            free_w(pFR32);
        }

        if(pTDOwner)
            free_w(pTDOwner);
    }

    return(GETHWND16(hwndDlg));
}





VOID
ThunkFINDREPLACE16to32(OUT FINDREPLACE    *pFR32,
                       IN  PFINDREPLACE16  pFR16)
/*++

Routine Description:

    This routine thunks a 16-bit FINDREPLACE structure to the 32-bit
    structure

Arguments:

    pFR32 - Supplies a pointer to the 32-bit FINDREPLACE structure.

    pFR16 - Supplies a pointer to the 16-bit FINDREPLACE structure.

Return Value:

    None.

--*/
{
    LPSTR  lpstr;
    DWORD  Flags;


    if(pFR16 && pFR32) {

        pFR32->lStructSize = sizeof(FINDREPLACE);
        pFR32->hwndOwner   = HWND32(pFR16->hwndOwner);

        // hInstance is thunked separately

        // preserve the template flag state while copying flags
        // 1. save template flag state
        //     note: we never will have a 32-bit FR_ENABLETEMPLATE flag
        // 2. copy flags from 16-bit struct (add the WOWAPP flag)
        // 3. turn off all template flags
        // 4. restore original template flag state
        Flags         = pFR32->Flags & FR_ENABLETEMPLATEHANDLE;
        pFR32->Flags  = DWORD32(pFR16->Flags) | CD_WOWAPP;
        pFR32->Flags &= ~(FR_ENABLETEMPLATE | FR_ENABLETEMPLATEHANDLE);
        pFR32->Flags |= Flags;

        GETPSZPTR(pFR16->lpstrFindWhat, lpstr);
        if(lpstr && pFR32->lpstrFindWhat) {
            WOW32_strncpy(pFR32->lpstrFindWhat, lpstr, WORD32(pFR16->wFindWhatLen));
            FREEPSZPTR(lpstr);
        }

        GETPSZPTR(pFR16->lpstrReplaceWith, lpstr);
        if(lpstr && pFR32->lpstrReplaceWith) {
            WOW32_strncpy(pFR32->lpstrReplaceWith,
                    lpstr,
                    WORD32(pFR16->wReplaceWithLen));
            FREEPSZPTR(lpstr);
        }

        pFR32->wFindWhatLen    = WORD32(pFR16->wFindWhatLen);
        pFR32->wReplaceWithLen = WORD32(pFR16->wReplaceWithLen);
        pFR32->lCustData       = DWORD32(pFR16->lCustData);

        // we always put this WOW hook in so we can destroy the modeless dialog.
        // WCD32FindReplaceDialogPRoc will determine whether to really dispatch
        // to a 16-bit hookproc or not.  pFR16->lpfnHook will be NULL if there
        // isn't a 16-bit hook proc
        pFR32->lpfnHook  = WCD32FindReplaceDialogProc;
        pFR32->Flags    |= FR_ENABLEHOOK;

        // lpTemplateName32 is thunked separately
    }
}





VOID
ThunkFINDREPLACE32to16(OUT PFINDREPLACE16  pFR16,
                       IN  FINDREPLACE    *pFR32)
{
    LPSTR  lpstr;
    DWORD  Flags, Flags32;


    if(pFR16 && pFR32) {

        // Update the 16-bit structure.

        // preserve the template flag state while copying flags
        // 1. save template flag state
        // 2. copy flags from 32-bit struct
        // 3. turn off all template flags and the WOWAPP flag
        // 4. restore original template flag state
        Flags    = DWORD32(pFR16->Flags) & (FR_ENABLETEMPLATE |
                                            FR_ENABLETEMPLATEHANDLE);
        Flags32  = pFR32->Flags;
        Flags32 &= ~(FR_ENABLETEMPLATE | FR_ENABLETEMPLATEHANDLE | CD_WOWAPP);
        Flags32 |= Flags;

        // we may have to turn off the hookproc flag if we added it in
        // ThunkFINDREPLACE16to32().
        if(!DWORD32(pFR16->lpfnHook)) {
            Flags32 &= ~FR_ENABLEHOOK;
        }
        STOREDWORD(pFR16->Flags, Flags32);

        GETPSZPTR(pFR16->lpstrFindWhat, lpstr);
        if(lpstr && pFR32->lpstrFindWhat) {
            WOW32_strncpy(lpstr, pFR32->lpstrFindWhat, WORD32(pFR16->wFindWhatLen));
            FREEPSZPTR(lpstr);
        }

        GETPSZPTR(pFR16->lpstrReplaceWith, lpstr);
        if(lpstr && pFR32->lpstrReplaceWith) {
            WOW32_strncpy(lpstr,
                    pFR32->lpstrReplaceWith,
                    WORD32(pFR16->wReplaceWithLen));
            FREEPSZPTR(lpstr);
        }
    }
}





LONG APIENTRY
WCD32UpdateFindReplaceTextAndFlags(HWND hwndOwner,
                                   LPARAM lParam)
{
    PCOMMDLGTD           ptdOwner;
    PFINDREPLACE16       pFR16;
    VPFINDREPLACE        vpfr;
    LPFINDREPLACE        pFR32 = (LPFINDREPLACE) lParam;
    LONG                 lRet = 0;


    ptdOwner = GetCommdlgTd(hwndOwner);
    WOW32ASSERT(ptdOwner);

    vpfr = ptdOwner->vpData;
    GETVDMPTR(vpfr, sizeof(FINDREPLACE16), pFR16);

    ThunkFINDREPLACE32to16(pFR16, pFR32);

    WCDDUMPFINDREPLACE16(pFR16);

    FREEVDMPTR(pFR16);

    return(vpfr);
}





PCOMMDLGTD
GetCommdlgTd(IN HWND Hwnd32)
/*++

Routine Description:

    Searches the thread's chain of commdlg data for the given 32-bit window.
    If the window is not already in the chain, it is added.

Arguments:

    Hwnd32 - Supplies the 32-bit hwnd that the dialog procedure was called
    with.

Return Value:

    Pointer to commdlg data.

--*/
{
    PCOMMDLGTD pTD;

    if ((pTD = CURRENTPTD()->CommDlgTd) == NULL) {
        return(NULL);
    }

    // look for the CommDlgTD struct for this dialog -- usually will be first
    // unless there are nested dialogs
    while (pTD->hdlg != GETHWND16(Hwnd32)) {

        pTD = pTD->Previous;

        // If Hwnd32 isn't in the list, we're probably getting called back
        // from user32 via WOWTellWOWThehDlg().  This means that the dialog
        // window was just created in user32.  Note that this can be either a
        // new dialog or a PrintSetup dialog.
        if (pTD==NULL) {

            pTD = CURRENTPTD()->CommDlgTd;

            while (pTD->hdlg != (HWND16)-1) {

                // Check to see if this is the first call for a PrintSetupHook.
                // It will share the same CommDlgTD as the PrintDlgHook.
                // Note: SetupHwnd will be 1 if this is the 1st time the user
                //       clicks the Setup button in the PrintDlg. Otherwise
                //       it will be the old Hwnd32 from the previous time he
                //       clicked the Setup button from within the same instance
                //       of the PrintDlg. Either way it is non-zero.
                if(pTD->SetupHwnd) {

                    // if the current CommDlgTD->hdlg is the owner of Hwnd32,
                    // we found the CommDlgTD for the PrintSetup dialog.
                    if(pTD->hdlg == GETHWND16(GetWindow(Hwnd32, GW_OWNER))) {
                        pTD->SetupHwnd = GETHWND16(Hwnd32);
                        return(pTD);
                    }
                }

                pTD = pTD->Previous;

                if(pTD == NULL) {
                    WOW32ASSERT(FALSE);
                    return(NULL);
                }
            }

            // set the hdlg for this CommDlgTD
            pTD->hdlg = GETHWND16(Hwnd32);
            return(pTD);
        }
    }

    return(pTD);
}





// Thunks 16-bit Common dialog templates to 32-bit
// Note: this calls back to 16-bit code causing possible 16-bit memory movement
// Note: GetTemplate16 call SETEXTENDEDERROR for *most* failures
HINSTANCE
ThunkCDTemplate16to32(IN     HAND16  hInst16,
                      IN     DWORD   hPT16,  // for PrintDlg only
                      IN     VPVOID  vpTemplateName,
                      IN     DWORD   dwFlags16,
                      IN OUT DWORD  *pFlags,
                      IN     DWORD   ETFlag,   // XX_ENABLETEMPLATE flag
                      IN     DWORD   ETHFlag,  // XX_ENABLETEMPLATEHANDLE flag
                      OUT    PPRES   pRes,
                      OUT    PBOOL   fError)
{
    // Note: struct->hInstance == NULL if neither xx_ENABLExxx flag is set
    HINSTANCE hInst32 = NULL;
    HAND16    hPrintTemp16 = (HAND16)NULL;


    SETEXTENDEDERROR( CDERR_NOTEMPLATE );  // most common error ret

    if(hPT16) {
        hPrintTemp16 = (HAND16)LOWORD(hPT16);
    }

    *pRes = NULL;
    if(dwFlags16 & ETFlag) {

        if(!vpTemplateName) {
            *fError = TRUE;
            return(NULL);
        }

        if(!hInst16) {
            SETEXTENDEDERROR( CDERR_NOHINSTANCE );
            *fError = TRUE;
            return(NULL);
        }

	    // Note: calls to GetTemplate16 may cause 16-bit memory to move
        *pRes = GetTemplate16(hInst16, vpTemplateName, FALSE);

	    if(*pRes == NULL) {
            *fError = TRUE;
            return(NULL);
        }

        hInst32 = (HINSTANCE)LockResource16(*pRes);

        if(!hInst32) {
            *fError = TRUE;
            SETEXTENDEDERROR( CDERR_LOCKRESFAILURE );
            return(NULL);
        }

        *pFlags &= ~ETFlag;
        *pFlags |= ETHFlag;

    } else if(dwFlags16 & ETHFlag) {

        // Win'95 does the following if !hInst && ETHFlag.
        // Note: the return val == FALSE in all cases except the last PD case
        //    CC  (0x00040) -> CDERR_NOTEMPLATE
        //    CF  (0x00020) -> No error (comdlg32 err = CDERR_LOCKRESFAILURE)
        //    FR  (0x02000) -> CDERR_LOCKRESFAILURE
        //    OFN (0x00080) -> CDERR_LOCKRESFAILURE
        //    PD  (0x10000) -> CDERR_LOCKRESFAILURE  (hInstance)
        //    PD  (0x20040) -> CDERR_LOCKRESFAILURE  (with PD_PRINTSETUP)
        //    PD  (0x20000) -> CDERR_LOCKRESFAILURE
        //
        // I think the error value is probably irrelavant since most of these
        // are pathological cases that only developers would see while building
        // and debugging their app.  In the cases where the Win'95 error code is
        // CDERR_LOCKRESFAILURE, comdlg32 sets it to CDERR_NOTEMPLATE (as we
        // now return for WOW) for 32-bit apps

        // one of the hTemplate's should always be set with the
        // ENABLETEMPLATEHANDLE flag

        // if it's a printdlg...
        if(hPT16) {

            // ...the hTemplate should be in either hPrintTemplate or
            // hPrintSetupTemplate
            if(!hPrintTemp16) {
                *fError = TRUE;
            }
        }

        // else for non-printdlg's, the hTemplate should be in hInstance
        else {
            if(!hInst16) {
                *fError = TRUE;
            }
        }

        if(*fError) {
            return(NULL);
        }

	    // Note: calls to GetTemplate16 may cause 16-bit memory to move
        if(hPT16) {
            hInst32 = (HINSTANCE) GetTemplate16(hPrintTemp16,(VPCSTR)NULL,TRUE);
        } else {
            hInst32 = (HINSTANCE) GetTemplate16(hInst16, (VPCSTR)NULL, TRUE);
        }
        if(!hInst32) {
            *fError = TRUE;
            return(NULL);
        }
        *pFlags |= ETHFlag;
    }

    SETEXTENDEDERROR( 0 ); // reset to no error

    return(hInst32);
}




VOID
FreeCDTemplate32(IN PRES      pRes,
                 IN HINSTANCE hInst,
                 IN BOOL      bETFlag,
                 IN BOOL      bETHFlag)
{
    if(pRes && bETFlag) {
        UnlockResource16(pRes);
        FreeResource16(pRes);
    } else if(hInst && bETHFlag) {
        free_w((PVOID)hInst);
    }
}



PRES
GetTemplate16(IN HAND16 hInstance,
              IN VPCSTR lpTemplateName,
              IN BOOLEAN UseHandle)
/*++

Routine Description:

    Finds and loads the specified 16-bit dialog template.

    WARNING: This may cause memory movement, invalidating flat pointers

Arguments:

    hInstance - Supplies the data block containing the dialog box template

    TemplateName - Supplies the name of the resource file for the dialog
        box template.  This may be either a null-terminated string or
        a numbered resource created with the MAKEINTRESOURCE macro.

    UseHandle - Indicates that hInstance identifies a pre-loaded dialog
        box template.  If this is TRUE, Templatename is ignored.

Return Value:

    success - A pointer to the loaded resource

    failure - NULL, dwLastError will be set.

--*/
{
    LPSZ    TemplateName=NULL;
    PRES    pRes;
    PBYTE   pDlg = NULL;
    INT     cb;
    INT     cb16;

    if (!UseHandle) {

        GETPSZIDPTR(lpTemplateName, TemplateName);

        // Both custom instance handle and the dialog template name are
        // specified.  Locate the 16-bit dialog resource in the specified
        // instance block and load it.
        pRes = FindResource16(hInstance,
                              TemplateName,
                              (LPSZ)RT_DIALOG);

        if (HIWORD(lpTemplateName) != 0) {
            FREEVDMPTR(TemplateName);
        }
        if (!pRes) {
            SETEXTENDEDERROR( CDERR_FINDRESFAILURE );
            return(NULL);
        }
        if (!(pRes = LoadResource16(hInstance,pRes))) {
            SETEXTENDEDERROR( CDERR_LOADRESFAILURE );
            return(NULL);
        }

        return(pRes);
    } else {

        VPVOID pDlg16;

        if (pDlg16 = RealLockResource16(hInstance, &cb16)) {
            cb = ConvertDialog16(NULL, pDlg16, 0, cb16);
            if (cb != 0) {
                if (pDlg = malloc_w(cb)) {
                    ConvertDialog16(pDlg, pDlg16, cb, cb16);
                }
            }
            GlobalUnlock16(hInstance);
        }
        else {
            SETEXTENDEDERROR( CDERR_LOCKRESFAILURE );
        }
        return((PRES)pDlg);
    }

}





// When an app calls a ComDlg API it passes a ptr to the appropriate structure.
// On Win3.1 the app & the system share a ptr to the same structure, so when
// either updates the struct, the other is aware of the change.  On NT we thunk
// the 16-bit struct to a 32-bit ANSI struct which is then thunked to a 32-bit
// UNICODE struct by the ComDlg32 code.  We need a mechanism to put all three
// structs in sync.  We attempt to do this by calling ThunkCDStruct32to16()
// from the WCD32xxxxDialogProc()'s (xxxx = Common OR FindReplace) for
// WM_INITDIALOG and WM_COMMAND messages before we callback the 16-bit hook
// proc.  We call ThunkCDStruct16to32() when we return from the 16-bit hook.
VOID
ThunkCDStruct16to32(IN HWND         hDlg,
                    IN CHOOSECOLOR *p32,
                    IN VPVOID       vp)
{

    PCHOOSECOLORDATA16  p16;

    GETVDMPTR(vp, sizeof(CHOOSECOLORDATA16), p16);

    if(p16) {

        switch(p16->lStructSize) {

            case sizeof(CHOOSECOLORDATA16):
                ThunkCHOOSECOLOR16to32(p32, p16);
                Ssync_ANSI_UNICODE_Struct_For_WOW(hDlg, TRUE, WOW_CHOOSECOLOR);
                break;

            case sizeof(CHOOSEFONTDATA16):
                ThunkCHOOSEFONT16to32((CHOOSEFONT *) p32,
                                      (PCHOOSEFONTDATA16) p16);
                Ssync_ANSI_UNICODE_Struct_For_WOW(hDlg, TRUE, WOW_CHOOSEFONT);
                break;

            case sizeof(FINDREPLACE16):
                ThunkFINDREPLACE16to32((FINDREPLACE *) p32,
                                       (PFINDREPLACE16) p16);
                // Find/Replace ANSI-UNICODE sync's are handled by
                // WCD32UpdateFindReplaceTextAndFlags() mechanism
                break;

            case sizeof(OPENFILENAME16):
                ThunkOPENFILENAME16to32((OPENFILENAME *) p32,
                                        (POPENFILENAME16) p16);
                Ssync_ANSI_UNICODE_Struct_For_WOW(hDlg, TRUE, WOW_OPENFILENAME);
                break;

            case sizeof(PRINTDLGDATA16):
                ThunkPRINTDLG16to32((PRINTDLG *) p32, (PPRINTDLGDATA16) p16);
                Ssync_ANSI_UNICODE_Struct_For_WOW(hDlg, TRUE, WOW_PRINTDLG);
                break;

        }

        FREEVDMPTR(p16);

    }
}





VOID
ThunkCDStruct32to16(IN HWND         hDlg,
                    IN VPVOID       vp,
                    IN CHOOSECOLOR *p32)
{

    PCHOOSECOLORDATA16  p16;

    GETVDMPTR(vp, sizeof(CHOOSECOLORDATA16), p16);

    if(p16) {

        switch(p16->lStructSize) {

            case sizeof(CHOOSECOLORDATA16):
                Ssync_ANSI_UNICODE_Struct_For_WOW(hDlg, FALSE, WOW_CHOOSECOLOR);
                ThunkCHOOSECOLOR32to16(p16, p32);
                break;

            case sizeof(CHOOSEFONTDATA16):
                Ssync_ANSI_UNICODE_Struct_For_WOW(hDlg, FALSE, WOW_CHOOSEFONT);
                ThunkCHOOSEFONT32to16((PCHOOSEFONTDATA16) p16,
                                      (CHOOSEFONT *) p32);
                break;

            case sizeof(FINDREPLACE16):
                // Find/Replace ANSI-UNICODE sync's are handled by
                // WCD32UpdateFindReplaceTextAndFlags() mechanism
                ThunkFINDREPLACE32to16((PFINDREPLACE16) p16,
                                       (FINDREPLACE *) p32);
                break;

            case sizeof(OPENFILENAME16):
                Ssync_ANSI_UNICODE_Struct_For_WOW(hDlg, FALSE, WOW_OPENFILENAME);
                ThunkOPENFILENAME32to16((POPENFILENAME16) p16,
                                        (OPENFILENAME *) p32,
                                        TRUE);
                break;

            case sizeof(PRINTDLGDATA16):
                Ssync_ANSI_UNICODE_Struct_For_WOW(hDlg, FALSE, WOW_PRINTDLG);
                ThunkPRINTDLG32to16(vp, (PRINTDLG *) p32);
                break;

        }

        FREEVDMPTR(p16);

    }
}




VOID Multi_strcpy(LPSTR dst, LPCSTR src)
/*++
  strcpy for string lists that have several strings that are separated by
  a null char and is terminated by two NULL chars.
--*/
{
    if(src && dst) {

        while(*src) {
            while(*dst++ = *src++)
                ;
        }
        *dst = '\0';
    }
}



INT Multi_strlen(LPCSTR str)
/*++
  strlen for string lists that have several strings that are separated by
  a null char and is terminated by two NULL chars.

  Returns len of str including all NULL *separators* but not the 2nd NULL
  terminator.  ie.  cat0dog00 would return len = 8;
--*/
{
    INT i = 0;

    if(str) {

        while(*str) {
            while(*str++)
                i++;
            i++;  // count the NULL separator
        }
    }

    return(i);
}




VOID Ssync_WOW_CommDlg_Structs(PCOMMDLGTD pTDIn,
                               BOOL f16to32,
                               DWORD dwThunkCSIP)
{
    HWND       hDlg;
    WORD       wCS16;
    PCOMMDLGTD pTDPrev;
    PCOMMDLGTD pTD = pTDIn;


    // we shouldn't sync for calls from krnl386 into wow32 (we found out)
    // eg. when kernel is handling segment not present faults etc.
    if(dwThunkCSIP) {

        wCS16 = HIWORD(dwThunkCSIP);

        if((wCS16 == gwKrnl386CodeSeg1) ||
           (wCS16 == gwKrnl386CodeSeg2) ||
           (wCS16 == gwKrnl386CodeSeg3))    {
                return;
        }
    }

    // since we don't have an hwnd to compare with we really don't know which
    // PCOMMDLGTD is the one we want -- so we have to sync them all.
    // This is only a problem for nested dialogs which is fairly rare.
    while(pTD) {

        // if this hasn't been initialized yet there is nothing to do
        if(pTD->hdlg == (HWND16)-1) {
            break;
        }

        hDlg = HWND32(pTD->hdlg);

        WOW32ASSERTMSG(hDlg,
                       ("WOW:Ssync_WOW_CommDlg_Structs: hDlg not found!\n"));

        //BlockWOWIdle(TRUE);

        if(f16to32) {
            ThunkCDStruct16to32(hDlg, (CHOOSECOLOR *)pTD->pData32, pTD->vpData);
        }
        else {
            ThunkCDStruct32to16(hDlg, pTD->vpData, (CHOOSECOLOR *)pTD->pData32);
        }

        //BlockWOWIdle(FALSE);

        pTDPrev = pTD->Previous;

        // multiple PCOMMDLGTD's in the list means 1 of 2 things:
        //   1. This is a find/replace text dialog
        //   2. This is a screwy nested dialog situation
        if(pTDPrev) {

            // 1. check for find/replace (it uses two PCOMMDLGTD structs and
            //    shares the same pData32 pointer with both)
            if(pTDPrev->pData32 == pTD->pData32) {

                // nothing to do -- they share the same data which was thunked
                // above so we'll go on to the next PCOMMDLGTD in the list
                pTD = pTDPrev->Previous;
            }

            // 2. there are nested dialogs lurking about & we need to sync
            //    each one!
            else {
                pTD = pTDPrev;
            }
        } else {
            break;
        }
    }
}




// There is a special case issue (we found) where certain dialog box
// API calls can pass a pszptr that is in a common dialog struct ie:
// GetDlgItemText(hDlg, id, OFN16->lpstrFile, size).  Our synchronization
// mechanism actually trashes OFN16->lpstrFile when we sync 32->16 upon
// returning from the API call.  To avoid this we will sync 16->32 upon
// returning from the API call (if needed as per the conditions below)
// before we sync 32->16 thus preserving the string returned in the 16-bit
// buffer.  The special case API's identified so far are:
//   GetDlgItemText, GetWindowText(), DlgDirSelectxxxx, and SendDlgItemMessage.
VOID Check_ComDlg_pszptr(PCOMMDLGTD ptd, VPVOID vp)
{
    VPVOID             vpData;
    POPENFILENAME16    p16;


    if(ptd) {

        vpData = ptd->vpData;
        if(vpData) {

            GETVDMPTR(vpData, sizeof(CHOOSECOLORDATA16), p16);

            if(p16) {

                switch(p16->lStructSize) {

                    // Only these 2 ComDlg structures have OUTPUT buffers.

                    case sizeof(CHOOSEFONTDATA16):
                        if((VPVOID)((PCHOOSEFONTDATA16)p16)->lpszStyle == vp) {
                            Ssync_WOW_CommDlg_Structs(ptd, w16to32, 0);
                        }
                        break;

                    case sizeof(OPENFILENAME16):
                        if(((VPVOID)p16->lpstrFilter       == vp) ||
                           ((VPVOID)p16->lpstrCustomFilter == vp) ||
                           ((VPVOID)p16->lpstrFile         == vp) ||
                           ((VPVOID)p16->lpstrFileTitle    == vp) ||
                           ((VPVOID)p16->lpstrInitialDir   == vp) ||
                           ((VPVOID)p16->lpstrTitle        == vp) ||
                           ((VPVOID)p16->lpstrDefExt       == vp))   {

                            Ssync_WOW_CommDlg_Structs(ptd, w16to32, 0);
                        }

                        break;

                } // end switch
            }
        }
    }
}




VOID FASTCALL WOWTellWOWThehDlg(HWND hDlg)
{

    if(CURRENTPTD()->CommDlgTd) {
        if(GetCommdlgTd(hDlg) == NULL) {
            WOW32WARNMSGF(FALSE,
                          ("WOW::WOWTellWOWThehDlg: No unassigned hDlgs\n"));
        }
    }

}





#ifdef DEBUG
void WCDDumpCHOOSECOLORData16(PCHOOSECOLORDATA16 p16)
{
    if (fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("CHOOSECOLORDATA16:\n"));
        LOGDEBUG(10, ("\tlStructSize      = %x\n",(p16)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner        = %lx\n",(p16)->hwndOwner));
        LOGDEBUG(10, ("\thInstance        = %lx\n",(p16)->hInstance));
        LOGDEBUG(10, ("\trgbResult        = %lx\n",(p16)->rgbResult));
        LOGDEBUG(10, ("\tlpCustColors     = %lx\n",(p16)->lpCustColors));
        LOGDEBUG(10, ("\tFlags            = %lx\n",(p16)->Flags));
        LOGDEBUG(10, ("\tlCustData        = %lx\n",(p16)->lCustData));
        LOGDEBUG(10, ("\tlpfnHook         = %lx\n",(p16)->lpfnHook));
        LOGDEBUG(10, ("\tlpTemplateName = %lx\n",(p16)->lpTemplateName));
    }
}


void WCDDumpCHOOSECOLORData32(CHOOSECOLOR *p32)
{
    if (fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("CHOOSECOLORDATA32:\n"));
        LOGDEBUG(10, ("\tlStructSize      = %x\n",(p32)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner        = %lx\n",(p32)->hwndOwner));
        LOGDEBUG(10, ("\thInstance        = %lx\n",(p32)->hInstance));
        LOGDEBUG(10, ("\trgbResult        = %lx\n",(p32)->rgbResult));
        LOGDEBUG(10, ("\tlpCustColors     = %lx\n",(p32)->lpCustColors));
        LOGDEBUG(10, ("\tFlags            = %lx\n",(p32)->Flags));
        LOGDEBUG(10, ("\tlCustData        = %lx\n",(p32)->lCustData));
        LOGDEBUG(10, ("\tlpfnHook         = %lx\n",(p32)->lpfnHook));
        LOGDEBUG(10, ("\tlpTemplateName = %lx\n",(p32)->lpTemplateName));
    }
}


void WCDDumpCHOOSEFONTData16(PCHOOSEFONTDATA16 p16)
{
    if (fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("CHOOSEFONT16:\n"));
        LOGDEBUG(10, ("\tlStructSize   = %lx\n",(p16)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner     = %lx\n",(p16)->hwndOwner));
        LOGDEBUG(10, ("\thDC           = %lx\n",(p16)->hDC));
        LOGDEBUG(10, ("\tlpLogFont     = %lx\n",(p16)->lpLogFont));
        LOGDEBUG(10, ("\tiPointSize    = %x\n",(p16)->iPointSize));
        LOGDEBUG(10, ("\tiFlags        = %lx\n",(p16)->Flags));
        LOGDEBUG(10, ("\trbgColors     = %lx\n",(p16)->rgbColors));
        LOGDEBUG(10, ("\tlCustData     = %lx\n",(p16)->lCustData));
        LOGDEBUG(10, ("\tlpfnHook      = %lx\n",(p16)->lpfnHook));
        LOGDEBUG(10, ("\tlpTemplateName= %lx\n",(p16)->lpTemplateName));
        LOGDEBUG(10, ("\thInstance     = %lx\n",(p16)->hInstance));
        LOGDEBUG(10, ("\tlpszStyle     = %lx\n",(p16)->lpszStyle));
        LOGDEBUG(10, ("\tnFontType     = %x\n",(p16)->nFontType));
        LOGDEBUG(10, ("\tnSizeMin      = %x\n",(p16)->nSizeMin));
        LOGDEBUG(10, ("\tnSizeMax      = %x\n",(p16)->nSizeMax));
    }
}


void WCDDumpCHOOSEFONTData32(CHOOSEFONT *p32)
{
    if (fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("CHOOSEFONT32:\n"));
        LOGDEBUG(10, ("\tlStructSize   = %lx\n",(p32)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner     = %lx\n",(p32)->hwndOwner));
        LOGDEBUG(10, ("\thDC           = %lx\n",(p32)->hDC));
        LOGDEBUG(10, ("\tlpLogFont     = %lx\n",(p32)->lpLogFont));
        LOGDEBUG(10, ("\tiPointSize    = %lx\n",(p32)->iPointSize));
        LOGDEBUG(10, ("\tiFlags        = %lx\n",(p32)->Flags));
        LOGDEBUG(10, ("\trbgColors     = %lx\n",(p32)->rgbColors));
        LOGDEBUG(10, ("\tlCustData     = %lx\n",(p32)->lCustData));
        LOGDEBUG(10, ("\tlpfnHook      = %lx\n",(p32)->lpfnHook));
        LOGDEBUG(10, ("\tlpTemplateName= %lx\n",(p32)->lpTemplateName));
        LOGDEBUG(10, ("\thInstance     = %lx\n",(p32)->hInstance));
        LOGDEBUG(10, ("\tlpszStyle     = %lx\n",(p32)->lpszStyle));
        LOGDEBUG(10, ("\tnFontType     = %x\n",(p32)->nFontType));
        LOGDEBUG(10, ("\tnSizeMin      = %lx\n",(p32)->nSizeMin));
        LOGDEBUG(10, ("\tnSizeMax      = %lx\n",(p32)->nSizeMax));
    }
}


void WCDDumpFINDREPLACE16(PFINDREPLACE16 p16)
{
    if (fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("FINDREPLACE16:\n"));
        LOGDEBUG(10, ("\tlStructSize      = %lx\n",(p16)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner        = %x\n",(p16)->hwndOwner));
        LOGDEBUG(10, ("\thInstance        = %x\n",(p16)->hInstance));
        LOGDEBUG(10, ("\tFlags            = %x\n",(p16)->Flags));
        LOGDEBUG(10, ("\tlpstrFindWhat    = %lx\n",(p16)->lpstrFindWhat));
        LOGDEBUG(10, ("\tlpstrReplaceWith = %lx\n",(p16)->lpstrReplaceWith));
        LOGDEBUG(10, ("\twFindWhatLen     = %x\n",(p16)->wFindWhatLen));
        LOGDEBUG(10, ("\twReplaceWithLen  = %x\n",(p16)->wReplaceWithLen));
        LOGDEBUG(10, ("\tlCustData     = %lx\n",(p16)->lCustData));
        LOGDEBUG(10, ("\tlpfnHook      = %lx\n",(p16)->lpfnHook));
        LOGDEBUG(10, ("\tlpTemplateName= %lx\n",(p16)->lpTemplateName));
    }
}


void WCDDumpFINDREPLACE32(FINDREPLACE *p32)
{
    if (fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("FINDREPLACE32:\n"));
        LOGDEBUG(10, ("\tlStructSize      = %lx\n",(p32)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner        = %x\n",(p32)->hwndOwner));
        LOGDEBUG(10, ("\thInstance        = %x\n",(p32)->hInstance));
        LOGDEBUG(10, ("\tFlags            = %x\n",(p32)->Flags));
        LOGDEBUG(10, ("\tlpstrFindWhat    = %s\n",(p32)->lpstrFindWhat));
        LOGDEBUG(10, ("\tlpstrReplaceWith = %s\n",(p32)->lpstrReplaceWith));
        LOGDEBUG(10, ("\twFindWhatLen     = %x\n",(p32)->wFindWhatLen));
        LOGDEBUG(10, ("\twReplaceWithLen  = %x\n",(p32)->wReplaceWithLen));
        LOGDEBUG(10, ("\tlCustData     = %lx\n",(p32)->lCustData));
        LOGDEBUG(10, ("\tlpfnHook      = %lx\n",(p32)->lpfnHook));
        LOGDEBUG(10, ("\tlpTemplateName= %lx\n",(p32)->lpTemplateName));
    }
}


void WCDDumpOPENFILENAME16(POPENFILENAME16 p16)
{
    if (fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("OPENFILENAME16:\n"));
        LOGDEBUG(10, ("\tlStructSize      = %x\n",(p16)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner        = %lx\n",(p16)->hwndOwner));
        LOGDEBUG(10, ("\thInstance        = %lx\n",(p16)->hInstance));
        LOGDEBUG(10, ("\tlpstrFilter      = %lx\n",(p16)->lpstrFilter));
        LOGDEBUG(10, ("\tlpstrCustomFilter= %lx\n",(p16)->lpstrCustomFilter));
        LOGDEBUG(10, ("\tnMaxCustFilter   = %lx\n",(p16)->nMaxCustFilter));
        LOGDEBUG(10, ("\tnFilterIndex     = %lx\n",(p16)->nFilterIndex));
        LOGDEBUG(10, ("\tlpstrFile        = %lx\n",(p16)->lpstrFile));
        LOGDEBUG(10, ("\tnMaxFile         = %lx\n",(p16)->nMaxFile));
        LOGDEBUG(10, ("\tlpstrFileTitle   = %lx\n",(p16)->lpstrFileTitle));
        LOGDEBUG(10, ("\tnMaxFileTitle    = %lx\n",(p16)->nMaxFileTitle));
        LOGDEBUG(10, ("\tlpstrInitialDir  = %lx\n",(p16)->lpstrInitialDir));
        LOGDEBUG(10, ("\tlpstrTitle       = %lx\n",(p16)->lpstrTitle));
        LOGDEBUG(10, ("\tFlags            = %lx\n",(p16)->Flags));
        LOGDEBUG(10, ("\tnFileOffset      = %lx\n",(p16)->nFileOffset));
        LOGDEBUG(10, ("\tnFileExtension   = %lx\n",(p16)->nFileExtension));
        LOGDEBUG(10, ("\tlpstrDefExt      = %lx\n",(p16)->lpstrDefExt));
        LOGDEBUG(10, ("\tlCustData        = %lx\n",(p16)->lCustData));
        LOGDEBUG(10, ("\tlpfnHook         = %lx\n",(p16)->lpfnHook));
        LOGDEBUG(10, ("\tlpTemplateName   = %lx\n",(p16)->lpTemplateName));
    }
}


void WCDDumpOPENFILENAME32(OPENFILENAME *p32)
{
    if (fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("OPENFILENAME32:\n"));
        LOGDEBUG(10, ("\tlStructSize      = %x\n",(p32)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner        = %lx\n",(p32)->hwndOwner));
        LOGDEBUG(10, ("\thInstance        = %lx\n",(p32)->hInstance));
        LOGDEBUG(10, ("\tlpstrFilter      = %s\n",(p32)->lpstrFilter));
        LOGDEBUG(10, ("\tlpstrCustomFilter= %s\n",(p32)->lpstrCustomFilter));
        LOGDEBUG(10, ("\tnMaxCustFilter   = %lx\n",(p32)->nMaxCustFilter));
        LOGDEBUG(10, ("\tnFilterIndex     = %lx\n",(p32)->nFilterIndex));
        LOGDEBUG(10, ("\tlpstrFile        = %s\n",(p32)->lpstrFile));
        LOGDEBUG(10, ("\tnMaxFile         = %lx\n",(p32)->nMaxFile));
        LOGDEBUG(10, ("\tlpstrFileTitle   = %s\n",(p32)->lpstrFileTitle));
        LOGDEBUG(10, ("\tnMaxFileTitle    = %lx\n",(p32)->nMaxFileTitle));
        LOGDEBUG(10, ("\tlpstrInitialDir  = %s\n",(p32)->lpstrInitialDir));
        LOGDEBUG(10, ("\tlpstrTitle       = %s\n",(p32)->lpstrTitle));
        LOGDEBUG(10, ("\tFlags            = %lx\n",(p32)->Flags));
        LOGDEBUG(10, ("\tnFileOffset      = %lx\n",(p32)->nFileOffset));
        LOGDEBUG(10, ("\tnFileExtension   = %lx\n",(p32)->nFileExtension));
        LOGDEBUG(10, ("\tlpstrDefExt      = %s\n",(p32)->lpstrDefExt));
        LOGDEBUG(10, ("\tlCustData        = %lx\n",(p32)->lCustData));
        LOGDEBUG(10, ("\tlpfnHook         = %lx\n",(p32)->lpfnHook));
        LOGDEBUG(10, ("\tlpTemplateName   = %lx\n",(p32)->lpTemplateName));
    }
}


void WCDDumpPRINTDLGData16(PPRINTDLGDATA16 p16)
{
    if (fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("PRINTDLGData16:\n"));
        LOGDEBUG(10, ("\tlStructSize      = %x\n",(p16)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner        = %lx\n",(p16)->hwndOwner));
        LOGDEBUG(10, ("\thDevMode         = %lx\n",(p16)->hDevMode));
        LOGDEBUG(10, ("\thDevNames        = %lx\n",(p16)->hDevNames));
        LOGDEBUG(10, ("\thDC              = %lx\n",(p16)->hDC));
        LOGDEBUG(10, ("\tFlags            = %lx\n",(p16)->Flags));
        LOGDEBUG(10, ("\tnFromPage        = %d\n",(p16)->nFromPage));
        LOGDEBUG(10, ("\tnToPage          = %d\n",(p16)->nToPage));
        LOGDEBUG(10, ("\tnMinPage         = %d\n",(p16)->nMinPage));
        LOGDEBUG(10, ("\tnMaxPage         = %d\n",(p16)->nMaxPage));
        LOGDEBUG(10, ("\tnCopies          = %d\n",(p16)->nCopies));
        LOGDEBUG(10, ("\thInstance        = %lx\n",(p16)->hInstance));
        LOGDEBUG(10, ("\tlCustData        = %lx\n",(p16)->lCustData));
        LOGDEBUG(10, ("\tlpfnPrintHook    = %lx\n",(p16)->lpfnPrintHook));
        LOGDEBUG(10, ("\tlpfnSetupHook    = %lx\n",(p16)->lpfnSetupHook));
        LOGDEBUG(10, ("\tlpPrintTemplateName = %lx\n",(p16)->lpPrintTemplateName));
        LOGDEBUG(10, ("\tlpSetupTemplateName = %lx\n",(p16)->lpSetupTemplateName));
        LOGDEBUG(10, ("\thPrintTemplate   = %lx\n",(p16)->hPrintTemplate));
        LOGDEBUG(10, ("\thSetupTemplate   = %lx\n",(p16)->hSetupTemplate));
    }
}


void WCDDumpPRINTDLGData32(PRINTDLG *p32)
{
    if (fLogFilter & FILTER_COMMDLG) {
        LOGDEBUG(10, ("PRINTDLGData32:\n"));
        LOGDEBUG(10, ("\tlStructSize      = %x\n",(p32)->lStructSize));
        LOGDEBUG(10, ("\thwndOwner        = %lx\n",(p32)->hwndOwner));
        LOGDEBUG(10, ("\thDevMode         = %lx\n",(p32)->hDevMode));
        LOGDEBUG(10, ("\thDevNames        = %lx\n",(p32)->hDevNames));
        LOGDEBUG(10, ("\thDC              = %lx\n",(p32)->hDC));
        LOGDEBUG(10, ("\tFlags            = %lx\n",(p32)->Flags));
        LOGDEBUG(10, ("\tnFromPage        = %d\n",(p32)->nFromPage));
        LOGDEBUG(10, ("\tnToPage          = %d\n",(p32)->nToPage));
        LOGDEBUG(10, ("\tnMinPage         = %d\n",(p32)->nMinPage));
        LOGDEBUG(10, ("\tnMaxPage         = %d\n",(p32)->nMaxPage));
        LOGDEBUG(10, ("\tnCopies          = %d\n",(p32)->nCopies));
        LOGDEBUG(10, ("\thInstance        = %lx\n",(p32)->hInstance));
        LOGDEBUG(10, ("\tlCustData        = %lx\n",(p32)->lCustData));
        LOGDEBUG(10, ("\tlpfnPrintHook    = %lx\n",(p32)->lpfnPrintHook));
        LOGDEBUG(10, ("\tlpfnSetupHook    = %lx\n",(p32)->lpfnSetupHook));
        LOGDEBUG(10, ("\tlpPrintTemplateName = %lx\n",(p32)->lpPrintTemplateName));
        LOGDEBUG(10, ("\tlpSetupTemplateName = %lx\n",(p32)->lpSetupTemplateName));
        LOGDEBUG(10, ("\thPrintTemplate   = %lx\n",(p32)->hPrintTemplate));
        LOGDEBUG(10, ("\thSetupTemplate   = %lx\n",(p32)->hSetupTemplate));
    }
}

#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wcommdlg.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1993, Microsoft Corporation
 *
 *  WCOMDLG.H
 *  WOW32 16-bit COMMDLG support
 *
 *  History:
 *      John Vert (jvert) 31-Dec-1992 - created
--*/



ULONG FASTCALL   WCD32ChooseColor(PVDMFRAME pFrame);
ULONG FASTCALL   WCD32ChooseFont(PVDMFRAME pFrame);
ULONG FASTCALL   WCD32ExtendedError(PVDMFRAME pFrame);
ULONG FASTCALL   WCD32GetOpenFileName(PVDMFRAME pFrame);
ULONG FASTCALL   WCD32GetSaveFileName(PVDMFRAME pFrame);
ULONG FASTCALL   WCD32PrintDlg(PVDMFRAME pFrame);
ULONG FASTCALL   WCD32FindText(PVDMFRAME pFrame);
ULONG FASTCALL   WCD32ReplaceText(PVDMFRAME pFrame);

LONG APIENTRY WCD32UpdateFindReplaceTextAndFlags(HWND hwnd, LPARAM lParam);

VOID Multi_strcpy(LPSTR  dst, LPCSTR src);

INT  Multi_strlen(LPCSTR str);

VOID FASTCALL WOWTellWOWThehDlg(HWND hDlg);

VOID Check_ComDlg_pszptr(PCOMMDLGTD ptd, VPVOID vp);
VOID Ssync_WOW_CommDlg_Structs(PCOMMDLGTD pTD, BOOL f16to32, VPVOID wThunkCSIP);

// these flags are combined to form the dwStat parameter in
// Ssync_WOW_CommDlg_Structs() calls
#define  w32to16     0
#define  w16to32     1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wcntl32.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WMSG32.C
 *  WOW32 32-bit message thunks
 *
 *  History:
 *  Created 19-Feb-1992 by Chandan Chauhan (ChandanC)
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wcntl32.c);

// This function thunks the button control messages,
//
//  BM_GETCHECK
//  BM_SETCHECK
//  BM_GETSTATE
//  BM_SETSTATE
//  BM_SETSTYLE
//

BOOL FASTCALL WM32BMControl(LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - BM_GETCHECK));
    }

    return (TRUE);
}


BOOL FASTCALL WM32BMClick (LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WIN31_BM_CLICK);
    }

    return (TRUE);
}



// This function thunks the following edit control messages,
//
//  EM_GETSEL
//  EM_GETMODIFY
//  EM_SETMODIFY
//  EM_GETLINECOUNT
//  EM_GETLINEINDEX
//  EM_LINELENGTH
//  EM_LIMITTEX
//  EM_CANUNDO
//  EM_UNDO
//  EM_FMTLINES
//  EM_LINEFROMCHAR
//  EM_SETPASSWORDCHAR
//  EM_EMPTYUNDOBUFFER

BOOL FASTCALL WM32EMControl(LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
    }

    return (TRUE);
}


// This function thunks the button control messages,
//
//  EM_SETSEL
//

BOOL FASTCALL WM32EMSetSel (LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
        LOW(lpwm32mpex->Parm16.WndProc.lParam) = (WORD) lpwm32mpex->uParam;
        HIW(lpwm32mpex->Parm16.WndProc.lParam) = (WORD)
                    ((lpwm32mpex->lParam != -1) ? lpwm32mpex->lParam :  32767);
    }

    return (TRUE);
}


// This function thunks the edit control messages,
//
//  EM_GETRECT
//

BOOL FASTCALL WM32EMGetRect (LPWM32MSGPARAMEX lpwm32mpex)
{
    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
        lpwm32mpex->Parm16.WndProc.lParam = malloc16(sizeof(RECT16));
        if (!(lpwm32mpex->Parm16.WndProc.lParam))
            return FALSE;
    } else {
        GETRECT16( lpwm32mpex->Parm16.WndProc.lParam, (LPRECT)lpwm32mpex->lParam );
        if (lpwm32mpex->Parm16.WndProc.lParam)
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
    }

    return (TRUE);
}


// This function thunks the edit control messages,
//
//  EM_SETRECT
//  EM_SETRECTNP
//

BOOL FASTCALL WM32EMSetRect (LPWM32MSGPARAMEX lpwm32mpex)
{

    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
        lpwm32mpex->Parm16.WndProc.lParam = malloc16(sizeof(RECT16));
        if (!(lpwm32mpex->Parm16.WndProc.lParam))
            return FALSE;
        PUTRECT16( lpwm32mpex->Parm16.WndProc.lParam, (LPRECT)lpwm32mpex->lParam );
    } else {
        if (lpwm32mpex->Parm16.WndProc.lParam)
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
    }

    return (TRUE);
}


// This function thunks the edit control messages,
//
//  EM_LINESCROLL
//

BOOL FASTCALL WM32EMLineScroll (LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
        LOW(lpwm32mpex->Parm16.WndProc.lParam) = (WORD) lpwm32mpex->lParam;
        HIW(lpwm32mpex->Parm16.WndProc.lParam) = (WORD) lpwm32mpex->uParam;
    }

    return (TRUE);
}


// This function thunks the edit control messages,
//
//  EM_REPLACESEL
//

BOOL FASTCALL WM32EMReplaceSel (LPWM32MSGPARAMEX lpwm32mpex)
{

    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
        if (lpwm32mpex->lParam) {
            INT cb;

            cb = strlen((LPSZ)lpwm32mpex->lParam)+1;
            lpwm32mpex->dwTmp[0] = (DWORD)cb; // save allocation size

            // winworks2.0a requires DS based string pointers for this message

            if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_DSBASEDSTRINGPOINTERS) {

                // be sure allocation size matches stackfree16() size below
                lpwm32mpex->Parm16.WndProc.lParam = stackalloc16(cb);

            } else {
                lpwm32mpex->Parm16.WndProc.lParam = malloc16(cb);
            }

            if (!(lpwm32mpex->Parm16.WndProc.lParam))
                return FALSE;
            putstr16((VPSZ)lpwm32mpex->Parm16.WndProc.lParam, (LPSZ)lpwm32mpex->lParam, cb);
        }
    } else {
        if (lpwm32mpex->Parm16.WndProc.lParam) {
            if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_DSBASEDSTRINGPOINTERS) {

                stackfree16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam,
                            ((UINT)lpwm32mpex->dwTmp[0]));
            } else {
                free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
            }
        }
    }

    return (TRUE);
}


BOOL FASTCALL WM32EMSetFont (LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
    }

    LOGDEBUG(0,(" Window %08lX is receiving Control Message %s(%08x)\n", lpwm32mpex->hwnd, (LPSZ)GetWMMsgName(lpwm32mpex->uMsg), lpwm32mpex->uMsg));
    return (TRUE);
}


// This function thunks the edit control messages,
//
//  EM_GETLINE
//

BOOL FASTCALL WM32EMGetLine (LPWM32MSGPARAMEX lpwm32mpex)
{

    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
        if (lpwm32mpex->lParam) {
            INT cb;
            PBYTE lp;

            // the first WORD is what USER uses.

            cb = *(UNALIGNED WORD *)(lpwm32mpex->lParam);
            lpwm32mpex->Parm16.WndProc.lParam = malloc16(cb);
            if (!(lpwm32mpex->Parm16.WndProc.lParam))
                return FALSE;
            ALLOCVDMPTR(lpwm32mpex->Parm16.WndProc.lParam,2,lp);
            *((UNALIGNED WORD *)lp) = (WORD)cb;
            FLUSHVDMPTR(lpwm32mpex->Parm16.WndProc.lParam,2,lp);  /* first 2 bytes modified */
        }
    } else {
        if (lpwm32mpex->Parm16.WndProc.lParam) {
            PBYTE lp;

            GETMISCPTR(lpwm32mpex->Parm16.WndProc.lParam,lp);
            RtlCopyMemory((PBYTE)lpwm32mpex->lParam,lp,lpwm32mpex->lReturn);
            FREEVDMPTR(lp);
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
        }
    }

    LOGDEBUG(3,(" Window %08lX is receiving Control Message %s(%08x)\n", lpwm32mpex->hwnd, (LPSZ)GetWMMsgName(lpwm32mpex->uMsg), lpwm32mpex->uMsg));

    return (TRUE);
}


BOOL FASTCALL WM32EMSetWordBreakProc (LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));

        // take out the marker bits and fix the RPL bits
        UnMarkWOWProc (lpwm32mpex->lParam,lpwm32mpex->Parm16.WndProc.lParam);

        LOGDEBUG(3,(" Window %08lX is receiving Control Message %s(%08x)\n", lpwm32mpex->hwnd, (LPSZ)GetWMMsgName(lpwm32mpex->uMsg), lpwm32mpex->uMsg));
    }

    return (TRUE);
}


BOOL FASTCALL WM32EMGetWordBreakProc (LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
        LOGDEBUG(3,(" Window %08lX is receiving Control Message %s(%08x)\n", lpwm32mpex->hwnd, (LPSZ)GetWMMsgName(lpwm32mpex->uMsg), lpwm32mpex->uMsg));
    }
    else {

        // Mark the address as WOW Proc and store the high bits in the RPL field
        MarkWOWProc (lpwm32mpex->lReturn,lpwm32mpex->lReturn);
    }


    return (TRUE);
}


// This function thunks the edit control messages,
//
//  EM_SETTABSTOPS
//

BOOL FASTCALL WM32EMSetTabStops (LPWM32MSGPARAMEX lpwm32mpex)
{

    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - EM_GETSEL));
        if (lpwm32mpex->uParam != 0) {
            lpwm32mpex->Parm16.WndProc.lParam = malloc16(lpwm32mpex->uParam * sizeof(WORD));
            if (!(lpwm32mpex->Parm16.WndProc.lParam))
                return FALSE;
            putintarray16((VPINT16)lpwm32mpex->Parm16.WndProc.lParam, (INT)lpwm32mpex->uParam, (LPINT)lpwm32mpex->lParam);
        }
    } else {
        if (lpwm32mpex->Parm16.WndProc.lParam)
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);

    }

    return (TRUE);
}


// This function thunks the following combo box control messages,
//
//  CB_GETEDITSEL
//  CB_LIMITTEXT
//  CB_SETEDITSEL
//  CB_DELETESTRING
//  CB_GETCOUNT
//  CB_GETCURSEL
//  CB_GETLBTEXTLEN
//  CB_SETCURSEL
//  CB_SHOWDROPDOWN
//  CB_GETITEMDATA
//  CB_SETITEMDATA


BOOL FASTCALL  WM32CBControl (LPWM32MSGPARAMEX lpwm32mpex)
{


    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - CB_GETEDITSEL));
    }

    return (TRUE);
}


// This function thunks the following combo box control messages,
//
//  CB_ADDSTRING
//  CB_INSERTSTRING
//  CB_FINDSTRING
//  CB_SELECTSTRING

BOOL FASTCALL  WM32CBAddString (LPWM32MSGPARAMEX lpwm32mpex)
{
    PWW pww;




    if ( lpwm32mpex->fThunk ) {
        if (!(pww = lpwm32mpex->pww)) {
            if (pww = FindPWW (lpwm32mpex->hwnd))
                lpwm32mpex->pww = pww;
            else
                return FALSE;
        }

        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - CB_GETEDITSEL));

        //
        // Determine if this combobox has string pointers or handles passed
        // in with CB_ADDSTRING messages.  Normal comboboxes have string
        // pointers passed.  Owner-draw comboboxes that don't have the
        // CBS_HASSTRINGS style bit set have handles passed in.  These handles
        // are simply passed back to the owner at paint time.  If the
        // CBS_HASSTRINGS style bit is set, strings are used instead of
        // handles as the "cookie" which is passed back to the application
        // at paint time.
        //
        // We treat lpwm32mpex->dwParam as a BOOL indicating this combobox
        // takes handles instead of strings.
        //

        lpwm32mpex->dwParam =
            (pww->style & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE)) &&
            !(pww->style & CBS_HASSTRINGS);

        if ( !lpwm32mpex->dwParam ) {        // if strings are used
            if (lpwm32mpex->lParam) {
                INT cb;

                cb = strlen((LPSZ)lpwm32mpex->lParam)+1;
                lpwm32mpex->Parm16.WndProc.lParam = malloc16(cb);
                if (!(lpwm32mpex->Parm16.WndProc.lParam))
                    return FALSE;
                putstr16((VPSZ)lpwm32mpex->Parm16.WndProc.lParam, (LPSZ)lpwm32mpex->lParam, cb);
            }
        }
    } else {
        if ( !lpwm32mpex->dwParam ) {        // if strings are used
            if (lpwm32mpex->Parm16.WndProc.lParam) {
                getstr16((VPSZ)lpwm32mpex->Parm16.WndProc.lParam, (LPSZ)lpwm32mpex->lParam, -1);
                free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
            }
        }
    }

    LOGDEBUG(3,(" Window %08lX is receiving Control Message %s(%08x)\n", lpwm32mpex->hwnd, (LPSZ)GetWMMsgName(lpwm32mpex->uMsg), lpwm32mpex->uMsg));

    return(TRUE);

}


// This function thunks the following combo box control messages,
//
//  CB_DIR
//
//  Code in this routine references code in wparam.c in order to circumvent
//  copying memory to 16-bit memory space.
//  GetParam16 verifies that the parameter we get (lparam) had not originated
//  in 16-bit code. If it did come from 16-bit code, then we send an original
//  16:16 pointer to the application.
//  This fixes PagePlus 3.0 application and (if implemented on a broader scale)
//  will positively affect performance of applications which send a lot of
//  standard messages and use subclassing a lot.
//  -- VadimB

BOOL FASTCALL  WM32CBDir (LPWM32MSGPARAMEX lpwm32mpex)
{
    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - CB_GETEDITSEL));
        if (lpwm32mpex->lParam) {
            INT cb;

            if (W32CheckThunkParamFlag()) {
                LONG lParam = (LONG)GetParam16(lpwm32mpex->lParam);
                if (lParam) {
                    lpwm32mpex->Parm16.WndProc.lParam = lParam;
                    return (TRUE);
                }
            }

            cb = strlen((LPSZ)lpwm32mpex->lParam)+1;
            lpwm32mpex->Parm16.WndProc.lParam = malloc16(cb);
            if (!(lpwm32mpex->Parm16.WndProc.lParam))
                return FALSE;
            putstr16((VPSZ)lpwm32mpex->Parm16.WndProc.lParam, (LPSZ)lpwm32mpex->lParam, cb);
        }
    } else {
        if (W32CheckThunkParamFlag()) {
            if (DeleteParamMap(lpwm32mpex->Parm16.WndProc.lParam, PARAM_16, NULL)) {
                return TRUE;
            }
        }
        if (lpwm32mpex->Parm16.WndProc.lParam)
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
    }

    return(TRUE);
}


// This function thunks the following combo box control messages,
//
//  CB_GETLBTEXT

BOOL FASTCALL WM32CBGetLBText (LPWM32MSGPARAMEX lpwm32mpex)
{
    PWW   pww;



    if ( lpwm32mpex->fThunk ) {
        INT cb;

        if (!(pww = lpwm32mpex->pww)) {
            if (pww = FindPWW (lpwm32mpex->hwnd))
                lpwm32mpex->pww = pww;
            else
                return FALSE;
        }

        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - CB_GETEDITSEL));

        //
        // Determine if this combobox has string pointers or handles passed
        // in with CB_ADDSTRING messages.  Normal comboboxes have string
        // pointers passed.  Owner-draw comboboxes that don't have the
        // CBS_HASSTRINGS style bit set have handles passed in.  These handles
        // are simply passed back to the owner at paint time.  If the
        // CBS_HASSTRINGS style bit is set, strings are used instead of
        // handles as the "cookie" which is passed back to the application
        // at paint time.
        //
        // We treat lpwm32mpex->dwParam as a BOOL indicating this combobox
        // takes handles instead of strings.
        //

        lpwm32mpex->dwParam =
            (pww->style & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE)) &&
            !(pww->style & CBS_HASSTRINGS);

        //
        // Determine the size of the buffer to allocate on the 16-bit side
        // to receive the text.
        //

        if (lpwm32mpex->dwParam) {           // if handles are used
            cb = 4;
        } else {
            cb = SendMessage(lpwm32mpex->hwnd, CB_GETLBTEXTLEN, lpwm32mpex->uParam, 0);
            if (cb == CB_ERR) {
                //
                // lpwm32mpex->dwTmp[0] is initialized to 0 so that nothing
                // gets copied to the buffer by getstr16() while unthunking
                // this message.
                //
                // bug # 24415, ChandanC
                //

                cb = SIZE_BOGUS;
                lpwm32mpex->dwTmp[0] = 0;
            }
            else {
                //
                // Add one for NULL character.
                //
                cb = cb + 1;
                (INT) lpwm32mpex->dwTmp[0] = (INT) -1;
            }
        }
        if (lpwm32mpex->lParam) {
            BYTE *lpT;

            // See comment on similar code below

            lpwm32mpex->Parm16.WndProc.lParam = malloc16(cb);
            if (!(lpwm32mpex->Parm16.WndProc.lParam))
                return FALSE;
            GETVDMPTR((lpwm32mpex->Parm16.WndProc.lParam), sizeof(BYTE), lpT);
            *lpT = 0;
            FREEVDMPTR(lpT);
        }
    }
    else {
        if (lpwm32mpex->lParam && lpwm32mpex->Parm16.WndProc.lParam) {
            if (lpwm32mpex->dwParam) {       // if handles are used
                UNALIGNED DWORD *lpT;
                GETVDMPTR((lpwm32mpex->Parm16.WndProc.lParam), sizeof(DWORD), lpT);
                *(UNALIGNED DWORD *)lpwm32mpex->lParam = *lpT;
                FREEVDMPTR(lpT);
            }
            else {
                getstr16((VPSZ)lpwm32mpex->Parm16.WndProc.lParam, (LPSZ)lpwm32mpex->lParam,
                         (INT) lpwm32mpex->dwTmp[0]);
            }

            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);

        }
    }

    return(TRUE);
}


// This function thunks the following combo box control messages,
//
//  CB_GETDROPPEDCONTROLRECT

BOOL FASTCALL WM32CBGetDropDownControlRect (LPWM32MSGPARAMEX lpwm32mpex)
{

    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - CB_GETEDITSEL));
        lpwm32mpex->Parm16.WndProc.lParam = malloc16(sizeof(RECT16));
        if (!(lpwm32mpex->Parm16.WndProc.lParam))
            return FALSE;
    } else {
        GETRECT16( lpwm32mpex->Parm16.WndProc.lParam, (LPRECT)lpwm32mpex->lParam );
        if (lpwm32mpex->Parm16.WndProc.lParam)
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
    }

    return(TRUE);
}


// This function thunks the following combo box control messages,
//
//  CBEC_SETCOMBOFOCUS           (WM_USER+CB_MSGMAX+1)
//  CBEC_KILLCOMBOFOCUS          (WM_USER+CB_MSGMAX+2)
// These undocumented messages are used by Excel 5.0
//

BOOL FASTCALL  WM32CBComboFocus (LPWM32MSGPARAMEX lpwm32mpex)
{
#if (CBEC_SETCOMBOFOCUS != 0x166)
#error The USER Guys changed CBEC_SETCOMBOFOCUS again
#endif

#if (CBEC_KILLCOMBOFOCUS != 0x167)
#error The USER Guys changed CBEC_KILLCOMBOFOCUS again
#endif    

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg =
                (WORD)((lpwm32mpex->uMsg-CBEC_SETCOMBOFOCUS) + OLDCBEC_SETCOMBOFOCUS);
    }

    return (TRUE);
}


// This function thunks the list box control messages
//
//  LB_RESETCONTENT
//  LB_SETCURSEL
//  LB_GETSEL
//  LB_GETCURSEL
//  LB_GETTEXTLEN
//  LB_GETCOUNT
//  LB_GETCARETINDEX
//  LB_GETTOPINDEX
//  LB_GETSELCOUNT
//  LB_GETHORIZONTALEXTENT
//  LB_SETHORIZONTALEXTENT
//  LB_SETCOLUMNWIDTH
//  LB_SETTOPINDEX
//  LB_SETCARETINDEX
//  LB_SETITEMDATA
//  LB_SELITEMRANGE
//  LB_SETITEMHEIGHT
//  LB_GETITEMHEIGHT
//  LB_DELETESTRING
//

BOOL FASTCALL  WM32LBControl (LPWM32MSGPARAMEX lpwm32mpex)
{


    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));
    }

    return (TRUE);
}

// This function thunks the list box control messages
//
//  LB_GETTEXT

BOOL FASTCALL WM32LBGetText (LPWM32MSGPARAMEX lpwm32mpex)
{
    PWW   pww;



    if ( lpwm32mpex->fThunk ) {
        INT cb;

        if (!(pww = lpwm32mpex->pww)) {
            if (pww = FindPWW (lpwm32mpex->hwnd))
                lpwm32mpex->pww = pww;
            else
                return FALSE;
        }

        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));

        //
        // Determine if this listbox has string pointers or handles passed
        // in with LB_ADDSTRING messages.  Owner-draw listboxes that don't
        // have the LBS_HASSTRINGS style bit set have handles passed in.
        // These handles are simply passed back to the owner at paint time.
        // If the LBS_HASSTRINGS style bit is set, strings are used instead of
        // handles as the "cookie" which is passed back to the application
        // at paint time.
        //
        // We treat lpwm32mpex->dwParam as a BOOL indicating this listbox
        // takes handles instead of strings.
        //

        lpwm32mpex->dwParam =
            (pww->style & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE)) &&
            !(pww->style & LBS_HASSTRINGS);

        if (lpwm32mpex->dwParam) {    // if this listbox takes handles
            cb = 4;
        }
        else {
            cb = SendMessage(lpwm32mpex->hwnd, LB_GETTEXTLEN, lpwm32mpex->uParam, 0);

            // Check for LB_ERR (which is -1) on the above SendMessage().
            // When cb is equal to LB_ERR make the size as SIZE_BOGUS (256 bytes),
            // and allocate a buffer just in case if the app diddles the lParam.
            // We will free the buffer while unthunking the message (LB_GETTEXT).
            // This fix makes the app MCAD happy.
            // ChandanC 4-21-93.

            if (cb == LB_ERR) {
                cb = SIZE_BOGUS;
            }
            else {
                //
                // Add one for NULL character.
                //
                cb = cb + 1;
            }

        }

        if (lpwm32mpex->lParam) {
            BYTE *lpT;

            lpwm32mpex->Parm16.WndProc.lParam = malloc16(cb);
            if (!(lpwm32mpex->Parm16.WndProc.lParam))
                return FALSE;

            // The reason for this code to be here is that sometimes thunks
            // are executed on a buffer that has not been initialized, e.g.
            // if the hooks are installed by a wow app. That means we will
            // alloc 16-bit buffer while thunking (boils down to uninitialized
            // data buffer and will try to copy the buffer back while unthunking
            // overwriting the stack sometimes (as user allocates temp bufs from
            // the stack). This code initializes data so problem is avoided
            // App: Grammatik/Windows v6.0 -- VadimB

            GETVDMPTR((lpwm32mpex->Parm16.WndProc.lParam), sizeof(BYTE), lpT);
            *lpT = 0;
            FREEVDMPTR(lpT);
        }
    }
    else {

        if ((lpwm32mpex->lReturn != LB_ERR) && lpwm32mpex->lParam && lpwm32mpex->Parm16.WndProc.lParam) {
            if (lpwm32mpex->dwParam) {   // if this listbox takes handles
                UNALIGNED DWORD *lpT;
                GETVDMPTR((lpwm32mpex->Parm16.WndProc.lParam), sizeof(DWORD), lpT);
                *(UNALIGNED DWORD *)lpwm32mpex->lParam = *lpT;
                FREEVDMPTR(lpT);
            }
            else {
                getstr16((VPSZ)lpwm32mpex->Parm16.WndProc.lParam, (LPSZ)lpwm32mpex->lParam, -1);
            }
        }

        if (lpwm32mpex->Parm16.WndProc.lParam) {
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
        }
    }

    return(TRUE);
}

// This function thunks the list box control messages
//
//  LB_GETTEXTLEN

BOOL FASTCALL  WM32LBGetTextLen (LPWM32MSGPARAMEX lpwm32mpex)
{


    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));

        // USER32 and so do we send the LB_GETTEXTLEN message whenever an
        // LB_GETTEXT message is sent. This LB_GETTEXTLEN message is an
        // additional message that an app normally wouldn't see in WIN31.
        // lParam by definition is NULL.
        //
        // Super Project dies (at times) when it receives the LB_GETTEXTLEN
        // message. It doesn't expect to see this message and as a result does
        // strlen(lParam) and dies.
        //                                               - nanduri

        if (CURRENTPTD()->dwWOWCompatFlags &  WOWCF_LB_NONNULLLPARAM) {

            // be sure allocation size matches stackfree16() size below
            LPBYTE lpT = (LPBYTE)stackalloc16(0x2);  // just an even number

            lpwm32mpex->Parm16.WndProc.lParam = (LONG)lpT;
            GETVDMPTR(lpT, 0x2, lpT);
            *lpT = '\0';
        }
    } else {
        if (CURRENTPTD()->dwWOWCompatFlags &  WOWCF_LB_NONNULLLPARAM) {
            if(lpwm32mpex->Parm16.WndProc.lParam) {
                stackfree16((VPVOID)lpwm32mpex->Parm16.WndProc.lParam, 0x2);
            }
        }
    }

    return (TRUE);
}



// This function thunks the list box control messages
//
//  LB_DIR

BOOL FASTCALL WM32LBDir (LPWM32MSGPARAMEX lpwm32mpex)
{
    INT cb;
    VPVOID vp;


    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));
        if (lpwm32mpex->lParam) {
            cb = strlen((LPSTR)lpwm32mpex->lParam)+1;
            if (!(vp = malloc16(cb))) {
                LOGDEBUG(0,(" WOW32.DLL : WM32LBDir() :: Could not allocate memory for string, ChandanC\n"));
                WOW32ASSERT(vp);
                return FALSE;
            }
            putstr16(vp, (LPSTR) lpwm32mpex->lParam, cb);
            lpwm32mpex->Parm16.WndProc.lParam = vp;
        }
    }
    else {
        if (lpwm32mpex->Parm16.WndProc.lParam) {
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
        }
    }

    return(TRUE);
}

// This function thunks the list box control messages
//
//  LB_GETSELITEMS

BOOL FASTCALL WM32LBGetSelItems (LPWM32MSGPARAMEX lpwm32mpex)
{

    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));
        if (lpwm32mpex->lParam) {
            INT cb;

            cb = lpwm32mpex->uParam * sizeof(WORD);
            lpwm32mpex->Parm16.WndProc.lParam = malloc16(cb);
            if (!(lpwm32mpex->Parm16.WndProc.lParam))
                return FALSE;

        }
    } else {
        getintarray16((VPRECT16)lpwm32mpex->Parm16.WndProc.lParam, (INT)lpwm32mpex->uParam, (LPINT)lpwm32mpex->lParam);
        if (lpwm32mpex->Parm16.WndProc.lParam)
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
    }

    return(TRUE);
}


// This function thunks the list box control messages
//
//  LB_SETTABSTOPS

BOOL FASTCALL WM32LBSetTabStops (LPWM32MSGPARAMEX lpwm32mpex)
{

    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));
        if (lpwm32mpex->uParam != 0) {
            lpwm32mpex->Parm16.WndProc.lParam = malloc16(lpwm32mpex->uParam * sizeof(WORD));
            if (!(lpwm32mpex->Parm16.WndProc.lParam))
                return FALSE;
            putintarray16((VPRECT16)lpwm32mpex->Parm16.WndProc.lParam, (INT)lpwm32mpex->uParam, (LPINT)lpwm32mpex->lParam);
        }
    } else {
        if (lpwm32mpex->Parm16.WndProc.lParam)
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
    }

    return(TRUE);
}

// This function thunks the list box control messages
//
//  LB_GETITEMRECT

BOOL FASTCALL WM32LBGetItemRect (LPWM32MSGPARAMEX lpwm32mpex)
{

    if ( lpwm32mpex->fThunk ) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));
        lpwm32mpex->Parm16.WndProc.lParam = malloc16(sizeof(RECT16));
        if (!(lpwm32mpex->Parm16.WndProc.lParam))
            return FALSE;
    } else {
        GETRECT16( lpwm32mpex->Parm16.WndProc.lParam, (LPRECT)lpwm32mpex->lParam );
        if (lpwm32mpex->Parm16.WndProc.lParam)
            free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
    }

    LOGDEBUG(3,(" Window %08lX is receiving Control Message %s(%08x)\n", lpwm32mpex->hwnd, (LPSZ)GetWMMsgName(lpwm32mpex->uMsg), lpwm32mpex->uMsg));

    return(TRUE);

}


// This function thunks the list box control messages
//
//  LB_ADDSTRING
//  LB_INSERTSTRING
//  LB_FINDSTRING
//  LB_SELECTSTRING

BOOL FASTCALL WM32LBAddString (LPWM32MSGPARAMEX lpwm32mpex)
{
    PWW   pww;


    if ( lpwm32mpex->fThunk ) {
        if (!(pww = lpwm32mpex->pww)) {
            if (pww = FindPWW (lpwm32mpex->hwnd))
                lpwm32mpex->pww = pww;
            else
                return FALSE;
        }

        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));

        //
        // Determine if this listbox has string pointers or handles passed
        // in with LB_ADDSTRING messages.  Owner-draw listboxes that don't
        // have the LBS_HASSTRINGS style bit set have handles passed in.
        // These handles are simply passed back to the owner at paint time.
        // If the LBS_HASSTRINGS style bit is set, strings are used instead of
        // handles as the "cookie" which is passed back to the application
        // at paint time.
        //
        // We treat lpwm32mpex->dwParam as a BOOL indicating this listbox
        // takes handles instead of strings.
        //

        lpwm32mpex->dwParam =
            (pww->style & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE)) &&
            !(pww->style & LBS_HASSTRINGS);

        if ( !lpwm32mpex->dwParam ) {   // if this listbox takes strings
            if (lpwm32mpex->lParam) {
                INT cb;

                cb = strlen((LPSZ)lpwm32mpex->lParam)+1;
                lpwm32mpex->Parm16.WndProc.lParam = malloc16(cb);
                if (!(lpwm32mpex->Parm16.WndProc.lParam))
                    return FALSE;
                putstr16((VPSZ)lpwm32mpex->Parm16.WndProc.lParam, (LPSZ)lpwm32mpex->lParam, cb);
            }
        }
    } else {
        if ( !lpwm32mpex->dwParam ) {   // if this listbox takes strings
            if (lpwm32mpex->Parm16.WndProc.lParam) {
                getstr16((VPSZ)lpwm32mpex->Parm16.WndProc.lParam, (LPSZ)lpwm32mpex->lParam, -1);
                free16((VPVOID) lpwm32mpex->Parm16.WndProc.lParam);
            }
        }
    }

    return(TRUE);
}

// This function thunks the scrollbar control messages,
//
//  SBM_SETPOS
//  SBM_GETPOS
//  SBM_ENABLE_ARROWS
//

BOOL FASTCALL WM32SBMControl (LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = WM_USER + (lpwm32mpex->uMsg - SBM_SETPOS);
    }

    return (TRUE);
}


//  SBM_GETRANGE

BOOL FASTCALL WM32SBMGetRange (LPWM32MSGPARAMEX lpwm32mpex)
{
    //
    // Changed semantics for this message to support 32-bit
    // scroll bar ranges (vs. 16-bit).
    //
    // Win16:
    //   posMin = LOWORD(SendMessage(hwnd, SBM_GETRANGE, 0, 0));
    //   posMax = HIWORD(SendMessage(hwnd, SBM_GETRANGE, 0, 0));
    //
    // Win32:
    //   SendMessage(hwnd, SBM_GETRANGE,
    //               (WPARAM) &posMin, (LPARAM) &posMax);
    //

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = OLDSBM_GETRANGE;
    } else {
        *(DWORD *)lpwm32mpex->uParam = INT32(LOWORD(lpwm32mpex->lReturn));
        *(DWORD *)lpwm32mpex->lParam = INT32(HIWORD(lpwm32mpex->lReturn));
        lpwm32mpex->lReturn = 0;
    }

    return (TRUE);
}


//  SBM_SETRANGE
//  SBM_SETRANGEREDRAW (new for Win32)

BOOL FASTCALL WM32SBMSetRange (LPWM32MSGPARAMEX lpwm32mpex)
{

    //
    // Changed semantics to support 32-bit scroll bar range:
    //
    // Win16:
    //   SendMessage(hwnd, SBM_SETRANGE, fRedraw, MAKELONG(posMin, posMax);
    //
    // Win32:
    //   SendMessage(hwnd, fRedraw ? SBM_SETRANGE : SBM_SETRANGEREDRAW,
    //               posMin, posMax);
    //

    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg   = OLDSBM_SETRANGE;
        lpwm32mpex->Parm16.WndProc.wParam = (SBM_SETRANGEREDRAW == lpwm32mpex->uMsg);
        lpwm32mpex->Parm16.WndProc.lParam = MAKELONG( (WORD)lpwm32mpex->uParam, (WORD)lpwm32mpex->lParam);
    }

    return (TRUE);
}


//  LB_SETSEL

BOOL FASTCALL  WM32LBSetSel (LPWM32MSGPARAMEX lpwm32mpex)
{


    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = (WORD) (WM_USER + (lpwm32mpex->uMsg - LB_ADDSTRING + 1));
        lpwm32mpex->Parm16.WndProc.wParam = (WORD) lpwm32mpex->uParam;
        lpwm32mpex->Parm16.WndProc.lParam = (WORD)lpwm32mpex->lParam;  // loword = index, hiword = 0
    }

    return (TRUE);
}


// This function thunks the static control messages,
//
//  STM_SETICON
//  STM_GETICON
//

BOOL FASTCALL WM32STMControl (LPWM32MSGPARAMEX lpwm32mpex)
{

    if (lpwm32mpex->fThunk) {
        switch (lpwm32mpex->uMsg) {
            case STM_SETICON:
                lpwm32mpex->Parm16.WndProc.wParam = (WORD)GETHICON16(lpwm32mpex->uParam);
                break;

            case STM_GETICON:
                break;

        }
        lpwm32mpex->Parm16.WndProc.wMsg = WM_USER + (lpwm32mpex->uMsg - STM_SETICON);
    }
    else {
        lpwm32mpex->lReturn = (LONG)HICON32(lpwm32mpex->lReturn);
    }


    return (TRUE);
}


// This function thunks the messages,
//
// MN_FINDMENUWINDOWFROMPOINT
//

// NT -    wparam = (PUINT)pitem  lParam = MAKELONG(pt.x, pt.y)
//         returns flags or hwnd    *pitem = index or -1
//
// win31   wParam = 0   lParam = same
//         returns 0 or MAKELONG(-1, item) or MAKELONG(-2, item) or MAKELONG(hwnd, item)


BOOL FASTCALL WM32MNFindMenuWindow (LPWM32MSGPARAMEX lpwm32mpex)
{
    if (lpwm32mpex->fThunk) {
        lpwm32mpex->Parm16.WndProc.wMsg = WIN30_MN_FINDMENUWINDOWFROMPOINT;
        lpwm32mpex->Parm16.WndProc.wParam = 0;

    } else {
        USHORT n =  LOWORD(lpwm32mpex->lReturn);

        *(PLONG)lpwm32mpex->uParam = (SHORT)HIWORD(lpwm32mpex->lReturn);
        lpwm32mpex->lReturn = (LONG)HWND32(n);  // this sign-extends -1, -2 and leaves 0 as 0
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wcurcash.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WCURCASH.H
 *  WOW32 Cursor & Icon cash worker routines.
 *
 *  History:
 *  Created on Jan 27th-93 by ChandanC
 *
--*/


typedef struct _CURICON {
    struct _CURICON *pNext; // pointer to next hDDE alias
    DWORD   lpszIcon;       // name of resource
    HICON16 hIcon16;        // 16 bit handle of the Icon/Cursor given to app
    HICON16 hRes16;         // 16 bit handle of the resource
    WORD    ResType;        // type of resource, ie RT_ICON or RT_CURSOR
    HAND16  hInst;          // instance handle that owns the resource
    DWORD   dwThreadID;     // ID of the thread
} CURICON, *PCURICON;


HICON16 W32CheckWOWCashforIconCursors(VPVOID pData, WORD ResType);
BOOL    W32AddCursorIconCash (WORD hInst, LPSTR psz1, HICON16 hIcon16, HICON16 hRes16, WORD ResType);
HICON16 W32FindCursorIcon (WORD hInst, LPSTR psz, WORD ResType, HICON16 *phRes16);
VOID    W32DeleteCursorIconCash (HICON16 hRes16);
VOID    W32DeleteCursorIconCashForTask ();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wctlm32.h ===
//*****************************************************************************
//
// 32bit Control message thunking
//
//
// 01-FEB-92 NanduriR Created
//*****************************************************************************


BOOL ThunkEMMsg32(HWND hwnd, UINT uMsg, UINT uParam, LONG lParam,
                  PWORD pwMsgNew, PWORD pwParamNew, PLONG plParamNew);
BOOL ThunkCBMsg32(HWND hwnd, UINT uMsg, UINT uParam, LONG lParam,
                  PWORD pwMsgNew, PWORD pwParamNew, PLONG plParamNew);
BOOL ThunkLBMsg32(HWND hwnd, UINT uMsg, UINT uParam, LONG lParam,
                  PWORD pwMsgNew, PWORD pwParamNew, PLONG plParamNew);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wctlm32.c ===
case EM_GETSEL:             //                          0x00B0
    case EM_SETSEL:             //                          0x00B1
    case EM_GETRECT:             //                         0x00B2
    case EM_SETRECT:             //                         0x00B3
    case EM_SETRECTNP:             //                       0x00B4
    case EM_SCROLL:             //                          0x00B5
    case EM_LINESCROLL:             //                      0x00B6
    case EM_GETMODIFY:             //                       0x00B8
    case EM_SETMODIFY:             //                       0x00B9
    case EM_GETLINECOUNT:             //                    0x00BA
    case EM_LINEINDEX:             //                       0x00BB
    case EM_SETHANDLE:             //                       0x00BC
    case EM_GETHANDLE:             //                       0x00BD
    case EM_GETTHUMB:             //                        0x00BE
    case EM_LINELENGTH:             //                      0x00C1
    case EM_REPLACESEL:             //                      0x00C2
    case EM_SETFONT:             //                         0x00C3
    case EM_GETLINE:             //                         0x00C4
    case EM_LIMITTEXT:             //                       0x00C5
    case EM_CANUNDO:             //                         0x00C6
    case EM_UNDO:             //                            0x00C7
    case EM_FMTLINES:             //                        0x00C8
    case EM_LINEFROMCHAR:             //                    0x00C9
    case EM_SETWORDBREAK:             //                    0x00CA
    case EM_SETTABSTOPS:             //                     0x00CB
    case EM_SETPASSWORDCHAR:             //                 0x00CC
    case EM_EMPTYUNDOBUFFER:             //                 0x00CD
    case EM_GETFIRSTVISIBLE:             //                 0x00CE
    case EM_SETREADONLY:             //                     0x00CF
    case EM_MSGMAX:             //                          0x00D0
        return ThunkEMMsg32(hwnd, uMsg, uParam, lParam,
                                pwMsgNew, pwParamNew, plParamNew);

    case SBM_SETPOS:             //                         0x00E0
    case SBM_GETPOS:             //                         0x00E1
    case SBM_SETRANGE:             //                       0x00E2
    case SBM_GETRANGE:             //                       0x00E3
    case SBM_ENABLE_ARROWS:             //                  0x00E4
        return ThunkSBMMsg32(hwnd, uMsg, uParam, lParam,
                                 pwMsgNew, pwParamNew, plParamNew);


    case BM_GETCHECK:             //                        0x00F0
    case BM_SETCHECK:             //                        0x00F1
    case BM_GETSTATE:             //                        0x00F2
    case BM_SETSTATE:             //                        0x00F3
    case BM_SETSTYLE:             //                        0x00F4
        return ThunkBMMsg32(hwnd, uMsg, uParam, lParam,
                                 pwMsgNew, pwParamNew, plParamNew);



    case CB_GETEDITSEL:             //                      0x0140
    case CB_LIMITTEXT:             //                       0x0141
    case CB_SETEDITSEL:             //                      0x0142
    case CB_ADDSTRING:             //                       0x0143
    case CB_DELETESTRING:             //                    0x0144
    case CB_DIR:             //                             0x0145
    case CB_GETCOUNT:             //                        0x0146
    case CB_GETCURSEL:             //                       0x0147
    case CB_GETLBTEXT:             //                       0x0148
    case CB_GETLBTEXTLEN:             //                    0x0149
    case CB_INSERTSTRING:             //                    0x014A
    case CB_RESETCONTENT:             //                    0x014B
    case CB_FINDSTRING:             //                      0x014C
    case CB_SELECTSTRING:             //                    0x014D
    case CB_SETCURSEL:             //                       0x014E
    case CB_SHOWDROPDOWN:             //                    0x014F
    case CB_GETITEMDATA:             //                     0x0150
    case CB_SETITEMDATA:             //                     0x0151
    case CB_GETDROPPEDCONTROLRECT:             //           0x0152
    case CB_SETITEMHEIGHT:             //                   0x0153
    case CB_GETITEMHEIGHT:             //                   0x0154
    case CB_SETEXTENDEDUI:             //                   0x0155
    case CB_GETEXTENDEDUI:             //                   0x0156
    case CB_GETDROPPEDSTATE:             //                 0x0157
    case CB_MSGMAX:             //                          0x0158
        return ThunkCBMsg32(hwnd, uMsg, uParam, lParam,
                                 pwMsgNew, pwParamNew, plParamNew);



    case LB_ADDSTRING:             //                       0x0180
    case LB_INSERTSTRING:             //                    0x0181
    case LB_DELETESTRING:             //                    0x0182
    case LB_RESETCONTENT:             //                    0x0184
    case LB_SETSEL:             //                          0x0185
    case LB_SETCURSEL:             //                       0x0186
    case LB_GETSEL:             //                          0x0187
    case LB_GETCURSEL:             //                       0x0188
    case LB_GETTEXT:             //                         0x0189
    case LB_GETTEXTLEN:             //                      0x018A
    case LB_GETCOUNT:             //                        0x018B
    case LB_SELECTSTRING:             //                    0x018C
    case LB_DIR:             //                             0x018D
    case LB_GETTOPINDEX:             //                     0x018E
    case LB_FINDSTRING:             //                      0x018F
    case LB_GETSELCOUNT:             //                     0x0190
    case LB_GETSELITEMS:             //                     0x0191
    case LB_SETTABSTOPS:             //                     0x0192
    case LB_GETHORIZONTALEXTENT:             //             0x0193
    case LB_SETHORIZONTALEXTENT:             //             0x0194
    case LB_SETCOLUMNWIDTH:             //                  0x0195
    case LB_SETTOPINDEX:             //                     0x0197
    case LB_GETITEMRECT:             //                     0x0198
    case LB_GETITEMDATA:             //                     0x0199
    case LB_SETITEMDATA:             //                     0x019A
    case LB_SELITEMRANGE:             //                    0x019B
    case LB_SETITEMHEIGHT:             //                   0x01A0
    case LB_GETITEMHEIGHT:             //                   0x01A1
    case LBCB_CARETON:                 //                   0x01A3
    case LBCB_CARETOFF:                //                   0x01A4
    case LB_MSGMAX:             //                          0x01A5
        return ThunkLBMsg32(hwnd, uMsg, uParam, lParam,
                                 pwMsgNew, pwParamNew, plParamNew);


BOOL ThunkEMMsg32(HWND hwnd, UINT uMsg, UINT uParam, LONG lParam,
                  PWORD pwMsgNew, PWORD pwParamNew, PLONG plParamNew)
{
    // case EM_GETSEL:             //                          0x00B0
    // case EM_SETSEL:             //                          0x00B1
    // case EM_GETRECT:             //                         0x00B2
    // case EM_SETRECT:             //                         0x00B3
    // case EM_SETRECTNP:             //                       0x00B4
    // case EM_SCROLL:             //                          0x00B5
    // case EM_LINESCROLL:             //                      0x00B6
    // case EM_GETMODIFY:             //                       0x00B8
    // case EM_SETMODIFY:             //                       0x00B9
    // case EM_GETLINECOUNT:             //                    0x00BA
    // case EM_LINEINDEX:             //                       0x00BB
    // case EM_SETHANDLE:             //                       0x00BC
    // case EM_GETHANDLE:             //                       0x00BD
    // case EM_GETTHUMB:             //                        0x00BE
    // case EM_LINELENGTH:             //                      0x00C1
    // case EM_REPLACESEL:             //                      0x00C2
    // case EM_SETFONT:             //                         0x00C3
    // case EM_GETLINE:             //                         0x00C4
    // case EM_LIMITTEXT:             //                       0x00C5
    // case EM_CANUNDO:             //                         0x00C6
    // case EM_UNDO:             //                            0x00C7
    // case EM_FMTLINES:             //                        0x00C8
    // case EM_LINEFROMCHAR:             //                    0x00C9
    // case EM_SETWORDBREAK:             //                    0x00CA
    // case EM_SETTABSTOPS:             //                     0x00CB
    // case EM_SETPASSWORDCHAR:             //                 0x00CC
    // case EM_EMPTYUNDOBUFFER:             //                 0x00CD
    // case EM_GETFIRSTVISIBLE:             //                 0x00CE
    // case EM_SETREADONLY:             //                     0x00CF
    // case EM_MSGMAX:             //                          0x00D0


    *pwMsgNew = WM_USER + (uMsg - EM_GETSEL); // EM_GETSEL is the base

    switch(uMsg) {
        case EM_GETSEL:             //                          0x00B0
            *pwParamNew = (WORD)0;
            *plParamNew = (LONG)0;
            break;

        case EM_SETSEL:             //                          0x00B1
            LOW(*plParamNew) = (WORD)((SHORT)uParam);
            HIW(*plParamNew) = (WORD)((SHORT)lParam);
            break;

        case EM_GETRECT:             //                         0x00B2
            *plParamNew = GlobalAllocLock16(GMEM_MOVEABLE,
                                                     sizeof(RECT16), NULL);
            if (!(*plParamNew))
                return FALSE;

            break;

        case EM_SETRECT:             //                         0x00B3
        case EM_SETRECTNP:             //                       0x00B4
            if (lParam) {
                *plParamNew = GlobalAllocLock16(GMEM_MOVEABLE,
                                                         sizeof(RECT16), NULL);
                if (!(*plParamNew))
                    return FALSE;
                putrect16((VPRECT16)*plParamNew, (LPRECT)lParam);
            }
            break;

        case EM_LINESCROLL:             //                      0x00B6
            LOW(*plParamNew) = (WORD)(uParam);
            HIW(*plParamNew) = (WORD)(lParam);
            break;

        case EM_SETHANDLE:             //                       0x00BC
        case EM_GETHANDLE:             //                       0x00BD
            LOGDEBUG(0, "ThunkEMMsg32:EM_xxxHANDLE - What to do\n");
            break;

        case EM_REPLACESEL:             //                      0x00C2
            if (lParam) {
                INT cb;

                cb = strlen((LPSZ)lParam+1);
                *plParamNew = GlobalAllocLock16(GMEM_MOVEABLE, cb, NULL);
                if (!(*plParamNew))
                    return FALSE;
                putstr16((VPSZ16)*plParamNew, (LPSZ)lParam, cb);
            }
            break;

        case EM_SETFONT:             //                         0x00C3
            LOGDEBUG(0, "ThunkEMMsg32:EM_SETFONT - What to do\n");
            break;

        case EM_GETLINE:             //                         0x00C4
*************************************

        case EM_SETWORDBREAK:             //                    0x00CA
            LOGDEBUG(0, "ThunkEMMsg32:EM_SETWORDBREAK - What to do\n");
            break;

        case EM_SETTABSTOPS:             //                     0x00CB
            if (wParam != 0) {
                *plParamNew = GlobalAllocLock16(GMEM_MOVEABLE,
                                                  wParam * sizeof(WORD), NULL);
                if (!(*plParamNew))
                    return FALSE;
**********************putrect16((VPRECT16)*plParamNew, (LPRECT)lParam);
            }
            break;

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wcurcash.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WCURCASH.H
 *  WOW32 Cursor & Icon cash worker routines.
 *
 *  History:
 *  Created on Jan 27th-93 by ChandanC
 *
--*/


#include "precomp.h"
#pragma hdrstop


STATIC PCURICON pCurIconFirst = NULL;       // pointer to first hCurIcon entry


HICON16 W32CheckWOWCashforIconCursors(VPVOID pData, WORD ResType)
{
    register PICONCUR16 parg16;
    HICON16 hIcon16;
    HICON16 hRes16;
    PSZ psz;
    HAND32 h32;

    GETMISCPTR(pData, parg16);
    GETPSZIDPTR(parg16->lpStr, psz);

    hIcon16 = W32FindCursorIcon (parg16->hInst, psz, ResType, &hRes16);

    if (hIcon16) {
        if (ResType == (WORD) RT_ICON) {
            h32 = HICON32(hIcon16);
            ResType = HANDLE_TYPE_ICON;
        }
        else {
            h32 = HCURSOR32(hIcon16);
            ResType = HANDLE_TYPE_CURSOR;
        }

        hIcon16 = SetupResCursorIconAlias((HAND16) parg16->hInst, h32, (HANDLE) hRes16, (UINT) ResType);
    }

    FREEPSZIDPTR(psz);
    FREEMISCPTR(parg16);

    return (hIcon16);
}


HICON16 W32FindCursorIcon (WORD hInst, LPSTR psz, WORD ResType, HICON16 *phRes16)
{
    PCURICON   pTemp;

    pTemp = pCurIconFirst;

    while (pTemp) {
        if (pTemp->ResType == ResType) {
            if (pTemp->hInst == hInst) {
                if ((HIWORD(psz) != 0) && (HIWORD(pTemp->lpszIcon) != 0))  {
                    if (!(WOW32_stricmp(psz, (LPSTR)pTemp->lpszIcon))) {
                        *phRes16 = pTemp->hRes16;
                        return (pTemp->hIcon16);
                    }
                }
                else if ((HIWORD(psz) == 0) && (HIWORD(pTemp->lpszIcon) == 0))  {
                    if ((WORD) pTemp->lpszIcon == (WORD)psz) {
                        *phRes16 = pTemp->hRes16;
                        return (pTemp->hIcon16);
                    }
                }
            }
        }
        pTemp = pTemp->pNext;
    }
    return 0;
}


BOOL W32AddCursorIconCash (WORD hInst, LPSTR psz1, HICON16 hIcon16, HICON16 hRes16, WORD ResType)
{
    PCURICON pCurIcon;
    PSZ psz2;
    WORD cb;

    // if "psz1" is a string, allocate the memory for it

    if ((WORD)HIWORD(psz1) != (WORD)NULL) {
        cb = strlen(psz1)+1;
        if (psz2 = malloc_w_small(cb)) {
            memcpy (psz2, psz1, cb);
        }
        else {
            LOGDEBUG (0, ("WOW::W32AddCursorIcon: Memory allocation failed *** \n"));
            return (0);
        }
    }
    else {
        psz2 = psz1;
    }

    if (pCurIcon = malloc_w_small (sizeof(CURICON))) {
        pCurIcon->pNext     = pCurIconFirst;
        pCurIconFirst       = pCurIcon;               // update list head
        pCurIcon->hInst     = hInst;
        pCurIcon->lpszIcon  = (DWORD)psz2;
        pCurIcon->hIcon16   = hIcon16;
        pCurIcon->hRes16    = hRes16;
        pCurIcon->ResType   = ResType;
        pCurIcon->dwThreadID = CURRENTPTD()->dwThreadID;
        return (TRUE);
    }
    else {
        LOGDEBUG(0, ("WOW::WAddCursorIcon(): *** memory allocation failed *** \n"));
        return (FALSE);
    }
}


// This routine deletes a resource (Cursor or Icon) from the cash.

VOID W32DeleteCursorIconCash (HICON16 hRes16)
{
    PCURICON   pTemp;
    PCURICON   pTempLast;

    pTemp = pCurIconFirst;

    while (pTemp) {
        if (pTemp->hRes16 == hRes16) {
            if (pTemp == pCurIconFirst) {
                pCurIconFirst = pTemp->pNext;
            }
            else {
                pTempLast->pNext = pTemp->pNext;
            }

            // if its a string, delete the memory that we allocated for it

            if ((WORD)HIWORD(pTemp->lpszIcon) != (WORD)NULL) {
                free_w_small ((PVOID)pTemp->lpszIcon);
            }

            free_w_small (pTemp);
            pTemp = NULL;
        }
        else {
            pTempLast = pTemp;
            pTemp = pTemp->pNext;
        }
    }
}


// This routine deletes all the cursors and Icons when a task terminates.

VOID W32DeleteCursorIconCashForTask ()
{
    DWORD dwThreadID;
    PCURICON   pTemp;
    PCURICON   pTempLast;
    PCURICON   pTempNext;

    dwThreadID = CURRENTPTD()->dwThreadID;

    pTemp = pCurIconFirst;

    while (pTemp) {
        if (pTemp->dwThreadID == dwThreadID) {
            if (pTemp == pCurIconFirst) {
                pCurIconFirst = pTemp->pNext;
            }
            else {
                pTempLast->pNext = pTemp->pNext;
            }

            // if its a string, delete the memory that we allocated for it

            if ((WORD)HIWORD(pTemp->lpszIcon) != (WORD)NULL) {
                free_w_small ((PVOID)pTemp->lpszIcon);
            }

            pTempNext = pTemp->pNext;
            free_w_small (pTemp);
            pTemp = pTempNext;
        }
        else {
            pTempLast = pTemp;
            pTemp = pTemp->pNext;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wcuricon.h ===
//*****************************************************************************
//
// Cursor and Icon compatibility Support -
//
//     Support for apps - which do a GlobalLock on Cursors and Icons to
//     create headaches for us.
//
//     A compatibility issue.
//
//
// 21-Apr-92  NanduriR   Created.
//
//*****************************************************************************

#define HANDLE_TYPE_UNKNOWN  0x01
#define HANDLE_TYPE_ICON     0x02
#define HANDLE_TYPE_CURSOR   0x04

#define HANDLE_TYPE_WOWGLOBAL 0x08

#define HANDLE_16BIT       0x01
#define HANDLE_32BIT       0x02
#define HANDLE_16BITRES    0x04

#define CIALIAS_TASKISGONE  0x01
#define CIALIAS_HMOD        0x02
#define CIALIAS_HTASK       0x04

typedef struct _CURSORICONALIAS {
    struct _CURSORICONALIAS FAR *lpNext;
    BYTE   fInUse;
    BYTE   flType;
    HAND16 h16;
    HAND32 h32;
    HAND16 hInst16;
    HAND16 hMod16;
    HTASK16 hTask16;
    WORD    hRes16;         // 16bit resource handle
    WORD    cbData;
    UINT    cLock;
    VPVOID  vpData;
    LPBYTE  pbDataOld;
    LPBYTE  pbDataNew;
    LPBYTE  lpszName;       // name of 16bit resource
} CURSORICONALIAS, FAR *LPCURSORICONALIAS;


#define PROBABLYCURSOR(BitsPixel, Planes) ((((BitsPixel) == 1) &&  \
                                                     ((Planes) == 1)) || \
                                            (BitsPixel) == 0 || (Planes) == 0)
#define BOGUSHANDLE(h) (~(h) & 0x4)

extern  UINT   cPendingCursorIconUpdates;

HANDLE W32CreateCursorIcon32(LPCURSORICONALIAS lpCIAlias);
HAND16 W32Create16BitCursorIcon(HAND16 hInst16, INT xHotSpot, INT yHotSpot,
         INT nWidth, INT nHeight, INT nPlanes, INT nBitsPixel,
         LPBYTE lpBitsAND, LPBYTE lpBitsXOR, INT   nBytesAND, INT nBytesXOR);

HANDLE GetCursorIconAlias32(HAND16 h16, UINT flType);
HAND16 GetCursorIconAlias16(HAND32 h32, UINT flType);
LPCURSORICONALIAS AllocCursorIconAlias();
LPCURSORICONALIAS FindCursorIconAlias(ULONG hCI, UINT flHandleSize);
BOOL DeleteCursorIconAlias(ULONG hCI, UINT flHandleSize);
BOOL FreeCursorIconAlias(HAND16 hand16, ULONG ulFLags);
HAND16 SetupCursorIconAlias(HAND16 hInst16, HAND32 h32, HAND16 h16, UINT flType,
                               LPBYTE lpResName, WORD hRes16);
HAND16 SetupResCursorIconAlias(HAND16 hInst16, HAND32 h32, LPBYTE lpResName, WORD hRes16, UINT flType);
ULONG SetCursorIconFlag(HAND16 h16, BOOL fSet);
BOOL  ReplaceCursorIcon(LPCURSORICONALIAS lpCIAliasIn);
BOOL FASTCALL  WK32WowCursorIconOp(PVDMFRAME pFrame);
VOID  UpdateCursorIcon(VOID);
HAND16 W32Create16BitCursorIconFrom32BitHandle(HANDLE h32, HAND16 hMod16,
                                                                 PUINT cbData);
BOOL  InitStdCursorIconAlias(VOID);

#if defined(FE_SB)
BOOL FindCursorIconAliasInUse(ULONG hCI);
#endif

#define HCURSOR32(hobj16)       GetCursorIconAlias32((HAND16)(hobj16), HANDLE_TYPE_CURSOR)
#define GETHCURSOR16(hobj32)    GetCursorIconAlias16((HAND32)(hobj32), HANDLE_TYPE_CURSOR)
#define FREEHCURSOR16(hobj16)   DeleteCursorIconAlias((ULONG)(hobj16), HANDLE_16BIT)

#define HICON32(hobj16)         GetCursorIconAlias32((HAND16)(hobj16), HANDLE_TYPE_ICON)
#define GETHICON16(hobj32)      GetCursorIconAlias16((HAND32)(hobj32), HANDLE_TYPE_ICON)
#define FREEHICON16(hobj16)     DeleteCursorIconAlias((ULONG)(hobj16), HANDLE_16BIT)

#define HICON32_REGCLASS(hobj16)  GetClassCursorIconAlias32((HAND16)(hobj16))
HANDLE GetClassCursorIconAlias32(HAND16 h16);
VOID InvalidateCursorIconAlias(LPCURSORICONALIAS lpT);

//
// In win32 USER
//

HANDLE WINAPI WOWLoadCursorIcon(HANDLE hInstance, LPCSTR lpIconName,
                                                 LPTSTR rt, LPHANDLE lphRes16);
HAND16 W32CheckIfAlreadyLoaded(VPVOID pData, WORD ResType);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wdde.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WDDE.C
 *  WOW32 DDE worker routines.
 *
 *  History:
 *  WOW DDE support designed and developed by ChandanC
 *
--*/


#include "precomp.h"
#pragma hdrstop

LPDDENODE DDEInitiateList = NULL;
STATIC PHDDE phDDEFirst = NULL;       // pointer to first hDDE entry
STATIC PCPDATA pCPDataFirst = NULL;       // pointer to first CopyData entry

MODNAME(wdde.c);


// This routine maintains a list of client windows that are in
// Initiate mode. This is called from THUNKING of DDE_INITIATE
// message (from both the WMDISP32.C and WMSG16.C).
//

VOID WI32DDEAddInitiator (HAND16 Initiator)
{
    LPDDENODE Node;

    Node = (LPDDENODE) malloc_w(sizeof(DDENODE));

    if (Node) {

        //
        // Initialize Node with the Initiator's window handle
        //

        Node->Initiator = Initiator;

        //
        // Insert this Node into the linked list of DDE_Initiate message
        // in progress.
        //

        Node->Next = DDEInitiateList;
        DDEInitiateList = Node;

        LOGDEBUG(12, ("WOW::WI32DDEInitiator(): thunking -- adding an Initiator %04lX\n", Initiator));
    }
    else {

        //
        // We could not allocate memory.
        //

        LOGDEBUG(12, ("WOW::WI32DDEInitiator(): thunking -- Couldn't allocate memory\n"));
        WOW32ASSERT (FALSE);
    }
}


// This routine deletes the client window that was in Initiate mode. Because
// the initiate message is completed now. This is called from UNTHUNKING
// of DDE_INITIATE message (from both the WMDISP32.C and WMSG16.C).
//

VOID WI32DDEDeleteInitiator(HAND16 Initiator)
{
    LPDDENODE Node, Temp1;

    Node = DDEInitiateList;

    if (Node) {

        while (Node) {
            if (Node->Initiator == Initiator) {

                if (Node == DDEInitiateList) {

                    //
                    // first guy in the list
                    //

                    DDEInitiateList = Node->Next;
                }
                else {

                    //
                    // update the list
                    //

                    Temp1->Next = Node->Next;
                }

                LOGDEBUG(12, ("WOW::WI32DDEDeleteInitiator(): unthunking -- deleting an Initiator %08lX\n", Initiator));

                //
                // free up the memory
                //

                free_w(Node);
                Node = NULL;
            }
            else {

                //
                // traverse the list
                //

                Temp1 = Node;
                Node = Node->Next;
            }
        }

    }
    else {

        // This is an ERROR condition, which should never occur. If it does
        // talk to CHANDANC as soon as possible.
        //

        LOGDEBUG(0, ("WOW::WI32DDEDeletInitiator(): unthunking -- no Initiator\n"));
        WOW32ASSERT (FALSE);
    }
}


// This routine is used by DDE_ACK thunk to figure out how to thunk the
// DDE_ACK message, ie, whether lParam is a combination of 2 atoms or
// its a pointer to 32 bit packed structure.
//

BOOL WI32DDEInitiate(HAND16 Initiator)
{
    LPDDENODE Node;

    Node = DDEInitiateList;

    while (Node) {
        if (Node->Initiator == Initiator) {
            //
            // DDE_Initiate is in progress for this Window
            //

            LOGDEBUG(12, ("WOW::WI32DDEInitiate(): thunking -- found an Initiator %08lX\n", Initiator));
            return (TRUE);
        }
        else {
            Node = Node->Next;
        }
    }
    LOGDEBUG(12, ("WOW::WI32DDEInitiate(): thunking -- did not find an Initiator %08lX\n", Initiator));

    //
    // DDE_Initiate is not in progress for this Window
    //

    return (FALSE);
}


//
// This routine determines if the current dde operation is a poke to MSDRAW
// Pokes to MSDRAW for metafilepicts are special because the metafile pict
// is part of the POKE block.
//

BOOL DDEIsTargetMSDraw(HAND16 To_hwnd)
{
    BOOL   fStatus = FALSE;
    HANDLE hInst;
    HAND16 hModuleName;
    LPSTR  lpszModuleName16, lpszMsDraw = "MSDRAW.EXE";
    WORD   cchModuleName = MAX_PATH, cchMsDraw = 10;
    VPVOID vp;
    LPSTR  lpszNewMsDrawKey = "MSDRAW\\protocol\\StdFileEditing\\verb";
    HKEY   hKey = NULL;
    LONG   Status;

    //
    // To check if the target is msdraw, check the following.
    //
    //  - That the destination window hInst is that of a 16 bit task (this is
    //    checking to see if the LOWORD of the hInst is not 0.
    //  - That the module name is MSDRAW.
    //
    // NOTE: THERE ARE THREE CALLBACK16 ROUTINES IN THIS CALL, MAKING IT AN
    //       EXPENSIVE CALL.  HOWEVER THIS CALL IS RARELY MADE.
    //

    if (
        (hInst = (HANDLE)GetWindowLong((HWND)HWND32(To_hwnd),GWL_HINSTANCE))
        && (LOWORD(hInst) != 0 )
        && (vp = GlobalAllocLock16(GMEM_MOVEABLE, cchModuleName, &hModuleName))
       ) {

        //
        // Callback 16 to get the module name of the current hInst
        //

        if (cchModuleName = GetModuleFileName16( LOWORD(hInst), vp, cchModuleName )) {
            GETMISCPTR(vp, lpszModuleName16);
            fStatus = (cchModuleName >= cchMsDraw)
                      && !WOW32_stricmp( lpszModuleName16 + (cchModuleName - cchMsDraw), lpszMsDraw )
                      && (Status = RegOpenKeyEx( HKEY_CLASSES_ROOT, lpszNewMsDrawKey, 0, KEY_READ, &hKey)) != ERROR_SUCCESS;

            if (hKey) {
                RegCloseKey( hKey );
            }
            FREEMISCPTR(lpszModuleName16);
        }

        //
        // Cleanup
        //

        GlobalUnlockFree16(vp);
    }
    return ( fStatus );
}



// This routine converts a 32 bit DDE memory object into a 16 bit DDE
// memory object. It also, does the data conversion from 32 bit to 16 bit
// for the type of data.
//
// WARNING: The Copyh32Toh16() calls may cause 16-bit memory movement
//

HAND16 DDECopyhData16(HAND16 To_hwnd, HAND16 From_hwnd, HANDLE h32, PDDEINFO pDdeInfo)
{
    HAND16  h16 = 0;
    VPVOID  vp1, vp2;
    DDEDATA *lpMem32;
    DDEDATA16 *lpMem16;
    int cb;

    //
    // NULL handle ?
    //

    if (!h32) {
        LOGDEBUG(12, ("WOW::DDECopyhData16(): h32 is %08x\n", h32));
        return 0;
    }

    cb = GlobalSize(h32);
    lpMem32 = GlobalLock(h32);
    LOGDEBUG(12, ("WOW::DDECopyhData16(): CF_FORMAT is %04x\n", lpMem32->cfFormat));

    switch (lpMem32->cfFormat) {

        default:

        // This is intentional to let it thru to "case statements".
        // ChandanC 5/11/92.

        case CF_TEXT:
        case CF_DSPTEXT:
        case CF_SYLK:
        case CF_DIF:
        case CF_TIFF:
        case CF_OEMTEXT:
        case CF_PENDATA:
        case CF_RIFF:
        case CF_WAVE:
        case CF_OWNERDISPLAY:
            h16 = Copyh32Toh16 (cb, (LPBYTE) lpMem32);

            pDdeInfo->Format = lpMem32->cfFormat;
            break;

        case CF_BITMAP:
        case CF_DSPBITMAP:
            vp1 = GlobalAllocLock16(GMEM_DDESHARE, (sizeof(DDEDATA)-1+sizeof(HAND16)), &h16);
            if (vp1) {
                pDdeInfo->Format = lpMem32->cfFormat;
                GETMISCPTR(vp1, lpMem16);
                RtlCopyMemory(lpMem16, lpMem32, 4);
                STOREWORD(lpMem16->Value, GETHBITMAP16(*((HANDLE *)lpMem32->Value)));
                FLUSHVDMPTR(vp1, (sizeof(DDEDATA)-1+sizeof(HAND16)), lpMem16);
                FREEMISCPTR(lpMem16);
                GlobalUnlock16(h16);
            }
            break;

        case CF_PALETTE:
            vp1 = GlobalAllocLock16(GMEM_DDESHARE, (sizeof(DDEDATA)-1+sizeof(HAND16)), &h16);
            if (vp1) {
                pDdeInfo->Format = lpMem32->cfFormat;
                GETMISCPTR(vp1, lpMem16);
                RtlCopyMemory(lpMem16, lpMem32, 4);
                STOREWORD(lpMem16->Value, GETHPALETTE16(*((HANDLE *)lpMem32->Value)));
                FLUSHVDMPTR(vp1, (sizeof(DDEDATA)-1+sizeof(HAND16)), lpMem16);
                FREEMISCPTR(lpMem16);
                GlobalUnlock16(h16);
            }
            break;

        case CF_DIB:
        {
            LPBYTE lpMemDib32;
            HAND16 hDib16 = 0;
            HANDLE hDib32;

            vp1 = GlobalAllocLock16(GMEM_DDESHARE, (sizeof(DDEDATA)-1+sizeof(HAND16)), &h16);
            if (vp1) {

                GETMISCPTR(vp1, lpMem16);
                RtlCopyMemory(lpMem16, lpMem32, 4);
                FREEMISCPTR(lpMem16);

                hDib32 = (*((HANDLE *)lpMem32->Value));
                if (hDib32) {
                    lpMemDib32 = GlobalLock(hDib32);
                    cb = GlobalSize(hDib32);
                    hDib16 = Copyh32Toh16 (cb, (LPBYTE) lpMemDib32);
                    GlobalUnlock(hDib32);
                    pDdeInfo->Format = lpMem32->cfFormat;
                    pDdeInfo->Flags = 0;
                    pDdeInfo->h16 = 0;
                    DDEAddhandle(To_hwnd, From_hwnd, (HAND16) hDib16, hDib32, pDdeInfo);

                }

                GETMISCPTR(vp1, lpMem16);
                STOREWORD(lpMem16->Value, hDib16);
                GlobalUnlock16(h16);
                FLUSHVDMPTR(vp1, (sizeof(DDEDATA)-1+sizeof(HAND16)), lpMem16);
                FREEMISCPTR(lpMem16);
            }
        }
        break;

        case CF_METAFILEPICT:
        case CF_DSPMETAFILEPICT:
        {
            HANDLE hMeta32, hMF32 = NULL;
            HAND16 hMeta16 = 0, hMF16 = 0;
            LPMETAFILEPICT lpMemMeta32;
            LPMETAFILEPICT16 lpMemMeta16;
            BOOL IsMSDRAWPoke;

            //
            // We need to find out if the to_handle is MSDRAW, in which case
            // we should copy the METAFILEPICT data to the DDEPOKE instead
            // of a handle to the METAFILEPICT.

            if( IsMSDRAWPoke = ((pDdeInfo->Msg == WM_DDE_POKE) && DDEIsTargetMSDraw(To_hwnd)) ) {
                cb  = sizeof(DDEPOKE)-1+sizeof(METAFILEPICT16);
            }
            else {
                cb  = sizeof(DDEDATA)-1+sizeof(HAND16);
            }
            vp1 = GlobalAllocLock16(GMEM_DDESHARE, cb, &h16);


            if (vp1) {
                GETMISCPTR(vp1, lpMem16);
                RtlCopyMemory(lpMem16, lpMem32, 4);
                hMeta32 = (*((HANDLE *)lpMem32->Value));

                if ( IsMSDRAWPoke ) {

                    lpMemMeta16 = (LPMETAFILEPICT16)((PBYTE)lpMem16 + sizeof(DDEPOKE) - 1);
                    RtlZeroMemory( (PVOID)lpMemMeta16, sizeof (METAFILEPICT16) );
                    if (hMeta32) {
                        lpMemMeta32 = GlobalLock(hMeta32);
                        FixMetafile32To16 (lpMemMeta32, lpMemMeta16);
                        FREEMISCPTR(lpMem16);

                        hMF32 = lpMemMeta32->hMF;
                        if (hMF32) {
                            hMF16 = WinMetaFileFromHMF(hMF32, FALSE);
                            pDdeInfo->Format = lpMem32->cfFormat;
                            pDdeInfo->h16 = 0;
                            pDdeInfo->Flags = DDE_METAFILE;
                            DDEAddhandle(To_hwnd, From_hwnd, (HAND16) hMF16, hMF32, pDdeInfo);
                        }

                        GETMISCPTR(vp1, lpMem16);
                        lpMemMeta16 = (LPMETAFILEPICT16)((PBYTE)lpMem16 + sizeof(DDEPOKE) - 1);
                        STOREWORD(lpMemMeta16->hMF, hMF16);
                        GlobalUnlock(hMeta32);
                    }

                }
                else {
                    if (hMeta32) {
                        lpMemMeta32 = GlobalLock(hMeta32);
                        FREEMISCPTR(lpMem16);
                        vp2 = GlobalAllocLock16(GMEM_DDESHARE, sizeof(METAFILEPICT16), &hMeta16);
                        WOW32ASSERT(vp2);
                        if (vp2) {
                            GETMISCPTR(vp2, lpMemMeta16);
                            FixMetafile32To16 (lpMemMeta32, lpMemMeta16);
                            FREEMISCPTR(lpMemMeta16);

                            pDdeInfo->Format = lpMem32->cfFormat;
                            pDdeInfo->Flags = 0;
                            pDdeInfo->h16 = 0;
                            DDEAddhandle(To_hwnd, From_hwnd, (HAND16) hMeta16, hMeta32, pDdeInfo);
                            hMF32 = lpMemMeta32->hMF;
                            if (hMF32) {
                                hMF16 = WinMetaFileFromHMF(hMF32, FALSE);
                                pDdeInfo->Flags = DDE_METAFILE;
                                DDEAddhandle(To_hwnd, From_hwnd, (HAND16) hMF16, hMF32, pDdeInfo);
                            }

                            GETMISCPTR(vp2, lpMemMeta16);
                            STOREWORD(lpMemMeta16->hMF, hMF16);
                            GlobalUnlock16(hMeta16);
                            FLUSHVDMPTR(vp2, 8, lpMemMeta16);
                            FREEMISCPTR(lpMemMeta16);
                        }
                        GlobalUnlock(hMeta32);
                    }
                    GETMISCPTR(vp1, lpMem16);
                    STOREWORD(lpMem16->Value, hMeta16);
                }

                GlobalUnlock16(h16);
                FLUSHVDMPTR(vp1, cb, lpMem16);
                FREEMISCPTR(lpMem16);
            }
        }
        break;
    }

    GlobalUnlock(h32);

    return (h16);
}




// This routine converts a 16 bit DDE memory object into a 32 bit DDE
// memory object. It also, does the data conversion from 16 bit to 32 bit
// for the type of data.
//

HANDLE  DDECopyhData32(HAND16 To_hwnd, HAND16 From_hwnd, HAND16 h16, PDDEINFO pDdeInfo)
{
    HANDLE  h32 = NULL;
    INT     cb;
    VPVOID  vp;
    DDEDATA *lpMem16;
    DDEDATA32 *lpMem32;

    //
    // AmiPro passes a NULL handle.
    //

    if (!h16) {
        LOGDEBUG(12, ("WOW::DDECopyhData16(): h16 is %04x\n", h16));
        return (HANDLE) NULL;
    }

    vp = GlobalLock16(h16, &cb);
    GETMISCPTR(vp, lpMem16);
    LOGDEBUG(12, ("WOW::DDECopyhData32(): CF_FORMAT is %04x\n", lpMem16->cfFormat));

    switch(lpMem16->cfFormat) {

        default:

        // This is intentional to let it thru to the "case statements".
        // ChandanC 5/11/92.

        case CF_TEXT:
        case CF_DSPTEXT:
        case CF_SYLK:
        case CF_DIF:
        case CF_TIFF:
        case CF_OEMTEXT:
        case CF_PENDATA:
        case CF_RIFF:
        case CF_WAVE:
        case CF_OWNERDISPLAY:
            h32 = Copyh16Toh32 (cb, (LPBYTE) lpMem16);

            pDdeInfo->Format = lpMem16->cfFormat;
        break;

        case CF_BITMAP:
        case CF_DSPBITMAP:
            h32 = WOWGLOBALALLOC(GMEM_DDESHARE, (sizeof(DDEDATA)-1+sizeof(HANDLE)));
            if (h32) {
                pDdeInfo->Format = lpMem16->cfFormat;
                lpMem32 = GlobalLock(h32);
                RtlCopyMemory(lpMem32, lpMem16, 4);
                lpMem32->Value = HBITMAP32(FETCHWORD(*((WORD *)lpMem16->Value)));
                GlobalUnlock(h32);
            }
            break;

        case CF_PALETTE:
            h32 = WOWGLOBALALLOC(GMEM_DDESHARE, (sizeof(DDEDATA)-1+sizeof(HANDLE)));
            if (h32) {
                pDdeInfo->Format = lpMem16->cfFormat;
                lpMem32 = GlobalLock(h32);
                RtlCopyMemory(lpMem32, lpMem16, 4);
                lpMem32->Value = HPALETTE32(FETCHWORD(*((WORD *)lpMem16->Value)));
                GlobalUnlock(h32);
            }
            break;

        case CF_DIB:
        {
            LPBYTE lpMemDib16;
            HAND16 hDib16;
            HANDLE hDib32 = NULL;

            h32 = WOWGLOBALALLOC(GMEM_DDESHARE, (sizeof(DDEDATA)-1+sizeof(HANDLE)));
            if (h32) {
                lpMem32 = GlobalLock(h32);
                RtlCopyMemory(lpMem32, lpMem16, 4);

                hDib16 = FETCHWORD(*((WORD *)lpMem16->Value));
                if (hDib16) {
                    vp = GlobalLock16(hDib16, &cb);
                    GETMISCPTR(vp, lpMemDib16);
                    hDib32 = Copyh16Toh32 (cb, (LPBYTE) lpMemDib16);

                    pDdeInfo->Format = lpMem16->cfFormat;
                    pDdeInfo->Flags = 0;
                    pDdeInfo->h16 = 0;
                    DDEAddhandle(To_hwnd, From_hwnd, (HAND16) hDib16, hDib32, pDdeInfo);

                    GlobalUnlock16(hDib16);
                    FREEMISCPTR(lpMemDib16);
                }
                lpMem32->Value = hDib32;
                GlobalUnlock(h32);
            }
        }
        break;

        case CF_METAFILEPICT:
        case CF_DSPMETAFILEPICT:
        {
            HANDLE hMeta32 = NULL, hMF32 = NULL;
            HAND16 hMeta16, hMF16 = 0;
            LPMETAFILEPICT lpMemMeta32;
            LPMETAFILEPICT16 lpMemMeta16;

            h32 = WOWGLOBALALLOC(GMEM_DDESHARE, (sizeof(DDEDATA)-1+sizeof(HANDLE)));
            if (h32) {
                lpMem32 = GlobalLock(h32);
                RtlCopyMemory(lpMem32, lpMem16, 4);

                //
                // MSDRAW has the METAFILEPICT in the DDEPOKE block instead of
                // a handle to the METAFILEPICT.  So we need to find out if the
                // to handle belongs to MSDRAW.  Since MSDRAW is a 16 bit
                // server we needn't thunk the metafilepict at all, we will just
                // use NULL as the 32 bit handle to the metafilepict.
                //

                hMeta32 = NULL;
                if( !((pDdeInfo->Msg == WM_DDE_POKE) && DDEIsTargetMSDraw(To_hwnd)) ) {

                    hMeta16 = FETCHWORD(*((WORD *)lpMem16->Value));

                    //
                    // Make sure that a valid metafile pict handle has been
                    // passed in otherwise use NULL again as the hMeta32.
                    //

                    if (hMeta16 && (vp = GlobalLock16(hMeta16, &cb))) {
                        GETMISCPTR(vp, lpMemMeta16);
                        hMeta32 = WOWGLOBALALLOC(GMEM_DDESHARE, sizeof(METAFILEPICT));
                        WOW32ASSERT(hMeta32);
                        if (hMeta32) {
                            lpMemMeta32 = GlobalLock(hMeta32);
                            lpMemMeta32->mm = (LONG) FETCHSHORT(lpMemMeta16->mm);
                            lpMemMeta32->xExt = (LONG) FETCHSHORT(lpMemMeta16->xExt);
                            lpMemMeta32->yExt = (LONG) FETCHSHORT(lpMemMeta16->yExt);
                            pDdeInfo->Format = lpMem16->cfFormat;
                            pDdeInfo->Flags = 0;
                            pDdeInfo->h16 = 0;
                            DDEAddhandle(To_hwnd, From_hwnd, (HAND16) hMeta16, hMeta32, pDdeInfo);

                            hMF16 = FETCHWORD(lpMemMeta16->hMF);

                            if (hMF16) {
                                hMF32 = (HMETAFILE) HMFFromWinMetaFile(hMF16, FALSE);
                                pDdeInfo->Flags = DDE_METAFILE;
                                DDEAddhandle(To_hwnd, From_hwnd, (HAND16) hMF16, hMF32, pDdeInfo);
                            }

                            lpMemMeta32->hMF = (HMETAFILE) hMF32;
                            GlobalUnlock(hMeta32);
                        }
                        GlobalUnlock16(hMeta16);
                        FREEMISCPTR(lpMemMeta16);
                    }
                }
                lpMem32->Value = hMeta32;
                GlobalUnlock(h32);
            }
        }
        break;
    }

    GlobalUnlock16(h16);

    FREEMISCPTR(lpMem16);
    return (h32);
}


/****** These routines maintain a linked list of dde handles, which
******* are the h16 and h32 pairs.
******/



//  This routine adds the given h16-h32 pair to the linked list, and updates
//  the list.
//

BOOL DDEAddhandle(HAND16 To_hwnd, HAND16 From_hwnd, HAND16 hMem16, HANDLE hMem32, PDDEINFO pDdeInfo)
{
    PHDDE   phTemp;

    if (hMem16 && hMem32) {
        if (phTemp = malloc_w (sizeof(HDDE))) {
            phTemp->hMem16    = hMem16;
            phTemp->hMem32    = hMem32;
            phTemp->To_hwnd   = To_hwnd;
            phTemp->From_hwnd = From_hwnd;

            phTemp->DdeMsg    = pDdeInfo->Msg;
            phTemp->DdeFormat = pDdeInfo->Format;
            phTemp->DdeFlags  = pDdeInfo->Flags;

            phTemp->h16       = pDdeInfo->h16;

            phTemp->pDDENext  = phDDEFirst;     // insert at the top
            phDDEFirst        = phTemp;         // update list head

            // Mark the GAH_WOWDDEFREEHANDLE (ie GAH_PAHTOM) bit in the global
            // arena of this handle.

            W32MarkDDEHandle (hMem16);

            return (TRUE);
        }
        else {
            LOGDEBUG(2, ("WOW::DDEAddhandle(): *** memory allocation failed *** \n"));
            return (FALSE);
        }
    }

    LOGDEBUG(2,("WOW::DDEAddhandle(): *** ERROR *** one of the handles is NULL \n"));
    return (FALSE);
}


//  This routine deletes the given h16-h32 pair from the list and frees up
//   the memory.
//

BOOL DDEDeletehandle(HAND16 h16, HANDLE h32)
{
    PHDDE   phTemp1, phTemp2;

    phTemp1 = phDDEFirst;

    if ((phTemp1->hMem16 == h16) && (phTemp1->hMem32 == h32)) {  // first node
        phDDEFirst = phTemp1->pDDENext;
        free_w(phTemp1);
        return (TRUE);
    }
    else {                // rest of the list
        phTemp2 = phTemp1;
        phTemp1 = phTemp1->pDDENext;

        while (phTemp1) {
            if ((phTemp1->hMem16 == h16) && (phTemp1->hMem32 == h32)) {
                phTemp2->pDDENext = phTemp1->pDDENext;
                free_w(phTemp1);
                return (TRUE);
            }
            phTemp2 = phTemp1;
            phTemp1 = phTemp1->pDDENext;
        }

        LOGDEBUG (2, ("WOW::DDEDeleteHandle : Can't find a 16-32 memory pair\n"));
//        WOW32ASSERT (FALSE);

        return (FALSE);
    }
}


// This routine finds a hMem16 for a DDE conversation, if one exists.
//

HAND16 DDEFindPair16(HAND16 To_hwnd, HAND16 From_hwnd, HANDLE hMem32)
{
    PHDDE   phTemp;

    phTemp = phDDEFirst;

    while (phTemp) {
        if ((phTemp->To_hwnd == To_hwnd) &&
            (phTemp->From_hwnd == From_hwnd) &&
            (phTemp->hMem32 == hMem32)) {
                return (phTemp->hMem16);
        }
        else {
            phTemp = phTemp->pDDENext;
        }
    }
    return (HAND16) NULL;
}


// This routine finds a hMem32 for a DDE conversation, if one exists.
//

HANDLE DDEFindPair32(HAND16 To_hwnd, HAND16 From_hwnd, HAND16 hMem16)
{
    PHDDE   phTemp;

    phTemp = phDDEFirst;

    while (phTemp) {
        if ((phTemp->To_hwnd == To_hwnd) &&
            (phTemp->From_hwnd == From_hwnd) &&
            (phTemp->hMem16 == hMem16)) {
                return (phTemp->hMem32);
        }
        else {
            phTemp = phTemp->pDDENext;
        }
    }
    return (HANDLE) NULL;
}


// This routine find the DDE node that is doing DDE conversation
//

PHDDE DDEFindNode16 (HAND16 h16)
{
    PHDDE   phTemp;

    phTemp = phDDEFirst;

    while (phTemp) {
        if (phTemp->hMem16 == h16) {
            return (phTemp);
        }
        phTemp = phTemp->pDDENext;
    }

    return (NULL);
}


// This routine find the DDE node that is doing DDE conversation
//

PHDDE DDEFindNode32 (HANDLE h32)
{
    PHDDE   phTemp;

    phTemp = phDDEFirst;

    while (phTemp) {
        if (phTemp->hMem32 == h32) {
            return (phTemp);
        }
        phTemp = phTemp->pDDENext;
    }

    return (NULL);
}


// This routine returns a pointer to the DDE node, if the conversation exists,
// else it retunrs NULL

PHDDE DDEFindAckNode (HAND16 To_hwnd, HAND16 From_hwnd, HANDLE hMem32)
{
    PHDDE   phTemp;

    phTemp = phDDEFirst;

    while (phTemp) {
        if ((phTemp->To_hwnd == To_hwnd) &&
            (phTemp->From_hwnd == From_hwnd) &&
            (phTemp->hMem32 == hMem32)) {
                return (phTemp);
        }
        else {
            phTemp = phTemp->pDDENext;
        }
    }
    return (PHDDE) NULL;
}


//  This function marks GAH_WOWDDEFREEHANDLE bit in the global arena of the
//  hMem16.
//

VOID W32MarkDDEHandle (HAND16 hMem16)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    Parm16.WndProc.wParam = hMem16;
    Parm16.WndProc.wMsg = 1;
    CallBack16(RET_WOWDDEFREEHANDLE, &Parm16, 0, &vp);
}

VOID W32UnMarkDDEHandle (HAND16 hMem16)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    Parm16.WndProc.wParam = hMem16;
    Parm16.WndProc.wMsg = 0;
    CallBack16(RET_WOWDDEFREEHANDLE, &Parm16, 0, &vp);
}

// This function frees the 32 and 16 bit memory. It is called by 32 bit
// BASE by GlobalFree.
//

BOOL W32DDEFreeGlobalMem32 (HANDLE h32)
{
    HAND16 h16;
    PHDDE pDdeNode;
    BOOL fOkToFree = TRUE;

    if (h32) {
        if (pDdeNode = DDEFindNode32(h32)) {

            if (pDdeNode->DdeFlags & DDE_METAFILE) {
                LOGDEBUG (12, ("WOW32: W32DDEFreeGlobalMem32: Freeing MetaFile hMF32 %x\n", h32));
                DeleteMetaFile (h32);
                fOkToFree = FALSE;
            }

            while ((pDdeNode) && (h16 = pDdeNode->hMem16)) {
                W32UnMarkDDEHandle (h16);
                GlobalUnlockFree16(GlobalLock16(h16, NULL));
                DDEDeletehandle(h16, h32);
                pDdeNode = DDEFindNode32(h32);
            }
        }
        else {

            LOGDEBUG (2, ("WOW32: W32DDEFreeGlobalMem32: Can't find a 16-32 memory pair\n"));
        }
    }
    else {
        WOW32WARNMSG(FALSE, "WOW32: W32DDEFreeGlobalMem32: h32 is NULL to Win32 GlobalFree\n");
        /*
         * since in this case the Failure and Success return values from
         * GlobalFree are NULL, just return false so things are faster
         * in GlobalFree.
         */
        fOkToFree = FALSE;
    }

    return(fOkToFree);
}


// This function frees only the 32 bit memory because the 16 bit memory
// is being free'd by the 16 bit app. We are just getting the
// notification of this fact.  So free the corresponding 32 bit memory.
//

ULONG FASTCALL WK32WowDdeFreeHandle (PVDMFRAME pFrame)
{
    ULONG  ul;
    HAND16 h16;
    PWOWDDEFREEHANDLE16 parg16;

    GETARGPTR(pFrame, sizeof(WOWDDEFREEHANDLE16), parg16);

    h16 = (HAND16) parg16->h16;

    ul = W32DdeFreeHandle16 (h16);

    FREEARGPTR(parg16);
    RETURN (ul);
}


BOOL W32DdeFreeHandle16 (HAND16 h16)
{
    HANDLE h32;
    PHDDE pDdeNode;

    if (!(pDdeNode = DDEFindNode16(h16))) {
        LOGDEBUG (12, ("WOW::W32DdeFreeHandle16 : Not found h16 -> %04x\n", h16));

        // in this case look for a 16:32 pair in the list of hdrop handles
        // see file wshell.c for comments
        FindAndReleaseHDrop16(h16);

        return (TRUE);
    }

    LOGDEBUG (12, ("WOW::W32DdeFreeHandle16 : Entering... h16 -> %04x\n", h16));

    if (pDdeNode->DdeMsg == WM_DDE_EXECUTE) {
        LOGDEBUG (12, ("WOW::W32DdeFreeHandle16 : App TRYING  !!! to freeing EXECUTE h16 -> %04x\n", h16));
        pDdeNode->DdeFlags = pDdeNode->DdeFlags | DDE_EXECUTE_FREE_MEM;
        return (FALSE);
    }
    else {
        while ((pDdeNode) && (h32 = pDdeNode->hMem32)) {
            if (pDdeNode->DdeFlags & DDE_METAFILE) {
                DDEDeletehandle(h16, h32);
                DeleteMetaFile (h32);
            }
            else {
                /*
                 * REMOVE THE PAIR FIRST!!!
                 * Since GlobalFree will hook back to W32DDEFreeGlobalMem32
                 * we want to remove the handle from our tables before
                 * the call.
                 */
                DDEDeletehandle(h16, h32);
                WOWGLOBALFREE(h32);
            }

            pDdeNode = DDEFindNode16(h16);
        }
    }

    LOGDEBUG (12, ("WOW::W32DdeFreeHandle16 : Leaving ...\n"));
    return (TRUE);
}


//  This routine adds the given h16-h32 CopyData pair to the linked list,
//  and updates the list.
//

BOOL CopyDataAddNode (HAND16 To_hwnd, HAND16 From_hwnd, DWORD Mem16, DWORD Mem32, DWORD Flags)
{
    PCPDATA pTemp;

    if (Mem16 && Mem32) {
        if (pTemp = malloc_w (sizeof(CPDATA))) {
            pTemp->Mem16    = Mem16;
            pTemp->Mem32    = Mem32;
            pTemp->To_hwnd  = To_hwnd;
            pTemp->From_hwnd= From_hwnd;
            pTemp->Flags    = Flags;
            pTemp->Next     = pCPDataFirst;     // insert at the top
            pCPDataFirst    = pTemp;         // update list head

            return (TRUE);
        }
        else {
            LOGDEBUG(2, ("WOW::CopyDataAddNode: *** memory allocation failed *** \n"));
            return (FALSE);
        }
    }

    LOGDEBUG(2,("WOW::CopyDataAddNode: *** ERROR *** one of the memory pointers is NULL \n"));
    return (FALSE);
}


VPVOID CopyDataFindData16 (HWND16 To_hwnd, HWND16 From_hwnd, DWORD Mem)
{
    PCPDATA pTemp;

    pTemp = pCPDataFirst;

    while (pTemp) {
        if ((pTemp->To_hwnd == To_hwnd) &&
            (pTemp->From_hwnd == From_hwnd) &&
            (pTemp->Mem32 == Mem)) {
                return (pTemp->Mem16);
        }
        else {
            pTemp = pTemp->Next;
        }
    }
    return 0;
}


PCPDATA CopyDataFindData32 (HWND16 To_hwnd, HWND16 From_hwnd, DWORD Mem)
{
    PCPDATA pTemp;

    pTemp = pCPDataFirst;

    while (pTemp) {
        if ((pTemp->To_hwnd == To_hwnd) &&
            (pTemp->From_hwnd == From_hwnd) &&
            (pTemp->Mem16 == Mem)) {
                return (pTemp);
        }
        else {
            pTemp = pTemp->Next;
        }
    }
    return 0;
}


//  This routine deletes the given h16-h32 pair from the list.
//
//

BOOL CopyDataDeleteNode (HWND16 To_hwnd, HWND16 From_hwnd, DWORD Mem)
{
    PCPDATA pTemp1;
    PCPDATA pTemp2;

    pTemp1 = pCPDataFirst;

    if ((pTemp1->To_hwnd == To_hwnd) &&
        (pTemp1->From_hwnd == From_hwnd) &&
        (pTemp1->Mem32 == Mem)) {
        pCPDataFirst = pTemp1->Next;
        free_w (pTemp1);
        return (TRUE);
    }
    else {
        pTemp2 = pTemp1;
        pTemp1 = pTemp1->Next;

        while (pTemp1) {
            if ((pTemp1->To_hwnd == To_hwnd) &&
                (pTemp1->From_hwnd == From_hwnd) &&
                (pTemp1->Mem32 == Mem)) {
                    pTemp2->Next = pTemp1->Next;
                    free_w (pTemp1);
                    return (TRUE);
            }

            pTemp2 = pTemp1;
            pTemp1 = pTemp1->Next;
        }
        return (FALSE);
    }

}


// While allocating GMEM_DDESHARE memory object should we have GMEM_MOVEABLE
// flag or not ???????????????????
// ChandanC Sept 23rd 1993.
//
// WARNING: This function may cause 16-bit memory movement.
//

HAND16  Copyh32Toh16 (int cb, LPBYTE lpMem32)
{
    HAND16  h16 = 0;
    LPBYTE  lpMem16;
    VPVOID  vp;

    vp = GlobalAllocLock16(GMEM_DDESHARE | GMEM_MOVEABLE, cb, &h16);
    WOW32ASSERT(vp);
    if (vp) {
        GETMISCPTR(vp, lpMem16);
        RtlCopyMemory(lpMem16, lpMem32, cb);
        GlobalUnlock16(h16);
        FLUSHVDMPTR(vp, cb, lpMem16);
        FREEMISCPTR(lpMem16);
    }

    return (h16);
}


HANDLE  Copyh16Toh32 (int cb, LPBYTE lpMem16)
{
    HANDLE hMem32;
    LPBYTE  lpMem32;

    hMem32 = WOWGLOBALALLOC(GMEM_DDESHARE | GMEM_MOVEABLE, cb);
    WOW32ASSERT(hMem32);
    if (hMem32) {
        lpMem32 = GlobalLock(hMem32);
        RtlCopyMemory (lpMem32, lpMem16, cb);
        GlobalUnlock(hMem32);
    }

    return (hMem32);
}


VOID  FixMetafile32To16 (LPMETAFILEPICT lpMemMeta32, LPMETAFILEPICT16 lpMemMeta16)
{

    if (lpMemMeta32->mm == MM_ANISOTROPIC) {
        LONG xExt = lpMemMeta32->xExt;
        LONG yExt = lpMemMeta32->yExt;

        while (xExt < (LONG)(SHORT)MINSHORT
            || xExt > (LONG)(SHORT)MAXSHORT
            || yExt < (LONG)(SHORT)MINSHORT
            || yExt > (LONG)(SHORT)MAXSHORT) {
            xExt = xExt / 2;
            yExt = yExt / 2;
        }
        STORESHORT(lpMemMeta16->mm,   MM_ANISOTROPIC);
        STORESHORT(lpMemMeta16->xExt, xExt);
        STORESHORT(lpMemMeta16->yExt, yExt);
    }
    else {
        STORESHORT(lpMemMeta16->mm,   lpMemMeta32->mm);
        STORESHORT(lpMemMeta16->xExt, lpMemMeta32->xExt);
        STORESHORT(lpMemMeta16->yExt, lpMemMeta32->yExt);
    }
}

//
// CHEESE ALERT: This function is exported for the OLE DDE code
// to call so it can correctly free up metafile handle pairs in
// a VDM. This function is NOT found in any header files. If you
// change this, you need to find its use in the OLE project.
// Probably best to just leave it alone.
//
BOOL WINAPI WOWFreeMetafile( HANDLE h32 )
{
    return( W32DDEFreeGlobalMem32( h32 ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wddeml32.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WDDEML.H
 *  WOW32 16-bit DDEML API support
 *
 *  History:
 *  Created Jan-23-1993 by Chandan Chauhan (ChandanC)
--*/

#define MAX_CONVS   3200

typedef struct _BIND1632 {
    DWORD  x16;
    DWORD  x32;
} BIND1632;

ULONG FASTCALL WD32DdeInitialize(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeUninitialize(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeConnectList(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeQueryNextServer(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeDisconnectList(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeConnect(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeDisconnect(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeQueryConvInfo(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeSetUserHandle(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeClientTransaction(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeAbandonTransaction(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdePostAdvise(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeCreateDataHandle(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeAddData(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeGetData(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeAccessData(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeUnaccessData(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeFreeDataHandle(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeGetLastError(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeCreateStringHandle(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeFreeStringHandle(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeQueryString(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeKeepStringHandle(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeEnableCallback(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeNameService(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeCmpStringHandles(PVDMFRAME pFrame);
ULONG FASTCALL WD32DdeReconnect(PVDMFRAME pFrame);
HDDEDATA W32DdemlCallBack(UINT type, UINT fmt, HCONV hconv, HSZ hsz1,
                        HSZ hsz2, HDDEDATA hData, DWORD dwData1,
                        DWORD dwData2);
VOID WOWDdemlBind (DWORD x16, DWORD x32, BIND1632 aBind[]);
VOID WOWDdemlUnBind (DWORD x32, BIND1632 aBind[]);
DWORD WOWDdemlGetBind16 (DWORD x32, BIND1632 aBind[]);
DWORD WOWDdemlGetBind32 (DWORD x16, BIND1632 aBind[]);
BOOL DdeDataBuf16to32(PVOID p16DdeData, LPBYTE *pp32DdeData, PDWORD pcbData,
        PDWORD pcbOffset, UINT format);
BOOL DdeDataBuf32to16(PVOID p16DdeData, PVOID p32DdeData, DWORD cbData,
        DWORD cbOffset, UINT format);
VOID DdeDataSize16to32(DWORD *pcbData, DWORD *pcbOff, UINT format);
VOID DdeDataSize32to16(DWORD *pcbData, DWORD *pcbOff, UINT format);
VOID W32GetConvContext (VPVOID vp, PCONVCONTEXT pCC32);
VOID W32PutConvContext (VPVOID vp, PCONVCONTEXT pCC32);

/*
 * Imports from user32.dll - need to eventually be moved to winuserp.h
 * or ddemlp.h
 */
BOOL DdeIsDataHandleInitialized(HDDEDATA hData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wddetbl2.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WDDETBL2.h
 *  WOW32 16-bit DDEML API tables
 *
 *  History:
 *  Created 26-Jan-1993 by Chandan Chauhan (ChandanC)
--*/


    {W32FUN(UNIMPLEMENTEDAPI,                 "DUMMYENTRY",               MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(WD32DdeInitialize,                "DDEINITIALIZE",            MOD_DDEML,   sizeof(DDEINITIALIZE16))},
    {W32FUN(WD32DdeUninitialize,              "DDEUNINITIALIZE",          MOD_DDEML,   sizeof(DDEUNINITIALIZE16))},
    {W32FUN(WD32DdeConnectList,               "DDECONNECTLIST",           MOD_DDEML,   sizeof(DDECONNECTLIST16))},
    {W32FUN(WD32DdeQueryNextServer,           "DDEQUERYNEXTSERVER",       MOD_DDEML,   sizeof(DDEQUERYNEXTSERVER16))},
    {W32FUN(WD32DdeDisconnectList,            "DDEDISCONNECTLIST",        MOD_DDEML,   sizeof(DDEDISCONNECTLIST16))},
    {W32FUN(WD32DdeConnect,                   "DDECONNECT",               MOD_DDEML,   sizeof(DDECONNECT16))},
    {W32FUN(WD32DdeDisconnect,                "DDECONNECT",               MOD_DDEML,   sizeof(DDEDISCONNECT16))},
    {W32FUN(WD32DdeQueryConvInfo,             "DDEQUERYCONVINFO",         MOD_DDEML,   sizeof(DDEQUERYCONVINFO16))},
    {W32FUN(WD32DdeSetUserHandle,              "DDESETUSERHANDLE",        MOD_DDEML,   sizeof(DDESETUSERHANDLE16))},

  /*** 0011 ***/
    {W32FUN(WD32DdeClientTransaction,         "DDECLIENTTRANSACTION",     MOD_DDEML,   sizeof(DDECLIENTTRANSACTION16))},
    {W32FUN(WD32DdeAbandonTransaction,        "DDEABANDONTRANSACTION",    MOD_DDEML,   sizeof(DDEABANDONTRANSACTION16))},
    {W32FUN(WD32DdePostAdvise,                "DDEPOSTADVISE",            MOD_DDEML,   sizeof(DDEPOSTADVISE16))},
    {W32FUN(WD32DdeCreateDataHandle,          "DDECREATEDATAHANDLE",      MOD_DDEML,   sizeof(DDECREATEDATAHANDLE16))},
    {W32FUN(WD32DdeAddData,                   "DDEADDDATA",               MOD_DDEML,   sizeof(DDEADDDATA16))},
    {W32FUN(WD32DdeGetData,                   "DDEGETDATA",               MOD_DDEML,   sizeof(DDEGETDATA16))},
    {W32FUN(WD32DdeAccessData,                "DDEACCESSDATA",            MOD_DDEML,   sizeof(DDEACCESSDATA16))},
    {W32FUN(WD32DdeUnaccessData,              "DDEUNACCESSDATA",          MOD_DDEML,   sizeof(DDEUNACCESSDATA16))},
    {W32FUN(WD32DdeFreeDataHandle,            "DDEFREEDATAHANDLE",        MOD_DDEML,   sizeof(DDEFREEDATAHANDLE16))},
    {W32FUN(WD32DdeGetLastError,              "DDEGETLASTERROR",          MOD_DDEML,   sizeof(DDEGETLASTERROR16))},

  /*** 0021 ***/
    {W32FUN(WD32DdeCreateStringHandle,        "DDECREATESTRINGHANDLE",    MOD_DDEML,   sizeof(DDECREATESTRINGHANDLE16))},
    {W32FUN(WD32DdeFreeStringHandle,          "DDEFREESTRINGHANDLE",      MOD_DDEML,   sizeof(DDEFREESTRINGHANDLE16))},
    {W32FUN(WD32DdeQueryString,               "DDEQUERYSTRING",           MOD_DDEML,   sizeof(DDEQUERYSTRING16))},
    {W32FUN(WD32DdeKeepStringHandle,          "DDEKEEPSTRINGHANDLE",      MOD_DDEML,   sizeof(DDEKEEPSTRINGHANDLE16))},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(WD32DdeEnableCallback,            "DDEENABLECALLBACK",        MOD_DDEML,   sizeof(DDEENABLECALLBACK16))},
    {W32FUN(WD32DdeNameService,               "DDENAMESERVICE",           MOD_DDEML,   sizeof(DDENAMESERVICE16))},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},

  /*** 0031 ***/
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(WD32DdeCmpStringHandles,          "DDECMPSTRINGHANDLES",      MOD_DDEML,   sizeof(DDECMPSTRINGHANDLES16))},
    {W32FUN(WD32DdeReconnect,                 "DDERECONNECT",             MOD_DDEML,   sizeof(DDERECONNECT16))},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,                 "",                         MOD_DDEML,   0)},

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wcuricon.c ===
//*****************************************************************************
//
// Cursor and Icon compatibility Support -
//
//     Support for apps - which do a GlobalLock on Cursors and Icons to
//     create headaches for us.
//
//     A compatibility issue.
//
//
// 21-Apr-92  NanduriR   Created.
//
//*****************************************************************************

#include "precomp.h"
#pragma hdrstop

MODNAME(wcuricon.c);


extern void FreeAccelAliasEntry(LPACCELALIAS lpT);

LPCURSORICONALIAS lpCIAlias = NULL;
UINT              cPendingCursorIconUpdates = 0;

//*****************************************************************************
//
// W32CreateCursorIcon32 -
//
//     Creates a 32bit Cursor or Icon given a WIN31 Cursor or Icon HANDLE.
//     The Cursor of Icon handle must correspond to an object that has
//     been created (like CreateIcon). That is because the format of a
//     resource cursor differs from that of a 'created'  cursor.
//
//     Returns the 32bit handle
//
//*****************************************************************************


HANDLE W32CreateCursorIcon32(LPCURSORICONALIAS lpCIAliasIn)
{
    HANDLE  hT;
    PCURSORSHAPE16 pcurs16;
    UINT   flType;

    int     nWidth;
    int     nHeight;
    int     nPlanes;
    int     nBitsPixel;
    DWORD   nBytesAND;
    LPBYTE  lpBitsAND;
    LPBYTE  lpBitsXOR;
    int     ScanLen16;


    pcurs16 = (PCURSORSHAPE16)lpCIAliasIn->pbDataNew;

    flType = lpCIAliasIn->flType;
    if (flType & HANDLE_TYPE_UNKNOWN) {
        if (PROBABLYCURSOR(FETCHWORD(pcurs16->BitsPixel),
                                              FETCHWORD(pcurs16->Planes)))
            flType = HANDLE_TYPE_CURSOR;
        else
            flType = HANDLE_TYPE_ICON;
    }

    nWidth     = INT32(FETCHWORD(pcurs16->cx));
    nHeight    = INT32(FETCHWORD(pcurs16->cy));

    nPlanes    = 1;
    nBitsPixel = 1;                                  // Monochrome

    // Get the AND mask bits

    ScanLen16 = (((nWidth*nBitsPixel)+15)/16) * 2 ;  // bytes/scan in 16 bit world
                                                     // effectively nBitsPixel is 1
    nBytesAND = ScanLen16*nHeight*nPlanes;
    lpBitsAND = (LPBYTE)pcurs16 + sizeof(CURSORSHAPE16);

    // Get the XOR mask bits

    if (flType == HANDLE_TYPE_ICON) {
        nPlanes    = INT32(FETCHWORD(pcurs16->Planes));
        nBitsPixel = INT32(FETCHWORD(pcurs16->BitsPixel));  // the actual value
    }

    lpBitsXOR = (LPBYTE)lpBitsAND + nBytesAND;

    lpCIAliasIn->flType = (BYTE)flType;

    if (flType & HANDLE_TYPE_CURSOR) {
        hT = CreateCursor(HMODINST32(lpCIAliasIn->hInst16),
                              (INT)FETCHWORD(pcurs16->xHotSpot),
                              (INT)FETCHWORD(pcurs16->yHotSpot),
                              nWidth, nHeight, lpBitsAND, lpBitsXOR);
    }
    else if (flType & HANDLE_TYPE_ICON) {
        hT = CreateIcon(HMODINST32(lpCIAliasIn->hInst16), nWidth, nHeight,
                              (BYTE)nPlanes, (BYTE)nBitsPixel, lpBitsAND, lpBitsXOR);

    }

    return hT;
}


//*****************************************************************************
//
// W32Create16BitCursorIcon -
//
//     Creates a WIN31 compatible Cursor or Icon  given the full 16bit
//     definition of the object to be created.
//
//
//*****************************************************************************


HAND16 W32Create16BitCursorIcon(HAND16 hInst16, INT xHotSpot, INT yHotSpot,
                         INT nWidth, INT nHeight,
                         INT nPlanes, INT nBitsPixel,
                         LPBYTE lpBitsAND, LPBYTE lpBitsXOR,
                         INT   nBytesAND, INT nBytesXOR                    )
{
    WORD h16 = 0;
    WORD wTotalSize;
    PCURSORSHAPE16 pcshape16;
    VPVOID vp;
    LPBYTE lpT;

    UNREFERENCED_PARAMETER(hInst16);

    wTotalSize = (WORD)(sizeof(CURSORSHAPE16) + nBytesAND + nBytesXOR);

    vp = GlobalAllocLock16(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE,
                                                             wTotalSize, &h16);
    if (vp != (VPVOID)NULL) {
        GETVDMPTR(vp, wTotalSize, pcshape16);

        STOREWORD(pcshape16->xHotSpot, xHotSpot);
        STOREWORD(pcshape16->yHotSpot, yHotSpot);
        STOREWORD(pcshape16->cx, nWidth);
        STOREWORD(pcshape16->cy, nHeight);
        STOREWORD(pcshape16->cbWidth, (((nWidth + 0x0F) & ~0x0F) >> 3));
        pcshape16->Planes = (BYTE)nPlanes;
        pcshape16->BitsPixel = (BYTE)nBitsPixel;

        lpT = (LPBYTE)pcshape16 + sizeof(CURSORSHAPE16);
        RtlCopyMemory(lpT, lpBitsAND, nBytesAND);
        RtlCopyMemory(lpT+nBytesAND, lpBitsXOR, nBytesXOR);

        FLUSHVDMPTR(vp, wTotalSize, pcshape16);
        FREEVDMPTR(pcshape16);
    }

    GlobalUnlock16(h16);
    return (HAND16)h16;
}



//*****************************************************************************
//
// GetCursorIconAlias32 -
//
//     Returns a 32bit handle  given a 16bit Cursor or Icon HANDLE
//     Creates the 32bit Cursor or Icon if necessary.
//
//     Returns the 32bit handle
//
//*****************************************************************************


HANDLE GetCursorIconAlias32(HAND16 h16, UINT flType)
{

    LPCURSORICONALIAS lpT;
    VPVOID vp;
    UINT   cb;
    PCURSORSHAPE16 pcurs16;

    if (h16 == (HAND16)0)
        return (ULONG)NULL;

    lpT = FindCursorIconAlias((ULONG)h16, HANDLE_16BIT);
    if (lpT) {
        return lpT->h32;
    }
    else {

        //
        // BEGIN: Check for Bogus handle
        //

        if (BOGUSHANDLE(h16))
            return (HANDLE)NULL;

#if defined(FE_SB)
        //In Excel95, XLVISEX.EXE use wrong cursor handle
        //that is already freed. So, we double check this handle
        //whether it is valid or not. 09/27/96 bklee.

        if (!FindCursorIconAliasInUse((ULONG)h16))
            return (HANDLE)NULL;
#endif

        vp = RealLockResource16(h16, (PINT)&cb);
        if (vp == (VPVOID)NULL)
            return (ULONG)NULL;

        GETVDMPTR(vp, cb, pcurs16);

        if (pcurs16->cbWidth !=  (SHORT)(((pcurs16->cx + 0x0f) & ~0x0f) >> 3))
            return (ULONG)NULL;

        //
        // END: Check for Bogus handle
        //

        lpT = AllocCursorIconAlias();
        if (!lpT) {
            return (ULONG)NULL;
        }

        lpT->h16 = h16;
        lpT->hTask16 = CURRENTPTD()->htask16;

        lpT->vpData = vp;
        lpT->cbData = (WORD)cb;
        lpT->pbDataNew = (LPBYTE)pcurs16;

        lpT->pbDataOld = malloc_w(cb);
        if (lpT->pbDataOld) {
            RtlCopyMemory(lpT->pbDataOld, lpT->pbDataNew, cb);
        }

        lpT->h32  = (HAND32)W32CreateCursorIcon32(lpT);

        GlobalUnlock16(h16);
        FREEVDMPTR(pcurs16);
        lpT->pbDataNew = (LPBYTE)NULL;

        if (lpT->h32) {
            lpT->fInUse = TRUE;
            SetCursorIconFlag(h16, TRUE);
        }
        else
            lpT->fInUse = FALSE;

        return lpT->h32;
    }
}


//*****************************************************************************
//
// GetCursorIconAlias16 -
//
//     Returns a 16bit handle  given a 32bit Cursor or Icon HANDLE
//     Creates the 16bit Cursor or Icon if necessary.
//
//     Returns the 16bit handle
//
//*****************************************************************************


HAND16 GetCursorIconAlias16(HAND32 h32, UINT flType)
{

    LPCURSORICONALIAS lpT;

    if (h32 == (HAND32)0)
        return (HAND16)NULL;

    lpT = FindCursorIconAlias((ULONG)h32, HANDLE_32BIT);
    if (lpT) {
        return lpT->h16;
    }
    else {
        HAND16 h16;

        // HACK:
        // From experience: numeric values of 32bit standard cursors and icons
        //                  are very small. so check for these handles.
        //                  we should not create aliases for standard cursors and
        //                  icons here.

        WOW32ASSERT((UINT)h32 >= 100);

        //
        // Always generate valid handles.
        //

        h16 = W32Create16BitCursorIconFrom32BitHandle(h32, (HAND16)NULL,
                                                                  (PUINT)NULL);
        if (h16) {
            h16 = SetupCursorIconAlias((HAND16)NULL, h32, h16, flType,
                                                      NULL, (WORD)NULL);
        }
        return h16;
    }
}


//*****************************************************************************
//
// AllocCursorIconAlias -
//
//     Allocates and reurns pointer to CURSORICONALIAS buffer.
//
//*****************************************************************************


LPCURSORICONALIAS AllocCursorIconAlias()
{
    LPCURSORICONALIAS  lpT;

    for (lpT = lpCIAlias; lpT != NULL; lpT = lpT->lpNext) {
         if (!lpT->fInUse)
             break;
    }

    if (lpT == NULL) {
        lpT = (LPCURSORICONALIAS)malloc_w_small(sizeof(CURSORICONALIAS));
        if (lpT) {
            lpT->lpNext = lpCIAlias;
            lpCIAlias = lpT;
        }
        else {
            LOGDEBUG(0, ("AllocCursorIconAlias: malloc_w_small for alias failed\n"));
        }
    }

    if (lpT != NULL) {
        lpT->fInUse = TRUE;
        lpT->h16 = (HAND16)0;
        lpT->h32 = (HAND32)0;
        lpT->vpData   = (VPVOID)NULL;
        lpT->cLock    = 0;
        lpT->cbData   = 0;
        lpT->pbDataOld = (LPBYTE)NULL;
        lpT->pbDataNew = (LPBYTE)NULL;
        lpT->lpszName  = (LPBYTE)NULL;

        lpT->flType = HANDLE_TYPE_UNKNOWN;
        lpT->hInst16 = (HAND16)0;
        lpT->hMod16  = (HAND16)0;
        lpT->hTask16 = (HTASK16)0;
        lpT->hRes16 = 0;
    }

    return lpT;
}


//*****************************************************************************
//
// FindCursorIconAlias -
//
//     Searches for the given handle and returns corresponding
//     LPCURSORICONALIAS.
//
//*****************************************************************************


LPCURSORICONALIAS FindCursorIconAlias(ULONG hCI, UINT flHandleSize)
{
    LPCURSORICONALIAS  lpT;
    LPCURSORICONALIAS  lpTprev;

    lpTprev = (LPCURSORICONALIAS)NULL;
    for (lpT = lpCIAlias; lpT != NULL; lpTprev = lpT, lpT = lpT->lpNext) {
         if (lpT->fInUse) {
             if ((flHandleSize == HANDLE_16BIT && lpT->h16 == (HAND16)hCI) ||
                      (flHandleSize == HANDLE_32BIT && lpT->h32 == (HAND32)hCI))
                 break;
             else if (flHandleSize == HANDLE_16BITRES && lpT->hRes16 &&
                                 (lpT->hRes16 == (HAND16)hCI))


                 break;
         }

    }

    if (lpT) {
        if (lpTprev) {
            lpTprev->lpNext = lpT->lpNext;
            lpT->lpNext = lpCIAlias;
            lpCIAlias = lpT;
        }
    }
    return lpT;
}

#if defined(FE_SB)
//*****************************************************************************
//
// FindCursorIconAliasInUse -
//
//     Searches for the given handle and returns corresponding
//     lpT->fInUse.
//
//     09/27/96 bklee
//*****************************************************************************


BOOL FindCursorIconAliasInUse(ULONG hCI)
{
    LPCURSORICONALIAS  lpT;
    LPCURSORICONALIAS  lpTprev;

    lpTprev = (LPCURSORICONALIAS)NULL;
    for (lpT = lpCIAlias; lpT != NULL; lpTprev = lpT, lpT = lpT->lpNext) {
         if (lpT->h16 == (HAND16)hCI)
               return lpT->fInUse;
    }

    return TRUE;
}
#endif


//*****************************************************************************
//
// DeleteCursorIconAlias -
//
//     Searches for the given handle and if a 16bit handle frees the memory
//     allocated for the Object. The alias table is not freed.
//
//*****************************************************************************


BOOL DeleteCursorIconAlias(ULONG hCI, UINT flHandleSize)
{
    LPCURSORICONALIAS  lpT;

    WOW32ASSERT(flHandleSize == HANDLE_16BIT);

    for (lpT = lpCIAlias; lpT != NULL; lpT = lpT->lpNext) {
         if (lpT->fInUse && !(lpT->flType & HANDLE_TYPE_WOWGLOBAL)) {

             // Have we found the handle mapping?

             if (flHandleSize == HANDLE_16BIT && lpT->h16 == (HAND16)hCI) {

                 if (lpT->hTask16) {

                     // We don't want to free the handle mapping when
                     // the handle corresponds to a 16-bit resource, i.e.
                     // hRes16 is non-null.

                     if (!(lpT->hRes16)) {
                         SetCursorIconFlag(lpT->h16, FALSE);
                         GlobalUnlockFree16(RealLockResource16((HMEM16)hCI, NULL));
                         free_w(lpT->pbDataOld);
                         lpT->fInUse = FALSE;
                         return TRUE;
                     }
                 }
                 else {
                     WOW32ASSERT(FALSE);
                 }

                 break;
             }
         }

    }

    return FALSE;
}




//*****************************************************************************
//
// FreeCursorIconAlias -
//
//     Frees all Cursors and Icons of the specified task.
//
//
//*****************************************************************************


BOOL FreeCursorIconAlias(HAND16 hand16, ULONG ulFlags)
{
    LPCURSORICONALIAS  lpT;

    for (lpT = lpCIAlias; lpT != NULL; lpT = lpT->lpNext) {
         if (lpT->fInUse &&
            (((ulFlags & CIALIAS_HMOD)  && (lpT->hMod16  == hand16)) ||
             ((ulFlags & CIALIAS_HTASK) && (lpT->hTask16 == hand16)))) {

             if (ulFlags & CIALIAS_TASKISGONE) {
                 // We're here if this function is called after the task
                 // cleanup on the 16bit side... then we really can't
                 // callback. Setting appropriate fields to NULL will
                 // avoid callbacks, but will leak the corresponding
                 // memory. The asserts will catch this on a checked
                 // build.
                 WOW32ASSERT(lpT->h16==(HAND16)NULL);
                 WOW32ASSERT(lpT->hRes16==(HAND16)NULL);
                 lpT->h16 = (HAND16)NULL;
                 lpT->hRes16 = (HAND16)NULL;
             }
             InvalidateCursorIconAlias(lpT);
         }
    }

    return TRUE;
}


//*****************************************************************************
//
// SetupCursorIconAlias -
//
//     Sets up association (alias) between a 32bit and a 16bit handle.
//     given both the handles.
//
//
//*****************************************************************************


HAND16 SetupCursorIconAlias(HAND16 hInst16, HAND32 h32, HAND16 h16, UINT flType,
                            LPBYTE lpResName, WORD hRes16)

{
    LPCURSORICONALIAS  lpT;
    VPVOID             vp;
    INT                cb;

    lpT = AllocCursorIconAlias();
    // paranoid check for memory exaust 
    if (!lpT) {
      return (HAND16)NULL;
    }

    lpT->fInUse = TRUE;
    lpT->h16 = h16;
    lpT->h32 = h32;
    lpT->flType = (BYTE)flType;
    if (!(flType & HANDLE_TYPE_WOWGLOBAL)) {
        lpT->hInst16 = hInst16;
        lpT->hMod16  = GETHMOD16(HMODINST32(hInst16));
        lpT->hTask16 = CURRENTPTD()->htask16;
        lpT->hRes16 = hRes16;

        vp = RealLockResource16(h16, &cb);
        if (vp == (VPVOID)NULL)
            return (HAND16)NULL;

        lpT->vpData = vp;
        lpT->cbData = (WORD)cb;
        GETVDMPTR(vp, cb, lpT->pbDataNew);

        lpT->pbDataOld = malloc_w(cb);
        if (lpT->pbDataOld) {
            RtlCopyMemory(lpT->pbDataOld, lpT->pbDataNew, cb);
        }

        if (hRes16) {
            lpT->lpszName = lpResName;
            if ((WORD)HIWORD(lpResName) != (WORD)NULL) {
                UINT   cb;
                cb = strlen(lpResName)+1;
                if (lpT->lpszName = malloc_w_small(cb)) {
                    memcpy (lpT->lpszName, lpResName, cb);
                }
            }
        }


    }
    // the alias has been setup. Now turn on the GAH_CURSORICON flag.

    SetCursorIconFlag(h16, TRUE);

    return h16;
}



//*****************************************************************************
//
// SetupResCursorIconAlias -
//
//     Sets up association (alias) between a 32bit and a 16bit handle.
//     given the 32bit handle and a handle to a 16bit resource.
//
//
//*****************************************************************************


HAND16 SetupResCursorIconAlias(HAND16 hInst16, HAND32 h32, LPBYTE lpResName, WORD hRes16, UINT flType)
{
    LPCURSORICONALIAS  lpT;
    HAND16 h16 = 0;
    HAND16 h16Res = 0;
    UINT   cb;


    if (hRes16) {
        // 16bit resource has been loaded. We always want to return the
        // SAME 16bit handle no matter howmany times the 'LoadIcon' or
        // LoadCursor has been called.

        h16Res = LOWORD(hRes16);
        lpT = FindCursorIconAlias(h16Res, HANDLE_16BITRES);
    }
    else {

        // Resource handle is NULL. The Resource must have been a
        // standard predefined resource like ARROW etc.

        lpT = FindCursorIconAlias((ULONG)h32, HANDLE_32BIT);
        flType |= HANDLE_TYPE_WOWGLOBAL;
    }

    if (lpT == NULL) {
        h16 = W32Create16BitCursorIconFrom32BitHandle(h32, hInst16, &cb);
        h16 = SetupCursorIconAlias(hInst16, h32, h16, flType, lpResName, hRes16);
    }
    else {
        if (lpT->flType & HANDLE_TYPE_WOWGLOBAL) {

            // eachtime we should get the same h32 from usersrv.
            //

            WOW32ASSERT(lpT->h32 == h32);
        }
        else {
            if (lpT->h32 != h32) {
                if (lpT->flType == HANDLE_TYPE_CURSOR)
                    DestroyCursor(h32);
                else
                    DestroyIcon(h32);
            }
            ReplaceCursorIcon(lpT);
        }

        h16 = lpT->h16;
    }

    return h16;
}


//*****************************************************************************
//
// SetCursorIconFlag  -
//
//     Sets/Clears the GAH_CURSORICONFLAG in the global arean header. This flag
//     is used to identify Cursors and Icon when they are GlobaLocked and
//     GlobalUnlocked
//
//*****************************************************************************

ULONG SetCursorIconFlag(HAND16 h16, BOOL fSet)
{
    PARM16 Parm16;
    VPVOID vp = 0;

    Parm16.WndProc.wParam = h16;
    Parm16.WndProc.wMsg = (WORD)fSet;
    CallBack16(RET_SETCURSORICONFLAG, &Parm16, 0, &vp);
    return (ULONG)0;
}


//*****************************************************************************
//
// UpdateCursorIcon  -
//
//     Compares the new object data with the old. If any of the bytes differ
//     the old object is replaced with the new.
//
//*****************************************************************************

VOID UpdateCursorIcon()
{
    LPCURSORICONALIAS  lpT;
    UINT               cbData;
    LPBYTE             lpBitsNew, lpBitsOld;
    UINT               i = 0;

    for (lpT = lpCIAlias; lpT != NULL ; lpT = lpT->lpNext) {
         if (lpT->fInUse && lpT->cLock) {
             GETVDMPTR(lpT->vpData, lpT->cbData, lpT->pbDataNew);
             if (lpT->hRes16) {
                 if (lpT->flType == HANDLE_TYPE_ICON) {
                     lpBitsNew = lpT->pbDataNew + sizeof(BITMAPINFOHEADER16);
                     lpBitsOld = lpT->pbDataOld + sizeof(BITMAPINFOHEADER16);
                     cbData    = lpT->cbData    - sizeof(BITMAPINFOHEADER16);
                 }
                 else {
                     lpBitsNew = lpT->pbDataNew + sizeof(CURSORRESOURCE16);
                     lpBitsOld = lpT->pbDataOld + sizeof(CURSORRESOURCE16);
                     cbData    = lpT->cbData    - sizeof(CURSORRESOURCE16);
                 }

             }
             else {
                 lpBitsNew = lpT->pbDataNew + sizeof(CURSORSHAPE16);
                 lpBitsOld = lpT->pbDataOld + sizeof(CURSORSHAPE16);
                 cbData    = lpT->cbData    - sizeof(CURSORSHAPE16);
             }

             if (! RtlEqualMemory(lpBitsNew, lpBitsOld, cbData))
                 ReplaceCursorIcon(lpT);

             if (cPendingCursorIconUpdates == ++i)
                 break;
         }

    }

}

//*****************************************************************************
//
// ReplaceCursorIcon  -
//
//     Updates the current cursor or icon. Creates a new icon or cursor and
//     replaces the contents of the old handle with that of the new.
//
//     returns TRUE for success.
//
//*****************************************************************************

BOOL ReplaceCursorIcon(LPCURSORICONALIAS lpIn)
{
    HANDLE hT32;


    if (lpIn != NULL) {

        // Get the data

        GETVDMPTR(lpIn->vpData, lpIn->cbData, lpIn->pbDataNew);

        // Create the object

        hT32  = (HAND32)W32CreateCursorIcon32(lpIn);

        // SetCursorConents will replace the contents of OLD cursor/icon
        // with that of the new handle and destroy the new handle

        SetCursorContents(lpIn->h32, hT32);

        // replace the old object data with the new

        RtlCopyMemory(lpIn->pbDataOld, lpIn->pbDataNew, lpIn->cbData);
        FREEVDMPTR(lpIn->pbDataNew);
        lpIn->pbDataNew = (LPBYTE)NULL;

    }


    return (BOOL)TRUE;

}


//*****************************************************************************
//
// WK32WowCursorIconOp -
//
//     Gets called when/from  GlobalLock or GlobalUnlock are called. The fLock
//     flag is TRUE if called from GlobalLock else it is FALSE.
//
//*****************************************************************************

BOOL FASTCALL WK32WowCursorIconOp(PVDMFRAME pFrame)
{

    PWOWCURSORICONOP16 prci16;
    HAND16 h16;
    LPCURSORICONALIAS lpT;
    BOOL   fLock;
    WORD   wFuncId;
    UINT   cLockT;


    GETARGPTR(pFrame, sizeof(WOWCURSORICONOP16), prci16);
    wFuncId = FETCHWORD(prci16->wFuncId);
    h16 = (HAND16)FETCHWORD(prci16->h16);

    lpT = FindCursorIconAlias((ULONG)h16, HANDLE_16BIT);
    // This is a Cursor or Icon
    if (lpT != NULL) {

        if (wFuncId == FUN_GLOBALLOCK || wFuncId == FUN_GLOBALUNLOCK) {

            if (!(lpT->flType & HANDLE_TYPE_WOWGLOBAL)) {

                fLock = (wFuncId == FUN_GLOBALLOCK);

                // Store the current lockcount.

                cLockT = lpT->cLock;

                // Update the Lock count

                lpT->cLock = fLock ? ++lpT->cLock : --lpT->cLock;

                if (lpT->cLock == 0) {

                    // New lock count == 0 implies that it was decremented from
                    // 1 to 0 thereby impling that it was one of the cursors that
                    // was being updated regularly.

                    // Decrement the global count and update the cursor one last
                    // time

                    cPendingCursorIconUpdates--;
                    ReplaceCursorIcon(lpT);
                }
                else if (fLock && cLockT == 0) {

                    // If previous Lockcount was zero and the object is being locked
                    // then it means that this is the very first time that the object
                    // is being locked

                    cPendingCursorIconUpdates++;
                }
            }
        }
        else if (wFuncId == FUN_GLOBALFREE) {

            // The h16 has not yet been GlobalFreed. We return TRUE if h16 can
            // be freed else FALSE. The h16 can be freed only if it is not a
            // global handle. ie, it doesn't correspond to a predefined cursor

            // Also we donot free the handle if h16 corresponds to a resource.
            // CorelDraw 3.0 calls FreeResource(h16) and then SetCursor(h16)
            // thus  GPing.

            BOOL fFree;

            fFree = !((lpT->flType & HANDLE_TYPE_WOWGLOBAL) || lpT->hRes16);
            if (fFree) {
                // Set handle to NULL so that InvalidateCursorIconAlias
                // doesn't try to free it.

                lpT->h16 = 0;
                InvalidateCursorIconAlias(lpT);
            }

            return (BOOL)fFree;

        }
        else {
            LOGDEBUG(0, ("WK32WowCursorIconOp: Unknown Func Id\n"));
        }
    }

    // else if this is a GlobalFree call
    else if (wFuncId == FUN_GLOBALFREE) {

        // and if this is a handle to an accelerator
        if(lpT = (LPCURSORICONALIAS)FindAccelAlias((HANDLE)h16, HANDLE_16BIT)) {

            // free it from the accelerator alias list
            FreeAccelAliasEntry((LPACCELALIAS) lpT);

            // cause this hMem16 to really be free'd in 16-bit GlobalFree
            return TRUE;
        }
    }

    return TRUE;
}


//*****************************************************************************
//
// W32Create16BitResCursorIconFrom32BitHandle -
//
//     Creates a WIN31 compatible Cursor or Icon given a 32bit cursor or icon
//     handle. This is primarily used to create a 16bit Cursor or Icon which
//     has been loaded from a 16bit resource.
//
//
//     returns 16bit handle
//*****************************************************************************


HAND16 W32Create16BitCursorIconFrom32BitHandle(HANDLE h32, HAND16 hInst16,
                                                 PUINT pcbData)
{
    HAND16   h16 = 0;
    ICONINFO iinfo;
    BITMAP   bm;
    BITMAP   bmClr;
    UINT     nBytesAND = 0;
    UINT     nBytesXOR = 0;
    LPBYTE   lpBitsAND, lpBitsXOR;

    if (GetIconInfo(h32, &iinfo)) {
        if (GetObject(iinfo.hbmMask, sizeof(BITMAP), &bm)) {
            nBytesAND = GetBitmapBits(iinfo.hbmMask, 0, (LPBYTE)NULL);
            WOW32WARNMSG(nBytesAND,("WOW: W32C16BCIFBH: nBytesAND == 0\n"));
            if (iinfo.hbmColor) {
                GetObject(iinfo.hbmColor, sizeof(BITMAP), &bmClr);
                nBytesXOR = GetBitmapBits(iinfo.hbmColor, 0, (LPBYTE)NULL);
                WOW32WARNMSG(nBytesXOR,("WOW: W32C16BCIFBH: nBytesAND == 0\n"));
            }
            else {
                bm.bmHeight /= 2;
                nBytesAND /= 2;
                nBytesXOR = nBytesAND;
            }


            if (pcbData) {
                *pcbData = nBytesAND + nBytesXOR + sizeof(CURSORSHAPE16);
            }

            lpBitsAND = malloc_w(nBytesAND + nBytesXOR);
            if (lpBitsAND != NULL) {
                lpBitsXOR = lpBitsAND + nBytesAND;
                GetBitmapBits(iinfo.hbmMask,
                              (iinfo.hbmColor) ? nBytesAND : (nBytesAND * 2),
                                                                    lpBitsAND);
                if (iinfo.hbmColor)
                    GetBitmapBits(iinfo.hbmColor, nBytesXOR, lpBitsXOR);

                h16 = W32Create16BitCursorIcon(hInst16,
                                       iinfo.xHotspot, iinfo.yHotspot,
                                       bm.bmWidth, bm.bmHeight,
                                       (iinfo.hbmColor) ? bmClr.bmPlanes :
                                                                    bm.bmPlanes,
                                       (iinfo.hbmColor) ? bmClr.bmBitsPixel :
                                                                 bm.bmBitsPixel,
                                       lpBitsAND, lpBitsXOR,
                                       (INT)nBytesAND, (INT)nBytesXOR);
                free_w(lpBitsAND);

            }

        }
        DeleteObject(iinfo.hbmMask);
        if (iinfo.hbmColor) {
            DeleteObject(iinfo.hbmColor);
        }
    }

    return h16;

}

//*****************************************************************************
//
// GetClassCursorIconAlias32 -
//
//     Returns a 32bit handle  given a 16bit Cursor or Icon HANDLE
//     DOES NOT Create the 32bit Cursor or Icon if there is no alias.
//     This is called in RegisterClass only - to support those apps which
//     pass a bogus handle for WNDCLASS.hIcon.
//
//     Returns the 32bit handle
//
//*****************************************************************************


HANDLE GetClassCursorIconAlias32(HAND16 h16)
{

    LPCURSORICONALIAS lpT;

    if (h16 == (HAND16)0)
        return (ULONG)NULL;

    lpT = FindCursorIconAlias((ULONG)h16, HANDLE_16BIT);
    if (lpT) {
        return lpT->h32;
    }
    else
        return (HANDLE)NULL;
}



//*****************************************************************************
//
// InvalidateCursorIconAlias -
//
//     Frees the allocated objects.
//
//*****************************************************************************


VOID InvalidateCursorIconAlias(LPCURSORICONALIAS lpT)
{
    VPVOID vp=0;
    PARM16 Parm16;

    if (!lpT->fInUse)
        return;

    if (lpT->h16) {
        SetCursorIconFlag(lpT->h16, FALSE);
        GlobalUnlockFree16(RealLockResource16((HMEM16)lpT->h16, NULL));
    }

    if (lpT->hRes16) {
        Parm16.WndProc.wParam = (HAND16) lpT->hRes16;
        CallBack16(RET_FREERESOURCE, &Parm16, 0, &vp);
    }

    if (lpT->h32) {
        if (lpT->flType == HANDLE_TYPE_CURSOR)
            DestroyCursor(lpT->h32);
        else
            DestroyIcon(lpT->h32);
    }

    if (lpT->pbDataOld)
        free_w(lpT->pbDataOld);

    if (lpT->cLock)
        cPendingCursorIconUpdates--;


    if ((WORD)HIWORD(lpT->lpszName) != (WORD)NULL) {
        free_w_small ((PVOID)lpT->lpszName);
    }

    lpT->fInUse = FALSE;
}


//*****************************************************************************
//
// InitStdCursorIconAlias -
//
//     Creates the aliases of standard cursors and icons.
//
// NOTES:
//
// The idea is to createaliases for all the standard cursors and icons to
// make sure that we indeed generate valid handles.
//
// This problem cameup because of the following scenario
// the app turbotax does the following:
//
//          h16Cursor1 = GetClassWord(hwndEditControl, GCL_HCURSOR);
//                              (bydefault, this is an I-beam)
//                         .....
//          h16Cursor2 = LoadCursor(NULL, IDC_IBEAM);
// Because of the way we create and maintain our 32-16 alias hCursor1 is a
// a WOW bogus handle (ie > 0xf000) and  since by default the "Edit" class is
// registered with hCursor = IDC_IBEAM, the h32s are same ie.
//
//     GetClassWord(hwndEditControl, GCL_HCURSOR) == LoadCursor(..IDC_IBEAM);
//
// Thus h16Cursor2 will be same as h16Cursor1 and that's a problem because we
// are NOT returning a valid wow handle for a predefined cursor.
//
//
// The solution is to createaliases for all standard cursors and icons during
// init time so that we don't run into this problem. However I think this
// approach as wasteful and am creating the alias for the only known case
// ie IDC_IBEAM.
//
//                                           - Nanduri Ramakrishna
//*****************************************************************************

DWORD InitCursorIds[] = {
                          (DWORD)IDC_ARROW,
                          (DWORD)IDC_IBEAM,
                          (DWORD)IDC_WAIT,
                          (DWORD)IDC_CROSS,
                          (DWORD)IDC_UPARROW,
                          (DWORD)IDC_SIZE,
                          (DWORD)IDC_ICON,
                          (DWORD)IDC_SIZENWSE,
                          (DWORD)IDC_SIZENESW,
                          (DWORD)IDC_SIZEWE,
                          (DWORD)IDC_SIZENS
                        };

BOOL InitStdCursorIconAlias()
{

    HCURSOR h32;
    UINT i;

    for (i = 0; i < (sizeof(InitCursorIds) / sizeof(DWORD)); i++) {

         //
         // Create the alias for each standard cursor in the list
         //

         h32 = (HCURSOR)LoadCursor((HINSTANCE)NULL, (LPCSTR)InitCursorIds[i]);
         WOW32ASSERT(h32);

         if (h32) {
             SetupResCursorIconAlias((HAND16)NULL, (HAND32)h32, NULL, (WORD)NULL,
                                                          HANDLE_TYPE_CURSOR);
         }

    }

    //
    // Add similar lines for  standard icons.
    //

    return TRUE;
}


//*****************************************************************************
//
// W32CheckIfAlreadyLoaded -
//
//     returns h16 if a cursoricon has previously been loaded.
//
//*****************************************************************************

HAND16 W32CheckIfAlreadyLoaded(VPVOID pData, WORD ResType)
{
    LPCURSORICONALIAS  lpT;
    PICONCUR16 parg16;
    PSZ psz;


    GETMISCPTR(pData, parg16);
    GETPSZIDPTR(parg16->lpStr, psz);

    ResType = (ResType == NW_LOADCURSOR) ?  HANDLE_TYPE_CURSOR : HANDLE_TYPE_ICON;
    for (lpT = lpCIAlias; lpT != NULL; lpT = lpT->lpNext) {
         if (lpT->fInUse) {
             LPBYTE lpszNameT = lpT->lpszName;
             if (lpszNameT &&  (lpT->flType & ResType) &&
                                            lpT->hInst16 == parg16->hInst) {
                 WOW32ASSERT(!(lpT->flType & HANDLE_TYPE_WOWGLOBAL));
                 if (HIWORD(lpszNameT) && HIWORD(psz)) {
                     if (!(WOW32_stricmp(psz, (LPSTR)lpszNameT)))
                         break;
                 }
                 else if (lpszNameT == psz) {
                    break;
                 }
             }
         }
    }


    FREEPSZIDPTR(psz);
    FREEMISCPTR(parg16);


    if (lpT && lpT->cLock)
        ReplaceCursorIcon(lpT);

    return (lpT ? lpT->h16 : 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wdib.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WDIB.C
 *  DIB.DRV support
 *
 *  History:
 *  28-Apr-1994 Sudeep Bharati
 *  Created.
 *
--*/


#include "precomp.h"
#pragma hdrstop
#include "wowgdip.h"
#include "wdib.h"
#include "memapi.h"

MODNAME(wdib.c);

#define CJSCAN(width,planes,bits) ((((width)*(planes)*(bits)+31) & ~31) / 8)
#define ABS(X) (((X) < 0 ) ? -(X) : (X))

BOOL W32CheckDibColorIndices(LPBITMAPINFOHEADER lpbmi);

// VGA colors
RGBQUAD rgbVGA[] = {
//    Blue  Green   Red
      0x00, 0x00, 0x00, 0,    // 0  ; black
      0x00, 0x00, 0x80, 0,    // 1  ; dark red
      0x00, 0x80, 0x00, 0,    // 2  ; dark green
      0x00, 0x80, 0x80, 0,    // 3  ; mustard
      0x80, 0x00, 0x00, 0,    // 4  ; dark blue
      0x80, 0x00, 0x80, 0,    // 5  ; purple
      0x80, 0x80, 0x00, 0,    // 6  ; dark turquoise
      0xc0, 0xc0, 0xc0, 0,    // 7  ; gray
      0x80, 0x80, 0x80, 0,    // 8  ; dark gray
      0x00, 0x00, 0xff, 0,    // 9  ; red
      0x00, 0xff, 0x00, 0,    // a  ; green
      0x00, 0xff, 0xff, 0,    // b  ; yellow
      0xff, 0x00, 0x00, 0,    // c  ; blue
      0xff, 0x00, 0xff, 0,    // d  ; magenta
      0xff, 0xff, 0x00, 0,    // e  ; cyan
      0xff, 0xff, 0xff, 0     // f  ; white
};

RGBQUAD rgb4[] = {
      0xc0, 0xdc, 0xc0, 0,    // 8
      0xf0, 0xca, 0xa6, 0,    // 9
      0xf0, 0xfb, 0xff, 0,    // 246
      0xa4, 0xa0, 0xa0, 0     // 247
};



PDIBINFO pDibInfoHead = NULL;
PDIBSECTIONINFO pDibSectionInfoHead = NULL;

HDC W32HandleDibDrv (PVPVOID vpbmi16)
{
    HDC             hdcMem = NULL;
    HBITMAP         hbm = NULL;
    PVOID           pvBits, pvIntelBits;
    STACKBMI32      bmi32;
    LPBITMAPINFO    lpbmi32;
    DWORD           dwClrUsed,nSize,nAlignmentSpace;
    PBITMAPINFOHEADER16 pbmi16;
    INT             nbmiSize,nBytesWritten;
    HANDLE          hfile=NULL,hsec=NULL;
    ULONG           RetVal,OriginalSelLimit,SelectorLimit,OriginalFlags;
    PARM16          Parm16;
    CHAR            pchTempFile[MAX_PATH];
    BOOL            bRet = FALSE;
    PVPVOID         vpBase16 = (PVPVOID) ((ULONG) vpbmi16 & 0xffff0000);

    if ((hdcMem = W32FindAndLockDibInfo((USHORT)HIWORD(vpbmi16))) != (HDC)NULL) {
        return hdcMem;
    }

    // First create a memory device context compatible to
    // the app's current screen
    if ((hdcMem = CreateCompatibleDC (NULL)) == NULL) {
        LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv CreateCompatibleDC failed\n"));
        return NULL;
    }

    // Copy bmi16 to bmi32. DIB.DRV only supports DIB_RGB_COLORS
    lpbmi32 = CopyBMI16ToBMI32(
                     vpbmi16,
                     (LPBITMAPINFO)&bmi32,
                     (WORD) DIB_RGB_COLORS);

    // this hack for Director 4.0 does essentially what WFW does
    // if this bitmap is 0 sized, just return an hDC for something simple
    if(bmi32.bmiHeader.biSizeImage == 0 &&
       (CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_DIBDRVIMAGESIZEZERO)) {
        LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv:Zero biSizeImage, returning memory DC!\n"));
        return hdcMem;
    }

    try {

        // Copy the wholething into a temp file. First get a temp file name
        if ((nSize = GetTempPath (MAX_PATH, pchTempFile)) == 0 ||
             nSize >= MAX_PATH)
            goto hdd_err;

        if (GetTempFileName (pchTempFile,
                             "DIB",
                             0,
                             pchTempFile) == 0)
            goto hdd_err;

        if ((hfile = CreateFile (pchTempFile,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_WRITE,
                                NULL,
                                CREATE_ALWAYS,
                                (FILE_ATTRIBUTE_NORMAL |
                                 FILE_ATTRIBUTE_TEMPORARY |
                                 FILE_FLAG_DELETE_ON_CLOSE),
                                NULL)) == INVALID_HANDLE_VALUE) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv CreateFile failed\n"));
            goto hdd_err;
        }

        // call back to get the size of the global object
        // associated with vpbmi16
        Parm16.WndProc.wParam = HIWORD(vpbmi16);

        CallBack16(RET_GETDIBSIZE,
                   &Parm16,
                   0,
                   (PVPVOID)&SelectorLimit);

        Parm16.WndProc.wParam = HIWORD(vpbmi16);

        if (SelectorLimit == 0xffffffff || SelectorLimit == 0) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv Invalid Selector %x\n",HIWORD(vpbmi16)));
            goto hdd_err;
        }

        SelectorLimit++;

        OriginalSelLimit = SelectorLimit;

        CallBack16(RET_GETDIBFLAGS,
                   &Parm16,
                   0,
                   (PVPVOID)&OriginalFlags);

        if (OriginalFlags == 0x4) { //GA_DGROUP
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv GA_DGROUP Not Handled\n"));
            goto hdd_err;
        }

        GETVDMPTR(vpBase16, SelectorLimit, pbmi16);

        nbmiSize = GetBMI16Size(vpbmi16, (WORD) DIB_RGB_COLORS, &dwClrUsed);

        // Under NT CreateDIBSection will fail if the offset to the bits
        // is not dword aligned. So we may have to add some space at the top
        // of the section to get the offset correctly aligned.

        nAlignmentSpace = (nbmiSize+LOWORD(vpbmi16)) % 4;

        if (nAlignmentSpace) {
            if (WriteFile (hfile,
                           pbmi16,
                           nAlignmentSpace,
                           &nBytesWritten,
                           NULL) == FALSE ||
                           nBytesWritten != (INT) nAlignmentSpace)
            goto hdd_err;
        }

        //
        // detect a clinical case of bitedit screwing around dib.drv
        //
        // code below is using dib macros declared in wdib.h
        // namely:
        //      DibNumColors - yields max number of colors in dib
        //      DibColors    - yields pointer to a dib color table
        //
        // Function W32CheckDibColorIndices checks to see if DIB color
        // table looks like a number (defined usually by biClrImportant)
        // of WORD indices in a sequential order (0, 1, 2, ...)
        // if this is the case, app is trying to use undocumented feature
        // of DIB.DRV that turns color matching off in this case.
        // Since we cannot enforce that rule, we approximate it by filling
        // color table by a number of known (and always same) entries
        // When blitting occurs, no color matching will be performed (when
        // both target and destination are of this very nature).
        // For no reason at all we fill color table with vga colors.
        // Sequential indices could have worked just as well.
        //
        // Modifications are made to memory pointed to by lpbmi32

        if (W32CheckDibColorIndices((LPBITMAPINFOHEADER)lpbmi32)) {
            BYTE i;
            INT nColors;
            LPBITMAPINFOHEADER lpbmi = (LPBITMAPINFOHEADER)lpbmi32;
            LPRGBQUAD lprgbq = (LPRGBQUAD)DibColors(lpbmi);

            nColors = DibNumColors(lpbmi);
            lpbmi->biClrImportant = nColors;

            switch (lpbmi->biBitCount) {
                case 1:
                    lprgbq[0] = rgbVGA[0];
                    lprgbq[1] = rgbVGA[0x0f];
                    break;

                case 4:
                    RtlCopyMemory(lprgbq, rgbVGA, sizeof(rgbVGA));
                    break;

                case 8:
                    RtlCopyMemory(lprgbq,     rgbVGA,   8*sizeof(RGBQUAD));
                    RtlCopyMemory(lprgbq+248, rgbVGA+8, 8*sizeof(RGBQUAD));
                    RtlCopyMemory(lprgbq+8,   rgb4,   2*sizeof(RGBQUAD));
                    RtlCopyMemory(lprgbq+246, rgb4+2, 2*sizeof(RGBQUAD));
                    for (i = 10; i < 246; ++i) {
                        lprgbq[i].rgbBlue = i;
                        lprgbq[i].rgbGreen= 0;
                        lprgbq[i].rgbRed  = 0;
                        lprgbq[i].rgbReserved = 0;
                    }
                    break;

                default: // this should never happen
                    break;
            }
        }

        if (WriteFile (hfile,
                       pbmi16,
                       SelectorLimit,
                       &nBytesWritten,
                       NULL) == FALSE || nBytesWritten != (INT) SelectorLimit)
            goto hdd_err;

        if (SelectorLimit < 64*1024) {
            if (SetFilePointer (hfile,
                                64*1024+nAlignmentSpace,
                                NULL,
                                FILE_BEGIN) == -1)
                goto hdd_err;

            if (SetEndOfFile (hfile) == FALSE)
                goto hdd_err;

            SelectorLimit = 64*1024;
        }

        if ((hsec = CreateFileMapping (hfile,
                                       NULL,
                                       PAGE_READWRITE | SEC_COMMIT,
                                       0,
                                       SelectorLimit+nAlignmentSpace,
                                       NULL)) == NULL) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv CreateFileMapping Failed\n"));
            goto hdd_err;
        }

        // Now create the DIB section
        if ((hbm = CreateDIBSection (hdcMem,
                                lpbmi32,
                                DIB_RGB_COLORS,
                                &pvBits,
                                hsec,
                                nAlignmentSpace + LOWORD(vpbmi16) + nbmiSize
                                )) == NULL) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv CreateDibSection Failed\n"));
            goto hdd_err;
        }

        FREEVDMPTR(pbmi16);

        if((pvBits = MapViewOfFile(hsec,
                         FILE_MAP_WRITE,
                         0,
                         0,
                         SelectorLimit+nAlignmentSpace)) == NULL) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv MapViewOfFile Failed\n"));
            goto hdd_err;
        }

        pvBits = (PVOID) ((ULONG)pvBits + nAlignmentSpace);

        SelectObject (hdcMem, hbm);

        GdiSetBatchLimit(1);

#ifndef i386
        if (!NT_SUCCESS(VdmAddVirtualMemory((ULONG)pvBits,
                                            (ULONG)SelectorLimit,
                                            (PULONG)&pvIntelBits))) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv VdmAddVirtualMemory failed\n"));
            goto hdd_err;
        }

        // On risc platforms, the intel base + the intel linear address
        // of the DIB section is not equal to the DIB section's process
        // address. This is because of the VdmAddVirtualMemory call
        // above. So here we zap the correct address into the flataddress
        // array.
        if (!VdmAddDescriptorMapping(HIWORD(vpbmi16),
                                    (USHORT) ((SelectorLimit+65535)/65536),
                                    (ULONG) pvIntelBits,
                                    (ULONG) pvBits)) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv VdmAddDescriptorMapping failed\n"));
            goto hdd_err;
        }

#else
        pvIntelBits = pvBits;
#endif

        // Finally set the selectors to the new DIB
        Parm16.WndProc.wParam = HIWORD(vpbmi16);
        Parm16.WndProc.lParam = (LONG)pvIntelBits;
        Parm16.WndProc.wMsg   = 0x10; // GA_NOCOMPACT
        Parm16.WndProc.hwnd   = 1;    // set so it's not randomly 0

        CallBack16(RET_SETDIBSEL,
                   &Parm16,
                   0,
                   (PVPVOID)&RetVal);

        if (!RetVal) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::W32HandleDibDrv Callback set_sel_for_dib failed\n"));
            goto hdd_err;
        }


        // Store all the relevant information so that DeleteDC could
        // free all the resources later.
        if (W32AddDibInfo(hdcMem,
                          hfile,
                          hsec,
                          nAlignmentSpace,
                          pvBits,
                          pvIntelBits,
                          hbm,
                          OriginalSelLimit,
                          (USHORT)OriginalFlags,
                          (USHORT)((HIWORD(vpbmi16)))) == FALSE)
            goto hdd_err;


        // Finally spit out the dump for debugging
        LOGDEBUG(6,("\t\tWOW::W32HandleDibDrv hdc=%04x nAlignment=%04x\n\t\tNewDib=%x OldDib=%04x:%04x DibSize=%x DibFlags=%x\n",hdcMem,nAlignmentSpace,pvBits,HIWORD(vpbmi16),LOWORD(vpbmi16),OriginalSelLimit,(USHORT)OriginalFlags));

        bRet = TRUE;
hdd_err:;
    }
    finally {
        if (!bRet) {

            if (hdcMem) {
                DeleteDC (hdcMem);
                hdcMem = NULL;
            }
            if (hfile)
                CloseHandle (hfile);

            if (hsec)
                CloseHandle (hsec);

            if (hbm)
                CloseHandle (hbm);
        }
    }
    return hdcMem;
}


BOOL W32AddDibInfo (
    HDC hdcMem,
    HANDLE hfile,
    HANDLE hsec,
    ULONG  nalignment,
    PVOID  newdib,
    PVOID  newIntelDib,
    HBITMAP hbm,
    ULONG dibsize,
    USHORT originaldibflags,
    USHORT originaldibsel
    )
{
    PDIBINFO pdi;

    if ((pdi = malloc_w (sizeof (DIBINFO))) == NULL)
        return FALSE;

    pdi->di_hdc     = hdcMem;
    pdi->di_hfile   = hfile;
    pdi->di_hsec    = hsec;
    pdi->di_nalignment    = nalignment;
    pdi->di_newdib  = newdib;
    pdi->di_newIntelDib = newIntelDib;
    pdi->di_hbm     = hbm;
    pdi->di_dibsize = dibsize;
    pdi->di_originaldibsel = originaldibsel;
    pdi->di_originaldibflags = originaldibflags;
    pdi->di_next    = pDibInfoHead;
    pdi->di_lockcount = 1;
    pDibInfoHead    = pdi;

    return TRUE;
}

BOOL W32FreeDibInfoHandle(PDIBINFO pdi, PDIBINFO pdiLast)
{
    if (W32RestoreOldDib (pdi) == 0) {
        LOGDEBUG(LOG_ALWAYS,("\nWOW::W32RestoreDib failed\n"));
        return FALSE;
    }
#ifndef i386
    VdmRemoveVirtualMemory((ULONG)pdi->di_newIntelDib);
#endif
    UnmapViewOfFile ((LPVOID)((ULONG)pdi->di_newdib - pdi->di_nalignment));

    DeleteObject (pdi->di_hbm);
    CloseHandle (pdi->di_hsec);
    CloseHandle (pdi->di_hfile);

    DeleteDC(pdi->di_hdc);
    W32FreeDibInfo (pdi, pdiLast);

    return TRUE;
}


BOOL    W32CheckAndFreeDibInfo (HDC hdc)
{
    PDIBINFO pdi = pDibInfoHead,pdiLast=NULL;

    while (pdi) {
        if (pdi->di_hdc == hdc){

            if (--pdi->di_lockcount) {
                //
                // This must be a releasedc within a nested call to createdc.
                // Just return, as this should be released again later.
                //
                LOGDEBUG(LOG_ALWAYS, ("\nW32CheckAndFreeDibInfo: lockcount!=0\n"));
                return TRUE;
            }

            return W32FreeDibInfoHandle(pdi, pdiLast);
        }
        pdiLast = pdi;
        pdi = pdi->di_next;
    }

    return FALSE;
}

VOID W32FreeDibInfo (PDIBINFO pdiCur, PDIBINFO pdiLast)
{
    if (pdiLast == NULL)
        pDibInfoHead = pdiCur->di_next;
    else
        pdiLast->di_next = pdiCur->di_next;

    free_w (pdiCur);
}

ULONG W32RestoreOldDib (PDIBINFO pdi)
{
    PARM16          Parm16;
    ULONG           retval;

    // callback to allocate memory and copy the dib from dib section

    Parm16.WndProc.wParam = pdi->di_originaldibsel;
    Parm16.WndProc.lParam = (LONG) (pdi->di_newdib);
    Parm16.WndProc.wMsg = pdi->di_originaldibflags;

    CallBack16(RET_FREEDIBSEL,
               &Parm16,
               0,
               (PVPVOID)&retval);

    return retval;
}


HDC W32FindAndLockDibInfo (USHORT sel)
{
    PDIBINFO pdi = pDibInfoHead;

    while (pdi) {

        if (pdi->di_originaldibsel == sel){
            pdi->di_lockcount++;
            return (pdi->di_hdc);

        }
        pdi = pdi->di_next;

    }
    return (HDC) NULL;
}

//
//  This function is called from krnl386 if GlobalReAlloc or GlobalFree is
//  trying to operate on memory which we suspect is dib-mapped. It finds
//  dib by original selector and restores it, thus allowing respective function
//  to succeede. Bitedit is the app that does globalrealloc before DeleteDC
//
//

ULONG FASTCALL WK32FindAndReleaseDib(PVDMFRAME pvf)
{
    USHORT sel;
    PFINDANDRELEASEDIB16 parg;
    PDIBINFO pdi;
    PDIBINFO pdiLast = NULL;

    // get the argument pointer, see wowkrnl.h
    GETARGPTR(pvf, sizeof(*parg), parg);

    // get selector from the handle
    sel = parg->hdib | (USHORT)0x01; // "convert to sel"

    // find this said sel in the dibinfo
    pdi = pDibInfoHead;
    while (pdi) {
        if (pdi->di_originaldibsel == sel) {

            // found ! this is what we are releasing or reallocating
            LOGDEBUG(LOG_ALWAYS, ("\nWOW: In FindAndReleaseDIB function %d\n", (DWORD)parg->wFunId));

            // see if we need to nuke...
            if (--pdi->di_lockcount) {
                // the problem with lock count...
                LOGDEBUG(LOG_ALWAYS, ("\nWOW: FindAndReleaseDib failed (lock count!)\n"));
                return FALSE;
            }

            return W32FreeDibInfoHandle(pdi, pdiLast);
        }

        pdiLast = pdi;
        pdi = pdi->di_next;
    }

    return FALSE;
}


BOOL W32CheckDibColorIndices(LPBITMAPINFOHEADER lpbmi)
{
    WORD i, nColors;
    LPWORD lpw = (LPWORD)DibColors(lpbmi);

    nColors = DibNumColors(lpbmi);
    if (lpbmi->biClrImportant) {
        nColors = min(nColors, (WORD)lpbmi->biClrImportant);
    }

    for (i = 0; i < nColors; ++i) {
        if (*lpw++ != i) {
            return FALSE;
        }
    }

    LOGDEBUG(LOG_ALWAYS, ("\nUndocumented Dib.Drv behaviour used\n"));

    return TRUE;
}

/******************************Public*Routine******************************\
* DIBSection specific calls
*
* History:
*  04-May-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

ULONG cjBitmapBitsSize(CONST BITMAPINFO *pbmi)
{
// Check for PM-style DIB

    if (pbmi->bmiHeader.biSize == sizeof(BITMAPCOREHEADER))
    {
        LPBITMAPCOREINFO pbmci;
        pbmci = (LPBITMAPCOREINFO)pbmi;
        return(CJSCAN(pbmci->bmciHeader.bcWidth,pbmci->bmciHeader.bcPlanes,
                      pbmci->bmciHeader.bcBitCount) *
                      pbmci->bmciHeader.bcHeight);
    }

// not a core header

    if ((pbmi->bmiHeader.biCompression == BI_RGB) ||
        (pbmi->bmiHeader.biCompression == BI_BITFIELDS))
    {
        return(CJSCAN(pbmi->bmiHeader.biWidth,pbmi->bmiHeader.biPlanes,
                      pbmi->bmiHeader.biBitCount) *
               ABS(pbmi->bmiHeader.biHeight));
    }
    else
    {
        return(pbmi->bmiHeader.biSizeImage);
    }
}

ULONG FASTCALL WG32CreateDIBSection(PVDMFRAME pFrame)
{
    ULONG              ul = 0;
    STACKBMI32         bmi32;
    LPBITMAPINFO       lpbmi32;
    HBITMAP            hbm32;
    PVOID              pv16, pvBits, pvIntelBits;
    PVPVOID            vpbmi16;
    PVOID              pvBits32;
    DWORD              dwArg16;

    register PCREATEDIBSECTION16 parg16;

    GETARGPTR(pFrame, sizeof(CREATEDIBSECTION16), parg16);

    // this is performance hack so we don't generate extra code
    dwArg16 = FETCHDWORD(parg16->f4); // do it once here
    pv16 = (PVOID)GetPModeVDMPointer(dwArg16, sizeof(DWORD)); // aligned here!

    WOW32ASSERTMSG(((parg16->f5 == 0) && (parg16->f6 == 0)),
                   ("WOW:WG32CreateDIBSection, hSection/dwOffset non-null\n"));

    vpbmi16 = (PVPVOID)FETCHDWORD(parg16->f2);
    lpbmi32 = CopyBMI16ToBMI32(vpbmi16,
                               (LPBITMAPINFO)&bmi32,
                               FETCHWORD(parg16->f3));

    hbm32 = CreateDIBSection(HDC32(parg16->f1),
                             lpbmi32,
                             WORD32(parg16->f3),
                             &pvBits,
                             NULL,
                             0);

    if (hbm32 != 0)
    {
        PARM16          Parm16;
        PDIBSECTIONINFO pdi;
        ULONG           SelectorLimit;

        SelectorLimit = (ULONG)cjBitmapBitsSize(lpbmi32);
#ifndef i386
        if (!NT_SUCCESS(VdmAddVirtualMemory((ULONG)pvBits,
                                            SelectorLimit,
                                            (PULONG)&pvIntelBits))) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::WG32CreateDibSection VdmAddVirtualMemory failed\n"));
            goto cds_err;
        }

#else
        pvIntelBits = pvBits;
#endif

        // Create a selector array for the bits backed by pvIntelBits

        Parm16.WndProc.wParam = (WORD)-1;           // -1 => allocate selectors
        Parm16.WndProc.lParam = (LONG) pvIntelBits; // backing pointer
        Parm16.WndProc.wMsg = 0x10;                 // GA_NOCOMPACT
        Parm16.WndProc.hwnd = (WORD)((SelectorLimit+65535)/65536);// selector count

        CallBack16(RET_SETDIBSEL,
                   &Parm16,
                   0,
                   (PVPVOID)&pvBits32);

        // 16:16 pointer is still valid as call above makes no difference
        if (pv16 != NULL) {
            *(UNALIGNED PVOID*)pv16 = pvBits32;
        }

        if (pvBits32 == NULL) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::WG32CreateDibSection, Callback set_sel_for_dib failed\n"));
            goto cds_err;
        }

#ifndef i386
        // okay, that was successful - map the descriptors properly

        if (!VdmAddDescriptorMapping(HIWORD(pvBits32),
                                    (USHORT) ((SelectorLimit+65535)/65536),
                                    (ULONG) pvIntelBits,
                                    (ULONG) pvBits)) {
            LOGDEBUG(LOG_ALWAYS,("\nWOW::WG32CreateDibSection VdmAddDescriptorMapping failed\n"));
            goto cds_err;
        }
#endif

        LOGDEBUG(LOG_ALWAYS, ("\nWOW:CreateDIBSection: [16:16 %x] [Intel %x] [Flat %x]\n",
                             pvBits32, pvIntelBits, pvBits));

        ul = GETHBITMAP16(hbm32);

        // Add it to the list used for cleanup at DeleteObject time.

        if ((pdi = malloc_w (sizeof (DIBSECTIONINFO))) != NULL) {
            pdi->di_hbm         = hbm32;
            pdi->di_pv16        = pvBits32;
#ifndef i386
            pdi->di_newIntelDib = pvIntelBits;
#endif
            pdi->di_next        = pDibSectionInfoHead;
            pDibSectionInfoHead = pdi;

            // need to turn batching off since a DIBSECTION means the app can
            // also draw on the bitmap and we need synchronization.

            GdiSetBatchLimit(1);

            goto cds_ok;
        }
        else {
            // Failure, free the selector array

            Parm16.WndProc.wParam = (WORD)-1;            // -1 => allocate/free
            Parm16.WndProc.lParam = (LONG) pvBits32; // pointer
            Parm16.WndProc.wMsg = 0x10; // GA_NOCOMPACT
            Parm16.WndProc.hwnd = 0;                     // 0 => free

            CallBack16(RET_SETDIBSEL,
                       &Parm16,
                       0,
                       (PVPVOID)&ul);
#ifndef i386
            VdmRemoveVirtualMemory((ULONG)pvIntelBits);
#endif

        }
    }
    else {
        LOGDEBUG(LOG_ALWAYS,("\nWOW::WG32CreateDibSection, CreateDibSection Failed\n"));
    }

cds_err:

    if (hbm32 != 0) {
        DeleteObject(hbm32);
    }
    LOGDEBUG(LOG_ALWAYS,("\nWOW::WG32CreateDibSection returning failure\n"));
    ul = 0;

cds_ok:
    WOW32APIWARN(ul, "CreateDIBSection");

    FREEMISCPTR(pv16);
    FREEARGPTR(parg16);

    return(ul);
}

ULONG FASTCALL WG32GetDIBColorTable(PVDMFRAME pFrame)
{
    ULONG              ul = 0;
    RGBQUAD *          prgb;

    register PGETDIBCOLORTABLE16 parg16;

    GETARGPTR(pFrame, sizeof(GETDIBCOLORTABLE16), parg16);
    GETMISCPTR(parg16->f4,prgb);

    ul = (ULONG)GetDIBColorTable(HDC32(parg16->f1),
                                 parg16->f2,
                                 parg16->f3,
                                 prgb);

    WOW32APIWARN(ul, "GetDIBColorTable");

    if (ul)
        FLUSHVDMPTR(parg16->f4,sizeof(RGBQUAD) * ul,prgb);

    FREEMISCPTR(prgb);
    FREEARGPTR(parg16);

    return(ul);
}

ULONG FASTCALL WG32SetDIBColorTable(PVDMFRAME pFrame)
{
    ULONG              ul = 0;
    RGBQUAD *          prgb;

    register PSETDIBCOLORTABLE16 parg16;

    GETARGPTR(pFrame, sizeof(SETDIBCOLORTABLE16), parg16);
    GETMISCPTR(parg16->f4,prgb);

    ul = (ULONG)SetDIBColorTable(HDC32(parg16->f1),
                                 parg16->f2,
                                 parg16->f3,
                                 prgb);

    WOW32APIWARN(ul, "SetDIBColorTable");

    FREEMISCPTR(prgb);
    FREEARGPTR(parg16);

    return(ul);
}


// DIBSection routines

BOOL W32CheckAndFreeDibSectionInfo (HBITMAP hbm)
{
    PDIBSECTIONINFO pdi = pDibSectionInfoHead,pdiLast=NULL;

    while (pdi) {
        if (pdi->di_hbm == hbm){

            PARM16 Parm16;
            ULONG  ulRet;

            // need to free the selector array for the memory

            Parm16.WndProc.wParam = (WORD)-1;            // selector, -1 == allocate/free
            Parm16.WndProc.lParam = (LONG) pdi->di_pv16; // pointer
            Parm16.WndProc.wMsg = 0x10; // GA_NOCOMPACT
            Parm16.WndProc.hwnd = 0;                     // selector count, 0 == free

            CallBack16(RET_SETDIBSEL,
                       &Parm16,
                       0,
                       (PVPVOID)&ulRet);
#ifndef i386
            VdmRemoveVirtualMemory((ULONG)pdi->di_newIntelDib);
#endif

            if (pdiLast == NULL)
                pDibSectionInfoHead = pdi->di_next;
            else
                pdiLast->di_next = pdi->di_next;

            // now delete the object

            DeleteObject (pdi->di_hbm);

            free_w(pdi);

            return TRUE;
        }
        pdiLast = pdi;
        pdi = pdi->di_next;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wdde.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WDDE.H
 *  WOW32 DDE worker routines.
 *
 *  History:
 *  WOW DDE support designed and developed by ChandanC
 *
--*/

#include "wowclip.h"

typedef struct _DDENODE {
    HAND16  Initiator;
    struct _DDENODE *Next;
} DDENODE, *LPDDENODE;


/* DDE h16 and h32 object alias structure
 */

typedef struct _HDDE {
    struct _HDDE *pDDENext;    // pointer to next hDDE alias
    HAND16  To_hwnd;           // window that will receive this message
    HAND16  From_hwnd;         // window that sent this message
    HAND16  hMem16;            // handle of WOW app allocated 16 bit object
    HANDLE  hMem32;            // handle of WOW allocated 32 bit object
    WORD    DdeMsg;            // message id
    WORD    DdeFormat;         // message format
    WORD    DdeFlags;          // indicates if it is metafile handle
    HAND16  h16;               // original h16 for bad apps doing EXECUTE
} HDDE, *PHDDE;


typedef struct _DDEINFO {
    WORD    Msg;               // message id
    WORD    Format;            // message format
    WORD    Flags;             // indicates if it is metafile handle
    HAND16  h16;               // original h16 for bad apps doing EXECUTE
} DDEINFO, *PDDEINFO;


typedef struct _CPDATA {
    struct _CPDATA *Next;      // pointer to next CopyData alias
    HAND16  To_hwnd;           // window that will receive this message
    HAND16  From_hwnd;         // window that sent this message
    DWORD   Mem16;             // handle of allocated 16 bit object
    DWORD   Mem32;             // handle of allocated 32 bit object
    DWORD   Flags;             // No real structure is complete without flags
} CPDATA, *PCPDATA;


// This is used by GetMessage to thunk a 32 bit message to the 16 bit
// message.

#define FREEDDEML               0x0001
#define DDE_EXECUTE_FREE_H16    0x0001
#define DDE_EXECUTE_FREE_MEM    0x0002
#define DDE_METAFILE            0x0004
#define DDE_PACKET              0x0008


// This flag is used when a 16 bit app sends data using WM_COPYDATA message
//

#define COPYDATA_16             0x0001

/*----------------------------------------------------------------------------
|       DDEDATA structure
|
|       WM_DDE_DATA parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*/

typedef struct {
   unsigned short wStatus;
   short    cfFormat;
   HAND16   Value;
} DDEDATA16;

typedef struct {
   unsigned short wStatus;
   short    cfFormat;
   HANDLE   Value;
} DDEDATA32;


VOID    WI32DDEAddInitiator (HAND16 Initiator);
VOID    WI32DDEDeleteInitiator(HAND16 Initiator);
BOOL    WI32DDEInitiate(HAND16 Initiator);
BOOL    DDEDeletehandle(HAND16 h16, HANDLE h32);
HANDLE  DDEFind32(HAND16 h16);
HAND16  DDEFind16(HANDLE h32);
BOOL    DDEAddhandle(HAND16 To_hwnd, HAND16 From_hwnd, HAND16 hMem16, HANDLE hMem32, PDDEINFO pDdeInfo);
HAND16  DDECopyhData16(HAND16 To_hwnd, HAND16 From_hwnd, HANDLE h32, PDDEINFO pDdeInfo);
HANDLE  DDECopyhData32(HAND16 To_hwnd, HAND16 From_hwnd, HAND16 h16, PDDEINFO pDdeInfo);
VOID    W32MarkDDEHandle (HAND16 hMem16);
VOID    W32UnMarkDDEHandle (HAND16 hMem16);
HANDLE  DDEFindPair32(HAND16 To_hwnd, HAND16 From_hwnd, HAND16 hMem16);
HAND16  DDEFindPair16(HAND16 To_hwnd, HAND16 From_hwnd, HANDLE hMem32);
BOOL    W32DDEFreeGlobalMem32 (HANDLE h32);
ULONG FASTCALL WK32WowDdeFreeHandle (PVDMFRAME pFrame);
BOOL    W32DdeFreeHandle16 (HAND16 h16);
PHDDE   DDEFindNode16 (HAND16 h16);
PHDDE   DDEFindNode32 (HANDLE h32);
PHDDE   DDEFindAckNode (HAND16 To_hwnd, HAND16 From_hwnd, HANDLE hMem32);
BOOL    CopyDataAddNode (HAND16 To_hwnd, HAND16 From_hwnd, DWORD Mem16, DWORD Mem32, DWORD Flags);
VPVOID  CopyDataFindData16 (HWND16 To_hwnd, HWND16 From_hwnd, DWORD Mem);
PCPDATA CopyDataFindData32 (HWND16 To_hwnd, HWND16 From_hwnd, DWORD Mem);
BOOL    CopyDataDeleteNode (HWND16 To_hwnd, HWND16 From_hwnd, DWORD Mem);
BOOL    DDEIsTargetMSDraw(HAND16 To_hwnd);
HAND16  Copyh32Toh16 (int cb, LPBYTE lpMem32);
HANDLE  Copyh16Toh32 (int cb, LPBYTE lpMem16);
VOID    FixMetafile32To16 (LPMETAFILEPICT lpMemMeta32, LPMETAFILEPICT16 lpMemMeta16);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wddeml32.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WDDEML.C
 *  WOW32 16-bit DDEML API support
 *
 *  History:
 *  Jan-23-1993 Chandan Chauhan (ChandanC)
 *  Created.
 *
 * Things needed:
 *  CALLBACK to user to find out if a given data handle has been initialized.
 *  Have DdeDataBuf routines check the handle tables before converting DIBS
 *  and METAFILEPICT formatted data so we don't have a leak.
 *
--*/


#include "precomp.h"
#pragma hdrstop
#include "wowclip.h"
#include "wddeml32.h"
#include "wowddeml.h"

MODNAME(wddeml32.c);

#ifdef DEBUG
#define WOW32SAFEASSERTWARN(exp,msg) {\
    if ((exp) == 0) {\
        LOGDEBUG(1,("    WOW32 ERROR: %s failed", msg));\
        WOW32ASSERT(FALSE); \
    }\
}
#else
#define WOW32SAFEASSERTWARN(exp,msg)
#endif

#ifdef DEBUG
WORD ddeloglevel = 3;
#define LOGDDEMLENTRY(pFrame)       LOGARGS(ddeloglevel, pFrame)
#define LOGDDEMLRETURN(pFrame, ret) LOGRETURN(ddeloglevel, pFrame, ret)
#else
#define LOGDDEMLENTRY(pFrame)
#define LOGDDEMLRETURN(pFrame, ret)
#endif

BIND1632 aCallBack[MAX_CONVS] = {0};
BIND1632 aAccessData[MAX_CONVS] = {0};

ULONG FASTCALL WD32DdeInitialize(PVDMFRAME pFrame)
{
    ULONG ul;
    DWORD IdInst;
    PDWORD16 p;
    register PDDEINITIALIZE16 parg16;

    LOGDDEMLENTRY(pFrame);

    GETARGPTR(pFrame, sizeof(DDEINITIALIZE16), parg16);
    GETMISCPTR (parg16->f1, p);

    IdInst = *p;

    ul = (ULONG)DdeInitialize(&IdInst, W32DdemlCallBack,
                               parg16->f3, parg16->f4);


    // There Could have been a Task Switch Before GetMessage Returned so Don't
    // Trust any 32 bit flat pointers we have, memory could have been compacted or
    // moved.

    FREEARGPTR(parg16);
    FREEVDMPTR(pFrame);

    GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
    GETARGPTR(pFrame, sizeof(DDEINITIALIZE16), parg16);

    if (!*p) {
        WOWDdemlBind ((DWORD)parg16->f2, IdInst, aCallBack);
    }

    *p = IdInst;

    WOW32SAFEASSERTWARN(!ul, "WD32DdeInitialize\n");
    FREEMISCPTR(p);
    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, ul);

    FREEVDMPTR(pFrame);
    RETURN(ul);
}


ULONG FASTCALL WD32DdeUninitialize(PVDMFRAME pFrame)
{
    ULONG ul;
    register PDDEUNINITIALIZE16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDEUNINITIALIZE16), parg16);

    ul = (ULONG)DdeUninitialize(parg16->f1);


    // There Could have been a Task Switch Before GetMessage Returned so Don't
    // Trust any 32 bit flat pointers we have, memory could have been compacted or
    // moved.

    FREEARGPTR(parg16);
    FREEVDMPTR(pFrame);

    GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
    GETARGPTR(pFrame, sizeof(DDEUNINITIALIZE16), parg16);

    if (ul) {
        WOWDdemlUnBind ((DWORD)parg16->f1, aCallBack);
    }

    WOW32SAFEASSERTWARN(ul, "WD32DdeUninitialize\n");
    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, ul);

    RETURN(ul);
}


ULONG FASTCALL WD32DdeConnectList(PVDMFRAME pFrame)
{
    ULONG ul;
    CONVCONTEXT CC;
    register PDDECONNECTLIST16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDECONNECTLIST16), parg16);

    W32GetConvContext (parg16->f5, &CC);

    ul = (ULONG)DdeConnectList(parg16->f1, parg16->f2,
                               parg16->f3, parg16->f4,
                               (parg16->f5) ? &CC : NULL);

    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, ul);

    RETURN(ul);
}


ULONG FASTCALL WD32DdeQueryNextServer(PVDMFRAME pFrame)
{
    ULONG ul;
    register PDDEQUERYNEXTSERVER16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDEQUERYNEXTSERVER16), parg16);

    ul = (ULONG)DdeQueryNextServer(parg16->f1, parg16->f2);


    // There Could have been a Task Switch Before GetMessage Returned so Don't
    // Trust any 32 bit flat pointers we have, memory could have been compacted or
    // moved.

    FREEARGPTR(parg16);
    FREEVDMPTR(pFrame);

#ifdef DEBUG
    GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
    LOGDDEMLRETURN(pFrame, ul);
    FREEVDMPTR(pFrame);
#endif

    RETURN(ul);
}


ULONG FASTCALL WD32DdeDisconnectList(PVDMFRAME pFrame)
{
    ULONG ul;
    register PDDEDISCONNECTLIST16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDEDISCONNECTLIST16), parg16);

    ul = (ULONG)DdeDisconnectList(parg16->f1);

    WOW32SAFEASSERTWARN(ul, "WD32DdeDisconnectList\n");

    // There Could have been a Task Switch Before GetMessage Returned so Don't
    // Trust any 32 bit flat pointers we have, memory could have been compacted or
    // moved.

    FREEARGPTR(parg16);
#ifdef DEBUG
    GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
    LOGDDEMLRETURN(pFrame, ul);
    FREEVDMPTR(pFrame);
#endif

    RETURN(ul);
}


ULONG FASTCALL WD32DdeConnect(PVDMFRAME pFrame)
{
    ULONG ul;
    CONVCONTEXT CC;
    register PDDECONNECT16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDECONNECT16), parg16);

    W32GetConvContext (parg16->f4, &CC);

    ul = (ULONG)DdeConnect(parg16->f1, parg16->f2,
                               parg16->f3, (parg16->f4) ? &CC : NULL);

    // There Could have been a Task Switch Before GetMessage Returned so Don't
    // Trust any 32 bit flat pointers we have, memory could have been compacted or
    // moved.

    FREEARGPTR(parg16);
#ifdef DEBUG
    GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
    LOGDDEMLRETURN(pFrame, ul);
    FREEVDMPTR(pFrame);
#endif

    RETURN(ul);
}


ULONG FASTCALL WD32DdeDisconnect(PVDMFRAME pFrame)
{
    ULONG ul;
    register PDDEDISCONNECT16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDEDISCONNECT16), parg16);

    ul = (ULONG)DdeDisconnect(parg16->f1);

    WOW32SAFEASSERTWARN(ul, "WD32DdeDisconnect\n");

    // There Could have been a Task Switch Before GetMessage Returned so Don't
    // Trust any 32 bit flat pointers we have, memory could have been compacted or
    // moved.

    FREEARGPTR(parg16);
#ifdef DEBUG
    GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
    LOGDDEMLRETURN(pFrame, ul);
    FREEVDMPTR(pFrame);
#endif

    RETURN(ul);
}


ULONG FASTCALL WD32DdeQueryConvInfo(PVDMFRAME pFrame)
{
    ULONG ul;
    DWORD cb16;
    CONVINFO ConvInfo;
    CONVINFO16 ConvInfo16;
    PCONVINFO16 pCI16;
    register PDDEQUERYCONVINFO16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDEQUERYCONVINFO16), parg16);

    // Initialize the size to be of NT CONVINFO structure

    ConvInfo.cb = sizeof(CONVINFO);
    ul = (ULONG)DdeQueryConvInfo(parg16->f1, parg16->f2, &ConvInfo);


    // There Could have been a Task Switch Before GetMessage Returned so Don't
    // Trust any 32 bit flat pointers we have, memory could have been compacted or
    // moved.

    FREEARGPTR(parg16);
    FREEVDMPTR(pFrame);

    GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
    GETARGPTR(pFrame, sizeof(DDEQUERYCONVINFO16), parg16);

    if (ul && parg16->f3) {
        GETMISCPTR(parg16->f3, pCI16);
        cb16 = pCI16->cb;
        RtlCopyMemory (&ConvInfo16, &ConvInfo, (LPBYTE)&ConvInfo.wFmt - (LPBYTE)&ConvInfo);
        ConvInfo16.wFmt = (WORD) ConvInfo.wFmt;
        ConvInfo16.wType = (WORD) ConvInfo.wType;
        ConvInfo16.wStatus = (WORD) ConvInfo.wStatus;
        ConvInfo16.wConvst = (WORD) ConvInfo.wConvst;
        ConvInfo16.wLastError = (WORD) ConvInfo.wLastError;
        ConvInfo16.hConvList = (DWORD) ConvInfo.hConvList;
        ConvInfo16.ConvCtxt.cb = (WORD) ConvInfo.ConvCtxt.cb;
        ConvInfo16.ConvCtxt.wFlags = (WORD) ConvInfo.ConvCtxt.wFlags;
        ConvInfo16.ConvCtxt.wCountryID = (WORD) ConvInfo.ConvCtxt.wCountryID;
        ConvInfo16.ConvCtxt.iCodePage = (INT16) ConvInfo.ConvCtxt.iCodePage;
        ConvInfo16.ConvCtxt.dwLangID = (DWORD) ConvInfo.ConvCtxt.dwLangID;
        ConvInfo16.ConvCtxt.dwSecurity = (DWORD) ConvInfo.ConvCtxt.dwSecurity;
        ConvInfo16.hwnd = (HWND16) ConvInfo.hwnd;
        ConvInfo16.hwndPartner = (HWND16) ConvInfo.hwndPartner;
        if (pCI16->cb > sizeof(CONVINFO16) || pCI16->cb == 0) {
            /*
             * If cb field is screwey assume it wasn't initialized properly
             * by the app.  Set it to the old CONVINFO16 size. (pre hwnd days)
             */
            pCI16->cb = sizeof(CONVINFO16) - sizeof(HAND16) - sizeof(HAND16);;
        }
        RtlCopyMemory (pCI16, (PVOID)&ConvInfo16, cb16);
        pCI16->cb = cb16;
        FREEMISCPTR(pCI16);
    }
    else {
        WOW32SAFEASSERTWARN(ul, "WD32QueryConvInfo\n");
    }

    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, ul);
    FREEVDMPTR(pFrame);
    RETURN(ul);
}


ULONG FASTCALL WD32DdeSetUserHandle(PVDMFRAME pFrame)
{
    ULONG ul;
    register PDDESETUSERHANDLE16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDESETUSERHANDLE16), parg16);

    ul = (ULONG)DdeSetUserHandle(parg16->f1, parg16->f2, parg16->f3);

    WOW32SAFEASSERTWARN(ul, "WD32DdeSetUserHandle\n");

    // There Could have been a Task Switch Before GetMessage Returned so Don't
    // Trust any 32 bit flat pointers we have, memory could have been compacted or
    // moved.

    FREEARGPTR(parg16);
#ifdef DEBUG
    GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
    LOGDDEMLRETURN(pFrame, ul);
    FREEVDMPTR(pFrame);
#endif

    RETURN(ul);
}


ULONG FASTCALL WD32DdeClientTransaction(PVDMFRAME pFrame)
{
    ULONG ul = 1;
    LPBYTE lpByte = NULL;
    DWORD Uresult;
    PVOID p;
    PDWORD16 pul;
    register PDDECLIENTTRANSACTION16 parg16;
    DWORD cbData;
    DWORD cbOffset;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDECLIENTTRANSACTION16), parg16);

    cbData = parg16->f2;
    cbOffset = 0;
    if (parg16->f1 && cbData && cbData != -1) { // -1 means p is a data handle
        GETMISCPTR(parg16->f1, p);
        ul = (ULONG)DdeDataBuf16to32 (p, &lpByte, &cbData, &cbOffset, parg16->f5);
        WOW32SAFEASSERTWARN(ul, "WD32DdeClientTransaction:data conversion failed.\n");
        FREEMISCPTR(p);
    }
    if (ul) {
        ul = (ULONG)DdeClientTransaction(lpByte ? lpByte : (LPBYTE)parg16->f1,
                                         cbData,
                                         parg16->f3,
                                         parg16->f4,
                                         parg16->f5,
                                         parg16->f6,
                                         parg16->f7,
                                         &Uresult);
    }
    if (lpByte) {
        free_w (lpByte);
    }


    // There Could have been a Task Switch Before GetMessage Returned so Don't
    // Trust any 32 bit flat pointers we have, memory could have been compacted or
    // moved.

    FREEARGPTR(parg16);
    FREEVDMPTR(pFrame);

    GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
    GETARGPTR(pFrame, sizeof(DDECLIENTTRANSACTION16), parg16);

    if (ul && parg16->f8) {
        GETMISCPTR (parg16->f8, pul);
        *pul = Uresult;
        FREEMISCPTR(pul);
    }

    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, ul);

    FREEVDMPTR(pFrame);
    RETURN(ul);
}


ULONG FASTCALL WD32DdeAbandonTransaction(PVDMFRAME pFrame)
{
    ULONG ul;
    register PDDEABANDONTRANSACTION16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDEABANDONTRANSACTION16), parg16);

    ul = (ULONG)DdeAbandonTransaction(parg16->f1, parg16->f2, parg16->f3);

    WOW32SAFEASSERTWARN(ul, "WD32DdeAbandonTransaction\n");

    // There Could have been a Task Switch Before GetMessage Returned so Don't
    // Trust any 32 bit flat pointers we have, memory could have been compacted or
    // moved.

    FREEARGPTR(parg16);
#ifdef DEBUG
    GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
    LOGDDEMLRETURN(pFrame, ul);
    FREEVDMPTR(pFrame);
#endif

    RETURN(ul);
}


ULONG FASTCALL WD32DdePostAdvise(PVDMFRAME pFrame)
{
    ULONG ul;
    register PDDEPOSTADVISE16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDEPOSTADVISE16), parg16);

    ul = (ULONG)DdePostAdvise(parg16->f1, parg16->f2, parg16->f3);

    WOW32SAFEASSERTWARN(ul, "WD32DdePostAdvise\n");

    // There Could have been a Task Switch Before GetMessage Returned so Don't
    // Trust any 32 bit flat pointers we have, memory could have been compacted or
    // moved.

    FREEARGPTR(parg16);
#ifdef DEBUG
    GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
    LOGDDEMLRETURN(pFrame, ul);
    FREEVDMPTR(pFrame);
#endif

    RETURN(ul);
}


ULONG FASTCALL WD32DdeCreateDataHandle(PVDMFRAME pFrame)
{
    ULONG ul = 1;
    LPBYTE lpByte = NULL;
    register PDDECREATEDATAHANDLE16 parg16;
    DWORD cbData;
    DWORD cbOffset;
    PVOID p;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDECREATEDATAHANDLE16), parg16);

    cbData = parg16->f3;
    cbOffset = parg16->f4;
    GETMISCPTR(parg16->f2, p);
    if (p != NULL) {
        ul = DdeDataBuf16to32 (p, &lpByte, &cbData, &cbOffset, parg16->f6);
        WOW32SAFEASSERTWARN(ul, "WD32DdeCreateDataHandle:data conversion failed.\n");
    }
    FREEMISCPTR(p);
    if (ul) {
        ul = (ULONG)DdeCreateDataHandle(parg16->f1,
                                        lpByte ? lpByte : 0,
                                        cbData,
                                        cbOffset,
                                        parg16->f5,
                                        parg16->f6,
                                        parg16->f7);
    }

    // There Could have been a Task Switch Before GetMessage Returned so Don't
    // Trust any 32 bit flat pointers we have, memory could have been compacted or
    // moved.

    FREEARGPTR(parg16);
    FREEVDMPTR(pFrame);

    if (lpByte) {
        free_w (lpByte);
    }

    WOW32SAFEASSERTWARN(ul, "WD32DdeCreateDataHandle\n");

#ifdef DEBUG
    GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
    LOGDDEMLRETURN(pFrame, ul);
    FREEVDMPTR(pFrame);
#endif

    RETURN(ul);
}


ULONG FASTCALL WD32DdeAddData(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    LPBYTE lpByte = NULL;
    UINT DataFormat;
    register PDDEADDDATA16 parg16;
    DWORD cbData;
    DWORD cbOffset;
    PVOID p;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDEADDDATA16), parg16);

    DataFormat = DdeGetDataHandleFormat ((DWORD)parg16->f1); // -1 is an error

    if (DataFormat != -1) {
        cbData = parg16->f3;
        cbOffset = parg16->f4;
        GETMISCPTR(parg16->f2, p);
        if (DdeDataBuf16to32 (p, &lpByte, &cbData, &cbOffset, DataFormat)) {
            ul = (ULONG)DdeAddData(parg16->f1, lpByte, cbData, cbOffset);
        } else {
            WOW32SAFEASSERTWARN(0, "WD32DdeAddData:data conversion failed.\n");
	}
	// memory may have moved - invalidate all flat pointers
	FREEARGPTR(parg16);
	FREEVDMPTR(pFrame);
        FREEMISCPTR(p);

        WOW32SAFEASSERTWARN(ul, "WD32DdeAddData\n");

        if (lpByte) {
            free_w (lpByte);
        }
    }

#ifdef DEBUG
    GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
    LOGDDEMLRETURN(pFrame, ul);
    FREEVDMPTR(pFrame);
#endif

    RETURN(ul);
}


ULONG FASTCALL WD32DdeGetData(PVDMFRAME pFrame)
{
    ULONG ul;
    LPBYTE lpByte = NULL;
    UINT DataFormat;
    PVOID p;
    register PDDEGETDATA16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDEGETDATA16), parg16);

    DataFormat = DdeGetDataHandleFormat (parg16->f1); // -1 is an error

    if (DataFormat != -1) {
        if (parg16->f2) {
            if ((lpByte = malloc_w(parg16->f3)) == NULL) {
                FREEARGPTR(parg16);
                LOGDDEMLRETURN(pFrame, 0);
                RETURN(0);
            }
        }

        DdeDataSize16to32(&(parg16->f3), &(parg16->f4), DataFormat);
	ul = (ULONG)DdeGetData(parg16->f1, lpByte, parg16->f3, parg16->f4);

	// memory may have moved - invalidate all flat pointers
	FREEVDMPTR(pFrame);
	FREEARGPTR(parg16);
	GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
	GETARGPTR(pFrame, sizeof(DDEGETDATA16), parg16);

        GETMISCPTR (parg16->f2, p);
        if (!DdeDataBuf32to16 (p, lpByte, parg16->f3, parg16->f4, DataFormat)) {
            WOW32SAFEASSERTWARN(0, "WD32DdeGetData:data conversion failed.\n");
            ul = 0;
        }
        FREEMISCPTR (p);

        WOW32SAFEASSERTWARN(ul, "WD32DdeGetData failed\n");
        if (lpByte) {
            free_w (lpByte);
        }
    }

    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, ul);

    RETURN(ul);
}


ULONG FASTCALL WD32DdeAccessData(PVDMFRAME pFrame)
{
    VPVOID vp = 0;
    DWORD cbData;
    DWORD cbData16;
    PVOID p;
    PDWORD16 pd16;
    LPBYTE lpByte;
    register PDDEACCESSDATA16 parg16;
    DWORD DataFormat;
    HAND16 h16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDEACCESSDATA16), parg16);

    DataFormat = DdeGetDataHandleFormat (parg16->f1); // -1 is an error

    if (DataFormat != -1) {
        lpByte = DdeAccessData(parg16->f1, &cbData);

        if (lpByte) {
            cbData16 = cbData;
            DdeDataSize32to16(&cbData16, NULL, DataFormat);
	    if (vp = GlobalAllocLock16(GMEM_MOVEABLE, cbData16, &h16)) {
		// 16-bit memory may have moved - invalidate all flat pointers
		FREEARGPTR(parg16);
		FREEFRAMEPTR(pFrame);
		GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
		GETARGPTR(pFrame, sizeof(DDEACCESSDATA16), parg16);

                GETMISCPTR (vp, p);
                if (!DdeIsDataHandleInitialized(parg16->f1) ||
                        DdeDataBuf32to16 (p, lpByte, cbData, 0, DataFormat)) {

                    if (parg16->f2) {
                        GETMISCPTR (parg16->f2, pd16);
                        *pd16 = cbData16;
                        FREEMISCPTR(pd16);
                    }

                    WOWDdemlBind (h16, (DWORD)parg16->f1, aAccessData);
                } else {
                    WOW32SAFEASSERTWARN(0, "WD32DdeAccessData:data conversion failed.\n");
                    GlobalUnlockFree16(h16);
                    vp = NULL;
                }
                FREEMISCPTR (p);
            }
        }
    }

    WOW32SAFEASSERTWARN(vp, "WD32DdeAccessData\n");

    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, vp);

    RETURN((ULONG)vp);
}


ULONG FASTCALL WD32DdeUnaccessData(PVDMFRAME pFrame)
{
    VPVOID vp;
    ULONG ul = 1;
    DWORD cbData;
    DWORD cbOffset = 0;
    LPBYTE lpByte;
    PVOID p;
    register PDDEUNACCESSDATA16 parg16;
    UINT DataFormat;
    HAND16 h16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDEUNACCESSDATA16), parg16);

    DataFormat = DdeGetDataHandleFormat (parg16->f1); // -1 is an error

    if (DataFormat != -1) {
        h16 = (VPVOID)WOWDdemlGetBind16 ((DWORD)parg16->f1, aAccessData);
        GlobalUnlock16(h16);
        vp = GlobalLock16(h16, NULL);

        if (!DdeIsDataHandleReadOnly((HDDEDATA)parg16->f1)) {
            lpByte = DdeAccessData(parg16->f1, &cbData);
            DdeDataSize32to16(&cbData, &cbOffset, DataFormat);
            GETMISCPTR (vp, p);
            ul = DdeDataBuf16to32 (p, &lpByte, &cbData, &cbOffset, DataFormat);
            WOW32SAFEASSERTWARN(ul, "WD32DdeAccessData:data conversion failed.\n");
            FREEMISCPTR (p);
        }

        WOWDdemlUnBind ((DWORD)parg16->f1, aAccessData);
        GlobalUnlockFree16(GlobalLock16(h16, NULL));
        if (ul) {
            ul = GETBOOL16(DdeUnaccessData(parg16->f1));
        }
    } else {
        ul = 0;
    }

    WOW32SAFEASSERTWARN(ul, "WD32DdeAccessData\n");

    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, ul);

    RETURN(ul);
}


ULONG FASTCALL WD32DdeFreeDataHandle(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PDDEFREEDATAHANDLE16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDEFREEDATAHANDLE16), parg16);

    ul = (ULONG)DdeFreeDataHandle(parg16->f1);

    WOW32SAFEASSERTWARN(ul, "WD32DdeFreeDataHandle\n");

    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, ul);

    RETURN(ul);
}


ULONG FASTCALL WD32DdeGetLastError(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PDDEGETLASTERROR16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDEGETLASTERROR16), parg16);

    ul = (ULONG)DdeGetLastError(parg16->f1);

    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, ul);

    RETURN(ul);
}


ULONG FASTCALL WD32DdeCreateStringHandle(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    LPSTR p;
    register PDDECREATESTRINGHANDLE16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDECREATESTRINGHANDLE16), parg16);
    GETPSZPTR (parg16->f2, p);

    ul = (ULONG)DdeCreateStringHandle(parg16->f1, p, INT32(parg16->f3));

    FREEPSZPTR(p);
    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, ul);
    RETURN(ul);
}


ULONG FASTCALL WD32DdeFreeStringHandle(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PDDEFREESTRINGHANDLE16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDEFREESTRINGHANDLE16), parg16);

    ul = (ULONG)DdeFreeStringHandle(parg16->f1, parg16->f2);

    WOW32SAFEASSERTWARN(ul, "WD32DdeFreeStringHandle\n");

    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, ul);

    RETURN(ul);
}


ULONG FASTCALL WD32DdeQueryString(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    LPSTR lpByte = NULL;
    register PDDEQUERYSTRING16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDEQUERYSTRING16), parg16);

    GETMISCPTR(parg16->f3, lpByte);
    ul = (ULONG)DdeQueryString(parg16->f1,
                               parg16->f2,
                               lpByte,
                               parg16->f4,
                               (int)UINT32(parg16->f5));
    if (lpByte)
        FREEMISCPTR(lpByte);

    WOW32SAFEASSERTWARN(ul, "WD32DdeQueryString\n");

    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, ul);
    RETURN(ul);
}


ULONG FASTCALL WD32DdeKeepStringHandle(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PDDEKEEPSTRINGHANDLE16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDEKEEPSTRINGHANDLE16), parg16);

    ul = (ULONG)DdeKeepStringHandle(parg16->f1, parg16->f2);

    WOW32SAFEASSERTWARN(ul, "WD32DdeKeepStringHandle\n");

    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, ul);
    RETURN(ul);
}


ULONG FASTCALL WD32DdeEnableCallback(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PDDEENABLECALLBACK16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDEENABLECALLBACK16), parg16);

    ul = (ULONG)DdeEnableCallback(parg16->f1, parg16->f2, parg16->f3);

    WOW32SAFEASSERTWARN(ul, "WD32DdeEnableCallBack\n");

    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, ul);
    RETURN(ul);
}


ULONG FASTCALL WD32DdeNameService(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PDDENAMESERVICE16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDENAMESERVICE16), parg16);

    ul = (ULONG)DdeNameService(parg16->f1, parg16->f2, parg16->f3, UINT32(parg16->f4));

    WOW32SAFEASSERTWARN(ul, "WD32DdeNameService\n");

    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, ul);
    RETURN(ul);
}


ULONG FASTCALL WD32DdeCmpStringHandles(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PDDECMPSTRINGHANDLES16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDECMPSTRINGHANDLES16), parg16);

    ul = (ULONG)DdeCmpStringHandles(parg16->f1, parg16->f2);

    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, ul);
    RETURN(ul);
}


ULONG FASTCALL WD32DdeReconnect(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PDDERECONNECT16 parg16;

    LOGDDEMLENTRY(pFrame);
    GETARGPTR(pFrame, sizeof(DDERECONNECT16), parg16);

    ul = (ULONG)DdeReconnect(parg16->f1);

    FREEARGPTR(parg16);
    LOGDDEMLRETURN(pFrame, ul);
    RETURN(ul);
}


HDDEDATA W32DdemlCallBack(UINT type, UINT fmt, HCONV hconv, HSZ hsz1,
                        HSZ hsz2, HDDEDATA hData, DWORD dwData1,
                        DWORD dwData2)
{
    DWORD  IdInst;
    VPVOID vp, vpCC;
    LONG   lReturn;
    PARM16 Parm16;
    BOOL fSuccess;
    HAND16 hCC16;

    LOGDEBUG(ddeloglevel, ("Calling WIN16 DDEMLCALLBACK(%08lx, %08lx, %08lx, %08lx, %08lx, %08lx, %08lx, %08lx)\n",
            type, fmt, hconv, hsz1, hsz2, hData, dwData1, dwData2));

    IdInst = DdeGetCallbackInstance ();

    vp = (VPVOID) WOWDdemlGetBind16 (IdInst, aCallBack);

    Parm16.Ddeml.type = (WORD)type;
    Parm16.Ddeml.fmt  = (WORD)fmt;
    Parm16.Ddeml.hconv = hconv;
    Parm16.Ddeml.hsz1 = hsz1;
    Parm16.Ddeml.hsz2 = hsz2;
    Parm16.Ddeml.hData = hData;
    if (type == XTYP_CONNECT || type == XTYP_WILDCONNECT) {
        /*
         * On XTYP_CONNECT and XTYP_WILDCONNECT transactions, dwData1 is a
         * pointer to a CONVCONTEXT structure.
         */
	vpCC = GlobalAllocLock16(GHND, sizeof(CONVCONTEXT16), &hCC16);
	// WARNING: 16-bit memory may move - invalidate any flat pointers now
        Parm16.Ddeml.dwData1 = vpCC;
        if (vpCC) {
            W32PutConvContext(vpCC, (PCONVCONTEXT)dwData1);
        }
    } else {
        Parm16.Ddeml.dwData1 = dwData1;
    }
    Parm16.Ddeml.dwData2 = dwData2;

    fSuccess = CallBack16(RET_DDEMLCALLBACK, &Parm16, vp, (PVPVOID)&lReturn);
    // WARNING: 16-bit memory may move - invalidate any flat pointers now

    if (type == XTYP_CONNECT || type == XTYP_WILDCONNECT) {
        GlobalUnlockFree16(vpCC);
    }

    if (!fSuccess) {
        WOW32SAFEASSERTWARN(NULL, "WOW::CallBack16 for DDEML failed.\n");
        lReturn = 0;
    }

    LOGDEBUG(ddeloglevel, ("DDEMLCALLBACK:%08lx\n", lReturn));
    return (lReturn);
}


VOID WOWDdemlBind (DWORD x16, DWORD x32, BIND1632 aBind[])
{
    int i;

    for (i=0; i < MAX_CONVS; i++) {
        if (aBind[i].x32 == 0) {
            aBind[i].x32 = x32;
            aBind[i].x16 = x16;
            return;
        }
    }

    LOGDEBUG(0,("WOW::WOWDdemlBind is all FULL!!!\n"));
}

VOID WOWDdemlUnBind (DWORD x32, BIND1632 aBind[])
{
    int i;

    for (i=0; i < MAX_CONVS; i++) {
        if (aBind[i].x32 == x32) {
            aBind[i].x32 = 0;
            aBind[i].x16 = 0;
            return;
        }
    }

    LOGDEBUG(0,("WOW::WOWDdemlUnBind can't find x32 !!!\n"));
}

DWORD WOWDdemlGetBind16 (DWORD x32, BIND1632 aBind[])
{
    int i;

    for (i=0; i < MAX_CONVS; i++) {
        if (aBind[i].x32 == x32) {
            return(aBind[i].x16);
        }
    }

    LOGDEBUG(0,("WOW::WOWDdemlGetBind16 can't find x16 !!!\n"));
}


DWORD WOWDdemlGetBind32 (DWORD x16, BIND1632 aBind[])
{
    int i;

    for (i=0; i < MAX_CONVS; i++) {
        if (aBind[i].x16 == x16) {
            return(aBind[i].x32);
        }
    }

    LOGDEBUG(0,("WOW::WOWDdemlGetBind32 can't find x16 !!!\n"));
}


BOOL DdeDataBuf16to32(
    PVOID p16DdeData,       // flat pointer to 16 bit DDE data buffer
    LPBYTE *pp32DdeData,    // we malloc_w this in this function if not pNULL - must be freed!
    PDWORD pcbData,         // IN:16 bit cbData OUT:32 bit cbData
    PDWORD pcbOffset,       // IN:16 bit cbOffset OUT:32 bit cbOffset
    UINT format)            // format of the data
{
    PHANDLE p;
    HAND16 hMF16;
    HANDLE hMF32;

    switch (format) {
    case CF_PALETTE:
        /*
         * GDI palette handle
         */
        if (*pcbOffset) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf16to32: PALETTE cbOffset is non NULL\n");
            return(FALSE);
            break;
        }

        if (*pcbData != sizeof(HAND16)) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf16to32: PALETTE cbData is wrong size\n");
            return(FALSE);
        }

        if (*pp32DdeData == NULL) {
            p = (PHANDLE)*pp32DdeData = malloc_w(sizeof(HANDLE));
        } else {
            p = (PHANDLE)*pp32DdeData;
        }

        *p = HPALETTE32(*(HAND16 *)p16DdeData);
        *pcbData = sizeof(HANDLE);
        break;

    case CF_DSPBITMAP:
    case CF_BITMAP:
        /*
         * GDI bitmap handle
         */
        if (*pcbOffset) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf16to32: BITMAP cbOffset is non NULL\n");
            return(FALSE);
            break;
        }
        if (*pcbData != sizeof(HAND16)) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf16to32: BITMAP cbData is wrong size\n");
            return(FALSE);
        }

        /*
         * Convert 16 bit handle to 32 bit bitmap handle and place into
         * 32 bit buffer.
         */
        if (*pp32DdeData == NULL) {
            p = (PHANDLE)*pp32DdeData = malloc_w(sizeof(HANDLE));
        } else {
            p = (PHANDLE)*pp32DdeData;
        }
        *p = HBITMAP32(*(HAND16 *)p16DdeData);
        *pcbData = sizeof(HANDLE);
        break;

    case CF_DIB:
        /*
         * GlobalDataHandle to DIB Bits
         */
        if (*pcbOffset) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf16to32: DIB cbOffset is wrong\n");
            return(FALSE);
        }

        if (*pcbData != sizeof(HAND16)) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf16to32: DIB cbData is wrong size\n");
            return(FALSE);
        }

        if (*pp32DdeData == NULL) {
            p = (PHANDLE)*pp32DdeData = malloc_w(sizeof(HANDLE));
        } else {
            p = (PHANDLE)*pp32DdeData;
        }
        if (p == NULL) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf16to32: DIB malloc failed.\n");
            return(FALSE);
        }
        *p = ConvertDIB32(*(HAND16 *)p16DdeData);
        if (*p == NULL) {
            return(FALSE);
        }
        DDEAddhandle((HAND16)-1, (HAND16)-1, *(HAND16 *)p16DdeData, *p);
        *pcbData = sizeof(HANDLE);
        break;

    case CF_DSPMETAFILEPICT:
    case CF_METAFILEPICT:
        /*
         * GlobalDataHandle holding a METAFILEPICT struct which
         * references a GDI metafile handle.
         */

        if (*pcbOffset) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf16to32: METAFILEPICT cbOffset is not 0\n");
            return(FALSE);
        }


        if (*pcbData != sizeof(HAND16)) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf16to32: METAFILEPICT cbData is wrong size\n");
            return(FALSE);
        }

        if (*pp32DdeData == NULL) {
            p = (PHANDLE)*pp32DdeData = malloc_w(sizeof(HANDLE));
        } else {
            p = (PHANDLE)*pp32DdeData;
        }
        if (p == NULL) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf16to32: METAFILEPICT malloc failed.\n");
            return(FALSE);
        }
        *p = ConvertMetaFile32(*(HAND16 *)p16DdeData, &hMF16, &hMF32);
        if (*p == NULL) {
            return(FALSE);
        }
        DDEAddhandle((HAND16)-1, (HAND16)-1, hMF16, hMF32);
        DDEAddhandle((HAND16)-1, (HAND16)-1, *(HAND16 *)p16DdeData, *p);
        *pcbData = sizeof(HANDLE);
        break;

    default:
        if (*pp32DdeData == NULL) {
            *pp32DdeData = malloc_w(*pcbData);
        }
        memcpy(*pp32DdeData, p16DdeData, *pcbData);
    }
    return(TRUE);
}



BOOL DdeDataBuf32to16(
PVOID p16DdeData,       // flat pointer to 16 bit app buffer for data
PVOID p32DdeData,       // source 32 bit buffer
DWORD cbData,           // IN:32 bit size
DWORD cbOffset,         // IN:32 bit offset
UINT format)            // format of data
{
    PHANDLE p;
    HAND16 hMF16;
    HANDLE hMF32;

    switch (format) {
    case CF_PALETTE:
        /*
         * GDI palette handle
         */
        if (cbOffset) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf32to16: PALETTE cbOffset is non NULL\n");
            return(FALSE);
            break;
        }

        if (cbData != sizeof(HANDLE)) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf32to16: PALETTE cbData is wrong size\n");
            return(FALSE);
        }

        *(HAND16 *)p16DdeData = GETHPALETTE16(*(HANDLE *)p32DdeData);
        break;

    case CF_DSPBITMAP:
    case CF_BITMAP:
        /*
         * GDI bitmap handle
         */
        if (cbOffset) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf32to16: BITMAP cbOffset is non NULL\n");
            return(FALSE);
            break;
        }
        if (cbData != sizeof(HANDLE)) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf32to16: BITMAP cbData is wrong size\n");
            return(FALSE);
        }

        /*
         * Convert 16 bit handle to 32 bit bitmap handle and place into
         * 32 bit buffer.
         */
        *(HAND16 *)p16DdeData = GETHBITMAP16(*(HBITMAP *)p32DdeData);
        break;

    case CF_DIB:
        /*
         * GlobalDataHandle to DIB Bits
         */
        if (cbOffset) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf32to16: DIB cbOffset is wrong\n");
            return(FALSE);
        }

        if (cbData != sizeof(HANDLE)) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf32to16: DIB cbData is wrong size\n");
            return(FALSE);
        }

        *(HAND16 *)p16DdeData = ConvertDIB16(*(HANDLE *)p32DdeData);
        if (*(HAND16 *)p16DdeData == NULL) {
            return(FALSE);
        }
        DDEAddhandle((HAND16)-1, (HAND16)-1, *(HAND16 *)p16DdeData, *(HANDLE *)p32DdeData);
        break;

    case CF_DSPMETAFILEPICT:
    case CF_METAFILEPICT:
        /*
         * GlobalDataHandle holding a METAFILEPICT struct which
         * references a GDI metafile handle.
         */

        if (cbOffset) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf32to16: METAFILEPICT cbOffset is not 0\n");
            return(FALSE);
        }

        if (cbData != sizeof(HANDLE)) {
            WOW32SAFEASSERTWARN(NULL, "WOW::DdeDataBuf32to16: METAFILEPICT cbData is wrong size\n");
            return(FALSE);
        }

        *(HAND16 *)p16DdeData = ConvertMetaFile16(*(HANDLE *)p32DdeData, &hMF16, &hMF32);
        if (*(HAND16 *)p16DdeData == NULL) {
            return(FALSE);
        }
        DDEAddhandle((HAND16)-1, (HAND16)-1, hMF16, hMF32);
        DDEAddhandle((HAND16)-1, (HAND16)-1, *(HAND16 *)p16DdeData, *(HANDLE *)p32DdeData);
        break;

    default:
        memcpy(p16DdeData, p32DdeData, cbData);
    }
    return(TRUE);
}



VOID DdeDataSize16to32(
DWORD *pcbData,
DWORD *pcbOff,
UINT format)
{
    switch (format) {
    case CF_DSPBITMAP:
    case CF_BITMAP:
    case CF_DIB:
    case CF_PALETTE:
    case CF_DSPMETAFILEPICT:
    case CF_METAFILEPICT:
        *pcbData = sizeof(HANDLE);
    }
}


VOID DdeDataSize32to16(
DWORD *pcbData,
DWORD *pcbOff,
UINT format)
{
    switch (format) {
    case CF_DSPBITMAP:
    case CF_BITMAP:
    case CF_DIB:
    case CF_PALETTE:
    case CF_DSPMETAFILEPICT:
    case CF_METAFILEPICT:
        *pcbData = sizeof(HAND16);
    }
}


VOID W32GetConvContext (VPVOID vp, PCONVCONTEXT pCC32)
{
    PCONVCONTEXT16 pCC16;

    GETMISCPTR (vp, pCC16);

    if (pCC16) {
        WOW32SAFEASSERTWARN((pCC16->cb == sizeof(CONVCONTEXT16)),"WOW::W32GetConvContext: Bad value in cb\n");
        pCC32->cb         = sizeof(CONVCONTEXT);
        pCC32->wFlags     = pCC16->wFlags;
        pCC32->wCountryID = pCC16->wCountryID;
        pCC32->iCodePage  = pCC16->iCodePage;
        pCC32->dwLangID   = pCC16->dwLangID;
        pCC32->dwSecurity = pCC16->dwSecurity;
        /*
         * WOW apps don't know anything about NT security so just pass on the
         * default QOS that the system grants to know-nothing apps.
         */
        pCC32->qos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        pCC32->qos.ImpersonationLevel = SecurityImpersonation;
        pCC32->qos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
        pCC32->qos.EffectiveOnly = TRUE;
    }

    FREEMISCPTR(pCC16);
}

VOID W32PutConvContext (VPVOID vp, PCONVCONTEXT pCC32)
{
    PCONVCONTEXT16 pCC16;

    GETMISCPTR (vp, pCC16);

    if (pCC16) {
        WOW32SAFEASSERTWARN((pCC32->cb == sizeof(CONVCONTEXT)),"WOW::W32PutConvContext: Bad value in cb\n");
        pCC16->cb         = sizeof(CONVCONTEXT16);
        pCC16->wFlags     = pCC32->wFlags;
        pCC16->wCountryID = pCC32->wCountryID;
        pCC16->iCodePage  = pCC32->iCodePage;
        pCC16->dwLangID   = pCC32->dwLangID;
        pCC16->dwSecurity = pCC32->dwSecurity;
    }

    FREEMISCPTR(pCC16);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wdib.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGDI.H
 *  WOW32 16-bit GDI API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/

typedef struct _DIBINFO {
    HDC     di_hdc;
    HANDLE  di_hfile;
    HANDLE  di_hsec;
    ULONG   di_nalignment;
    PVOID   di_newdib;
    PVOID   di_newIntelDib;
    HBITMAP di_hbm;
    ULONG   di_dibsize;
    USHORT  di_originaldibsel;
    USHORT  di_originaldibflags;
    ULONG   di_lockcount;
    struct _DIBINFO *di_next;
} DIBINFO, *PDIBINFO;


HDC     W32HandleDibDrv (PVPVOID vpbmi16);
BOOL    W32AddDibInfo ( HDC hdcMem, 
                        HANDLE hfile, 
                        HANDLE hsec, 
                        ULONG nalignment,
                        PVOID newdib, 
                        PVOID newIntelDib, 
                        HBITMAP hbm, 
                        ULONG dibsize,
                        USHORT OriginalFlags, 
                        USHORT OriginalSel);

BOOL    W32CheckAndFreeDibInfo (HDC hdc);
VOID    W32FreeDibInfo (PDIBINFO pdiCur, PDIBINFO pdiLast);
ULONG   W32RestoreOldDib (PDIBINFO pdi);
HDC     W32FindAndLockDibInfo (USHORT sel);

BOOL W32CheckDibDrvColorIndices(HDC16 hdcDest, HDC16 hdcSrc);
VOID W32DibDrvColorIndicesRestore(void);

typedef struct _DIBSECTIONINFO {
    HBITMAP di_hbm;
    PVOID   di_pv16;
    PVOID   di_newIntelDib;
    struct _DIBSECTIONINFO *di_next;
} DIBSECTIONINFO, *PDIBSECTIONINFO;

BOOL    W32CheckAndFreeDibSectionInfo (HBITMAP hbm);
ULONG cjBitmapBitsSize(CONST BITMAPINFO *pbmi);

extern PDIBSECTIONINFO pDibSectionInfoHead;

///////////////////////////////////////////////////////////////////////////////
//
//  DIB Macros
//
///////////////////////////////////////////////////////////////////////////////
//
//  These are commonly used macros for dib fields access
//
//

#define __abs(a) ((a) >= 0 ? (a) : -(a))

#define WIDTHBYTES(i)           ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DibWidthBytes(lpbi)     (UINT)WIDTHBYTES((UINT)(lpbi)->biWidth * (UINT)((lpbi)->biBitCount))

#define DibSizeImage(lpbi)      ((DWORD)(UINT)DibWidthBytes(lpbi) * (DWORD)(UINT)(__abs((lpbi)->biHeight)))
#define DibSize(lpbi)           ((lpbi)->biSize + (lpbi)->biSizeImage + (int)(lpbi)->biClrUsed * sizeof(RGBQUAD))

#define DibPtr(lpbi)            (LPVOID)(DibColors(lpbi) + (UINT)(lpbi)->biClrUsed)
#define DibColors(lpbi)         ((LPRGBQUAD)((LPBYTE)(lpbi) + (int)(lpbi)->biSize))

#define DibNumColors(lpbi)      ((lpbi)->biClrUsed == 0 && (lpbi)->biBitCount <= 8 \
                                    ? (int)(1 << (int)(lpbi)->biBitCount)          \
                                    : (int)(lpbi)->biClrUsed)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wdos.c ===
/* wdos.c - DOS realted functions for WOW
 *
 * Modification History
 *
 * Sudeepb 23-Aug-1991 Created
 */

#include "precomp.h"
#pragma hdrstop
#include "curdir.h"


MODNAME(wdos.c);

ULONG demClientErrorEx (HANDLE hFile, CHAR chDrive, BOOL bSetRegs);

extern DOSWOWDATA DosWowData;
extern PWORD16 pCurTDB, pCurDirOwner;

//
// This is our local array of current directory strings. A particular entry
// is only used if the directory becomes longer than the old MS-DOS limit
// of 67 characters.
//
#define MAX_DOS_DRIVES 26
LPSTR CurDirs[MAX_DOS_DRIVES] = {NULL};


VOID DosWowUpdateTDBDir(UCHAR Drive, LPSTR pszDir);
VOID DosWowUpdateCDSDir(UCHAR Drive, LPSTR pszDir);

#ifdef DEBUG
VOID __cdecl Dumpdir(LPSTR pszfn, LPSTR pszDir, ...);
#else
#define Dumpdir //
#endif

//
// modify this to change all the current directory spew's logging level
//
#define CURDIR_LOGLEVEL 4

/* First, a brief explanation on Windows and current directory
 *
 * 1. Windows keeps a single current directory (and drive off course) per
 *    application. All the "other" drives are shared between the apps and
 *    current dirs on them could change without further notice, such that
 *    if app "Abra" has c as it's current drive and "c:\foo" is it's current
 *    dir, and another app "Cadabra" has d as it's current drive and "d:\bar"
 *    as it's current dir, then this is what apps get in return to the respective
 *    system calls:
 *    App     Call                 Param      result
 *    Cadabra GetCurrentDirectory  c:         c:\foo
 *    Abra    SetCurrentDirectory  c:\foobar
 *    Cadabra GetCurrentDirectory  c:         c:\foobar
 *    Abra    SetCurrentDirectory  d:\test
 *    Abra    GetCurrentDirectory  d:         d:\test
 *    Cadabra GetCurrentDirectory  d:         d:\bar   <- d is it's current drive!
 *
 * 2. Windows is a "non-preemptive" multitasking OS. Remember that for later.
 *
 * 3. Tasks are id'd by their respective TDB's which have these interesting
 *    members (see tdb16.h for the complete list):
 *
 *    TDB_Drive
 *    TDB_LFNDirectory
 *
 *    when the high bit of the TDB_Drive is set (TDB_DIR_VALID) -- TDB_LFNDirectory
 *    is a valid current directory for the TDB_Drive (which is app's current
 *    drive). The drive itself (0-based drive number) is stored in
 *    TDB_Drive & ~TDB_DIR_VALID
 *
 * 4. Who touches TDB_Drive ?
 *    SaveState code -- which is called when the task is being switched away *from*
 *    it looks to see if info on current drive and directory in TDB is stale (via
 *    the TDB_DIR_VALID bit) and calls GetDefaultDrive and GetCurrentDirectory to
 *    make sure what's in TDB is valid
 *
 * 5. Task switching
 *    When task resumes it's running due to explanation above -- it has valid
 *    TDB_Drive in it. When the very first call to the relevant i21 is being
 *    made -- kernel looks at the owner of the current drive (kernel variable)
 *    and if some other task owns the current drive/directory -- it makes calls
 *    to wow to set current drive/dir from the TDB (which is sure valid at
 *    this point). Current Drive owner is set to the current task so that
 *    the next time around this call is not performed -- and since windows does
 *    not allow task preemptions -- any calls to set drive/directory are not
 *    reflected upon tdb up until the task switch time.
 *
 * 6. WOW considerations
 *    We in WOW have a great deal of hassle due to a number of APIs that are
 *    not called from i21 handler but rather deal with file i/o and other
 *    issues that depend upon Win32 current directory. Lo and behold we have
 *    an UpdateDosCurrentDirectory call that we make before and after the call
 *    to certain Win32 apis (which were found by trial and error)
 *    The logic inside is that we always try to keep as much sync as possible
 *    between TDB, CDS and Win32.
 *
 * 7. CurDirs
 *    CDS can only accomodate current dirs which are up to 64 chars in length
 *    hence there is an array of CurDirs which is filled on a per-need basis
 *    for those drives that have curdir lengths > 64+3 chars
 *
 * 8. Belief
 *    I profoundly believe that the above information is sufficient by large
 *    to successfully troubleshoot all the "current directory" issues that may
 *    arise :-)
 *
 * 9. Thanks
 *    Goes to Neil and Dave for all the insight and patience that made all these
 *    wonderful discoveries possible.
 *
 * -- VadimB, This day -- July, the 28th 1997
 */

/* GetCurrentDir - Updatess current dir in CDS structure
 *
 * Entry - pcds    = pointer to CDS
 *         chDrive = Physical Drive in question (0, 1 ...)
 *
 * Exit
 *      SUCCESS - returns TRUE
 *
 *      FAILURE - returns FALSE
 */
BOOL GetCurrentDir (PCDS pcds, UCHAR Drive)
{
    static CHAR  EnvVar[] = "=?:";
    DWORD EnvVarLen;
    BOOL bStatus = TRUE;
    UCHAR FixedCount;
    int i;
    PCDS pcdstemp;

    FixedCount = *(PUCHAR) DosWowData.lpCDSCount;
    //
    // from Macro.Asm in DOS:
    // ; Sudeepb 20-Dec-1991 ; Added for redirected drives
    // ; We always sync the redirected drives. Local drives are sync
    // ; as per the curdir_tosync flag and SCS_ToSync
    //

    if (*(PUCHAR)DosWowData.lpSCS_ToSync) {

#ifdef FE_SB
        if (GetSystemDefaultLangID() == MAKELANGID(LANG_JAPANESE,SUBLANG_DEFAULT)) {
            PCDS_JPN pcdstemp_jpn;

            pcdstemp_jpn = (PCDS_JPN) DosWowData.lpCDSFixedTable;
            for (i=0;i < (int)FixedCount; i++, pcdstemp_jpn++)
                pcdstemp_jpn->CurDirJPN_Flags |= CURDIR_TOSYNC;
        }
        else {
            pcdstemp = (PCDS) DosWowData.lpCDSFixedTable;
            for (i=0;i < (int)FixedCount; i++, pcdstemp++)
                pcdstemp->CurDir_Flags |= CURDIR_TOSYNC;
        }
#else
        pcdstemp = (PCDS) DosWowData.lpCDSFixedTable;
        for (i=0;i < (int)FixedCount; i++, pcdstemp++)
            pcdstemp->CurDir_Flags |= CURDIR_TOSYNC;
#endif

        // Mark tosync in network drive as well
        pcdstemp = (PCDS)DosWowData.lpCDSBuffer;
        pcdstemp->CurDir_Flags |= CURDIR_TOSYNC;

        *(PUCHAR)DosWowData.lpSCS_ToSync = 0;
    }

    // If CDS needs to be synched or if the requested drive is different
    // then the the drive being used by NetCDS go refresh the CDS.
    if ((pcds->CurDir_Flags & CURDIR_TOSYNC) ||
        ((Drive >= FixedCount) && (pcds->CurDir_Text[0] != (Drive + 'A') &&
                                   pcds->CurDir_Text[0] != (Drive + 'a')))) {
        // validate media
        EnvVar[1] = Drive + 'A';
        if((EnvVarLen = GetEnvironmentVariableOem (EnvVar, (LPSTR)pcds,
                                                MAXIMUM_VDM_CURRENT_DIR+3)) == 0){

        // if its not in env then and drive exist then we have'nt
        // yet touched it.

            pcds->CurDir_Text[0] = EnvVar[1];
            pcds->CurDir_Text[1] = ':';
            pcds->CurDir_Text[2] = '\\';
            pcds->CurDir_Text[3] = 0;
            SetEnvironmentVariableOem ((LPSTR)EnvVar,(LPSTR)pcds);
        }

        if (EnvVarLen > MAXIMUM_VDM_CURRENT_DIR+3) {
            //
            // The current directory on this drive is too long to fit in the
            // cds. That's ok for a win16 app in general, since it won't be
            // using the cds in this case. But just to be more robust, put
            // a valid directory in the cds instead of just truncating it on
            // the off chance that it gets used.
            //
            pcds->CurDir_Text[0] = EnvVar[1];
            pcds->CurDir_Text[1] = ':';
            pcds->CurDir_Text[2] = '\\';
            pcds->CurDir_Text[3] = 0;
        }

        pcds->CurDir_Flags &= 0xFFFF - CURDIR_TOSYNC;
        pcds->CurDir_End = 2;

    }

    if (!bStatus) {

        *(PUCHAR)DosWowData.lpDrvErr = ERROR_INVALID_DRIVE;
    }

    return (bStatus);

}

/* SetCurrentDir - Set the current directory
 *
 *
 * Entry - lpBuf   = pointer to string specifying new directory
 *         chDrive = Physical Drive in question (0, 1 ...)
 *
 * Exit
 *     SUCCESS returns TRUE
 *     FAILURE returns FALSE
 *
 */

BOOL SetCurrentDir (LPSTR lpBuf, UCHAR Drive)
{
    static CHAR EnvVar[] = "=?:";
    CHAR chDrive = Drive + 'A';
    BOOL bRet;

    // ok -- we are setting the current directory ONLY if the drive
    // is the current drive for the app

    if (*(PUCHAR)DosWowData.lpCurDrv == Drive) { // if on the current drive--go win32
       bRet = SetCurrentDirectoryOem(lpBuf);
    }
    else {  // verify it's a valid dir
       DWORD dwAttributes;

       dwAttributes = GetFileAttributesOem(lpBuf);
       bRet = (0xffffffff != dwAttributes) && (dwAttributes & FILE_ATTRIBUTE_DIRECTORY);
    }

    if (!bRet) {
       demClientErrorEx(INVALID_HANDLE_VALUE, chDrive, FALSE);
       return(FALSE);
    }

    EnvVar[1] = chDrive;
    bRet = SetEnvironmentVariableOem((LPSTR)EnvVar,lpBuf);

    return (bRet);
}


/* QueryCurrentDir - Verifies current dir provided in CDS structure
 *                      for $CURRENT_DIR
 *
 * First Validates Media, if invalid -> i24 error
 * Next  Validates Path, if invalid set path to root (not an error)
 *
 * Entry - Client (DS:SI) Buffer to CDS path to verify
 *     Client (AL)    Physical Drive in question (A=0, B=1, ...)
 *
 * Exit
 *     SUCCESS
 *       Client (CY) = 0
 *
 *         FAILURE
 *           Client (CY) = 1 , I24 drive invalid
 */
BOOL QueryCurrentDir (PCDS pcds, UCHAR Drive)
{
    DWORD dw;
    CHAR  chDrive;
    static CHAR  pPath[]="?:\\";
    static CHAR  EnvVar[] = "=?:";

    // validate media
    chDrive = Drive + 'A';
    pPath[0] = chDrive;
    dw = GetFileAttributesOem(pPath);
    if (dw == 0xFFFFFFFF || !(dw & FILE_ATTRIBUTE_DIRECTORY))
      {
        demClientErrorEx(INVALID_HANDLE_VALUE, chDrive, FALSE);
        return (FALSE);
        }

    // if invalid path, set path to the root
    // reset CDS, and win32 env for win32
    dw = GetFileAttributesOem(pcds->CurDir_Text);
    if (dw == 0xFFFFFFFF || !(dw & FILE_ATTRIBUTE_DIRECTORY))
      {
        strcpy(pcds->CurDir_Text, pPath);
        pcds->CurDir_End = 2;
        EnvVar[1] = chDrive;
        SetEnvironmentVariableOem(EnvVar,pPath);
        }

    return (TRUE);
}


/* strcpyCDS - copies CDS paths
 *
 *  This routine emulates how DOS was coping the directory path. It is
 *  unclear if it is still necessary to do it this way.
 *
 * Entry -
 *
 * Exit
 *     SUCCESS
 *
 *         FAILURE
 */
VOID strcpyCDS (PCDS source, LPSTR dest)
{
#ifdef FE_SB   // for DBCS Directory name by v-hidekk 1994.5.23
    unsigned char ch;
    unsigned char ch2;
#else // !FE_SB
    char ch;
#endif // !FE_SB
    int index;

    index = source->CurDir_End;

    if (source->CurDir_Text[index]=='\\')
        index++;
#ifdef FE_SB  //for DBCS Directory by v-hidekk 1994.5.23

// BUGBUG -- the code below is not equivalent to the code in Else clause
// we need to check for 0x05 character preceded by '\\' and replace it
// wth 0xE5

    while (ch = source->CurDir_Text[index]) {
        if (IsDBCSLeadByte(ch) ) {
            if( ch2 = source->CurDir_Text[index+1] ) {
                *dest++ = ch;
                *dest++ = ch2;
                index+=2;
            }
            else {
                index++;
            }
        }
        else {
            *dest++ = (UCHAR)toupper(ch);
            index++;
        }
    }


#else // !FE_SB

    while (ch = source->CurDir_Text[index]) {

        if ((ch == 0x05) && (source->CurDir_Text[index-1] == '\\')) {
            ch = (CHAR) 0xE5;
        }

        *dest++ = toupper(ch);
        index++;
    }
#endif // !FE_SB

    *dest = ch;                                 // trailing zero

}


/* GetCDSFromDrv - Updates current dir in CDS structure
 *
 * Entry - Drive    = Physical Drive in question (0, 1 ...)
 *
 * Exit
 *      SUCCESS - returns v86 pointer to CDS structure in DOS
 *
 *      FAILURE - returns 0
 */

PCDS GetCDSFromDrv (UCHAR Drive)
{
    PCDS  pCDS = NULL;
    static CHAR  pPath[]="?:\\";
    CHAR  chDrive;
     //
    // Is Drive valid?
    //

    if (Drive >= *(PUCHAR)DosWowData.lpCDSCount) {

        if (Drive <= 25) {

            chDrive = Drive + 'A';
            pPath[0] = chDrive;

            //
            // test to see if non-fixed/floppy drive exists
            //

            if ((*(PUCHAR)DosWowData.lpCurDrv == Drive) ||
                (GetDriveType(pPath) > 1)) {

                //
                // Network drive
                //

                pCDS = (PCDS) DosWowData.lpCDSBuffer;
            }

        }

    } else {

#if NEC_98
        //  This is updated a current dir in lpCDSBuffer or lpCDSFixedTable.
        //  Then, The drive is checked  the drive type and lpCDSCount(continuation drive).
        if (Drive <= 25)
        {
            chDrive = Drive + 'A';
            pPath[0] = chDrive;

            switch(GetDriveType(pPath))
            {
                case DRIVE_REMOTE:
                // NetWorkDrive
                    pCDS = (PCDS) DosWowData.lpCDSBuffer;
                    break;

                case DRIVE_REMOVABLE:
                case DRIVE_FIXED:
                case DRIVE_CDROM:
                case DRIVE_RAMDISK:
                    pCDS = (PCDS) DosWowData.lpCDSFixedTable;
                    pCDS = (PCDS)((ULONG)pCDS + (Drive*sizeof(CDS_JPN)));
                    break;
            }
        }
#else   // NEC_98
        chDrive = Drive + 'A';
        pPath[0] = chDrive;
        if ((Drive != 1) || (DRIVE_REMOVABLE == GetDriveType(pPath))) {

            //
            // Drive defined in fixed table
            //

            pCDS = (PCDS) DosWowData.lpCDSFixedTable;
#ifdef FE_SB
            if (GetSystemDefaultLangID() == MAKELANGID(LANG_JAPANESE,SUBLANG_DEFAULT)) {
                pCDS = (PCDS)((ULONG)pCDS + (Drive*sizeof(CDS_JPN)));
            }
            else
                pCDS = (PCDS)((ULONG)pCDS + (Drive*sizeof(CDS)));
#else
            pCDS = (PCDS)((ULONG)pCDS + (Drive*sizeof(CDS)));
#endif
        }
#endif  // NEC_98

    }

    return (pCDS);
}


/* DosWowSetDefaultDrive - Emulate DOS set default drive call
 *
 * Entry -
 *  BYTE  DriveNum;    = drive number to switch to
 *
 * Exit
 *       returns client AX
 *
 */

ULONG DosWowSetDefaultDrive(UCHAR Drive)
{
    PCDS pCDS;

    if (NULL != (pCDS = GetCDSFromDrv (Drive))) {

        if (GetCurrentDir (pCDS, Drive)) {

            if (*(PUCHAR)DosWowData.lpCurDrv != Drive) {

                // The upper bit in the TDB_Drive byte is used to indicate
                // that the current drive and directory information in the
                // TDB is stale. Turn it off here.

                // what is the curdir for this drive ?
                //

                CHAR  szPath[MAX_PATH] = "?:\\";
                PTDB  pTDB;

                if (*pCurTDB) {
                   pTDB = (PTDB)SEGPTR(*pCurTDB,0);
                   if (TDB_SIGNATURE == pTDB->TDB_sig) {
                      if ((pTDB->TDB_Drive & TDB_DIR_VALID) &&
                          (Drive == (pTDB->TDB_Drive & ~TDB_DIR_VALID))) {
                         // update cds with current stuff here

                         szPath[0] = 'A' + Drive;
                         strcpy(&szPath[2], pTDB->TDB_LFNDirectory);
                         // this call also updates the current dos drive
                         DosWowUpdateCDSDir(Drive, szPath);
                         Dumpdir("SetDefaultDrive(TDB->CDS): Drive %x", szPath, (UINT)Drive);
                         return(Drive);
                      }
                   }
                }

                szPath[0] = Drive + 'A';

                if ((Drive<MAX_DOS_DRIVES) && CurDirs[Drive]) {
                   strcpy(&szPath[3], CurDirs[Drive]);
                }
                else { // grab one from CDS
                   strcpyCDS(pCDS, &szPath[3]);
                }

                // update TDB to be in-sync with the cds

                Dumpdir("SetDefaultDrive(CDS->TDB): Drive %x", szPath, (UINT)Drive);
                *(PUCHAR)DosWowData.lpCurDrv = Drive;
                DosWowUpdateTDBDir(Drive, szPath);

            }

        }
    }

    return (*(PUCHAR)DosWowData.lpCurDrv);

}


#ifdef DEBUG

VOID __cdecl
Dumpdir(LPSTR pszfn, LPSTR pszDir, ...)
{

   PTDB pTDB;
   char szMod[9];
   char s[256];
   va_list va;

   if (NULL != WOW32_strchr(pszfn, '%')) {
      va_start(va, pszDir);
      wvsprintf(s, pszfn, va);
      va_end(va);
      pszfn = s;
   }

   LOGDEBUG(CURDIR_LOGLEVEL, ("%s: ", pszfn));

   if (*pCurTDB) {

      pTDB = (PTDB)SEGPTR(*pCurTDB,0);
      if (NULL != pTDB && TDB_SIGNATURE == pTDB->TDB_sig) {

         WOW32_strncpy(szMod, pTDB->TDB_ModName, 8);
         szMod[8] = '\0';
         LOGDEBUG(CURDIR_LOGLEVEL, ("CurTDB: %x (%s) ", (DWORD)*pCurTDB, szMod));
         LOGDEBUG(CURDIR_LOGLEVEL, ("Drv %x Dir %s\n", (DWORD)pTDB->TDB_Drive, pTDB->TDB_LFNDirectory));

      }
   }
   else {
      LOGDEBUG(CURDIR_LOGLEVEL, ("CurTDB: NULL\n"));
   }

   LOGDEBUG(CURDIR_LOGLEVEL, ("%s: ", pszfn));

   if (*pCurDirOwner) {

      pTDB = (PTDB)SEGPTR(*pCurDirOwner,0);
      if (NULL != pTDB && TDB_SIGNATURE == pTDB->TDB_sig) {

         WOW32_strncpy(szMod, pTDB->TDB_ModName, 8);
         szMod[8] = '\0';
         LOGDEBUG(CURDIR_LOGLEVEL, ("CurDirOwn: %x (%s) ", (DWORD)*pCurDirOwner, szMod));
         LOGDEBUG(CURDIR_LOGLEVEL, ("Drive %x Dir %s\n", (DWORD)pTDB->TDB_Drive, pTDB->TDB_LFNDirectory));

      }

   }
   else {
      LOGDEBUG(CURDIR_LOGLEVEL, ("CurDirOwn: NULL\n"));
   }

   if (NULL != pszDir) {
      LOGDEBUG(CURDIR_LOGLEVEL, ("%s: %s\n", pszfn, pszDir));
   }

}
#endif

// returns: current directory as done from the root

BOOL DosWowGetTDBDir(UCHAR Drive, LPSTR pCurrentDirectory)
{
   PTDB pTDB;

   if (*pCurTDB) {
      pTDB = (PTDB)SEGPTR(*pCurTDB,0);
      if (TDB_SIGNATURE == pTDB->TDB_sig &&
            (pTDB->TDB_Drive & TDB_DIR_VALID) &&
            ((pTDB->TDB_Drive & ~TDB_DIR_VALID) == Drive)) {
         strcpy(pCurrentDirectory, &pTDB->TDB_LFNDirectory[1]);
         // upper-case directory name
         WOW32_strupr(pCurrentDirectory);
         Dumpdir("DosWowGetTDBDir(CurTDB): Drive %x", pCurrentDirectory, (UINT)Drive);
         return(TRUE);
      }
   }
   return(FALSE);
}



/* DosWowGetCurrentDirectory - Emulate DOS Get current Directory call
 *
 *
 * Entry -
 *    Drive - Drive number for directory request
 *    pszDir- pointer to receive directory (MUST BE OF SIZE MAX_PATH)
 *
 * Exit
 *     SUCCESS
 *       0
 *
 *     FAILURE
 *       system status code
 *
 */
ULONG DosWowGetCurrentDirectory(UCHAR Drive, LPSTR pszDir)
{
    PCDS pCDS;
    DWORD dwRet = 0xFFFF000F;       // assume error

    //
    // Handle default drive value of 0
    //

    if (Drive == 0) {
       Drive = *(PUCHAR)DosWowData.lpCurDrv;
    } else {
       Drive--;
    }

    if (DosWowGetTDBDir(Drive, pszDir)) {
       return(0);
    }

    //
    // If the path has grown larger than the old MS-DOS path size, then
    // get the directory from our own private array.
    //
    if ((Drive<MAX_DOS_DRIVES) && CurDirs[Drive]) {
        strcpy(pszDir, CurDirs[Drive]);
        Dumpdir("GetCurrentDirectory(CurDirs): Drive %x", pszDir, (UINT)Drive);
        return 0;
    }

    if (NULL != (pCDS = GetCDSFromDrv (Drive))) {

        if (GetCurrentDir (pCDS, Drive)) {
            // for removable media we need to check that media is present.
            // fixed disks, network drives and CDROM drives are fixed drives in
            // DOS. sudeepb 30-Dec-1993
            if (!(pCDS->CurDir_Flags & CURDIR_NT_FIX)) {
                if(QueryCurrentDir (pCDS, Drive) == FALSE)
                    return (dwRet);         // fail
            }
            strcpyCDS(pCDS, pszDir);
            dwRet = 0;
        }
    }

    Dumpdir("GetCurrentDirectory: Drive %x", pszDir, (UINT)Drive);
    return (dwRet);

}

// updates current directory in CDS for the specified drive
//

VOID DosWowUpdateCDSDir(UCHAR Drive, LPSTR pszDir)
{
   PCDS pCDS;

   if (NULL != (pCDS = GetCDSFromDrv(Drive))) {
      // cds retrieved successfully

      // now for this drive -- validate

      if (strlen(pszDir) > MAXIMUM_VDM_CURRENT_DIR+3) {
         if ((!CurDirs[Drive]) &&
              (NULL == (CurDirs[Drive] = malloc_w(MAX_PATH)))) {
            return;
         }

         strcpy(CurDirs[Drive], &pszDir[3]);
         // put a valid directory in cds just for robustness' sake
         WOW32_strncpy(&pCDS->CurDir_Text[0], pszDir, 3);
         pCDS->CurDir_Text[3] = 0;
      } else {
         if (CurDirs[Drive]) {
            free_w(CurDirs[Drive]);
            CurDirs[Drive] = NULL;
         }
         strcpy(&pCDS->CurDir_Text[0], pszDir);
      }

      *(PUCHAR)DosWowData.lpCurDrv = Drive;

   }

}

// updates current task's tdb with the current drive and directory information
//
//

VOID DosWowUpdateTDBDir(UCHAR Drive, LPSTR pszDir)
{
   PTDB pTDB;

   if (*pCurTDB) {

      pTDB = (PTDB)SEGPTR(*pCurTDB,0);
      if (TDB_SIGNATURE == pTDB->TDB_sig) {

         // So TDB should be updated IF the current drive is
         // indeed the drive we're updating a directory for

         if (*(PUCHAR)DosWowData.lpCurDrv == Drive) { // or valid and it's current drive

            pTDB->TDB_Drive = Drive | TDB_DIR_VALID;
            strcpy(pTDB->TDB_LFNDirectory, pszDir+2);
            *pCurDirOwner = *pCurTDB;
         }

      }

   }
}


/* DosWowSetCurrentDirectory - Emulate DOS Set current Directory call
 *
 *
 * Entry -
 *    lpDosDirectory - pointer to new DOS directory
 *
 * Exit
 *     SUCCESS
 *       0
 *
 *     FAILURE
 *       system status code
 *
 */

extern NTSTATUS demSetCurrentDirectoryLCDS(UCHAR, LPSTR);

ULONG DosWowSetCurrentDirectory(LPSTR pszDir)
{
    PCDS pCDS;
    UCHAR Drive;
    LPTSTR pLast;
    PSTR lpDirName;
    UCHAR szPath[MAX_PATH];
    DWORD dwRet = 0xFFFF0003;       // assume error
    static CHAR  EnvVar[] = "=?:";
    BOOL  ItsANamedPipe = FALSE;
    BOOL  fSetDirectory = TRUE;       // try mapping directory from 9x special path to nt if false

    if (':' == pszDir[1]) {
        Drive = toupper(pszDir[0]) - 'A';
    } else {
        if (IS_ASCII_PATH_SEPARATOR(pszDir[0]) &&
            IS_ASCII_PATH_SEPARATOR(pszDir[1])) {
            return dwRet;       // can't update dos curdir with UNC
        }
        Drive = *(PUCHAR)DosWowData.lpCurDrv;
    }


    if (NULL != (pCDS = GetCDSFromDrv (Drive))) {

        lpDirName = NormalizeDosPath(pszDir, Drive, &ItsANamedPipe);

        GetFullPathNameOem(lpDirName, MAX_PATH, szPath, &pLast);



        fSetDirectory = SetCurrentDir(szPath,Drive);

        if (!fSetDirectory) {

             //
             // If set directory with the given path failed it might be one of the
             // 9x special path, so try mapping it to NT special path
             // i.e. c:\winnt\startm~1 becomes c:\docume~1\alluse~1\startm~1         
             //

             UCHAR szMappedPath[MAX_PATH];
                                
             if( W32Map9xSpecialPath(szPath,szMappedPath) ){
                 strcpy(szPath,szMappedPath);
                 fSetDirectory = SetCurrentDir(szPath,Drive);
             } 
        }

        
        if (fSetDirectory) {

            //
            // If the directory is growing larger than the old MS-DOS max,
            // then remember the path in our own array. If it is shrinking,
            // then free up the string we allocated earlier.
            //
            if (strlen(szPath) > MAXIMUM_VDM_CURRENT_DIR+3) {
                if ((!CurDirs[Drive]) &&
                    (NULL == (CurDirs[Drive] = malloc_w(MAX_PATH)))) {
                    return dwRet;
                }
                strcpy(CurDirs[Drive], &szPath[3]);
                // put a valid directory in cds just for robustness' sake
                WOW32_strncpy(&pCDS->CurDir_Text[0], szPath, 3);
                pCDS->CurDir_Text[3] = 0;
            } else {
                if (CurDirs[Drive]) {
                    free_w(CurDirs[Drive]);
                    CurDirs[Drive] = NULL;
                }
                strcpy(&pCDS->CurDir_Text[0], szPath);
            }

            dwRet = 0;

            //
            // Update kernel16's "directory owner" with the current TDB.
            //
            Dumpdir("SetCurrentDirectory", szPath);
            DosWowUpdateTDBDir(Drive, szPath);

            // now update dem
            demSetCurrentDirectoryLCDS(Drive, szPath);

        }

    }

    return (dwRet);
}


//*****************************************************************************
// UpdateDosCurrentDirectory -
//
// Entry -
//    fDir - specifies which directory should be updated
//
// Exit -
//    TRUE if the update was successful, FALSE otherwise
//
// Notes:
//
// There are actually three different current directories:
// - The WIN32 current directory (this is really the one that counts)
// - The DOS current directory, kept on a per drive basis
// - The TASK current directory, kept in the TDB of a win16 task
//
// It is the responsibility of this routine to effectively copy the contents
// of one of these directories into another. From where to where is determined
// by the passed parameter, so it is the caller's responsibility to be sure
// what exactly needs to be sync'd up with what.
//
//*****************************************************************************

BOOL UpdateDosCurrentDirectory(UDCDFUNC fDir)
{
    LONG   lReturn = (LONG)FALSE;

    switch(fDir)  {

        case DIR_DOS_TO_NT: {

            UCHAR szPath[MAX_PATH] = "?:\\";
            PTDB pTDB;

            WOW32ASSERT(DosWowData.lpCurDrv != (ULONG) NULL);

            Dumpdir("UpdateDosCurrentDir DOS->NT", NULL);
            if ((*pCurTDB) && (*pCurDirOwner != *pCurTDB)) {

                pTDB = (PTDB)SEGPTR(*pCurTDB,0);

                if ((TDB_SIGNATURE == pTDB->TDB_sig) &&
                    (pTDB->TDB_Drive & TDB_DIR_VALID)) {

                    szPath[0] = 'A' + (pTDB->TDB_Drive & ~TDB_DIR_VALID);
                    strcpy(&szPath[2], pTDB->TDB_LFNDirectory);

                    LOGDEBUG(CURDIR_LOGLEVEL, ("UpdateDosCurrentDirectory: DOS->NT %s, case 1\n", szPath));
                    if (SetCurrentDirectoryOem(szPath)) {
                       // update cds and the current drive all at the same time
                       DosWowUpdateCDSDir((UCHAR)(pTDB->TDB_Drive & ~TDB_DIR_VALID), szPath);

                       // set the new curdir owner
                       *pCurDirOwner = *pCurTDB;
                    }
                    break;          // EXIT case
                }
            }


            szPath[0] = *(PUCHAR)DosWowData.lpCurDrv + 'A';

            if (CurDirs[*(PUCHAR)DosWowData.lpCurDrv]) {

                strcpy(&szPath[3], CurDirs[*(PUCHAR)DosWowData.lpCurDrv]);
                LOGDEBUG(CURDIR_LOGLEVEL, ("UpdateDosCurrentDirectory: DOS->NT %s, case 2\n", szPath));
                DosWowUpdateTDBDir(*(PUCHAR)DosWowData.lpCurDrv, szPath);

                SetCurrentDirectoryOem(CurDirs[*(PUCHAR)DosWowData.lpCurDrv]);
                lReturn = TRUE;
                break;
            }

            if (DosWowGetCurrentDirectory(0, &szPath[3])) {
                LOGDEBUG(LOG_ERROR, ("DowWowGetCurrentDirectory failed\n"));
            } else {

                // set the current directory owner so that when the
                // task switch occurs -- i21 handler knows to set
                // the current dir
                LOGDEBUG(CURDIR_LOGLEVEL, ("UpdateDosCurrentDirectory: DOS->NT %s, case 3\n", szPath));
                DosWowUpdateTDBDir(*(PUCHAR)DosWowData.lpCurDrv, szPath);

                SetCurrentDirectoryOem(szPath);
                lReturn = TRUE;
            }
            break;
        }

        case DIR_NT_TO_DOS: {

            UCHAR szPath[MAX_PATH];

            if (!GetCurrentDirectoryOem(MAX_PATH, szPath)) {

                LOGDEBUG(LOG_ERROR, ("DowWowSetCurrentDirectory failed\n"));

            } else {

                Dumpdir("UpdateDosCurrentDirectory NT->DOS", szPath);
                LOGDEBUG(LOG_WARNING, ("UpdateDosCurrentDirectory NT->DOS: %s\n", &szPath[0]));
                if (szPath[1] == ':') {
                    DosWowSetDefaultDrive((UCHAR) (toupper(szPath[0]) - 'A'));
                    DosWowSetCurrentDirectory(szPath);
                    lReturn = TRUE;
                }

            }
            break;
        }

    }
    return (BOOL)lReturn;
}

/***************************************************************************

 Stub entry points (called by KRNL386, 286 via thunks)

 ***************************************************************************/


/* WK32SetDefaultDrive - Emulate DOS set default drive call
 *
 * Entry -
 *  BYTE  DriveNum;    = drive number to switch to
 *
 * Exit
 *       returns client AX
 *
 */

ULONG FASTCALL WK32SetDefaultDrive(PVDMFRAME pFrame)
{
    PWOWSETDEFAULTDRIVE16   parg16;
    UCHAR Drive;

    GETARGPTR(pFrame, sizeof(WOWSETDEFAULTDRIVE16), parg16);

    Drive = (UCHAR) parg16->wDriveNum;

    FREEARGPTR(parg16);

    return (DosWowSetDefaultDrive (Drive));

}


/* WK32SetCurrentDirectory - Emulate DOS set current Directory call
 *
 * Entry -
 *    DWORD lpDosData    = pointer to DosWowData structure in DOS
 *    parg16->lpDosDirectory - pointer to real mode DOS pdb variable
 *    parg16->wNewDirectory  - 16-bit pmode selector for new Directory
 *
 * Exit
 *     SUCCESS
 *       0
 *
 *     FAILURE
 *       system status code
 *
 */
ULONG FASTCALL WK32SetCurrentDirectory(PVDMFRAME pFrame)
{

    PWOWSETCURRENTDIRECTORY16   parg16;
    LPSTR pszDir;
    ULONG dwRet;

    GETARGPTR(pFrame, sizeof(WOWSETCURRENTDIRECTORY16), parg16);
    GETVDMPTR(parg16->lpCurDir, 4, pszDir);
    FREEARGPTR(parg16);

    dwRet = DosWowSetCurrentDirectory (pszDir);

    FREEVDMPTR(pszDir);
    return(dwRet);

}


/* WK32GetCurrentDirectory - Emulate DOS Get current Directory call
 *
 *
 * Entry -
 *    DWORD lpDosData    = pointer to DosWowData structure in DOS
 *    parg16->lpCurDir  - pointer to buffer to receive directory
 *    parg16->wDriveNum - Drive number requested
 *                        Upper bit (0x80) is set if the caller wants long path
 *
 * Exit
 *     SUCCESS
 *       0
 *
 *     FAILURE
 *       DOS error code (000f)
 *
 */
ULONG FASTCALL WK32GetCurrentDirectory(PVDMFRAME pFrame)
{
    PWOWGETCURRENTDIRECTORY16   parg16;
    LPSTR pszDir;
    UCHAR Drive;
    ULONG dwRet;

    GETARGPTR(pFrame, sizeof(WOWGETCURRENTDIRECTORY16), parg16);
    GETVDMPTR(parg16->lpCurDir, 4, pszDir);
    Drive = (UCHAR) parg16->wDriveNum;
    FREEARGPTR(parg16);

    if (Drive<0x80) {
        UCHAR ChkDrive;

        //
        // Normal GetCurrentDirectory call.
        // If the path has grown larger than the old MS-DOS path size, then
        // return error, just like on win95.
        //

        if (Drive == 0) {
            ChkDrive = *(PUCHAR)DosWowData.lpCurDrv;
        } else {
            ChkDrive = Drive-1;
        }
        if ((Drive<MAX_DOS_DRIVES) && CurDirs[ChkDrive]) {
            return 0xFFFF000F;
        }

    } else {

        //
        // the caller wants the long path path
        //

        Drive &= 0x7f;
    }

    dwRet = DosWowGetCurrentDirectory (Drive, pszDir);

    FREEVDMPTR(pszDir);
    return(dwRet);

}

/* WK32GetCurrentDate - Emulate DOS Get current Date call
 *
 *
 * Entry -
 *
 * Exit
 *    return value is packed with date information
 *
 */
ULONG FASTCALL WK32GetCurrentDate(PVDMFRAME pFrame)
{
    SYSTEMTIME systemtime;

    UNREFERENCED_PARAMETER(pFrame);

    GetLocalTime(&systemtime);

    return ((DWORD) (systemtime.wYear  << 16 |
                     systemtime.wDay   << 8  |
                     systemtime.wMonth << 4  |
                     systemtime.wDayOfWeek
                     ));

}


#if 0
/* The following routine will probably never be used because we allow
   WOW apps to set a local time within the WOW. So we really want apps
   that read the time with int21 to go down to DOS where this local time
   is kept. But if we ever want to return the win32 time, then this
   routine will do it. */
/* WK32GetCurrentTime - Emulate DOS Get current Time call
 *
 *
 * Entry -
 *
 * Exit
 *    return value is packed with time information
 *
 */
ULONG FASTCALL WK32GetCurrentTime(PVDMFRAME pFrame)
{
    SYSTEMTIME systemtime;

    UNREFERENCED_PARAMETER(pFrame);

    GetLocalTime(&systemtime);

    return ((DWORD) (systemtime.wHour   << 24 |
                     systemtime.wMinute << 16 |
                     systemtime.wSecond << 8  |
                     systemtime.wMilliseconds/10
                     ));

}
#endif

/* WK32DeviceIOCTL - Emulate misc. DOS IOCTLs
 *
 * Entry -
 *  BYTE  DriveNum;    = drive number
 *
 * Exit
 *       returns client AX
 *
 */

ULONG FASTCALL WK32DeviceIOCTL(PVDMFRAME pFrame)
{
    PWOWDEVICEIOCTL16   parg16;
    UCHAR Drive;
    UCHAR Cmd;
    DWORD dwReturn = 0xFFFF0001;        // error invalid function
    UINT uiDriveStatus;
    static CHAR  pPath[]="?:\\";

    GETARGPTR(pFrame, sizeof(WOWDEVICEIOCTL16), parg16);

    Cmd = (UCHAR) parg16->wCmd;
    Drive = (UCHAR) parg16->wDriveNum;

    FREEARGPTR(parg16);

    if (Cmd != 8) {                     // Does Device Use Removeable Media
        return (dwReturn);
    }

    if (Drive == 0) {
        Drive = *(PUCHAR)DosWowData.lpCurDrv;
    } else {
        Drive--;
    }

    pPath[0] = Drive + 'A';
    uiDriveStatus = GetDriveType(pPath);

    if ((uiDriveStatus == 0) || (uiDriveStatus == 1)) {
        return (0xFFFF000F);            // error invalid drive
    }

    if (uiDriveStatus == DRIVE_REMOVABLE) {
        dwReturn = 0;
    } else {
        dwReturn = 1;
    }

    return (dwReturn);

}


BOOL DosWowDoDirectHDPopup(VOID)
{
   BOOL fNoPopupFlag;

   fNoPopupFlag = !!(CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_NODIRECTHDPOPUP);
   LOGDEBUG(0, ("direct hd access popup flag: %s\n", fNoPopupFlag ? "TRUE" : "FALSE"));
   return(!fNoPopupFlag);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgdi.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGDI.C
 *  WOW32 16-bit GDI API support
 *
 *  History:
 *  07-Mar-1991 Jeff Parsons (jeffpar)
 *  Created.
 *
 *  09-Apr-1991 NigelT
 *  Various defines are used here to remove calls to Win32
 *  features which don't work yet.
 *
 *  06-June-1992 Chandan Chauhan (ChandanC)
 *  Fixed BITMAP and DeviceIndependentBitmap (DIB) issues
 *
 *  22-May-1995  Craig Jones (a-craigj)
 *  METAFILE NOTE: several 32-bit API's will return TRUE when GDI is in
 *                 "metafile" mode -- however, the POINT struct does not get
 *                 updated by GDI32 even if the API returns successfully so
 *                 we just return TRUE or FALSE as the point coors like W3.1.
 *
--*/


#include "precomp.h"
#pragma hdrstop
#include "wowgdip.h"
#include "wdib.h"

#include "stddef.h"    // these three are needed to include the
#include "wingdip.h"
                       // definition of EXTTEXTMETRICS in wingdip.h
                       // [bodind]
MODNAME(wgdi.c);



#define SETGDIXFORM 4113
#define RESETPAGE   4114


// This must be removed from POSTBETA for sure. ChandanC 3/22/94.

#define IGNORESTARTPGAE  0x7FFFFFFF
#define ADD_MSTT         0x7FFFFFFD
	
#ifdef FE_SB
// WOWCF_FE_FLW2_PRINTING_PS, Japanese Lotus Freelance printing with PostScript.
// Between Escape( BEGIN_PATH ) and Escape( END_PATH ), select brush object
// with WHITE_BRUSH
BOOL fCmptFLW = FALSE;
#endif // FE_SB

LPDEVMODE GetDefaultDevMode32(LPSTR pszDriver); // Implemented in wspool.c

// Hack for apps which try to be their own printer driver & send form feeds to
// the printer in Escape(PassThrough) calls.  This mechanism prevents an
// additional page being spit out of the printer when the app calls EndDoc()
// because GDI32 EndDoc() does an implicit form feed.
typedef struct _FormFeedHack {
    struct _FormFeedHack UNALIGNED *next;
    HAND16                hTask16;
    HDC                   hdc;
    LPBYTE                lpBytes;
    int                   cbBytes;
} FORMFEEDHACK;
typedef FORMFEEDHACK UNALIGNED *PFORMFEEDHACK;

PFORMFEEDHACK gpFormFeedHackList = NULL;  // start of global formfeed Hack list

LONG          HandleFormFeedHack(HDC hdc, LPBYTE lpdata, int cb);
LPBYTE        SendFrontEndOfDataStream(HDC hdc, LPBYTE lpData, int *cb, LONG *ul);
void          FreeFormFeedHackNode(PFORMFEEDHACK pNode);
void          FreeTaskFormFeedHacks(HAND16 hTask16);
void          SendFormFeedHack(HDC hdc);
PFORMFEEDHACK FindFormFeedHackNode(HDC hdc);
PFORMFEEDHACK CreateFormFeedHackNode(HDC hdc, int cb, LPBYTE lpData);
void          RemoveFormFeedHack(HDC hdc);



ULONG FASTCALL WG32CreateBitmap(PVDMFRAME pFrame)
{
    ULONG ul;
    register PCREATEBITMAP16 parg16;
    LPBYTE  lpBitsOriginal;

    GETARGPTR(pFrame, sizeof(CREATEBITMAP16), parg16);
    GETOPTPTR(parg16->f5, 0, lpBitsOriginal);

    ul = GETHBITMAP16(CreateBitmap(INT32(parg16->f1),
                                   INT32(parg16->f2),
                                   LOBYTE(parg16->f3),
                                   LOBYTE(parg16->f4),
                                   lpBitsOriginal));

    WOW32APIWARN(ul, "CreateBitmap");

    FREEOPTPTR(lpBitsOriginal);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32CreateBitmapIndirect(PVDMFRAME pFrame)
{
    ULONG ul;
    register PCREATEBITMAPINDIRECT16 parg16;

    PBITMAP16 pbm16;
    BITMAP  bm;
    LPBYTE  lp = NULL;

    GETARGPTR(pFrame, sizeof(CREATEBITMAPINDIRECT16), parg16);

    GETVDMPTR(parg16->f1, sizeof(BITMAP16), pbm16);
    GETOPTPTR(pbm16->bmBits, 0, lp);

    bm.bmType = (LONG) FETCHSHORT(pbm16->bmType);
    bm.bmWidth = (LONG) FETCHSHORT(pbm16->bmWidth);
    bm.bmHeight = (LONG) FETCHSHORT(pbm16->bmHeight);
    bm.bmWidthBytes = (LONG) FETCHSHORT(pbm16->bmWidthBytes);
    bm.bmPlanes = (WORD) pbm16->bmPlanes;
    bm.bmBitsPixel = (WORD) pbm16->bmBitsPixel;
    bm.bmBits = lp;

    ul = GETHBITMAP16(CreateBitmapIndirect(&bm));

    WOW32APIWARN(ul, "CreateBitmapIndirect");

    FREEOPTPTR(lp);
    FREEARGPTR(parg16);
    RETURN(ul);
}



ULONG FASTCALL WG32CreateBrushIndirect(PVDMFRAME pFrame)
{
    ULONG ul;
    LOGBRUSH t1;
    HAND16 hMem16;
    HANDLE hMem32 = NULL;
    LPBYTE lpMem16, lpMem32;
    INT cb;
    VPVOID vp;
    register PCREATEBRUSHINDIRECT16 parg16;

    GETARGPTR(pFrame, sizeof(CREATEBRUSHINDIRECT16), parg16);
    GETLOGBRUSH16(parg16->f1, &t1);

    // some apps don't properly set the style. Make sure it is a valid w3.1 style

    if (t1.lbStyle > BS_DIBPATTERN)
        t1.lbStyle = BS_SOLID;

    if (t1.lbStyle == BS_PATTERN) {
        t1.lbStyle = BS_PATTERN8X8;
    }
    else if (t1.lbStyle == BS_DIBPATTERN) {
        hMem16 = (WORD) t1.lbHatch;
        if (hMem16) {
            vp = RealLockResource16(hMem16, &cb);
            if (vp) {
                GETMISCPTR(vp, lpMem16);
                hMem32 = WOWGLOBALALLOC(GMEM_MOVEABLE, cb);
                WOW32ASSERT(hMem32);
                if (hMem32) {
                    lpMem32 = GlobalLock(hMem32);
                    RtlCopyMemory(lpMem32, lpMem16, cb);
                    GlobalUnlock(hMem32);
                }
                GlobalUnlock16(hMem16);
                FREEMISCPTR(lpMem16);
            }
        }
        t1.lbHatch = (LONG)hMem32;
    }
    else if (t1.lbStyle == BS_SOLID)
    {
        t1.lbColor = COLOR32(t1.lbColor);
    }

    ul = GETHBRUSH16(CreateBrushIndirect(&t1));

    if (hMem32)
    {
        WOWGLOBALFREE(hMem32);
    }

    WOW32APIWARN(ul, "CreateBrushIndirect");

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32CreateCompatibleDC(PVDMFRAME pFrame)
{
    ULONG ul;
    HDC   hdc;
    register PCREATECOMPATIBLEDC16 parg16;

    GETARGPTR(pFrame, sizeof(CREATECOMPATIBLEDC16), parg16);

    if ( parg16->f1 ) {
        hdc = HDC32(parg16->f1);
        if ( hdc == NULL ) {
            FREEARGPTR(parg16);
            return(0);
        }
    } else {
        hdc = NULL;
    }
    ul = GETHDC16(CreateCompatibleDC(hdc));
//
// Some apps such as MSWORKS and MS PUBLISHER use some wizard code that accepts
// a hDC or a hWnd as a parameter and attempt to figure out what type of handle
// it is by using the IsWindow() call. Since both handles come from different
// handle spaces they may end up the same value and this wizard code will end
// up writing to the DC for a random window. By ORing in a 1 we ensure that the
// handle types will never share the same value since all hWnds are even. Note
// that this hack is also made in WU32GetDC().
//
// Note that there are some apps that use the lower 2 bits of the hDC for their
// own purposes.
    if (ul && CURRENTPTD()->dwWOWCompatFlags & WOWCF_UNIQUEHDCHWND) {
        ul = ul | 1;
    }

    WOW32APIWARN(ul, "CreateCompatibleDC");

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32CreateDC(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    PSZ psz1 = NULL;
    PSZ psz2 = NULL;
    PSZ psz3 = NULL;
    PSZ pszDib;
    LPDEVMODE t4 = NULL;
    register PCREATEDC16 parg16;

    GETARGPTR(pFrame, sizeof(CREATEDC16), parg16);

    if(parg16->f1) {
        if(!(psz1 = malloc_w_strcpy_vp16to32(parg16->f1, FALSE, 0)))
            goto ExitPath;
    }
    if(parg16->f2) {
        if(!(psz2 = malloc_w_strcpy_vp16to32(parg16->f2, FALSE, 0)))
            goto ExitPath;
    }
    if(parg16->f3) {
        if(!(psz3 = malloc_w_strcpy_vp16to32(parg16->f3, FALSE, 0)))
            goto ExitPath;
    }

    // Note: parg16->f4 will usually be a lpDevMode, but it is documented
    //       that it can also be a lpBitMapInfo if the driver name is "dib.drv"

    // test for "dib.drv".  Director 4.0 uses "dirdib.drv"
    if (psz1 && ((pszDib = WOW32_strstr (psz1, "DIB")) ||
                (pszDib = WOW32_strstr (psz1, "dib")))) {
        if (WOW32_stricmp (pszDib, "DIB") == 0 ||
            WOW32_stricmp (pszDib, "DIB.DRV") == 0) {
          ul = GETHDC16(W32HandleDibDrv ((PVPVOID)parg16->f4));
          // Note: flat 16:16 ptrs should be considered invalid after this call
        }
    }

    // handle normal non-dib.drv case
    else {
        if (FETCHDWORD(parg16->f4) == 0L) {
            t4 = GetDefaultDevMode32(psz2);
        }
        else {
            t4 = ThunkDevMode16to32(parg16->f4);
        }

        // this can callback into a 16-bit fax driver!
        ul = GETHDC16(CreateDC(psz1, psz2, psz3, t4));

        // Note: flat 16:16 ptrs should be considered invalid after this call
        FREEARGPTR(parg16);
    }

ExitPath:
    if(psz1)
        free_w(psz1);
    if(psz2)
        free_w(psz2);
    if(psz3)
        free_w(psz3);

    WOW32APIWARN(ul, "CreateDC");

    FREEDEVMODE32(t4);
    FREEARGPTR(parg16);

    RETURN(ul);
}


ULONG FASTCALL WG32CreateDIBPatternBrush(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    LPBYTE lpb16;
    LOGBRUSH logbr;
    register PCREATEDIBPATTERNBRUSH16 parg16;

    GETARGPTR(pFrame, sizeof(CREATEDIBPATTERNBRUSH16), parg16);
    GETMISCPTR(parg16->f1, lpb16);
    logbr.lbStyle = BS_DIBPATTERN8X8;
    logbr.lbColor = WORD32(parg16->f2);
    logbr.lbHatch = (LONG) lpb16;

    ul = GETHBRUSH16(CreateBrushIndirect(&logbr));
    WOW32APIWARN(ul, "CreateDIBPatternBrush");

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32CreateDIBitmap(PVDMFRAME pFrame)
{
    ULONG              ul=0;
    LPBYTE             lpib4;
    BITMAPINFOHEADER   bmxh2;
    STACKBMI32         bmi32;
    LPBITMAPINFOHEADER lpbmih32;
    LPBITMAPINFO       lpbmi32;


    register PCREATEDIBITMAP16 parg16;

    GETARGPTR(pFrame, sizeof(CREATEDIBITMAP16), parg16);
    GETMISCPTR(parg16->f4, lpib4);

    lpbmih32 = CopyBMIH16ToBMIH32((PVPVOID) FETCHDWORD(parg16->f2), &bmxh2);
    if (lpbmih32) {

        lpbmi32 = CopyBMI16ToBMI32((PVPVOID)FETCHDWORD(parg16->f5),
                                   (LPBITMAPINFO)&bmi32,
                                   FETCHWORD(parg16->f6));

        // see if we need to adjust the image sze for RLE bitmaps
        if(lpbmi32 && lpib4 && (DWORD32(parg16->f3) == CBM_INIT)) {

            if((lpbmi32->bmiHeader.biCompression == BI_RLE4) ||
               (lpbmi32->bmiHeader.biCompression == BI_RLE8)) {

                if(lpbmi32->bmiHeader.biSizeImage == 0) {

                    lpbmi32->bmiHeader.biSizeImage =
                         Get_RLE_Compression_Size(lpbmi32->bmiHeader.biCompression,
                                                  lpib4,
                                                  parg16->f4);
                }
            }
        }

        ul = GETHBITMAP16(CreateDIBitmap(HDC32(parg16->f1),
                                    lpbmih32,
                                    DWORD32(parg16->f3),
                                    lpib4,
                                    lpbmi32,
                                    WORD32(parg16->f6) ));
    }


    WOW32APIWARN(ul, "CreateDIBitmap");

    FREEMISCPTR(lpib4);
    FREEARGPTR(parg16);

    return(ul);
}

ULONG FASTCALL WG32CreateEllipticRgnIndirect(PVDMFRAME pFrame)
{
    ULONG ul;
    RECT t1;
    register PCREATEELLIPTICRGNINDIRECT16 parg16;

    GETARGPTR(pFrame, sizeof(CREATEELLIPTICRGNINDIRECT16), parg16);
    WOW32VERIFY(GETRECT16(parg16->f1, &t1));

    ul = GETHRGN16(CreateEllipticRgnIndirect(&t1));

    WOW32APIWARN(ul, "CreateEllipticRgnIndirect");

    FREEARGPTR(parg16);
    RETURN(ul);
}

ULONG FASTCALL WG32CreateIC(PVDMFRAME pFrame)
{
    ULONG ul  = 0;
    PSZ psz1  = NULL;
    PSZ psz2  = NULL;
    PSZ psz2t = NULL;
    PSZ psz3  = NULL;
    LPDEVMODE t4 = NULL;
    register PCREATEIC16 parg16;
    INT   len;
    PCHAR pch;
    CHAR  achDevice[256];
    DWORD dw;

    GETARGPTR(pFrame, sizeof(CREATEIC16), parg16);

    if(parg16->f1) {
        if(!(psz1 = malloc_w_strcpy_vp16to32(parg16->f1, FALSE, 0)))
            goto ExitPath;
    }
    if(parg16->f2) {
        if(!(psz2 = malloc_w_strcpy_vp16to32(parg16->f2, FALSE, 0)))
            goto ExitPath;
    }
    if(parg16->f3) {
        if(!(psz3 = malloc_w_strcpy_vp16to32(parg16->f3, FALSE, 0)))
            goto ExitPath;
    }

    if (FETCHDWORD(parg16->f4) != 0L) {
        t4 = ThunkDevMode16to32(parg16->f4);
    }
    else {
        t4 = GetDefaultDevMode32(psz2);
    }

    // invalidate all flat ptrs to 16:16 memory now!
    FREEARGPTR(parg16);

    psz2t = psz2;

    //
    // HACK Alert!
    //
    // NBI's Legacy comes with a pscript.drv that resides in   [AppPath]\cbt
    // they call CreateIC() specifying the the path to this file as the driver.
    // the app GP faults if the CreateIC returns 0.  once they've loaded this
    // printer driver, on successive calls to CreateIC() they simply use
    // "PSCRIPT" as the driver name and use "PostScript Printer", "FILE:" as
    // the other parms.
    // let's recognize these driver names and try to replace it with the
    // system default printer.   if there's no printer installed, a GP fault
    // is unavoidable.  the app appears to use this pscript.drv only during
    // the tutorial, so we're not providing life-support for an app that's
    // clinically dead.
    //

    //
    // check for a driver name that ends with "PSCRIPT" and if so,
    // check that the device name is "PostScript Printer".
    // on NT the driver name should always be "winspool", although it's
    // completely ignored.
    //
    // PageMaker 5.0a calls this with ("pscript","Postscript printer","LPT1:",0)
    // when opening calibrat.pt5

    len = psz1 ? strlen(psz1) : 0;
    if (len >= 7) {
#if 0
        static CHAR achPS[] = "PostScript Printer";
#endif

        if (!WOW32_stricmp(psz1+len-7, "pscript")
#if 0
            // let's see who else thinks they're using a pscript driver
            //
            && (RtlCompareMemory(achPS, psz2, sizeof(achPS)) == sizeof(achPS))
#endif
           ) {

            LOGDEBUG(LOG_ALWAYS,("WOW32: CreateIC - detected request for Pscript driver\n"));
            dw = GetProfileString("windows", "device", "", achDevice,
                        sizeof(achDevice));
            if (dw) {
                psz2t = achDevice;
                pch = WOW32_strchr(achDevice, ',');
                if (pch) {
                    *pch = '\0';
                }
            }
        }
    }

    // this can callback into a 16-bit fax driver!
    ul = GETHDC16(CreateIC(psz1, psz2t, psz3, t4));

    // Note: flat 16:16 ptrs should be considered invalid after this call
    FREEARGPTR(parg16);

ExitPath:
    if(psz1)
        free_w(psz1);
    if(psz2)
        free_w(psz2);
    if(psz3)
        free_w(psz3);

    WOW32APIWARN(ul, "CreateIC");

    FREEDEVMODE32(t4);

    RETURN(ul);
}

ULONG FASTCALL WG32CreatePatternBrush(PVDMFRAME pFrame)
{
    ULONG ul;
    LOGBRUSH logbr;
    register PCREATEPATTERNBRUSH16 parg16;

    GETARGPTR(pFrame, sizeof(CREATEPATTERNBRUSH16), parg16);

    logbr.lbStyle = BS_PATTERN8X8;
    logbr.lbColor = 0;
    logbr.lbHatch = (LONG)HBITMAP32(parg16->f1);

    ul = GETHBRUSH16(CreateBrushIndirect(&logbr));

    WOW32APIWARN(ul, "CreatePatternBrush");

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32CreatePenIndirect(PVDMFRAME pFrame)
{
    ULONG ul;
    LOGPEN t1;
    register PCREATEPENINDIRECT16 parg16;

    GETARGPTR(pFrame, sizeof(CREATEPENINDIRECT16), parg16);
    GETLOGPEN16(parg16->f1, &t1);

    ul = GETHPEN16(CreatePenIndirect(&t1));

    WOW32APIWARN(ul, "CreatePenIndirect");

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32CreatePolyPolygonRgn(PVDMFRAME pFrame)
{
    ULONG ul;
    LPPOINT pPoints;
    PINT pPolyCnt;
    UINT cpts = 0;
    INT ii;
    register PCREATEPOLYPOLYGONRGN16 parg16;
    INT      cInt16;
    INT      BufferT[256]; // comfortably large array

    GETARGPTR(pFrame, sizeof(CREATEPOLYPOLYGONRGN16), parg16);
    cInt16 = INT32(parg16->f3);
    pPolyCnt = STACKORHEAPALLOC(cInt16 * sizeof(INT), sizeof(BufferT), BufferT);
    if (!pPolyCnt) {
        FREEARGPTR(parg16);
        RETURN(0);
    }

    getintarray16(parg16->f2, cInt16, pPolyCnt);
    for (ii=0; ii < cInt16; ii++)
        cpts += pPolyCnt[ii];

    pPoints = STACKORHEAPALLOC(cpts * sizeof(POINT),
                                     sizeof(BufferT) - cInt16 * sizeof(INT),
                                     BufferT + cInt16);
    getpoint16(parg16->f1, cpts, pPoints);

    ul = GETHRGN16(CreatePolyPolygonRgn(pPoints,
                                        pPolyCnt,
                                        INT32(parg16->f3),
                                        INT32(parg16->f4)));

    WOW32APIWARN(ul, "CreatePolyPolygonRgn");

    STACKORHEAPFREE(pPoints, BufferT + cInt16);
    STACKORHEAPFREE(pPolyCnt, BufferT);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32CreatePolygonRgn(PVDMFRAME pFrame)
{
    ULONG ul;
    LPPOINT t1;
    register PCREATEPOLYGONRGN16 parg16;
    POINT  BufferT[128];

    GETARGPTR(pFrame, sizeof(CREATEPOLYGONRGN16), parg16);
    t1 = STACKORHEAPALLOC(parg16->f2 * sizeof(POINT), sizeof(BufferT), BufferT);
    getpoint16(parg16->f1, parg16->f2, t1);

    ul = GETHRGN16(CreatePolygonRgn(t1, INT32(parg16->f2), INT32(parg16->f3)));

    WOW32APIWARN(ul, "CreatePolygonRgn");

    STACKORHEAPFREE(t1, BufferT);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32CreateRectRgnIndirect(PVDMFRAME pFrame)
{
    ULONG ul;
    RECT t1;
    register PCREATERECTRGNINDIRECT16 parg16;

    GETARGPTR(pFrame, sizeof(CREATERECTRGNINDIRECT16), parg16);
    WOW32VERIFY(GETRECT16(parg16->f1, &t1));

    ul = GETHRGN16(CreateRectRgnIndirect(&t1));

    WOW32APIWARN(ul, "CreateRectRgnIndirect");

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32DPtoLP(PVDMFRAME pFrame)
{
    ULONG ul=0;
    LPPOINT t2;
    register PDPTOLP16 parg16;
    POINT  BufferT[128];

    GETARGPTR(pFrame, sizeof(DPTOLP16), parg16);
    t2 = STACKORHEAPALLOC(parg16->f3 * sizeof(POINT), sizeof(BufferT), BufferT);

    if (t2) {
        getpoint16(parg16->f2, parg16->f3, t2);

        ul = GETBOOL16(DPtoLP(HDC32(parg16->f1), t2, INT32(parg16->f3)));

        PUTPOINTARRAY16(parg16->f2, parg16->f3, t2);
        STACKORHEAPFREE(t2, BufferT);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32DeleteDC(PVDMFRAME pFrame)
{
    ULONG ul;
    register PDELETEDC16 parg16;

    GETARGPTR(pFrame, sizeof(DELETEDC16), parg16);

    if ((ul = W32CheckAndFreeDibInfo (HDC32(parg16->f1))) == FALSE) {
        ul = GETBOOL16(DeleteDC(HDC32(parg16->f1)));
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32DeleteObject(PVDMFRAME pFrame)
{
    ULONG ul;
    register PDELETEOBJECT16 parg16;
    HGDIOBJ hGdiObj;

    GETARGPTR(pFrame, sizeof(DELETEOBJECT16), parg16);

    if ((pDibSectionInfoHead == NULL) ||
        (ul = W32CheckAndFreeDibSectionInfo (HBITMAP32(parg16->f1))) == FALSE) {

        hGdiObj = HOBJ32(parg16->f1);

        ul = GETBOOL16(DeleteObject(hGdiObj));

        if (!ul) {
            //
            // Most apps probably don't care what the return value from
            // DeleteObject is, but in any case, in this regard, NT has
            // different logic from win31/win95. For example, it appears
            // that win95 always returns TRUE when a palette object is
            // passed to DeleteObject, even if the palette was not deleted
            // (because it was already selected).
            //
            // Here we try to decide if we should change the return value
            // from FALSE to TRUE.
            //
            // ChessMaster 3000 tries to delete a Palette object that
            // is still selected. If it fails, then it puts up a popup.
            //

            switch(GetObjectType(hGdiObj)) {
                case OBJ_PAL:
                case OBJ_PEN:
                case OBJ_BRUSH:
                    ul = TRUE;
                    break;
            }
        }
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


// WARNING: This function may cause 16-bit memory movement
INT W32EnumObjFunc(LPSTR lpLogObject, PENUMOBJDATA pEnumObjData)
{
    PARM16  Parm16;
    INT iReturn;

    WOW32ASSERT(pEnumObjData);

    switch (pEnumObjData->ObjType) {
      case OBJ_BRUSH:
          PUTLOGBRUSH16(pEnumObjData->vpObjData, sizeof(LOGBRUSH), (LPLOGBRUSH)lpLogObject);
          break;
      case OBJ_PEN:
          PUTLOGPEN16(pEnumObjData->vpObjData, sizeof(LOGPEN), (LPLOGPEN)lpLogObject);
          break;
      default:
           LOGDEBUG(LOG_ALWAYS,("WOW32 ERROR -- Illegal type %d passes to EnumObj\n",pEnumObjData->ObjType));
           return 0;
    } // end switch

    STOREDWORD(Parm16.EnumObjProc.vpLogObject, pEnumObjData->vpObjData);
    STOREDWORD(Parm16.EnumObjProc.vpData, pEnumObjData->dwUserParam);
    CallBack16(RET_ENUMOBJPROC, &Parm16, pEnumObjData->vpfnEnumObjProc, (PVPVOID)&iReturn);

    return (SHORT)iReturn;


}


ULONG FASTCALL WG32EnumObjects(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PENUMOBJECTS16 parg16;
    ENUMOBJDATA EnumObjData;

    GETARGPTR(pFrame, sizeof(ENUMOBJECTS16), parg16);

    EnumObjData.ObjType = INT32(parg16->f2);

    switch(EnumObjData.ObjType) {
        case OBJ_BRUSH:
            EnumObjData.vpObjData = malloc16(sizeof(LOGBRUSH16));
            break;
        case OBJ_PEN:
            EnumObjData.vpObjData = malloc16(sizeof(LOGPEN16));
            break;
        default:
            LOGDEBUG(LOG_ALWAYS,("WOW32 ERROR -- Illegal type %d passes to EnumObj\n",EnumObjData.ObjType));
            EnumObjData.vpObjData = (VPVOID)0;
    }
    // malloc16 may have caused 16-bit memory movement - invalidate flat ptrs
    FREEVDMPTR(pFrame);
    FREEARGPTR(parg16);
    GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
    GETARGPTR(pFrame, sizeof(ENUMOBJECTS16), parg16);

    if( EnumObjData.vpObjData ) {
        EnumObjData.vpfnEnumObjProc = DWORD32(parg16->f3);
        EnumObjData.dwUserParam     = DWORD32(parg16->f4);

        ul = (ULONG)(GETINT16(EnumObjects(HDC32(parg16->f1),
                                          (int)INT32(parg16->f2),
                                          (GOBJENUMPROC)W32EnumObjFunc,
                                          (LPARAM)&EnumObjData)));
	// 16-bit memory may have moved - invalidate flat pointers
	FREEARGPTR(parg16);
	FREEVDMPTR(pFrame);
        free16(EnumObjData.vpObjData);

    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


/**************************************************************************\
*
\**************************************************************************/

typedef struct _ESCKERNPAIR {
    union
    {
        BYTE each[2];
        WORD both;
    } kpPair;
    SHORT KernAmount;
} ESCKERNPAIR;

/******************************Public*Routine******************************\
* iGetKerningPairsEsc32
*
* History:
*  Tue 16-Mar-1993 11:08:36 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

int
iGetKerningPairsEsc32(
    HDC hdc,
    ESCKERNPAIR *pekp
    )
{
    int i,j;
    int n;

    ESCKERNPAIR *pekpT, *pekpTOut;
    KERNINGPAIR *pkpT;

    KERNINGPAIR *pkp = (KERNINGPAIR*) NULL;

    if
    (
        (n = GetKerningPairs(hdc,0,NULL))                               &&
        (pkp = malloc_w((n * sizeof(KERNINGPAIR))))                     &&
        (n = (int) GetKerningPairs(hdc, n, pkp))
    )
    {
        n = min(n,512);

    //
    // load the low byte of each word, Win 3.1 doesn't seem to care about
    // the high byte
    //
        pekpT    = pekp;
        pekpTOut = pekp + n;
        pkpT     = pkp;

        while (pekpT < pekpTOut)
        {
            pekpT->kpPair.each[0] = (BYTE) pkpT->wFirst;
            pekpT->kpPair.each[1] = (BYTE) pkpT->wSecond;
            pekpT->KernAmount     = (SHORT) pkpT->iKernAmount;

            pekpT += 1;
            pkpT  += 1;
        }

    //
    // bubble sort word formed by byte pair
    //
        for (i = 0; i < n - 1; i++)
        {
            for (j = n-1; j > i; --j)
            {
                if (pekp[j-1].kpPair.both > pekp[j].kpPair.both)
                {
                    ESCKERNPAIR ekp;

                    ekp = pekp[j];
                    pekp[j] = pekp[j-1];
                    pekp[j] = ekp;
                }
            }
        }
    }

    if (pkp)
    {
        free_w(pkp);
    }

    return(n);
}

ULONG FASTCALL WG32Escape(PVDMFRAME pFrame)
{
    ULONG   ul=0;
    register PESCAPE16 parg16;
    PVOID   pin = NULL;
    int     iMapMode;
    CHAR    buf[32];

    GETARGPTR(pFrame, sizeof(ESCAPE16), parg16);
    GETOPTPTR(parg16->f4, 0, pin);


    switch (INT32(parg16->f2)) {
        case GETPHYSPAGESIZE:
        case GETPRINTINGOFFSET:
        case GETSCALINGFACTOR:
            {   POINT  pt;
                ul = GETINT16(Escape(HDC32(parg16->f1),
                                    INT32(parg16->f2),
                                    INT32(parg16->f3),
                                    pin,
                                    (LPSTR)&pt));

                if (!ul)
                {
                // if these fail, they are almost certainly doing it on a display dc.
                // We will fill the return value in with reasonable values for those
                // apps (micrographx draw) that ignore our return values.
                // we still return failure.

                    switch (INT32(parg16->f2))
                    {
                        case GETPHYSPAGESIZE:
                            pt.x = GetDeviceCaps(HDC32(parg16->f1),HORZRES);
                            pt.y = GetDeviceCaps(HDC32(parg16->f1),VERTRES);
                            break;

                        case GETPRINTINGOFFSET:
                            pt.x = 0;
                            pt.y = 0;
                            break;

                        default:
                            break;
                    }
                }

                PUTPOINT16(parg16->f5, &pt);
            }
            break;

        case GETCOLORTABLE:
            {
                PDWORD pdw;
                DWORD dw;
                INT i;

                if (pin) {
                    i = (INT) FETCHSHORT(*(PSHORT)pin);
                } else {
                    ul = (ULONG)-1;
                    break;
                }

                ul = GETINT16(Escape(HDC32(parg16->f1),
                                    INT32(parg16->f2),
                                    sizeof(INT),
                                    (LPCSTR)&i,
                                    &dw));

                GETVDMPTR(parg16->f5, sizeof(DWORD), pdw);
                STOREDWORD ((*pdw), dw);
                FREEVDMPTR(pdw);
            }
            break;

        case NEXTBAND:
            {   RECT   rt;

                ul = GETINT16(Escape(HDC32(parg16->f1),
                                    INT32(parg16->f2),
                                    INT32(parg16->f3),
                                    pin,
                                    (LPSTR)&rt));

                PUTRECT16(parg16->f5, &rt);
            }
            break;

        case QUERYESCSUPPORT:
            {
            INT i;

            i = (INT) FETCHWORD((*(PWORD)pin));

            switch (i) {

                // For Escapes return FALSE for MGX Draw and TRUE for all other apps.
                // ChandanC, 27/5/93.
                //
                case OPENCHANNEL:               // 4110
                case DOWNLOADHEADER:            // 4111
                case CLOSECHANNEL:              // 4112
                case SETGDIXFORM:               // 4113
                case RESETPAGE:                 // 4114
                    if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_MGX_ESCAPES) {
                        ul = 0;
                    }
                    else {
                        ul = 1;
                    }
                    break;


                case POSTSCRIPT_PASSTHROUGH:    // 4115
                    if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_MGX_ESCAPES) {
                        ul = 0;
                    }
                    else {
                        LOGDEBUG(3,("Querying support for escape %x\n",i));
                        ul = GETINT16(Escape(HDC32(parg16->f1),
                                            INT32(parg16->f2),
                                            sizeof(int),
                                            (PVOID)&i,
                                            NULL));
                    }
                    break;


                case ENCAPSULATED_POSTSCRIPT:   // 4116
                    if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_MGX_ESCAPES) {
                        ul = 0;
                    }
                    else {
                        LOGDEBUG(3,("Querying support for escape %x\n",i));
                        ul = GETINT16(DrawEscape (HDC32(parg16->f1),
                                    INT32(parg16->f2),
                                    sizeof(int),
                                    (PVOID)&i));
                    }
                    break;

                case GETEXTENDEDTEXTMETRICS:
                case GETPAIRKERNTABLE:
                case FLUSHOUTPUT:
                    ul = 1;
                    break;


                case SETCOPYCOUNT:
                case GETCOLORTABLE:
                case GETPHYSPAGESIZE:
                case GETPRINTINGOFFSET:
                case GETSCALINGFACTOR:
                case NEXTBAND:
                case SETABORTPROC:
                case BEGIN_PATH:
                case END_PATH:
                case CLIP_TO_PATH:
                    LOGDEBUG(3,("Querying support for escape %x\n",i));
                    ul = GETINT16(Escape(HDC32(parg16->f1),
                                    INT32(parg16->f2),
                                    sizeof(int),
                                    (PVOID)&i,
                                    NULL));
                    break;



                case POSTSCRIPT_DATA:
                case POSTSCRIPT_IGNORE:
                    if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_MGX_ESCAPES) {
                        ul = 0;
                    }
                    else {
                        LOGDEBUG(3,("Querying support for escape %x\n",i));
                        ul = GETINT16(Escape(HDC32(parg16->f1),
                                            INT32(parg16->f2),
                                            sizeof(int),
                                            (PVOID)&i,
                                            NULL));
                    }
                    break;

                case GETTECHNOLOGY:
                case PASSTHROUGH:
                case DOWNLOADFACE:
                case GETFACENAME:
                case GETDEVICEUNITS:
                case EPSPRINTING:
                    LOGDEBUG(3,("Querying support for escape %x\n",i));
                    ul = GETINT16(ExtEscape(HDC32(parg16->f1),
                                            INT32(parg16->f2),
                                            sizeof(int),
                                            (PVOID)&i,
                                            0,
                                            NULL));
                    break;

                case DRAWPATTERNRECT:
                    LOGDEBUG(3,("Querying support for escape %x\n",i));

                    // some apps just don't do DRAWPATTERNRECT correctly (Excel
                    // 6.0c, Word 6.0c Access 2.0 #122856). Others can't handle
                    // the new 32bit DRAWPATTERNRECT struct (AmiPro 3.1
                    // #107210).  We just tell them that it isn't supported and
                    // force them to figure out the effect on their own.
                    if(CURRENTPTD()->dwWOWCompatFlagsEx &
                                                WOWCFEX_SAYNO2DRAWPATTERNRECT) {
                        ul = 0;
                        break;
                    }
                    else {
                        ul = GETINT16(ExtEscape(HDC32(parg16->f1),
                                                INT32(parg16->f2),
                                                sizeof(int),
                                                (PVOID)&i,
                                                0,
                                                NULL));
                        break;
                    }

                default:
                    LOGDEBUG(3,("Querying support for escape %x\n",i));
                    ul = GETINT16(Escape(HDC32(parg16->f1),
                                    INT32(parg16->f2),
                                    sizeof(int),
                                    (PVOID)&i,
                                    NULL));
                    break;
                }

            }
            break;


        case SETABORTPROC:
            ((PTDB)SEGPTR(pFrame->wTDB, 0))->TDB_vpfnAbortProc =
                                                       FETCHDWORD(parg16->f4);

            ul = GETINT16(Escape(HDC32(parg16->f1),
                                INT32(parg16->f2),
                                0,
                                (LPCSTR)W32AbortProc,
                                NULL));

            break;


        case GETDEVICEUNITS:
            {
            PVOID pout;
            LONG out[4];

            ul = GETINT16(Escape(HDC32(parg16->f1),
                                 INT32(parg16->f2),
                                 0,
                                 NULL,
                                 (LPSTR)out));

            if (ul == 1) {
                GETOPTPTR(parg16->f5, 0, pout);
                RtlCopyMemory(pout, out, sizeof(out));
                FREEOPTPTR(pout);
            }

            }
            break;


        case GETPAIRKERNTABLE:
            {
                PVOID pout;
                GETOPTPTR(parg16->f5, 0, pout);

                ul = GETINT16(iGetKerningPairsEsc32(
                                        HDC32(parg16->f1),
                                        (ESCKERNPAIR*) pout));

                FREEOPTPTR(pout);
            }
            break;

        case GETEXTENDEDTEXTMETRICS:
            {
                PVOID pout;
                EXTTEXTMETRIC etm;

                if ( (ul = GETINT16(GetETM(HDC32(parg16->f1),
                                              &etm))) != 0 )
                {
                    GETOPTPTR(parg16->f5, 0, pout);
                    RtlCopyMemory(pout, &etm, sizeof(EXTTEXTMETRIC));
                    FREEOPTPTR(pout);
                }
            }
            break;

        case OPENCHANNEL:                   // 4110

            if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_MGX_ESCAPES) {

                ul = 0;

            } else {

                DOCINFO16 *pout;
                DOCINFO DocInfo;

                DocInfo.cbSize       = sizeof(DocInfo);
                DocInfo.lpszDatatype = "RAW";
                DocInfo.fwType       = 0;


                GETOPTPTR(parg16->f5, 0, pout);

                if (pout) {

                    GETOPTPTR(pout->lpszDocName, 0, DocInfo.lpszDocName);
                    GETOPTPTR(pout->lpszOutput, 0, DocInfo.lpszOutput);

                    ul = StartDoc(HDC32(parg16->f1), &DocInfo);

                    FREEOPTPTR(DocInfo.lpszDocName);
                    FREEOPTPTR(DocInfo.lpszOutput);

                } else {

                    //
                    // Fifth parameter null, use old (startdoc) format
                    //

                    GETOPTPTR(parg16->f4, 0, DocInfo.lpszDocName);
                    DocInfo.lpszOutput = NULL;

                    ul = StartDoc(HDC32(parg16->f1), &DocInfo);

                    FREEOPTPTR(DocInfo.lpszDocName);

                }

                FREEOPTPTR(pout);
            }
            break;


        case DOWNLOADHEADER:                // 4111
            if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_MGX_ESCAPES) {
                ul = 0;
            }
            else {
                PBYTE pout;
                char  ach[64];

                GETOPTPTR(parg16->f5, 0, pout);

                if (pout) {
                    ul = GETINT16(ExtEscape(HDC32(parg16->f1),
                                 INT32(parg16->f2),
                                 0,
                                 NULL,
                                 sizeof(ach),
                                 ach));

                    strcpy (pout, ach);
                }
                else {
                    ul = GETINT16(ExtEscape(HDC32(parg16->f1),
                                 INT32(parg16->f2),
                                 0,
                                 NULL,
                                 0,
                                 NULL));

                }


                FREEOPTPTR(pout);
            }
            break;


        case CLOSECHANNEL:                  // 4112
            if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_MGX_ESCAPES) {
                ul = 0;
            }
            else {

                // send any buffered data streams to the printer before EndDoc
                if(CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_FORMFEEDHACK) {
                    SendFormFeedHack(HDC32(parg16->f1));
                }

                ul = EndDoc(HDC32(parg16->f1));
            }
            break;



        // This Escape is defined for PageMaker. It is SETGDIXFORM.
        // ChandanC, 24/5/93.
        //
        case SETGDIXFORM:                   // 4113
        case RESETPAGE:                     // 4114
            if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_MGX_ESCAPES) {
                ul = 0;
            }
            else {
                ul = 1;
            }
            break;


        case POSTSCRIPT_PASSTHROUGH:        // 4115
            if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_MGX_ESCAPES) {
                ul = 0;
            }
            else {
                ul = GETINT16(Escape(HDC32(parg16->f1),
                                    INT32(parg16->f2),
                                    (FETCHWORD(*(PWORD)pin) + 2),
                                    (LPCSTR)pin,
                                    NULL));
            }
            break;


        case ENCAPSULATED_POSTSCRIPT:       // 4116
            if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_MGX_ESCAPES) {
                ul = 0;
            }
            else {
                DWORD cb;
                PVOID lpInData32 = NULL;

                lpInData32 = pin;
                cb = FETCHDWORD (*(PDWORD) pin);

                if ((DWORD) pin & 3) {
                    if (lpInData32 = (PVOID) malloc_w (cb)) {
                        RtlCopyMemory(lpInData32, pin, cb);
                    }
                    else {
                        ul = 0;
                        break;
                    }
                }

                ul = GETINT16(DrawEscape(HDC32(parg16->f1),
                                        INT32(parg16->f2),
                                        cb,
                                        lpInData32));

                if (((DWORD) pin & 3) && (lpInData32)) {
                    free_w (lpInData32);
                }

            }
            break;


        case POSTSCRIPT_DATA:
            if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_MGX_ESCAPES) {
                ul = 0;
                LOGDEBUG (LOG_ALWAYS, ("MicroGraphax app using POSTSCRIPT_DATA, contact PingW/ChandanC\n"));
                WOW32ASSERT(FALSE);
            }
            else {
                //
                // XPress needs IGNORESTARTPAGE escape.
                // PingW, ChandanC 3/22/94
                //
                if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_NEEDIGNORESTARTPAGE) {
                    int l;
                    char szBuf[40];

                    if ((l = ExtEscape(HDC32(parg16->f1),
                                GETTECHNOLOGY,
                                0,
                                NULL,
                                sizeof(szBuf),
                                szBuf)) > 0) {

                        if (!WOW32_stricmp(szBuf, szPostscript)) {
                            l = ExtEscape(HDC32(parg16->f1),
                                IGNORESTARTPGAE,
                                0,
                                NULL,
                                0,
                                NULL);
                        }
                    }
                }

                ul = GETINT16(Escape(HDC32(parg16->f1),
                                 INT32(parg16->f2),
                                 (FETCHWORD(*(PWORD)pin) + 2),
                                 (LPCSTR)pin,
                                 NULL));
            }
            break;

        case POSTSCRIPT_IGNORE:
            if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_MGX_ESCAPES) {
                ul = 0;
                LOGDEBUG (LOG_ALWAYS, ("MicroGraphax app using POSTSCRIPT_IGNORE, contact PingW/ChandanC\n"));
                WOW32ASSERT(FALSE);
            }
            else {
                ul = GETINT16(Escape(HDC32(parg16->f1),
                                 INT32(parg16->f2),
                                 INT32(parg16->f3),
                                 (LPCSTR)pin,
                                 NULL));
            }
            break;

        case BEGIN_PATH:
        // Some apps set the empty clip region before doing the path escapes,
        // We need to undo that so the drawing APIs between begin and endpath
        // go through to drivers.

            SelectClipRgn(HDC32(parg16->f1),NULL);

        // fall through to escape call
        case END_PATH:
#ifdef FE_SB
            // WOWCF_FE_FLW2_PRINTING_PS,
            // Japanese Lotus Freelance printing with PostScript.
            // Between Escape( BEGIN_PATH ) and Escape( END_PATH ),
            // select brush object with WHITE_BRUSH
            if (GetSystemDefaultLangID() == 0x411 &&
                CURRENTPTD()->dwWOWCompatFlagsFE & WOWCF_FE_FLW2_PRINTING_PS ) {
                if( INT32(parg16->f2) == BEGIN_PATH )
                    fCmptFLW = TRUE;
                else
                    fCmptFLW = FALSE;
            }
#endif // FE_SB

        // fall through to escape call
        case CLIP_TO_PATH:
            ul = GETINT16(Escape(HDC32(parg16->f1),
                                 INT32(parg16->f2),
                                 INT32(parg16->f3),
                                 (LPCSTR)pin,
                                 NULL));
            break;

        case PASSTHROUGH:

            // if this is a form feed hack app...
            if(CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_FORMFEEDHACK) {

                ul = HandleFormFeedHack(HDC32(parg16->f1),
                                        pin,
                                        FETCHWORD(*(PWORD)pin)); // cb only
            }

            else {

                ul = GETINT16(Escape(HDC32(parg16->f1),
                                     INT32(parg16->f2),
                                     (FETCHWORD(*(PWORD)pin) + 2),
                                     (LPCSTR)pin,
                                     NULL));
            }
            break;


        case FLUSHOUTPUT:
            ul = TRUE;
            break;


        case DOWNLOADFACE:
            {
                WORD  InData;
                PWORD lpInData = NULL;

            // PM5 forgot to set there map mode so we do it.

                if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_FORCETWIPSESCAPE)
                    iMapMode = SetMapMode(HDC32(parg16->f1),MM_TWIPS);

                if (pin) {
                    InData = FETCHWORD(*(PWORD)pin);
                    lpInData = &InData;
                }

                ul = GETINT16(Escape(HDC32(parg16->f1),
                                    INT32(parg16->f2),
                                    sizeof(USHORT),
                                    (LPCSTR)lpInData,
                                    NULL));

                if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_FORCETWIPSESCAPE)
                    SetMapMode(HDC32(parg16->f1),iMapMode);
            }
            break;

        case GETFACENAME:
            {
                PSZ pout;
                CHAR ach[60];

            // PM5 forgot to set there map mode so we do it.

                if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_FORCETWIPSESCAPE)
                    iMapMode = SetMapMode(HDC32(parg16->f1),MM_TWIPS);

                GETOPTPTR(parg16->f5, 0, pout);


                // This HACK is for FH4.0 only. If you have any questions
                // talk to PingW or ChandanC.
                // July 21st 1994.
                //
                if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_ADD_MSTT) {

                    ExtEscape(HDC32(parg16->f1),
                        ADD_MSTT,
                        0,
                        NULL,
                        60,
                        ach);
                }

            // pass in 60 as a magic number.  Just copy out the valid string.

                ul = GETINT16(ExtEscape(HDC32(parg16->f1),
                                    INT32(parg16->f2),
                                    INT32(parg16->f3),
                                    pin,
                                    60,
                                    ach));
#ifdef FE_SB
                ach[59] = '\0';
#endif // !FE_SB
                strcpy (pout, ach);
                FREEOPTPTR(pout);

                if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_FORCETWIPSESCAPE)
                    SetMapMode(HDC32(parg16->f1),iMapMode);
            }
            break;

        case EPSPRINTING:
            {
                WORD  InData;
                PWORD lpInData = NULL;

                if (pin)
                {
                    InData = FETCHWORD(*(PWORD)pin);
                    lpInData = &InData;
                }

                ul = GETINT16(ExtEscape(HDC32(parg16->f1),
                                     INT32(parg16->f2),
                                     sizeof(BOOL),
                                     (LPCSTR)lpInData,
                                     0,
                                     NULL));
            }
            break;

        case GETTECHNOLOGY:
            {
                PVOID pout;

                buf[0] = '\0';

                GETOPTPTR(parg16->f5, 0, pout);

                if (!(CURRENTPTD()->dwWOWCompatFlags & WOWCF_FORCENOPOSTSCRIPT))
                {
                    ul = GETINT16(ExtEscape(HDC32(parg16->f1),
                                    INT32(parg16->f2),
                                    INT32(parg16->f3),
                                    pin,
                                    sizeof(buf),
                                    buf));
#ifdef FE_SB
                    // #636 When function is not supported,
                    // wow may destroy app's stack
                    if ((int)ul < 0)
                        buf[0] = '\0';
#endif // FE_SB

                }

                if (pout)
                    strcpy (pout, buf);

                FREEOPTPTR(pout);
            }
            break;

        case SETCOPYCOUNT:
            {
                int cCopiesOut, cCopiesIn=1;

                if (pin)
                    cCopiesIn = *(UNALIGNED SHORT *)pin;

                ul = GETINT16(Escape(HDC32(parg16->f1),
                                INT32(parg16->f2),
                                pin ? sizeof(cCopiesIn) : 0,
                                pin ? &cCopiesIn : pin,
                                parg16->f5 ? &cCopiesOut : NULL));

                if ( parg16->f5 ) {
                    if ( (INT)ul > 0 ) {
                        PUTINT16(parg16->f5, cCopiesOut);
                    } else {
                        // Pagemaker v4 needs the output value
                        PUTINT16(parg16->f5, 1);
                    }
                }
            }
            break;

        case STARTDOC:
            {
                PVOID pout;

                GETOPTPTR(parg16->f5, 0, pout);

                //
                // Win32 StartDoc depends on having the correct current directory
                // when printing to FILE: (which pops up for a filename).
                //

                UpdateDosCurrentDirectory(DIR_DOS_TO_NT);

                ul = GETINT16(Escape(HDC32(parg16->f1),
                                INT32(parg16->f2),
                                INT32(parg16->f3),
                                pin,
                                pout));

                //
                // PhotoShop needs a StartPage when it does StartDoc Escape.
                // PingW, ChandanC 3/22/94
                //
                if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_NEEDSTARTPAGE) {
                    int l;
                    char szBuf[80];

                    //
                    // It should be done ONLY for POSTSCRIPT drivers
                    //
                    if ((l = ExtEscape(HDC32(parg16->f1),
                                    GETTECHNOLOGY,
                                    0,
                                    NULL,
                                    sizeof(szBuf),
                                    szBuf)) > 0) {

                        if (!WOW32_stricmp(szBuf, szPostscript)) {
                            l = StartPage(HDC32(parg16->f1));
                        }
                    }
                }

                FREEOPTPTR(pout);
            }
            break;

        // Win'95 really messed us up here.  They changed the DRAWPATTERNRECT
        // structure instead of defining a new DRAWPATTERNRECT32 struct.
        // On NT, all metafiles are 32-bit. So if an app is building a metafile,
        // it will only know how to do 16-bit DRAWPATTERNRECT (DPR).  We have
        // to convert it to a 32-bit DPR before passing it to GDI.  On the other
        // hand, if an app is reading a metafile (either memory or disk file) it
        // will be 32-bit if it was created by calls to NT's metafile API, or it
        // could be 16-bit if it is something the app created or a file shipped
        // with the app.  If the app handles it correctly by using the size
        // field in the metafile record, then we can fix them up correctly.
        case DRAWPATTERNRECT:
            {
                DRAWPATRECT   dpr32in;

                if(pin) {

                    // if the app specifies that it is a 32-bit sized DPR struct
                    if(INT32(parg16->f3) == sizeof(DRAWPATRECT)) {
                        dpr32in.ptPosition.x =
                            (LONG)FETCHDWORD(((PDRAWPATRECT)pin)->ptPosition.x);
                        dpr32in.ptPosition.y =
                            (LONG)FETCHDWORD(((PDRAWPATRECT)pin)->ptPosition.y);
                        dpr32in.ptSize.x     =
                            (LONG)FETCHDWORD(((PDRAWPATRECT)pin)->ptSize.x);
                        dpr32in.ptSize.y     =
                            (LONG)FETCHDWORD(((PDRAWPATRECT)pin)->ptSize.y);
                        dpr32in.wStyle       =
                            FETCHWORD(((PDRAWPATRECT)pin)->wStyle);
                        dpr32in.wPattern     =
                            FETCHWORD(((PDRAWPATRECT)pin)->wPattern);
                    }
                    // else any other size, all we can do is assume that they
                    // are passing it as a 16-bit DRAWPATTERNRECT
                    else {
                        dpr32in.ptPosition.x =
                                 (LONG)FETCHWORD(((PDPR16)pin)->ptPosition.x);
                        dpr32in.ptPosition.y =
                                 (LONG)FETCHWORD(((PDPR16)pin)->ptPosition.y);
                        dpr32in.ptSize.x     =
                                 (LONG)FETCHWORD(((PDPR16)pin)->ptSize.x);
                        dpr32in.ptSize.y     =
                                 (LONG)FETCHWORD(((PDPR16)pin)->ptSize.y);
                        dpr32in.wStyle     = FETCHWORD(((PDPR16)pin)->wStyle);
                        dpr32in.wPattern   = FETCHWORD(((PDPR16)pin)->wPattern);
                    }

                    ul = GETINT16(Escape(HDC32(parg16->f1),
                                         DRAWPATTERNRECT,
                                         sizeof(DRAWPATRECT),
                                         (PVOID)&dpr32in,
                                         NULL));
                }
            }
            break;

        default:
            {
                PVOID pout;

                GETOPTPTR(parg16->f5, 0, pout);

                ul = GETINT16(Escape(HDC32(parg16->f1),
                                INT32(parg16->f2),
                                INT32(parg16->f3),
                                pin,
                                pout));

                FREEOPTPTR(pout);
            }
            break;

    } // end switch

    FREEOPTPTR(pin);
    FREEARGPTR(parg16);
    RETURN(ul);
}

ULONG FASTCALL WG32GetBitmapDimension(PVDMFRAME pFrame)
{
    ULONG ul;
    SIZE size2;
    register PGETBITMAPDIMENSION16 parg16;

    GETARGPTR(pFrame, sizeof(GETBITMAPDIMENSION16), parg16);

    ul = 0;
    if (GetBitmapDimensionEx(HBITMAP32(parg16->f1), &size2)) {
        ul = (WORD)size2.cx | (size2.cy << 16);
    }
    else {
        WOW32APIWARN (ul, "GetBitmapDimension");
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32GetBrushOrg(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT pt;
    POINT pt2;
    register PGETBRUSHORG16 parg16;

    GETARGPTR(pFrame, sizeof(GETBRUSHORG16), parg16);

// for windows compatability, we must first add the DCorg
// since windows brushorg is relative to the screen where as NT
// is relative to the window.  In the future, this should call
// a private gdi entry point to avoid an extra c/s hit. (erick)

    ul = 0;
    if (GetDCOrgEx(HDC32(parg16->f1),&pt))
    {
        if (GetBrushOrgEx(HDC32(parg16->f1), &pt2)) {
            ul = (WORD)(pt2.x + pt.x) | ((pt2.y + pt.y) << 16);
        }
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32GetClipBox(PVDMFRAME pFrame)
{
    ULONG ul;
    RECT t2;
    register PGETCLIPBOX16 parg16;
    HDC     hdc;

    GETARGPTR(pFrame, sizeof(GETCLIPBOX16), parg16);

    hdc = HDC32(parg16->f1);

    ul = GETINT16(GetClipBox(hdc,&t2));

    if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_SIMPLEREGION) {
        ul = SIMPLEREGION;
    }

    PUTRECT16(parg16->f2, &t2);
    FREEARGPTR(parg16);

    RETURN(ul);
}


ULONG FASTCALL WG32GetCurrentPosition(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT pt;
    register PGETCURRENTPOSITION16 parg16;

    GETARGPTR(pFrame, sizeof(GETCURRENTPOSITION16), parg16);

    ul = 0;
    if (GetCurrentPositionEx(HDC32(parg16->f1), &pt)) {
        ul = (WORD)pt.x | (pt.y << 16);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32GetDCOrg(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT   pt;
    register PGETDCORG16 parg16;

    GETARGPTR(pFrame, sizeof(GETDCORG16), parg16);

    ul = 0;
    if ( GetDCOrgEx(HDC32(parg16->f1),&pt) ) {
        ul = (WORD)pt.x | (pt.y << 16);
    }

    LOGDEBUG(6,("GetDCOrg for hdc %x returns %lx\n",parg16->f1,ul));

    FREEARGPTR(parg16);
    RETURN(ul);
}



// PowerPoint 2&3 call this 2 times for each slide in the slide previewer
// the lpvBits == NULL on the first call (presumably to find the size to
// allocate) -- in which case Win3.x returns 1
ULONG FASTCALL WG32GetDIBits(PVDMFRAME pFrame)
{
    INT          nbmiSize;
    ULONG        ul = 0L;
    PBYTE        pb5;
    PBYTE        pb6;
    STACKBMI32   bmi32;
    LPBITMAPINFO lpbmi32;
    register     PGETDIBITS16 parg16;

    GETARGPTR(pFrame, sizeof(GETDIBITS16), parg16);
    GETMISCPTR(parg16->f5, pb5);
    GETMISCPTR(parg16->f6, pb6);

    // copy just the BITMAPINFOHEADER portion of the BITMAPINFO struct
    if(lpbmi32=(LPBITMAPINFO)CopyBMIH16ToBMIH32((PVPVOID)FETCHDWORD(parg16->f6),
                                                (LPBITMAPINFOHEADER)&bmi32)) {

        // gdi32 will adjust key fields of the BITMAPINFOHEADER & copy the
        // color table into the 32-bit BITMAPINFO struct
        if( ul = GETINT16(GetDIBits(HDC32(parg16->f1),
                                    HBITMAP32(parg16->f2),
                                    WORD32(parg16->f3),
                                    WORD32(parg16->f4),
                                    pb5,
                                    lpbmi32,
                                    WORD32(parg16->f7))) ) {

            // if lpvBits, then they want the bits of the bitmap too
            if(pb5) {
                ul = WORD32(parg16->f4); // return # scanlines requested
                FLUSHVDMPTR(parg16->f5, SIZE_BOGUS, pb5);
            }
            // else tell app that BITMAPINFO structure filled in only
            else {
                ul = 1L;
            }

            // copy the updated BITMAPINFO struct back into the 16-bit version
            nbmiSize = GetBMI32Size(lpbmi32, WORD32(parg16->f7));
            RtlCopyMemory(pb6, lpbmi32, nbmiSize);

            FLUSHVDMPTR(parg16->f6, nbmiSize, pb6);
        }
    }

    FREEMISCPTR(pb5);
    FREEMISCPTR(pb6);
    FREEARGPTR(parg16);
    RETURN(ul);
}



ULONG FASTCALL WG32GetDeviceCaps(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETDEVICECAPS16 parg16;

    GETARGPTR(pFrame, sizeof(GETDEVICECAPS16), parg16);

    if (INT32(parg16->f2) == COLORRES) {
        ul = 18;
    }
    else {
        ul = GetDeviceCaps(HDC32(parg16->f1), INT32(parg16->f2));

        if (ul == (ULONG)-1) {
            switch (parg16->f2) {
                case NUMBRUSHES:
                case NUMPENS:
                case NUMCOLORS:
                    ul = 2048;
                    break;
                default:
                    break;
            }
        } else if(ul > 32767) {

            // 16-bit apps can't handle 16M colors in a 16-bit INT
            // most just check if the return is <= 2 to see if they are
            // going to print mono-chrome or color.
            if(parg16->f2 == NUMCOLORS) {
                ul = 32767;
            }
        }

        // if the 4plane conversion flag is set, tell them we are 4 planes 1bpp
        // instead of 1plane 4bpp.

        if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_4PLANECONVERSION) {
            if (INT32(parg16->f2) == BITSPIXEL) {
                if ((ul == 4) && (GetDeviceCaps(HDC32(parg16->f1),PLANES) == 1))
                    ul = 1;
            }
            else if (INT32(parg16->f2) == PLANES) {
                if ((ul == 1) && (GetDeviceCaps(HDC32(parg16->f1),BITSPIXEL) == 4))
                    ul = 4;
            }
        }
       if ( (POLYGONALCAPS == parg16->f2) && (CURRENTPTD()->dwWOWCompatFlags & WOWCF_NOPC_RECTANGLE)) {
            ul &= !PC_RECTANGLE;  // Quattro Pro 1.0 for Windows doesn't handle this bit well.
       }

       if ( RASTERCAPS == INT32(parg16->f2) )
       {
           //
           // bjm 10/10/97
           // This is always on in Win31 and Win95 (supporting BITMAPS is
           // pretty much a requirement for drivers) so Win32 killed
           // the bit and will never return it.
           // So, let's make sure it's always on.
           //
           ul |= 0x8000;
       }

    }

    ul = GETINT16(ul);

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32GetEnvironment(PVDMFRAME pFrame)
{
    // not a Win32 function

    //
    // if lpEnviron==NULL then the user is querying the size of device
    // data.  WinProj doesn't check the return value, calling the driver
    // with an undersized buffer, trashing the global heap.
    // WinFax passes a hard coded 0xA9 == 0x44+0x69 == sizeof(win3.0 DevMode) +
    // known WinFax.DRV->dmDriverExtra. Beware also that WinFax calls this
    // whenever an app calls any API that requires a DevMode.


    INT   len;
    ULONG ul=0;
    register PGETENVIRONMENT16 parg16;
    PSZ psz;
    PSZ psz1 = NULL;
    VPDEVMODE31 vpdm2;
    CHAR *pszDriver = NULL;
    UINT cbT = 0;
    WORD nMaxBytes;

    GETARGPTR(pFrame, sizeof(GETENVIRONMENT16), parg16);

    // save off the 16-bit params now since this could callback into a 16-bit
    // fax driver & cause 16-bit memory to move.
    GETPSZPTR(parg16->f1, psz);
    if(psz) {
        len = lstrlen(psz) + 1;
        psz1 = malloc_w(len);
        if(psz1) {
            strcpy(psz1, psz);
            pszDriver = malloc_w(max(len,40));
        }
    }
    FREEPSZPTR(psz);
    vpdm2 = FETCHDWORD(parg16->f2);

    nMaxBytes = FETCHWORD(parg16->f3);

    FREEARGPTR(parg16);
    // invalidate all flat ptrs to 16:16 memory now

    // this implies that psz1 may also be bad
    if(!pszDriver) {
        goto exitpath;
    }

    if (!(spoolerapis[WOW_EXTDEVICEMODE].lpfn)) {
        if (!LoadLibraryAndGetProcAddresses("WINSPOOL.DRV", spoolerapis, WOW_SPOOLERAPI_COUNT)) {
            goto exitpath;
        }
    }

    // get required size for output buffer
    // When WinFax calls this api, calls to GetDriverName for pszDriver ==
    // "FaxModem" seem to fail -- this is a good thing if the app called
    // ExtDeviceMode() because we would get into an infinite loop here.  WinFax
    // just fills in a DevMode with default values if this api fails.
    if  (GetDriverName(psz1, pszDriver)) {
        ul = (*spoolerapis[WOW_EXTDEVICEMODE].lpfn)(NULL,
                                                     NULL,
                                                     NULL,
                                                     pszDriver,
                                                     psz1,
                                                     NULL,
                                                     NULL,
                                                     0);
        LOGDEBUG(6,("WOW::GetEnvironment returning ul = %d, for Device = %s, Port = %s \n", ul, pszDriver, psz1));

        // adjust the size for our DEVMODE handling (see note in wstruc.c)
        // (it won't hurt to allocate too much)
        if(ul) {
            ul += sizeof(WOWDM31);
            cbT = (UINT)ul;
        }

        // if they also want us to fill in their environment structure...
        if ((vpdm2 != 0) && (ul != 0)) {
            LPDEVMODE lpdmOutput;

            if (lpdmOutput = malloc_w(ul)) {

                // this might be calling into a 16-bit fax driver!!
                ul = (*spoolerapis[WOW_EXTDEVICEMODE].lpfn)(NULL,
                                                            NULL,
                                                            lpdmOutput,
                                                            pszDriver,
                                                            psz1,
                                                            NULL,
                                                            NULL,
                                                            DM_OUT_BUFFER);

                // if a WinFax call to GetDriverName() succeeds & gets to here
                // we may need to hack on the lpdmOutput->dmSize==0x40
                // (Win3.0 size) to account for the hard coded buffer size of
                // 0xa9 the app passes. So far I haven't seen WinFax get past
                // GetDriverName() call & it still seems to work OK.
                if (ul > 0L) {
                    // Use the min of nMaxBytes & what we calculated
                    ThunkDevMode32to16(vpdm2, lpdmOutput, min(nMaxBytes, cbT));
                }

                free_w(lpdmOutput);

                LOGDEBUG(6,("WOW::GetEnvironment getting DEVMODE structure, ul = %d, for Device = %s, Port = %s \n", ul, pszDriver, psz1));
            }
        }
    }

exitpath:
    if(psz1) {
        free_w(psz1);
    }
    if(pszDriver) {
        free_w(pszDriver);
    }

    RETURN(ul);

}


ULONG FASTCALL WG32GetObject(PVDMFRAME pFrame)
{
    ULONG ul;
    HANDLE  hgdi;
    register PGETOBJECT16 parg16;

    GETARGPTR(pFrame, sizeof(GETOBJECT16), parg16);

    hgdi = HOBJ32(parg16->f1);

    switch (GetObjectType(hgdi)) {
    case OBJ_BITMAP:
        {
            BITMAP bm;
            ul = GETINT16(GetObject(hgdi, sizeof(BITMAP), (LPSTR)&bm));
            if (ul) {
                PUTBITMAP16(parg16->f3, parg16->f2, &bm);
                if ( ul > sizeof(BITMAP16) ) {
                    ul = sizeof(BITMAP16);
                }
            }
        }
        break;

    case OBJ_BRUSH:
        {
            LOGBRUSH lb;
            ul = GETINT16(GetObject(hgdi, sizeof(LOGBRUSH), (LPSTR)&lb));
            if (ul) {
                PUTLOGBRUSH16(parg16->f3, parg16->f2, &lb);
                if (ul > sizeof(LOGBRUSH16)) {
                    ul = sizeof(LOGBRUSH16);
                }
            }
        }
        break;

    case OBJ_PEN:
        {
            LOGPEN lp;
            ul = GETINT16(GetObject(hgdi, sizeof(LOGPEN), (LPSTR)&lp));
            if (ul) {
                PUTLOGPEN16(parg16->f3, parg16->f2, &lp);
                if (ul > sizeof(LOGPEN16)) {
                    ul = sizeof(LOGPEN16);
                }
            }
        }
        break;

    case OBJ_FONT:
        {
            LOGFONT lf;
            ul = GETINT16(GetObject(hgdi, sizeof(LOGFONT), (LPSTR)&lf));
            if (ul) {
                PUTLOGFONT16(parg16->f3, parg16->f2, &lf);
                if (ul > sizeof(LOGFONT16)) {
                    ul = sizeof(LOGFONT16);
                }
            }
        }
        break;

    case OBJ_PAL:
        {
            PSHORT16 lpT;
            SHORT sT;

            ul = GETINT16(GetObject(hgdi, sizeof(SHORT), (LPSTR)&sT));
            if (ul && (FETCHWORD(parg16->f2) >= sizeof(WORD))) {
                GETVDMPTR(FETCHDWORD(parg16->f3), sizeof(WORD), lpT);
                if (lpT) {
                    STOREWORD(lpT[0], sT);
                }
                FREEVDMPTR(lpT);
            }
        }
        break;


    default:
        {
            PBYTE pb3;

            LOGDEBUG(LOG_ALWAYS,(" HACK: GetObject handle unknown, contact ChandanC\n"));

            GETVDMPTR(parg16->f3, parg16->f2, pb3);

            ul = GETINT16(GetObject(hgdi, INT32(parg16->f2), pb3));

            FLUSHVDMPTR(parg16->f3, parg16->f2, pb3);
            FREEVDMPTR(pb3);
        }

    }   // switch

    WOW32APIWARN(ul, "GetObject");

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32GetRgnBox(PVDMFRAME pFrame)
{
    ULONG ul;
    RECT t2;
    register PGETRGNBOX16 parg16;

    GETARGPTR(pFrame, sizeof(GETRGNBOX16), parg16);

    ul = GETINT16(GetRgnBox(HRGN32(parg16->f1), &t2));

    PUTRECT16(parg16->f2, &t2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32GetViewportExt(PVDMFRAME pFrame)
{
    ULONG ul;
    SIZE size;
    register PGETVIEWPORTEXT16 parg16;

    GETARGPTR(pFrame, sizeof(GETVIEWPORTEXT16), parg16);

    ul = 0;
    if (GetViewportExtEx(HDC32(parg16->f1), &size)) {

        //
        // win31 returns 1 rather than 0 unless there was an error
        //

        if (!(ul = (WORD)size.cx | (size.cy << 16)))
            ul = 1;
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32GetViewportOrg(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT pt;
    register PGETVIEWPORTORG16 parg16;

    GETARGPTR(pFrame, sizeof(GETVIEWPORTORG16), parg16);

    ul = 0;
    if (GetViewportOrgEx(HDC32(parg16->f1), &pt)) {
        ul = (WORD)pt.x | (pt.y << 16);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32GetWindowExt(PVDMFRAME pFrame)
{
    ULONG ul;
    SIZE size;
    register PGETWINDOWEXT16 parg16;

    GETARGPTR(pFrame, sizeof(GETWINDOWEXT16), parg16);

    ul = 0;
    if (GetWindowExtEx(HDC32(parg16->f1), &size)) {
        if (!(ul = (WORD)size.cx | (size.cy << 16)))    // see above
            ul = 1;
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32GetWindowOrg(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT pt;
    register PGETWINDOWORG16 parg16;

    GETARGPTR(pFrame, sizeof(GETWINDOWORG16), parg16);

    ul = 0;
    if (GetWindowOrgEx(HDC32(parg16->f1), &pt)) {
        ul = (WORD)pt.x | (pt.y << 16);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32LPtoDP(PVDMFRAME pFrame)
{
    ULONG ul=0;
    LPPOINT t2;
    register PLPTODP16 parg16;
    POINT  BufferT[128];

    GETARGPTR(pFrame, sizeof(LPTODP16), parg16);
    t2 = STACKORHEAPALLOC(parg16->f3 * sizeof(POINT), sizeof(BufferT), BufferT);

    if (t2) {
        getpoint16(parg16->f2, parg16->f3, t2);

        ul = GETBOOL16(LPtoDP(HDC32(parg16->f1), t2, INT32(parg16->f3)));

        PUTPOINTARRAY16(parg16->f2, parg16->f3, t2);

        STACKORHEAPFREE(t2, BufferT);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


void W32LineDDAFunc(int x, int y, PLINEDDADATA pDDAData)
{
    PARM16 Parm16;

    WOW32ASSERT(pDDAData);
    Parm16.LineDDAProc.vpData     = (VPVOID)pDDAData->dwUserDDAParam;
    Parm16.LineDDAProc.x = (SHORT)x;
    Parm16.LineDDAProc.y = (SHORT)y;
    Parm16.LineDDAProc.vpData     = (VPVOID)pDDAData->dwUserDDAParam;
    CallBack16(RET_LINEDDAPROC, &Parm16, pDDAData->vpfnLineDDAProc, NULL);

    return;
}

ULONG FASTCALL WG32LineDDA(PVDMFRAME pFrame)
{
    LINEDDADATA DDAData;
    register    PLINEDDA16 parg16;

    GETARGPTR(pFrame, sizeof(LINEDDA16), parg16);

    DDAData.vpfnLineDDAProc = DWORD32(parg16->f5);
    DDAData.dwUserDDAParam  = DWORD32(parg16->f6);

    LineDDA(INT32(parg16->f1),
            INT32(parg16->f2),
            INT32(parg16->f3),
            INT32(parg16->f4),
            (LINEDDAPROC)W32LineDDAFunc,
	    (LPARAM)&DDAData);
    // 16-bit memory may have moved - invalidate flat pointers now
    FREEVDMPTR(pFrame);
    FREEARGPTR(parg16);

    RETURN(1L);
}


ULONG FASTCALL WG32MoveTo(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT pt;
    register PMOVETO16 parg16;

    GETARGPTR(pFrame, sizeof(MOVETO16), parg16);

    ul = 0;
    pt.x = 1L; // see "METAFILE NOTE"
    pt.y = 0L;
    if (MoveToEx(HDC32(parg16->f1),
                 INT32(parg16->f2),
                 INT32(parg16->f3),
                 &pt)) {

        ul = (WORD)pt.x | (pt.y << 16);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32OffsetViewportOrg(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT pt;
    register POFFSETVIEWPORTORG16 parg16;

    GETARGPTR(pFrame, sizeof(OFFSETVIEWPORTORG16), parg16);

    ul = 0;
    pt.x = 1L; // see "METAFILE NOTE"
    pt.y = 0L;
    if (OffsetViewportOrgEx(HDC32(parg16->f1),
                            INT32(parg16->f2),
                            INT32(parg16->f3),
                            &pt)) {

        ul = (WORD)pt.x | (pt.y << 16);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32OffsetWindowOrg(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT pt;
    register POFFSETWINDOWORG16 parg16;

    GETARGPTR(pFrame, sizeof(OFFSETWINDOWORG16), parg16);

    ul = 0;
    pt.x = 1L; // see "METAFILE NOTE"
    pt.y = 0L;
    if (OffsetWindowOrgEx(HDC32(parg16->f1),
                          INT32(parg16->f2),
                          INT32(parg16->f3),
                          &pt)) {

        ul = (WORD)pt.x | (pt.y << 16);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32PolyPolygon(PVDMFRAME pFrame)
{
    ULONG    ul=0;
    LPPOINT  pPoints;
    PINT     pPolyCnt;
    UINT     cpts = 0;
    INT      ii;
    register PPOLYPOLYGON16 parg16;
    INT      cInt16;
    INT      BufferT[256]; // comfortably large array


    GETARGPTR(pFrame, sizeof(POLYPOLYGON16), parg16);

    cInt16 = INT32(parg16->f4);
    pPolyCnt = STACKORHEAPALLOC(cInt16 * sizeof(INT), sizeof(BufferT), BufferT);

    if (!pPolyCnt) {
        FREEARGPTR(parg16);
        RETURN(0);
    }

    getintarray16(parg16->f3, cInt16, pPolyCnt);

    for (ii=0; ii < cInt16; ii++)
        cpts += pPolyCnt[ii];

    pPoints = STACKORHEAPALLOC(cpts * sizeof(POINT),
                                     sizeof(BufferT) - cInt16 * sizeof(INT),
                                     BufferT + cInt16);

    if (pPoints) {

        getpoint16(parg16->f2, cpts, pPoints);

        ul = GETBOOL16(PolyPolygon(HDC32(parg16->f1),
                              pPoints,
                              pPolyCnt,
                              INT32(parg16->f4)));

        STACKORHEAPFREE(pPoints, BufferT + cInt16);
    }

    STACKORHEAPFREE(pPolyCnt, BufferT);
    FREEARGPTR(parg16);
    RETURN(ul);
}

ULONG FASTCALL WG32PolyPolylineWOW(PVDMFRAME pFrame)
{
    ULONG    ul;
    register PPOLYPOLYLINEWOW16 parg16;
    LPPOINT  pptArray;
    LPDWORD  pcntArray;
    DWORD    cnt;

    GETARGPTR(pFrame, sizeof(POLYPOLYLINEWOW16), parg16);

    cnt = FETCHDWORD(parg16->f4);

    GETVDMPTR(parg16->f2, sizeof(POINT)*cnt, pptArray);
    GETVDMPTR(parg16->f3, sizeof(DWORD)*cnt, pcntArray);

    ul = GETBOOL16(PolyPolyline(HDC32(parg16->f1),
                               pptArray,
                               pcntArray,
                               cnt));
    FREEVDMPTR(pptArray);
    FREEVDMPTR(pcntArray);

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32Polygon(PVDMFRAME pFrame)
{
    ULONG ul=0;
    LPPOINT p2;
    register PPOLYGON16 parg16;
    POINT  BufferT[128];
#ifdef FE_SB // for Japanese Lotus Freelance
   HBRUSH  hbr = 0;
#endif // FE_SB

    GETARGPTR(pFrame, sizeof(POLYGON16), parg16);
    p2 = STACKORHEAPALLOC(parg16->f3 * sizeof(POINT), sizeof(BufferT), BufferT);

    if (p2) {
         getpoint16(parg16->f2, parg16->f3, p2);
#ifdef FE_SB
    // WOWCF_FE_FLW2_PRINTING_PS, Japanese Lotus Freelance
    // printing with PostScript.
    // Between Escape( BEGIN_PATH ) and Escape( END_PATH ),
    // select brush object with WHITE_BRUSH
         if (GetSystemDefaultLangID() == 0x411 && fCmptFLW &&
              CURRENTPTD()->dwWOWCompatFlagsFE & WOWCF_FE_FLW2_PRINTING_PS) {
              hbr = SelectObject( HDC32(parg16->f1), GetStockObject( WHITE_BRUSH ));
         }
#endif // FE_SB

         ul = GETBOOL16(Polygon(HDC32(parg16->f1), p2, INT32(parg16->f3)));
#ifdef FE_SB
         if (hbr) {
             SelectObject( HDC32(parg16->f1), hbr );
         }
#endif // FE_SB

         STACKORHEAPFREE(p2, BufferT);
    }
    
    FREEARGPTR(parg16);
    

    RETURN(ul);
}


ULONG FASTCALL WG32Polyline(PVDMFRAME pFrame)
{
    ULONG ul=0;
    PPOINT t2;
    register PPOLYLINE16 parg16;
    POINT  BufferT[128];

    GETARGPTR(pFrame, sizeof(POLYLINE16), parg16);
    t2 = STACKORHEAPALLOC(parg16->f3 * sizeof(POINT), sizeof(BufferT), BufferT);

    if (t2) {
       getpoint16(parg16->f2, parg16->f3, t2);

       ul = GETBOOL16(Polyline(HDC32(parg16->f1), t2, INT32(parg16->f3)));

       STACKORHEAPFREE(t2, BufferT);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32RectInRegion(PVDMFRAME pFrame)
{
    ULONG ul;
    RECT t2;
    register PRECTINREGION16 parg16;

    GETARGPTR(pFrame, sizeof(RECTINREGION16), parg16);
    WOW32VERIFY(GETRECT16(parg16->f2, &t2));

    ul = GETBOOL16(RectInRegion(HRGN32(parg16->f1), &t2));

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32RectVisible(PVDMFRAME pFrame)
{
    ULONG ul;
    RECT t2;
    register PRECTVISIBLE16 parg16;

    GETARGPTR(pFrame, sizeof(RECTVISIBLE16), parg16);
    WOW32VERIFY(GETRECT16(parg16->f2, &t2));

    ul = GETBOOL16(RectVisible(HDC32(parg16->f1), &t2));

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32ScaleViewportExt(PVDMFRAME pFrame)
{
    ULONG ul;
    SIZE size;
    register PSCALEVIEWPORTEXT16 parg16;

    GETARGPTR(pFrame, sizeof(SCALEVIEWPORTEXT16), parg16);

    ul = 0;
    if (ScaleViewportExtEx(HDC32(parg16->f1),
                           INT32(parg16->f2),
                           INT32(parg16->f3),
                           INT32(parg16->f4),
                           INT32(parg16->f5),
                           &size)) {

        if (!(ul = (WORD)size.cx | (size.cy << 16)))    // see above
            ul = 1;
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32ScaleWindowExt(PVDMFRAME pFrame)
{
    ULONG ul;
    SIZE size;
    register PSCALEWINDOWEXT16 parg16;

    GETARGPTR(pFrame, sizeof(SCALEWINDOWEXT16), parg16);

    ul = 0;
    if (ScaleWindowExtEx(HDC32(parg16->f1),
                         INT32(parg16->f2),
                         INT32(parg16->f3),
                         INT32(parg16->f4),
                         INT32(parg16->f5),
                         &size)) {

        if (!(ul = (WORD)size.cx | (size.cy << 16)))    // see above
            ul = 1;
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


/******************************Public*Routine******************************\
* PBYTE pjCvtPlaneToPacked4
*
*   Convert a 4plane, 1bpp bitmap into a 1plane, 4bpp bitmap.
*   This functions returns a pointer that must later be freed with LocalFree().
*
*   This has been added for PhotoShop 16 color vga compatability.
*
* History:
*  28-May-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PBYTE pjCvtPlaneToPacked4(
    BITMAP *pbm,
    PBYTE pjSrc,
    DWORD *pcjSrc)
{
    PBYTE pjDstRet;
    PBYTE pjDst;
    PBYTE pjPlane[4];   // pointer to first byte of current scan for each plane
    DWORD cjWidth;      // width of the destination in bytes
    DWORD cjSrcWidth;   // width of the source scan in bytes inc. all planes
    DWORD cy;           // number of scans
    BYTE  shift;        // shift value,
    DWORD i,x,y;

// just grab the width of the dest out of the BITMAP

    cjWidth = pbm->bmWidthBytes;

// the src should be word aligned for each plane with 4 planes

    cjSrcWidth = ((pbm->bmWidth + 15) & ~15) / 8 * 4;
    if (!cjSrcWidth) {
        WOW32ASSERT ( 0 != cjSrcWidth );
        return(NULL);
    }


// compute the height, the smaller of the bm height and the source height

    cy = min((DWORD)pbm->bmHeight,(DWORD)(*pcjSrc / cjSrcWidth));

// allocate the new chunk of memory

    *pcjSrc = cy * cjWidth;

    pjDst = LocalAlloc(LMEM_FIXED,*pcjSrc);

    if (pjDst == NULL)
        return(NULL);

    pjDstRet = pjDst;

// intialize the beginings of the planes

    for (i = 0; i < 4; ++i)
        pjPlane[i] = pjSrc + (cjSrcWidth / 4) * i;

// loop through the scans

    for (y = 0; y < cy; ++y)
    {
        shift = 7;

    // loop through the bytes within a scan

        for (x = 0; x < cjWidth; ++x)
        {

        // bit 7 -> nibble 1
        // bit 6 -> nibble 0
        // bit 5 -> nibble 3
        // bit 4 -> nibble 2
        // . . .

            *pjDst = (((pjPlane[0][x/4] >> (shift-1)) & 1) << 0 ) |       // 0x01
                     (((pjPlane[1][x/4] >> (shift-1)) & 1) << 1 ) |       // 0x02
                     (((pjPlane[2][x/4] >> (shift-1)) & 1) << 2 ) |       // 0x04
                     (((pjPlane[3][x/4] >> (shift-1)) & 1) << 3 ) |       // 0x08

                     (((pjPlane[0][x/4] >> (shift-0)) & 1) << 4 ) |       // 0x10
                     (((pjPlane[1][x/4] >> (shift-0)) & 1) << 5 ) |       // 0x20
                     (((pjPlane[2][x/4] >> (shift-0)) & 1) << 6 ) |       // 0x40
                     (((pjPlane[3][x/4] >> (shift-0)) & 1) << 7 );        // 0x80

            pjDst++;
            shift = (shift - 2) & 7;
        }

        pjPlane[0] += cjSrcWidth;
        pjPlane[1] += cjSrcWidth;
        pjPlane[2] += cjSrcWidth;
        pjPlane[3] += cjSrcWidth;
    }

    return(pjDstRet);
}

ULONG FASTCALL WG32SetBitmapBits(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    PBYTE pb3;
    register PSETBITMAPBITS16 parg16;
    HBITMAP hbm;
    DWORD cj;
    BITMAP bm;
    BOOL   fValidObj;

    GETARGPTR(pFrame, sizeof(SETBITMAPBITS16), parg16);
    GETOPTPTR(parg16->f3, 0, pb3);

    hbm = HBITMAP32(parg16->f1);
    cj  = DWORD32(parg16->f2);

    fValidObj = (GetObject(hbm,sizeof(BITMAP),&bm) == sizeof(BITMAP));
    if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_4PLANECONVERSION) {

    // Get the size of the destination bitmap

        if (fValidObj &&
            (bm.bmPlanes == 1) &&
            (bm.bmBitsPixel == 4))
        {
            PBYTE pjCvt = pjCvtPlaneToPacked4(&bm,pb3,&cj);

            if (pjCvt)
                ul = SetBitmapBits(hbm,cj,pjCvt);
            else
                ul = 0;

            LocalFree(pjCvt);
            hbm = 0;
        }
    }
    else {
        cj = min(cj, (DWORD)(bm.bmWidthBytes * bm.bmHeight));
    }


    if (hbm != 0)
        ul = GETLONG16(SetBitmapBits(hbm,cj,pb3));

    WOW32APIWARN (ul, "SetBitmapBits");

    FREEMISCPTR(pb3);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32SetBitmapDimension(PVDMFRAME pFrame)
{
    ULONG ul;
    SIZE size4;
    register PSETBITMAPDIMENSION16 parg16;

    GETARGPTR(pFrame, sizeof(SETBITMAPDIMENSION16), parg16);

    ul = 0;
    if (SetBitmapDimensionEx(HBITMAP32(parg16->f1),
                             INT32(parg16->f2),
                             INT32(parg16->f3),
                             &size4)) {

        ul = (WORD)size4.cx | (size4.cy << 16);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32SetBrushOrg(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    POINT pt;
    POINT pt2;
    register PSETBRUSHORG16 parg16;

    GETARGPTR(pFrame, sizeof(SETBRUSHORG16), parg16);

// for windows compatability, we must first subtract off the DCorg
// since windows brushorg is relative to the screen where as NT
// is relative to the window.  In the future, this should call
// a private gdi entry point to avoid an extra c/s hit. (erick)

    if (GetDCOrgEx(HDC32(parg16->f1),&pt))
    {
        ul = 0;
        pt2.x = 1L; // see "METAFILE NOTE"
        pt2.y = 0L;
        if (SetBrushOrgEx(HDC32(parg16->f1),
                          INT32(parg16->f2) - pt.x,
                          INT32(parg16->f3) - pt.y,
                          &pt2)) {

// add the origin back on so the app gets a consistent return value.
// view...all from micrografx designer doesn't work unless this returns
// the right thing.

            ul = (WORD)(pt2.x + pt.x) | ((pt2.y + pt.y) << 16);
        }
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32SetDIBits(PVDMFRAME pFrame)
{
    ULONG        ul = 0L;
    PBYTE        pb5;
    STACKBMI32   bmi32;
    LPBITMAPINFO lpbmi32;
    register     PSETDIBITS16 parg16;

    GETARGPTR(pFrame, sizeof(SETDIBITS16), parg16);
    GETMISCPTR(parg16->f5, pb5);

    lpbmi32 = CopyBMI16ToBMI32((PVPVOID)FETCHDWORD(parg16->f6),
                               (LPBITMAPINFO)&bmi32,
                               FETCHWORD(parg16->f7));

    // see if we need to adjust the image sze for RLE bitmaps
    if(lpbmi32 && pb5) {

        if((lpbmi32->bmiHeader.biCompression == BI_RLE4) ||
           (lpbmi32->bmiHeader.biCompression == BI_RLE8)) {

            if(lpbmi32->bmiHeader.biSizeImage == 0) {

                lpbmi32->bmiHeader.biSizeImage =
                     Get_RLE_Compression_Size(lpbmi32->bmiHeader.biCompression,
                                              pb5,
                                              parg16->f5);
            }
        }
    }

    ul = GETINT16(SetDIBits(HDC32(parg16->f1),
                            HBITMAP32(parg16->f2),
                            WORD32(parg16->f3),
                            WORD32(parg16->f4),
                            pb5,
                            lpbmi32,
                            WORD32(parg16->f7)));

    WOW32APIWARN (ul, "WG32SetDIBits\n");

    FREEMISCPTR(pb5);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32SetDIBitsToDevice(PVDMFRAME pFrame)
{
    ULONG        ul = 0L;
    PSZ          p10;
    STACKBMI32   bmi32;
    LPBITMAPINFO lpbmi32;
    register     PSETDIBITSTODEVICE16 parg16;

    GETARGPTR(pFrame, sizeof(SETDIBITSTODEVICE16), parg16);
    GETMISCPTR(parg16->f10, p10);

    lpbmi32 = CopyBMI16ToBMI32((PVPVOID)FETCHDWORD(parg16->f11),
                               (LPBITMAPINFO)&bmi32,
                               FETCHWORD(parg16->f12));

    // these are doc'd as WORD in Win3.0, doc'd as INT in Win3.1
    WOW32ASSERTMSG(((INT)parg16->f4 >= 0),("WOW:signed val - CMJones\n"));
    WOW32ASSERTMSG(((INT)parg16->f5 >= 0),("WOW:signed val - CMJones\n"));
    WOW32ASSERTMSG(((INT)parg16->f8 >= 0),("WOW:signed val - CMJones\n"));
    WOW32ASSERTMSG(((INT)parg16->f9 >= 0),("WOW:signed val - CMJones\n"));

    // see if we need to adjust the image sze for RLE bitmaps
    if(lpbmi32 && p10) {

        if((lpbmi32->bmiHeader.biCompression == BI_RLE4) ||
           (lpbmi32->bmiHeader.biCompression == BI_RLE8)) {

            if(lpbmi32->bmiHeader.biSizeImage == 0) {

                lpbmi32->bmiHeader.biSizeImage =
                     Get_RLE_Compression_Size(lpbmi32->bmiHeader.biCompression,
                                              p10,
                                              parg16->f10);
            }
        }
    }

    ul = GETINT16(SetDIBitsToDevice(HDC32(parg16->f1),
                                    INT32(parg16->f2),
                                    INT32(parg16->f3),
                                    WORD32(parg16->f4),
                                    WORD32(parg16->f5),
                                    INT32(parg16->f6),
                                    INT32(parg16->f7),
                                    WORD32(parg16->f8),
                                    WORD32(parg16->f9),
                                    p10,
                                    lpbmi32,
                                    WORD32(parg16->f12)));

    WOW32APIWARN (ul, "WG32SetDIBitsToDevice\n");

    FREEMISCPTR(p10);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32SetViewportExt(PVDMFRAME pFrame)
{
    ULONG ul;
    SIZE size;
    register PSETVIEWPORTEXT16 parg16;

    GETARGPTR(pFrame, sizeof(SETVIEWPORTEXT16), parg16);

    ul = 0;
    if (SetViewportExtEx(HDC32(parg16->f1),
                         INT32(parg16->f2),
                         INT32(parg16->f3),
                         &size)) {

        if (!(ul = (WORD)size.cx | (size.cy << 16)))    // see above
            ul = 1;
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32SetViewportOrg(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT pt;
    register PSETVIEWPORTORG16 parg16;

    GETARGPTR(pFrame, sizeof(SETVIEWPORTORG16), parg16);

    ul = 0;
    pt.x = 1L; // see "METAFILE NOTE"
    pt.y = 0L;
    if (SetViewportOrgEx(HDC32(parg16->f1),
                         INT32(parg16->f2),
                         INT32(parg16->f3),
                         &pt)) {

        ul = (WORD)pt.x | (pt.y << 16);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32SetWindowExt(PVDMFRAME pFrame)
{
    ULONG ul;
    SIZE size;
    register PSETWINDOWEXT16 parg16;

    GETARGPTR(pFrame, sizeof(SETWINDOWEXT16), parg16);

    ul = 0;
    if (SetWindowExtEx(HDC32(parg16->f1),
                       INT32(parg16->f2),
                       INT32(parg16->f3),
                       &size)) {
        if (!(ul = (WORD)size.cx | (size.cy << 16)))    // see above
            ul = 1;
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32SetWindowOrg(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT pt;
    register PSETWINDOWORG16 parg16;

    GETARGPTR(pFrame, sizeof(SETWINDOWORG16), parg16);

    ul = 0;
    pt.x = 1L; // see "METAFILE NOTE"
    pt.y = 0L;
    if (SetWindowOrgEx(HDC32(parg16->f1),
                       INT32(parg16->f2),
                       INT32(parg16->f3),
                       &pt)) {
        ul = (WORD)pt.x | (pt.y << 16);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32StretchDIBits(PVDMFRAME pFrame)
{
    ULONG        ul = 0L;
    PBYTE        pb10;
    STACKBMI32   bmi32;
    LPBITMAPINFO lpbmi32;
    register     PSTRETCHDIBITS16 parg16;

    GETARGPTR(pFrame, sizeof(STRETCHDIBITS16), parg16);
    GETMISCPTR(parg16->f10, pb10);

    lpbmi32 = CopyBMI16ToBMI32((PVPVOID)FETCHDWORD(parg16->f11),
                               (LPBITMAPINFO)&bmi32,
                               FETCHWORD(parg16->f12));

    // see if we need to adjust the image sze for RLE bitmaps
    if(lpbmi32 && pb10) {

        if((lpbmi32->bmiHeader.biCompression == BI_RLE4) ||
           (lpbmi32->bmiHeader.biCompression == BI_RLE8)) {

            if(lpbmi32->bmiHeader.biSizeImage == 0) {

                lpbmi32->bmiHeader.biSizeImage =
                     Get_RLE_Compression_Size(lpbmi32->bmiHeader.biCompression,
                                              pb10,
                                              parg16->f10);
            }
        }
    }

    ul = GETINT16(StretchDIBits(HDC32(parg16->f1),
                                INT32(parg16->f2),
                                INT32(parg16->f3),
                                INT32(parg16->f4),
                                INT32(parg16->f5),
                                INT32(parg16->f6),
                                INT32(parg16->f7),
                                INT32(parg16->f8),
                                INT32(parg16->f9),
                                pb10,
                                lpbmi32,
                                (DWORD)FETCHWORD(parg16->f12),
                                DWORD32(parg16->f13)));

    WOW32APIWARN (ul, "WG32StretchDIBits\n");

    FREEMISCPTR(pb10);
    FREEARGPTR(parg16);
    RETURN(ul);
}


//
// This routine calls back the apps SetAbortProc routine.
//

LONG W32AbortProc(HDC hPr, int code)
{
    LONG lReturn;
    PARM16 Parm16;
    register PTD ptd;
    DWORD AbortProcT;


    ptd = CURRENTPTD();

    WOW32ASSERT(ptd->htask16);

    AbortProcT = ((PTDB)SEGPTR(ptd->htask16, 0))->TDB_vpfnAbortProc;
    if (AbortProcT) {

        Parm16.SetAbortProc.hPr = GETHDC16(hPr);
        Parm16.SetAbortProc.code = (SHORT) code;

        CallBack16(RET_SETABORTPROC,
                   &Parm16,
                   AbortProcT,
                   (PVPVOID)&lReturn);

        lReturn = (LONG)LOWORD(lReturn);        // Returns a BOOL
    }
    else {
        lReturn = (LONG)TRUE;
    }

    return (lReturn);
}






// note: cb is the number of data bytes in lpData NOT including the USHORT byte
//       count at the start of the data stream. In other words, lpData contains
//       cb + sizeof(USHORT) bytes.
LONG HandleFormFeedHack(HDC hdc, LPBYTE lpdata, int cb)
{
    int           cbBytes;
    LONG          ul;
    PFORMFEEDHACK pCur;

    // look for a node with a pointer to a data stream buffer from the previous
    // call to Escape(,,PASSTHROUGH,,)...
    pCur = FindFormFeedHackNode(hdc);

    // if we found one, it's time to send the data stream to the printer...
    if(pCur) {

        // ...time to send it to the printer
        ul = GETINT16(Escape(hdc,
                             PASSTHROUGH,
                             pCur->cbBytes + sizeof(USHORT),
                             pCur->lpBytes,
                             NULL));

        // free the current node
        FreeFormFeedHackNode(pCur);

        // if there was a problem we're done
        if(ul <= 0) {
            return(ul);
        }
    }

    // send everything up to the last form feed in the new data stream
    cbBytes = cb;
    lpdata = SendFrontEndOfDataStream(hdc, lpdata, &cbBytes, &ul);

    // if there was a problem
    // OR if the entire data stream got sent since it didn't contain a formfeed
    // -- we're done
    if(lpdata == NULL) {
        return(ul);   // this will contain error code OR number of bytes sent
    }

    // else create a node for this data stream
    else {

        pCur = CreateFormFeedHackNode(hdc, cbBytes, lpdata);

        // if we can't allocate a new node...
        if(pCur == NULL) {

            // Things are in pretty bad shape if we get to here...
            // We need to write the byte count at the front of the data stream.
            // Remember lpdata had a word size byte count at the front of it
            // when it was sent to us.

            // if any bytes got sent via SendFrontEndOfDataStream()...
            if(cbBytes < cb) {

                // ...first we need to word align this for Escape32()...
                if((DWORD)lpdata & 0x00000001) {
                    lpdata--;
                    *lpdata = '\0'; // stick a harmless char in the stream
                    cbBytes++;      // ...and account for it
                }

                // ...adjust the data stream ptr to accomodate the byte count...
                lpdata -= sizeof(USHORT);

            }

            // ...write in the byte count...
            *(UNALIGNED USHORT *)lpdata = (USHORT)cbBytes;

            // ...and send the remainder of the data stream to the printer.
            // If an extra page gets sent to the printer, too bad.
            ul = GETINT16(Escape(hdc,
                                 PASSTHROUGH,
                                 cbBytes + sizeof(USHORT),
                                 lpdata,
                                 NULL));

            // if the was an error, return it to the app
            if(ul <= 0) {
                return(ul);
            }
            // else we managed to get everything sent to the printer OK
            else {
                return(cb); // return the number of bytes the app sent
            }
        }
    }

    // return the number of bytes the app requested to send
    return(cb);

}






LPBYTE SendFrontEndOfDataStream(HDC hdc, LPBYTE lpData, int *cb, LONG *ul)
{
    int    diff;
    LPBYTE lpByte, lpStart;

    // if there's no data or a bad cb, just send it so we can get the error code
    if((lpData == NULL) || (*cb <= 0)) {
        *ul = GETINT16(Escape(hdc,
                              PASSTHROUGH,
                              *cb + sizeof(USHORT),
                              lpData,
                              NULL));
        return(NULL);
    }

    // find the start of the actual data after the byte count
    lpStart = lpData + sizeof(USHORT);

    // look for a formfeed char at or near the end of the data stream
    lpByte = lpStart + ((*cb - 1) * sizeof(BYTE));
    while(lpByte >= lpStart) {

        // if we have found the odious formfeed char....
        if((UCHAR)(*lpByte) == 0x0c) {

            diff = lpByte - lpStart;

            // send everything in the stream up to (but not incl) the formfeed
            if(diff) {

                // adjust the byte count in the data stream
                *(UNALIGNED USHORT *)lpData = (USHORT)diff;

                // send it to the printer
                *ul = GETINT16(Escape(hdc,
                                      PASSTHROUGH,
                                      diff + sizeof(USHORT),
                                      lpData,
                                      NULL));

                // if there was a problem, return it to the app
                if(*ul <= 0) {
                    return(NULL);
                }
            }

            // else formfeed is the first char in the data stream
            else {
                *ul = *cb; // just lie and say we sent it all
            }

            // adjust the remaining number of bytes
            *cb -= diff;

            // return ptr to the formfeed char as new start of data stream
            return(lpByte);
        }

        lpByte--;
    }

    // if there are no formfeed's in the data stream just send the whole thing
    *ul = GETINT16(Escape(hdc,
                          PASSTHROUGH,
                          *cb + sizeof(USHORT),
                          lpData,
                          NULL));

    return(NULL);  // specify we sent the whole thing

}






// note: this assumes that if there is a node, there is a list
void FreeFormFeedHackNode(PFORMFEEDHACK pNode)
{
    PFORMFEEDHACK pCur, pPrev, pListStart;

    pPrev = NULL;
    pCur  = pListStart = gpFormFeedHackList;

    // if there is a node, there must be a node list
    WOW32ASSERT(pCur);

    if(pNode) {

        while(pCur) {

            if(pCur == pNode) {

                if(pNode->lpBytes) {
                    free_w(pNode->lpBytes);
                }

                if(pPrev) {
                   pPrev->next = pCur->next;
                }
                else {
                   pListStart = pCur->next;
                }

                free_w(pNode);
                break;
            }
            else {
                pPrev = pCur;
                pCur  = pCur->next;
            }
        }
    }

    gpFormFeedHackList = pListStart;
}





void FreeTaskFormFeedHacks(HAND16 h16)
{
    PFORMFEEDHACK pNext, pCur;

    pCur = gpFormFeedHackList;

    while(pCur) {

        if(pCur->hTask16 == h16) {

            // we already told the app we sent this so give it one last try
            Escape(pCur->hdc,
                   PASSTHROUGH,
                   pCur->cbBytes + sizeof(USHORT),
                   pCur->lpBytes,
                   NULL);

            pNext = pCur->next;
            if(pCur->lpBytes) {
                free_w(pCur->lpBytes);
            }

            if(pCur == gpFormFeedHackList) {
                gpFormFeedHackList = pNext;
            }

            free_w(pCur);

            pCur = pNext;
        }
    }
}






// this should only be called by Escape(,,ENDDOC,,)
void SendFormFeedHack(HDC hdc)
{
    int           cb;
    LPBYTE        pBytes = NULL;
    PFORMFEEDHACK pCur;

    pCur = gpFormFeedHackList;

    while(pCur) {

        if(pCur->hdc == hdc) {

            if(pCur->lpBytes) {

                cb = pCur->cbBytes;

                // point to actual data after byte count
                pBytes = pCur->lpBytes + sizeof(USHORT);

                // strip the form feed from the buffered data stream...
                if((UCHAR)(*pBytes) == 0x0c) {
                    *pBytes = '\0';
                    pBytes++;
                    cb--;
                }

                // strip the carriage ret from the buffered data stream...
                // (some apps put a carriage return after the last formfeed)
                if((UCHAR)(*pBytes) == 0x0d) {
                    *pBytes = '\0';
                    cb--;
                }

                // ...and send it to the printer
                if(cb > 0) {
                    Escape(hdc,
                           PASSTHROUGH,
                           cb + sizeof(USHORT),
                           pCur->lpBytes,
                           NULL);
                }
            }

            // free this node from the hack list now
            FreeFormFeedHackNode(pCur);

            break;
        }
        pCur = pCur->next;
    }
}





PFORMFEEDHACK FindFormFeedHackNode(HDC hdc)
{
    PFORMFEEDHACK  pCur;


    pCur = gpFormFeedHackList;

    while(pCur) {

        if(pCur->hdc == hdc) {
            return(pCur);
        }

        pCur = pCur->next;
    }

    return(NULL);
}




// this will only get called if PART of the data stream got sent to the printer
PFORMFEEDHACK CreateFormFeedHackNode(HDC hdc, int cb, LPBYTE lpData)
{
    LPBYTE         pBytes;
    PFORMFEEDHACK  pNode;

    // allocate a new node
    pNode = malloc_w(sizeof(FORMFEEDHACK));

    // if we were able to get one...
    if(pNode) {

        // ...allocate a buffer for the data stream
        pBytes = malloc_w(cb + sizeof(USHORT));

        // if we were able to get one...
        if(pBytes) {

            // ...fill in the node...
            pNode->hdc     = hdc;
            pNode->lpBytes = pBytes;
            pNode->cbBytes = cb;
            pNode->hTask16 = CURRENTPTD()->htask16;

            // ...and stick the new node at the front of the node list
            pNode->next        = gpFormFeedHackList;
            gpFormFeedHackList = pNode;

            // add the new size to the front of the data stream
            *(UNALIGNED USHORT *)pBytes = (USHORT)cb;
            pBytes += sizeof(USHORT);

            // copy the the data stream into the node buffer
            RtlCopyMemory(pBytes, lpData, cb);

            return(pNode);
        }

        // else if we couldn't get a data stream buffer...
        else {
            free_w(pNode);
        }
    }

    return(NULL);  // return NULL if either allocate failed
}






// this should only be called by Escape(,,AbortDOC,,) and AbortDoc()
void RemoveFormFeedHack(HDC hdc)
{
    PFORMFEEDHACK  pNode;

    pNode = FindFormFeedHackNode(hdc);

    if(pNode) {

        FreeFormFeedHackNode(pNode);
    }
}
#ifdef FE_SB //GetFontAssocStatus, pisuih, 10/5/94'
int GetFontAssocStatus(HDC hdc);                      //Modified by bklee. 02/01/95
ULONG FASTCALL WG32GetFontAssocStatus(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETFONTASSOCSTATUS16 parg16;

    GETARGPTR(pFrame, sizeof(GETFONTASSOCSTATUS16), parg16);

    ul = GetFontAssocStatus(HDC32(parg16->f1));

    FREEARGPTR(parg16);
    RETURN (ul);
}
#endif  //FE_SB



/*+++

  This returns the number of bytes in RLE4 and RLE8 compressed bitmaps.

  Code below fixes problems in Sounditoutland with RLE-encoded
  bitmaps which have biSizeImage == 0. On Win 3.1 they work since
  gdi is happy with decoding some piece of memory.  NT GDI however
  needs to know the size of bits passed.  We remedy this by calculating
  size using RET_GETDIBSIZE (GetSelectorLimit). GDI won't copy the
  memory, it will just use size as indication of accessibility
  Applications: "Sound It Out Land", QuarkXpress, KidPhonics

---*/

ULONG Get_RLE_Compression_Size(DWORD RLE_Type, PBYTE pStart, VPVOID vpBytes)
{

    BOOL   bDone  = FALSE;
    PBYTE  pBytes = pStart;
    PARM16 Parm16;
    ULONG  SelectorLimit;
    LONG   lSize;


    if(pBytes && vpBytes) {

        Parm16.WndProc.wParam = HIWORD(vpBytes);

        // get # bytes allocated to the selector (this even works for huge)
        CallBack16(RET_GETDIBSIZE, &Parm16, 0, (PVPVOID)&SelectorLimit);

        // is the selector valid?
        if(SelectorLimit != 0 && SelectorLimit != 0xffffffff) {

            // max byte buffer = memory block size - starting offset
            lSize = (LONG)SelectorLimit - LOWORD(vpBytes) + 1;

        } else {
            LOGDEBUG(LOG_ALWAYS, ("WOW:Get_RLE_Compression_Size: Selector [ptr:%x] is invalid\n", (DWORD)vpBytes));
            return(0);
        }

        while (!bDone) {

            // if absolute mode
            if (*pBytes == 0) {

                switch (pBytes[1]) {

                    case 0:     // end of line
                        pBytes += 2;
                        break;

                    case 1:     // end of bitmap
                        pBytes += 2;
                        bDone = TRUE;
                        break;

                    case 2:     // offset
                        pBytes += 4;
                        break;

                    default:
                        // align the bytes to word boundries
                        if(RLE_Type == BI_RLE4) {
                            pBytes += ((2 + ((pBytes[1] + 3) / 2)) & ~1);
                        } else {
                            pBytes += ((2 + pBytes[1] + 1) & ~1);
                        }

                        break;
                }

            } else {  // else encoded mode

                pBytes += 2;

            }

            // are we past the end of the selector?
            if ( lSize < (pBytes - pStart + 1) ) {
                LOGDEBUG(LOG_ALWAYS, ("WOW:Get_RLE_Compression_Size:Bad RLE size: %x < %x\n", lSize, (pBytes - pStart)));
                return(lSize);
            }
        }
    }

    return((ULONG)(pBytes - pStart));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgdi31.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGDI31.C
 *  WOW32 16-bit Win 3.1 GDI API support
 *
 *  History:
 *  Created 16-Mar-1992 by Chandan S. Chauhan (ChandanC)
 *
--*/

#include "precomp.h"
#pragma hdrstop
#include "wowgdip.h"

MODNAME(wgdi31.c);


// This must be removed POSTBETA 2 for sure. We should be using common defines between
// GDI and WOW. ChandanC 5/27/94.

#define NOFIRSTSAVE     0x7FFFFFFE
#define ADD_MSTT        0x7FFFFFFD

// located in wgdi.c
extern void SendFormFeedHack(HDC hdc);
extern void RemoveFormFeedHack(HDC hdc);


ULONG FASTCALL WG32AbortDoc(PVDMFRAME pFrame)
{
    ULONG    ul;
    register PABORTDOC16 parg16;

    GETARGPTR(pFrame, sizeof(ABORTDOC16), parg16);

    // remove any buffered data streams.
    if(CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_FORMFEEDHACK) {
        RemoveFormFeedHack(HDC32(parg16->f1));
    }

    ul = GETINT16(AbortDoc(HDC32(parg16->f1)));

    if ((INT)ul < 0) {
        WOW32ASSERT ("WOW::WG32AbortDoc: Failed\n");
    }

    FREEARGPTR(parg16);

    RETURN(ul);
}


ULONG FASTCALL WG32CreateScalableFontResource(PVDMFRAME pFrame)
{
    ULONG    ul;
    PSZ      t2;
    PSZ      t3;
    PSZ      t4;
    DWORD    fHidden;
    register PCREATESCALABLEFONTRESOURCE16 parg16;

    GETARGPTR(pFrame, sizeof(CREATESCALABLEFONTRESOURCE16), parg16);
    GETPSZPTR(parg16->f2, t2);
    GETPSZPTR(parg16->f3, t3);
    GETPSZPTR(parg16->f4, t4);

    // We need to convert this param to 2 if the app gives 1. This tells GDI
    // to embed client TID in the private (hidden) font.
    //

    fHidden = (parg16->f1 == 1) ? 2 : (parg16->f1);

    ul = GETBOOL16(CreateScalableFontResource(fHidden,
                                              t2,
                                              t3,
                                              t4));
    FREEARGPTR(parg16);

    RETURN(ul);
}


ULONG FASTCALL WG32EndDoc(PVDMFRAME pFrame)
{
    ULONG    ul;
    register PENDDOC16 parg16;

    GETARGPTR(pFrame, sizeof(ENDDOC16), parg16);

    // send any buffered data streams to the printer.
    if(CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_FORMFEEDHACK) {
        SendFormFeedHack(HDC32(parg16->f1));
    }

    ul = GETINT16(EndDoc(HDC32(parg16->f1)));

    FREEARGPTR(parg16);

    RETURN(ul);
}


ULONG FASTCALL WG32EnumFontFamilies(PVDMFRAME pFrame)
{
    return( W32EnumFontHandler(pFrame, TRUE) );
}


ULONG FASTCALL WG32GetAspectRatioFilterEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    SIZE     AspectRatio;
    register PGETASPECTRATIOFILTEREX16 parg16;

    GETARGPTR(pFrame, sizeof(GETASPECTRATIOFILTEREX16), parg16);

    ul = GETBOOL16(GetAspectRatioFilterEx(HDC32(parg16->f1), &AspectRatio));

    PUTSIZE16(parg16->f2, &AspectRatio);

    FREEARGPTR(parg16);

    RETURN(ul);
}


ULONG FASTCALL WG32GetBitmapDimensionEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    SIZE     Dimension;
    register PGETBITMAPDIMENSIONEX16 parg16;

    GETARGPTR(pFrame, sizeof(GETBITMAPDIMENSIONEX16), parg16);

    ul = GETBOOL16(GetBitmapDimensionEx(HBITMAP32(parg16->f1), &Dimension));

    PUTSIZE16(parg16->f2, &Dimension);

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32GetBoundsRect(PVDMFRAME pFrame)
{
    ULONG    ul = 0;
    RECT     Bounds;
    register PGETBOUNDSRECT16 parg16;

    GETARGPTR(pFrame, sizeof(GETBOUNDSRECT16), parg16);

    ul = GETUINT16(GetBoundsRect(HDC32(parg16->f1),
                                 &Bounds,
                                 UINT32(parg16->f3)));

    //
    // Win16 GetBoundsRect always returns DCB_SET or DCB_RESET.
    //
    ul = (ul & DCB_SET) ? DCB_SET : DCB_RESET;

    PUTRECT16(parg16->f2, &Bounds);

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32GetBrushOrgEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    POINT    Point;
    register PGETBRUSHORGEX16 parg16;

    GETARGPTR(pFrame, sizeof(GETBRUSHORGEX16), parg16);

    ul = GETBOOL16(GetBrushOrgEx(HDC32(parg16->f1), &Point));

    PUTPOINT16(parg16->f2, &Point);

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32GetCharABCWidths(PVDMFRAME pFrame)
{
    ULONG    ul=0;
    LPABC    lpAbc;
    WORD     cb;
    register PGETCHARABCWIDTHS16 parg16;

    GETARGPTR(pFrame, sizeof(GETCHARABCWIDTHS16), parg16);

    cb = WORD32(parg16->f3) - WORD32(parg16->f2) + 1;
    if (lpAbc = (LPABC) malloc_w (sizeof(ABC) * cb)) {
        ul = GETBOOL16(GetCharABCWidths(HDC32(parg16->f1),
                                        WORD32(parg16->f2),
                                        WORD32(parg16->f3),
                                        lpAbc));
        if (ul) {
            putabcpairs16(parg16->f4, cb, lpAbc);
        }

        free_w (lpAbc);
    }

    FREEARGPTR(parg16);
    RETURN (ul);
}



ULONG FASTCALL WG32GetCurrentPositionEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    POINT    Point;
    register PGETCURRENTPOSITIONEX16 parg16;

    GETARGPTR(pFrame, sizeof(GETCURRENTPOSITIONEX16), parg16);

    ul = GETBOOL16(GetCurrentPositionEx(HDC32(parg16->f1), &Point));

    PUTPOINT16(parg16->f2, &Point);

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32GetGlyphOutline(PVDMFRAME pFrame)
{
    ULONG        ul;
    LPSTR        lpBuffer;
    MAT2         Matrix;
    GLYPHMETRICS Metrics;
    register     PGETGLYPHOUTLINE16 parg16;

    GETARGPTR(pFrame, sizeof(GETGLYPHOUTLINE16), parg16);
    GETMAT2(parg16->f7, &Matrix);
    GETVDMPTR(parg16->f6, parg16->f5, lpBuffer);

    ul = GETDWORD16(GetGlyphOutlineWow(HDC32(parg16->f1),
                                    WORD32(parg16->f2),
                                    WORD32(parg16->f3),
                                    parg16->f4 ? &Metrics : (GLYPHMETRICS*)NULL,
                                    DWORD32(parg16->f5),
                                    lpBuffer,
                                    &Matrix));

    if ( FETCHDWORD(parg16->f4) != 0 ) {
        PUTGLYPHMETRICS16(FETCHDWORD(parg16->f4), &Metrics);
    }

    FREEVDMPTR(lpBuffer);
    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32GetKerningPairs(PVDMFRAME pFrame)
{
    ULONG        ul;
    LPKERNINGPAIR lpkrnpair = NULL;
    register     PGETKERNINGPAIRS16 parg16;

    GETARGPTR(pFrame, sizeof(GETKERNINGPAIRS16), parg16);

    if (FETCHDWORD(parg16->f3)) {
        lpkrnpair = (LPKERNINGPAIR) malloc_w (sizeof(KERNINGPAIR) * (parg16->f2));
        if (!lpkrnpair) {
            LOGDEBUG (0, ("WOW::WG32GetKeriningPairs: *** MALLOC failed ***\n"));
            FREEARGPTR(parg16);
            RETURN (0);
        }

    }

    ul = GetKerningPairs(HDC32(parg16->f1), parg16->f2, lpkrnpair);

    if (FETCHDWORD(parg16->f3)) {
        putkerningpairs16 (FETCHDWORD(parg16->f3), parg16->f2, lpkrnpair);
        free_w (lpkrnpair);
    }

    FREEARGPTR(parg16);
    RETURN (ul);
}


ULONG FASTCALL WG32GetOutlineTextMetrics(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETOUTLINETEXTMETRICS16 parg16;
    UINT    cb;
    UINT    new_cb;
    VPOUTLINETEXTMETRIC16   vpotm;
    LPOUTLINETEXTMETRIC lpBuffer;

    GETARGPTR(pFrame, sizeof(GETOUTLINETEXTMETRICS16), parg16);

    vpotm = (VPOUTLINETEXTMETRIC16)FETCHDWORD(parg16->f3);

    new_cb = cb = FETCHWORD(parg16->f2);

    if ( vpotm ) {
        new_cb += sizeof(OUTLINETEXTMETRIC) - sizeof(OUTLINETEXTMETRIC16);
        if (!(lpBuffer = (LPOUTLINETEXTMETRIC)malloc_w(new_cb))) {
            FREEARGPTR(parg16);
            RETURN (0);
        }
    } else {
        lpBuffer = NULL;
    }


    ul = GETDWORD16(GetOutlineTextMetrics(HDC32(parg16->f1), new_cb, lpBuffer));

    if ( vpotm ) {
        PUTOUTLINETEXTMETRIC16(vpotm, cb, lpBuffer);
        free_w( lpBuffer );
    } else {
        if ( ul != 0 ) {
            ul -= sizeof(OUTLINETEXTMETRIC) - sizeof(OUTLINETEXTMETRIC16);
        }
    }

    FREEARGPTR(parg16);

    RETURN (ul);
}

ULONG FASTCALL WG32GetRasterizerCaps(PVDMFRAME pFrame)
{
    ULONG ul;
    RASTERIZER_STATUS RStatus;
    register PGETRASTERIZERCAPS16 parg16;

    GETARGPTR(pFrame, sizeof(GETRASTERIZERCAPS16), parg16);

    ul = GETBOOL16(GetRasterizerCaps(&RStatus, INT32(parg16->f2)));

    PUTRASTERIZERSTATUS16(parg16->f1, &RStatus);

    FREEARGPTR(parg16);

    RETURN (ul);
}

#define PUTEXTSIZE16(vp, lp)               \
{                                          \
    PSIZE16 p16;                           \
    GETVDMPTR(vp, sizeof(SIZE16), p16);    \
    if (((lp)->cx|(lp)->cy) & ~SHRT_MAX)   \
    {                                      \
      if ((lp)->cx > SHRT_MAX)             \
        STORESHORT(p16->cx, SHRT_MAX);     \
      else                                 \
        STORESHORT(p16->cx, (lp)->cx);     \
      if ((lp)->cy > SHRT_MAX)             \
        STORESHORT(p16->cy, SHRT_MAX);     \
      else                                 \
        STORESHORT(p16->cy, (lp)->cy);     \
    }                                      \
    else                                   \
    {                                      \
      STORESHORT(p16->cx, (lp)->cx);       \
      STORESHORT(p16->cy, (lp)->cy);       \
    }                                      \
    FREEVDMPTR(p16);                       \
}


ULONG FASTCALL WG32GetTextExtentPoint(PVDMFRAME pFrame)
{
    ULONG    ul;
    PSZ      lpString;
    SIZE     Size;
    register PGETTEXTEXTENTPOINT16 parg16;
    HDC hDC32;
    HDC hDCMenu = NULL;
    HGDIOBJ hOldFont;
    HGDIOBJ hFont = NULL;
    NONCLIENTMETRICS ncm;
    PTD ptd = CURRENTPTD();

    GETARGPTR(pFrame, sizeof(GETTEXTEXTENTPOINT16), parg16);
    GETPSZPTR(parg16->f2, lpString);

    hDC32 = HDC32(parg16->f1);

// WP tutorial assumes that the font selected in the hDC for desktop window
// (ie, result of GetDC(NULL)) is the same font as the font selected for
// drawing the menu. Unfortunetly in SUR this is not true as the user can
// select any font for the menu. So we remember the hDC returned for GetDC(0)
// and check for it in GetTextExtentPoint. If the app does try to use it we
// find the hDC for the current menu window and substitute that. When the app
// does another GetDC or ReleaseDC we forget the hDC returned for the original
// GetDC(0).
    if ((ptd->dwWOWCompatFlagsEx & WOWCFEX_FIXDCFONT4MENUSIZE) &&
        (parg16->f1 == ptd->ulLastDesktophDC) &&
        ((hDCMenu = GetDC(NULL)) != NULL) &&
        ((ncm.cbSize = sizeof(NONCLIENTMETRICS)) != 0) &&
        (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, (PVOID)&ncm, 0)) &&
        ((hFont = CreateFontIndirect(&(ncm.lfMenuFont))) != NULL)) {
            hOldFont = SelectObject(hDCMenu, hFont);
            hDC32 = hDCMenu;
    }

    ul = GETBOOL16(GetTextExtentPoint(hDC32,
                                      lpString,
                                      INT32(parg16->f3),
                                      &Size));

    if (hDCMenu != NULL) {

        if (hFont != NULL) {
            SelectObject(hDCMenu, hOldFont);
            DeleteObject(hFont);
        }

        ReleaseDC(NULL, hDCMenu);
    }


    PUTEXTSIZE16(parg16->f4, &Size);

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32GetViewportExtEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    SIZE     Size;
    register PGETVIEWPORTEXTEX16 parg16;

    GETARGPTR(pFrame, sizeof(GETVIEWPORTEXTEX16), parg16);

    ul = GETBOOL16(GetViewportExtEx(HDC32(parg16->f1), &Size));

    PUTSIZE16(parg16->f2, &Size);

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32GetViewportOrgEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    POINT    Point;
    register PGETVIEWPORTORGEX16 parg16;

    GETARGPTR(pFrame, sizeof(GETVIEWPORTORGEX16), parg16);

    ul = GETBOOL16(GetViewportOrgEx(HDC32(parg16->f1), &Point));

    PUTPOINT16(parg16->f2, &Point);

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32GetWindowExtEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    SIZE     Size;
    register PGETWINDOWEXTEX16 parg16;

    GETARGPTR(pFrame, sizeof(GETWINDOWEXTEX16), parg16);

    ul = GETBOOL16(GetWindowExtEx( HDC32(parg16->f1),&Size));

    PUTSIZE16(parg16->f2, &Size);

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32GetWindowOrgEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    POINT    Point;
    register PGETWINDOWORGEX16 parg16;

    GETARGPTR(pFrame, sizeof(GETWINDOWORGEX16), parg16);

    ul = GETBOOL16(GetWindowOrgEx(HDC32(parg16->f1), &Point));

    PUTPOINT16(parg16->f2, &Point);

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32MoveToEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    POINT    Point;
    LPPOINT  lpPoint = NULL;
    register PMOVETOEX16 parg16;

    GETARGPTR(pFrame, sizeof(MOVETOEX16), parg16);

    if (parg16->f4) {
        lpPoint = &Point;
    }

    ul = GETBOOL16(MoveToEx(HDC32(parg16->f1),
                            INT32(parg16->f2),
                            INT32(parg16->f3),
                            lpPoint));
    if (parg16->f4) {
        PUTPOINT16(parg16->f4, lpPoint);
    }

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32OffsetViewportOrgEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    POINT    Point;
    LPPOINT  lpPoint = NULL;
    register POFFSETVIEWPORTORGEX16 parg16;

    GETARGPTR(pFrame, sizeof(OFFSETVIEWPORTEX16), parg16);

    if (parg16->f4) {
        lpPoint = &Point;
    }

    ul = GETBOOL16(OffsetViewportOrgEx(HDC32(parg16->f1),
                                       INT32(parg16->f2),
                                       INT32(parg16->f3),
                                       lpPoint));

    if (parg16->f4) {
        PUTPOINT16(parg16->f4, lpPoint);
    }

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32OffsetWindowOrgEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    POINT    Point;
    LPPOINT  lpPoint = NULL;
    register POFFSETWINDOWORGEX16 parg16;

    GETARGPTR(pFrame, sizeof(OFFSETWINDOWORGEX16), parg16);

    if (parg16->f4) {
        lpPoint = &Point;
    }

    ul = GETBOOL16(OffsetWindowOrgEx(HDC32(parg16->f1),
                                     INT32(parg16->f2),
                                     INT32(parg16->f3),
                                     lpPoint));

    if (parg16->f4) {
        PUTPOINT16(parg16->f4, lpPoint);
    }

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32ResetDC(PVDMFRAME pFrame)
{
    ULONG     ul = 0;
    LPDEVMODE lpInitData;
    register  PRESETDC16 parg16;

    GETARGPTR(pFrame, sizeof(RESETDC16), parg16);

    if( lpInitData = ThunkDevMode16to32(FETCHDWORD(parg16->f2)) ) {

        // send any buffered data streams.
        if(CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_FORMFEEDHACK) {
            SendFormFeedHack(HDC32(parg16->f1));
        }

        ul = GETHDC16(ResetDC(HDC32(parg16->f1), lpInitData));

        FREEDEVMODE32(lpInitData);

    }

    RETURN (ul);
}


ULONG FASTCALL WG32ScaleViewportExtEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    SIZE     Size;
    LPSIZE   lpSize = NULL;
    register PSCALEVIEWPORTEXTEX16 parg16;

    GETARGPTR(pFrame, sizeof(SCALEVIEWPORTEXTEX16), parg16);

    if (parg16->f6) {
        lpSize = &Size;
    }

    ul = GETBOOL16(ScaleViewportExtEx(HDC32(parg16->f1),
                                      INT32(parg16->f2),
                                      INT32(parg16->f3),
                                      INT32(parg16->f4),
                                      INT32(parg16->f5),
                                      lpSize));
    if (parg16->f6) {
        PUTSIZE16(parg16->f6, lpSize);
    }

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32ScaleWindowExtEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    SIZE     Size;
    LPSIZE   lpSize = NULL;
    register PSCALEWINDOWEXTEX16 parg16;

    GETARGPTR(pFrame, sizeof(SCALEWINDOWEXTEX16), parg16);

    if (parg16->f6) {
        lpSize = &Size;
    }

    ul = GETBOOL16(ScaleWindowExtEx(HDC32(parg16->f1),
                                    INT32(parg16->f2),
                                    INT32(parg16->f3),
                                    INT32(parg16->f4),
                                    INT32(parg16->f5),
                                    lpSize));
    if (parg16->f6) {
        PUTSIZE16(parg16->f6, lpSize);
    }

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32SetAbortProc(PVDMFRAME pFrame)
{
    ULONG    ul;
    register PSETABORTPROC16 parg16;

    GETARGPTR(pFrame, sizeof(SETABORTPROC16), parg16);

    ((PTDB)SEGPTR(pFrame->wTDB, 0))->TDB_vpfnAbortProc = FETCHDWORD(parg16->f2);

    ul = GETINT16(SetAbortProc(HDC32(parg16->f1), (ABORTPROC) W32AbortProc));

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32SetBitmapDimensionEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    SIZE     Size;
    LPSIZE   lpSize = NULL;
    register PSETBITMAPDIMENSIONEX16 parg16;

    GETARGPTR(pFrame, sizeof(SETBITMAPDIMENSIONEX16), parg16);

    if (parg16->f4) {
        lpSize = &Size;
    }

    ul = GETBOOL16(SetBitmapDimensionEx(HBITMAP32(parg16->f1),
                                        INT32(parg16->f2),
                                        INT32(parg16->f3),
                                        lpSize));
    if (parg16->f4) {
        PUTSIZE16(parg16->f4, lpSize);
    }

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32SetBoundsRect(PVDMFRAME pFrame)
{
    ULONG    ul = 0;
    RECT     rcBounds;
    register PSETBOUNDSRECT16 parg16;

    GETARGPTR(pFrame, sizeof(SETBOUNDSRECT16), parg16);
    GETRECT16(parg16->f2, &rcBounds);

    ul = GETWORD16(SetBoundsRect(HDC32(parg16->f1),
                                 &rcBounds,
                                 WORD32(parg16->f3)));

    FREEARGPTR(parg16);

    RETURN (ul);
}


#if 0  // implemented in gdi.exe

ULONG FASTCALL WG32SetMetaFileBitsBetter(PVDMFRAME pFrame)
{
    return(WG32SetMetaFileBits(pFrame));
}

#endif

ULONG FASTCALL WG32SetViewportExtEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    SIZE     Size;
    LPSIZE   lpSize = NULL;
    register PSETVIEWPORTEXTEX16 parg16;

    GETARGPTR(pFrame, sizeof(SETVIEWPORTEXTEX16), parg16);

    if (parg16->f4) {
        lpSize = &Size;
    }

    ul = GETBOOL16(SetViewportExtEx(HDC32(parg16->f1),
                                    INT32(parg16->f2),
                                    INT32(parg16->f3),
                                    lpSize));

    if (parg16->f4) {
        PUTSIZE16(parg16->f4, lpSize);
    }

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32SetViewportOrgEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    POINT    Point;
    LPPOINT  lpPoint = NULL;
    register PSETVIEWPORTORGEX16 parg16;

    GETARGPTR(pFrame, sizeof(SETVIEWPORTORGEX16), parg16);

    if (parg16->f4) {
        lpPoint = &Point;
    }

    ul = GETBOOL16(SetViewportOrgEx(HDC32(parg16->f1),
                                    INT32(parg16->f2),
                                    INT32(parg16->f3),
                                    lpPoint));
    if (parg16->f4) {
        PUTPOINT16(parg16->f4, lpPoint);
    }

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32SetWindowExtEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    SIZE     Size;
    LPSIZE   lpSize = NULL;
    register PSETWINDOWEXTEX16 parg16;

    GETARGPTR(pFrame, sizeof(SETWINDOWEXTEX16), parg16);

    if (parg16->f4) {
        lpSize = &Size;
    }

    ul = GETBOOL16(SetWindowExtEx(HDC32(parg16->f1),
                                  INT32(parg16->f2),
                                  INT32(parg16->f3),
                                  lpSize));
    if (parg16->f4) {
        PUTSIZE16(parg16->f4, lpSize);
    }

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32SetWindowOrgEx(PVDMFRAME pFrame)
{
    ULONG    ul;
    POINT    Point;
    LPPOINT  lpPoint = NULL;
    register PSETWINDOWORGEX16 parg16;

    GETARGPTR(pFrame, sizeof(SETWINDOWORGEX16), parg16);

    if (parg16->f4) {
        lpPoint = &Point;
    }

    ul = GETBOOL16(SetWindowOrgEx(HDC32(parg16->f1),
                                  INT32(parg16->f2),
                                  INT32(parg16->f3),
                                  lpPoint));

    if (parg16->f4) {
        PUTPOINT16(parg16->f4, lpPoint);
    }

    FREEARGPTR(parg16);

    RETURN (ul);
}


ULONG FASTCALL WG32StartDoc(PVDMFRAME pFrame)
{
    ULONG       ul;
    VPVOID      vpDocName;
    VPVOID      vpOutput;
    DOCINFO     DocInfo;
    LPDOCINFO16 pdi16;
    register    PSTARTDOC16 parg16;

    GETARGPTR(pFrame, sizeof(STARTDOC16), parg16);
    GETVDMPTR(parg16->f2, sizeof(DOCINFO16), pdi16);

    //
    // Win32 StartDoc depends on having the correct current directory
    // when printing to FILE: (which pops up for a filename).
    //

    UpdateDosCurrentDirectory(DIR_DOS_TO_NT);

    DocInfo.cbSize = sizeof(DOCINFO);

    vpDocName = FETCHDWORD(pdi16->lpszDocName);
    vpOutput  = FETCHDWORD(pdi16->lpszOutput);

    GETPSZPTR(vpDocName, DocInfo.lpszDocName);
    GETPSZPTR(vpOutput, DocInfo.lpszOutput);

    DocInfo.lpszDatatype = NULL;
    DocInfo.fwType       = 0;

    FREEVDMPTR(pdi16);

    ul = GETINT16(StartDoc(HDC32(parg16->f1), &DocInfo));

    if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_NOFIRSTSAVE) {
        int l;
        char szBuf[80];

        if ((l = ExtEscape(HDC32(parg16->f1),
                                    GETTECHNOLOGY,
                                    0,
                                    NULL,
                                    sizeof(szBuf),
                                    szBuf)) > 0) {

            if (!WOW32_stricmp(szBuf, szPostscript)) {
                l = ExtEscape(HDC32(parg16->f1),
                        NOFIRSTSAVE,
                        0,
                        NULL,
                        0,
                        NULL);

                // This HACK is for FH4.0 only. If you have any questions
                // talk to PingW or ChandanC.
                // July 21st 1994.
                //
                if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_ADD_MSTT) {
                    l = ExtEscape(HDC32(parg16->f1),
                        ADD_MSTT,
                        0,
                        NULL,
                        0,
                        NULL);
                }
            }
        }
    }

    FREEPSZPTR(DocInfo.lpszDocName);
    FREEPSZPTR(DocInfo.lpszOutput);
    FREEARGPTR(parg16);

    RETURN (ul);
}


// InquireVisRgn is an undocumented Win 3.1 API. This code has been
// suggested by ChuckWh. If this does not fix the FileMaker Pro 2.0
// problem, then ChuckWh would be providing us with an private entry
// point.
// ChandanC 7th Feb 93
//

HRGN ghrgnVis = NULL;


ULONG FASTCALL WG32InquireVisRgn(PVDMFRAME pFrame)
{
    register PINQUIREVISRGN16 parg16;
    extern int GetRandomRgn(HDC hdc, HRGN hrgn, int cmd);

    GETARGPTR(pFrame, sizeof(INQUIREVISRGN16), parg16);

    // call special gdi entry point to get copy of vis rgn

    GetRandomRgn(HDC32(parg16->f1), ghrgnVis, 4);

    FREEARGPTR(parg16);

    RETURN (GETHRGN16(ghrgnVis));
}


BOOL InitVisRgn()
{
    ghrgnVis = CreateRectRgn(0,0,0,0);

    return(ghrgnVis != NULL);
}


VOID putabcpairs16(VPABC16 vpAbc, UINT cb, LPABC lpAbc)
{
    UINT i;
    register PABC16 pAbc16;

    GETVDMPTR(vpAbc, sizeof(ABC16), pAbc16);

    for (i=0; i < cb; i++) {
        pAbc16[i].abcA = (INT16) lpAbc[i].abcA;
        pAbc16[i].abcB = (WORD)  lpAbc[i].abcB;
        pAbc16[i].abcC = (INT16) lpAbc[i].abcC;
    }

    FLUSHVDMPTR(vpAbc, sizeof(ABC16), pAbc16);
    FREEVDMPTR(pAbc16);
}


ULONG FASTCALL WG32GetClipRgn(PVDMFRAME pFrame)
{
    register PGETCLIPRGN16 parg16;

    // this is a private win3.1 entry pointed defined as HRGN GetClipRgn(HDC);
    // NT exports the entry point defined as DWORD GetClipRgn(HDC,HRGN);
    // NT will not give out the handle to its internal cliprgn so instead
    // makes a copy.  Any app uses this private win3.1 entry point will
    // have a global region created for it that will go away when the
    // app goes away.

    GETARGPTR(pFrame, sizeof(GETCLIPRGN16), parg16);

    if (CURRENTPTD()->hrgnClip == NULL)
        CURRENTPTD()->hrgnClip = CreateRectRgn(0,0,0,0);

    GetClipRgn(HDC32(parg16->f1), CURRENTPTD()->hrgnClip);

    FREEARGPTR(parg16);

    RETURN (GETHRGN16(CURRENTPTD()->hrgnClip));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgdi31.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGDI31.H
 *  WOW32 16-bit Win 3.1 GDI API support
 *
 *  History:
 *  Created 16-Mar-1992 by Chandan S. Chauhan (ChandanC)
--*/

#define PUTSIZE16(vp, lp) {\
    PSIZE16 p16;\
    GETVDMPTR(vp, sizeof(SIZE16), p16);\
    STORESHORT(p16->cx, (lp)->cx);\
    STORESHORT(p16->cy, (lp)->cy);\
    FREEVDMPTR(p16);\
    }

#define PUTRASTERIZERSTATUS16(vp, lp) {\
    PRASTERIZER_STATUS16 p16;\
    GETVDMPTR(vp, sizeof(RASTERIZER_STATUS16), p16);\
    STORESHORT(p16->nSize, (lp)->nSize);\
    STORESHORT(p16->wFlags, (lp)->wFlags);\
    STORESHORT(p16->nLanguageID, (lp)->nLanguageID);\
    FREEVDMPTR(p16);\
    }

#define PUTGLYPHMETRICS16(vp, lp) {\
    PGLYPHMETRICS16 p16;\
    GETVDMPTR(vp, sizeof(GLYPHMETRICS16), p16);\
    STOREWORD(p16->gmBlackBoxX, (lp)->gmBlackBoxX);\
    STOREWORD(p16->gmBlackBoxY, (lp)->gmBlackBoxY );\
    STORESHORT(p16->gmptGlyphOrigin.x, (lp)->gmptGlyphOrigin.x);\
    STORESHORT(p16->gmptGlyphOrigin.y, (lp)->gmptGlyphOrigin.y);\
    STORESHORT(p16->gmCellIncX, (lp)->gmCellIncX);\
    STORESHORT(p16->gmCellIncY, (lp)->gmCellIncY);\
    FREEVDMPTR(p16);\
    }

#define GETMAT2(vp, lp) {\
    PMAT216 p16;\
    GETVDMPTR(vp, sizeof(MAT216), p16);\
    (lp)->eM11.fract = FETCHWORD(p16->eM11.fract);\
    (lp)->eM11.value = FETCHSHORT(p16->eM11.value);\
    (lp)->eM12.fract = FETCHWORD(p16->eM12.fract);\
    (lp)->eM12.value = FETCHSHORT(p16->eM12.value);\
    (lp)->eM21.fract = FETCHWORD(p16->eM21.fract);\
    (lp)->eM21.value = FETCHSHORT(p16->eM21.value);\
    (lp)->eM22.fract = FETCHWORD(p16->eM22.fract);\
    (lp)->eM22.value = FETCHSHORT(p16->eM22.value);\
    FREEVDMPTR(p16);\
    }


ULONG FASTCALL WG32AbortDoc(PVDMFRAME pFrame);
ULONG FASTCALL WG32CreateScalableFontResource(PVDMFRAME pFrame);
ULONG FASTCALL WG32EndDoc(PVDMFRAME pFrame);
ULONG FASTCALL WG32EnumFontFamilies(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetAspectRatioFilterEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetBitmapDimensionEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetBoundsRect(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetBrushOrgEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetCharABCWidths(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetCurrentPositionEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetGlyphOutline(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetKerningPairs(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetOutlineTextMetrics(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetTextExtentPoint(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetViewportExtEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetViewportOrgEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetWindowExtEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetWindowOrgEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32MoveToEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32OffsetViewportOrgEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32OffsetWindowOrgEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32ResetDC(PVDMFRAME pFrame);
ULONG FASTCALL WG32ScaleViewportExtEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32ScaleWindowExtEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32SetAbortProc(PVDMFRAME pFrame);
ULONG FASTCALL WG32SetBitmapDimensionEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32SetBoundsRect(PVDMFRAME pFrame);
ULONG FASTCALL WG32SetMetaFileBitsBetter(PVDMFRAME pFrame);
ULONG FASTCALL WG32SetViewportExtEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32SetViewportOrgEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32SetWindowExtEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32SetWindowOrgEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32StartDoc(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetRasterizerCaps(PVDMFRAME pFrame);

VOID  putabcpairs16(VPABC16 vpAbc, UINT c, LPABC lpAbc);

ULONG FASTCALL WG32InquireVisRgn(PVDMFRAME pFrame);
BOOL  InitVisRgn();
ULONG FASTCALL WG32GetClipRgn(PVDMFRAME pFrame);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wdos.h ===
/* wdos.h - DOS Defines for WOW
 *
 * Modification History
 *
 * Sudeepb 23-Aug-1991 Created
 */

ULONG FASTCALL   WK32SetDefaultDrive(PVDMFRAME pFrame);
ULONG FASTCALL   WK32GetCurrentDirectory(PVDMFRAME pFrame);
ULONG FASTCALL   WK32SetCurrentDirectory(PVDMFRAME pFrame);
ULONG FASTCALL   WK32GetCurrentDate(PVDMFRAME pFrame);
ULONG FASTCALL   WK32DeviceIOCTL(PVDMFRAME pFrame);
ULONG FASTCALL   WK32WOWGetFlatAddressArray(PVDMFRAME pFrame);

ULONG DosWowSetDefaultDrive (UCHAR);
ULONG DosWowGetCurrentDirectory (UCHAR, LPSTR);
ULONG DosWowSetCurrentDirectory (LPSTR);

typedef enum {
    DIR_NT_TO_DOS,
    DIR_DOS_TO_NT,
} UDCDFUNC;

BOOL UpdateDosCurrentDirectory(UDCDFUNC fDir);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgdi.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGDI.H
 *  WOW32 16-bit GDI API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/

typedef struct _LINEDDADATA {   /* LineDDAdata */
    VPPROC  vpfnLineDDAProc;    // 16-bit function
    DWORD   dwUserDDAParam;     // user param, if any
} LINEDDADATA, *PLINEDDADATA;

typedef struct _ENUMOBJDATA {   /* LineDDAdata */
    INT     ObjType;
    VPPROC  vpfnEnumObjProc;     // 16-bit function
    VPVOID  vpObjData;
    DWORD   dwUserParam;         // user param, if any
} ENUMOBJDATA, *PENUMOBJDATA;

// 16-bit version of DRAWPATRECT which is used in Windows 3.1
typedef struct _DRAWPATRECT16 {
        POINT16 ptPosition;
        POINT16 ptSize;
        WORD wStyle;
        WORD wPattern;
} DRAWPATRECT16, *PDPR16;

ULONG FASTCALL   WG32CreateBitmap(PVDMFRAME pFrame);
ULONG FASTCALL   WG32CreateBitmapIndirect(PVDMFRAME pFrame);
ULONG FASTCALL   WG32CreateBrushIndirect(PVDMFRAME pFrame);
ULONG FASTCALL   WG32CreateCompatibleDC(PVDMFRAME pFrame);
ULONG FASTCALL   WG32CreateDC(PVDMFRAME pFrame);
ULONG FASTCALL   WG32CreateDIBPatternBrush(PVDMFRAME pFrame);
ULONG FASTCALL   WG32CreateDIBitmap(PVDMFRAME pFrame);
ULONG FASTCALL   WG32CreateEllipticRgnIndirect(PVDMFRAME pFrame);
ULONG FASTCALL   WG32CreateIC(PVDMFRAME pFrame);
ULONG FASTCALL   WG32CreatePatternBrush(PVDMFRAME pFrame);
ULONG FASTCALL   WG32CreatePenIndirect(PVDMFRAME pFrame);
ULONG FASTCALL   WG32CreatePolyPolygonRgn(PVDMFRAME pFrame);
ULONG FASTCALL   WG32CreatePolygonRgn(PVDMFRAME pFrame);
ULONG FASTCALL   WG32CreateRectRgnIndirect(PVDMFRAME pFrame);
ULONG FASTCALL   WG32DPtoLP(PVDMFRAME pFrame);
ULONG FASTCALL   WG32DeleteDC(PVDMFRAME pFrame);
ULONG FASTCALL   WG32DeleteObject(PVDMFRAME pFrame);
ULONG FASTCALL   WG32DeviceMode(PVDMFRAME pFrame);
ULONG FASTCALL   WG32EnumObjects(PVDMFRAME pFrame);
ULONG FASTCALL   WG32Escape(PVDMFRAME pFrame);
ULONG FASTCALL   WG32ExtDeviceMode(PVDMFRAME pFrame);
ULONG FASTCALL   WG32DeviceCapabilities(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetBitmapDimension(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetBrushOrg(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetClipBox(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetCurLogFont(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetCurrentPosition(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetDCOrg(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetDIBits(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetDeviceCaps(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetEnvironment(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetObject(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetObjectType(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetRgnBox(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetViewportExt(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetViewportOrg(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetWindowExt(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetWindowOrg(PVDMFRAME pFrame);
ULONG FASTCALL   WG32LPtoDP(PVDMFRAME pFrame);
ULONG FASTCALL   WG32LineDDA(PVDMFRAME pFrame);
ULONG FASTCALL   WG32MoveTo(PVDMFRAME pFrame);
ULONG FASTCALL   WG32OffsetViewportOrg(PVDMFRAME pFrame);
ULONG FASTCALL   WG32OffsetWindowOrg(PVDMFRAME pFrame);
ULONG FASTCALL   WG32PolyPolygon(PVDMFRAME pFrame);
ULONG FASTCALL   WG32Polygon(PVDMFRAME pFrame);
ULONG FASTCALL   WG32Polyline(PVDMFRAME pFrame);
ULONG FASTCALL   WG32PolyPolylineWOW(PVDMFRAME pFrame);
ULONG FASTCALL   WG32RectInRegion(PVDMFRAME pFrame);
ULONG FASTCALL   WG32RectVisible(PVDMFRAME pFrame);
ULONG FASTCALL   WG32ScaleViewportExt(PVDMFRAME pFrame);
ULONG FASTCALL   WG32ScaleWindowExt(PVDMFRAME pFrame);
LONG             W32AbortProc(HDC hPr, int code);
ULONG FASTCALL   WG32SetBitmapBits(PVDMFRAME pFrame);
ULONG FASTCALL   WG32SetBitmapDimension(PVDMFRAME pFrame);
ULONG FASTCALL   WG32SetBrushOrg(PVDMFRAME pFrame);
ULONG FASTCALL   WG32SetDIBits(PVDMFRAME pFrame);
ULONG FASTCALL   WG32SetDIBitsToDevice(PVDMFRAME pFrame);
ULONG FASTCALL   WG32SetViewportExt(PVDMFRAME pFrame);
ULONG FASTCALL   WG32SetViewportOrg(PVDMFRAME pFrame);
ULONG FASTCALL   WG32SetWindowExt(PVDMFRAME pFrame);
ULONG FASTCALL   WG32SetWindowOrg(PVDMFRAME pFrame);
ULONG FASTCALL   WG32StretchDIBits(PVDMFRAME pFrame);
ULONG FASTCALL   WG32CreateDIBSection(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetDIBColorTable(PVDMFRAME pFrame);
ULONG FASTCALL   WG32SetDIBColorTable(PVDMFRAME pFrame);
ULONG FASTCALL   WG32DMBitBlt(PVDMFRAME pFrame);

BOOL  IsFaxPrinterSupportedDevice(PSZ pszDevice);
BOOL  IsFaxPrinterWriteProfileString(PSZ szSection, PSZ szKey, PSZ szString);
DWORD GetFaxPrinterProfileString(PSZ szSection, PSZ szKey, PSZ szDefault, PSZ szRetBuf, DWORD cbBufSize);

ULONG Get_RLE_Compression_Size(DWORD RLE_Type, PBYTE pStart, VPVOID vpBytes);

HANDLE hConvert16to32 (int h16);
HAND16 hConvert32to16 (DWORD h32);

#ifdef FE_SB //GetFontAssocStatus, pisuih, 10/5/94'
ULONG FASTCALL   WG32GetFontAssocStatus(PVDMFRAME pFrame);
#endif  //FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgfont.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGFONT.C
 *  WOW32 16-bit GDI API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/


#include "precomp.h"
#pragma hdrstop
#include "wingdip.h"

MODNAME(wgfont.c);

extern int RemoveFontResourceTracking(LPCSTR psz, UINT id);
extern int AddFontResourceTracking(LPCSTR psz, UINT id);


// for Quickbooks v4 & v5 OCR font support
void LoadOCRFont(void);
char szOCRA[]      = "OCR-A";
char szFonts[]     = "\\FONTS";
char szOCRDotTTF[] = "\\OCR-A.TTF";
BOOL gfOCRFontLoaded = FALSE;


// a.k.a. WOWAddFontResource
ULONG FASTCALL WG32AddFontResource(PVDMFRAME pFrame)
{
    ULONG    ul;
    PSZ      psz1;
    register PADDFONTRESOURCE16 parg16;

    GETARGPTR(pFrame, sizeof(ADDFONTRESOURCE16), parg16);
    GETPSZPTR(parg16->f1, psz1);

    // note: we will never get an hModule in the low word here.
    //       the 16-bit side resolves hModules to an lpsz before calling us

    if( CURRENTPTD()->dwWOWCompatFlags & WOWCF_UNLOADNETFONTS )
    {
        ul = GETINT16(AddFontResourceTracking(psz1,(UINT)CURRENTPTD()));
    }
    else
    {
        ul = GETINT16(AddFontResourceA(psz1));
    }

    FREEPSZPTR(psz1);
    FREEARGPTR(parg16);

    RETURN(ul);
}


#define PITCH_MASK  ( FIXED_PITCH | VARIABLE_PITCH )

ULONG FASTCALL WG32CreateFont(PVDMFRAME pFrame)
{
    ULONG    ul;
    PSZ      psz14;
    register PCREATEFONT16 parg16;
    INT      iWidth;
    char     achCapString[LF_FACESIZE];
    BYTE     lfCharSet;
    BYTE     lfPitchAndFamily;
#ifdef FE_SB
    BOOL     bUseAlternateFace = FALSE;
#endif    

    GETARGPTR(pFrame, sizeof(CREATEFONT16), parg16);
    GETPSZPTR(parg16->f14, psz14);

    // take careof compatiblity flags:
    //   if a specific width is specified and GACF_30AVGWIDTH compatiblity
    //   flag is set, scaledown the width by 7/8.
    //

    iWidth = INT32(parg16->f2);
    if (iWidth != 0 &&
           (W32GetAppCompatFlags((HAND16)NULL) & GACF_30AVGWIDTH)) {
        iWidth = (iWidth * 7) / 8;
    }

    lfCharSet        = BYTE32(parg16->f9);
    lfPitchAndFamily = BYTE32(parg16->f13);

#ifdef FE_SB
    if (psz14 && *psz14)
#else // !FE_SB
    if (psz14)
#endif // !FE_SB
    {
        // Capitalize the string for faster compares.

        WOW32_strncpy(achCapString, psz14, LF_FACESIZE);
        WOW32_strupr(achCapString);

        // Here we are going to implement a bunch of Win 3.1 hacks rather
        // than contaminate the 32-bit engine.  These same hacks can be found
        // in WOW (in the CreateFont/CreateFontIndirect code).
        //
        // These hacks are keyed off the facename in the LOGFONT.  String
        // comparisons have been unrolled for maximal performance.

        // Win 3.1 facename-based hack.  Some apps, like
        // Publisher, create a "Helv" font but have the lfPitchAndFamily
        // set to specify FIXED_PITCH.  To work around this, we will patch
        // the pitch field for a "Helv" font to be variable.

        if ( !WOW32_strcmp(achCapString, szHelv) )
        {
            lfPitchAndFamily |= ( (lfPitchAndFamily & ~PITCH_MASK) | VARIABLE_PITCH );
        }
        else
        {
            // Win 3.1 hack for Legacy 2.0.  When a printer does not enumerate
            // a "Tms Rmn" font, the app enumerates and gets the LOGFONT for
            // "Script" and then create a font with the name "Tms Rmn" but with
            // the lfCharSet and lfPitchAndFamily taken from the LOGFONT for
            // "Script".  Here we will over the lfCharSet to be ANSI_CHARSET.

            if ( !WOW32_strcmp(achCapString, szTmsRmn) )
            {
                lfCharSet = ANSI_CHARSET;
            }
            else
            {
                // If the lfFaceName is "Symbol", "Zapf Dingbats", or "ZapfDingbats",
                // enforce lfCharSet to be SYMBOL_CHARSET.  Some apps (like Excel) ask
                // for a "Symbol" font but have the char set set to ANSI.  PowerPoint
                // has the same problem with "Zapf Dingbats".

                if ( !WOW32_strcmp(achCapString, szSymbol) ||
                     !WOW32_strcmp(achCapString, szZapfDingbats) ||
                     !WOW32_strcmp(achCapString, szZapf_Dingbats) )
                {
                    lfCharSet = SYMBOL_CHARSET;
                }
            }
        }

        // Win3.1(Win95) hack for Mavis Beacon Teaches Typing 3.0
        // The app uses a fixed width of 34*13 for the typing screen.
        // NT returns 14 from GetTextExtent for Mavis Beacon Courier FP font (width of 14)
        // while Win95 returns 13, thus long strings won't fit in the typing screen on NT.
        // Force the width to 13.

        if ( iWidth==14 && (INT32(parg16->f1)== 20) && !WOW32_strcmp(achCapString, szMavisCourier))
        {
           iWidth = 13;
        }

#ifdef FE_SB
       // WOWCF_FE_ICHITARO_ITALIC
       // Ichitaro asks for System Mincho because WIFE fonts aren't installed
       // we give it a proportional font which is can't handle.  If we see
       // this face name we will replace it with Ms Mincho

        if (GetSystemDefaultLangID() == 0x411 &&
            CURRENTPTD()->dwWOWCompatFlagsFE & WOWCF_FE_ICHITARO_ITALIC ) 
        {
            if(!WOW32_strcmp(achCapString, szSystemMincho))
            {
                strcpy(achCapString, szMsMincho);
                bUseAlternateFace = TRUE;
            }
        }
#endif // FE_SB

    }

#ifdef FE_SB
    ul = GETHFONT16(CreateFont(INT32(parg16->f1),
                               iWidth,
                               INT32(parg16->f3),
                               INT32(parg16->f4),
                               INT32(parg16->f5),
                               BYTE32(parg16->f6),
                               BYTE32(parg16->f7),
                               BYTE32(parg16->f8),
                               lfCharSet,
                               BYTE32(parg16->f10),
                               BYTE32(parg16->f11),
                               BYTE32(parg16->f12),
                               lfPitchAndFamily,
                               (bUseAlternateFace ? achCapString : psz14)
                               ));
#else
    ul = GETHFONT16(CreateFont(INT32(parg16->f1),
                               iWidth,
                               INT32(parg16->f3),
                               INT32(parg16->f4),
                               INT32(parg16->f5),
                               BYTE32(parg16->f6),
                               BYTE32(parg16->f7),
                               BYTE32(parg16->f8),
                               lfCharSet,
                               BYTE32(parg16->f10),
                               BYTE32(parg16->f11),
                               BYTE32(parg16->f12),
                               lfPitchAndFamily,
                               psz14));
#endif



    FREEPSZPTR(psz14);
    FREEARGPTR(parg16);

    RETURN(ul);
}


ULONG FASTCALL WG32CreateFontIndirect(PVDMFRAME pFrame)
{
    ULONG    ul;
    LOGFONT  logfont;
    register PCREATEFONTINDIRECT16 parg16;
    char     achCapString[LF_FACESIZE];

    GETARGPTR(pFrame, sizeof(CREATEFONTINDIRECT16), parg16);
    GETLOGFONT16(parg16->f1, &logfont);

    // Capitalize the string for faster compares.

    WOW32_strncpy(achCapString, logfont.lfFaceName, LF_FACESIZE);
    CharUpperBuff(achCapString, LF_FACESIZE);

    // Here we are going to implement a bunch of Win 3.1 hacks rather
    // than contaminate the 32-bit engine.  These same hacks can be found
    // in WOW (in the CreateFont/CreateFontIndirect code).
    //
    // These hacks are keyed off the facename in the LOGFONT.  String
    // comparisons have been unrolled for maximal performance.

    // Win 3.1 facename-based hack.  Some apps, like
    // Publisher, create a "Helv" font but have the lfPitchAndFamily
    // set to specify FIXED_PITCH.  To work around this, we will patch
    // the pitch field for a "Helv" font to be variable.

    if ( !WOW32_strcmp(achCapString, szHelv) )
    {
        logfont.lfPitchAndFamily |= ( (logfont.lfPitchAndFamily & ~PITCH_MASK) | VARIABLE_PITCH );
#ifdef FE_SB
        //
        // FE Win 3.1 facename-based hack.  Some FE apps
        // create a "Helv" font but have the lfCharSet
        // set to DBCS charset (ex. SHIFTJIS_CHARSET).
        // To work around this, we will wipe out the
        // lfFaceName[0] with '\0' and let GDI picks a
        // DBCS font for us.
        //
        if (IS_ANY_DBCS_CHARSET(logfont.lfCharSet))
            logfont.lfFaceName[0]='\0';
#endif // FE_SB
    }
    else
    {
        // Win 3.1 hack for Legacy 2.0.  When a printer does not enumerate
        // a "Tms Rmn" font, the app enumerates and gets the LOGFONT for
        // "Script" and then create a font with the name "Tms Rmn" but with
        // the lfCharSet and lfPitchAndFamily taken from the LOGFONT for
        // "Script".  Here we will over the lfCharSet to be ANSI_CHARSET.

        if ( !WOW32_strcmp(achCapString, szTmsRmn) )
        {
            logfont.lfCharSet = ANSI_CHARSET;
        }
        
        // for Quickbooks v4 & v5 OCR font support (see LoadOCRFont for details)
        else if ( !WOW32_strcmp(achCapString, szOCRA) )
        {

            // Further localize this hack to QuickBooks.  Most other apps won't
            // know about this quirk in this particular font.
            if(logfont.lfCharSet == SYMBOL_CHARSET) {
                logfont.lfCharSet = DEFAULT_CHARSET;

                if(!gfOCRFontLoaded) {
                    LoadOCRFont();
                }
            }
        }
        else
        {
            // If the lfFaceName is "Symbol", "Zapf Dingbats", or "ZapfDingbats",
            // enforce lfCharSet to be SYMBOL_CHARSET.  Some apps (like Excel) ask
            // for a "Symbol" font but have the char set set to ANSI.  PowerPoint
            // has the same problem with "Zapf Dingbats".

            if ( !WOW32_strcmp(achCapString, szSymbol) ||
                 !WOW32_strcmp(achCapString, szZapfDingbats) ||
                 !WOW32_strcmp(achCapString, szZapf_Dingbats) )
            {
                logfont.lfCharSet = SYMBOL_CHARSET;
            }

#ifdef FE_SB
       // WOWCF_FE_ICHITARO_ITALIC
       // Ichitaro asks for System Mincho because WIFE fonts aren't installed
       // we give it a proportional font which is can't handle.  If we see
       // this face name we will replace it with Ms Mincho

        if (GetSystemDefaultLangID() == 0x411 &&
            CURRENTPTD()->dwWOWCompatFlagsFE & WOWCF_FE_ICHITARO_ITALIC ) 
        {
            if(!WOW32_strcmp(achCapString, szSystemMincho))
            {
                strcpy(logfont.lfFaceName, szMsMincho);
            }
        }
#endif // FE_SB
        }
    }

    ul = GETHFONT16(CreateFontIndirect(&logfont));

    FREEARGPTR(parg16);

    RETURN(ul);
}


LPSTR lpMSSansSerif = "MS Sans Serif";
LPSTR lpMSSerif     = "MS Serif";
LPSTR lpHelvetica   = "Helvetica";

INT W32EnumFontFunc(LPENUMLOGFONT pEnumLogFont,
                    LPNEWTEXTMETRIC pNewTextMetric, INT nFontType, PFNTDATA pFntData)
{
    INT    iReturn;
    PARM16 Parm16;
    LPSTR  lpFaceNameT = NULL;

    WOW32ASSERT(pFntData);

    // take care of compatibility flags:
    //  ORin DEVICE_FONTTYPE bit if the fonttype is truetype and  the
    //  Compataibility flag GACF_CALLTTDEVICE is set.
    //

    if (nFontType & TRUETYPE_FONTTYPE) {
        if (W32GetAppCompatFlags((HAND16)NULL) & GACF_CALLTTDEVICE) {
            nFontType |= DEVICE_FONTTYPE;
        }
    }

    // take care of compatibility flags:
    //   replace Ms Sans Serif with Helv and
    //   replace Ms Serif      with Tms Rmn
    //
    // only if the facename is NULL and the compat flag GACF_ENUMHELVNTMSRMN
    // is set.

    if (pFntData->vpFaceName == (VPVOID)NULL) {
        if (W32GetAppCompatFlags((HAND16)NULL) & GACF_ENUMHELVNTMSRMN) {
            if (!WOW32_strcmp(pEnumLogFont->elfLogFont.lfFaceName, lpMSSansSerif)) {
                strcpy(pEnumLogFont->elfLogFont.lfFaceName, "Helv");
                lpFaceNameT = lpMSSansSerif;
            }
            else if (!WOW32_strcmp(pEnumLogFont->elfLogFont.lfFaceName, lpHelvetica)) {
                strcpy(pEnumLogFont->elfLogFont.lfFaceName, "Helv");
                lpFaceNameT = lpMSSansSerif;
            }
            else if (!WOW32_strcmp(pEnumLogFont->elfLogFont.lfFaceName, lpMSSerif)) {
                strcpy(pEnumLogFont->elfLogFont.lfFaceName, "Tms Rmn");
                lpFaceNameT = lpMSSerif;
            }
        }
    }

CallAgain:

    // be sure allocation size matches stackfree16() size below
    pFntData->vpLogFont    = stackalloc16(sizeof(ENUMLOGFONT16)+sizeof(NEWTEXTMETRIC16));

    pFntData->vpTextMetric = (VPVOID)((LPSTR)pFntData->vpLogFont + sizeof(ENUMLOGFONT16));

    PUTENUMLOGFONT16(pFntData->vpLogFont, pEnumLogFont);
    PUTNEWTEXTMETRIC16(pFntData->vpTextMetric, pNewTextMetric);

    STOREDWORD(Parm16.EnumFontProc.vpLogFont, pFntData->vpLogFont);
    STOREDWORD(Parm16.EnumFontProc.vpTextMetric, pFntData->vpTextMetric);
    STOREDWORD(Parm16.EnumFontProc.vpData,pFntData->dwUserFntParam);

    Parm16.EnumFontProc.nFontType = (SHORT)nFontType;

    CallBack16(RET_ENUMFONTPROC, &Parm16, pFntData->vpfnEnumFntProc, (PVPVOID)&iReturn);

    if(pFntData->vpLogFont) {
        stackfree16(pFntData->vpLogFont,
                    (sizeof(ENUMLOGFONT16) + sizeof(NEWTEXTMETRIC16)));
    }

    if (((SHORT)iReturn) && lpFaceNameT) {
        // if the callback returned true, now call with the actual facename
        // Just to be sure, we again copy all the data for callback. This will
        // take care of any apps which modify the passed in structures.

        strcpy(pEnumLogFont->elfLogFont.lfFaceName, lpFaceNameT);
        lpFaceNameT = (LPSTR)NULL;
        goto CallAgain;
    }
    return (SHORT)iReturn;
}


ULONG  W32EnumFontHandler( PVDMFRAME pFrame, BOOL fEnumFontFamilies )
{
    ULONG    ul = 0;
    PSZ      psz2;
    FNTDATA  FntData;
    register PENUMFONTS16 parg16;

    GETARGPTR(pFrame, sizeof(ENUMFONTS16), parg16);
    GETPSZPTR(parg16->f2, psz2);

    FntData.vpfnEnumFntProc = DWORD32(parg16->f3);
    FntData.dwUserFntParam  = DWORD32(parg16->f4);
    FntData.vpFaceName   = DWORD32(parg16->f2);


    if ( fEnumFontFamilies ) {
        ul = GETINT16(EnumFontFamilies(HDC32(parg16->f1),
                                       psz2,
                                       (FONTENUMPROC)W32EnumFontFunc,
                                       (LPARAM)&FntData));
    } else {
        ul = GETINT16(EnumFonts(HDC32(parg16->f1),
                                psz2,
                                (FONTENUMPROC)W32EnumFontFunc,
                                (LPARAM)&FntData));
    }



    FREEPSZPTR(psz2);
    FREEARGPTR(parg16);

    RETURN(ul);
}



ULONG FASTCALL WG32EnumFonts(PVDMFRAME pFrame)
{
    return( W32EnumFontHandler( pFrame, FALSE ) );
}



ULONG FASTCALL WG32GetAspectRatioFilter(PVDMFRAME pFrame)
{
    ULONG    ul = 0;
    SIZE     size2;
    register PGETASPECTRATIOFILTER16 parg16;

    GETARGPTR(pFrame, sizeof(GETASPECTRATIOFILTER16), parg16);

    if (GETDWORD16(GetAspectRatioFilterEx(HDC32(parg16->f1), &size2))) {
        ul = (WORD)size2.cx | (size2.cy << 16);
    }

    FREEARGPTR(parg16);

    RETURN(ul);
}


ULONG FASTCALL WG32GetCharWidth(PVDMFRAME pFrame)
{
    ULONG    ul = 0L;
    INT      ci;
    PINT     pi4;
    register PGETCHARWIDTH16 parg16;
    INT      BufferT[256];

    GETARGPTR(pFrame, sizeof(GETCHARWIDTH16), parg16);

    ci = WORD32(parg16->wLastChar) - WORD32(parg16->wFirstChar) + 1;
    pi4 = STACKORHEAPALLOC(ci * sizeof(INT), sizeof(BufferT), BufferT);

    if (pi4) {
        ULONG ulLast = WORD32(parg16->wLastChar);
#ifdef FE_SB
        /*
         * If ulLast sets DBCS code (0x82xx), then below code is illigal.
         */
        if (ulLast > 0xff && !(IsDBCSLeadByte(HIBYTE(ulLast))))
#else // !FE_SB
        if (ulLast > 0xff)
#endif // !FE_SB
            ulLast = 0xff;

        ul = GETBOOL16(GetCharWidth(HDC32(parg16->hDC),
                                    WORD32(parg16->wFirstChar),
                                    ulLast,
                                    pi4));

        PUTINTARRAY16(parg16->lpIntBuffer, ci, pi4);
        STACKORHEAPFREE(pi4, BufferT);

    }

    FREEARGPTR(parg16);

    RETURN(ul);
}


// a.k.a. WOWRemoveFontResource
ULONG FASTCALL WG32RemoveFontResource(PVDMFRAME pFrame)
{
    ULONG    ul;
    PSZ      psz1;
    register PREMOVEFONTRESOURCE16 parg16;

    GETARGPTR(pFrame, sizeof(REMOVEFONTRESOURCE16), parg16);

    GETPSZPTR(parg16->f1, psz1);

    // note: we will never get an hModule in the low word here.
    //       the 16-bit side resolves hModules to an lpsz before calling us


    if( CURRENTPTD()->dwWOWCompatFlags & WOWCF_UNLOADNETFONTS )
    {
        ul = GETBOOL16(RemoveFontResourceTracking(psz1,(UINT)CURRENTPTD()));
    }
    else
    {
        ul = GETBOOL16(RemoveFontResource(psz1));
    }

    FREEPSZPTR(psz1);

    FREEARGPTR(parg16);

    RETURN(ul);
}


/* WG32GetCurLogFont
 *
 * This thunk implements the undocumented Win3.0 and Win3.1 API
 * GetCurLogFont (GDI.411). Symantec QA4.0 uses it.
 *
 * HFONT GetCurLogFont (HDC)
 * HDC   hDC;        // Device Context
 *
 * This function returns the current Logical font selected for the
 * specified device context.
 *
 * To implement this undocumented API we will use the NT undocumented API
 * GetHFONT.
 *
 * SudeepB 08-Mar-1996
 *
 */

extern HFONT APIENTRY GetHFONT (HDC hdc);

ULONG FASTCALL WG32GetCurLogFont(PVDMFRAME pFrame)
{

    ULONG    ul;
    register PGETCURLOGFONT16 parg16;

    GETARGPTR(pFrame, sizeof(GETCURLOGFONT16), parg16);

    ul = GETHFONT16 (GetHFONT(HDC32 (parg16->hDC)));

    FREEARGPTR(parg16);

    return (ul);
}



//
//  This allows Quickbooks v4 & v5 to use their OCR-A.TTF font right after they
//  install.  At the end of installation on both versions, you are asked if you
//  want to "restart" windows. If you click OK it logs you off of NT5, but does
//  *not* reboot the system -- which the app is counting on to cause the OCR-A 
//  font to be loaded. The result on W2K is that whenever the app uses the OCR-A
//  font, it will get mapped to wingdings instead.
//
//  This is further complicated by the fact that the font file OCR-A.TTF doesn't
//  specify the charset in the header.  On Win3.1, Win95, & pre-NT5, unspecified
//  charset's got mapped to the SYMBOL_CHARSET - therefore, Quickbooks specifies
//  SYMBOL_CHARSET in its LOGFONT struct to accomodate this.  (OCR-A apparently
//  is licenced from Monotype Typography, Ltd. which presumably is why Intuit
//  didn't fix the header issue in the font file).
//
//  This changed on Win98 and W2K, unspecified charset's now get mapped to the
//  DEFAULT_CHARSET.  This was done so these fonts will always map to a default 
//  localized font that will always be readable. Hence, the hack where we change
//  the charset from SYMBOL_CHARSET to DEFAULT_CHARSET in the LOGFONT struct.
//
//  On v4, the install program copies OCR-A.FOT & OCR-A.TTF to the SYSTEM dir.  
//  Once you "restart" (not reboot) the system & log back on, the OCR-A font is
//  added to the registry (as OCR-A.FOT) but the font files are still in the 
//  SYSTEM dir.  Rebooting causes the fonts files to be moved to the FONTS dir,
//  the registry entry is changed to OCR-A.TTF. (done by the "Font Sweeper")
//
//  On v5, the install program copies the .ttf & .fot files to the FONTS dir
//  but again, counts on the reboot to cause the fonts to be loaded.  It puts 
//  correct registry entry (OCR-A.TTF) in the registry fonts section.
//
//  The result of all this is:
//  For either version of the app, without the charset hack, you will always get
//  a wingding font instead of OCR-A.  With the charset hack, you will get a
//  readable font, such as Arial, until you reboot -- after which you will get
//  OCR-A for v5 but Arial for v4. With this function (in conjunction with the 
//  charset hack) both version will always get OCR-A with or without rebooting.
//
//  This function explicitly loads the OCR-A from the font files located in 
//  either the FONTS dir or the SYSTEM dir.
//
void LoadOCRFont(void)
{
    char  szFontPath[MAX_PATH];
    DWORD dw;
    int   cb;

    // get equivalent of "c:\windows" for this system
    dw = GetWindowsDirectory(szFontPath, MAX_PATH);

    // we're going to add a maximum of 18 chars "\SYSTEM\OCR-A.TTF"
    if(dw && ((MAX_PATH - 18) > dw)) {

        // build "c:\windows\FONTS\OCR-A.TTF"  (QuickBooks v5)
        strcat(szFontPath, szFonts);
        strcat(szFontPath, szOCRDotTTF); 

        // If font file doesn't exist in FONTS dir, this must be QuickBooks v4
        // The FR_PRIVATE flag means that the font will be unloaded when the vdm
        // process goes away.  The FR_NO_ENUM flag means that this instance of
        // the font can't be enumerated by other processes (it might go away
        // while the other processes are trying to use it).
        cb = AddFontResourceEx(szFontPath, FR_PRIVATE | FR_NOT_ENUM, NULL);
        if(!cb) {
                 
            // reset path to "c:\windows"
            szFontPath[dw] = '\0';

            // build "c:\windows\SYSTEM\OCR-A.TTF"
            strcat(szFontPath, szSystem);
            strcat(szFontPath, szOCRDotTTF); 
            
            cb = AddFontResourceEx(szFontPath, FR_PRIVATE | FR_NOT_ENUM, NULL);

            // if it wasn't loaded from the SYSTEM dir either, punt
        }

        if(cb) {

            // specify that the font is already loaded for the life of this VDM
            gfOCRFontLoaded = TRUE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgfont.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGFONT.H
 *  WOW32 16-bit GDI API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/


/* Enumeration handler data
 */
typedef struct _FNTDATA {	/* fntdata */
    VPPROC  vpfnEnumFntProc;    // 16-bit enumeration function
    DWORD   dwUserFntParam;	// user param, if any
    HMEM16  hLogFont;		//
    VPVOID  vpLogFont;		// 16-bit storage for logical font
    HMEM16  hTextMetric;	//
    VPVOID  vpTextMetric;	// 16-bit storage for textmetric structure
    VPVOID  vpFaceName;     // 16bit far ptr - input to Enum Fonts & Families
} FNTDATA, *PFNTDATA;


/* Function prototypes
 */
ULONG FASTCALL WG32AddFontResource(PVDMFRAME pFrame);
ULONG FASTCALL WG32CreateFont(PVDMFRAME pFrame);
ULONG FASTCALL WG32CreateFontIndirect(PVDMFRAME pFrame);

INT	W32FontFunc(LPLOGFONT pLogFont,
		    LPTEXTMETRIC pTextMetrics, INT nFontType, PFNTDATA pFntData);

ULONG FASTCALL WG32EnumFonts(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetAspectRatioFilter(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetCharWidth(PVDMFRAME pFrame);
ULONG FASTCALL WG32RemoveFontResource(PVDMFRAME pFrame);

ULONG W32EnumFontHandler( PVDMFRAME pFrame, BOOL fEnumFontFamilies );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgman.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGMAN.H
 *  WOW32 16-bit GDI API support (manually-coded thunks)
 *
 *  History:
 *  Created 27-Jan-1991 by Jeff Parsons (jeffpar)
--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgman.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGMAN.C
 *  WOW32 16-bit GDI API support (manually-coded thunks)
 *
 *  History:
 *  Created 27-Jan-1991 by Jeff Parsons (jeffpar)
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wgman.c);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgmeta.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGMETA.H
 *  WOW32 16-bit GDI API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/



ULONG FASTCALL   WG32CloseMetaFile(PVDMFRAME pFrame);
ULONG FASTCALL   WG32CopyMetaFile(PVDMFRAME pFrame);
ULONG FASTCALL   WG32CreateMetaFile(PVDMFRAME pFrame);
ULONG FASTCALL   WG32DeleteMetaFile(PVDMFRAME pFrame);
ULONG FASTCALL   WG32EnumMetaFile(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetMetaFile(PVDMFRAME pFrame);
ULONG FASTCALL   WG32GetMetaFileBits(PVDMFRAME pFrame);
ULONG FASTCALL   WG32PlayMetaFile(PVDMFRAME pFrame);
ULONG FASTCALL   WG32PlayMetaFileRecord(PVDMFRAME pFrame);
ULONG FASTCALL   WG32SetMetaFileBits(PVDMFRAME pFrame);
HAND16  WinMetaFileFromHMF(HMETAFILE hmf, BOOL fFreeOriginal);
HMETAFILE HMFFromWinMetaFile(HAND16 h16, BOOL fFreeOriginal);


/* MetaFile Enumeration handler data
 */
typedef struct _METADATA {       /* fntdata */
    PARMEMP parmemp;                // 16-bit enumeration data (WOW.H)
    VPPROC  vpfnEnumMetaFileProc;   // 16-bit enumeration function
    DWORD   mtMaxRecordSize;
} METADATA, *PMETADATA;


INT W32EnumMetaFileCallBack(HDC hdc, LPHANDLETABLE lpht, LPMETARECORD lpMR, LONG nObj, PMETADATA pMetaData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgpal.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGPAL.C
 *  WOW32 16-bit GDI API support
 *
 *  History:
 *  07-Mar-1991 Jeff Parsons (jeffpar)
 *  Created.
 *
 *  09-Apr-1991 NigelT
 *  Various defines are used here to remove calls to Win32
 *  features which don't work yet.
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wgpal.c);


ULONG FASTCALL WG32GetSystemPaletteEntries(PVDMFRAME pFrame)
{
    ULONG ul = 0L;
    PPALETTEENTRY ppal;
    register PGETSYSTEMPALETTEENTRIES16 parg16;

    GETARGPTR(pFrame, sizeof(GETSYSTEMPALETTEENTRIES16), parg16);

    GETVDMPTR(parg16->f4, parg16->f3 * sizeof(PALETTEENTRY), ppal);

    if( ppal ) {

        ul = GETWORD16(GetSystemPaletteEntries(HDC32(parg16->f1),
                                               WORD32(parg16->f2),
                                               WORD32(parg16->f3),
                                               ppal));

        // if we fail but are on a rgb device, fill in the default 256 entries.
        // WIN31 just calls Escape(hdc,GETCOLORTABLE) which on NT just calls
        // GetSysteemPaletteEntries().

        if (!ul && (GetDeviceCaps(HDC32(parg16->f1),BITSPIXEL) > 8))
        {
            if (parg16->f4 == 0)
            {
                ul = 256;
            }
            else
            {
                int j;
                int i = WORD32(parg16->f2);
                int c = WORD32(parg16->f3);

                if ((c + i) > 256)
                    c = 256 - i;

                if (c > 0)
                {
                    BYTE abGreenRed[8] = {0x0,0x25,0x48,0x6d,0x92,0xb6,0xdb,0xff};
                    BYTE abBlue[4]     = {0x0,0x55,0xaa,0xff};

                    // green mask 00000111
                    // red mask   00111000
                    // blue mask  11000000
                    // could certainly do this faster with a table and mem copy
                    // but I don't really care about performance here.  Apps
                    // shouldn't be doing this.  That is why it is in the wow
                    // layer.

                    for (j = 0; j < c; ++j,++i)
                    {
                        ppal[j].peGreen = abGreenRed[i & 0x07];
                        ppal[j].peRed   = abGreenRed[(i >> 3) & 0x07];
                        ppal[j].peBlue  = abBlue[(i >> 6) & 0x03];
                        ppal[j].peFlags = 0;
                    }

                    ul = c;
                }
            }
        }

        FREEVDMPTR(ppal);
    }

    FREEARGPTR(parg16);

    RETURN(ul);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgprnset.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGPRNSET.H
 *  WOW32 printer setup support routines
 *
 *  These routines help a Win 3.0 task to complete the printer set-up,
 *  when a user initiates the printer setup from the file menu of an
 *  application.
 *
 *  History:
 *  Created 18-Apr-1991 by Chandan Chauhan (ChandanC)
--*/


#define DBG_UNREFERENCED_LOCAL_VARIABLE(V)  (V)

ULONG FASTCALL WG32DeviceMode (PVDMFRAME pFrame);
ULONG FASTCALL WG32ExtDeviceMode (PVDMFRAME pFrame);
ULONG FASTCALL WG32DeviceCapabilities (PVDMFRAME pFrame);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgpal.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGPAL.H
 *  WOW32 16-bit GDI API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/



ULONG FASTCALL WG32GetSystemPaletteEntries(PVDMFRAME pFrame);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgmeta.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGMETA.C
 *  WOW32 16-bit GDI API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wgmeta.c);

typedef METAHEADER UNALIGNED *PMETAHEADER16;




// WARNING: This function may cause 16-bit memory to move
VOID CopyMetaFile16FromHMF32(HAND16 hMF16, HMETAFILE hMF32)
{
    UINT   cbMF32, cbMF16;
    VPVOID vp;
    PBYTE  pMF16;


    if((vp = GlobalLock16(hMF16, &cbMF16)) && hMF32) {

        GETMISCPTR(vp, pMF16);

        cbMF32 = GetMetaFileBitsEx(hMF32, 0, NULL);
    
        // Verify these are the same size within the 16-bit kernel memory
        // allocation granularity
        WOW32WARNMSGF((abs(cbMF16 - cbMF32) < 32),
                      ("WOW32: Size MF16 = %lu  MF32 = %lu\n", cbMF16, cbMF32));

        // copy the bits from the 32-bit metafile to the 16-bit metafile memory
        cbMF32 = GetMetaFileBitsEx(hMF32, min(cbMF16, cbMF32), pMF16);

        GlobalUnlock16(hMF16);
        FLUSHVDMPTR(vp, cbMF32, pMF16);
        FREEMISCPTR(pMF16);
    }
}




// WARNING: This function may cause 16-bit memory to move
HAND16 WinMetaFileFromHMF(HMETAFILE hmf, BOOL fFreeOriginal)
{
    UINT cbMetaData;
    VPVOID vpMetaData;
    PBYTE pMetaData;
    HAND16 h16;

    /*
     * Under Windows Metafiles were merely Global Handle to memory
     * so we have to mimick that behavior because some apps "operate"
     * on metafile handles directly.  (WinWord and PowerPoint to
     * GlobalSize and GlobalAlloc to size and create metafiles)
     */

    cbMetaData = GetMetaFileBitsEx(hmf, 0, NULL);

    if (!cbMetaData)
       return((HAND16)NULL);

    /*
     * Win 3.1 allocates extra space in MetaFile and OLE2 checks for this.
     * METAHEADER is defined to be the same size as the 16-bit structure.
     */

    cbMetaData += sizeof(METAHEADER);

    vpMetaData = GlobalAllocLock16(GMEM_MOVEABLE | GMEM_DDESHARE, cbMetaData, &h16);

    if (!vpMetaData)
       return((HAND16)NULL);


    GETOPTPTR(vpMetaData, 0, pMetaData);

    if (GetMetaFileBitsEx(hmf, cbMetaData, pMetaData)) {
       GlobalUnlock16(h16);
    } else {
       GlobalUnlockFree16(vpMetaData);
       return((HAND16)NULL);
    }

    if (fFreeOriginal)
        DeleteMetaFile(hmf);

    return(h16);
}

HMETAFILE HMFFromWinMetaFile(HAND16 h16, BOOL fFreeOriginal)
{
    INT cb;
    VPVOID vp;
    HMETAFILE hmf = (HMETAFILE)0;
    PMETAHEADER16 pMFH16;

    vp = GlobalLock16(h16, &cb);

    if (vp) {
        GETMISCPTR(vp, pMFH16);

        hmf = SetMetaFileBitsEx(cb, (LPBYTE)pMFH16);

        if (fFreeOriginal)
            GlobalUnlockFree16(vp);
        else
            GlobalUnlock16(h16);

        FREEMISCPTR(pMFH16);
    }

    return(hmf);
}


ULONG FASTCALL WG32CloseMetaFile(PVDMFRAME pFrame)
{
    HMETAFILE hmf;
    ULONG ulRet = 0;
    register PCLOSEMETAFILE16 parg16;

    GETARGPTR(pFrame, sizeof(CLOSEMETAFILE16), parg16);

    hmf = CloseMetaFile(HDC32(parg16->f1));

    if (hmf)
   ulRet = (ULONG)WinMetaFileFromHMF(hmf, TRUE);
    // WARNING: 16-bit memory may have moved - invalidate flat pointers now
    FREEVDMPTR(pFrame);
    FREEARGPTR(parg16);
    RETURN(ulRet);
}


ULONG FASTCALL WG32CopyMetaFile(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz2;
    HMETAFILE hmfNew;
    HMETAFILE hmf;
    register PCOPYMETAFILE16 parg16;

    GETARGPTR(pFrame, sizeof(COPYMETAFILE16), parg16);
    GETPSZPTR(parg16->f2, psz2);

    if (psz2) {
        hmf = HMFFromWinMetaFile(parg16->f1, FALSE);
        hmfNew = CopyMetaFile(hmf, psz2);
        DeleteMetaFile(hmf);
   ul = (ULONG)WinMetaFileFromHMF(hmfNew, TRUE);
   // WARNING: 16-bit memory may have moved - invalidate flat pointers now
   FREEVDMPTR(pFrame);
   FREEARGPTR(parg16);
   FREEPSZPTR(psz2);
    } else {
        UINT cb;
        VPVOID vp, vpNew;
        PBYTE pMF, pMFNew;
        HAND16 h16New, h16;

        h16 = (HAND16)parg16->f1;

        ul = (ULONG) NULL;

        vp = GlobalLock16(h16, &cb);
        if (vp) {

        /*
         * Windows app such as WinWord uses GlobalSize to determine
         * the size of the metafile.  However, this size can be larger
         * than the true size of a metafile.  We have to make sure that
         * both source and destination sizes are identical so that
         * WinWord doesn't crash.
         */

       vpNew = GlobalAllocLock16(GMEM_MOVEABLE | GMEM_DDESHARE, cb, &h16New);

       // 16-bit memory may have moved - invalidate flat pointers now
       FREEVDMPTR(pFrame);
       FREEARGPTR(parg16);
       FREEPSZPTR(psz2);

            if (vpNew) {
      GETMISCPTR(vp, pMF);
                GETOPTPTR(vpNew, 0, pMFNew);

                RtlCopyMemory(pMFNew, pMF, cb);

                GlobalUnlock16(h16New);
                FLUSHVDMPTR(vpNew, cb, pMFNew);
                FREEOPTPTR(pMFNew);
                ul = h16New;
            }

            GlobalUnlock16(h16);
            FREEMISCPTR(pMF);
        }
    }

    FREEPSZPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32CreateMetaFile(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz1;
    register PCREATEMETAFILE16 parg16;

    GETARGPTR(pFrame, sizeof(CREATEMETAFILE16), parg16);
    GETPSZPTR(parg16->f1, psz1);

    ul = GETHDC16(CreateMetaFile(psz1));

    FREEPSZPTR(psz1);
    FREEARGPTR(parg16);
    RETURN(ul);
}

//
// This routine does what the 16-bit parameter validation layer would
// normally do for metafile handles, but since it is currently disabled,
// we'll do it here to fix WordPerfect that relies on it. Once true
// win31-style parameter validation has been re-enabled for metafile
// handles, all code within the ifndefs here and in WG32DeleteMetaFile
// can be removed.
//
#ifndef PARAMETER_VALIDATION_16_RE_ENABLED
#define MEMORYMETAFILE 1
#define DISKMETAFILE 2
#define HEADERSIZE          (sizeof(METAHEADER)/sizeof(WORD))
#define METAVERSION         0x0300
#define METAVERSION100      0x0100

BOOL IsValidMetaFile16(PMETAHEADER16 lpMetaData)
{
    BOOL            sts = FALSE;

        sts = (lpMetaData->mtType == MEMORYMETAFILE ||
           lpMetaData->mtType == DISKMETAFILE) &&
              (lpMetaData->mtHeaderSize == HEADERSIZE) &&
              ((lpMetaData->mtVersion ==METAVERSION) ||
           (lpMetaData->mtVersion ==METAVERSION100)) ;
    return sts;
}
#endif

ULONG FASTCALL WG32DeleteMetaFile(PVDMFRAME pFrame)
{
    ULONG ul = FALSE;
    VPVOID vp;
#ifndef PARAMETER_VALIDATION_16_RE_ENABLED
    PMETAHEADER16 lpMetaData;
#endif

    register PDELETEMETAFILE16 parg16;

    GETARGPTR(pFrame, sizeof(DELETEMETAFILE16), parg16);

    if (vp = GlobalLock16(parg16->f1,NULL)) {
#ifdef PARAMETER_VALIDATION_16_RE_ENABLED
        GlobalUnlockFree16(vp);
        ul = TRUE;
#else
        GETVDMPTR(vp, 1, lpMetaData);

        if (IsValidMetaFile16(lpMetaData)) {
            GlobalUnlockFree16(vp);
            ul = TRUE;
        }

        FREEVDMPTR(lpMetaData);
#endif
    }


    // If this metafile was in DDE conversation, then DDE cleanup code
    // needs to free its 32 bit counter part. So give DDE clean up
    // code a chance.
    // ChandanC

    W32DdeFreeHandle16 (parg16->f1);

    FREEARGPTR(parg16);
    RETURN(ul);
}

INT WG32EnumMetaFileCallBack(HDC hdc, LPHANDLETABLE lpht, LPMETARECORD lpMR, LONG nObj, PMETADATA pMetaData )
{
    INT iReturn;
    DWORD nWords;

    // update object table if we have one
    if (pMetaData->parmemp.vpHandleTable)
        PUTHANDLETABLE16(pMetaData->parmemp.vpHandleTable,nObj,lpht);

    // update MetaRecord

    // don't trash the heap with a bogus record, halt the enumeration
    nWords = lpMR->rdSize;
    if (nWords > pMetaData->mtMaxRecordSize) {
        LOGDEBUG(0,("WOW:bad metafile record during enumeration\n"));
        WOW32ASSERT(FALSE); // contact barryb
        return 0;   // all done
    }
    putstr16(pMetaData->parmemp.vpMetaRecord, (LPSZ)lpMR, nWords*sizeof(WORD));

    CallBack16(RET_ENUMMETAFILEPROC, (PPARM16)&pMetaData->parmemp, pMetaData->vpfnEnumMetaFileProc, (PVPVOID)&iReturn);

    // update the metarec in case the app altered it (Approach does)
    getstr16(pMetaData->parmemp.vpMetaRecord, (LPSZ)lpMR, nWords*sizeof(WORD));

    // update object table if we have one
    if (pMetaData->parmemp.vpHandleTable)
        GETHANDLETABLE16(pMetaData->parmemp.vpHandleTable,nObj,lpht);

    return (SHORT)iReturn;

    hdc;    // quiet the compilier; we already know the DC
}

ULONG FASTCALL WG32EnumMetaFile(PVDMFRAME pFrame)
{
    ULONG       ul = 0;
    register    PENUMMETAFILE16 parg16;
    METADATA    metadata;
    VPVOID      vpMetaFile = (VPVOID) NULL;
    PBYTE       pMetaFile;
    HMETAFILE   hmf = (HMETAFILE) 0;
    HAND16      hMetaFile16;
    HDC  hDC = 0;

    GETARGPTR(pFrame, sizeof(ENUMMETAFILE16), parg16);

    hMetaFile16 = parg16->f2;

    metadata.vpfnEnumMetaFileProc = DWORD32(parg16->f3);
    metadata.parmemp.vpData = (VPVOID)DWORD32(parg16->f4);
    metadata.parmemp.vpMetaRecord = (VPVOID) NULL;
    metadata.parmemp.vpHandleTable = (VPVOID) NULL;
    metadata.parmemp.hdc = parg16->f1;

    // WinWord never calls SetMetaFileBits; they peeked and know that
    // a metafile is really a GlobalHandle in Windows so we have
    // to look for that case.

    hmf = HMFFromWinMetaFile(hMetaFile16, FALSE);
    if (!hmf)
        goto EMF_Exit;

    // Get the metafile bits so we can get max record size and number of objects

    vpMetaFile = GlobalLock16(hMetaFile16, NULL);
    FREEARGPTR(parg16);    // memory may have moved
    FREEVDMPTR(pFrame);
    if (!vpMetaFile)
        goto EMF_Exit;

    GETOPTPTR(vpMetaFile, 0, pMetaFile);
    if (!pMetaFile)
        goto EMF_Exit;

    metadata.parmemp.nObjects = ((PMETAHEADER16)pMetaFile)->mtNoObjects;
    metadata.mtMaxRecordSize = ((PMETAHEADER16)pMetaFile)->mtMaxRecord;

    if (metadata.parmemp.nObjects)
    {
   PBYTE pHT;
   DWORD cb = ((PMETAHEADER16)pMetaFile)->mtNoObjects*sizeof(HAND16);

   metadata.parmemp.vpHandleTable = GlobalAllocLock16(GMEM_MOVEABLE, cb, NULL);
   FREEOPTPTR(pMetaFile);   // memory may have moved
   FREEARGPTR(parg16);
   FREEVDMPTR(pFrame);
        if (!metadata.parmemp.vpHandleTable)
            goto EMF_Exit;

        GETOPTPTR(metadata.parmemp.vpHandleTable, 0, pHT);
   RtlZeroMemory(pHT, cb);
    }

    metadata.parmemp.vpMetaRecord = GlobalAllocLock16(GMEM_MOVEABLE, metadata.mtMaxRecordSize*sizeof(WORD), NULL);
    FREEOPTPTR(pMetaFile);  // memory may have moved
    FREEARGPTR(parg16);
    FREEVDMPTR(pFrame);
    if (!metadata.parmemp.vpMetaRecord)
        goto EMF_Exit;

    // Corel Draw passes a NULL hDC, we'll create a dummy to keep GDI32 happy.
    if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_GETDUMMYDC) {
   if ((hDC = HDC32(metadata.parmemp.hdc)) == 0) {
            hDC = CreateMetaFile(NULL);
        }
    }
    else {
   hDC = HDC32(metadata.parmemp.hdc);
    }

    // When processing metafile, access2.0 faults while receiving
    // WM_DEVMODECHANGE so we block that particular message when
    // in EnumMetaFile

    if ( CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_EATDEVMODEMSG) {
         CURRENTPTD()->dwFlags |= TDF_EATDEVMODEMSG;
    }
    ul = GETBOOL16(EnumMetaFile(hDC,
                                hmf,
                                (MFENUMPROC)WG32EnumMetaFileCallBack,
            ((LPARAM)(LPVOID)&metadata)));


    CURRENTPTD()->dwFlags &= ~TDF_EATDEVMODEMSG;
    
    
    // 16-bit memory may have moved - nothing to do as no flat ptrs exist now

    // copy the 32-bit metafile back to 16-bit land (the app may have altered
    // some of the metarecs in its MetaRecCallBackFunc -- Approach does)
    CopyMetaFile16FromHMF32(hMetaFile16, hmf);

    // Cleanup the dummy hDC created for Corel Draw 5.0.
    if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_GETDUMMYDC) {
   if (HDC32(metadata.parmemp.hdc) == 0) {
            DeleteMetaFile(CloseMetaFile(hDC));
        }
    }

EMF_Exit:
    if (vpMetaFile)
        GlobalUnlock16(hMetaFile16);

    if (hmf)
        DeleteMetaFile(hmf);

    if (metadata.parmemp.vpHandleTable)
        GlobalUnlockFree16(metadata.parmemp.vpHandleTable);

    if (metadata.parmemp.vpMetaRecord)
        GlobalUnlockFree16(metadata.parmemp.vpMetaRecord);

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32GetMetaFile(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz1;
    HMETAFILE hmf;
    register PGETMETAFILE16 parg16;

    GETARGPTR(pFrame, sizeof(GETMETAFILE16), parg16);
    GETPSZPTR(parg16->f1, psz1);

    hmf = GetMetaFile(psz1);

    if (hmf)
        ul = WinMetaFileFromHMF(hmf, TRUE);
    else
        ul = 0;

    FREEPSZPTR(psz1);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32PlayMetaFile(PVDMFRAME pFrame)
{
    ULONG ul;
    HMETAFILE hmf;
    register PPLAYMETAFILE16 parg16;

    GETARGPTR(pFrame, sizeof(PLAYMETAFILE16), parg16);

    hmf = HMFFromWinMetaFile(parg16->f2, FALSE);

    ul = GETBOOL16(PlayMetaFile(HDC32(parg16->f1), hmf));

    if (hmf)
        DeleteMetaFile(hmf);

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32PlayMetaFileRecord(PVDMFRAME pFrame)
{
    ULONG ul = FALSE;
    LPHANDLETABLE pHT = NULL;
    PBYTE pMetaData;
    WORD wHandles;
    VPHANDLETABLE16 vpHT;
    register PPLAYMETAFILERECORD16 parg16;

    GETARGPTR(pFrame, sizeof(PLAYMETAFILERECORD16), parg16);

    wHandles = parg16->f4;
    vpHT     = parg16->f2;
    if (wHandles && vpHT) {
        ALLOCHANDLETABLE16(wHandles, pHT);
        if (!pHT)
            goto PMFR_Exit;

        GETHANDLETABLE16(vpHT, wHandles, pHT);
    }
    GETOPTPTR(parg16->f3, 0, pMetaData);

    ul = (ULONG) PlayMetaFileRecord(HDC32(parg16->f1),
                                    pHT,
                                    (LPMETARECORD)pMetaData,
                                    (UINT)wHandles);


    if (wHandles && vpHT) {
        PUTHANDLETABLE16(vpHT, wHandles, pHT);
        FREEHANDLETABLE16(pHT);
    }
PMFR_Exit:
    FREEARGPTR(parg16);
    RETURN(ul);
}

#if 0  // implemented in gdi.exe

ULONG FASTCALL WG32GetMetaFileBits(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PGETMETAFILEBITS16 parg16;

    GETARGPTR(pFrame, sizeof(GETMETAFILEBITS16), parg16);

    if (GlobalLock16(parg16->f1,NULL))
    {
        GlobalUnlock16(parg16->f1);
        ul = parg16->f1;
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}

ULONG FASTCALL WG32SetMetaFileBits(PVDMFRAME pFrame)
{
    ULONG ul;
    register PSETMETAFILEBITS16 parg16;

    GETARGPTR(pFrame, sizeof(SETMETAFILEBITS16), parg16);

    ul = parg16->f1;

    FREEARGPTR(parg16);
    RETURN(ul);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgprnset.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGPRNSET.C
 *  WOW32 printer setup support routines
 *
 *  These routines help a Win 3.0 task to complete the printer set-up,
 *  when a user initiates the printer setup from the file menu of an
 *  application.
 *
 *  History:
 *  Created 18-Apr-1991 by Chandan Chauhan (ChandanC)
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wgprnset.c);

DLLENTRYPOINTS  spoolerapis[WOW_SPOOLERAPI_COUNT] =  {"EXTDEVICEMODE", NULL,
                                    "DEVICEMODE", NULL,
                                    "DEVICECAPABILITIES", NULL,
                                    "OpenPrinterA", NULL,
                                    "StartDocPrinterA", NULL,
                                    "StartPagePrinter", NULL,
                                    "EndPagePrinter", NULL,
                                    "EndDocPrinter", NULL,
                                    "ClosePrinter", NULL,
                                    "WritePrinter", NULL,
                                    "DeletePrinter", NULL,
                                    "GetPrinterDriverDirectoryA", NULL,
                                    "AddPrinterA", NULL,
                                    "AddPrinterDriverA", NULL,
                                    "AddPortExA",NULL};


/****************************************************************************
*                                                                           *
*  ULONG FASTCALL   WG32DeviceMode (PVDMFRAME pFrame)                                *
*                                                                           *
*  (hWnd, hModule, lpDeviceName, lpOutPut)                                  *
*                                                                           *
*   This function passes WDevMode structure (which is per wow task) to      *
*   Win32 printer driver ExtDeviceMode API. This structure is then          *
*   initialized by the printer driver based on the user input.              *
*                                                                           *
*   Later on, when a WOW task creates a dc (by CreateDC API), the device    *
*   mode (WDevMode) structure associated with this wow task is passed along *
*   with the CreateDC API. Which contains the printer setup information     *
*   needed to print the document.                                           *
*                                                                           *
****************************************************************************/
ULONG FASTCALL   WG32DeviceMode (PVDMFRAME pFrame)
{

    register PDEVICEMODE16 parg16;
    PSZ      psz3 = NULL;
    PSZ      psz4 = NULL;
    ULONG    l    = 0;
    HWND     hwnd32;

    GETARGPTR(pFrame, sizeof(DEVICEMODE16), parg16);

    // copy all 16-bit params now since 16-bit memory may move if this calls
    // into a 16-bit fax driver
    hwnd32 = HWND32(parg16->f1);

    if(parg16->f3) {
        if(!(psz3 = malloc_w_strcpy_vp16to32(parg16->f3, FALSE, 0)))
            goto ExitPath;
    }
    if(parg16->f4) {
        if(!(psz4 = malloc_w_strcpy_vp16to32(parg16->f4, FALSE, 0)))
            goto ExitPath;
    }


    // invalidate all flat ptrs to 16:16 memory now!
    FREEARGPTR(parg16);

    if (!(spoolerapis[WOW_DEVICEMODE].lpfn)) {
        if (!LoadLibraryAndGetProcAddresses("WINSPOOL.DRV", spoolerapis, WOW_SPOOLERAPI_COUNT)) {
            goto ExitPath;
        }
    }

    // this can callback into a 16-bit fax driver!
    (*spoolerapis[WOW_DEVICEMODE].lpfn)(hwnd32, NULL, psz3, psz4);

    l = 1;

ExitPath:
    if(psz3) {
        free_w(psz3);
    }
    if(psz4) {
        free_w(psz4);
    }

    RETURN(l);  // DeviceMode returns void. Charisma checks the return value!
}





/*****************************************************************************
*                                                                            *
*  ULONG FASTCALL   WG32ExtDeviceMode (PVDMFRAME pFrame)                              *
*                                                                            *
*  INT     (hWnd, hDriver, lpDevModeOutput, lpDeviceName, lpPort,            *
*                     lpDevModeInput, lpProfile, wMode)                      *
*                                                                            *
*   This function is same as DeviceMode except that the wow task supplies    *
*   a DeviceMode structure. Apart from it, this API can be called in         *
*   different modes.                                                         *
*                                                                            *
*****************************************************************************/
ULONG FASTCALL   WG32ExtDeviceMode (PVDMFRAME pFrame)
{
    UINT      cb;
    LONG      l = 0;
    HWND      hWnd1;
    WORD      wMode8;
    PSZ       psz4 = NULL;
    PSZ       psz5 = NULL;
    PSZ       psz7 = NULL;
    VPVOID    vpdm3, vpdm6;
    LPDEVMODE lpdmInput6;
    LPDEVMODE lpdmOutput3;
    register  PEXTDEVICEMODE16 parg16;


    GETARGPTR(pFrame, sizeof(EXTDEVICEMODE16), parg16);

    // copy the 16-bit parameters into local vars since this may callback
    // into a 16-bit fax driver and cause 16-bit memory to move
    hWnd1  = HWND32(parg16->f1);
    vpdm3  = FETCHDWORD(parg16->f3);
    vpdm6  = FETCHDWORD(parg16->f6);
    wMode8 = FETCHWORD(parg16->f8);

    if(parg16->f4) {
        if(!(psz4 = malloc_w_strcpy_vp16to32(parg16->f4, FALSE, 0)))
            goto ExitPath;
    }
    if(parg16->f5) {
        if(!(psz5 = malloc_w_strcpy_vp16to32(parg16->f5, FALSE, 0)))
            goto ExitPath;
    }
    if(parg16->f7) {
        if(!(psz7 = malloc_w_strcpy_vp16to32(parg16->f7, FALSE, 0)))
            goto ExitPath;
    }

    FREEARGPTR(parg16);
    // all flat ptrs to 16:16 memory are now invalid!!

    if (!(spoolerapis[WOW_EXTDEVICEMODE].lpfn)) {
        if (!LoadLibraryAndGetProcAddresses("WINSPOOL.DRV", spoolerapis, WOW_SPOOLERAPI_COUNT)) {
            goto ExitPath;
        }
    }

    lpdmInput6 = ThunkDevMode16to32(FETCHDWORD(vpdm6));

    /* if they want output buffer size OR they want to fill output buffer */
    if( (wMode8 == 0) || (wMode8 & DM_OUT_BUFFER) ) {

        /* get required size for output buffer */
        l = (*spoolerapis[WOW_EXTDEVICEMODE].lpfn)(hWnd1,
                                                   NULL,
                                                   NULL,
                                                   psz4,
                                                   psz5,
                                                   lpdmInput6,
                                                   psz7,
                                                   0);

        // adjust size for WOW handling (see notes in wstruc.c)
        if(l > 0) {
            l += sizeof(WOWDM31);
            cb = (UINT)l;
        }

        /* if caller wants output buffer filled... */
        if( (wMode8 != 0) && (vpdm3 != 0L) && l > 0 ) {

            if( lpdmOutput3 = malloc_w(l) ) {

                l = (*spoolerapis[WOW_EXTDEVICEMODE].lpfn)(hWnd1,
                                                           NULL,
                                                           lpdmOutput3,
                                                           psz4,
                                                           psz5,
                                                           lpdmInput6,
                                                           psz7,
                                                           wMode8);

                /* Data in lpdmOutput3 is only valid with IDOK return. */
                if( l == IDOK ) {

                    // do our WOW magic on this before we give it to the app
                    ThunkDevMode32to16(vpdm3, lpdmOutput3, cb);
                }

                free_w(lpdmOutput3);
            }
            else {
                l = -1L;
            }
        }
    }

    /* else call for cases where they don't want to fill the output buffer */
    else {

        l = (*spoolerapis[WOW_EXTDEVICEMODE].lpfn)(hWnd1,
                                                   NULL,
                                                   NULL,
                                                   psz4,
                                                   psz5,
                                                   lpdmInput6,
                                                   psz7,
                                                   wMode8);
    }

    if( lpdmInput6 ) {
        free_w(lpdmInput6);
    }

ExitPath:
    if(psz4) {
        free_w(psz4);
    }
    if(psz5) {
        free_w(psz5);
    }
    if(psz7) {
        free_w(psz7);
    }

    RETURN((ULONG)l);

}




ULONG FASTCALL   WG32DeviceCapabilities (PVDMFRAME pFrame)
{
    LONG      l=0L, cb;
    WORD      fwCap3;
    PBYTE     pOutput4, pOutput32;
    VPVOID    vpOutput4;
    PSZ       psz1 = NULL;
    PSZ       psz2 = NULL;
    LPDEVMODE lpdmInput5;
    DWORD     dwDM5;
    register  PDEVICECAPABILITIES16 parg16;

    GETARGPTR(pFrame, sizeof(DEVICECAPABILITIES16), parg16);

    // copy the 16-bit parameters into local vars since this may callback
    // into a 16-bit fax driver and cause 16-bit memory to move
    if(parg16->f1) {
        if(!(psz1 = malloc_w_strcpy_vp16to32(parg16->f1, FALSE, 0)))
            goto ExitPath;
    }
    if(parg16->f2) {
        if(!(psz2 = malloc_w_strcpy_vp16to32(parg16->f2, FALSE, 0)))
            goto ExitPath;
    }

    fwCap3 = FETCHWORD(parg16->f3);

    vpOutput4 = FETCHDWORD(parg16->f4);

    dwDM5 = FETCHDWORD(parg16->f5);

    FREEARGPTR(parg16);
    // all flat ptrs to 16:16 memory are now invalid!!

    if (!(spoolerapis[WOW_DEVICECAPABILITIES].lpfn)) {
        if (!LoadLibraryAndGetProcAddresses("WINSPOOL.DRV",
                                            spoolerapis,
                                            WOW_SPOOLERAPI_COUNT)) {
            goto ExitPath;
        }
    }

    lpdmInput5 = ThunkDevMode16to32(dwDM5);

    LOGDEBUG(LOG_TRACE, ("WG32DeviceCapabilities %d\n", fwCap3));

    switch (fwCap3) {

        // These ones do not fill up an output Buffer

        case DC_FIELDS:
        case DC_DUPLEX:
        case DC_SIZE:
        case DC_EXTRA:
        case DC_VERSION:
        case DC_DRIVER:
        case DC_TRUETYPE:
        case DC_ORIENTATION:
        case DC_COPIES:

            l = (*spoolerapis[WOW_DEVICECAPABILITIES].lpfn)(psz1,
                                                            psz2,
                                                            fwCap3,
                                                            NULL,
                                                            lpdmInput5);

            LOGDEBUG(LOG_TRACE, ("WG32DeviceCapabilities simple case returned %d\n", l));

            // adjust for WOW handling of devmodes  // see notes in wstruc.c
            if(fwCap3 == DC_SIZE) {

                // we always convert NT DevModes to Win3.1 DevModes
                WOW32WARNMSGF((l==sizeof(DEVMODE)),
                              ("WG32DeviceCapabilities: Unexpected DevMode size: %d\n",l));
                if(l == sizeof(DEVMODE)) {
                    l = sizeof(DEVMODE31);
                }
            }
            // adjust DriverExtra to allow for difference between NT devmodes
            // & Win3.1 devmodes + our secret WOW stuff at the end
            else if(fwCap3 == DC_EXTRA) {
                l += WOW_DEVMODEEXTRA;
            }
            // we tell them Win3.1 for the spec version too
            else if(fwCap3 == DC_VERSION) {
                l = WOW_DEVMODE31SPEC; // tell 'em the spec version is Win3.1
            }

            break;

#ifdef DBCS
// not supported the following indexes.
    case DC_MINEXTENT:
    case DC_MAXEXTENT:

#ifdef DBCS_LATER
#if DBG
LOGDEBUG(0,("WG32DeviceCapabilities more complicated:"));
#endif
        pOutput = malloc_w(8);

        if (pOutput) {
            l = DEVICECAPABILITIES(psz1, psz2, parg16->f3, pOutput, pdmInput5);

            if (l >= 0) {
#if DBG
LOGDEBUG(0,("Copying %d points from %0x to %0x\n", l, pOutput, pb4));
#endif
                putpoint16(parg16->f4, 1, pOutput);
            }
            free_w(pOutput);
        }
        else {
            l = -1;
        }
#endif // DBCS_LATER
        l = -1;         // always error return
        break;
#endif // DBCS

        // These require an output buffer
        case DC_PAPERS:
        case DC_PAPERSIZE:
#ifndef DBCS
        case DC_MINEXTENT:
        case DC_MAXEXTENT:
#endif // !DBCS
        case DC_BINS:
        case DC_BINNAMES:
        case DC_ENUMRESOLUTIONS:
        case DC_FILEDEPENDENCIES:
        case DC_PAPERNAMES:

            LOGDEBUG(LOG_TRACE, ("WG32DeviceCapabilities more complicated:\n"));

            // We've got to figure out how much memory we will need
            GETMISCPTR(vpOutput4, pOutput4);
            if (pOutput4) {

                cb = (*spoolerapis[WOW_DEVICECAPABILITIES].lpfn)(psz1,
                                                                 psz2,
                                                                 fwCap3,
                                                                 NULL,
                                                                 lpdmInput5);

                FREEPSZPTR(pOutput4); // invalidate -16bit memory may have moved

                LOGDEBUG(LOG_TRACE, ("we need %d bytes ", cb));

                if (cb > 0) {

                    switch (fwCap3) {

                        case DC_PAPERS:
                            cb *= 2;
                            break;

                        case DC_BINNAMES:
                            cb *= 24;
                            break;

                        case DC_BINS:
                            cb*=2;
                            break;

                        case DC_FILEDEPENDENCIES:
                        case DC_PAPERNAMES:
                            cb *= 64;
                            break;

                        case DC_MAXEXTENT:
                        case DC_MINEXTENT:
                        case DC_PAPERSIZE:
                            cb *= 8;

                            LOGDEBUG(LOG_TRACE, ("DC_PAPERSIZE called: Needed %d bytes\n", cb));

                            break;

                        case DC_ENUMRESOLUTIONS:
                            cb *= sizeof(LONG)*2;
                            break;

                    } // end switch

                    pOutput32 = malloc_w(cb);

                    if (pOutput32) {

                        l = (*spoolerapis[WOW_DEVICECAPABILITIES].lpfn)(psz1, psz2, fwCap3, pOutput32, lpdmInput5);

                        if (l >= 0) {

                            GETMISCPTR(vpOutput4, pOutput4);

                            switch (fwCap3) {

                                case DC_PAPERS:
                                    if (CURRENTPTD()->dwWOWCompatFlags &
                                        WOWCF_RESETPAPER29ANDABOVE) {

                                        // wordperfect for windows 5.2 GPs if
                                        // papertype is > 0x28. so reset such
                                        // paper types to 0x1. In particular
                                        // this happens if the selected printer
                                        // is Epson LQ-510.
                                        //                       - nanduri

                                        LONG i = l;
                                        while(i--) {
                                            if (((LPWORD)pOutput32)[i] > 0x28) {
                                                ((LPWORD)pOutput32)[i] = 0x1;
                                            }
                                        }
                                    } // end if

                                    RtlCopyMemory(pOutput4, pOutput32, cb);
                                    break;

                                case DC_MAXEXTENT:
                                case DC_MINEXTENT:
                                case DC_PAPERSIZE:
                                    LOGDEBUG(LOG_TRACE, ("Copying %d points from %0x to %0x\n", l, pOutput32, pOutput4));

                                    putpoint16(vpOutput4, l,(LPPOINT)pOutput32);
                                    break;

                                default:
                                    LOGDEBUG(LOG_TRACE, ("Copying %d bytes from %0x to %0x\n",cb, pOutput32, pOutput4));

                                    RtlCopyMemory(pOutput4, pOutput32, cb);
                                    break;

                            } // end switch

                            FLUSHVDMPTR(vpOutput4, (USHORT)cb, pOutput4);
                            FREEPSZPTR(pOutput4);

                        } // end if

                        free_w(pOutput32);

                    } else
                        l = -1;
                } else
                    l = cb;


            } else {


                l = (*spoolerapis[WOW_DEVICECAPABILITIES].lpfn)(psz1,
                                                                psz2,
                                                                fwCap3,
                                                                NULL,
                                                                lpdmInput5);

                LOGDEBUG(LOG_TRACE, ("No Output buffer specified: Returning %d\n", l));
            }

            break;

        default:
            LOGDEBUG(LOG_TRACE, ("!!!! WG32DeviceCapabilities unhandled %d\n", fwCap3));
            l = -1L;
            break;

    } // end switch

    if (lpdmInput5) {
        free_w(lpdmInput5);
    }
ExitPath:
    if(psz1) {
        free_w(psz1);
    }
    if(psz2) {
        free_w(psz2);
    }

    RETURN(l);
}




BOOL LoadLibraryAndGetProcAddresses(char *name, DLLENTRYPOINTS *p, int num)
{
    int     i;
    HINSTANCE   hInst;

    if (!(hInst = SafeLoadLibrary (name))) {
        WOW32ASSERTMSGF (FALSE, ("WOW::LoadLibraryAndGetProcAddresses: LoadLibrary('%s') failed\n", name));
        return FALSE;
    }

    for (i = 0; i < num ; i++) {
        p[i].lpfn = (void *) GetProcAddress (hInst, (p[i].name));
        WOW32ASSERTMSGF (p[i].lpfn, ("WOW::LoadLibraryAndGetProcAddresses: GetProcAddress(%s, '%s') failed\n", name, p[i].name));
    }

    return TRUE;
}

#ifdef i386
/*
 * "Safe" version of LoadLibrary which preserves floating-point state
 * across the load.  This is critical on x86 because the FP state being
 * preserved is the 16-bit app's state.  MSVCRT.DLL is one offender which
 * changes the Precision bits in its Dll init routine.
 *
 * On RISC, this is an alias for LoadLibrary
 *
 */
HINSTANCE SafeLoadLibrary(char *name)
{
    HINSTANCE hInst;
    BYTE FpuState[108];

    // Save the 487 state
    _asm {
        lea    ecx, [FpuState]
        fsave  [ecx]
    }

    hInst = LoadLibrary(name);

    // Restore the 487 state
    _asm {
        lea    ecx, [FpuState]
        frstor [ecx]
    }

    return hInst;
}
#endif  //i386
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgtbl2.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGTBL2.h
 *  WOW32 16-bit GDI API tables
 *
 *  History:
 *  Created 27-Jan-1991 by Jeff Parsons (jeffpar)
--*/

    {W32FUN(UNIMPLEMENTEDAPI,               "DUMMYENTRY",               MOD_GDI,   0)},
    {W32FUN(IT(SetBkColor),                 "SetBkColor",               MOD_GDI,   sizeof(SETBKCOLOR16))},
    {W32FUN(IT(SetBkMode),                  "SetBkMode",                MOD_GDI,   sizeof(SETBKMODE16))},
    {W32FUN(IT(SetMapMode),                 "SetMapMode",               MOD_GDI,   sizeof(SETMAPMODE16))},
    {W32FUN(IT(SetROP2),                    "SetROP2",                  MOD_GDI,   sizeof(SETROP216))},
    {W32FUN(IT(SetRelAbs),                  "SetRelAbs",                MOD_GDI,   sizeof(SETRELABS16))},
    {W32FUN(IT(SetPolyFillMode),            "SetPolyFillMode",          MOD_GDI,   sizeof(SETPOLYFILLMODE16))},
    {W32FUN(IT(SetStretchBltMode),          "SetStretchBltMode",        MOD_GDI,   sizeof(SETSTRETCHBLTMODE16))},
    {W32FUN(IT(SetTextCharacterExtra),      "SetTextCharacterExtra",    MOD_GDI,   sizeof(SETTEXTCHARACTEREXTRA16))},
    {W32FUN(IT(SetTextColor),               "SetTextColor",             MOD_GDI,   sizeof(SETTEXTCOLOR16))},

  /*** 0010 ***/
    {W32FUN(IT(SetTextJustification),       "SetTextJustification",     MOD_GDI,   sizeof(SETTEXTJUSTIFICATION16))},
    {W32FUN(WG32SetWindowOrg,               "SETWINDOWORG",             MOD_GDI,   sizeof(SETWINDOWORG16))},
    {W32FUN(WG32SetWindowExt,               "SETWINDOWEXT",             MOD_GDI,   sizeof(SETWINDOWEXT16))},
    {W32FUN(WG32SetViewportOrg,             "SETVIEWPORTORG",           MOD_GDI,   sizeof(SETVIEWPORTORG16))},
    {W32FUN(WG32SetViewportExt,             "SETVIEWPORTEXT",           MOD_GDI,   sizeof(SETVIEWPORTEXT16))},
    {W32FUN(WG32OffsetWindowOrg,            "OFFSETWINDOWORG",          MOD_GDI,   sizeof(OFFSETWINDOWORG16))},
    {W32FUN(WG32ScaleWindowExt,             "SCALEWINDOWEXT",           MOD_GDI,   sizeof(SCALEWINDOWEXT16))},
    {W32FUN(WG32OffsetViewportOrg,          "OFFSETVIEWPORTORG",        MOD_GDI,   sizeof(OFFSETVIEWPORTORG16))},
    {W32FUN(WG32ScaleViewportExt,           "SCALEVIEWPORTEXT",         MOD_GDI,   sizeof(SCALEVIEWPORTEXT16))},
    {W32FUN(IT(LineTo),                     "LineTo",                   MOD_GDI,   sizeof(LINETO16))},

  /*** 0020 ***/
    {W32FUN(WG32MoveTo,                     "MoveTo",                   MOD_GDI,   sizeof(MOVETO16))},
    {W32FUN(IT(ExcludeClipRect),            "ExcludeClipRect",          MOD_GDI,   sizeof(EXCLUDECLIPRECT16))},
    {W32FUN(IT(IntersectClipRect),          "IntersectClipRect",        MOD_GDI,   sizeof(INTERSECTCLIPRECT16))},
    {W32FUN(IT(Arc),                        "Arc",                      MOD_GDI,   sizeof(ARC16))},
    {W32FUN(IT(Ellipse),                    "Ellipse",                  MOD_GDI,   sizeof(ELLIPSE16))},
    {W32FUN(IT(FloodFill),                  "FloodFill",                MOD_GDI,   sizeof(FLOODFILL16))},
    {W32FUN(IT(Pie),                        "Pie",                      MOD_GDI,   sizeof(PIE16))},
    {W32FUN(IT(Rectangle),                  "Rectangle",                MOD_GDI,   sizeof(RECTANGLE16))},
    {W32FUN(IT(RoundRect),                  "RoundRect",                MOD_GDI,   sizeof(ROUNDRECT16))},
    {W32FUN(IT(PatBlt),                     "PatBlt",                   MOD_GDI,   sizeof(PATBLT16))},

  /*** 0030 ***/
    {W32FUN(IT(SaveDC),                     "SaveDC",                   MOD_GDI,   sizeof(SAVEDC16))},
    {W32FUN(IT(SetPixel),                   "SetPixel",                 MOD_GDI,   sizeof(SETPIXEL16))},
    {W32FUN(IT(OffsetClipRgn),              "OffsetClipRgn",            MOD_GDI,   sizeof(OFFSETCLIPRGN16))},
    {W32FUN(IT(TextOut),                    "TextOut",                  MOD_GDI,   sizeof(TEXTOUT16))},
    {W32FUN(IT(BitBlt),                     "BitBlt",                   MOD_GDI,   sizeof(BITBLT16))},
    {W32FUN(IT(StretchBlt),                 "StretchBlt",               MOD_GDI,   sizeof(STRETCHBLT16))},
    {W32FUN(WG32Polygon,                    "Polygon",                  MOD_GDI,   sizeof(POLYGON16))},
    {W32FUN(WG32Polyline,                   "Polyline",                 MOD_GDI,   sizeof(POLYLINE16))},
    {W32FUN(WG32Escape,                     "Escape",                   MOD_GDI,   sizeof(ESCAPE16))},
    {W32FUN(IT(RestoreDC),                  "RestoreDC",                MOD_GDI,   sizeof(RESTOREDC16))},

  /*** 0040 ***/
    {W32FUN(IT(FillRgn),                    "FillRgn",                  MOD_GDI,   sizeof(FILLRGN16))},
    {W32FUN(IT(FrameRgn),                   "FrameRgn",                 MOD_GDI,   sizeof(FRAMERGN16))},
    {W32FUN(IT(InvertRgn),                  "InvertRgn",                MOD_GDI,   sizeof(INVERTRGN16))},
    {W32FUN(IT(PaintRgn),                   "PaintRgn",                 MOD_GDI,   sizeof(PAINTRGN16))},
    {W32FUN(IT(SelectClipRgn),              "SelectClipRgn",            MOD_GDI,   sizeof(SELECTCLIPRGN16))},
    {W32FUN(IT(SelectObject),               "SelectObject",             MOD_GDI,   sizeof(SELECTOBJECT16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "BITMAPBITS",               MOD_GDI,   0)},
    {W32FUN(IT(CombineRgn),                 "CombineRgn",               MOD_GDI,   sizeof(COMBINERGN16))},
    {W32FUN(WG32CreateBitmap,               "CREATEBITMAP",             MOD_GDI,   sizeof(CREATEBITMAP16))},
    {W32FUN(WG32CreateBitmapIndirect,       "CREATEBITMAPINDIRECT",     MOD_GDI,   sizeof(CREATEBITMAPINDIRECT16))},

  /*** 0050 ***/
    {W32FUN(WG32CreateBrushIndirect,        "CREATEBRUSHINDIRECT",      MOD_GDI,   sizeof(CREATEBRUSHINDIRECT16))},
    {W32FUN(IT(CreateCompatibleBitmap),     "CreateCompatibleBitmap",   MOD_GDI,   sizeof(CREATECOMPATIBLEBITMAP16))},
    {W32FUN(WG32CreateCompatibleDC,         "CREATECOMPATIBLEDC",       MOD_GDI,   sizeof(CREATECOMPATIBLEDC16))},
    {W32FUN(WG32CreateDC,                   "CREATEDC",                 MOD_GDI,   sizeof(CREATEDC16))},
    {W32FUN(IT(CreateEllipticRgn),          "CreateEllipticRgn",        MOD_GDI,   sizeof(CREATEELLIPTICRGN16))},
    {W32FUN(WG32CreateEllipticRgnIndirect,  "CREATEELLIPTICRGNINDIRECT",MOD_GDI,   sizeof(CREATEELLIPTICRGNINDIRECT16))},
    {W32FUN(WG32CreateFont,                 "CREATEFONT",               MOD_GDI,   sizeof(CREATEFONT16))},
    {W32FUN(WG32CreateFontIndirect,         "CREATEFONTINDIRECT",       MOD_GDI,   sizeof(CREATEFONTINDIRECT16))},
    {W32FUN(IT(CreateHatchBrush),           "CreateHatchBrush",         MOD_GDI,   sizeof(CREATEHATCHBRUSH16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0060 ***/
    {W32FUN(WG32CreatePatternBrush,         "CREATEPATTERNBRUSH",       MOD_GDI,   sizeof(CREATEPATTERNBRUSH16))},
    {W32FUN(IT(CreatePen),                  "CreatePen",                MOD_GDI,   sizeof(CREATEPEN16))},
    {W32FUN(WG32CreatePenIndirect,          "CREATEPENINDIRECT",        MOD_GDI,   sizeof(CREATEPENINDIRECT16))},
    {W32FUN(WG32CreatePolygonRgn,           "CREATEPOLYGONRGN",         MOD_GDI,   sizeof(CREATEPOLYGONRGN16))},
    {W32FUN(IT(CreateRectRgn),              "CreateRectRgn",            MOD_GDI,   sizeof(CREATERECTRGN16))},
    {W32FUN(WG32CreateRectRgnIndirect,      "CreateRectRgnIndirect",    MOD_GDI,   sizeof(CREATERECTRGNINDIRECT16))},
    {W32FUN(IT(CreateSolidBrush),           "CreateSolidBrush",         MOD_GDI,   sizeof(CREATESOLIDBRUSH16))},
    {W32FUN(WG32DPtoLP,                     "DPTOLP",                   MOD_GDI,   sizeof(DPTOLP16))},
    {W32FUN(WG32DeleteDC,                   "DELETEDC",                 MOD_GDI,   sizeof(DELETEDC16))},
    {W32FUN(WG32DeleteObject,               "DELETEOBJECT",             MOD_GDI,   sizeof(DELETEOBJECT16))},

  /*** 0070 ***/
    {W32FUN(WG32EnumFonts,                  "ENUMFONTS",                MOD_GDI,   sizeof(ENUMFONTS16))},
    {W32FUN(WG32EnumObjects,                "ENUMOBJECTS",              MOD_GDI,   sizeof(ENUMOBJECTS16))},
    {W32FUN(IT(EqualRgn),                   "EqualRgn",                 MOD_GDI,   sizeof(EQUALRGN16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "EXCLUDEVISRECT",           MOD_GDI,   0)},
    {W32FUN(IT(GetBitmapBits),              "GetBitmapBits",            MOD_GDI,   sizeof(GETBITMAPBITS16))},
    {W32FUN(IT(GetBkColor),                 "GetBkColor",               MOD_GDI,   sizeof(GETBKCOLOR16))},
    {W32FUN(IT(GetBkMode),                  "GetBkMode",                MOD_GDI,   sizeof(GETBKMODE16))},
    {W32FUN(WG32GetClipBox,                 "GETCLIPBOX",               MOD_GDI,   sizeof(GETCLIPBOX16))},
    {W32FUN(WG32GetCurrentPosition,         "GETCURRENTPOSITION",       MOD_GDI,   sizeof(GETCURRENTPOSITION16))},
    {W32FUN(WG32GetDCOrg,                   "GETDCORG",                 MOD_GDI,   sizeof(GETDCORG16))},

  /*** 0080 ***/
    {W32FUN(WG32GetDeviceCaps,              "GETDEVICECAPS",            MOD_GDI,   sizeof(GETDEVICECAPS16))},
    {W32FUN(IT(GetMapMode),                 "GetMapMode",               MOD_GDI,   sizeof(GETMAPMODE16))},
    {W32FUN(WG32GetObject,                  "GETOBJECT",                MOD_GDI,   sizeof(GETOBJECT16))},
    {W32FUN(IT(GetPixel),                   "GetPixel",                 MOD_GDI,   sizeof(GETPIXEL16))},
    {W32FUN(IT(GetPolyFillMode),            "GetPolyFillMode",          MOD_GDI,   sizeof(GETPOLYFILLMODE16))},
    {W32FUN(IT(GetROP2),                    "GetROP2",                  MOD_GDI,   sizeof(GETROP216))},
    {W32FUN(IT(GetRelAbs),                  "GetRelAbs",                MOD_GDI,   sizeof(GETRELABS16))},
    {W32FUN(IT(GetStockObject),             "GetStockObject",           MOD_GDI,   sizeof(GETSTOCKOBJECT16))},
    {W32FUN(IT(GetStretchBltMode),          "GetStretchBltMode",        MOD_GDI,   sizeof(GETSTRETCHBLTMODE16))},
    {W32FUN(IT(GetTextCharacterExtra),      "GetTextCharacterExtra",    MOD_GDI,   sizeof(GETTEXTCHARACTEREXTRA16))},

  /*** 0090 ***/
    {W32FUN(IT(GetTextColor),               "GetTextColor",             MOD_GDI,   sizeof(GETTEXTCOLOR16))},
    {W32FUN(WG32GetTextExtent,              "GetTextExtent",            MOD_GDI,   sizeof(GETTEXTEXTENT16))},
    {W32FUN(IT(GetTextFace),                "GetTextFace",              MOD_GDI,   sizeof(GETTEXTFACE16))},
    {W32FUN(WG32GetTextMetrics,             "GetTextMetrics",           MOD_GDI,   sizeof(GETTEXTMETRICS16))},
    {W32FUN(WG32GetViewportExt,             "GetViewportExt",           MOD_GDI,   sizeof(GETVIEWPORTEXT16))},
    {W32FUN(WG32GetViewportOrg,             "GetViewportOrg",           MOD_GDI,   sizeof(GETVIEWPORTORG16))},
    {W32FUN(WG32GetWindowExt,               "GetWindowExt",             MOD_GDI,   sizeof(GETWINDOWEXT16))},
    {W32FUN(WG32GetWindowOrg,               "GetWindowOrg",             MOD_GDI,   sizeof(GETWINDOWORG16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "INTERSECTVISRECT",         MOD_GDI,   0)},
    {W32FUN(WG32LPtoDP,                     "LPtoDP",                   MOD_GDI,   sizeof(LPTODP16))},

  /*** 0100 ***/
    {W32FUN(WG32LineDDA,                    "LineDDA",                  MOD_GDI,   sizeof(LINEDDA16))},
    {W32FUN(IT(OffsetRgn),                  "OffsetRgn",                MOD_GDI,   sizeof(OFFSETRGN16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "OFFSETVISRGN",             MOD_GDI,   0)},
    {W32FUN(IT(PtVisible),                  "PtVisible",                MOD_GDI,   sizeof(PTVISIBLE16))},
    {W32FUN(WG32RectVisible,                "RectVisible",              MOD_GDI,   sizeof(RECTVISIBLE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "SELECTVISRGN",             MOD_GDI,   0)},
    {W32FUN(WG32SetBitmapBits,              "SetBitmapBits",            MOD_GDI,   sizeof(SETBITMAPBITS16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0110 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "SETDCORG",                 MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "INTERNALCREATEDC",         MOD_GDI,   0)},
    {W32FUN(WG32AddFontResource,            "ADDFONTRESOURCE",          MOD_GDI,   sizeof(ADDFONTRESOURCE16))},

  /*** 0120 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DEATH",                    MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "RESURRECTION",             MOD_GDI,   0)},
    {W32FUN(WG32PlayMetaFile,               "PLAYMETAFILE",             MOD_GDI,   sizeof(PLAYMETAFILE16))},
    {W32FUN(WG32GetMetaFile,                "GETMETAFILE",              MOD_GDI,   sizeof(GETMETAFILE16))},
    {W32FUN(WG32CreateMetaFile,             "CREATEMETAFILE",           MOD_GDI,   sizeof(CREATEMETAFILE16))},
    {W32FUN(WG32CloseMetaFile,              "CLOSEMETAFILE",            MOD_GDI,   sizeof(CLOSEMETAFILE16))},
    {W32FUN(WG32DeleteMetaFile,             "DELETEMETAFILE",           MOD_GDI,   sizeof(DELETEMETAFILE16))},
    {W32FUN(LOCALAPI,                       "MULDIV",                   MOD_GDI,   sizeof(MULDIV16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "SAVEVISRGN",               MOD_GDI,   0)},

  /*** 0130 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "RESTOREVISRGN",            MOD_GDI,   0)},
    {W32FUN(WG32InquireVisRgn,              "INQUIREVISRGN",            MOD_GDI,   0)},
    {W32FUN(NOPAPI,                         "SETENVIRONMENT",           MOD_GDI,   sizeof(SETENVIRONMENT16))},
    {W32FUN(WG32GetEnvironment,             "GETENVIRONMENT",           MOD_GDI,   sizeof(GETENVIRONMENT16))},
    {W32FUN(WG32GetRgnBox,                  "GETRGNBOX",                MOD_GDI,   sizeof(GETRGNBOX16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "SCANLR",                   MOD_GDI,   0)},
    {W32FUN(WG32RemoveFontResource,         "REMOVEFONTRESOURCE",       MOD_GDI,   sizeof(REMOVEFONTRESOURCE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "GSV",                      MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DPXLATE",                  MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "SETWINVIEWEXT",            MOD_GDI,   0)},

  /*** 0140 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "SCALEEXT",                 MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "WORDSET",                  MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "RECTSTUFF",                MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "OFFSETORG",                MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(WG32SetBrushOrg,                "SETBRUSHORG",              MOD_GDI,   sizeof(SETBRUSHORG16))},
    {W32FUN(WG32GetBrushOrg,                "GETBRUSHORG",              MOD_GDI,   sizeof(GETBRUSHORG16))},

  /*** 0150 ***/
    {W32FUN(IT(UnrealizeObject),            "UnrealizeObject",          MOD_GDI,   sizeof(UNREALIZEOBJECT16))},
    {W32FUN(WG32CopyMetaFile,               "COPYMETAFILE",             MOD_GDI,   sizeof(COPYMETAFILE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(WG32CreateIC,                   "CREATEIC",                 MOD_GDI,   sizeof(CREATEIC16))},
    {W32FUN(IT(GetNearestColor),            "GetNearestColor",          MOD_GDI,   sizeof(GETNEARESTCOLOR16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "QUERYABORT",               MOD_GDI,   0)},
    {W32FUN(IT(CreateDiscardableBitmap),    "CreateDiscardableBitmap",  MOD_GDI,   sizeof(CREATEDISCARDABLEBITMAP16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "COMPATIBLEBITMAP",         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "ENUMCALLBACK",             MOD_GDI,   0)},
    {W32FUN(LOCALAPI,                       "GETMETAFILEBITS",          MOD_GDI,   0)},

  /*** 0160 ***/
    {W32FUN(LOCALAPI,                       "SETMETAFILEBITS",          MOD_GDI,   0)},
    {W32FUN(IT(PtInRegion),                 "PtInRegion",               MOD_GDI,   sizeof(PTINREGION16))},
    {W32FUN(WG32GetBitmapDimension,         "GETBITMAPDIMENSION",       MOD_GDI,   sizeof(GETBITMAPDIMENSION16))},
    {W32FUN(WG32SetBitmapDimension,         "SETBITMAPDIMENSION",       MOD_GDI,   sizeof(SETBITMAPDIMENSION16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "PIXTOLINE",                MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "ISDCDIRTY",                MOD_GDI,   0)},

  /*** 0170 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "SETDCSTATUS",              MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "LVBUNION",                 MOD_GDI,   0)},
    {W32FUN(IT(SetRectRgn),                 "SetRectRgn",               MOD_GDI,   sizeof(SETRECTRGN16))},
    {W32FUN(WG32GetClipRgn,                 "GetClipRgn",               MOD_GDI,   sizeof(GETCLIPRGN16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(WG32EnumMetaFile,               "ENUMMETAFILE",             MOD_GDI,   sizeof(ENUMMETAFILE16))},
    {W32FUN(WG32PlayMetaFileRecord,         "PLAYMETAFILERECORD",       MOD_GDI,   sizeof(PLAYMETAFILERECORD16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "RCOS",                     MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "RSIN",                     MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETDCSTATE",               MOD_GDI,   0)},

  /*** 0180 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "SETDCSTATE",               MOD_GDI,   0)},
    {W32FUN(WG32RectInRegion,               "RECTINREGION",             MOD_GDI,   sizeof(RECTINREGION16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "STUFFVISIBLE",             MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "STUFFINREGION",            MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DELETEABOVELINEFONTS",     MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "GetTextExtentEx",          MOD_GDI,   sizeof(GETTEXTEXTENTEX16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0190 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(WG32SetBoundsRect,              "SETBOUNDSRECT",            MOD_GDI,   sizeof(SETBOUNDSRECT16))},
    {W32FUN(WG32GetBoundsRect,              "GETBOUNDSRECT",            MOD_GDI,   sizeof(GETBOUNDSRECT16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(LOCALAPI,                       "SETMETAFILEBITSBETTER",    MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0200 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(WG32DMBitBlt,                   "DMBITBLT",                 MOD_GDI,   sizeof(DMBITBLT16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "DMCOLORINFO",              MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DMENUMDFONTS",             MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DMENUMOBJ",                MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DMOUTPUT",                 MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DMPIXEL",                  MOD_GDI,   0)},

  /*** 0210 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "DMREALIZEOBJECT",          MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DMSTRBLT",                 MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DMSCANLR",                 MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "BRUTE",                    MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DMEXTTEXTOUT",             MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DMGETCHARWIDTH",           MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DMSTRETCHBLT",             MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DMDIBBITS",                MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DMSTRETCHDIBITS",          MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DMSETDIBTODEV",            MOD_GDI,   0)},

  /*** 0220 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "DMTRANSPOSE",              MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0230 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "CREATEPQ",                 MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "MINPQ",                    MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "EXTRACTPQ",                MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "INSERTPQ",                 MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "SIZEPQ",                   MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DELETEPQ",                 MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0240 ***/
    {W32FUN(WG32OpenJob,                    "OPENJOB",                  MOD_GDI,   sizeof(OPENJOB16))},
    {W32FUN(WG32WriteSpool,                 "WRITESPOOL",               MOD_GDI,   sizeof(WRITESPOOL16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "WRITEDIALOG",              MOD_GDI,   sizeof(WRITEDIALOG16))},
    {W32FUN(WG32CloseJob,                   "CLOSEJOB",                 MOD_GDI,   sizeof(CLOSEJOB16))},
    {W32FUN(WG32DeleteJob,                  "DELETEJOB",                MOD_GDI,   sizeof(DELETEJOB16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETSPOOLJOB",              MOD_GDI,   0)},
    {W32FUN(WG32StartSpoolPage,             "STARTSPOOLPAGE",           MOD_GDI,   sizeof(STARTSPOOLPAGE16))},
    {W32FUN(WG32EndSpoolPage,               "ENDSPOOLPAGE",             MOD_GDI,   sizeof(ENDSPOOLPAGE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "QUERYJOB",                 MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0250 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "COPY",                     MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DELETESPOOLPAGE",          MOD_GDI,   0)},
    {W32FUN(WG32SpoolFile,                  "SPOOLFILE",                MOD_GDI,   sizeof(SPOOLFILE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0260 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "GETOBJECTTYPE",            MOD_GDI,   0)},
    {W32FUN(IT(GetCurrentObject),           "GetCurrentObject",         MOD_GDI,   sizeof(GETCURRENTOBJECT16))},
    {W32FUN(IT(GetRegionData),              "GetRegionData",            MOD_GDI,   sizeof(GETREGIONDATA16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "OpenPrinterA",             MOD_GDI,   sizeof(OPENPRINTERA16))},
    {W32FUN(UNIMPLEMENTED95API,             "StartDocPrinterA",         MOD_GDI,   sizeof(STARTDOCPRINTERA16))},
    {W32FUN(UNIMPLEMENTED95API,             "StartPagePrinter",         MOD_GDI,   sizeof(STARTPAGEPRINTER16))},
    {W32FUN(UNIMPLEMENTED95API,             "WritePrinter",             MOD_GDI,   sizeof(WRITEPRINTER16))},

  /*** 0270 ***/
    {W32FUN(UNIMPLEMENTED95API,             "EndPagePrinter",           MOD_GDI,   sizeof(ENDPAGEPRINTER16))},
    {W32FUN(UNIMPLEMENTED95API,             "AbortPrinter",             MOD_GDI,   sizeof(ABORTPRINTER16))},
    {W32FUN(UNIMPLEMENTED95API,             "EndDocPrinter",            MOD_GDI,   sizeof(ENDDOCPRINTER16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "ClosePrinter",             MOD_GDI,   sizeof(CLOSEPRINTER16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0280 ***/
    {W32FUN(UNIMPLEMENTED95API,             "GetRealDriverInfo",        MOD_GDI,   sizeof(GETREALDRIVERINFO16))},
    {W32FUN(UNIMPLEMENTED95API,             "DrvSetPrinterData",        MOD_GDI,   sizeof(DRVSETPRINTERDATA16))},
    {W32FUN(UNIMPLEMENTED95API,             "DrvGetPrinterData",        MOD_GDI,   sizeof(DRVGETPRINTERDATA16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0290 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "EngineGetCharWidthEx",     MOD_GDI,   sizeof(ENGINEGETCHARWIDTHEX16))},

  /*** 0300 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "ENGINEENUMERATEFONT",      MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "ENGINEDELETEFONT",         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "ENGINEREALIZEFONT",        MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "ENGINEGETCHARWIDTH",       MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "ENGINESETFONTCONTEXT",     MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "EngineGetGlyphBmpExt",     MOD_GDI,   sizeof(ENGINEGETGLYPHBMPEXT16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "ENGINEMAKEFONTDIR",        MOD_GDI,   0)},
    {W32FUN(WG32GetCharABCWidths,           "GETCHARABCWIDTHS",         MOD_GDI,   sizeof(GETCHARABCWIDTHS16))},
    {W32FUN(WG32GetOutlineTextMetrics,      "GETOUTLINETEXTMETRICS",    MOD_GDI,   sizeof(GETOUTLINETEXTMETRICS16))},
    {W32FUN(WG32GetGlyphOutline,            "GETGLYPHOUTLINE",          MOD_GDI,   sizeof(GETGLYPHOUTLINE16))},

  /*** 0310 ***/
    {W32FUN(WG32CreateScalableFontResource, "CreateScalableFontResource",MOD_GDI,  sizeof(CREATESCALABLEFONTRESOURCE16))},
    {W32FUN(IT(GetFontData),                "GetFontData",              MOD_GDI,   sizeof(GETFONTDATA16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "CONVERTOUTLINEFONTFILE",   MOD_GDI,   0)},
    {W32FUN(WG32GetRasterizerCaps,          "GETRASTERIZERCAPS",        MOD_GDI,   sizeof(GETRASTERIZERCAPS16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "ENGINEEXTTEXTOUT",         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "EngineRealizeFontExt",     MOD_GDI,   sizeof(ENGINEREALIZEFONTEXT16))},
    {W32FUN(UNIMPLEMENTED95API,             "EngineGetCharWidthStr",    MOD_GDI,   sizeof(ENGINEGETCHARWIDTHSTR16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0320 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0330 ***/
    {W32FUN(WG32EnumFontFamilies,           "ENUMFONTFAMILIES",         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(WG32GetKerningPairs,            "GETKERNINGPAIRS",          MOD_GDI,   sizeof(GETKERNINGPAIRS16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0340 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(IT(GetTextAlign),               "GetTextAlign",             MOD_GDI,   sizeof(GETTEXTALIGN16))},
    {W32FUN(IT(SetTextAlign),               "SetTextAlign",             MOD_GDI,   sizeof(SETTEXTALIGN16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "MFDRAWTEXT",               MOD_GDI,   0)},
    {W32FUN(IT(Chord),                      "Chord",                    MOD_GDI,   sizeof(CHORD16))},
    {W32FUN(IT(SetMapperFlags),             "SetMapperFlags",           MOD_GDI,   sizeof(SETMAPPERFLAGS16))},

  /*** 0350 ***/
    {W32FUN(WG32GetCharWidth,               "GETCHARWIDTH",             MOD_GDI,   sizeof(GETCHARWIDTH16))},
    {W32FUN(WG32ExtTextOut,                 "EXTTEXTOUT",               MOD_GDI,   sizeof(EXTTEXTOUT16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETPHYSICALFONTHANDLE",    MOD_GDI,   0)},
    {W32FUN(WG32GetAspectRatioFilter,       "GETASPECTRATIOFILTER",     MOD_GDI,   sizeof(GETASPECTRATIOFILTER16))},
    {W32FUN(NOPAPI,                         "SHRINKGDIHEAP",            MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "FTRAPPING0",               MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0360 ***/
    {W32FUN(IT(CreatePalette),              "CreatePalette",            MOD_GDI,   sizeof(CREATEPALETTE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "GDISELECTPALETTE",         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "GDIREALIZEPALETTE",        MOD_GDI,   0)},
    {W32FUN(IT(GetPaletteEntries),          "GetPaletteEntries",        MOD_GDI,   sizeof(GETPALETTEENTRIES16))},
    {W32FUN(IT(SetPaletteEntries),          "SetPaletteEntries",        MOD_GDI,   sizeof(SETPALETTEENTRIES16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "REALIZEDEFAULTPALETTE",    MOD_GDI,   0)},
    {W32FUN(IT(UpdateColors),               "UpdateColors",             MOD_GDI,   sizeof(UPDATECOLORS16))},
    {W32FUN(IT(AnimatePalette),             "AnimatePalette",           MOD_GDI,   sizeof(ANIMATEPALETTE16))},
    {W32FUN(IT(ResizePalette),              "ResizePalette",            MOD_GDI,   sizeof(RESIZEPALETTE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0370 ***/
    {W32FUN(IT(GetNearestPaletteIndex),     "GetNearestPaletteIndex",   MOD_GDI,   sizeof(GETNEARESTPALETTEINDEX16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(IT(ExtFloodFill),               "ExtFloodFill",             MOD_GDI,   sizeof(EXTFLOODFILL16))},
    {W32FUN(IT(SetSystemPaletteUse),        "SetSystemPaletteUse",      MOD_GDI,   sizeof(SETSYSTEMPALETTEUSE16))},
    {W32FUN(IT(GetSystemPaletteUse),        "GetSystemPaletteUse",      MOD_GDI,   sizeof(GETSYSTEMPALETTEUSE16))},
    {W32FUN(WG32GetSystemPaletteEntries,    "GetSystemPaletteEntries",  MOD_GDI,   sizeof(GETSYSTEMPALETTEENTRIES16))},
    {W32FUN(WG32ResetDC,                    "ResetDC",                  MOD_GDI,   sizeof(RESETDC16))},
    {W32FUN(WG32StartDoc,                   "StartDoc",                 MOD_GDI,   sizeof(STARTDOC16))},
    {W32FUN(WG32EndDoc,                     "EndDoc",                   MOD_GDI,   sizeof(ENDDOC16))},
    {W32FUN(IT(StartPage),                  "StartPage",                MOD_GDI,   sizeof(STARTPAGE16))},

  /*** 0380 ***/
    {W32FUN(IT(EndPage),                    "EndPage",                  MOD_GDI,   sizeof(ENDPAGE16))},
    {W32FUN(WG32SetAbortProc,               "SetAbortProc",             MOD_GDI,   sizeof(SETABORTPROC16))},
    {W32FUN(WG32AbortDoc,                   "AbortDoc",                 MOD_GDI,   sizeof(ABORTDOC16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0390 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0400 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "FASTWINDOWFRAME",          MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "GDIMOVEBITMAP",            MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "GDIINIT2",                 MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "GetTTGlyphIndexMap",       MOD_GDI,   sizeof(GETTTGLYPHINDEXMAP16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "FINALGDIINIT",             MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "CREATEREALBITMAPINDIRECT", MOD_GDI,   0)},
    {W32FUN(WG32CreateBitmap,               "CREATEUSERBITMAP",         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "CREATEREALBITMAP",         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "CREATEUSERDISCARDABLEBITMAP",MOD_GDI, 0)},

  /*** 0410 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "ISVALIDMETAFILE",          MOD_GDI,   0)},
    {W32FUN(WG32GetCurLogFont,              "GETCURLOGFONT",            MOD_GDI,   sizeof(GETCURLOGFONT16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "ISDCCURRENTPALETTE",       MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0420 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},

  /*** 0430 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(WG32StretchDIBits,              "STRETCHDIBITS",            MOD_GDI,   sizeof(STRETCHDIBITS16))},

  /*** 0440 ***/
    {W32FUN(WG32SetDIBits,                  "SETDIBITS",                MOD_GDI,   sizeof(SETDIBITS16))},
    {W32FUN(WG32GetDIBits,                  "GETDIBITS",                MOD_GDI,   sizeof(GETDIBITS16))},
    {W32FUN(WG32CreateDIBitmap,             "CREATEDIBITMAP",           MOD_GDI,   sizeof(CREATEDIBITMAP16))},
    {W32FUN(WG32SetDIBitsToDevice,          "SETDIBITSTODEVICE",        MOD_GDI,   sizeof(SETDIBITSTODEVICE16))},
    {W32FUN(IT(CreateRoundRectRgn),         "CreateRoundRectRgn",       MOD_GDI,   sizeof(CREATEROUNDRECTRGN16))},
    {W32FUN(WG32CreateDIBPatternBrush,      "CreateDIBPatternBrush",    MOD_GDI,   sizeof(CREATEDIBPATTERNBRUSH16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "DEVICECOLORMATCH",         MOD_GDI,   0)},

  /*** 0450 ***/
    {W32FUN(WG32PolyPolygon,                "PolyPolygon",              MOD_GDI,   sizeof(POLYPOLYGON16))},
    {W32FUN(WG32CreatePolyPolygonRgn,       "CreatePolyPolygonRgn",     MOD_GDI,   sizeof(CREATEPOLYPOLYGONRGN16))},
    {W32FUN(WG32DeviceMode,                 "DeviceMode",               MOD_GDI,   sizeof(DEVICEMODE16))},
    {W32FUN(WG32ExtDeviceMode,              "ExtDeviceMode",            MOD_GDI,   sizeof(EXTDEVICEMODE16))},
    {W32FUN(WG32DeviceCapabilities,         "DeviceCapabilities",       MOD_GDI,   sizeof(DEVICECAPABILITIES16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
#ifdef FE_SB //add GetFontAssocStatus(), pisuih, 10/6/94'
    {W32FUN(WG32GetFontAssocStatus,         "GETFONTASSOCSTATUS",       MOD_GDI,   sizeof(GETFONTASSOCSTATUS16))},
#else   // FE_SB
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_GDI,   0)},
#endif  // FE_SB

  /*** 0460 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "GDITASKTERMINATION",       MOD_GDI,   0)},
    {W32FUN(NOPAPI,                         "SetObjectOwner",           MOD_GDI,   0)},
    {W32FUN(IT(IsGDIObject),                "IsGDIObject",              MOD_GDI,   sizeof(ISGDIOBJECT16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "MAKEOBJECTPRIVATE",        MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "FIXUPBOGUSPUBLISHERMETAFILE",MOD_GDI, 0)},
    {W32FUN(WG32RectVisible,                "RECTVISIBLE_EHH",          MOD_GDI,   sizeof(RECTVISIBLE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "RECTINREGION_EHH",         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "UNICODETOANSI",            MOD_GDI,   0)},
    {W32FUN(WG32GetBitmapDimensionEx,       "GETBITMAPDIMENSIONEX",     MOD_GDI,   sizeof(GETBITMAPDIMENSIONEX16))},
    {W32FUN(WG32GetBrushOrgEx,              "GETBRUSHORGEX",            MOD_GDI,   sizeof(GETBRUSHORGEX16))},

  /*** 0470 ***/
    {W32FUN(WG32GetCurrentPositionEx,       "GETCURRENTPOSITIONEX",     MOD_GDI,   sizeof(GETCURRENTPOSITIONEX16))},
    {W32FUN(WG32GetTextExtentPoint,         "GETTEXTEXTENTPOINT",       MOD_GDI,   sizeof(GETTEXTEXTENTPOINT16))},
    {W32FUN(WG32GetViewportExtEx,           "GETVIEWPORTEXTEX",         MOD_GDI,   sizeof(GETVIEWPORTEXTEX16))},
    {W32FUN(WG32GetViewportOrgEx,           "GETVIEWPORTORGEX",         MOD_GDI,   sizeof(GETVIEWPORTORGEX16))},
    {W32FUN(WG32GetWindowExtEx,             "GETWINDOWEXTEX",           MOD_GDI,   sizeof(GETWINDOWEXTEX16))},
    {W32FUN(WG32GetWindowOrgEx,             "GETWINDOWORGEX",           MOD_GDI,   sizeof(GETWINDOWORGEX16))},
    {W32FUN(WG32OffsetViewportOrgEx,        "OFFSETVIEWPORTORGEX",      MOD_GDI,   sizeof(OFFSETVIEWPORTORGEX16))},
    {W32FUN(WG32OffsetWindowOrgEx,          "OFFSETWINDOWORGEX",        MOD_GDI,   sizeof(OFFSETWINDOWORGEX16))},
    {W32FUN(WG32SetBitmapDimensionEx,       "SETBITMAPDIMENSIONEX",     MOD_GDI,   sizeof(SETBITMAPDIMENSIONEX16))},
    {W32FUN(WG32SetViewportExtEx,           "SETVIEWPORTEXTEX",         MOD_GDI,   sizeof(SETVIEWPORTEXTEX16))},

  /*** 0480 ***/
    {W32FUN(WG32SetViewportOrgEx,           "SETVIEWPORTORGEX",         MOD_GDI,   sizeof(SETVIEWPORTORGEX16))},
    {W32FUN(WG32SetWindowExtEx,             "SETWINDOWEXTEX",           MOD_GDI,   sizeof(SETWINDOWEXTEX16))},
    {W32FUN(WG32SetWindowOrgEx,             "SETWINDOWORGEX",           MOD_GDI,   sizeof(SETWINDOWORGEX16))},
    {W32FUN(WG32MoveToEx,                   "MOVETOEX",                 MOD_GDI,   sizeof(MOVETOEX16))},
    {W32FUN(WG32ScaleViewportExtEx,         "SCALEVIEWPORTEXTEX",       MOD_GDI,   sizeof(SCALEVIEWPORTEXTEX16))},
    {W32FUN(WG32ScaleWindowExtEx,           "SCALEWINDOWEXTEX",         MOD_GDI,   sizeof(SCALEWINDOWEXTEX16))},
    {W32FUN(WG32GetAspectRatioFilterEx,     "GETASPECTRATIOFILTEREX",   MOD_GDI,   sizeof(GETASPECTRATIOFILTEREX16))},
    {W32FUN(WG32PolyPolylineWOW,            "POLYPOLYLINEWOW",          MOD_GDI,   sizeof(POLYPOLYLINEWOW16))},
    {W32FUN(WG32SetDIBColorTable,           "SETDIBCOLORTABLE",         MOD_GDI,   sizeof(SETDIBCOLORTABLE16))},
    {W32FUN(WG32CreateDIBSection,           "CREATEDIBSECTION",         MOD_GDI,   sizeof(CREATEDIBSECTION16))},

  /*** 0490 ***/
    {W32FUN(IT(CloseEnhMetaFile),           "CloseEnhMetaFile",         MOD_GDI,   sizeof(CLOSEENHMETAFILE16))},
    {W32FUN(IT(CopyEnhMetaFile),            "CopyEnhMetaFile",          MOD_GDI,   sizeof(COPYENHMETAFILE16))},
    {W32FUN(WG32CreateEnhMetaFile,          "CreateEnhMetaFile",        MOD_GDI,   sizeof(CREATEENHMETAFILE16))},
    {W32FUN(IT(DeleteEnhMetaFile),          "DeleteEnhMetaFile",        MOD_GDI,   sizeof(DELETEENHMETAFILE16))},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(IT(GdiComment),                 "GdiComment",               MOD_GDI,   sizeof(GDICOMMENT16))},
    {W32FUN(IT(GetEnhMetaFile),             "GetEnhMetaFile",           MOD_GDI,   sizeof(GETENHMETAFILE16))},
    {W32FUN(IT(GetEnhMetaFileBits),         "GetEnhMetaFileBits",       MOD_GDI,   sizeof(GETENHMETAFILEBITS16))},
    {W32FUN(IT(GetEnhMetaFileDescription),  "GetEnhMetaFileDescription",MOD_GDI,   sizeof(GETENHMETAFILEDESCRIPTION16))},
    {W32FUN(IT(GetEnhMetaFileHeader),       "GetEnhMetaFileHeader",     MOD_GDI,   sizeof(GETENHMETAFILEHEADER16))},

  /*** 0500 ***/
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(IT(GetEnhMetaFilePaletteEntries), "GetEnhMetaFilePaletteEntries", MOD_GDI,sizeof(GETENHMETAFILEPALETTEENTRIES16))},
    {W32FUN(UNIMPLEMENTED95API,             "PolyBezier",               MOD_GDI,   sizeof(POLYBEZIER16))},
    {W32FUN(UNIMPLEMENTED95API,             "PolyBezierTo",             MOD_GDI,   sizeof(POLYBEZIERTO16))},
    {W32FUN(IT(PlayEnhMetaFileRecord),      "PlayEnhMetaFileRecord",    MOD_GDI,   sizeof(PLAYENHMETAFILERECORD16))},
    {W32FUN(IT(SetEnhMetaFileBits),         "SetEnhMetaFileBits",       MOD_GDI,   sizeof(SETENHMETAFILEBITS16))},
    {W32FUN(IT(SetMetaRgn),                 "SetMetaRgn",               MOD_GDI,   sizeof(SETMETARGN16))},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(IT(ExtSelectClipRgn),           "ExtSelectClipRgn",         MOD_GDI,   sizeof(EXTSELECTCLIPRGN16))},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},

  /*** 0510 ***/
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(IT(AbortPath),                  "AbortPath",                MOD_GDI,   sizeof(ABORTPATH16))},
    {W32FUN(IT(BeginPath),                  "BeginPath",                MOD_GDI,   sizeof(BEGINPATH16))},
    {W32FUN(IT(CloseFigure),                "CloseFigure",              MOD_GDI,   sizeof(CLOSEFIGURE16))},
    {W32FUN(IT(EndPath),                    "EndPath",                  MOD_GDI,   sizeof(ENDPATH16))},
    {W32FUN(IT(FillPath),                   "FillPath",                 MOD_GDI,   sizeof(FILLPATH16))},
    {W32FUN(IT(FlattenPath),                "FlattenPath",              MOD_GDI,   sizeof(FLATTENPATH16))},
    {W32FUN(IT(GetPath),                    "GetPath",                  MOD_GDI,   sizeof(GETPATH16))},
    {W32FUN(IT(PathToRegion),               "PathToRegion",             MOD_GDI,   sizeof(PATHTOREGION16))},
    {W32FUN(IT(SelectClipPath),             "SelectClipPath",           MOD_GDI,   sizeof(SELECTCLIPPATH16))},

  /*** 0520 ***/
    {W32FUN(IT(StrokeAndFillPath),          "StrokeAndFillPath",        MOD_GDI,   sizeof(STROKEANDFILLPATH16))},
    {W32FUN(IT(StrokePath),                 "StrokePath",               MOD_GDI,   sizeof(STROKEPATH16))},
    {W32FUN(IT(WidenPath),                  "WidenPath",                MOD_GDI,   sizeof(WIDENPATH16))},
    {W32FUN(IT(ExtCreatePen),               "ExtCreatePen",             MOD_GDI,   sizeof(EXTCREATEPEN16))},
    {W32FUN(IT(GetArcDirection),            "GetArcDirection",          MOD_GDI,   sizeof(GETARCDIRECTION16))},
    {W32FUN(IT(SetArcDirection),            "SetArcDirection",          MOD_GDI,   sizeof(SETARCDIRECTION16))},
    {W32FUN(IT(GetMiterLimit),              "GetMiterLimit",            MOD_GDI,   sizeof(GETMITERLIMIT16))},
    {W32FUN(IT(SetMiterLimit),              "SetMiterLimit",            MOD_GDI,   sizeof(SETMITERLIMIT16))},
    {W32FUN(UNIMPLEMENTED95API,             "GdiParametersInfo",        MOD_GDI,   sizeof(GDIPARAMETERSINFO16))},
    {W32FUN(IT(CreateHalftonePalette),      "CreateHalftonePalette",    MOD_GDI,   sizeof(CREATEHALFTONEPALETTE16))},

  /*** 0530 ***/
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},

  /*** 0540 ***/
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},

  /*** 0550 ***/
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},

  /*** 0560 ***/
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},

  /*** 0570 ***/
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},

  /*** 0580 ***/
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},

  /*** 0590 ***/
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},

  /*** 0600 ***/
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                         MOD_GDI,   0)},
    {W32FUN(WG32SetDIBColorTable,           "SETDIBCOLORTABLE",         MOD_GDI,   sizeof(SETDIBCOLORTABLE16))},
    {W32FUN(WG32GetDIBColorTable,           "GETDIBCOLORTABLE",         MOD_GDI,   sizeof(GETDIBCOLORTABLE16))},
    {W32FUN(UNIMPLEMENTED95API,             "SetSolidBrush",            MOD_GDI,   sizeof(SETSOLIDBRUSH16))},
    {W32FUN(UNIMPLEMENTED95API,             "SysDeleteObject",          MOD_GDI,   sizeof(SYSDELETEOBJECT16))},
    {W32FUN(IT(SetMagicColors),             "SetMagicColors",           MOD_GDI,   sizeof(SETMAGICCOLORS16))},
    {W32FUN(IT(GetRegionData),              "GetRegionData",            MOD_GDI,   sizeof(GETREGIONDATA16))},
    {W32FUN(IT(ExtCreateRegion),            "ExtCreateRegion",          MOD_GDI,   sizeof(EXTCREATEREGION16))},
    {W32FUN(LOCALAPI,                       "Avail - GdiFreeResources", MOD_GDI,   0)},

  /*** 0610 ***/
    {W32FUN(UNIMPLEMENTED95API,             "GdiSignalProc32",          MOD_GDI,   sizeof(GDISIGNALPROC3216))},
    {W32FUN(IT(GetRandomRgn),               "GetRandomRgn",             MOD_GDI,   sizeof(GETRANDOMRGN16))},
    {W32FUN(IT(GetTextCharset),             "GetTextCharset",           MOD_GDI,   sizeof(GETTEXTCHARSET16))},
    {W32FUN(UNIMPLEMENTED95API,             "EnumFontFamiliesEx",       MOD_GDI,   sizeof(ENUMFONTFAMILIESEX16))},
    {W32FUN(UNIMPLEMENTED95API,             "AddLPKtoGDI",              MOD_GDI,   sizeof(ADDLPKTOGDI16))},
    {W32FUN(WG32GetCharacterPlacement,      "GetCharacterPlacement",    MOD_GDI,   sizeof(GETCHARACTERPLACEMENT16))},
    {W32FUN(IT(GetFontLanguageInfo),        "GetFontLanguageInfo",      MOD_GDI,   sizeof(GETFONTLANGUAGEINFO16))},
    {W32FUN(UNIMPLEMENTED95API,             "BuildInverseTableDIB",     MOD_GDI,   sizeof(BUILDINVERSETABLEDIB16))},
    {W32FUN(UNIMPLEMENTED95API,             "ICMCreateTransform",       MOD_GDI,   sizeof(ICMCREATETRANSFORM16))},
    {W32FUN(UNIMPLEMENTED95API,             "ICMDeleteTransform",       MOD_GDI,   sizeof(ICMDELETETRANSFORM16))},

  /*** 0620 ***/
    {W32FUN(UNIMPLEMENTED95API,             "ICMTranslateRGB",          MOD_GDI,   sizeof(ICMTRANSLATERGB16))},
    {W32FUN(UNIMPLEMENTED95API,             "ICMTranslateRGBs",         MOD_GDI,   sizeof(ICMTRANSLATERGBS16))},
    {W32FUN(UNIMPLEMENTED95API,             "ICMCheckColorsInGamut",    MOD_GDI,   sizeof(ICMCHECKCOLORSINGAMUT16))},
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgtbl.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGTBL.H
 *  WOW32 16-bit GDI API tables
 *
 *  History:
 *  Created 27-Jan-1991 by Jeff Parsons (jeffpar)
--*/



/* GDI dispatch table
 */
extern W32 aw32GDI[];


#ifdef DEBUG_OR_WOWPROFILE
extern INT iGDIMax;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgtext.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGTEXT.H
 *  WOW32 16-bit GDI API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/



ULONG FASTCALL WG32ExtTextOut(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetTextExtent(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetTextMetrics(PVDMFRAME pFrame);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wheap.c ===
//*****************************************************************************
//
// Small Heap -
//
//     This heap is used for allocating small size linked list structures.
//     This will reduce WOW's working set as the linked structures will be
//     together (less scattered) than if they were allocated from the
//     general purpose wow heap.
//
// 07-Oct-93  NanduriR   Created.
//
//*****************************************************************************

#include "precomp.h"
#pragma hdrstop

MODNAME(wheap.c);



HANDLE hWOWHeapSmall;


BOOL FASTCALL CreateSmallHeap()
{
  hWOWHeapSmall = HeapCreate (HEAP_NO_SERIALIZE, 4096, GROW_HEAP_AS_NEEDED);
  return (BOOL)hWOWHeapSmall;
}


PVOID FASTCALL malloc_w_small (ULONG size)
{
    PVOID pv = HeapAlloc(hWOWHeapSmall, 0, size);

#ifdef DEBUG
    if (pv == (PVOID)NULL) {
        LOGDEBUG(0, ("malloc_w_small: HeapAlloc failed\n"));
    }
#endif
    return pv;

}


BOOL FASTCALL free_w_small(PVOID p)
{
    return HeapFree(hWOWHeapSmall, 0, (LPSTR)(p));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wheap.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WHEAP.H
 *  WOW32 Heap Support (Instead of using malloc/free from CRT)
 *
 *  History:
 *  Created 13-Dec-1991 by Sudeep Bharati (sudeepb)
--*/

//
// Dynamic memory macros
//
// On checked (debug) builds, malloc_w and friends complain when they fail.
//

PVOID FASTCALL malloc_w(ULONG size);
DWORD FASTCALL size_w (PVOID pv);
PVOID FASTCALL malloc_w_zero (ULONG size);
PVOID FASTCALL realloc_w (PVOID p, ULONG size, DWORD dwFlags);
VOID  FASTCALL free_w(PVOID p);
LPSTR malloc_w_strcpy_vp16to32(VPVOID vpstr16, BOOL fMulti, INT cMax);

PVOID FASTCALL malloc_w_or_die(ULONG size);

#define INITIAL_WOW_HEAP_SIZE   32*1024   // 32k
#define GROW_HEAP_AS_NEEDED     0         // grow heap as needed


//*****************************************************************************
// Small Heap -
//*****************************************************************************
BOOL FASTCALL CreateSmallHeap(VOID);
PVOID FASTCALL malloc_w_small (ULONG size);
BOOL FASTCALL free_w_small(PVOID p);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wgtext.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WGTEXT.C
 *  WOW32 16-bit GDI API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
 *  10-Nov-1992 Modified GetTextMetrics to GetTextMetricsWOW by Chandan Chauhan
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wgtext.c);


ULONG FASTCALL WG32ExtTextOut(PVDMFRAME pFrame)
{
    ULONG ul;
    RECT t5;
    PSTR pstr6;
    PINT p8;
    register PEXTTEXTOUT16 parg16;
    INT      BufferT[256];

    GETARGPTR(pFrame, sizeof(EXTTEXTOUT16), parg16);
    GETRECT16(parg16->f5, &t5);
    GETSTRPTR(parg16->f6, parg16->f7, pstr6);
    if (DWORD32(parg16->f8)) {
       p8 = STACKORHEAPALLOC(parg16->f7 * sizeof(INT), sizeof(BufferT), BufferT);
       getintarray16((VPINT16)DWORD32(parg16->f8), parg16->f7, p8);   // *this* INT array is optional
    } else {
        p8 = NULL;
    }


    ul = GETBOOL16(ExtTextOut(
                    HDC32(parg16->f1),
                    INT32(parg16->f2),
                    INT32(parg16->f3),
                    (WORD32(parg16->f4) & (ETO_CLIPPED|ETO_OPAQUE)),
                    &t5,
                    pstr6,
                    WORD32(parg16->f7),
                    (LPINT)p8
                    ));

    FREESTRPTR(pstr6);
    STACKORHEAPFREE(p8, BufferT);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32GetTextExtent(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    PSTR pstr2;
    SIZE size4;
    register PGETTEXTEXTENT16 parg16;

    GETARGPTR(pFrame, sizeof(GETTEXTEXTENT16), parg16);
    GETSTRPTR(parg16->f2, parg16->f3, pstr2);

    if (GETDWORD16(GetTextExtentPoint(
                    HDC32(parg16->f1),
                    pstr2,
                    INT32(parg16->f3),
                    &size4
                   )))
    {
        // check if either cx or cy are bigger than SHRT_MAX == 7fff
        // but do it in ONE SINGLE check

	    if ((size4.cx | size4.cy) & ~SHRT_MAX)
	    {
	        if (size4.cx > SHRT_MAX)
	           ul = SHRT_MAX;
	        else
	           ul = (ULONG)size4.cx;

	        if (size4.cy > SHRT_MAX)
	           ul |= (SHRT_MAX << 16);
	        else
	           ul |= (ULONG)(size4.cy << 16);
	    }
	    else
	    {
	        ul = (ULONG)(size4.cx | (size4.cy << 16));
	    }

    }
    FREESTRPTR(pstr2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WG32GetTextMetrics(PVDMFRAME pFrame)
{
    ULONG ul;
    TEXTMETRIC t2;
    register PGETTEXTMETRICS16 parg16;

    GETARGPTR(pFrame, sizeof(GETTEXTMETRICS16), parg16);

    ul = GETBOOL16(GetTextMetrics(
                    HDC32(parg16->f1),
                    &t2
                  ));

#ifdef FE_SB
    // original source code should be fixed
    // If GetTextMetrics return value is FALSE, don't need set data to 16bit
    // TEXTMETRICS STRUCTURE.
    // kksuzuka #3759 BC++40J is not see return value and used TEXTMETRICS
    // data.  1994.11.16 V-HIDEKK
    if( ul )
#endif // FE_SB

    PUTTEXTMETRIC16(parg16->f2, &t2);

    FREEARGPTR(parg16);
    RETURN(ul);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\win95.c ===
/*++
 *
 *  Windows NT v5.0 WOW
 *
 *  Copyright (c) 1997, Microsoft Corporation
 *
 *  WIN95.C
 *
 *  WOW32 Hand-coded (as opposed to interpreted) thunks for new-for-Win95
 *        exports.
 *
 *  History:
 *  16 Feb 97 Created davehart
--*/

#include "precomp.h"
#pragma hdrstop

MODNAME(win95.c);


ULONG FASTCALL WU32TileWindows(PVDMFRAME pFrame)
{
    return W32TileOrCascadeWindows(pFrame, TileWindows);
}


ULONG FASTCALL WU32CascadeWindows(PVDMFRAME pFrame)
{
    return W32TileOrCascadeWindows(pFrame, CascadeWindows);
}


ULONG FASTCALL W32TileOrCascadeWindows(PVDMFRAME pFrame, PFNTILECASCADEWINDOWS pfnWin32)
{
    register PCASCADEWINDOWS16 parg16;
    ULONG ul;
    RECT rc;
    PRECT prc;
    HWND ahwnd[8];
    DWORD chwnd;
    HWND16 UNALIGNED *phwnd16;
    HWND *phwnd;

    GETARGPTR(pFrame, sizeof(*parg16), parg16);
    chwnd = parg16->chwnd;

    if (parg16->lpRect) {
        GETRECT16(parg16->lpRect, &rc);
        prc = &rc;
    } else {
        prc = NULL;
    }

    if (parg16->ahwnd) {
        phwnd = STACKORHEAPALLOC( chwnd * sizeof(HWND), sizeof(ahwnd), ahwnd);
        phwnd16 = VDMPTR(parg16->ahwnd, chwnd * sizeof(HWND16));

        for (ul = 0; ul < chwnd; ul++) {
            phwnd[ul] = HWND32(phwnd16[ul]);
        }

        FREEVDMPTR(phwnd16);
    } else {
        phwnd = NULL;
    }

    ul = (*pfnWin32)(
             HWND32(parg16->hwndParent),
             parg16->wFlags,
             prc,
             chwnd,
             phwnd
             );

    //
    // Memory movement may have occurred due to message activity,
    // so throw away flat pointers to 16-bit memory.
    //

    FREEARGPTR(parg16);

    if (phwnd) {
        STACKORHEAPFREE(phwnd, ahwnd);
    }

    return ul;
}


ULONG FASTCALL WU32DrawAnimatedRects(PVDMFRAME pFrame)
{
    register PDRAWANIMATEDRECTS16 parg16;
    ULONG ul;
    RECT rcFrom, rcTo;

    GETARGPTR(pFrame, sizeof(*parg16), parg16);
    GETRECT16(parg16->lprcStart, &rcFrom);
    GETRECT16(parg16->lprcEnd, &rcTo);

    ul = DrawAnimatedRects(
             HWND32(parg16->hwndClip),
             parg16->idAnimation,
             &rcFrom,
             &rcTo
             );

    FREEARGPTR(parg16);

    return ul;
}


ULONG FASTCALL WU32DrawCaption(PVDMFRAME pFrame)
{
    register PDRAWCAPTION16 parg16;
    ULONG ul;
    RECT rc;

    GETARGPTR(pFrame, sizeof(*parg16), parg16);
    GETRECT16(parg16->lprc, &rc);

    ul = DrawCaption(
             HWND32(parg16->hwnd),
             HDC32(parg16->hdc),
             &rc,
             parg16->wFlags
             );

    FREEARGPTR(parg16);

    return ul;
}


ULONG FASTCALL WU32DrawEdge(PVDMFRAME pFrame)
{
    return W32DrawEdgeOrFrameControl(pFrame, DrawEdge);
}


ULONG FASTCALL WU32DrawFrameControl(PVDMFRAME pFrame)
{
    return W32DrawEdgeOrFrameControl(pFrame, DrawFrameControl);
}


ULONG FASTCALL W32DrawEdgeOrFrameControl(PVDMFRAME pFrame, PFNDRAWEDGEFRAMECONTROL pfnWin32)
{
    register PDRAWEDGE16 parg16;
    ULONG ul;
    RECT rc;

    GETARGPTR(pFrame, sizeof(*parg16), parg16);
    GETRECT16(parg16->lprc, &rc);

    ul = (*pfnWin32)(
             HDC32(parg16->hdc),
             &rc,
             parg16->wEdge,
             parg16->wFlags
             );

    PUTRECT16(parg16->lprc, &rc);

    FREEARGPTR(parg16);

    return ul;
}


ULONG FASTCALL WU32DrawTextEx(PVDMFRAME pFrame)
{
    register PDRAWTEXTEX16 parg16;
    ULONG ul;
    PSZ psz;
    RECT rc;
    DRAWTEXTPARAMS dtp, *pdtp;
    PDRAWTEXTPARAMS16 pdtp16;

    GETARGPTR(pFrame, sizeof(*parg16), parg16);
    GETVARSTRPTR(parg16->lpchText, parg16->cchText, psz);
    GETRECT16(parg16->lprc, &rc);

    if ( (parg16->lpDTparams)  &&
         (pdtp16 = VDMPTR(parg16->lpDTparams, sizeof(DRAWTEXTPARAMS16))) ) {

        pdtp = &dtp;
        dtp.cbSize = sizeof(dtp);
        dtp.iTabLength = pdtp16->iTabLength;
        dtp.iLeftMargin = pdtp16->iLeftMargin;
        dtp.iRightMargin = pdtp16->iRightMargin;
        dtp.uiLengthDrawn = 0;
    } else {
        pdtp = NULL;
    }

    ul = DrawTextEx(
             HDC32(parg16->hdc),
             psz,
             parg16->cchText,
             &rc,
             parg16->dwDTformat,
             pdtp
             );

    if (pdtp) {
        pdtp16->uiLengthDrawn = (WORD)dtp.uiLengthDrawn;
    }

    FREEVDMPTR(pdtp16);
    FREEVDMPTR(psz);
    FREEARGPTR(parg16);

    return ul;
}


ULONG FASTCALL WU32GetIconInfo(PVDMFRAME pFrame)
{
    register PGETICONINFO16 parg16;
    ULONG ul;
    ICONINFO ii;
    PICONINFO16 pii16;

    GETARGPTR(pFrame, sizeof(*parg16), parg16);

    ul = GetIconInfo(
             HICON32(parg16->hicon),
             &ii
             );

    pii16 = VDMPTR(parg16->lpiconinfo, sizeof(*pii16));
    pii16->fIcon = (BOOL16)ii.fIcon;
    pii16->xHotspot = (INT16)ii.xHotspot;
    pii16->yHotspot = (INT16)ii.yHotspot;
    pii16->hbmMask  = GETHBITMAP16(ii.hbmMask);
    pii16->hbmColor = GETHBITMAP16(ii.hbmColor);
    FREEVDMPTR(pii16);

    FREEARGPTR(pFrame);

    return ul;
}


ULONG FASTCALL WU32GetMenuItemInfo(PVDMFRAME pFrame)
{
    register PGETMENUITEMINFO16 parg16;
    ULONG ul;
    MENUITEMINFO mii;
    PMENUITEMINFO16 pmii16;

    GETARGPTR(pFrame, sizeof(*parg16), parg16);
    GETVDMPTR(parg16->lpmii, sizeof(*pmii16), pmii16);

    mii.cbSize = sizeof(mii);
    mii.fMask = pmii16->fMask;

    FREEVDMPTR(pmii16);

    ul = GetMenuItemInfo(
             HMENU32(parg16->hmenu),
             parg16->wIndex,
             parg16->fByPosition,
             &mii
             );

    putmenuiteminfo16(parg16->lpmii, &mii);

    FREEARGPTR(pFrame);

    return ul;
}


ULONG FASTCALL WU32InsertMenuItem(PVDMFRAME pFrame)
{
    register PINSERTMENUITEM16 parg16;
    ULONG ul;
    MENUITEMINFO mii;

    GETARGPTR(pFrame, sizeof(*parg16), parg16);

    getmenuiteminfo16(parg16->lpmii, &mii);

    ul = InsertMenuItem(
             HMENU32(parg16->hmenu),
             parg16->wIndex,
             parg16->fByPosition,
             &mii
             );


    FREEARGPTR(pFrame);

    return ul;
}


ULONG FASTCALL WU32SetMenuItemInfo(PVDMFRAME pFrame)
{
    register PSETMENUITEMINFO16 parg16;
    ULONG ul;
    MENUITEMINFO mii;

    GETARGPTR(pFrame, sizeof(*parg16), parg16);

    getmenuiteminfo16(parg16->lpmii, &mii);

    ul = SetMenuItemInfo(
             HMENU32(parg16->hmenu),
             parg16->wIndex,
             parg16->fByPosition,
             &mii
             );

    FREEARGPTR(pFrame);

    return ul;
}


ULONG FASTCALL WU32GetMenuItemRect(PVDMFRAME pFrame)
{
    register PGETMENUITEMRECT16 parg16;
    ULONG ul;
    RECT rc;

    GETARGPTR(pFrame, sizeof(*parg16), parg16);

    ul = GetMenuItemRect(
             HWND32(parg16->hwnd),
             HMENU32(parg16->hmenu),
             parg16->wIndex,
             &rc
             );

    PUTRECT16(parg16->lprcScreen, &rc);

    FREEARGPTR(pFrame);

    return ul;
}


ULONG FASTCALL WU32TrackPopupMenuEx(PVDMFRAME pFrame)
{
    register PTRACKPOPUPMENUEX16 parg16;
    ULONG ul;
    TPMPARAMS tpmp;
    LPTPMPARAMS lptpmp;
    VPRECT16 vprcExclude;

    GETARGPTR(pFrame, sizeof(*parg16), parg16);

    if (parg16->lpTpm) {
        lptpmp = &tpmp;
        tpmp.cbSize = sizeof(tpmp);
        vprcExclude = parg16->lpTpm + offsetof(TPMPARAMS16, rcExclude);
        GETRECT16(vprcExclude, &tpmp.rcExclude);
    } else {
        lptpmp = NULL;
    }

    ul = TrackPopupMenuEx(
             HMENU32(parg16->hmenu),
             parg16->wFlags,
             parg16->x,
             parg16->y,
             HWND32(parg16->hwndOwner),
             lptpmp
             );

    FREEARGPTR(pFrame);

    return ul;
}


ULONG FASTCALL WG32GetCharacterPlacement(PVDMFRAME pFrame)
{
    register PGETCHARACTERPLACEMENT16 parg16;
    ULONG ul;
    PSZ pszText;
    PGCP_RESULTS16 pgcp16;
    GCP_RESULTS gcp;

    //
    // Thankfully on Win95 the 16-bit GCP_RESULTS structure
    // points to 32-bit ints, so the structure thunking
    // is trivial.
    //

    GETARGPTR(pFrame, sizeof(*parg16), parg16);
    GETPSZPTR(parg16->lpszText, pszText);
    GETVDMPTR(parg16->lpResults, sizeof(*pgcp16), pgcp16);

    gcp.lStructSize = sizeof gcp;
    gcp.nGlyphs = pgcp16->nGlyphs;
    gcp.nMaxFit = pgcp16->nMaxFit;
    GETOPTPTR(pgcp16->lpOutString, 1, gcp.lpOutString);
    GETOPTPTR(pgcp16->lpOrder, 4, gcp.lpOrder);
    GETOPTPTR(pgcp16->lpDx, 4, gcp.lpDx);
    GETOPTPTR(pgcp16->lpCaretPos, 4, gcp.lpCaretPos);
    GETOPTPTR(pgcp16->lpClass, 1, gcp.lpClass);
    GETOPTPTR(pgcp16->lpGlyphs, 4, gcp.lpGlyphs);

    ul = GetCharacterPlacement(
             HDC32(parg16->hdc),
             pszText,
             parg16->wCount,
             parg16->wMaxExtent,
             &gcp,
             parg16->dwFlags
             );

    pgcp16->nGlyphs = (SHORT)gcp.nGlyphs;
    pgcp16->nMaxFit = (SHORT)gcp.nMaxFit;

    FREEARGPTR(pFrame);

    return ul;
}

//
// On Win95, GetProductName returns "Windows 95".
// We'll return "Windows NT" unless something forces us
// to be identical.
//
// Two flavors:  call with cbBuffer == 0 and it returns
// the length required minus 1 (a bug I think).  Call with
// cbBuffer > 0 and it copies as much as possible and returns
// lpBuffer.
//

ULONG FASTCALL WK32GetProductName(PVDMFRAME pFrame)
{
    register PGETPRODUCTNAME16 parg16;
    ULONG ul;
    PSZ pszBuffer;
    static char szProductName[] = "Windows NT";

    GETARGPTR(pFrame, sizeof(*parg16), parg16);

    if (0 == parg16->cbBuffer) {
        ul = (sizeof szProductName) - 1;
    } else {
        GETVDMPTR(parg16->lpBuffer, parg16->cbBuffer, pszBuffer);
        WOW32VERIFY(pszBuffer == lstrcpyn(pszBuffer, szProductName, parg16->cbBuffer));
        FREEVDMPTR(pszBuffer);
        ul = parg16->lpBuffer;
    }

    FREEARGPTR(pFrame);

    return ul;
}


typedef struct _tagWOWDRAWSTATECALLBACK {
    VPVOID vpfnCallback;
    LPARAM lparamUser;
} WOWDRAWSTATECALLBACK, *PWOWDRAWSTATECALLBACK;


BOOL CALLBACK WOWDrawStateCallback(HDC hdc, LPARAM lData, WPARAM wData, int cx, int cy)
{
    PWOWDRAWSTATECALLBACK pwds = (PWOWDRAWSTATECALLBACK) lData;
    ULONG ul;
    WORD awCallbackArgs[6];

    awCallbackArgs[0] = (WORD)(SHORT)cy;
    awCallbackArgs[1] = (WORD)(SHORT)cx;
    awCallbackArgs[2] = (WORD)wData;
    awCallbackArgs[3] = LOWORD(pwds->lparamUser);
    awCallbackArgs[4] = HIWORD(pwds->lparamUser);
    awCallbackArgs[5] = GETHDC16(hdc);

    WOWCallback16Ex(
        pwds->vpfnCallback,
        WCB16_PASCAL,
        sizeof awCallbackArgs,
        awCallbackArgs,
        &ul                      // retcode filled into ul
        );

    return LOWORD(ul);
}


ULONG FASTCALL WU32DrawState(PVDMFRAME pFrame)
{
    register PDRAWSTATE16 parg16;
    ULONG ul;
    WOWDRAWSTATECALLBACK wds;
    DRAWSTATEPROC pDrawStateCallback = NULL;
    LPARAM lData;
    HBRUSH hbr;

    GETARGPTR(pFrame, sizeof(*parg16), parg16);

    switch (parg16->uFlags & DST_TYPEMASK) {

        case DST_COMPLEX:
            if (parg16->pfnCallBack) {
                wds.vpfnCallback = parg16->pfnCallBack;
                wds.lparamUser = parg16->lData;
                lData = (LPARAM) &wds;
                pDrawStateCallback = (DRAWSTATEPROC) WOWDrawStateCallback;
            }
            break;

        case DST_TEXT:
        case DST_PREFIXTEXT:
            lData = (LPARAM) VDMPTR(parg16->lData, parg16->wData);
            break;

        case DST_ICON:
            lData = (LPARAM) HICON32( (WORD) parg16->lData );
            break;

        case DST_BITMAP:
            lData = (LPARAM) HBITMAP32(parg16->lData);
            break;

        default:
            WOW32WARNMSGF(FALSE, ("WOW32: Unknown DST_ code to DrawState %x.\n",
                                  parg16->uFlags & DST_TYPEMASK));
    }

    hbr = (parg16->uFlags & DSS_MONO)
              ? HBRUSH32(parg16->hbrFore)
              : NULL;

    ul = GETBOOL16(DrawState(
                       HDC32(parg16->hdcDraw),
                       hbr,
                       pDrawStateCallback,
                       lData,
                       parg16->wData,
                       parg16->x,
                       parg16->y,
                       parg16->cx,
                       parg16->cy,
                       parg16->uFlags
                       ));

    FREEARGPTR(pFrame);

    return ul;
}


ULONG FASTCALL WU32GetAppVer(PVDMFRAME pFrame)
{
    return ((PTDB)SEGPTR(pFrame->wTDB,0))->TDB_ExpWinVer;
}


ULONG FASTCALL WU32CopyImage(PVDMFRAME pFrame)
{
    register PCOPYIMAGE16 parg16;
    ULONG ul;
    BOOL fIconCursor;   // as opposed to bitmap

    GETARGPTR(pFrame, sizeof(*parg16), parg16);

    //
    // NOTE first parameter to Win16 CopyImage is hinstOwner,
    // which isn't a parameter to Win32 CopyImage.  It may
    // be that we'll need to special-case LR_COPYFROMRESOURCE
    // to work correctly.
    //

    fIconCursor = (parg16->wType != IMAGE_BITMAP);

    ul = (ULONG) CopyImage(
                     (fIconCursor)
                         ? HICON32(parg16->hImage)
                         : HBITMAP32(parg16->hImage),
                     parg16->wType,
                     parg16->cxNew,
                     parg16->cyNew,
                     parg16->wFlags
                     );

    ul = (fIconCursor)
             ? GETHICON16(ul)
             : GETHBITMAP16(ul);

    return ul;
}


//
// WowMsgBoxIndirectCallback is called by User32 when a 16-bit app
// calls MessageBoxIndirect and specifies a help callback proc.
// User32 passes the 16:16 callback address to us along with a
// flat pointer to the HELPINFO structure to pass to the callback.
//

VOID FASTCALL WowMsgBoxIndirectCallback(DWORD vpfnCallback, LPHELPINFO lpHelpInfo)
{
    VPVOID vpHelpInfo16;
    LPHELPINFO lpHelpInfo16;

    //
    // As best as I can tell Win95 passes the WIN32 HELPINFO struct back to the
    // 16-bit callback proc (i.e. there is no HELPINFO16).
    //

    // be sure allocation size matches stackfree16() size below
    vpHelpInfo16 = stackalloc16( sizeof(*lpHelpInfo16) );

    GETVDMPTR(vpHelpInfo16, sizeof(*lpHelpInfo16), lpHelpInfo16);
    RtlCopyMemory(lpHelpInfo16, lpHelpInfo, sizeof(*lpHelpInfo16));
    FREEVDMPTR(lpHelpInfo16);

    WOWCallback16(
        vpfnCallback,
        vpHelpInfo16
        );

    if(vpHelpInfo16) {
        stackfree16(vpHelpInfo16, sizeof(*lpHelpInfo16));
    }
}


ULONG FASTCALL WU32MessageBoxIndirect(PVDMFRAME pFrame)
{
    register PMESSAGEBOXINDIRECT16 parg16;
    ULONG ul;
    PMSGBOXPARAMS16 pmbp16;
    MSGBOXPARAMS mbp;

    GETARGPTR(pFrame, sizeof(*parg16), parg16);
    GETVDMPTR(parg16->lpmbp, sizeof *pmbp16, pmbp16);

    mbp.cbSize = sizeof mbp;
    mbp.hwndOwner = HWND32(pmbp16->hwndOwner);
    mbp.hInstance = HINSTRES32(pmbp16->hInstance);
    GETPSZIDPTR(pmbp16->lpszText, mbp.lpszText);
    GETPSZIDPTR(pmbp16->lpszCaption, mbp.lpszCaption);
    mbp.dwStyle = pmbp16->dwStyle;
    GETPSZIDPTR(pmbp16->lpszIcon, mbp.lpszIcon);
    mbp.dwContextHelpId = pmbp16->dwContextHelpId;
    if (pmbp16->vpfnMsgBoxCallback) {
        MarkWOWProc(pmbp16->vpfnMsgBoxCallback, mbp.lpfnMsgBoxCallback)
    } else {
        mbp.lpfnMsgBoxCallback = 0;
    }
    mbp.dwLanguageId = pmbp16->dwLanguageId;

    ul = GETINT16( MessageBoxIndirect(&mbp) );

    FREEARGPTR(pFrame);

    return ul;
}


//
// was in wow.it: HGDI  CreateEnhMetaFile(HGDI, PTR, PTR, PTR);
// Using real thunk to ensure Win32 curdir matches Win16.
//
ULONG FASTCALL WG32CreateEnhMetaFile(PVDMFRAME pFrame)
{
    register PCREATEENHMETAFILE16 parg16;
    ULONG ul;
    LPCSTR lpszFile, lpszDescription;
    CONST RECT *prclFrame;

    GETARGPTR(pFrame, sizeof(*parg16), parg16);
    GETVDMPTR(parg16->lpszFile, 1, lpszFile);
    // note lpszDescription is really two SZs with extra terminator
    GETVDMPTR(parg16->lpszDescription, 3, lpszDescription);
    // note lprclFrame is a LPRECTL, a Win32 RECT
    GETVDMPTR(parg16->lprclFrame, sizeof(*prclFrame), prclFrame);

    //
    // Make sure the Win32 current directory matches this task's.
    //

    UpdateDosCurrentDirectory(DIR_DOS_TO_NT);

    ul = GETHDC16(CreateEnhMetaFile(
             HDC32(parg16->hdcRef),
             lpszFile,
             prclFrame,
             lpszDescription
             ));

    FREEVDMPTR(prclFrame);
    FREEVDMPTR(lpszDescription);
    FREEVDMPTR(lpszFile);

    return ul;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\win95.h ===
/*++
 *
 *  Windows NT v5.0 WOW
 *
 *  Copyright (c) 1997, Microsoft Corporation
 *
 *  WIN95.H
 *
 *  WOW32 Hand-coded (as opposed to interpreted) thunks for new-for-Win95
 *        exports.
 *
 *  History:
 *  16 Feb 97 Created davehart
--*/

typedef WORD (WINAPI *PFNTILECASCADEWINDOWS)(HWND, UINT, CONST RECT *, UINT, const HWND FAR *);
ULONG FASTCALL WU32TileWindows(PVDMFRAME pFrame);
ULONG FASTCALL WU32CascadeWindows(PVDMFRAME pFrame);
ULONG FASTCALL W32TileOrCascadeWindows(PVDMFRAME pFrame, PFNTILECASCADEWINDOWS pfnWin32);

typedef BOOL (WINAPI *PFNDRAWEDGEFRAMECONTROL)(HDC, LPRECT, UINT, UINT);
ULONG FASTCALL WU32DrawEdge(PVDMFRAME pFrame);
ULONG FASTCALL WU32DrawFrameControl(PVDMFRAME pFrame);
ULONG FASTCALL W32DrawEdgeOrFrameControl(PVDMFRAME pFrame, PFNDRAWEDGEFRAMECONTROL pfnWin32);


ULONG FASTCALL WU32DrawTextEx(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetIconInfo(PVDMFRAME pFrame);
ULONG FASTCALL WU32DrawAnimatedRects(PVDMFRAME pFrame);
ULONG FASTCALL WU32DrawCaption(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetMenuItemInfo(PVDMFRAME pFrame);
ULONG FASTCALL WU32InsertMenuItem(PVDMFRAME pFrame);
ULONG FASTCALL WU32SetMenuItemInfo(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetMenuItemRect(PVDMFRAME pFrame);
ULONG FASTCALL WU32TrackPopupMenuEx(PVDMFRAME pFrame);
ULONG FASTCALL WG32GetCharacterPlacement(PVDMFRAME pFrame);
ULONG FASTCALL WK32GetProductName(PVDMFRAME pFrame);
ULONG FASTCALL WU32DrawState(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetAppVer(PVDMFRAME pFrame);
ULONG FASTCALL WU32CopyImage(PVDMFRAME pFrame);
VOID FASTCALL WowMsgBoxIndirectCallback(DWORD vpfnCallback, LPHELPINFO lpHelpInfo);
ULONG FASTCALL WU32MessageBoxIndirect(PVDMFRAME pFrame);
ULONG FASTCALL WG32CreateEnhMetaFile(PVDMFRAME pFrame);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\witbl.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WITBL.H
 *  WOW32 16-bit Internal API tables
 *
 *  History:
 *  Created 22-Apr-1992 by FritzS
--*/



/* Internal dispatch table
 */
extern W32 aw32Internal[];


#ifdef DEBUG_OR_WOWPROFILE
extern INT iInternalMax;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\winspldl.h ===
extern BOOL    fWinspoolLoaded;


extern DWORD (WINAPI *lpfnDEVICECAPABILITIES)(LPSTR lpDriverName, LPSTR lpDeviceName,
    WORD nIndex, LPSTR lpOutput, LPDEVMODE lpDevMode);

extern BOOL (WINAPI *lpfnDEVICEMODE)(HWND hWnd, LPSTR lpDriverName, LPSTR lpDeviceName, LPSTR lpOutput);

extern DWORD (WINAPI *lpfnEXTDEVICEMODE)(HWND hWnd,LPSTR lpDriverName,
    LPDEVMODE lpDevModeOutput, LPSTR lpDeviceName, LPSTR lpPort,
    LPDEVMODE lpDevModeInput, LPSTR lpProfile, DWORD flMode);

extern BOOL (WINAPI *lpfnOpenPrinter)(LPSTR pPrinterName, LPHANDLE phPrinter,
                               VOID *pDefault);

extern DWORD (WINAPI *lpfnStartDocPrinter)(HANDLE hPrinter, DWORD Level,
                                    LPBYTE  pDocInfo);

extern BOOL (WINAPI *lpfnStartPagePrinter)(HANDLE hPrinter);
extern BOOL (WINAPI *lpfnEndPagePrinter)(HANDLE hPrinter);
extern BOOL (WINAPI *lpfnEndDocPrinter)(HANDLE hPrinter);
extern BOOL (WINAPI *lpfnClosePrinter)(HANDLE hPrinter);
extern BOOL (WINAPI *lpfnWritePrinter)(HANDLE hPrinter, LPVOID pBuf, DWORD cbBuf,
                                LPDWORD pcWritten);
extern BOOL (WINAPI *lpfnDeletePrinter)(HANDLE hPrinter);

BOOL LoadWinspoolAndGetProcAddresses();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\winsockp.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    Winsockp.h

Abstract:

    Private header file for WOW winsock support.

Author:

    David Treadwell (davidtr)    02-Oct-1992

Revision History:

--*/

#include "wow32.h"
#include <winsock.h>
#include <wowwsock.h>
#include "wcall16.h"
#include "wsocktbl.h"

typedef struct _WINSOCK_THREAD_DATA {
    VPVOID vIpAddress;
    VPHOSTENT16 vHostent;
    VPSERVENT16 vServent;
    VPPROTOENT16 vProtoent;
    VPPROC vBlockingHook;
    DWORD ThreadSerialNumber;
    DWORD ThreadStartupCount;
    WORD ThreadVersion;
} WINSOCK_THREAD_DATA, *PWINSOCK_THREAD_DATA;

extern DWORD WWS32TlsSlot;
extern RTL_CRITICAL_SECTION WWS32CriticalSection;
extern LIST_ENTRY WWS32AsyncContextBlockListHead;
extern WORD WWS32AsyncTaskHandleCounter;
extern LIST_ENTRY WWS32SocketHandleListHead;
extern WORD WWS32SocketHandleCounter;
extern BOOL WWS32SocketHandleCounterWrapped;
extern DWORD WWS32ThreadSerialNumberCounter;

#define WWS32IpAddress \
    ( ((PWINSOCK_THREAD_DATA)(TlsGetValue( WWS32TlsSlot )))->IpAddress )
#define WWS32vIpAddress \
    ( ((PWINSOCK_THREAD_DATA)(TlsGetValue( WWS32TlsSlot )))->vIpAddress )
#define WWS32vHostent \
    ( ((PWINSOCK_THREAD_DATA)(TlsGetValue( WWS32TlsSlot )))->vHostent )
#define WWS32vServent \
    ( ((PWINSOCK_THREAD_DATA)(TlsGetValue( WWS32TlsSlot )))->vServent )
#define WWS32vProtoent \
    ( ((PWINSOCK_THREAD_DATA)(TlsGetValue( WWS32TlsSlot )))->vProtoent )
#define WWS32vBlockingHook \
    ( ((PWINSOCK_THREAD_DATA)(TlsGetValue( WWS32TlsSlot )))->vBlockingHook )
#define WWS32ThreadSerialNumber \
    ( ((PWINSOCK_THREAD_DATA)(TlsGetValue( WWS32TlsSlot )))->ThreadSerialNumber )
#define WWS32ThreadStartupCount \
    ( ((PWINSOCK_THREAD_DATA)(TlsGetValue( WWS32TlsSlot )))->ThreadStartupCount )
#define WWS32ThreadVersion \
    ( ((PWINSOCK_THREAD_DATA)(TlsGetValue( WWS32TlsSlot )))->ThreadVersion )

#define WWS32IsThreadVersion10 ( WWS32ThreadVersion == MAKEWORD(1, 0) )
#define WWS32IsThreadVersion11 ( WWS32ThreadVersion == MAKEWORD(1, 1) )

#define WWS32IsThreadInitialized \
    ( TlsGetValue( WWS32TlsSlot ) == NULL ? FALSE : TRUE )

typedef struct _WINSOCK_ASYNC_CONTEXT_BLOCK {
    LIST_ENTRY ContextBlockListEntry;
    HANDLE AsyncTaskHandle32;
    HAND16 AsyncTaskHandle16;
    VPVOID vBuffer16;
    DWORD Buffer16Length;
    PVOID Buffer32;
} WINSOCK_ASYNC_CONTEXT_BLOCK, *PWINSOCK_ASYNC_CONTEXT_BLOCK;

typedef struct _WINSOCK_SOCKET_INFO {
    LIST_ENTRY GlobalSocketListEntry;
    SOCKET SocketHandle32;
    DWORD ThreadSerialNumber;
    HAND16 SocketHandle16;
} WINSOCK_SOCKET_INFO, *PWINSOCK_SOCKET_INFO;

PFD_SET
AllocateFdSet32 (
    IN PFD_SET16 FdSet16
    );

INT
ConvertFdSet16To32 (
    IN PFD_SET16 FdSet16,
    IN PFD_SET FdSet32
    );

VOID
ConvertFdSet32To16 (
    IN PFD_SET FdSet32,
    IN PFD_SET16 FdSet16
    );

int PASCAL
WSApSetPostRoutine (
    IN PVOID PostRoutine
    );

typedef
BOOL
(*PWINSOCK_POST_ROUTINE) (
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
WWS32DispatchPostMessage (
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
WWS32PostAsyncSelect (
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
WWS32PostAsyncGetHost (
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
WWS32PostAsyncGetProto (
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
WWS32PostAsyncGetServ (
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

PWINSOCK_ASYNC_CONTEXT_BLOCK
WWS32FindAndRemoveAsyncContext (
    IN HANDLE AsyncTaskHandle32
    );

HAND16
WWS32GetAsyncTaskHandle16 (
    VOID
    );

VOID
WWS32TaskCleanup(
    VOID
    );

//
// Message types used by WWS32DispatchPostMessage to dispatch a post
// message call to the appropriate routine.
//

#define WWS32_MESSAGE_ASYNC_SELECT   0
#define WWS32_MESSAGE_ASYNC_GETHOST  1
#define WWS32_MESSAGE_ASYNC_GETPROTO 2
#define WWS32_MESSAGE_ASYNC_GETSERV  3

//
// An arbitrary value that indicates the default blocking hook is in use.
//

#define WWS32_DEFAULT_BLOCKING_HOOK 0xFFFFFFFF

//
// Determine if a pointer is DWORD aligned.
//

#define IS_DWORD_ALIGNED(p) (((DWORD)(p) & (sizeof(DWORD)-1)) == 0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wkbman.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WKBMAN.H
 *  WOW32 16-bit Keyboard API support (manually-coded thunks)
 *
 *  History:
 *  Created 27-Jan-1991 by Jeff Parsons (jeffpar)
--*/



/* Keyboard thunks
 */


ULONG FASTCALL WKB32ToAscii(PVDMFRAME pFrame);
ULONG FASTCALL WKB32OemKeyScan(PVDMFRAME pFrame);
ULONG FASTCALL WKB32VkKeyScan(PVDMFRAME pFrame);
ULONG FASTCALL WKB32GetKeyboardType(PVDMFRAME pFrame);
ULONG FASTCALL WKB32MapVirtualKey(PVDMFRAME pFrame);
ULONG FASTCALL WKB32GetKBCodePage(PVDMFRAME pFrame);
ULONG FASTCALL WKB32GetKeyNameText(PVDMFRAME pFrame);
ULONG FASTCALL WKB32AnsiToOemBuff(PVDMFRAME pFrame);
ULONG FASTCALL WKB32OemToAnsiBuff(PVDMFRAME pFrame);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wkbdtbl2.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WKBTBL2.h
 *  WOW32 16-bit Keyboard API tables
 *
 *  History:
 *  Created 27-Jan-1991 by Jeff Parsons (jeffpar)
--*/

    {W32FUN(UNIMPLEMENTEDAPI,      "DUMMYENTRY",      MOD_KEYBOARD,   0)},
    {W32FUN(LOCALAPI,              "INQUIRE",         MOD_KEYBOARD,   0)},
    {W32FUN(LOCALAPI,              "ENABLE",          MOD_KEYBOARD,   0)},
    {W32FUN(LOCALAPI,              "DISABLE",         MOD_KEYBOARD,   0)},
    {W32FUN(WKB32ToAscii,          "TOASCII",         MOD_KEYBOARD,   sizeof(TOASCII16))},
    {W32FUN(IT(AnsiToOem),         "AnsiToOem",       MOD_KEYBOARD,   sizeof(ANSITOOEM16))},
    {W32FUN(IT(OemToAnsi),         "OemToAnsi",       MOD_KEYBOARD,   sizeof(OEMTOANSI16))},
    {W32FUN(LOCALAPI,              "SETSPEED",        MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},

  /*** 0010 ***/
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},

  /*** 0020 ***/
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},

  /*** 0030 ***/
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},

  /*** 0040 ***/
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},

  /*** 0050 ***/
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},

  /*** 0060 ***/
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},

  /*** 0070 ***/
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},

  /*** 0080 ***/
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},

  /*** 0090 ***/
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},

  /*** 0100 ***/
    {W32FUN(LOCALAPI,              "SCREENSWITCHENABLE",MOD_KEYBOARD, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},

  /*** 0110 ***/
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},

  /*** 0120 ***/
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(UNIMPLEMENTEDAPI,      "",                MOD_KEYBOARD,   0)},
    {W32FUN(LOCALAPI,              "GETTABLESEG",     MOD_KEYBOARD,   0)},
    {W32FUN(LOCALAPI,              "NEWTABLE",        MOD_KEYBOARD,   0)},
    {W32FUN(WKB32OemKeyScan,       "OEMKEYSCAN",      MOD_KEYBOARD,   sizeof(OEMKEYSCAN16))},
    {W32FUN(WKB32VkKeyScan,        "VKKEYSCAN",       MOD_KEYBOARD,   sizeof(VKKEYSCAN16))},

  /*** 0130 ***/
    {W32FUN(WKB32GetKeyboardType,  "GETKEYBOARDTYPE", MOD_KEYBOARD,   sizeof(GETKEYBOARDTYPE16))},
    {W32FUN(WKB32MapVirtualKey,    "MAPVIRTUALKEY",   MOD_KEYBOARD,   sizeof(MAPVIRTUALKEY16))},
    {W32FUN(WKB32GetKBCodePage,    "GETKBCODEPAGE",   MOD_KEYBOARD,   0)},
    {W32FUN(WKB32GetKeyNameText,   "GETKEYNAMETEXT",  MOD_KEYBOARD,   sizeof(GETKEYNAMETEXT16))},
    {W32FUN(WKB32AnsiToOemBuff,    "ANSITOOEMBUFF",   MOD_KEYBOARD,   sizeof(ANSITOOEMBUFF16))},
    {W32FUN(WKB32OemToAnsiBuff,    "OEMTOANSIBUFF",   MOD_KEYBOARD,   sizeof(OEMTOANSIBUFF16))},
    {W32FUN(LOCALAPI,              "ENABLEKBSYSREQ",  MOD_KEYBOARD,   0)},
    {W32FUN(LOCALAPI,              "GETBIOSKEYPROC",  MOD_KEYBOARD,   0)},
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wkbtbl.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WKBTBL.H
 *  WOW32 16-bit Keyboard API tables
 *
 *  History:
 *  Created 27-Jan-1991 by Jeff Parsons (jeffpar)
--*/



/* Keyboard dispatch table
 */
extern W32 aw32Keyboard[];


#ifdef DEBUG_OR_WOWPROFILE
extern INT iKeyboardMax;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wkbman.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WKBMAN.C
 *  WOW32 16-bit Keyboard API support (manually-coded thunks)
 *
 *  History:
 *  Created  27-Jan-1991 by Jeff Parsons (jeffpar)
 *  Modified 13-Jan-1992 by Nandurir . Added all the code.
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wkbman.c);

ULONG FASTCALL WKB32ToAscii(PVDMFRAME pFrame)
{
    ULONG ul;
    register PTOASCII16 parg16;
    LPSTR lpstrT;
    LPVOID lpvoidT;

    GETARGPTR(pFrame, sizeof(TOASCII16), parg16);
    GETPSZPTR(parg16->f3, lpstrT);
    GETMISCPTR(parg16->f4, lpvoidT);

    ul = ToAscii((WORD)(parg16->f1),
                 (WORD)(parg16->f2),
                 lpstrT,
                 lpvoidT,
                 (WORD)(parg16->f5));


    FREEPSZPTR(lpstrT);
    FLUSHVDMPTR(parg16->f4, 4, lpvoidT);
    FREEMISCPTR(lpvoidT);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WKB32OemKeyScan(PVDMFRAME pFrame)
{
    ULONG ul;
    register POEMKEYSCAN16 parg16;

    GETARGPTR(pFrame, sizeof(OEMKEYSCAN16), parg16);

    ul = (ULONG)OemKeyScan((WORD)(parg16->f1));

    FREEARGPTR(parg16);
    RETURN(ul);
}



ULONG FASTCALL WKB32VkKeyScan(PVDMFRAME pFrame)
{
    ULONG ul;
    register PVKKEYSCAN16 parg16;

    GETARGPTR(pFrame, sizeof(VKKEYSCAN16), parg16);

    ul = (ULONG)VkKeyScan((CHAR)(parg16->f1));

    FREEARGPTR(parg16);
    RETURN(ul);
}



ULONG FASTCALL WKB32GetKeyboardType(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETKEYBOARDTYPE16 parg16;

    GETARGPTR(pFrame, sizeof(GETKEYBOARDTYPE16), parg16);

    ul = GetKeyboardType(INT32(parg16->f1));

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WKB32MapVirtualKey(PVDMFRAME pFrame)
{
    ULONG ul;
    register PMAPVIRTUALKEY16 parg16;

    GETARGPTR(pFrame, sizeof(MAPVIRTUALKEY16), parg16);

    ul = MapVirtualKey((UINT)(parg16->f1), (UINT)(parg16->f2));

    // MapVirtualKey sets the high bit (Win16 & Win32) to indicate diacritic
    if (ul & 0x80000000) {
        ul |= 0x8000;
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WKB32GetKBCodePage(PVDMFRAME pFrame)
{
    ULONG ul;

    ul = (ULONG)GetKBCodePage();

    RETURN(ul);
}


ULONG FASTCALL WKB32GetKeyNameText(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETKEYNAMETEXT16 parg16;
    LPSTR lpstrT;

    GETARGPTR(pFrame, sizeof(GETKEYNAMETEXT16), parg16);
    GETPSZPTR(parg16->f2, lpstrT);

    ul = (ULONG)GetKeyNameText(DWORD32(parg16->f1), lpstrT,
                                                      (INT)(WORD)(parg16->f3));

    FLUSHVDMPTR(parg16->f2, (WORD) (parg16->f3), lpstrT);
    FREEPSZPTR(lpstrT);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WKB32AnsiToOemBuff(PVDMFRAME pFrame)
{
    ULONG ul;
    register PANSITOOEMBUFF16 parg16;
    LPSTR  lpstrAnsi, lpstrOem;

    GETARGPTR(pFrame, sizeof(ANSITOOEMBUFF16), parg16);
    GETPSZPTR(parg16->f1, lpstrAnsi);
    GETPSZPTR(parg16->f2, lpstrOem);

    ul = AnsiToOemBuff(lpstrAnsi, lpstrOem, (DWORD)(WORD)(parg16->f3));

    FLUSHVDMPTR(parg16->f2, ((parg16->f3) ? (parg16->f3) : 0xFFFF), lpstrOem);
    FREEPSZPTR(lpstrAnsi);
    FREEPSZPTR(lpstrOem);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WKB32OemToAnsiBuff(PVDMFRAME pFrame)
{
    ULONG ul;
    register POEMTOANSIBUFF16 parg16;
    LPSTR  lpstrAnsi, lpstrOem;

    GETARGPTR(pFrame, sizeof(OEMTOANSIBUFF16), parg16);
    GETPSZPTR(parg16->f1, lpstrOem);
    GETPSZPTR(parg16->f2, lpstrAnsi);

    ul = (ULONG)OemToAnsiBuff(lpstrOem, lpstrAnsi, (DWORD)(WORD)(parg16->f3));

    FLUSHVDMPTR(parg16->f2, ((parg16->f3) ? (parg16->f3) : 0xFFFF), lpstrAnsi);
    FREEPSZPTR(lpstrOem);
    FREEPSZPTR(lpstrAnsi);
    FREEARGPTR(parg16);
    RETURN(ul);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wkernel.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WKERNEL.C
 *  WOW32 16-bit Kernel API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wkernel.c);


ULONG FASTCALL WK32WritePrivateProfileString(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ pszSection;
    PSZ pszKey;
    PSZ pszValue;
    PSZ pszFilename;
    register PWRITEPRIVATEPROFILESTRING16 parg16;
    BOOL fIsWinIni;
    CHAR szLowercase[MAX_PATH];

    GETARGPTR(pFrame, sizeof(WRITEPRIVATEPROFILESTRING16), parg16);
    GETPSZPTR(parg16->f1, pszSection);
    GETPSZPTR(parg16->f2, pszKey);
    GETPSZPTR(parg16->f3, pszValue);
    GETPSZPTR(parg16->f4, pszFilename);

    UpdateDosCurrentDirectory(DIR_DOS_TO_NT);

    strcpy(szLowercase, pszFilename);
    WOW32_strlwr(szLowercase);

    fIsWinIni = IS_WIN_INI(szLowercase);

    // Trying to install or change default printer to fax printer?
    if (fIsWinIni &&
        pszSection &&
        pszKey &&
        pszValue &&
        !WOW32_stricmp(pszSection, szDevices) &&
        IsFaxPrinterWriteProfileString(pszSection, pszKey, pszValue)) {

        ul = TRUE;
        goto Done;
    }

    ul = GETBOOL16( WritePrivateProfileString(
             pszSection,
             pszKey,
             pszValue,
             pszFilename
             ));

    if( ul != 0 &&
        fIsWinIni &&
        IS_EMBEDDING_SECTION( pszSection ) &&
        pszKey != NULL &&
        pszValue != NULL ) {

        UpdateClassesRootSubKey( pszKey, pszValue);
    }

Done:
    FREEPSZPTR(pszSection);
    FREEPSZPTR(pszKey);
    FREEPSZPTR(pszValue);
    FREEPSZPTR(pszFilename);
    FREEARGPTR(parg16);

    return ul;
}


ULONG FASTCALL WK32WriteProfileString(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ   pszSection;
    PSZ   pszKey;
    PSZ   pszValue;
    register PWRITEPROFILESTRING16 parg16;

    GETARGPTR(pFrame, sizeof(WRITEPROFILESTRING16), parg16);
    GETPSZPTR(parg16->f1, pszSection);
    GETPSZPTR(parg16->f2, pszKey);
    GETPSZPTR(parg16->f3, pszValue);

    // For WinFax Lite install hack. Bug #126489  See wow32fax.c
    if(!gbWinFaxHack) { 

        // Trying to install or change default printer to fax printer?
        if (pszSection &&
            pszKey &&
            pszValue &&
            !WOW32_stricmp(pszSection, szDevices) &&
            IsFaxPrinterWriteProfileString(pszSection, pszKey, pszValue)) {
    
            ul = TRUE;
            goto Done;
        }
 
    } else {
        IsFaxPrinterWriteProfileString(pszSection, pszKey, pszValue);
    }

    ul = GETBOOL16( WriteProfileString(
             pszSection,
             pszKey,
             pszValue
             ));

    if( ( ul != 0 ) &&
        IS_EMBEDDING_SECTION( pszSection ) &&
        ( pszKey != NULL ) &&
        ( pszValue != NULL ) ) {
        UpdateClassesRootSubKey( pszKey, pszValue);
    }

Done:
    FREEPSZPTR(pszSection);
    FREEPSZPTR(pszKey);
    FREEPSZPTR(pszValue);
    FREEARGPTR(parg16);
    return ul;
}


ULONG FASTCALL WK32GetProfileString(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ pszSection;
    PSZ pszKey;
    PSZ pszDefault;
    PSZ pszReturnBuffer;
    UINT cchMax;
#ifdef FE_SB
    PSZ pszTmp = NULL;
#endif // FE_SB
    register PGETPROFILESTRING16 parg16;

    GETARGPTR(pFrame, sizeof(GETPROFILESTRING16), parg16);
    GETPSZPTR(parg16->f1, pszSection);
    GETPSZPTR(parg16->f2, pszKey);
    GETPSZPTR(parg16->f3, pszDefault);
    ALLOCVDMPTR(parg16->f4, parg16->f5, pszReturnBuffer);
    cchMax = INT32(parg16->f5);
#ifdef FE_SB
    //
    // For those applications that expect sLongDate contains
    // windows 3.1J picture format string.
    //
    if (GetSystemDefaultLangID() == 0x411 &&
            !lstrcmpi(pszSection, "intl") && !lstrcmpi(pszKey, "sLongDate")) {

        pszTmp = pszKey;
        pszKey = "sLongDate16";
    }
#endif // FE_SB

    if (IS_EMBEDDING_SECTION( pszSection ) &&
        !WasSectionRecentlyUpdated() ) {
        if( pszKey == NULL ) {
            UpdateEmbeddingAllKeys();
        } else {
            UpdateEmbeddingKey( pszKey );
        }
        SetLastTimeUpdated();

    } else if (pszSection &&
               pszKey &&
               !WOW32_stricmp(pszSection, szDevices) &&
               IsFaxPrinterSupportedDevice(pszKey)) {

        ul = GETINT16(GetFaxPrinterProfileString(pszSection, pszKey, pszDefault, pszReturnBuffer, cchMax));
        goto FlushAndReturn;
    }

    ul = GETINT16(GetProfileString(
             pszSection,
             pszKey,
             pszDefault,
             pszReturnBuffer,
             cchMax));


    //
    // Win3.1/Win95 compatibility:  Zap the first trailing blank in pszDefault
    // with null, but only if the default string was returned.  To detect
    // the default string being returned we need to ignore trailing blanks.
    //
    // This code is duplicated in thunks for GetProfileString and
    // GetPrivateProfileString, update both if you make changes.
    //

    if ( pszDefault && pszKey )  {

        int  n, nLenDef;

        //
        // Is the default the same as the returned string up to any NULLs?
        //
        nLenDef = 0;
        n=0;
        while (
            (pszDefault[nLenDef] == pszReturnBuffer[n]) &&
            pszReturnBuffer[n]
            ) {
            
            n++;
            nLenDef++;
        }
        
        //
        // Did we get out of the loop because we're at the end of the returned string?
        //
        if ( '\0' != pszReturnBuffer[n] ) {
            //
            // No.  The strings are materially different - fall out.
            //
        }
        else {
            //
            // Ok, the strings are identical to the end of the returned string.
            // Is the default string spaces out to the end?
            //
            while ( ' ' == pszDefault[nLenDef] ) {
                nLenDef++;
            }
            
            //
            // The last thing was not a space.  If it was a NULL, then the app
            // passed in a string with trailing NULLs as default.  (Otherwise
            // the two strings are materially different and we do nothing.)
            //
            if ( '\0' == pszDefault[nLenDef] ) {
                
                char szBuf[4];  // Some random, small number of chars to get.
                                // If the string is long, we'll get only 3 chars
                                // (and NULL), but so what? - we only need to know if
                                // we got a default last time...
                
                //
                // The returned string is the same as the default string
                // without trailing blanks, but this might be coincidence,
                // so see if a call with empty pszDefault returns anything.
                // If it does, we don't zap because the default isn't
                // being used.
                //

                if (0 == GetProfileString(pszSection, pszKey, "", szBuf, sizeof(szBuf))) {

                    //
                    // Zap first trailing blank in pszDefault with null.
                    //

                    pszDefault[ul] = 0;
                    FLUSHVDMPTR(parg16->f3 + ul, 1, pszDefault + ul);
                }
            }
        }
    }


FlushAndReturn:
#ifdef FE_SB
    if ( pszTmp )
        pszKey = pszTmp;

    if (CURRENTPTD()->dwWOWCompatFlagsFE & WOWCF_FE_USEUPPER) { // for WinWrite
        if (pszSection && !lstrcmpi(pszSection, "windows") &&
             pszKey && !lstrcmpi(pszKey, "device")) {
            CharUpper(pszReturnBuffer);
        }
        if (pszSection && !lstrcmpi(pszSection, "devices") && pszKey) {
            CharUpper(pszReturnBuffer);
        }
    }
#endif // FE_SB
    FLUSHVDMPTR(parg16->f4, (ul + (pszSection && pszKey) ? 1 : 2), pszReturnBuffer);
    FREEPSZPTR(pszSection);
    FREEPSZPTR(pszKey);
    FREEPSZPTR(pszDefault);
    FREEVDMPTR(pszReturnBuffer);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WK32GetPrivateProfileString(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ pszSection;
    PSZ pszKey;
    PSZ pszDefault;
    PSZ pszReturnBuffer;
    PSZ pszFilename;
    UINT cchMax;
#ifdef FE_SB
    PSZ pszTmp = NULL;
#endif // FE_SB
    register PGETPRIVATEPROFILESTRING16 parg16;
    CHAR szLowercase[MAX_PATH];

    GETARGPTR(pFrame, sizeof(GETPRIVATEPROFILESTRING16), parg16);
    GETPSZPTR(parg16->f1, pszSection);
    GETPSZPTR(parg16->f2, pszKey);
    GETPSZPTR(parg16->f3, pszDefault);
    ALLOCVDMPTR(parg16->f4, parg16->f5, pszReturnBuffer);
    GETPSZPTR(parg16->f6, pszFilename);

    // PC3270 (Personal communications): while installing this app it calls
    // GetPrivateProfileString (sectionname, NULL, defaultbuffer, returnbuffer,
    // cch = 0, filename). On win31 this call returns relevant data in return
    // buffer and corresponding size as return value. On NT, since the
    // buffersize(cch) is '0' no data is copied into the return buffer and
    // return value is zero which makes this app abort installation.
    //
    // So restricted compatibility:
    //   if above is the case set
    //      cch = 64k - offset of returnbuffer;
    //
    // A safer 'cch' would be
    //      cch = GlobalSize(selector of returnbuffer) -
    //                                (offset of returnbuffer);
    //                                                           - nanduri

    if (!(cchMax = INT32(parg16->f5))) {
        if (pszKey == (PSZ)NULL) {
            if (pszReturnBuffer != (PSZ)NULL) {
                 cchMax = 0xffff - (LOW16(parg16->f4));
            }
        }
    }

    UpdateDosCurrentDirectory(DIR_DOS_TO_NT);

    strcpy(szLowercase, pszFilename);
    WOW32_strlwr(szLowercase);

    if (IS_WIN_INI( szLowercase )) {
#ifdef FE_SB
        //
        // For those applications that expect sLongDate contains
        // windows 3.1J picture format string.
        //
        if (GetSystemDefaultLangID() == 0x411 &&
            lstrcmpi( pszSection, "intl") == 0 &&
            lstrcmpi( pszKey, "sLongDate") == 0) {
            pszTmp = pszKey;
            pszKey = "sLongDate16";
        }
#endif // FE_SB
        if (IS_EMBEDDING_SECTION( pszSection ) &&
            !WasSectionRecentlyUpdated() ) {
            if( pszKey == NULL ) {
                UpdateEmbeddingAllKeys();
            } else {
                UpdateEmbeddingKey( pszKey );
            }
            SetLastTimeUpdated();

        } else if (pszSection &&
                   pszKey &&
                   !WOW32_stricmp(pszSection, szDevices) &&
                   IsFaxPrinterSupportedDevice(pszKey)) {

            ul = GETINT16(GetFaxPrinterProfileString(pszSection, pszKey, pszDefault, pszReturnBuffer, cchMax));
            goto FlushAndReturn;
        }
    }

    ul = GETUINT16(GetPrivateProfileString(
        pszSection,
        pszKey,
        pszDefault,
        pszReturnBuffer,
        cchMax,
        pszFilename));

    
    // start comaptibility hacks
    
    
    //
    // Win3.1/Win95 compatibility:  Zap the first trailing blank in pszDefault
    // with null, but only if the default string was returned.  To detect
    // the default string being returned we need to ignore trailing blanks.
    //
    // This code is duplicated in thunks for GetProfileString and
    // GetPrivateProfileString, update both if you make changes.
    //

    if ( pszDefault && pszKey )  {

        int  n, nLenDef;

        //
        // Is the default the same as the returned string up to any NULLs?
        //
        nLenDef = 0;
        n=0;
        while (
            (pszDefault[nLenDef] == pszReturnBuffer[n]) &&
            pszReturnBuffer[n]
            ) {
            
            n++;
            nLenDef++;
        }
        
        //
        // Did we get out of the loop because we're at the end of the returned string?
        //
        if ( '\0' != pszReturnBuffer[n] ) {
            //
            // No.  The strings are materially different - fall out.
            //
        }
        else {
            //
            // Ok, the strings are identical to the end of the returned string.
            // Is the default string spaces out to the end?
            //
            while ( ' ' == pszDefault[nLenDef] ) {
                nLenDef++;
            }
            
            //
            // The last thing was not a space.  If it was a NULL, then the app
            // passed in a string with trailing NULLs as default.  (Otherwise
            // the two strings are materially different and we do nothing.)
            //
            if ( '\0' == pszDefault[nLenDef] ) {
                
                char szBuf[4];  // Some random, small number of chars to get.
                                // If the string is long, we'll get only 3 chars
                                // (and NULL), but so what? - we only need to know if
                                // we got a default last time...
                
                //
                // The returned string is the same as the default string
                // without trailing blanks, but this might be coincidence,
                // so see if a call with empty pszDefault returns anything.
                // If it does, we don't zap because the default isn't
                // being used.
                //
                if (0 == GetProfileString(pszSection, pszKey, "", szBuf, sizeof(szBuf))) {

                    //
                    // Zap first trailing blank in pszDefault with null.
                    //

                    pszDefault[ul] = 0;
                    FLUSHVDMPTR(parg16->f3 + ul, 1, pszDefault + ul);
                }
            }
        }
    }

    
    if( CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_SAYITSNOTTHERE ) {
    
        // CrossTalk 2.2 gets hung in a loop while trying to match a printer in
        // their xtalk.ini file with a printer name in the PrintDlg listbox.  
        // There is a bug in their code for handling this that gets exposed by
        // the fact that NT PrintDlg listboxes do not include the port name as
        // Win3.1 & Win'95 do.  We avoid the buggy code altogether with this 
        // hack by telling them that the preferred printer isn't stored in 
        // xtalk.ini. See bug #43168  a-craigj        
        // Maximizer 5.0 has similar problem. it tries to parse 
        // print driver location however, allocates too small buffer. See
        // Whistler bug 288491
         
        if(!WOW32_stricmp(pszSection, "Printer")) {
           if((WOW32_strstr(szLowercase, "xtalk.ini")   && !WOW32_stricmp(pszKey, "Device")) ||  // CrossTalk 2.2
              (WOW32_strstr(szLowercase, "bclwdde.ini") && !WOW32_stricmp(pszKey, "Driver")) ){   // Maximizer 5             
              strcpy(pszReturnBuffer, pszDefault);
              ul = strlen(pszReturnBuffer);
           }
        }

        // WHISTLER RAID BUG # 379253  05/06/2001 - alexsm
        // National Geographic Explorer needed the oppisite of the above. The app 
        // was checking for a QTWVideo string, which contained a path to a quicktime
        // driver. Without the key, the app wouldn't play video. It's not really a
        // SAYITSNOTTHERE, more of a SAYITISTHERE, but this saves on compat bits.
        if(!WOW32_stricmp(pszSection, "mci")) {
            if((WOW32_strstr(szLowercase, "system.ini") && !WOW32_stricmp(pszKey, "QTWVideo"))) {
                CHAR szMCIQTW[] = "\\system\\mciqtw.drv";
                CHAR szQTWVideo[MAX_PATH + sizeof(szMCIQTW) / sizeof(CHAR)];          // make sure there's room for the new string (max_path + pszMCIQTW)

                GetSystemWindowsDirectory(szQTWVideo, MAX_PATH);
                strcat(szQTWVideo, szMCIQTW);
                strncpy(pszReturnBuffer, szQTWVideo, cchMax - 1);
                *(pszReturnBuffer + (cchMax - 1))  = '\0';
                ul = strlen(szQTWVideo);
            }
        }

    }

FlushAndReturn:
#ifdef FE_SB
    if ( pszTmp )
        pszKey = pszTmp;
#endif // FE_SB
    if (ul) {
        FLUSHVDMPTR(parg16->f4, (ul + (pszSection && pszKey) ? 1 : 2), pszReturnBuffer);
        LOGDEBUG(8,("GetPrivateProfileString returns '%s'\n", pszReturnBuffer));
    }

#ifdef DEBUG

    //
    // Check for bad return on retrieving entire section by walking
    // the section making sure it's full of null-terminated strings
    // with an extra null at the end.  Also ensure that this all fits
    // within the buffer.
    //

    if (!pszKey) {
        PSZ psz;

        //
        // We don't want to complain if the poorly-formed buffer was the one
        // passed in as pszDefault by the caller.
        //

        // Although the api docs clearly state that pszDefault should never
        // be null but win3.1 is nice enough to still deal with this. Delphi is
        // passing pszDefault as NULL and this following code causes an
        // assertion in WOW. So added the pszDefault check first.
        //
        // sudeepb 11-Sep-1995


        if (!pszDefault || WOW32_strcmp(pszReturnBuffer, pszDefault)) {

            psz = pszReturnBuffer;

            while (psz < (pszReturnBuffer + ul + 2) && *psz) {
                psz += strlen(psz) + 1;
            }

            WOW32ASSERTMSGF(
                psz < (pszReturnBuffer + ul + 2),
                ("GetPrivateProfileString of entire section returns poorly formed buffer.\n"
                 "pszReturnBuffer = %p, return value = %d\n",
                 pszReturnBuffer,
                 ul
                 ));
        }
    }

#endif // DEBUG

    FREEPSZPTR(pszSection);
    FREEPSZPTR(pszKey);
    FREEPSZPTR(pszDefault);
    FREEVDMPTR(pszReturnBuffer);
    FREEPSZPTR(pszFilename);
    FREEARGPTR(parg16);
    RETURN(ul);
}




ULONG FASTCALL WK32GetProfileInt(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz1;
    PSZ psz2;
    register PGETPROFILEINT16 parg16;

    GETARGPTR(pFrame, sizeof(GETPROFILEINT16), parg16);
    GETPSZPTR(parg16->f1, psz1);
    GETPSZPTR(parg16->f2, psz2);

    ul = GETWORD16(GetProfileInt(
    psz1,
    psz2,
    INT32(parg16->f3)
    ));

    //
    // In HKEY_CURRENT_USER\Control Panel\Desktop\WindowMetrics, there
    // are a bunch of values that define the screen appearance. You can
    // watch these values get updated when you go into the display control
    // panel applet and change the "appearance scheme", or any of the
    // individual elements. The win95 shell is different than win31 in that it
    // sticks "twips" values in there instead of pixels. These are calculated
    // with the following formula:
    //
    //  twips = - pixels * 72 * 20 / cyPixelsPerInch
    //
    //  pixels = -twips * cyPixelsPerInch / (72*20)
    //
    // So if the value is negative, it is in twips, otherwise it in pixels.
    // The idea is that these values are device independent. NT is
    // different than win95 in that we provide an Ini file mapping to this
    // section of the registry where win95 does not. Now, when the Lotus
    // Freelance Graphics 2.1 tutorial runs, it mucks around with the look
    // of the screen, and it changes the border width of window frames by
    // using SystemParametersInfo(). When it tries to restore it, it uses
    // GetProfileInt("Windows", "BorderWidth", <default>), which on win31
    // returns pixels, on win95 returns the default (no ini mapping), and
    // on NT returns TWIPS. Since this negative number is interpreted as
    // a huge UINT, then the window frames become huge. What this code
    // below will do is translate the number back to pixels.   [neilsa]
    //

    if ((CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_PIXELMETRICS) &&
        !WOW32_stricmp(psz1, "Windows") &&
        !WOW32_stricmp(psz2, "Bor