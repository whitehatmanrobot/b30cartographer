his condition is checked
        before hEnum is tested for validity.

    WN_BAD_HANDLE - hEnum is not a valid handle.

--*/
{
    DWORD               status = WN_SUCCESS;
    DWORD               i;

    //
    // Probe the handle
    //
    __try {
        *(volatile DWORD *)hEnum;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetCloseEnum:Unexpected Exception 0x%lx\n",status);
        }

        status = WN_BAD_HANDLE;
    }

    if (status != WN_SUCCESS) {
        SetLastError(WN_BAD_HANDLE);
        return(status);
    }

    //
    // Use hEnum as a pointer and check the DWORD value at its location.
    // If it contains a CONNECT_TABLE_KEY, we must close all handles to
    // the providers before freeing the memory for the table.
    // If it is a STATE_TABLE_KEY, we just free the memory.
    //
    switch(*(LPDWORD)hEnum){

    case CONNECT_TABLE_KEY:
    {
        LPCONNECT_HEADER    connectEnumHeader;
        LPCONNECT_ENUM      connectEnumTable;

        connectEnumHeader = (LPCONNECT_HEADER)hEnum;
        connectEnumTable  = (LPCONNECT_ENUM)(connectEnumHeader + 1);
        //
        // Close all the open provider handles
        //
        MPR_LOG(TRACE,"Closing Connection Enum Handles from Providers\n",0);

        for(i = 0; i < connectEnumHeader->dwNumProviders; i++) {

            if((connectEnumTable[i].State != NOT_OPENED) &&
               (connectEnumTable[i].pfCloseEnum != NULL))
            {
                status = connectEnumTable[i].pfCloseEnum(
                            connectEnumTable[i].ProviderEnumHandle);

                if(status != WN_SUCCESS) {
                    //
                    // Because we are closing many handles at once, the failure
                    // is noted for debug purposes only.
                    //
                    MPR_LOG(ERROR,"WNetCloseEnum:(connect-provider #%d) failed\n",i);
                    MPR_LOG(ERROR,"WNetCloseEnum: error code = %d\n",status);
                    //
                    // Error information is returned if there is only one
                    // provider.
                    //
                    if (connectEnumHeader->dwNumProviders != 1) {
                        status = WN_SUCCESS;
                    }
                }

                //
                // If this fires, the logic in MprOpenEnumConnect is wrong
                //
                ASSERT(connectEnumTable[i].hProviderDll != NULL);

                FreeLibrary(connectEnumTable[i].hProviderDll);
            }
            else
            {
                //
                // If this fires, the logic in MprOpenEnumConnect is wrong
                // and we're not releasing a refcounted provider DLL
                //
                ASSERT(connectEnumTable[i].hProviderDll == NULL);
            }
        }

        //
        // Free the Table Memory
        //
        if (LocalFree(hEnum)) {
            MPR_LOG(ERROR,"WNetCloseEnum:LocalFree(connect) failed %d\n",
            GetLastError());
        }

        if (status != WN_SUCCESS)
        {
            SetLastError(status);
        }
        return(status);
    }

    case STATE_TABLE_KEY:
    {
        LPNETWORK_HEADER    StateTableHeader;
        LPNETWORK_ENUM      StateTable;

        //
        // Free the State Table Memory.
        //
        MPR_LOG(TRACE,"Free State Table for Network Enum\n",0);

        StateTableHeader = (LPNETWORK_HEADER)hEnum;
        StateTable       = (LPNETWORK_ENUM)(StateTableHeader + 1);

        for (i = 0; i < StateTableHeader->dwNumProviders; i++)
        {
            if (StateTable[i].hProviderDll != NULL)
            {
                FreeLibrary(StateTable[i].hProviderDll);
                LocalFree(StateTable[i].lpnr);
            }
            else
            {
                //
                // If this fires, MprOpenEnumNetwork is causing a mem leak
                //
                ASSERT(StateTable[i].lpnr == NULL);
            }
        }

        if (LocalFree(hEnum)) {
            MPR_LOG(ERROR,"WNetCloseEnum:LocalFree(network) failed %d\n",
            GetLastError());
        }
        return(WN_SUCCESS);
    }

    case PROVIDER_ENUM_KEY:
    {
        LPENUM_HANDLE       enumHandle;

        //
        // Close the providers enumeration handle, and free the
        // ENUM_HANDLE structure.
        //
        MPR_LOG(TRACE,"Closing Provider Enum Handle\n",0);

        enumHandle = (LPENUM_HANDLE)hEnum;

        ASSERT(enumHandle->pfCloseEnum != NULL);
        status = (enumHandle->pfCloseEnum)(enumHandle->EnumHandle);

        ASSERT(enumHandle->hProviderDll != NULL);
        FreeLibrary(enumHandle->hProviderDll);

        if (LocalFree(enumHandle) != 0) {
            MPR_LOG(ERROR,"WNetCloseEnum:LocalFree(provider) failed %d\n",
            GetLastError());
        }

        //
        // Check the status returned from the Provider's CloseEnum
        //
        if(status != WN_SUCCESS) {

            MPR_LOG(ERROR,"WNetCloseEnum:(provider) failed %d\n",status);

            SetLastError(status);
        }

        return(status);
    }

    case REMEMBER_KEY:
    {
        LPREMEMBER_HANDLE   rememberHandle;

        rememberHandle = (LPREMEMBER_HANDLE)hEnum;

        //
        // Close the RegistryKey Handle associated with this handle.
        //
        if (rememberHandle->ConnectKey != NULL) {
            RegCloseKey(rememberHandle->ConnectKey);
        }

        //
        // Free up the memory for the handle.
        //

        if (LocalFree(rememberHandle) != 0) {
            MPR_LOG(ERROR,"WNetCloseEnum:LocalFree(remember) failed %d\n",
            GetLastError());
        }

        return(WN_SUCCESS);
    }

    default:
        SetLastError(WN_BAD_HANDLE);
        return(WN_BAD_HANDLE);
    }
}


DWORD
MprOpenEnumConnect(
    IN  DWORD          dwScope,
    IN  DWORD          dwType,
    IN  DWORD          dwUsage,
    IN  LPNETRESOURCE  lpNetResource,
    OUT LPHANDLE       lphEnum
    )

/*++

Routine Description:

    This function handles the opening of connection enumerations and context
    enumerations.  It does this by sending an OpenEnum to all Providers, and
    storing the returned handles in a table.  The handle that is returned is
    a pointer to this table.

    The first DWORD in the table is a key that will help to identify a
    correct table.  The second DWORD is a Boolean value that tells whether
    a NETRESOURCE structure representing the root of the network needs to be
    returned in the enumeration.

Arguments:

    dwScope - RESOURCE_CONNECTED, RESOURCE_CONTEXT, or RESOURCE_SHAREABLE

    dwType -

    dwUsage -

    lpNetResource -

    lphEnum - This is a pointer to a location where the handle for
        the connection enumeration is to be stored.

Return Value:

    WN_SUCCESS - The operation was successful.

    WN_OUT_OF_MEMORY - The memory allocation for the handle was unsuccessful.

--*/
{
    DWORD                    i;
    DWORD                    status;
    LPCONNECT_HEADER         connectEnumHeader;
    LPCONNECT_ENUM           connectEnumTable;
    LPPROVIDER               provider;
    BOOL                     fcnSupported = FALSE; // Is fcn supported by a provider?
    BOOL                     atLeastOne=FALSE;
    BOOL                     bDynamicEntries = TRUE; // Whether to show dynamic entries
                                                     // in the net neighborhood
    HKEY                     hkPolicies = NULL;

    ASSERT(dwScope == RESOURCE_CONNECTED
            ||
           dwScope == RESOURCE_CONTEXT
            ||
           dwScope == RESOURCE_SHAREABLE);

    ASSERT_INITIALIZED(NETWORK);

    //
    // If there are no providers, return NO_NETWORK
    //
    if (GlobalNumActiveProviders == 0) {
        return(WN_NO_NETWORK);
    }

    //
    // Allocate the handle table with enough room for a header.
    //
    connectEnumHeader = (LPCONNECT_HEADER) LocalAlloc(
                    LPTR,
                    sizeof(CONNECT_HEADER) +
                        sizeof(CONNECT_ENUM) * GlobalNumProviders
                    );

    if (connectEnumHeader == NULL) {
        MPR_LOG(ERROR,"MprOpenEnumConnect:LocalAlloc Failed %d\n",GetLastError());
        return(WN_OUT_OF_MEMORY);
    }

    //
    // Initialize the key used in the connect table.
    //
    connectEnumHeader->Key                    = CONNECT_TABLE_KEY;
    connectEnumHeader->ReturnRoot             = FALSE;
    connectEnumHeader->dwNumProviders         = GlobalNumProviders;
    connectEnumHeader->dwNumActiveProviders   = GlobalNumActiveProviders;

    connectEnumTable = (LPCONNECT_ENUM)(connectEnumHeader + 1);

    //
    // Check the policy on whether dynamic entries are to be shown in the
    // network neighborhood.  By default, they are shown.
    //
    if (dwScope == RESOURCE_CONTEXT)
    {
        if (MprOpenKey(
                HKEY_CURRENT_USER,
                REGSTR_PATH_NETWORK_POLICIES,
                &hkPolicies,
                KEY_READ))
        {
            bDynamicEntries = ! (MprGetKeyNumberValue(
                                        hkPolicies,
                                        REGSTR_VAL_NOWORKGROUPCONTENTS,
                                        FALSE));
        }
        else
        {
            hkPolicies = NULL;
        }
    }

    //
    // Initialize all state flags for providers to the NOT_OPENED state, so
    // we won't try to enumerate or close their handles unless we actually
    // got handles from them.
    // Initialize handles for the network providers by calling them with
    // OpenEnum.
    //

    for(i=0; i<GlobalNumProviders; i++) {

        connectEnumTable[i].State = NOT_OPENED;

        provider = GlobalProviderInfo + i;

        if ((provider->InitClass & NETWORK_TYPE) &&
            (provider->OpenEnum != NULL)) {

            if (dwScope == RESOURCE_CONTEXT)
            {
                DWORD dwCaps = provider->GetCaps(WNNC_ENUMERATION);

                if (dwCaps & WNNC_ENUM_GLOBAL)
                {
                    // A browsing network is present, so show root,
                    // even if network is down, and even if ENUM_CONTEXT
                    // isn't supported.
                    connectEnumHeader->ReturnRoot = TRUE;
                }

                if ((dwCaps & WNNC_ENUM_CONTEXT) == 0)
                {
                    // This provider can't show hood entries, so skip it.
                    continue;
                }
            }
            else if (dwScope == RESOURCE_SHAREABLE)
            {
                DWORD dwCaps = provider->GetCaps(WNNC_ENUMERATION);

                if ((dwCaps & WNNC_ENUM_SHAREABLE) == 0)
                {
                    // This provider can't show shareable resources, so skip it.
                    continue;
                }
            }

            fcnSupported = TRUE;

            if (bDynamicEntries)
            {
                //
                // Refcount the provider
                //
                connectEnumTable[i].hProviderDll = LoadLibraryEx(provider->DllName,
                                                                 NULL,
                                                                 LOAD_WITH_ALTERED_SEARCH_PATH);

                if (connectEnumTable[i].hProviderDll == NULL)
                {
                    status = GetLastError();

                    //
                    // This can happen under extreme low memory conditions.  The
                    // loader can sometimes return ERROR_MOD_NOT_FOUND in this case.
                    //
                    MPR_LOG2(ERROR,
                             "MprOpenEnumConnect: LoadLibraryEx on %ws FAILED %d\n",
                             provider->DllName,
                             status);

                    ASSERT(status == ERROR_NOT_ENOUGH_MEMORY || status == ERROR_MOD_NOT_FOUND);
                    continue;
                }

                connectEnumTable[i].pfEnumResource = provider->EnumResource;
                connectEnumTable[i].pfCloseEnum    = provider->CloseEnum;

                status = provider->OpenEnum(
                            dwScope,                // Scope
                            dwType,                 // Type
                            dwUsage,                // Usage
                            (dwScope == RESOURCE_SHAREABLE ? lpNetResource : NULL), // NetResource
                            &(connectEnumTable[i].ProviderEnumHandle));             // hEnum

                if (status != WN_SUCCESS) {

                    MPR_LOG(ERROR,"MprOpenEnumConnect:OpenEnum Failed %d\n",status);
                    MPR_LOG(ERROR,
                            "That was for the %ws Provider\n",
                            provider->Resource.lpProvider);

                    FreeLibrary(connectEnumTable[i].hProviderDll);

                    connectEnumTable[i].hProviderDll   = NULL;
                    connectEnumTable[i].pfEnumResource = NULL;
                    connectEnumTable[i].pfCloseEnum    = NULL;
                }
                else {
                    //
                    // At least one provider has returned a handle.
                    //
                    atLeastOne = TRUE;

                    //
                    // Set the state to MORE_ENTRIES, so we later enumerate from the
                    // handle and/or close it.
                    //
                    connectEnumTable[i].State = MORE_ENTRIES;

                    MPR_LOG(TRACE,"MprOpenEnumConnect: OpenEnum Handle = 0x%lx\n",
                        connectEnumTable[i].ProviderEnumHandle);
                }
            }
            else
            {
                // Succeed the WNetOpenEnum but leave this provider as NOT_OPENED
                atLeastOne = TRUE;
            }
        }
    }

    if (connectEnumHeader->ReturnRoot)
    {
        // Able to show the root object.  Check the policy on whether
        // to show it.
        connectEnumHeader->ReturnRoot = ! (MprGetKeyNumberValue(
                                                hkPolicies,
                                                REGSTR_VAL_NOENTIRENETWORK,
                                                FALSE));
        fcnSupported = TRUE;
        atLeastOne = TRUE;
    }

    if (hkPolicies)
    {
        RegCloseKey(hkPolicies);
    }

    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        // Note that in this case, atLeastOne will always be FALSE.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // return the handle (pointer to connectEnumTable);
    //
    *lphEnum = connectEnumHeader;

    if (atLeastOne == FALSE) {
        //
        // If none of the providers returned a handle, then return the
        // status from the last provider.
        //

        *lphEnum = NULL;
        LocalFree( connectEnumHeader);
        return(status);
    }

    return(WN_SUCCESS);

}


DWORD
MprOpenEnumNetwork(
    OUT LPHANDLE    lphEnum
    )

/*++

Routine Description:

    This function handles the opening of net resource enumerations.
    It does this by allocating a table of Provider State Flags and returning
    a handle to that table.  The state flags (or for each provider) will
    be set to MORE_ENTRIES.  Later, when enumerations take place, the state
    for each provider is changed to DONE after the buffer is successfully
    loaded with the the NETRESOURCE info for that provider.

Arguments:

    lphEnum - This is a pointer to a location where the handle for
        the network resource enumeration is to be stored.

Return Value:

    WN_SUCCESS - The operation was successful.

    WN_OUT_OF_MEMORY - The memory allocation for the handle was unsuccessful.


--*/
{
    LPNETWORK_ENUM   stateTable;
    LPNETWORK_HEADER stateTableHeader;
    DWORD            i;

    ASSERT_INITIALIZED(NETWORK);

    //
    // If there are no providers, return NO_NETWORK
    //
    if (GlobalNumActiveProviders == 0) {
        return(WN_NO_NETWORK);
    }

    //
    // Allocate the state table.
    //
    stateTableHeader = (LPNETWORK_HEADER) LocalAlloc(
                    LPTR,
                    sizeof(NETWORK_HEADER) +
                        sizeof(NETWORK_ENUM) * GlobalNumProviders
                    );

    if (stateTableHeader == NULL) {
        MPR_LOG(ERROR,"MprOpenEnumNetwork:LocalAlloc Failed %d\n",GetLastError());
        return(WN_OUT_OF_MEMORY);
    }

    stateTableHeader->Key                  = STATE_TABLE_KEY;
    stateTableHeader->dwNumProviders       = GlobalNumProviders;
    stateTableHeader->dwNumActiveProviders = GlobalNumActiveProviders;

    stateTable = (LPNETWORK_ENUM)(stateTableHeader + 1);

    //
    // Initialize state flags for all network providers to the MORE_ENTRIES state.
    //
    for(i = 0; i < GlobalNumProviders; i++) {

        if (GlobalProviderInfo[i].InitClass & NETWORK_TYPE)
        {
            if (GlobalProviderInfo[i].Handle != NULL)
            {
                stateTable[i].hProviderDll = LoadLibraryEx(GlobalProviderInfo[i].DllName,
                                                           NULL,
                                                           LOAD_WITH_ALTERED_SEARCH_PATH);

                if (stateTable[i].hProviderDll == NULL)
                {
                    DWORD status = GetLastError();

                    //
                    // This can happen under extreme low memory conditions.  The
                    // loader can sometimes return ERROR_MOD_NOT_FOUND in this case.
                    //
                    MPR_LOG1(ERROR,
                             "MprOpenEnumNetwork:  LoadLibraryEx on %ws FAILED\n",
                             GlobalProviderInfo[i].DllName);

                    ASSERT(status == ERROR_NOT_ENOUGH_MEMORY || status == ERROR_MOD_NOT_FOUND);
                }
                else
                {
                    LPBYTE  lpTempBuffer;
                    DWORD   dwSize = 0;
                    DWORD   dwStatus;

                    //
                    // Figure out how much space we'll need for the NETRESOURCE.
                    // It needs to be copied since the provider (and its resource)
                    // may go away between now and the WNetEnumResource call.
                    //
                    dwStatus = MprCopyResource(NULL,
                                               &GlobalProviderInfo[i].Resource,
                                               &dwSize);

                    ASSERT(dwStatus == WN_MORE_DATA);

                    stateTable[i].lpnr = (LPNETRESOURCE)LocalAlloc(LPTR, dwSize);

                    if (stateTable[i].lpnr == NULL)
                    {
                        MPR_LOG0(ERROR, "MprOpenEnumNetwork:  LocalAlloc FAILED\n");

                        //
                        // Rather than fail silently in this case, bail out
                        //
                        for (UINT j = 0; j <= i; j++)
                        {
                            if (stateTable[j].hProviderDll)
                            {
                                FreeLibrary(stateTable[j].hProviderDll);
                                stateTable[j].hProviderDll = NULL;
                                stateTable[j].State        = MORE_ENTRIES;
                            }

                            LocalFree(stateTable[j].lpnr);
                        }

                        LocalFree(stateTableHeader);
                        return(WN_OUT_OF_MEMORY);
                    }
                    else
                    {
                        lpTempBuffer = (LPBYTE)stateTable[i].lpnr;

                        dwStatus = MprCopyResource(&lpTempBuffer,
                                                   &GlobalProviderInfo[i].Resource,
                                                   &dwSize);

                        ASSERT(dwStatus == WN_SUCCESS);
                    }
                }
            }

            stateTable[i].State = MORE_ENTRIES;
        }
        else {
            stateTable[i].State = DONE;
        }
    }

    //
    // return the handle (pointer to stateTable);
    //
    *lphEnum = stateTableHeader;

    return(WN_SUCCESS);
}


DWORD
MprEnumConnect(
    IN OUT  LPCONNECT_HEADER    ConnectEnumHeader,
    IN OUT  LPDWORD             NumEntries,
    IN OUT  LPVOID              lpBuffer,
    IN OUT  LPDWORD             lpBufferSize
    )

/*++

Routine Description:

    This function looks in the ConnectEnumTable for the next provider that
    has MORE_ENTRIES.  It begins requesting Enum Data from that provider -
    each time copying data that is returned from the provider enum into the
    users enum buffer (lpBuffer).  This continues until we finish, or
    we reach the requested number of elements, or the user buffer is full.
    Each time we enumerate a provider to completion, that provider is
    marked as DONE.

    Note, for a context enumeration, the first NETRESOURCE returned in the
    enumeration is a constant NETRESOURCE representing the root of the
    network.  This is done to make it easy for the shell to display a
    "Rest of Network" object in a "Network Neighborhood" view.

Arguments:

    ConnectEnumHeader - This is a pointer to a CONNECT_HEADER structure
        followed by an array of CONNECT_ENUM structures.  The ReturnRoot
        member of the header tells whether the root object needs to be
        returned at the start of the enumeration.  On exit, if the root
        object has been returned, the ReturnRoot member is set to FALSE.

    NumEntries - On entry this points to the maximum number of entries
        that the user desires to receive.  On exit it points to the
        number of entries that were placed in the users buffer.

    lpBuffer - This is a pointer to the users buffer in which the
        enumeration data is to be placed.

    lpBufferSize - This is the size (in bytes) of the users buffer.  It will
        be set to the size of the required buffer size of WN_MORE_DATA is
        returned.

Return Value:

    WN_SUCCESS - This indicates that the call is returning some entries.
        However, the enumeration is not complete due to one of the following:
        1)  There was not enough buffer space.
        2)  The requested number of entries was reached.
        3)  There is no more data to enumerate - the next call will
            return WN_NO_MORE_ENTRIES.

    WN_MORE_DATA - This indicates that the buffer was not large enough
        to receive one enumeration entry.

    WN_NO_MORE_ENTRIES - This indicates that there are no more entries
        to enumerate.  No data is returned with this return code.

    WN_NO_NETWORK - If there are no providers loaded.

Note:


--*/
{

    DWORD           i;              // provider index
    DWORD           status=WN_NO_MORE_ENTRIES;
    DWORD           entriesRead=0;  // number of entries read into the buffer.
    LPBYTE          tempBufPtr;     // pointer to top of remaining free buffer space.
    LPNETRESOURCEW  providerBuffer; // buffer for data returned from provider
    DWORD           bytesLeft;      // Numer of bytes left in the buffer
    DWORD           entryCount;     // number of entries read from provider
    LPCONNECT_ENUM  ConnectEnumTable = (LPCONNECT_ENUM) (ConnectEnumHeader + 1);
                                    // Start of array

    //
    // If there are no providers, return NO_NETWORK
    //
    if (ConnectEnumHeader->dwNumActiveProviders == 0) {
        return(WN_NO_NETWORK);
    }

    bytesLeft  = ROUND_DOWN(*lpBufferSize);
    tempBufPtr = (LPBYTE) lpBuffer;

    //
    // Check to see if there are any flags in state table that indicate
    // MORE_ENTRIES.  If not, we want to return WN_NO_MORE_ENTRIES.
    //

    for(i = 0; i < ConnectEnumHeader->dwNumProviders; i++) {
        if(ConnectEnumTable[i].State == MORE_ENTRIES) {
            break;
        }
    }

    if ( (i == ConnectEnumHeader->dwNumProviders) && (! ConnectEnumHeader->ReturnRoot) ) {
        *NumEntries = 0;
        return(WN_NO_MORE_ENTRIES);
    }

    //
    // If no entries are requested, we have nothing to do
    //
    if (*NumEntries == 0) {
        return WN_SUCCESS;
    }

    //
    // Allocate a buffer for the provider to return data in.
    // The buffer size must equal the number of bytes left in the
    // user buffer.
    // (We can't have the provider write data directly to the caller's
    // buffer because NPEnumResource is not required to place strings
    // at the end of the buffer -- only at the end of the array of
    // NETRESOURCEs.)
    //
    providerBuffer = (LPNETRESOURCEW) LocalAlloc(LPTR, bytesLeft);
    if (providerBuffer == NULL) {
        MPR_LOG(ERROR,"MprEnumConnect:LocalAlloc Failed %d\n",
            GetLastError());

        *NumEntries = 0;
        return(WN_OUT_OF_MEMORY);
    }

    //
    // Copy the root-of-network resource if required.
    //
    if (ConnectEnumHeader->ReturnRoot)
    {
        NETRESOURCEW RootResource = {
                            RESOURCE_GLOBALNET,         // dwScope
                            RESOURCETYPE_ANY,           // dwType
                            RESOURCEDISPLAYTYPE_ROOT,   // dwDisplayType
                            RESOURCEUSAGE_CONTAINER,    // dwUsage
                            NULL,                       // lpLocalName
                            NULL,                       // lpRemoteName
                            g_wszEntireNetwork,         // lpComment
                            NULL                        // lpProvider
                            };


        status = MprCopyResource(&tempBufPtr, &RootResource, &bytesLeft);

        if (status == WN_SUCCESS)
        {
            entriesRead = 1;
            ConnectEnumHeader->ReturnRoot = FALSE;
        }
        else
        {
            if (status == WN_MORE_DATA)
            {
                //
                // Not even enough room for one NETRESOURCE
                //
                *lpBufferSize = bytesLeft;
            }

            goto CleanExit;
        }
    }

    //
    // Loop until we have copied from all Providers or until the
    // the maximum number of entries has been reached.
    //
    for ( ; i < ConnectEnumHeader->dwNumProviders && entriesRead < *NumEntries; i++)
    {
        if (ConnectEnumTable[i].State != MORE_ENTRIES)
        {
            //
            // Skip providers that don't have more entries
            //
            continue;
        }

        if (ConnectEnumTable[i].hProviderDll == NULL) {
            //
            // If the provider has not been initialized because it is
            // not "ACTIVE", then skip it.
            //
            ConnectEnumTable[i].State = DONE;
            status = WN_SUCCESS;
            continue;
        }

        //
        // Adjust the entry count for any entries that have been read
        // so far.
        //
        entryCount = *NumEntries - entriesRead;

        //
        // Call the provider to get the enumerated data
        //
        status = ConnectEnumTable[i].pfEnumResource(
                    ConnectEnumTable[i].ProviderEnumHandle,
                    &entryCount,
                    providerBuffer,
                    &bytesLeft );   // (note, the provider updates
                                    // bytesLeft only if it returns
                                    // WN_MORE_DATA)

        switch (status)
        {
        case WN_SUCCESS:

            MPR_LOG(TRACE,"EnumResourceHandle = 0x%lx\n",
                ConnectEnumTable[i].ProviderEnumHandle);

            status = MprCopyProviderEnum(
                        providerBuffer,
                        &entryCount,
                        &tempBufPtr,
                        &bytesLeft);

            entriesRead += entryCount;

            if (status != WN_SUCCESS) {
                //
                // An internal error occured - for some reason the
                // buffer space left in the user buffer was smaller
                // than the buffer space that the provider filled in.
                // The best we can do in this case is return what data
                // we have.  WARNING: the data that didn't make it
                // will become lost since the provider thinks it
                // enumerated successfully, but we couldn't do anything
                // with it.
                //
                MPR_LOG(ERROR,
                    "MprEnumConnect:MprCopyProviderEnum Internal Error %d\n",
                    status);

                if(entriesRead > 0) {
                    status = WN_SUCCESS;
                }
                goto CleanExit;
            }
            //
            // We successfully placed all the received data from
            // that provider into the user buffer.  In this case,
            // if we haven't reached the requested number of entries,
            // we want to loop around and ask the same provider
            // to enumerate more.  This time the provider should
            // indicate why it quit last time - either there are
            // no more entries, or we ran out of buffer space.
            //
            break;

        case WN_NO_MORE_ENTRIES:
            //
            // This Provider has completed its enumeration, mark it
            // as done and increment to the next provider.  We don't
            // want to return NO_MORE_ENTRIES status.  That should
            // only be returned by the check at beginning or end
            // of this function.
            //
            ConnectEnumTable[i].State = DONE;
            status = WN_SUCCESS;
            break;

        case WN_MORE_DATA:
            //
            // This provider has more data, but there is not enough
            // room left in the user buffer to place any more data
            // from this provider.  We don't want to go on to the
            // next provider until we're finished with this one.  So
            // if we have any entries at all to return, we send back
            // a SUCCESS status.  Otherwise, the WN_MORE_DATA status
            // is appropriate.
            //
            if(entriesRead > 0) {
                status = WN_SUCCESS;
            }
            else
            {
                //
                // If 0 entries were read, then the provider should
                // have set bytesLeft with the required buffer size
                //
                *lpBufferSize = ROUND_UP(bytesLeft);
            }
            goto CleanExit;
            break;

        default:
            //
            // We received an unexpected error from the Provider Enum
            // call.
            //
            MPR_LOG(ERROR,"MprEnumConnect:ProviderEnum Error %d\n",status);
            if(entriesRead > 0) {
                //
                // If we have received data so far, ignore this error
                // and move on to the next provider.  This provider will
                // be left in the MORE_ENTRIES state, so that on some other
                // pass - when all other providers are done, this error
                // will be returned.
                //
                status = WN_SUCCESS;
            }
            else{
                //
                // No entries have been read so far.  We can return
                // immediately with the error.
                //
                goto CleanExit;
            }

        } // end switch (status)

    } // end for (each provider)

    //
    // If we looped through all providers and they are all DONE.
    // If there were no connections, then return proper error code.
    //
    if ((entriesRead == 0) && (status == WN_SUCCESS)) {
        status = WN_NO_MORE_ENTRIES;
    }

CleanExit:
    //
    // Update the number of entries to be returned to user.
    //
    *NumEntries = entriesRead;
    LocalFree(providerBuffer);
    return(status);
}

DWORD
MprEnumNetwork(
    IN OUT  LPNETWORK_HEADER     StateTableHeader,
    IN OUT  LPDWORD              NumEntries,
    IN OUT  LPVOID               lpBuffer,
    IN OUT  LPDWORD              lpBufferSize
    )

/*++

Routine Description:

    This function Looks in the state table for the next provider that has
    MORE_ENTRIES.  It begins by copying the NETRESOURCE info for that one.
    This continues until we finish, or we reach the requested number of
    elements, or the buffer is full.  Each time we copy a complete structure,
    we mark that provider as DONE.

Arguments:

    StateTable - This is a pointer to the state table that is managed by
        the handle used in this request.  The state table is a table of
        flags used to indicate the enumeration state for a given
        provider.  These flags are in the same order as the provider
        information in the GlobalProviderInfo Array.  The state can be
        either DONE or MORE_ENTRIES.

    NumEntries - On entry this points to the maximum number of entries
        that the user desires to receive.  On exit it points to the
        number of entries that were placed in the users buffer.

    lpBuffer - This is a pointer to the users buffer in which the
        enumeration data is to be placed.

    lpBufferSize - This is the size (in bytes) of the users buffer.

Return Value:

    WN_SUCCESS - This indicates that the call is returning some entries.
        However, the enumeration is not complete due to one of the following:
        1)  There was not enough buffer space.
        2)  The requested number of entries was reached.
        3)  There is no more data to enumerate - the next call will
            return WN_NO_MORE_ENTRIES.

    WN_MORE_DATA - This indicates that the buffer was not large enough
        to receive one enumeration entry.

    WN_NO_MORE_ENTRIES - This indicates that there are no more entries
        to enumerate.  No data is returned with this return code.

Note:

    CAUTION:  "DONE" entries may appear anywhere in the statetable.
        You cannot always rely on the fact that all of the entries
        after a MORE_ENTRIES entry are also in the MORE_ENTRIES state.
        This is because a provider that would not pass back a handle
        at open time will be marked as DONE so that it gets skipped
        at Enum Time.

--*/
{
    DWORD       i;
    DWORD       status;
    DWORD       entriesRead=0;  // number of entries read into the buffer.
    LPBYTE      tempBufPtr;     // pointer to top of remaining free buffer space.
    DWORD       bytesLeft;      // num bytes left in free buffer space

    LPNETWORK_ENUM  StateTable = (LPNETWORK_ENUM)(StateTableHeader + 1);


    //
    // If there are no providers, return NO_NETWORK
    //
    if (StateTableHeader->dwNumActiveProviders == 0) {
        return(WN_NO_NETWORK);
    }

    bytesLeft  = ROUND_DOWN(*lpBufferSize);
    tempBufPtr = (LPBYTE) lpBuffer;

    //
    // Check to see if there are any flags in state table that indicate
    // MORE_ENTRIES.  If not, we want to return WN_NO_MORE_ENTRIES.
    //

    for(i = 0; i < StateTableHeader->dwNumProviders; i++) {
        if(StateTable[i].State == MORE_ENTRIES) {
            break;
        }
    }

    if ( i >= StateTableHeader->dwNumProviders ) {
        *NumEntries = 0;
        return(WN_NO_MORE_ENTRIES);
    }

    //
    // Loop until we have copied from all Providers or until the
    // the maximum number of entries has been reached.
    //
    for(; (i < StateTableHeader->dwNumProviders) && (entriesRead < *NumEntries); i++)
    {
        if (StateTable[i].State == MORE_ENTRIES) {

            if (StateTable[i].hProviderDll == NULL)
            {
                //
                // If the provider is not ACTIVE, skip it.
                //
                StateTable[i].State = DONE;
            }
            else
            {
                status = MprCopyResource(
                            &tempBufPtr,
                            StateTable[i].lpnr,
                            &bytesLeft);

                if (status == WN_SUCCESS)
                {
                    StateTable[i].State = DONE;
                    entriesRead++;
                }
                else
                {
                    //
                    // The buffer must be full - so exit.
                    // If no entries are being returned, we will indicate
                    // that the buffer was not large enough for even one entry.
                    //
                    *NumEntries = entriesRead;

                    if (entriesRead > 0) {
                        return(WN_SUCCESS);
                    }
                    else {
                        *lpBufferSize = ROUND_UP(bytesLeft);
                        return(WN_MORE_DATA);
                    }
                }
            }
        } // EndIf (state == MORE_ENTRIES)
    } // EndFor (each provider)

    //
    // Update the number of entries to be returned to user
    //
    *NumEntries = entriesRead;

    return(WN_SUCCESS);
}

DWORD
MprProviderEnum(
    IN      LPENUM_HANDLE   EnumHandlePtr,
    IN OUT  LPDWORD         lpcCount,
    IN      LPVOID          lpBuffer,
    IN OUT  LPDWORD         lpBufferSize
    )

/*++

Routine Description:

    This function calls the provider (identified by the EnumHandlePtr)
    with a WNetEnumResource request.  Aside from the EnumHandlePtr, all the
    rest of the parameters are simply passed thru to the provider.

Arguments:

    EnumHandlePtr - This is a pointer to an ENUM_HANDLE structure which
        contains a pointer to the provider structure and the handle for
        that provider's enumeration.

    lpcCount - A pointer to a value that on entry contains the requested
        number of elements to enumerate.  On exit this contains the
        actual number of elements enumerated.

    lpBuffer - A pointer to the users buffer that the enumeration data
        is to be placed into.

    lpBufferSize - The number of bytes of free space in the user's buffer.

Return Value:

    This function can return any return code that WNetEnumResource()
    can return.

--*/
{
    DWORD   status;

    ASSERT(EnumHandlePtr->pfEnumResource != NULL);

    //
    // Call the provider listed in the ENUM_HANDLE structure and ask it
    // to enumerate.
    //
    status = EnumHandlePtr->pfEnumResource(
                EnumHandlePtr->EnumHandle,
                lpcCount,
                lpBuffer,
                lpBufferSize);

    if (status == WN_SUCCESS) {
        MPR_LOG(TRACE,"EnumResourceHandle = 0x%lx\n",
            EnumHandlePtr->EnumHandle);
    }
    return(status);
}

DWORD
MprCopyResource(
    IN OUT  LPBYTE          *BufPtr,
    IN const NETRESOURCEW   *Resource,
    IN OUT  LPDWORD         BytesLeft
    )

/*++

Routine Description:

    This function copies a single NETRESOURCE structure into a buffer.
    The structure gets copied to the top of the buffer, and the strings
    that the structure references are copied to the bottom of the
    buffer.  So any remaining free buffer space is left in the middle.

    Upon successful return from this function, BufPtr will point to
    the top of this remaining free space, and BytesLeft will be updated
    to indicate how many bytes of free space are remaining.

    If there is not enough room in the buffer to copy the Resource and its
    strings, an error is returned, and BufPtr is not changed.

Arguments:

    BufPtr - This is a pointer to a location that upon entry, contains a
        pointer to the buffer that the copied data is to be placed into.
        Upon exit, this pointer location points to the next free location
        in the buffer.

    Resource - This points to the Resource Structure that is to be copied
        into the buffer.

    BytesLeft - This points to a location to where a count of the remaining
        free bytes in the buffer is stored.  This is updated on exit to
        indicate the adjusted number of free bytes left in the buffer.
        If the buffer is not large enough, and WN_MORE_DATA is returned, then
        the size of the buffer required to fit all the data is returned in
        this field.

Return Value:

    WN_SUCCESS - The operation was successful

    WN_MORE_DATA - The buffer was not large enough to contain the
        Resource structure an its accompanying strings.

Note:


History:
    02-Apr-1992    JohnL
    Changed error return code to WN_MORE_DATA, added code to set the
    required buffer size if WN_MORE_DATA is returned.


--*/

{
    LPTSTR          startOfFreeBuf;
    LPTSTR          endOfFreeBuf;
    LPNETRESOURCEW  newResource;

    //
    // The buffer must be at least large enough to hold a resource structure.
    //
    if (*BytesLeft < sizeof(NETRESOURCEW)) {
        *BytesLeft = MprMultiStrBuffSize( Resource->lpRemoteName,
                      Resource->lpLocalName,
                      Resource->lpComment,
                      Resource->lpProvider,
                      NULL ) + sizeof(NETRESOURCEW) ;
        return(WN_MORE_DATA);
    }

    //
    // Copy the Resource structure into the beginning of the buffer.
    //
    newResource = (LPNETRESOURCEW) *BufPtr;
    memcpy(newResource, Resource, sizeof(NETRESOURCEW));

    startOfFreeBuf = (LPTSTR)((PCHAR)newResource + sizeof(NETRESOURCEW));
    endOfFreeBuf = (LPTSTR)((LPBYTE)newResource + *BytesLeft);

    //
    // If a REMOTE_NAME string is to be copied, copy that and update the
    // pointer in the structure.
    //
    if (Resource->lpRemoteName != NULL) {
        //
        // If we must copy the remote name,
        //
        if (!NetpCopyStringToBuffer(
                    Resource->lpRemoteName,         // pointer to string
                    STRLEN(Resource->lpRemoteName), // num chars in string
                    startOfFreeBuf,                 // start of open space
                    &endOfFreeBuf,                  // end of open space
                    &newResource->lpRemoteName)) {  // where string pointer goes

            *BytesLeft = MprMultiStrBuffSize( Resource->lpRemoteName,
                          Resource->lpLocalName,
                          Resource->lpComment,
                          Resource->lpProvider,
                          NULL ) ;
            goto ErrorMoreData ;
        }
    }
    else{
        newResource->lpRemoteName = NULL;
    }

    //
    // If a LOCAL_NAME string is to be copied, copy that and update the
    // pointer in the structure.
    //
    if( ((Resource->dwScope == RESOURCE_CONNECTED)  ||
         (Resource->dwScope == RESOURCE_REMEMBERED))
          &&
        (Resource->lpLocalName != NULL) ) {

        //
        // If we must copy the local name,
        //
        if (!NetpCopyStringToBuffer(
                    Resource->lpLocalName,         // pointer to string
                    STRLEN(Resource->lpLocalName), // num chars in string
                    startOfFreeBuf,                // start of open space
                    &endOfFreeBuf,                 // end of open space
                    &newResource->lpLocalName))    // where string pointer goes
        {
            goto ErrorMoreData ;
        }
    }
    else{
        newResource->lpLocalName = NULL;
    }

    //
    // If a COMMENT string is to be copied, copy that and update the
    // pointer in the structure.
    //
    if (Resource->lpComment != NULL) {
        //
        // If we must copy the comment string,
        //
        if (!NetpCopyStringToBuffer(
                    Resource->lpComment,            // pointer to string
                    STRLEN(Resource->lpComment),    // num chars in string
                    startOfFreeBuf,                 // start of open space
                    &endOfFreeBuf,                  // end of open space
                    &newResource->lpComment))       // where string pointer goes
        {
            goto ErrorMoreData ;
        }
    }
    else{
        newResource->lpComment = NULL;
    }

    //
    // If a PROVIDER string is to be copied, copy that and update the
    // pointer in the structure.
    //
    if (Resource->lpProvider != NULL) {
        //
        // If we must copy the provider name,
        //
        if (!NetpCopyStringToBuffer(
                    Resource->lpProvider,           // pointer to string
                    STRLEN(Resource->lpProvider),   // num chars in string
                    startOfFreeBuf,                 // start of open space
                    &endOfFreeBuf,                  // end of open space
                    &newResource->lpProvider))      // where string pointer goes
        {
            goto ErrorMoreData ;
        }
    }
    else{
        newResource->lpProvider = NULL;
    }

    //
    // Update the returned information
    //
    *BufPtr = (LPBYTE)startOfFreeBuf;

    *BytesLeft = (DWORD) ((LPBYTE) endOfFreeBuf - (LPBYTE) startOfFreeBuf);

    return (WN_SUCCESS);

    //
    // This is reached when we couldn't fill the buffer because the given
    // buffer size is too small.  We therefore need to set the required
    // buffer size before returning.

ErrorMoreData:

    *BytesLeft = MprMultiStrBuffSize( Resource->lpRemoteName,
                      Resource->lpLocalName,
                      Resource->lpComment,
                      Resource->lpProvider,
                      NULL ) + sizeof(NETRESOURCEW) ;

    return (WN_MORE_DATA);
}


DWORD
MprCopyProviderEnum(
    IN      LPNETRESOURCEW  ProviderBuffer,
    IN OUT  LPDWORD         EntryCount,
    IN OUT  LPBYTE          *TempBufPtr,
    IN OUT  LPDWORD         BytesLeft
    )

/*++

Routine Description:

    This function moves the enumerated NETRESOURCE structures that are
    returned from a provider to a buffer that can be returned to the user.
    The buffer that is returned to the user may contain enum data from
    several providers.  Because, we don't know how strings are packed in
    the buffer that is returned from the provider, we must simply walk
    through each structure and copy the information into the user buffer
    in a format that we do know about.  Then the amount of free space
    left in the user buffer can be determined so that enum data from
    another provider can be added to it.

Arguments:

    ProviderBuffer - This is a pointer to the top of an array of NETRESOURCE
        structures that is returned from one of the providers.

    EntryCount - This points to the number of elements in the array that
        was returned from the provider.  On exit, this points to the number
        of elements that was successfully copied.  This should always be
        the same as the number of elements passed in.

    TempBufPtr - This is a pointer to the top of the free space in the user
        buffer.

    BytesLeft - Upon entry, this contains the number of free space bytes
        in the user buffer.  Upon exit, this contains the updated number
        of free space bytes in the user buffer.


Return Value:

    WN_SUCCESS - The operation was successful

    WN_OUT_OF_MEMORY - The buffer was not large enough to contain all of
        data the provider returned.  This should never happen.

Note:


--*/
{
    DWORD   i;
    DWORD   status;
    DWORD   entriesRead=0;

    //
    // Loop for each element in the array of NetResource Structures.
    //
    for(i=0; i<*EntryCount; i++,ProviderBuffer++) {

        status = MprCopyResource(
                    TempBufPtr,
                    ProviderBuffer,
                    BytesLeft);

        if (status != WN_SUCCESS) {
            MPR_LOG(ERROR,"MprCopyProviderEnum: Buffer Size Mismatch\n",0);
            //
            // The buffer must be full - this should never happen since
            // the amount of data placed in the ProviderBuffer is limited
            // by the number of bytes left in the user buffer.
            //
            ASSERT(0);
            *EntryCount = entriesRead;
            return(status);
        }
        entriesRead++;
    }
    *EntryCount = entriesRead;
    return(WN_SUCCESS);
}


//===================================================================
// CProviderOpenEnum - open an enumeration by a provider
//===================================================================

DWORD
CProviderOpenEnum::ValidateRoutedParameters(
    LPCWSTR *       ppProviderName,
    LPCWSTR *       ppRemoteName,
    LPCWSTR *       ppLocalName
    )
{
    //
    // Let the base class validate any specified provider name.
    // Note: This must be done before setting _lpNetResource to NULL!
    //
    *ppProviderName = _lpNetResource->lpProvider;

    //
    // Check to see if a top level enumeration for the provider is requested.
    // (This is different from a top level MPR enumeration.)
    // A top level enum is signified by a net resource with either a special
    // bit set in the dwUsage field, or a provider name but no remote name.
    //
    if ((_lpNetResource->dwUsage & RESOURCEUSAGE_RESERVED) ||
        IS_EMPTY_STRING(_lpNetResource->lpRemoteName))
    {
        //
        // Top level enum.  Don't pass the net resource to the provider.
        //
        ASSERT(! IS_EMPTY_STRING(_lpNetResource->lpProvider));
        _lpNetResource = NULL;
    }
    else
    {
        //
        // Use the remote name as a hint to pick the provider order.
        //
        *ppRemoteName = _lpNetResource->lpRemoteName;
    }

    *ppLocalName = NULL;

    return WN_SUCCESS;
}


DWORD
CProviderOpenEnum::TestProvider(
    const PROVIDER * pProvider
    )
{
    ASSERT(MPR_IS_INITIALIZED(NETWORK));

    if ((pProvider->GetCaps(WNNC_ENUMERATION) & WNNC_ENUM_GLOBAL) == 0)
    {
        return WN_NOT_SUPPORTED;
    }

    return ( pProvider->OpenEnum(
                            _dwScope,
                            _dwType,
                            _dwUsage,
                            _lpNetResource,
                            &_ProviderEnumHandle) );
}


DWORD
CProviderOpenEnum::GetResult()
{
    //
    // Let the base class try the providers until one responds
    // CRoutedOperation::GetResult calls INIT_IF_NECESSARY
    //
    DWORD status = CRoutedOperation::GetResult();
    if (status != WN_SUCCESS)
    {
        return status;
    }

    MPR_LOG(TRACE,"CProviderOpenEnum: OpenEnum Handle = 0x%lx\n",
        _ProviderEnumHandle);

    //
    // Allocate memory to store the handle.
    //
    LPENUM_HANDLE enumHandleStruct =
        (ENUM_HANDLE *) LocalAlloc(LPTR, sizeof(ENUM_HANDLE));

    if (enumHandleStruct == NULL)
    {
        //
        // If we can't allocate memory to store the handle
        // away, then we must close it, and change the status
        // to indicate a memory failure.
        //
        MPR_LOG(ERROR,"CProviderOpenEnum: LocalAlloc failed %d\n",
            GetLastError());

        LastProvider()->CloseEnum(_ProviderEnumHandle);

        status = WN_OUT_OF_MEMORY;
    }
    else
    {
        //
        // Store the handle in the ENUM_HANDLE structure and
        // return the pointer to that structure as a handle
        // for the user.
        //
        enumHandleStruct->Key = PROVIDER_ENUM_KEY;

        //
        // Refcount the provider
        //
        enumHandleStruct->hProviderDll = LoadLibraryEx(LastProvider()->DllName,
                                                       NULL,
                                                       LOAD_WITH_ALTERED_SEARCH_PATH);

        if (enumHandleStruct->hProviderDll == NULL)
        {
            status = GetLastError();

            //
            // This can happen under extreme low memory conditions.  The
            // loader can sometimes return ERROR_MOD_NOT_FOUND in this case.
            //
            MPR_LOG2(ERROR,
                     "MprOpenEnumConnect: LoadLibraryEx on %ws FAILED %d\n",
                     LastProvider()->DllName,
                     status);

            ASSERT(status == ERROR_NOT_ENOUGH_MEMORY || status == ERROR_MOD_NOT_FOUND);
            LastProvider()->CloseEnum(_ProviderEnumHandle);
            LocalFree(enumHandleStruct);
        }
        else
        {
            enumHandleStruct->pfEnumResource = LastProvider()->EnumResource;
            enumHandleStruct->pfCloseEnum    = LastProvider()->CloseEnum;
            enumHandleStruct->EnumHandle     = _ProviderEnumHandle;
            *_lphEnum = enumHandleStruct;
        }
    }

    return status;
}


DWORD
MprOpenRemember(
    IN  DWORD       dwType,
    OUT LPHANDLE    lphRemember
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    LPREMEMBER_HANDLE   rememberInfo;

    rememberInfo = (REMEMBER_HANDLE *) LocalAlloc(LPTR, sizeof(REMEMBER_HANDLE));

    if (rememberInfo == NULL) {
        MPR_LOG(ERROR,"MprOpenRemember:LocalAlloc Failed %d\n",GetLastError());
        return(WN_OUT_OF_MEMORY);
    }

    rememberInfo->Key = REMEMBER_KEY;
    rememberInfo->KeyIndex = 0;
    rememberInfo->ConnectionType = dwType;

    //
    // Open the key to the connection information in the current user
    // section of the registry.
    //
    // NOTE:  If this fails, we must assume that there is no connection
    //  information stored.  This is not an error condition.
    //  In this case, we store a NULL for the handle so that we know
    //  the situation.  Each time EnumResource is called, we can try
    //  to open the key again.
    //

    if (!MprOpenKey(
            HKEY_CURRENT_USER,
            CONNECTION_KEY_NAME,
            &(rememberInfo->ConnectKey),
            DA_READ)) {

        MPR_LOG(ERROR,"MprOpenRemember: MprOpenKey Failed\n",0);
        rememberInfo->ConnectKey = NULL;
    }

    *lphRemember = (HANDLE)rememberInfo;

    return(WN_SUCCESS);

}

DWORD
MprEnumRemembered(
    IN OUT  LPREMEMBER_HANDLE   RememberInfo,
    IN OUT  LPDWORD             NumEntries,
    IN OUT  LPBYTE              lpBuffer,
    IN OUT  LPDWORD             lpBufferSize
    )

/*++

Routine Description:


Arguments:

    RememberInfo - This is a pointer to REMEMBER_HANDLE data structure
        that contains the context information for this enumeration handle.

    NumEntries - On entry this points to the maximum number of entries
        that the user desires to receive.  On exit it points to the
        number of entries that were placed in the users buffer.

    lpBuffer - This is a pointer to the users buffer in which the
        enumeration data is to be placed.

    lpBufferSize - This is the size (in bytes) of the users buffer.


Return Value:


    WN_SUCCESS - The call was successful, and some entries were returned.
        However, there are still more entries to be enumerated.

    WN_NO_MORE_ENTRIES - This function has no data to return because
        there was no further connection information in the registry.

    WN_CONNOT_OPEN_PROFILE - This function could open a key to the
        connection information, but could not get any information about
        that key.

    WN_MORE_DATA - The caller's buffer was too small for even one entry.

Note:

History:
    Changed to return "status" instead of WN_SUCCESS

--*/
{
    DWORD       status = WN_SUCCESS ;
    LPTSTR              userName;
    NETRESOURCEW        netResource;
    LPBYTE              tempBufPtr;
    DWORD               bytesLeft;
    DWORD               entriesRead = 0;
    DWORD               numSubKeys;
    DWORD               maxSubKeyLen;
    DWORD               maxValueLen;

    if ((RememberInfo->ConnectKey == NULL) && (RememberInfo->KeyIndex == 0)) {

        //
        // If we failed to open the key at Open-time, attempt to open it
        // now.  This registry key is closed when the CloseEnum function is
        // called.
        //

        if (!MprOpenKey(
                HKEY_CURRENT_USER,
                CONNECTION_KEY_NAME,
                &(RememberInfo->ConnectKey),
                DA_READ)) {

            //
            // We couldn't open the key.  So we must assume that it doesn't
            // exist because there if no connection information stored.
            //

            MPR_LOG(ERROR,"MprEnumRemembered: MprOpenKey Failed\n",0);
            RememberInfo->ConnectKey = NULL;
            return(WN_NO_MORE_ENTRIES);
        }
    }

    //
    // Find out the size of the largest key name.
    //

    if(!MprGetKeyInfo(
        RememberInfo->ConnectKey,
        NULL,
        &numSubKeys,
        &maxSubKeyLen,
        NULL,
        &maxValueLen)) {

        MPR_LOG(ERROR,"MprEnumRemembered: MprGetKeyInfo Failed\n",0);
        return(WN_CANNOT_OPEN_PROFILE);
    }

    //
    // If we've already enumerated all the subkeys, there are no more entries.
    //
    if (RememberInfo->KeyIndex >= numSubKeys) {
        return(WN_NO_MORE_ENTRIES);
    }
    tempBufPtr = lpBuffer;
    bytesLeft  = ROUND_DOWN(*lpBufferSize);
    tempBufPtr = lpBuffer;

    netResource.lpComment     = NULL;
    netResource.dwScope       = RESOURCE_REMEMBERED;
    netResource.dwUsage       = 0;
    netResource.dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;

    //
    // MprReadConnectionInfo may access the providers
    //
    MprCheckProviders();

    CProviderSharedLock    PLock;

    while(
            (RememberInfo->KeyIndex < numSubKeys) &&
            (entriesRead < *NumEntries)           &&
            (bytesLeft > sizeof(NETRESOURCE))
         )
    {
        //
        // Get the connection info from the key and stuff it into
        // a NETRESOURCE structure.
        //
        BOOL fMatch = FALSE;
        DWORD ProviderFlags; // ignored
        DWORD DeferFlags;    // ignored

        if(!MprReadConnectionInfo(
                RememberInfo->ConnectKey,
                NULL,
                RememberInfo->KeyIndex,
                &ProviderFlags,
                &DeferFlags,
                &userName,
                &netResource,
                NULL,
                maxSubKeyLen)) {

            //
            // NOTE:  The ReadConnectionInfo call could return FALSE
            // if it failed in a memory allocation.
            //
            if (entriesRead == 0) {
                status = WN_NO_MORE_ENTRIES;
            }
            else {
                status = WN_SUCCESS;
            }
            break;
        }
        else
        {
            if ((netResource.dwType == RememberInfo->ConnectionType) ||
                (RememberInfo->ConnectionType == RESOURCETYPE_ANY))  {

                fMatch = TRUE;
            }
        }

        //
        // Copy the new netResource information into the user's
        // buffer.  Each time this function is called, the tempBufPtr
        // gets updated to point to the next free space in the user's
        // buffer.
        //
        if ( fMatch )
        {
            status = MprCopyResource(
                         &tempBufPtr,
                         &netResource,
                         &bytesLeft);

            if (status != WN_SUCCESS) {

                if (entriesRead == 0) {
                    *lpBufferSize = ROUND_UP(bytesLeft);
                    status = WN_MORE_DATA;
                }
                else {
                    status = WN_SUCCESS;
                }
                break;
            }
            entriesRead++;
        }

        //
        // Free the allocated memory resources.
        //
        LocalFree(netResource.lpLocalName);
        LocalFree(netResource.lpRemoteName);
        LocalFree(netResource.lpProvider);
        if (userName != NULL) {
            LocalFree(userName);
        }

        (RememberInfo->KeyIndex)++;
    }

    *NumEntries = entriesRead;

    return(status);

}


DWORD
MprMultiStrBuffSize(
    IN      LPTSTR      lpString1,
    IN      LPTSTR      lpString2,
    IN      LPTSTR      lpString3,
    IN      LPTSTR      lpString4,
    IN      LPTSTR      lpString5
    )

/*++

Routine Description:

    This function is a worker function that simply determines the total
    storage requirements needed by the passed set of strings.  Any of the
    strings maybe NULL in which case the string will be ignored.

    The NULL terminator is added into the total memory requirements.

Arguments:

    lpString1 -> 5  - Pointers to valid strings or NULL.

Return Value:

    The count of bytes required to store the passed strings.

Note:


--*/
{
    DWORD cbRequired = 0 ;

    if ( lpString1 != NULL )
    {
    cbRequired += (STRLEN( lpString1 ) + 1) * sizeof(TCHAR) ;
    }

    if ( lpString2 != NULL )
    {
    cbRequired += (STRLEN( lpString2 ) + 1) * sizeof(TCHAR) ;
    }

    if ( lpString3 != NULL )
    {
    cbRequired += (STRLEN( lpString3 ) + 1) * sizeof(TCHAR) ;
    }

    if ( lpString4 != NULL )
    {
    cbRequired += (STRLEN( lpString4 ) + 1) * sizeof(TCHAR) ;
    }

    if ( lpString5 != NULL )
    {
    cbRequired += (STRLEN( lpString5 ) + 1) * sizeof(TCHAR) ;
    }

    return cbRequired ;
}

BOOL
MprNetIsAvailable(
    VOID)

/*++

Routine Description:

    This function checks if the net is available by calling the GetCaps
    of each provider to make sure it is started.

Arguments:

    none

Return Value:

    TRUE is yes, FALSE otherwise

Note:


--*/
{
    DWORD       status = WN_SUCCESS;
    LPDWORD     index;
    DWORD       indexArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders, i;
    LPPROVIDER  provider;
    DWORD       dwResult ;

    //
    // Find the list of providers to call for this request.
    // If there are no active providers, MprFindCallOrder returns
    // WN_NO_NETWORK.
    //
    index = indexArray;
    status = MprFindCallOrder(
                NULL,
                &index,
                &numProviders,
                NETWORK_TYPE);
    if (status != WN_SUCCESS)
        return(FALSE);

    //
    // Loop through the list of providers, making sure at least one
    // is started
    //
    ASSERT(MPR_IS_INITIALIZED(NETWORK));

    for (i=0; i<numProviders; i++)
    {
        //
        // Call the appropriate providers API entry point
        //
        provider = GlobalProviderInfo + index[i];

        if (provider->GetCaps != NULL)
        {
            dwResult = provider->GetCaps( WNNC_START );
            if (dwResult != 0)
            {
                if (index != indexArray)
                    LocalFree(index);
                return (TRUE) ;
            }
        }
    }

    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (index != indexArray)
        LocalFree(index);

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\lasterr.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lasterr.c

Abstract:

    Contains the entry point for
        WNetGetLastErrorW
        WNetSetLastErrorW
        MultinetGetErrorTextW

    Also contains the following support routines:
        MprAllocErrorRecord
        MprFreeErrorRecord
        MprFindErrorRecord

Author:

    Dan Lafferty (danl) 17-Oct-1991

Environment:

    User Mode - Win32

Revision History:

    09-Aug-1996 anirudhs
        Fixed bug in MprFindErrorRecord.  Replaced MprFreeErrorRecord with
        MprFreeAllErrorRecords (see mprinit.cxx).  Moved some definitions
        from mprdata.h here.

    20-Jun-1995 anirudhs
        Added MultinetGetErrorTextW.  Removed CurrentThreadId parameter to
        MprFindErrorRecord.  Some other cleanups.

    11-Aug-1993 danl
        WNetGetLastErrorW: Got rid of TCHAR stuff and committed to UNICODE.
        Also, consistently use number of characters rather than number
        of bytes.

    08-Jun-1993 danl
        Now we handle the case where WNetSetLastError is called with a
        threadId that we don't know about.   This happens in the case where
        a sub-thread does a LoadLibrary on MPR.DLL.  We only get
        notification of the one thread attaching.  Yet other threads within
        that process may call the WinNet functions.

    17-Oct-1991 danl
        Created

--*/
//
// INCLUDES
//

#include "precomp.hxx"
#include <tstring.h>    // STRSIZE, STRCPY
#include "mprres.h"     // IDS_XERR_UNKNOWN

//=======================
// Data Structures
//=======================

typedef struct _ERROR_RECORD {
    struct  _ERROR_RECORD   *Prev;
    struct  _ERROR_RECORD   *Next;
    DWORD                   ThreadId;
    DWORD                   ErrorCode;
    LPTSTR                  ErrorText;      // This is an allocated buffer
    LPTSTR                  ProviderName;   // This is an allocated buffer
} ERROR_RECORD, *LPERROR_RECORD;


//=======================
// MACROS/DEFINES
//=======================

#define FIND_END_OF_LIST(record)    while(record->Next != NULL) {   \
                                        record=record->Next;        \
                                    }

#define REMOVE_FROM_LIST(record)    record->Prev->Next = record->Next;      \
                                    if (record->Next != NULL) {             \
                                        record->Next->Prev = record->Prev;  \
                                    }

#define ADD_TO_LIST(record, newRec) FIND_END_OF_LIST(record)    \
                                    record->Next = newRec;      \
                                    newRec->Prev = record;      \
                                    newRec->Next = NULL;

//
// The string (in English) is 44 characters long (+1 for the NULL)
//
#define UNKNOWN_ERROR_LENGTH    80


//=======================
// GLOBALS
//=======================

extern HMODULE  hDLL;    // DLL instance handle

//
// Local Functions
//

LPERROR_RECORD
MprAllocErrorRecord(
    VOID);

LPERROR_RECORD
MprFindErrorRecord(
    VOID);


//
// Global Data Structures
//

ERROR_RECORD        MprErrorRecList;    // Initialized to zeros by loader
CRITICAL_SECTION    MprErrorRecCritSec; // Initialized in mprinit.cxx



DWORD
WNetGetLastErrorW(
    OUT     LPDWORD lpError,
    OUT     LPWSTR  lpErrorBuf,
    IN      DWORD   nErrorBufLen,
    OUT     LPWSTR  lpNameBuf,
    IN      DWORD   nNameBufLen
    )

/*++

Routine Description:

    This function allows users to obtain the error code and accompanying
    text when they receive a WN_EXTENDED_ERROR in response to a WNet API
    function call.

Arguments:

    lpError - This is a pointer to the location that will receive the
        error code.

    lpErrorBuf - This points to a buffer that will receive the null
        terminated string describing the error.

    nErrorBufLen - This value that indicates the size (in characters) of
        lpErrorBuf.
        If the buffer is too small to receive an error string, the
        string will simply be truncated.  (it is still guaranteed to be
        null terminated).  A buffer of at least 256 bytes is recommended.

    lpNameBuf - This points to a buffer that will receive the name of
        the provider that raised the error.

    nNameBufLen - This value indicates the size (in characters) of lpNameBuf.
        If the buffer is too small to receive an error string, the
        string will simply be truncated.  (it is still guaranteed to be
        null terminated).

Return Value:

    WN_SUCCESS - if the call was successful.

    WN_BAD_POINTER - One or more of the passed in pointers is bad.

    WN_DEVICE_ERROR - This indicates that the threadID for the current
        thread could not be found in that table anywhere.  This should
        never happen.

--*/
{
    LPERROR_RECORD  errorRecord;
    DWORD           nameStringLen;
    DWORD           textStringLen;
    DWORD           status = WN_SUCCESS;

    //
    // Screen the parameters as best we can.
    //
    __try {
        //
        // If output buffers are provided, Probe them.
        //

        *lpError = WN_SUCCESS;

        if (IsBadWritePtr(lpErrorBuf, nErrorBufLen * sizeof(WCHAR)) ||
            IsBadWritePtr(lpNameBuf,  nNameBufLen  * sizeof(WCHAR)))
        {
            status = WN_BAD_POINTER;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetGetLastError:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS) {
        return(status);
    }

    //
    // Get the current thread's error record.
    //
    errorRecord = MprFindErrorRecord();

    if (errorRecord != NULL) {
        //
        // The record was found in the linked list.
        // See if there is a buffer to put data into.
        //
        if (nErrorBufLen > 0) {
            //
            // Check to see if there is error text to return.
            // If not, indicate a 0 length string.
            //
            if(errorRecord->ErrorText == NULL) {
                *lpErrorBuf = L'\0';
            }
            else {
                //
                // If the error text won't fit into the user buffer, fill it
                // as best we can, and NULL terminate it.
                //
                textStringLen = wcslen(errorRecord->ErrorText);

                if(nErrorBufLen < textStringLen + 1) {
                    textStringLen = nErrorBufLen - 1;
                }

                //
                // textStringLen now contains the number of characters we
                // will copy without the NULL terminator.
                //
                wcsncpy(lpErrorBuf, errorRecord->ErrorText, textStringLen);
                *(lpErrorBuf + textStringLen) = L'\0';
            }
        }

        //
        // If there is a Name Buffer to put the provider into, then...
        //
        if (nNameBufLen > 0) {
            //
            // See if the Provider Name will fit in the user buffer.
            //
            nameStringLen = errorRecord->ProviderName ?
                 (wcslen(errorRecord->ProviderName) + 1) :
                 1 ;

            //
            // If the user buffer is smaller than the required size,
            // set up to copy the smaller of the two.
            //
            if(nNameBufLen < nameStringLen + 1) {
                nameStringLen = nNameBufLen - 1;
            }

            if (errorRecord->ProviderName) {
                wcsncpy(lpNameBuf, errorRecord->ProviderName, nameStringLen);
                *(lpNameBuf + nameStringLen) = L'\0';
            }
            else {
                *lpNameBuf = L'\0';
            }
        }
        *lpError = errorRecord->ErrorCode;

        return(WN_SUCCESS);
    }
    else {

        //
        // If we get here, a record for the current thread could not be found.
        //
        *lpError = WN_SUCCESS;
        if (nErrorBufLen > 0) {
            *lpErrorBuf = L'\0';
        }
        if (nNameBufLen > 0) {
            *lpNameBuf  = L'\0';
        }
        return(WN_SUCCESS);
    }
}


VOID
WNetSetLastErrorW(
    IN  DWORD   err,
    IN  LPWSTR  lpError,
    IN  LPWSTR  lpProvider
    )

/*++

Routine Description:

    This function is used by Network Providers to set extended errors.
    It saves away the error information in a "per thread" data structure.
    This function also calls SetLastError with the WN_EXTENDED_ERROR.

Arguments:

    err - The error that occured.  This may be a Windows defined error,
        in which case LpError is ignored.  or it may be ERROR_EXTENDED_ERROR
        to indicate that the provider has a network specific error to report.

    lpError - String describing a network specific error.

    lpProvider - String naming the network provider raising the error.

Return Value:

    none


--*/
{
    DWORD           status = WN_SUCCESS;
    LPERROR_RECORD  errorRecord;

    //
    // Set the extended error status that tells the user they need to
    // call WNetGetLastError to obtain further information.
    //
    SetLastError(WN_EXTENDED_ERROR);

    //
    // Get the Error Record for the current thread.
    //
    errorRecord = MprFindErrorRecord();

    //
    // if there isn't a record for the current thread, then add it.
    //
    if (errorRecord == NULL)
    {
        errorRecord = MprAllocErrorRecord();

        if (errorRecord == NULL)
        {
            MPR_LOG0(ERROR,"WNetSetLastError:Could not allocate Error Record\n");
            return;
        }
    }

    //
    // Update the error code in the error record.  At the same time,
    // free up any old strings since they are now obsolete, and init
    // the pointer to NULL.  Also set the ProviderName pointer in the
    // ErrorRecord to point to the provider's name.
    //

    errorRecord->ErrorCode = err;

    LocalFree(errorRecord->ProviderName);
    errorRecord->ProviderName = NULL;

    LocalFree(errorRecord->ErrorText);
    errorRecord->ErrorText = NULL;

    //
    // Allocate memory for the provider name.
    //
    __try {
        errorRecord->ProviderName = (WCHAR *) LocalAlloc(LPTR, STRSIZE(lpProvider));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // We have a problem with lpProvider.
        //
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetSetLastError:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS) {
        return;
    }

    if (errorRecord->ProviderName == NULL) {
        //
        // Unable to allocate memory for the Provider Name for the error
        // record.
        //
        MPR_LOG(ERROR,
            "WNetSetLastError:Unable to allocate mem for ProviderName\n",0);
        return;
    }

    //
    // Copy the string to the newly allocated buffer.
    //
    wcscpy(errorRecord->ProviderName, lpProvider);

    //
    //  Allocate memory for the storage of the error text.
    //
    __try {
        errorRecord->ErrorText = (WCHAR *) LocalAlloc(LPTR,STRSIZE(lpError));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // We have a problem with lpError.
        //
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetSetLastError:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }
    if (status != WN_SUCCESS) {
        errorRecord->ErrorText = NULL;
    }

    if (errorRecord->ErrorText == NULL) {

        //
        // If we were unsuccessful in allocating for the ErrorText, then
        // abort.  The ErrorText Pointer has already been set to null.
        //
        MPR_LOG(ERROR,"WNetSetLastError:Unable to Alloc for ErrorText %d\n",
            GetLastError());

        return;
    }

    //
    // Copy the error text into the newly allocated buffer.
    //
    wcscpy(errorRecord->ErrorText, lpError);
    return;
}

LPERROR_RECORD
MprFindErrorRecord(
    VOID)

/*++

Routine Description:

    Looks through the linked list of ErrorRecords in search of one for
    the current thread.

Arguments:

    none

Return Value:

    Returns LPERROR_RECORD if an error record was found.  Otherwise, it
    returns NULL.

--*/
{
    LPERROR_RECORD  errorRecord;
    DWORD           CurrentThreadId = GetCurrentThreadId();

    EnterCriticalSection(&MprErrorRecCritSec);
    for (errorRecord = MprErrorRecList.Next;
         errorRecord != NULL;
         errorRecord = errorRecord->Next)
    {
        if (errorRecord->ThreadId == CurrentThreadId)
        {
            break;
        }
    }
    LeaveCriticalSection(&MprErrorRecCritSec);
    return(errorRecord);
}


LPERROR_RECORD
MprAllocErrorRecord(
    VOID)

/*++

Routine Description:

    This function allocates and initializes an Error Record for the
    current thread.  Then it places the error record in the global
    MprErrorRecList.
    Even if the thread exits, the record is not freed until the DLL unloads.
    This is OK because this function is called only if a provider calls
    WNetSetLastError, which is rare.

Arguments:

    none

Return Value:

    TRUE - The operation completed successfully

    FALSE - An error occured in the allocation.

Note:


--*/
{
    LPERROR_RECORD  record;
    LPERROR_RECORD  errorRecord;

    //
    //  Allocate memory for the storage of the error message
    //  and add the record to the linked list.
    //
    errorRecord = (LPERROR_RECORD)LocalAlloc(LPTR,sizeof (ERROR_RECORD));

    if (errorRecord == NULL) {
        MPR_LOG1(ERROR,"MprAllocErrorRecord:LocalAlloc Failed %d\n",
        GetLastError());
        return NULL;
    }

    //
    // Initialize the error record
    //
    errorRecord->ThreadId = GetCurrentThreadId();
    errorRecord->ErrorCode = WN_SUCCESS;
    errorRecord->ErrorText = NULL;

    //
    // Add the record to the linked list.
    //
    EnterCriticalSection(&MprErrorRecCritSec);

    record = &MprErrorRecList;
    ADD_TO_LIST(record, errorRecord);

    LeaveCriticalSection(&MprErrorRecCritSec);

    return errorRecord;
}


VOID
MprFreeAllErrorRecords(
    VOID)

/*++

Routine Description:

    This function is called when the DLL is unloading due to a FreeLibrary
    call.  It frees all the error records (for all threads) that have been
    created since the DLL was loaded.  If there is a pointer to a text string
    in a record, the buffer for that string is freed also.

Arguments:


Return Value:


Note:


--*/
{
    LPERROR_RECORD nextRecord;

    EnterCriticalSection(&MprErrorRecCritSec);

    for (LPERROR_RECORD record = MprErrorRecList.Next;
         record != NULL;
         record = nextRecord)
    {
        MPR_LOG1(TRACE,"MprFreeErrorRecord: Freeing Record for thread 0x%x\n",
            record->ThreadId);

        LocalFree(record->ErrorText);
        LocalFree(record->ProviderName);

        nextRecord = record->Next;

        LocalFree(record);
    }

    MprErrorRecList.Next = NULL;

    LeaveCriticalSection(&MprErrorRecCritSec);
}


DWORD
MultinetGetErrorTextW(
    OUT     LPWSTR  lpErrorTextBuf OPTIONAL,
    IN OUT  LPDWORD lpnErrorBufSize,
    OUT     LPWSTR  lpProviderNameBuf OPTIONAL,
    IN OUT  LPDWORD lpnNameBufSize
    )

/*++

Routine Description:

    This is an internal interface between the shell and the MPR.  It
    combines the work of calling GetLastError and WNetGetLastError into
    one call.  It returns the text for the last error that occurred in
    a WNet API in the current thread.  The error text could have been
    customized by the provider calling WNetSetLastError.

Arguments:

    lpErrorTextBuf - Pointer to buffer that will receive a null-terminated
        string describing the error.  May be NULL if not required.

    lpnErrorBufSize - On entry, indicates the size (in characters) of
        lpErrorTextBuf.  A buffer of at least 256 bytes is recommended.
        If the buffer is too small for the error string, the string will
        simply be truncated (it is still guaranteed to be null terminated).
        May be NULL if lpErrorTextBuf is NULL.

    lpProviderNameBuf - This points to a buffer that will receive the name
        of the provider that raised the error, if it is known.  May be NULL
        if not required.

    lpnNameBufSize - This value indicates the size (in characters) of
        lpProviderNameBuf.  If the buffer is too small for the provider
        name, the name will simply be truncated (it is still guaranteed to
        be null terminated).  May be NULL if lpProviderNameBuf is NULL.

Return Value:

    WN_SUCCESS - if the call was successful.

    WN_BAD_POINTER - One or more of the passed in pointers is bad.

    Other errors from WNetGetLastErrorW or FormatMessageW.

Differences from Win 95:

    The provider name is returned as an empty string except in cases when
    the error was set by calling WNetSetLastError.

    Win 95 implements the feature that the caller can call other Win32 APIs
    before calling this API without losing the last error from the last
    WNet API.  This is not implemented here.  The caller must preserve the
    last error by calling GetLastError after the WNet API and SetLastError
    before MultinetGetErrorText.

    Win 95 gives providers the ability to customize error strings for
    standard Win32 error codes by calling NPSSetCustomText.  We do not.

--*/
{
    DWORD status = WN_SUCCESS;
    DWORD nErrorBufSize = 0;
    DWORD nNameBufSize = 0;

    //
    // Probe output buffers, and initialize to empty strings
    //

    if (ARGUMENT_PRESENT(lpErrorTextBuf))
    {
        if (IS_BAD_WCHAR_BUFFER(lpErrorTextBuf, lpnErrorBufSize))
        {
            status = WN_BAD_POINTER;
        }
        else
        {
            nErrorBufSize = *lpnErrorBufSize;
            if (nErrorBufSize > 0)
            {
                lpErrorTextBuf[0] = L'\0';
            }
        }
    }

    if (ARGUMENT_PRESENT(lpProviderNameBuf))
    {
        if (IS_BAD_WCHAR_BUFFER(lpProviderNameBuf, lpnNameBufSize))
        {
            status = WN_BAD_POINTER;
        }
        else
        {
            nNameBufSize = *lpnNameBufSize;
            if (nNameBufSize > 0)
            {
                lpProviderNameBuf[0] = L'\0';
            }
        }
    }

    if (status != WN_SUCCESS)
    {
        return status;
    }


    //
    // Get the last error that occurred in this thread
    //
    DWORD   LastError = GetLastError(); // last error in this thread
    DWORD   ErrorCode = LastError;      // message id to retrieve
    LPWSTR  ErrorText = NULL;           // error text to return
    LPWSTR  ProviderName = NULL;        // provider name to return
    BOOL    bFreeErrorText = FALSE;     // whether to call LocalFree

    //
    // If it's an extended error, look in this thread's error record for
    // the actual error code and strings
    //
    if (LastError == WN_EXTENDED_ERROR)
    {
        LPERROR_RECORD errorRecord = MprFindErrorRecord();

        if (errorRecord)
        {
            ErrorCode = errorRecord->ErrorCode;
            ErrorText = errorRecord->ErrorText;
            ProviderName = errorRecord->ProviderName;
        }
        else
        {
            // No error record found.
            // Either someone called SetLastError(WN_EXTENDED_ERROR) without
            // calling WNetSetErrorText, or an error record couldn't be
            // allocated because of lack of memory.
            // We'll return the standard message for WN_EXTENDED_ERROR.
            MPR_LOG0(ERROR,"MultinetGetErrorTextW:Couldn't retrieve extended error\n");
        }
    }

    WCHAR   Buffer[UNKNOWN_ERROR_LENGTH] = L"";

    //
    // Compute the final error text
    //
    if (ARGUMENT_PRESENT(lpErrorTextBuf))
    {
        //
        // If it wasn't an extended error, or we didn't get a custom error
        // string from WNetGetLastError, load the standard message for the
        // error code.
        //
        if (ErrorText == NULL)
        {
            if (FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM |        // get msg from system
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |    // let system alloc buffer
                    FORMAT_MESSAGE_IGNORE_INSERTS,      // no parms in msg
                    NULL,               // no source module or buffer
                    ErrorCode,          // message id
                    0,                  // use default language id
                    (LPWSTR) &ErrorText,// pointer to buffer for message
                    nErrorBufSize,      // min num of chars to allocate
                    NULL                // message parameters (none)
                    ))
            {
                bFreeErrorText = TRUE;  // ErrorText was allocated by the system
            }
            else
            {
                //
                // Couldn't get a message from the system, so use a catch-all
                //
                int cch = LoadString(hDLL,
                                     IDS_XERR_UNKNOWN,
                                     Buffer,
                                     LENGTH(Buffer));

                //
                // If this fails, up the value of UNKNOWN_ERROR_LENGTH
                //
                ASSERT(cch > 0 && cch < LENGTH(Buffer));

                ErrorText = Buffer;
            }
        }

        ASSERT (ErrorText != NULL);

        //
        // Decide whether to copy the error text to the caller's buffer
        //
        DWORD ReqLen = wcslen(ErrorText) + 1 ;
        if (ReqLen > nErrorBufSize)
        {
            *lpnErrorBufSize = ReqLen;
            status = WN_MORE_DATA;
        }
    }

    //
    // Compute final provider name, decide whether to copy to caller's buffer
    //
    if (ARGUMENT_PRESENT(lpProviderNameBuf))
    {
        if (ProviderName == NULL)
        {
            ProviderName = L"";
        }

        DWORD ReqLen = wcslen(ProviderName) + 1;
        if (ReqLen > nNameBufSize)
        {
            *lpnNameBufSize = ReqLen;
            status = WN_MORE_DATA;
        }
    }

    //
    // Copy strings
    //
    if (status == WN_SUCCESS)
    {
        if (ARGUMENT_PRESENT(lpErrorTextBuf))
        {
            wcscpy(lpErrorTextBuf, ErrorText);
        }

        if (ARGUMENT_PRESENT(lpProviderNameBuf))
        {
            wcscpy(lpProviderNameBuf, ProviderName);
        }
    }

    //
    // Free buffer allocated by FormatMessage
    //
    if (bFreeErrorText)
    {
        LocalFree(ErrorText);
    }

    //
    // FormatMessage, LocalFree, or other APIs we may have called from this API,
    // could have changed the last error, so restore it now.
    //
    SetLastError(LastError);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\connify.cxx ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    connify.cxx

Abstract:

    Contains code used to notify all DLLs interested in notifiable MPR
    Events.  Currently only connection information results in
    notification.

Author:

    Dan Lafferty (danl)     14-Dec-1993

Environment:

    User Mode -Win32

Revision History:

    14-Dec-1993     danl
        created

    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include "connify.h"    // MprAddConnectNotify


//===================
// TYPEDEFs
//===================
typedef struct _NOTIFYEE {
    PF_AddConnectNotify         PF_AddConnectNotify;
    PF_CancelConnectNotify      PF_CancelConnectNotify;
    HINSTANCE                   DllHandle;
}NOTIFYEE, *LPNOTIFYEE;

//===================
// DEFINES
//===================
#define NOTIFYEE_ROOT   TEXT("system\\CurrentControlSet\\Control\\NetworkProvider\\Notifyees")


//===================
// GLOBALs
//===================
//
// A pointer to an array of NOTIFYEE structures.
// These are only modified by MprConnectNotifyInif.
// The MprInitCritSec is obtained prior to calling
// MprConnectNotifyInit.
//
    LPNOTIFYEE  NotifyList = NULL;
    DWORD       GlobalNumNotifyees = 0;



DWORD
MprConnectNotifyInit(
    VOID
    )

/*++

Routine Description:

    This function does the following:
    1)  Look in the registry to determine which DLLs want to be notified of
        Connection Events.
    2)  Load the Notifiee DLLs.
    3)  Obtain the entry points for the notify functions.
    4)  Create a list of all the Notifiee Information.

Arguments:

    NONE

Return Value:

    WN_SUCCESS


--*/
{
    HKEY    notifyeeRootKey;
    DWORD   status;
    DWORD   numSubKeys;
    DWORD   cchMaxSubKey;
    DWORD   numValues;
    DWORD   cchMaxValueName;
    DWORD   type;
    DWORD   bufSize;
    TCHAR   dllPath[MAX_PATH];
    TCHAR   buffer[MAX_PATH];
    LPTSTR  expandedPath=NULL;
    DWORD   nameSize;
    HINSTANCE   hLib=NULL;
    DWORD   i;
    DWORD   numReqd;
    LPNOTIFYEE  NotifyEntry;

    //
    // Read the Registry Information for Notifiees.
    // If the key doesn't exist, then there is no one to notify.
    //
    if (!MprOpenKey (
            HKEY_LOCAL_MACHINE,     // hKey
            NOTIFYEE_ROOT,          // lpSubKey
            &notifyeeRootKey,       // Newly Opened Key Handle
            DA_READ)) {             // Desired Access

        MPR_LOG0(CNOTIFY,"MprConnectInfoInit: NOTIFYEE_ROOT doesen't exist\n");
        return(WN_SUCCESS);
    }

    //
    // GetKeyInfo (find out how many values)
    //

    if (!MprGetKeyInfo (
                notifyeeRootKey,
                NULL,
                &numSubKeys,
                &cchMaxSubKey,
                &numValues,
                &cchMaxValueName)) {

        MPR_LOG0(CNOTIFY,"MprConnectInfoInit: Couldn't get key info\n");
        return(WN_SUCCESS);
    }
    MPR_LOG1(CNOTIFY,"MprConnectInfoInit: GlobalNumNotifyees = %d\n",numValues);

    //
    // Allocate space for that many notifyees.
    //
    if (numValues == 0) {
        return(WN_SUCCESS);
    }

    NotifyList = (LPNOTIFYEE) LocalAlloc(LPTR,numValues * sizeof(NOTIFYEE));
    if (NotifyList == NULL) {
        return(GetLastError());
    }

    NotifyEntry = NotifyList;
    //
    // Load the Notifyees and get their entry points.
    //
    for (i=0; i<numValues; i++) {
        bufSize  = MAX_PATH * sizeof (TCHAR);
        nameSize = MAX_PATH;
        expandedPath = NULL;

        status = RegEnumValue(
                    notifyeeRootKey,
                    i,
                    buffer,
                    &nameSize,
                    NULL,
                    &type,
                    (LPBYTE)dllPath,
                    &bufSize);

        if (status != NO_ERROR) {
            MPR_LOG0(CNOTIFY,"MprConnectInfoInit: RegEnumValue failure\n");
        }
        else {
            switch (type) {
            case REG_EXPAND_SZ:
                numReqd = ExpandEnvironmentStrings(dllPath,buffer,MAX_PATH);
                if (numReqd > MAX_PATH) {
                    expandedPath = (LPTSTR) LocalAlloc(LMEM_FIXED,numReqd*sizeof(TCHAR) );
                    if (expandedPath == NULL) {
                        //
                        // We can't expand the string, so we skip this notifyee
                        // and go onto the next.
                        //
                        status = GetLastError();
                        break;  // Leave the switch and cleanup this notifyee
                    }
                    numReqd = ExpandEnvironmentStrings(dllPath,expandedPath,numReqd);
                    if (numReqd > MAX_PATH) {
                        MPR_LOG0(CNOTIFY,"MprConnectNotifyInit: Couldn't Expand Path\n");
                        status = ERROR_BAD_LENGTH;
                        break;  // Leave the switch and cleanup this notifyee
                    }
                }
                else {
                    expandedPath = buffer;
                }

                // Fall thru to the REG_SZ case....

            case REG_SZ:
                if (expandedPath == NULL) {
                    expandedPath = dllPath;
                }
                //
                // Load the DLL
                //
                hLib =  LoadLibraryEx(expandedPath,
                                      NULL,
                                      LOAD_WITH_ALTERED_SEARCH_PATH);
                if (hLib == NULL) {
                    status = GetLastError();
                    MPR_LOG2(CNOTIFY,"MprConnectInfoInit:LoadLibraryEx for %ws failed %d\n",
                        expandedPath, status);

                    break;  // Leave the switch and cleanup this notifyee
                }

                //
                // Get the Entry Points from the DLL.
                //
                NotifyEntry->PF_AddConnectNotify =
                    (PF_AddConnectNotify)GetProcAddress(hLib,"AddConnectNotify");
                NotifyEntry->PF_CancelConnectNotify =
                    (PF_CancelConnectNotify)GetProcAddress(hLib,"CancelConnectNotify");

                //
                // If and Only If both functions are supported, then increment
                // the NotifyList.
                //
                if ((NotifyEntry->PF_AddConnectNotify != NULL) &&
                    (NotifyEntry->PF_CancelConnectNotify != NULL)) {
                    NotifyEntry->DllHandle = hLib;
                    NotifyEntry++;
                    GlobalNumNotifyees++;
                    MPR_LOG1(CNOTIFY,"MprConnectInfoInit: Item added to "
                    "notify list %d\n",GlobalNumNotifyees);
                }
                else {
                    FreeLibrary (hLib);
                    hLib = NULL;
                }
                break;

            default:
                break;
            }
        }

        //
        // Cleanup resources for this notifyee
        //
        if ((expandedPath != NULL)      &&
            (expandedPath != dllPath)   &&
            (expandedPath != buffer)) {
            LocalFree(expandedPath);
        }

    }  // End for(Each Notifyee)

    if (GlobalNumNotifyees == 0) {
        if (NotifyList != NULL) {
            LocalFree(NotifyList);
            NotifyList = NULL;
        }
    }

    RegCloseKey(notifyeeRootKey);
    return(WN_SUCCESS);
}

VOID
MprCleanupNotifyInfo(
    VOID
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD   i;

    ASSERT_INITIALIZED(NOTIFIEE);

    for (i=0; i<GlobalNumNotifyees; i++ ) {
        FreeLibrary(NotifyList[i].DllHandle);
    }
    LocalFree(NotifyList);
    return;
}


PVOID
MprAllocConnectContext(
    VOID
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    ASSERT_INITIALIZED(NOTIFIEE);

    if (GlobalNumNotifyees == 0) {
        return(NULL);
    }
    MPR_LOG1(CNOTIFY,"In MprAllocConnectContext.  Allocating for %d notifyees\n",
        GlobalNumNotifyees);

    return(PVOID)(LocalAlloc(LPTR,sizeof(PVOID) * GlobalNumNotifyees));
}


VOID
MprFreeConnectContext(
    PVOID   ConnectContext
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    MPR_LOG0(CNOTIFY,"In MprFreeConnectContext\n");
    LocalFree(ConnectContext);
}


DWORD
MprAddConnectNotify(
    LPNOTIFYINFO        lpNotifyInfo,
    LPNOTIFYADD         lpAddInfo
    )

/*++

Routine Description:

    This function calls all the Notifyees if an add connection event.

Arguments:

    lpNotifyInfo -
    lpAddInfo -

Return Value:

    If any of the notifyees returns WN_CANCEL, the notification is immediately
    aborted and the WN_CANCEL is returned from the caller.
    Aside from that error, if WN_RETRY is returned from any notifyee, then
    WN_RETRY is returned to the caller.  Otherwise, the last error is returned.
    If all notifyees return WN_SUCCESS, then the last error will be WN_SUCCESS.

--*/
{
    DWORD   i;
    DWORD   status;
    DWORD   lastError=WN_SUCCESS;
    BOOL    retryFlag=FALSE;
    DWORD   numNotifyees = GlobalNumNotifyees;
    PVOID   *ContextInfo;
    LPNOTIFYEE  NotifyEntry=NotifyList;

    MPR_LOG0(CNOTIFY,"In MprAddConnectNotify\n");

    ASSERT_INITIALIZED(NOTIFIEE);

    //
    // Save away the pointer to the array of context information.
    //
    ContextInfo = (PVOID *) lpNotifyInfo->lpContext;

    for (i=0; i<numNotifyees; i++,NotifyEntry++ )
    {
        if (lpNotifyInfo->dwNotifyStatus == NOTIFY_POST)
        {
            if (ContextInfo && ContextInfo[i] != NULL)
            {
                lpNotifyInfo->lpContext = ContextInfo[i];
            }
            else
            {
                //
                // Don't notify if it is a POST notification, and there
                // is no context saved.  Here we go directly to the next
                // notifyee (or out of the for loop).
                //
                continue;
            }
        }

        status = NotifyEntry->PF_AddConnectNotify(lpNotifyInfo,lpAddInfo);

        switch (status) {
        case WN_SUCCESS:
            MPR_LOG0(CNOTIFY,"AddConnectNotify SUCCESS\n");

            if (ContextInfo != NULL)
            {
                ContextInfo[i] = lpNotifyInfo->lpContext;
            }

            break;

        case WN_CANCEL:
            MPR_LOG0(CNOTIFY,"AddConnectNotify WN_CANCEL\n");
            //
            // CANCEL shouldn't be returned from NOTIFY_POST calls.
            //
            if (lpNotifyInfo->dwNotifyStatus == NOTIFY_PRE) {
                //
                // If we got the cancel for the first notifyee, then we can
                // stop here.
                //
                if (i == 0) {
                    lpNotifyInfo->lpContext = ContextInfo;
                    return(status);
                }
                //
                // If we have already successfully called some notifyees, then we
                // must now post notify them of the cancel.
                //
                numNotifyees = i;
                lpNotifyInfo->dwNotifyStatus = NOTIFY_POST;
                i = 0xffffffff;
            }
            break;

        case WN_RETRY:
            MPR_LOG0(CNOTIFY,"AddConnectNotify WN_RETRY\n");
            //
            // RETRY is only valid if the operation failed and
            // this is a post notification.
            //
            if ((lpNotifyInfo->dwOperationStatus != WN_SUCCESS) &&
                (lpNotifyInfo->dwNotifyStatus == NOTIFY_POST)) {

                retryFlag = TRUE;

                if (ContextInfo != NULL)
                {
                    ContextInfo[i] = lpNotifyInfo->lpContext;
                }

                //
                // If we need to retry, then we must now pre-notify those
                // notifyees that we have already post-notified.  We don't
                // want to post-notify any more notifyees.
                //

                if (i > 0) {
                    numNotifyees = i;
                    lpNotifyInfo->dwNotifyStatus = NOTIFY_PRE;
                    i = 0xffffffff;
                }
            }
            break;

        default:
            MPR_LOG1(CNOTIFY,"AddConnectNotify returned an error %d\n",status);
            lastError = status;
            break;
        }
    }
    //
    // Restore the pointer to the array of context information.
    //
    lpNotifyInfo->lpContext = ContextInfo;

    //
    // No matter if other error occured, if one of the notifyees wants
    // a retry, we will return retry.
    //
    if (retryFlag == TRUE) {
        return(WN_RETRY);
    }
    return(lastError);
}

DWORD
MprCancelConnectNotify(
    LPNOTIFYINFO        lpNotifyInfo,
    LPNOTIFYCANCEL      lpCancelInfo
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD   i;
    DWORD   status;
    DWORD   lastError=WN_SUCCESS;
    BOOL    retryFlag=FALSE;
    DWORD   numNotifyees = GlobalNumNotifyees;
    PVOID   *ContextInfo;
    LPNOTIFYEE  NotifyEntry=NotifyList;

    MPR_LOG0(CNOTIFY,"In MprCancelConnectNotify\n");

    ASSERT_INITIALIZED(NOTIFIEE);

    //
    // Save away the pointer to the array of context information.
    //
    ContextInfo = (PVOID *) lpNotifyInfo->lpContext;

    for (i=0; i<numNotifyees; i++,NotifyEntry++)
    {
        if (lpNotifyInfo->dwNotifyStatus == NOTIFY_POST)
        {
            if (ContextInfo && ContextInfo[i] != NULL)
            {
                lpNotifyInfo->lpContext = ContextInfo[i];
            }
            else
            {
                //
                // Don't notify if it is a POST notification, and there
                // is no context saved.  Here we go directly to the next
                // notifyee (or out of the for loop).
                //
                continue;
            }
        }

        status = NotifyEntry->PF_CancelConnectNotify(lpNotifyInfo,lpCancelInfo);

        switch (status) {
        case WN_SUCCESS:
            MPR_LOG0(CNOTIFY,"CancelConnectNotify SUCCESS\n");

            if (ContextInfo != NULL)
            {
                ContextInfo[i] = lpNotifyInfo->lpContext;
            }

            break;

        case WN_CANCEL:
            MPR_LOG0(CNOTIFY,"CancelConnectNotify WN_CANCEL\n");
            //
            // It is assumed that CANCEL won't be returned from
            // NOTIFY_POST calls.
            //
            // If we got the cancel for the first notifyee, then we can
            // stop here.
            //
            if (i == 0) {
                lpNotifyInfo->lpContext = ContextInfo;
                return(status);
            }
            //
            // If we have already successfully called some notifyees, then we
            // must now post notify them of the cancel.
            //
            numNotifyees = i;
            lpNotifyInfo->dwNotifyStatus = NOTIFY_POST;
            i = 0xffffffff;
            break;

        case WN_RETRY:
            MPR_LOG0(CNOTIFY,"CancelConnectNotify WN_RETRY\n");
            retryFlag = TRUE;

            if (ContextInfo != NULL)
            {
                ContextInfo[i] = lpNotifyInfo->lpContext;
            }

            break;

        default:
            MPR_LOG1(CNOTIFY,"CancelConnectNotify returned an error %d\n",status);
            lastError = status;
            break;
        }
    }

    //
    // Restore the pointer to the array of context information.
    //
    lpNotifyInfo->lpContext = ContextInfo;

    //
    // No matter if other error occured, if one of the notifyees wants
    // a retry, we will return retry.
    //
    if (retryFlag == TRUE) {
        return(WN_RETRY);
    }
    return(lastError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\makefile.inc ===
$(O)\mpr.lib : $(O)\mprp.lib

$(O)\mprp.lib: mprp.def $(LIBRARY_OBJS)
    -lib -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:mprp.def
$(LIBRARY_OBJS)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\mpransi.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mpransi.cxx

Abstract:

    Contains Ansi Entry points for the MPR api.

Author:

    Dan Lafferty (danl)     20-Dec-1991

Environment:

    User Mode -Win32

Notes:

    I may want to add a buffer size parameter to ConvertToAnsi

Revision History:

    08-Aug-1996     anirudhs
        Major revision (simplification): Converted all remaining APIs to
        the smaller, faster interpreted scheme.  Added ANSI_API_ macros.
        Eliminated helper functions used by the old scheme.  These changes
        shrink this file by about 1400 lines.
    16-Feb-1996     anirudhs
        Added InputParmsToUnicode, OutputBufferToAnsi and helper functions.
        These form a smaller, faster, interpreted scheme for writing the
        Ansi APIs.  This scheme is smaller chiefly because it eliminates
        a very large amount of code duplication present in the previous
        scheme.  This also makes the Ansi APIs less bug-prone.  It is
        faster chiefly because intermediate storage is allocated with a
        single heap allocation per API, rather than several.  Also, the
        number of passes to scan and copy data is minimized.
    06-Oct-1995     anirudhs
        MprMakeUnicodeNetRes and related functions: Removed duplicated
        code for the string fields of the net resource; added code to
        iterate over the string fields instead.  Fixed access violation
        and memory leaks.
    24-Aug-1992     danl
        For WNetGetConnection & WNetGetUser, we allocate a buffer twice
        the size of the user buffer.  The data is placed in this buffer.
        Then we check to see if the data will fit in the user buffer
        after it is translated to Ansi.  The presence of DBSC characters
        may make it not fit.  In which case, we return the required number
        of bytes. This number assumes worse-case where all characters are
        DBCS characters.
    20-Dec-1991     danl
        created

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <string.h>     // strlen
#include <tstring.h>    // STRLEN


//
// CONSTANTS
//

#define MAX_STRINGS_PER_API     6

//
// The following masks are used to indicate which fields in the NetResource
// structure are used by an API.
// The values must match the NRWField and NRAField arrays.
//
#define NETRESFIELD_LOCALNAME       0x00000001
#define NETRESFIELD_REMOTENAME      0x00000002
#define NETRESFIELD_COMMENT         0x00000004
#define NETRESFIELD_PROVIDER        0x00000008

#define NUMBER_OF_NETRESFIELD   4

//
// Combinations of the NETRESFIELD_ constants, for passing to InputParmsToUnicode.
//
#define NETRES_LRP  "\xB"   // local name, remote name, provider
#define NETRES_RP   "\xA"   // remote name, provider

//
// Alignment macros
// These macros assume that sizeof(WCHAR) and sizeof(DWORD) are powers of 2
//
#define ROUND_UP_TO_WCHAR(x)    (((DWORD)(x) + sizeof(WCHAR) - 1) & ~(sizeof(WCHAR) - 1))
#define ROUND_UP_TO_DWORD(x)    (((DWORD)(x) + sizeof(DWORD) - 1) & ~(sizeof(DWORD) - 1))
#define IS_WCHAR_ALIGNED(x)     (((ULONG_PTR)(x) & (sizeof(WCHAR) - 1)) == 0)
#define IS_DWORD_ALIGNED(x)     (((ULONG_PTR)(x) & (sizeof(DWORD) - 1)) == 0)

//
// Nearly every API ends this way
//
#define SET_AND_RETURN(status)                              \
    if (status != NO_ERROR)                                 \
    {                                                       \
        SetLastError(status);                               \
    }                                                       \
                                                            \
    return status;

//
// This is the general pattern of an Ansi wrapper for an API with no
// output Ansi parameters.  There are some exceptions.
//
#define ANSI_API_WITHOUT_ANSI_OUTPUT(NUMBER_OF_PARMS,       \
                                     ANSI_PARM_ASSIGNMENT,  \
                                     INSTRUCTION_STRING,    \
                                     UNICODE_CALL)          \
                                                            \
    DWORD           status;                                 \
    LPBYTE          tempBuffer = NULL;                      \
    ANSI_PARM       AParm[NUMBER_OF_PARMS];                 \
    UNICODE_PARM    UParm[NUMBER_OF_PARMS];                 \
                                                            \
    ANSI_PARM_ASSIGNMENT                                    \
                                                            \
    status = InputParmsToUnicode(INSTRUCTION_STRING, AParm, UParm, &tempBuffer);    \
                                                            \
    if (status == WN_SUCCESS)                               \
    {                                                       \
        status = UNICODE_CALL                               \
    }                                                       \
                                                            \
    LocalFree(tempBuffer);                                  \
                                                            \
    SET_AND_RETURN(status)



//
// This is the general pattern of an Ansi wrapper for an API that
// has output Ansi parameters.  There are some exceptions.
//
#define ANSI_API_WITH_ANSI_OUTPUT(NUMBER_OF_PARMS,          \
                                  ANSI_PARM_ASSIGNMENT,     \
                                  INSTRUCTION_STRING,       \
                                  UNICODE_CALL,             \
                                  OUTPUT_CALL)              \
                                                            \
    DWORD           status;                                 \
    LPBYTE          tempBuffer = NULL;                      \
    ANSI_PARM       AParm[NUMBER_OF_PARMS];                 \
    UNICODE_PARM    UParm[NUMBER_OF_PARMS];                 \
                                                            \
    ANSI_PARM_ASSIGNMENT                                    \
                                                            \
    status = InputParmsToUnicode(INSTRUCTION_STRING, AParm, UParm, &tempBuffer);    \
                                                            \
    if (status == WN_SUCCESS)                               \
    {                                                       \
        status = UNICODE_CALL                               \
                                                            \
        if (status == WN_SUCCESS)                           \
        {                                                   \
            status = OUTPUT_CALL                            \
        }                                                   \
    }                                                       \
                                                            \
    LocalFree(tempBuffer);                                  \
                                                            \
    SET_AND_RETURN(status)



//
// STRUCTURES
//

// These unions are defined so that parameters of various types can be passed
// to the generic routine InputParmsToUnicode.
// CODEWORK: By using these unions, we have lost type safety, and this could
// cause some bugs to go undetected.  To get back type safety, ANSI_PARM and
// UNICODE_PARM could be made into "smart union" classes, with overloaded
// assignment and cast operators that, in the checked build, remember the
// type of the data that they are assigned, and assert if they are used as
// any other type of data.
// This would also make the code neater by allowing initializers like
// ANSI_PARM AParm[] = { lpName, lpUserName, lpnLength };

typedef union
{
    DWORD           dword;
    LPCSTR          lpcstr;
    LPNETRESOURCEA  lpNetResA;
    LPVOID          lpvoid;
    LPDWORD         lpdword;
} ANSI_PARM;

typedef union
{
    DWORD           dword;
    LPBYTE          lpbyte;
    LPWSTR          lpwstr;
    LPNETRESOURCEW  lpNetResW;
} UNICODE_PARM;


class ANSI_OUT_BUFFER
{
private:
    const LPBYTE    _Start; // Pointer to start of buffer
    const DWORD     _Size;  // Total number of bytes in buffer
    DWORD           _Used;  // Number of bytes used (may exceed Size)

public:

            ANSI_OUT_BUFFER(LPBYTE Start, DWORD Size) :
                _Start(Start),
                _Size (Size),
                _Used (0)
                { }

    BYTE *  Next() const
        { return _Start + _Used; }

    BOOL    Overflow() const
        { return (_Used > _Size); }

    DWORD   FreeSpace() const
        { return (Overflow() ? 0 : _Size - _Used); }

    BOOL    HasRoomFor(DWORD Request) const
        { return (_Used + Request <= _Size); }

    void    AddUsed(DWORD Request)
        { _Used += Request; }

    DWORD   GetUsage() const
        { return _Used; }
};

//
// STATIC DATA
//

//
// These arrays of members are used to iterate through the string fields
// of a net resource.
// The order must match the NETRESFIELD_ definitions.
//

LPWSTR NETRESOURCEW::* const NRWField[NUMBER_OF_NETRESFIELD] =
{
    &NETRESOURCEW::lpLocalName,
    &NETRESOURCEW::lpRemoteName,
    &NETRESOURCEW::lpComment,
    &NETRESOURCEW::lpProvider
};

LPSTR NETRESOURCEA::* const NRAField[NUMBER_OF_NETRESFIELD] =
{
    &NETRESOURCEA::lpLocalName,
    &NETRESOURCEA::lpRemoteName,
    &NETRESOURCEA::lpComment,
    &NETRESOURCEA::lpProvider
};


//
// Local Functions
//

DWORD
InputParmsToUnicode(
    IN  LPCSTR          Instructions,
    IN  const ANSI_PARM InputParms[],
    OUT UNICODE_PARM    OutputParms[],
    OUT LPBYTE *        ppBuffer
    );

DWORD
StringParmToUnicodePass1(
    IN      LPCSTR          StringParm,
    OUT     PANSI_STRING    AnsiString,
    OUT     PUNICODE_STRING UnicodeString,
    IN OUT  PULONG          BufferOffset
    );

DWORD
StringParmToUnicodePass2(
    IN OUT  PANSI_STRING    AnsiString,
    OUT     PUNICODE_STRING UnicodeString,
    IN      const BYTE *    BufferStart,
    OUT     LPWSTR *        Result
    );

DWORD
OutputBufferToAnsi(
    IN  char        BufferFormat,
    IN  LPBYTE      SourceBuffer,
    OUT LPVOID      AnsiBuffer,
    IN OUT LPDWORD  pcbBufferSize
    );

DWORD
OutputStringToAnsi(
    IN  LPCWSTR     UnicodeIn,
    IN OUT ANSI_OUT_BUFFER * Buf
    );

DWORD
OutputStringToAnsiInPlace(
    IN  LPWSTR      UnicodeIn
    );

DWORD
OutputNetResourceToAnsi(
    IN  NETRESOURCEW *  lpNetResW,
    IN OUT ANSI_OUT_BUFFER * Buf
    );



DWORD
InputParmsToUnicode(
    IN  LPCSTR          Instructions,
    IN  const ANSI_PARM InputParms[],
    OUT UNICODE_PARM    OutputParms[],
    OUT LPBYTE *        ppBuffer
    )
/*++

Routine Description:

    This function converts the caller's input parameters to Unicode.
    If necessary, it allocates one temporary buffer in which it stores
    the intermediate Unicode parameters.  This minimizes the cost of
    calls to LocalAlloc.

Arguments:

    Instructions - A string of characters, roughly one for each member
        of the InputParms array, describing the action to be taken on each
        InputParms member.  Recognized values for the characters are:

        'S' (String) - InputParms member is an LPSTR to be converted to
            Unicode.  Store a pointer to the Unicode string in the
            corresponding OutputParms member.

        'N' (NetResource) - InputParms member is a LPNETRESOURCEA to be
            converted to a NETRESOURCEW.  The next character in Instructions
            is a bitmask of the NETRESFIELD_ constants, indicating which
            fields of the NETRESOURCEA to convert.  Store a pointer to the
            NETRESOURCEW in the corresponding OutputParms member.

        'B' (Buffer) - InputParms member (say InputParms[i]) is a pointer to
            an output buffer.  InputParms[i+1] is a pointer to a DWORD
            indicating the buffer size in bytes.  Probe the buffer for write.
            Allocate an area of double the size (i.e. of size
            (*InputParms[i+1])*sizeof(WCHAR)) in the intermediate buffer.
            Store a pointer to this area of the buffer in OutputParms[i].
            Store the size of this area in OutputParms[i+1].

            If InputParms[i] is NULL, store NULL in OutputParms[i], and
            ignore InputParms[i+1].  (In other words, the buffer pointer
            is optional; the size pointer is required if the buffer pointer
            is present and ignored if the buffer pointer is absent.)

        'Bs' (Buffer beginning with structure) - Same as 'B', but the first
            N bytes of the output buffer, where N is stored in InputParms[i+2],
            are supposed to hold a fixed-size structure, not strings.
            When calculating the size of the intermediate area, double the
            size of the rest of the buffer, but not the size of the structure.
            CODEWORK: Also verify that the buffer is DWORD-aligned?

    InputParms - An array of parameters to the Ansi API, described by the
        Instructions parameter.

    OutputParms - An array of the same size as InputParms, to hold the
        converted Unicode parameters.

    ppBuffer - A pointer to the intermediate buffer allocated by this
        function will be stored here.  It must be freed by a single call
        to LocalFree, regardless of the return value from this function.

Return Value:

    WN_SUCCESS

    WN_OUT_OF_MEMORY

    WN_BAD_POINTER

History:

    16-Feb-1996     anirudhs    Created.

Notes:

    The function works by making two passes through the Instructions string.
    In the first pass the string lengths are determined and saved, and the
    required size of the temporary buffer is calculated.  In the second
    pass the parameters are actually converted to Unicode.

--*/
{
    ANSI_STRING    AnsiStrings   [MAX_STRINGS_PER_API] = {0};
    UNICODE_STRING UnicodeStrings[MAX_STRINGS_PER_API] = {0};
    ULONG          Bytes = 0;       // Size of buffer to allocate
    DWORD          status = WN_SUCCESS;

    //
    // The caller must have initialized the buffer pointer to NULL, so
    // he can free the buffer even if this function fails.
    //
    ASSERT(*ppBuffer == NULL);

    __try
    {
        //
        // For two passes through Instructions
        //
        #define FIRST_PASS  (iPass == 0)
        for (ULONG iPass = 0; iPass <= 1; iPass++)
        {
            ULONG iString = 0;          // Index into AnsiStrings and UnicodeStrings

            //
            // For each character in Instructions
            //
            const CHAR * pInstruction;  // Pointer into Instructions
            ULONG iParm;                // Index into InputParms and OutputParms
            for (pInstruction = Instructions, iParm = 0;
                 *pInstruction;
                 pInstruction++, iParm++)
            {
                MPR_LOG(ANSI, "Processing instruction '%hc'\n", *pInstruction);

                switch (*pInstruction)
                {
                case 'B':
                    //
                    // The next 2 InputParms are a buffer pointer and size.
                    // Note that this code could cause an exception.
                    //
                    if (InputParms[iParm].lpvoid == NULL)
                    {
                        // A NULL pointer stays NULL; the size pointer is ignored
                        OutputParms[iParm].lpbyte = NULL;
                    }
                    else if (FIRST_PASS)
                    {
                        // Probe the original buffer
                        if (IS_BAD_BYTE_BUFFER(InputParms[iParm].lpvoid,
                                               InputParms[iParm+1].lpdword))
                        {
                            status = WN_BAD_POINTER;
                            __leave;
                        }

                        // Reserve the intermediate buffer area
                        Bytes = ROUND_UP_TO_DWORD(Bytes);
                        OutputParms[iParm].dword = Bytes;
                        OutputParms[iParm+1].dword =
                            (*InputParms[iParm+1].lpdword) * sizeof(WCHAR);

                        // Check for an optional 's' in Instructions
                        if (*(pInstruction+1) == 's')
                        {
                            // CODEWORK: Check for DWORD alignment on RISC?
                            // if (!IS_DWORD_ALIGNED(InputParms[iParm].lpvoid))
                            //  { status = WN_BAD_POINTER; __leave; }

                            // InputParms[iParm+2].dword holds the size of the
                            // fixed-length structure that will go at the start
                            // of the buffer.  We don't want to multiply its
                            // size by sizeof(WCHAR).
                            if (OutputParms[iParm+1].dword/sizeof(WCHAR) <
                                InputParms[iParm+2].dword)
                            {
                                OutputParms[iParm+1].dword /= sizeof(WCHAR);
                            }
                            else
                            {
                                OutputParms[iParm+1].dword -=
                                    InputParms[iParm+2].dword*(sizeof(WCHAR)-1);
                            }
                        }

                        Bytes += OutputParms[iParm+1].dword;
                    }
                    else // Non-NULL pointer, second pass
                    {
                        // Convert the offset to a pointer
                        OutputParms[iParm].lpbyte =
                            *ppBuffer + OutputParms[iParm].dword;
                        ASSERT(IS_DWORD_ALIGNED(OutputParms[iParm].lpbyte));
                    }

                    iParm++;        // iParm+1 was for the buffer size

                    if (*(pInstruction+1) == 's')
                    {
                        pInstruction++;
                        iParm++;    // iParm+2 was for the fixed structure size
                    }
                    break;

                case 'S':
                    //
                    // InputParm is a string to be converted.
                    // A NULL string stays NULL.
                    //
                    if (FIRST_PASS)
                    {
                        ASSERT(iString < MAX_STRINGS_PER_API);
                        Bytes = ROUND_UP_TO_WCHAR(Bytes);
                        status = StringParmToUnicodePass1(
                                        InputParms[iParm].lpcstr,
                                        &AnsiStrings[iString],
                                        &UnicodeStrings[iString],
                                        &Bytes);
                    }
                    else
                    {
                        status = StringParmToUnicodePass2(
                                        &AnsiStrings[iString],
                                        &UnicodeStrings[iString],
                                        *ppBuffer,
                                        &OutputParms[iParm].lpwstr);
                    }

                    if (status != WN_SUCCESS)
                    {
                        __leave;
                    }

                    iString++;
                    break;

                case 'N':
                    //
                    // InputParm is a NETRESOURCEA to be converted, and the
                    // next character in Instructions tells which of its string
                    // fields are to be converted.
                    // NULL strings remain NULL; ignored fields are copied
                    // unchanged.
                    //

                    pInstruction++;

                    if (InputParms[iParm].lpNetResA == NULL)
                    {
                        // A null netresource stays null
                        OutputParms[iParm].lpNetResW = NULL;
                        break;
                    }

                    {
                        // First deal with the fixed-size part of the structure.
                        const NETRESOURCEA *pNetResA =
                                    InputParms[iParm].lpNetResA;
                        NETRESOURCEW *pNetResW;

                        if (FIRST_PASS)
                        {
                            // Reserve space for the NETRESOURCEW
                            Bytes = ROUND_UP_TO_DWORD(Bytes);
                            OutputParms[iParm].dword = Bytes;
                            Bytes += sizeof(NETRESOURCEW);
                            ASSERT(IS_WCHAR_ALIGNED(Bytes));
                        }
                        else
                        {
                            // Copy fixed-size fields and NULL pointers
                            pNetResW = (NETRESOURCEW *)
                                        (*ppBuffer + OutputParms[iParm].dword);
                            ASSERT(IS_DWORD_ALIGNED(pNetResW));
                            RtlCopyMemory(pNetResW, pNetResA, sizeof(NETRESOURCEA));

                            OutputParms[iParm].lpNetResW = pNetResW;
                        }

                        // Next add each non-null string specified in the
                        // field mask.
                        CHAR FieldMask = *pInstruction;
                        ASSERT(FieldMask != 0);

                        for (ULONG iField = 0;
                             iField < NUMBER_OF_NETRESFIELD;
                             iField++)
                        {
                            if ((FieldMask >> iField) & 1)
                            {
                                if (FIRST_PASS)
                                {
                                    ASSERT(iString < MAX_STRINGS_PER_API);
                                    status = StringParmToUnicodePass1(
                                                pNetResA->*NRAField[iField],
                                                &AnsiStrings[iString],
                                                &UnicodeStrings[iString],
                                                &Bytes);
                                }
                                else
                                {
                                    status = StringParmToUnicodePass2(
                                                &AnsiStrings[iString],
                                                &UnicodeStrings[iString],
                                                *ppBuffer,
                                                &(pNetResW->*NRWField[iField]));
                                }

                                if (status != WN_SUCCESS)
                                {
                                    __leave;
                                }

                                iString++;
                            }
                        }
                    }
                    break;

                default:
                    ASSERT(0);
                }
            }

            if (FIRST_PASS)
            {
                //
                // Actually allocate the space for the Unicode parameters
                //
                *ppBuffer = (LPBYTE) LocalAlloc(0, Bytes);
                if (*ppBuffer == NULL)
                {
                    status = GetLastError();
                    MPR_LOG2(ERROR,
                             "InputParmsToUnicode: LocalAlloc for %lu bytes failed, %lu\n",
                             Bytes, status);
                    __leave;
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
#if DBG == 1
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION)
        {
            MPR_LOG(ERROR,"InputParmsToUnicode: Unexpected Exception %#lx\n",status);
        }
#endif
        status = WN_BAD_POINTER;
    }

    return status;
}



DWORD
StringParmToUnicodePass1 (
    IN      LPCSTR          StringParm,
    OUT     PANSI_STRING    AnsiString,
    OUT     PUNICODE_STRING UnicodeString,
    IN OUT  PULONG          BufferOffset
    )
/*++

Routine Description:

    Helper function for InputParmsToUnicode.

--*/
{
    RtlInitAnsiString( AnsiString, StringParm );

    if (StringParm == NULL)
    {
        return WN_SUCCESS;
    }

    // Save the offset to the memory for this Unicode string, to be converted
    // to a pointer after the memory is allocated
    ULONG UnicodeLength = RtlAnsiStringToUnicodeSize( AnsiString );
    if (UnicodeLength > MAXUSHORT)
    {
        MPR_LOG(ERROR,
                "Unicode size of Ansi string parm is %lu, exceeds MAXUSHORT\n",
                UnicodeLength);
        return WN_BAD_VALUE;
    }
    UnicodeString->Buffer = (LPWSTR) UlongToPtr(*BufferOffset);
    UnicodeString->MaximumLength = (USHORT) UnicodeLength;

    *BufferOffset = ROUND_UP_TO_DWORD(*BufferOffset + UnicodeLength);

    return WN_SUCCESS;
}


DWORD
StringParmToUnicodePass2 (
    IN OUT  PANSI_STRING    AnsiString,
    OUT     PUNICODE_STRING UnicodeString,
    IN      const BYTE *    BufferStart,
    OUT     LPWSTR *        Result
    )
/*++

Routine Description:

    Helper function for InputParmsToUnicode.

--*/
{
    if (AnsiString->Buffer == NULL)
    {
        *Result = NULL;
        // NOTE: the UnicodeString is not initialized in this case
        return WN_SUCCESS;
    }

    // Convert the previously stored buffer offset into a pointer
    UnicodeString->Buffer = (LPWSTR)
        (BufferStart + (ULONG_PTR) UnicodeString->Buffer);
    ASSERT(IS_WCHAR_ALIGNED(UnicodeString->Buffer));

    // Convert the string to Unicode
    NTSTATUS ntstatus =
        RtlAnsiStringToUnicodeString(UnicodeString, AnsiString, FALSE);
    if (!NT_SUCCESS(ntstatus))
    {
        MPR_LOG(ERROR, "RtlAnsiStringToUnicodeString failed %#lx\n", ntstatus);
        return RtlNtStatusToDosError(ntstatus);
    }
    *Result = UnicodeString->Buffer;

    return WN_SUCCESS;
}



DWORD
OutputBufferToAnsi(
    IN  char        BufferFormat,
    IN  LPBYTE      SourceBuffer,
    OUT LPVOID      AnsiBuffer,
    IN OUT LPDWORD  pcbBufferSize
    )
/*++

Routine Description:

    This function converts the data in the result buffer that was returned
    from a Unicode API into Ansi and stores it in the Ansi caller's result
    buffer. If the caller's buffer isn't large enough it saves the required
    size in *pcbBufferSize and returns WN_MORE_DATA.

    Nearly all the WNet APIs that have output buffers have only a single
    field in the output buffer, so this API takes only a single character,
    rather than a string, for the buffer format.  APIs with more complicated
    output buffers should handle the complexity themselves, by directly
    calling the functions that this function calls.

Arguments:

    BufferFormat - A character indicating the format of the SourceBuffer
        field.  Recognized values are:

        'S' - SourceBuffer contains a Unicode string.  Convert it to Ansi
            and store the Ansi version in AnsiBuffer.

        'N' - SourceBuffer contains a NETRESOURCEW with its associated
            strings.  Convert it to Ansi and store the Ansi version in
            AnsiBuffer.

    SourceBuffer - The output buffer returned from a Unicode API.
        This must not be NULL.

    AnsiBuffer - The output buffer that the caller of the Ansi API supplied.
        This must not be NULL.

    pcbBufferSize - On entry, the size of AnsiBuffer in bytes.  If the
        function returns WN_MORE_DATA, the required size is stored here;
        otherwise this is unmodified.
        This must not be NULL (must be a writeable DWORD pointer).

Return Value:

    WN_SUCCESS - successful.

    WN_MORE_DATA - The buffer specified by AnsiBuffer and pcbBufferSize was
        not large enough to hold the converted data from SourceBuffer.  In
        this case the required buffer size (in bytes) is written to
        *pcbBufferSize.  The contents of AnsiBuffer are undefined (it will
        be partially filled).

History:

    16-Feb-1996     anirudhs    Created.

Notes:

--*/
{
    // Doesn't handle optional parameters for now
    ASSERT(SourceBuffer != NULL &&
           AnsiBuffer != NULL &&
           pcbBufferSize != NULL);

    ANSI_OUT_BUFFER Buf((LPBYTE) AnsiBuffer, *pcbBufferSize);
    DWORD status;

    switch (BufferFormat)
    {
    case 'S':
        status = OutputStringToAnsi((LPCWSTR) SourceBuffer, &Buf);
        break;

    case 'N':
        status = OutputNetResourceToAnsi((NETRESOURCEW *) SourceBuffer, &Buf);
        break;

    default:
        ASSERT(0);
        return ERROR_INVALID_LEVEL;
    }

    //
    // Map the results to the conventions followed by the WNet APIs
    //
    if (status == WN_SUCCESS)
    {
        if (Buf.Overflow())
        {
            *pcbBufferSize = Buf.GetUsage();
            status = WN_MORE_DATA;
        }
    }
    else
    {
        ASSERT(status != WN_MORE_DATA);
    }

    return status;
}



DWORD
OutputStringToAnsi(
    IN  LPCWSTR     UnicodeIn,
    IN OUT ANSI_OUT_BUFFER * Buf
    )
/*++

Routine Description:

    This function converts a Unicode string to Ansi and calculates the number
    of bytes required to store it.  If the caller passes a buffer that has
    enough remaining free space, it stores the Ansi data in the buffer.
    Otherwise it just increments the buffer's space usage by the number of
    bytes required.

Arguments:

    UnicodeIn - A Unicode string to be converted to Ansi.
        This must not be NULL.

    Buf - A structure whose elements are interpreted as follows:

        _Start - Start address of a buffer to contain the Ansi data.
            This buffer must be writeable, or an exception will occur.

        _Size - The total size of the buffer for the Ansi data.

        _Used - On entry, the number of bytes in the buffer that have
            already been used.  The function will begin writing data at
            _Start + _Used and will never write past the total size
            specified by _Size.  If there is not enough room left
            in the buffer it will be partially filled or unmodified.
            On a successful return, _Used is incremented by the number
            of bytes that would be required to store the converted Ansi
            data, whether or not it was actually stored in the buffer.
            (This is done because the WNet APIs need to return the
            required buffer size if the caller's buffer was too small.)

        The use of this structure simplifies the writing of routines that
        use this function and need to convert multiple fields of Unicode
        data.  Callers that need to convert only a single field can use
        OutputBufferToAnsi.

Return Value:

    WN_SUCCESS - successful.  The Ansi data was written to the buffer if
        Buf->_Used <= Buf->_Size.  Otherwise, Buf->_Used was incremented
        without completely writing the data.

    Note that WN_MORE_DATA is never returned.

History:

    16-Feb-1996     anirudhs    Created.

Notes:

--*/
{
    NTSTATUS        ntStatus;
    UNICODE_STRING  unicodeString;
    ANSI_STRING     ansiString;

    ASSERT(UnicodeIn != NULL);      // Doesn't handle optional parameters for now

    //
    // Initialize the string structures
    //
    RtlInitUnicodeString(&unicodeString, UnicodeIn);

    ansiString.Buffer = (PCHAR) Buf->Next();
    ansiString.MaximumLength = (Buf->FreeSpace() > MAXUSHORT ?
                                        MAXUSHORT :
                                        (USHORT) Buf->FreeSpace()
                               );

    //
    // Call the conversion function
    //
    ntStatus = RtlUnicodeStringToAnsiString (
                &ansiString,        // Destination
                &unicodeString,     // Source
                (BOOLEAN)FALSE);    // Don't allocate the destination

    if (NT_SUCCESS(ntStatus))
    {
        // Add on the buffer space we used
        Buf->AddUsed(ansiString.Length + 1);
        ASSERT(! Buf->Overflow());
        return WN_SUCCESS;
    }
    else if (ntStatus == STATUS_BUFFER_OVERFLOW)
    {
        // We couldn't fit the string in the buffer, but still figure out
        // how much buffer space we would have used if we could
        Buf->AddUsed(RtlUnicodeStringToAnsiSize(&unicodeString));
        ASSERT(Buf->Overflow());
        return WN_SUCCESS;
    }
    else
    {
        MPR_LOG(ERROR, "RtlUnicodeStringToAnsiString failed %#lx\n", ntStatus);
        DWORD status = RtlNtStatusToDosError(ntStatus);
        ASSERT(status != WN_MORE_DATA);
        return status;
    }
}



DWORD
OutputNetResourceToAnsi(
    IN  NETRESOURCEW *  lpNetResW,
    IN OUT ANSI_OUT_BUFFER * Buf
    )
/*++

Routine Description:

    This function converts a NETRESOURCEW and its associated Unicode strings
    to Ansi and returns the number of bytes required to store them.  If the
    caller passes a buffer that has enough remaining free space, it stores
    the Ansi data in the buffer.

Arguments:

    lpNetResW - A Unicode net resource to be converted to Ansi.
        This must not be NULL.

    Buf - same as OutputStringToAnsi.

Return Value:

    Same as OutputStringToAnsi.

History:

    16-Feb-1996     anirudhs    Created.

Notes:

--*/
{
    //
    // Copy the fixed-size part of the structure, including NULL pointers,
    // and/or add on the buffer space it would take
    //
    LPNETRESOURCEA lpNetResA = (LPNETRESOURCEA) Buf->Next();
    if (Buf->HasRoomFor(sizeof(NETRESOURCEA)))
    {
        RtlCopyMemory(lpNetResA, lpNetResW, sizeof(NETRESOURCEA));
    }
    Buf->AddUsed(sizeof(NETRESOURCEA));

    //
    // Copy each non-NULL string field,
    // and/or add on the buffer space it would take
    //
    for (DWORD iField = 0;
         iField < NUMBER_OF_NETRESFIELD;
         iField++)
    {
        if (lpNetResW->*NRWField[iField] != NULL)
        {
            // Save a pointer to the Ansi string we are about to create
            // in the Ansi net resource
            lpNetResA->*NRAField[iField] = (LPSTR) Buf->Next();

            // Convert the string
            DWORD status = OutputStringToAnsi(lpNetResW->*NRWField[iField], Buf);
            if (status != WN_SUCCESS)
            {
                ASSERT(status != WN_MORE_DATA);
                return status;
            }
        }
    }

    return WN_SUCCESS;
}



DWORD
OutputStringToAnsiInPlace(
    IN  LPWSTR      UnicodeIn
    )
/*++

Routine Description:

    This function converts a Unicode string to Ansi in place.
    This is the same as OutputStringToAnsi, optimized for in-place conversions.

Arguments:

    UnicodeIn - A Unicode string to be converted to Ansi.
        This may be NULL, in which case the function does nothing.

Return Value:

    WN_SUCCESS - successful.

    Note that WN_MORE_DATA is never returned.

History:

    08-Aug-1996     anirudhs    Created.

Notes:

--*/
{
    NTSTATUS        ntStatus;
    UNICODE_STRING  unicodeString;
    ANSI_STRING     ansiString;

    if (UnicodeIn == NULL)
    {
        return WN_SUCCESS;
    }

    //
    // Initialize the string structures
    //
    RtlInitUnicodeString(&unicodeString, UnicodeIn);

    ansiString.Buffer = (PCHAR) UnicodeIn;
    ansiString.MaximumLength = unicodeString.MaximumLength;

    //
    // Call the conversion function
    //
    ntStatus = RtlUnicodeStringToAnsiString (
                &ansiString,        // Destination
                &unicodeString,     // Source
                (BOOLEAN)FALSE);    // Don't allocate the destination

    ASSERT(ntStatus != STATUS_BUFFER_OVERFLOW);

    if (NT_SUCCESS(ntStatus))
    {
        return WN_SUCCESS;
    }
    else
    {
        MPR_LOG(ERROR, "RtlUnicodeStringToAnsiString failed %#lx\n", ntStatus);
        DWORD status = RtlNtStatusToDosError(ntStatus);
        ASSERT(status != WN_MORE_DATA);
        return status;
    }
}


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


DWORD APIENTRY
WNetGetNetworkInformationA(
    IN  LPCSTR              lpProvider,
    IN OUT LPNETINFOSTRUCT  lpNetInfoStruct
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpcstr = lpProvider; ,
        "S",
        WNetGetNetworkInformationW(UParm[0].lpwstr, lpNetInfoStruct);
        )
}



DWORD APIENTRY
WNetGetProviderNameA(
    IN  DWORD       dwNetType,
    OUT LPSTR       lpProviderName,
    IN OUT LPDWORD  lpBufferSize
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITH_ANSI_OUTPUT(
        2,
            AParm[0].lpvoid  = lpProviderName;
            AParm[1].lpdword = lpBufferSize; ,
        "B",
        WNetGetProviderNameW(dwNetType, UParm[0].lpwstr, lpBufferSize); ,
        OutputBufferToAnsi('S', UParm[0].lpbyte, lpProviderName, lpBufferSize);
        )
}


DWORD
WNetGetProviderTypeA(
    IN  LPCSTR          lpProvider,
    OUT LPDWORD         lpdwNetType
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpcstr = lpProvider; ,
        "S",
        WNetGetProviderTypeW(UParm[0].lpwstr, lpdwNetType);
        )
}



DWORD APIENTRY
WNetAddConnectionA (
     IN LPCSTR   lpRemoteName,
     IN LPCSTR   lpPassword,
     IN LPCSTR   lpLocalName
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[3];
    UNICODE_PARM    UParm[3];

    AParm[0].lpcstr     = lpRemoteName;
    AParm[1].lpcstr     = lpPassword;
    AParm[2].lpcstr     = lpLocalName;

    UParm[1].lpwstr     = NULL;

    status = InputParmsToUnicode("SSS", AParm, UParm, &tempBuffer);

    if (status == WN_SUCCESS)
    {
        status = WNetAddConnectionW(
                        UParm[0].lpwstr,
                        UParm[1].lpwstr,
                        UParm[2].lpwstr
                        );
    }

    MprClearString(UParm[1].lpwstr);

    LocalFree(tempBuffer);

    SET_AND_RETURN(status)
}

DWORD APIENTRY
WNetAddConnection2A (
     IN LPNETRESOURCEA   lpNetResource,
     IN LPCSTR           lpPassword,
     IN LPCSTR           lpUserName,
     IN DWORD            dwFlags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return (WNetUseConnectionA(
                NULL,
                lpNetResource,
                lpPassword,
                lpUserName,
                dwFlags,
                NULL,
                NULL,
                NULL
                ));
}

DWORD APIENTRY
WNetAddConnection3A (
     IN HWND             hwndOwner,
     IN LPNETRESOURCEA   lpNetResource,
     IN LPCSTR           lpPassword,
     IN LPCSTR           lpUserName,
     IN DWORD            dwFlags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return (WNetUseConnectionA(
                hwndOwner,
                lpNetResource,
                lpPassword,
                lpUserName,
                dwFlags,
                NULL,
                NULL,
                NULL
                ));
}



DWORD APIENTRY
WNetUseConnectionA(
    IN  HWND            hwndOwner,
    IN  LPNETRESOURCEA  lpNetResource,
    IN  LPCSTR          lpPassword,
    IN  LPCSTR          lpUserID,
    IN  DWORD           dwFlags,
    OUT LPSTR           lpAccessName OPTIONAL,
    IN OUT LPDWORD      lpBufferSize OPTIONAL,  // Optional only if lpAccessName absent
    OUT LPDWORD         lpResult
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[5];
    UNICODE_PARM    UParm[5];

    AParm[0].lpNetResA  = lpNetResource;
    AParm[1].lpcstr     = lpPassword;
    AParm[2].lpcstr     = lpUserID;
    AParm[3].lpvoid     = lpAccessName;
    AParm[4].lpdword    = lpBufferSize;

    UParm[1].lpwstr     = NULL;

    status = InputParmsToUnicode("N" NETRES_LRP "SSB", AParm, UParm, &tempBuffer);

    if (status == WN_SUCCESS)
    {
        status = WNetUseConnectionW(
                        hwndOwner,
                        UParm[0].lpNetResW,
                        UParm[1].lpwstr,
                        UParm[2].lpwstr,
                        dwFlags,
                        UParm[3].lpwstr,
                        lpBufferSize,
                        lpResult
                        );

        if (status == WN_SUCCESS)
        {
            if (ARGUMENT_PRESENT(lpAccessName))
            {
                //
                // Note: At this point, we know that lpBufferSize is writeable.
                //
                status = OutputBufferToAnsi(
                            'S', UParm[3].lpbyte, lpAccessName, lpBufferSize);
            }
        }
    }

    MprClearString(UParm[1].lpwstr);

    LocalFree(tempBuffer);

    SET_AND_RETURN(status)
}



DWORD APIENTRY
WNetCancelConnection2A (
    IN LPCSTR   lpName,
    IN DWORD    dwFlags,
    IN BOOL     fForce
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpcstr = lpName; ,
        "S",
        WNetCancelConnection2W(UParm[0].lpwstr, dwFlags, fForce);
        )
}

DWORD APIENTRY
WNetCancelConnectionA (
    IN LPCSTR   lpName,
    IN BOOL     fForce
    )

/*++

Routine Description:

    This routine is provided for Win 3.1 compatibility.

Arguments:

Return Value:

--*/
{
    return WNetCancelConnection2A( lpName, CONNECT_UPDATE_PROFILE, fForce ) ;
}

DWORD APIENTRY
WNetGetConnectionA (
    IN      LPCSTR   lpLocalName,
    OUT     LPSTR    lpRemoteName,
    IN OUT  LPDWORD  lpnLength
    )

/*++

Routine Description:

    This function returns the RemoteName that is associated with a
    LocalName (or drive letter).

Arguments:

    lpLocalName - This is a pointer to the string that contains the LocalName.

    lpRemoteName - This is a pointer to the buffer that will contain the
        RemoteName string upon exit.

    lpnLength -  This is a pointer to the size (in characters) of the buffer
        that is to be filled in with the RemoteName string.  It is assumed
        upon entry, that characters are all single byte characters.
        If the buffer is too small and WN_MORE_DATA is returned, the data
        at this location contains buffer size information - in number of
        characters (bytes).  This information indicates how large the buffer
        should be (in bytes) to obtain the remote name.  It is assumed that
        all Unicode characteres translate into DBCS characters.


Return Value:


--*/
{
    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[3];
    UNICODE_PARM    UParm[3];

    AParm[0].lpcstr  = lpLocalName;
    AParm[1].lpvoid  = lpRemoteName;
    AParm[2].lpdword = lpnLength;

    status = InputParmsToUnicode("SB", AParm, UParm, &tempBuffer);

    if (status == WN_SUCCESS)
    {
        status = WNetGetConnectionW(UParm[0].lpwstr, UParm[1].lpwstr, lpnLength);

        if (status == WN_SUCCESS || status == WN_CONNECTION_CLOSED)
        {
            DWORD tempStatus =
                OutputBufferToAnsi('S', UParm[1].lpbyte, lpRemoteName, lpnLength);
            if (tempStatus != WN_SUCCESS)
            {
                status = tempStatus;
            }
        }
    }

    LocalFree(tempBuffer);

    SET_AND_RETURN(status)
}

DWORD APIENTRY
WNetGetConnection2A (
    IN      LPSTR    lpLocalName,
    OUT     LPVOID   lpBuffer,
    IN OUT  LPDWORD  lpnLength
    )

/*++

Routine Description:

    This function returns the RemoteName that is associated with a
    LocalName (or drive letter) and the provider name that made the
    connection.

Arguments:

    lpLocalName - This is a pointer to the string that contains the LocalName.

    lpBuffer - This is a pointer to the buffer that will contain the
    WNET_CONNECTIONINFO structure upon exit.

    lpnLength -  This is a pointer to the size (in characters) of the buffer
        that is to be filled in with the RemoteName string.  It is assumed
        upon entry, that characters are all single byte characters.
        If the buffer is too small and WN_MORE_DATA is returned, the data
        at this location contains buffer size information - in number of
        characters (bytes).  This information indicates how large the buffer
        should be (in bytes) to obtain the remote name.  It is assumed that
        all Unicode characters translate into DBCS characters.


Return Value:


--*/
{
    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[4];
    UNICODE_PARM    UParm[4];

    AParm[0].lpcstr  = lpLocalName;
    AParm[1].lpvoid  = lpBuffer;
    AParm[2].lpdword = lpnLength;
    AParm[3].dword   = sizeof(WNET_CONNECTIONINFO);

    status = InputParmsToUnicode("SBs", AParm, UParm, &tempBuffer);

    if (status == WN_SUCCESS)
    {
        status = WNetGetConnection2W(
                    UParm[0].lpwstr,
                    UParm[1].lpbyte,
                    &UParm[2].dword
                    );

        if (status == WN_SUCCESS || status == WN_CONNECTION_CLOSED)
        {
            ANSI_OUT_BUFFER Buf((LPBYTE) lpBuffer, *lpnLength);

            //
            // Copy the fixed-size part of the structure, including NULL pointers,
            // and/or add on the buffer space it would take
            //
            WNET_CONNECTIONINFOW * pconninfow = (WNET_CONNECTIONINFOW *) UParm[1].lpbyte;
            WNET_CONNECTIONINFOA * pconninfoa = (WNET_CONNECTIONINFOA *) Buf.Next();
            ASSERT(Buf.HasRoomFor(sizeof(WNET_CONNECTIONINFOA)));
            RtlCopyMemory(pconninfoa, pconninfow, sizeof(WNET_CONNECTIONINFOA));
            Buf.AddUsed(sizeof(WNET_CONNECTIONINFOA));

            //
            // Copy each non-NULL string field,
            // and/or add on the buffer space it would take
            //
            DWORD tempStatus = WN_SUCCESS;
            if (pconninfow->lpRemoteName != NULL)
            {
                pconninfoa->lpRemoteName = (LPSTR) Buf.Next();
                tempStatus = OutputStringToAnsi(pconninfow->lpRemoteName, &Buf);
            }

            if (tempStatus == WN_SUCCESS &&
                pconninfow->lpProvider != NULL)
            {
                pconninfoa->lpProvider = (LPSTR) Buf.Next();
                tempStatus = OutputStringToAnsi(pconninfow->lpProvider, &Buf);
            }

            //
            // Map the results to WNet API conventions
            //
            if (tempStatus != WN_SUCCESS)
            {
                status = tempStatus;
            }
            else if (Buf.Overflow())
            {
                *lpnLength = Buf.GetUsage();
                status = WN_MORE_DATA;
            }
        }
        else if (status == WN_MORE_DATA)
        {
            //
            // Adjust the required buffer size for ansi/DBCS.
            //
            // We don't know how many characters will be required so we have to
            // assume the worst case (all characters are DBCS characters).
            //
            *lpnLength = UParm[2].dword;
        }
    }

    LocalFree(tempBuffer);

    SET_AND_RETURN(status)
}



DWORD APIENTRY
WNetGetConnection3A(
    IN  LPCSTR      lpLocalName,
    IN  LPCSTR      lpProviderName OPTIONAL,
    IN  DWORD       dwLevel,
    OUT LPVOID      lpBuffer,
    IN OUT LPDWORD  lpBufferSize    // in bytes
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    // For the only supported level, the output buffer is a DWORD, so no
    // conversion of the output buffer is necessary
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        2,
            AParm[0].lpcstr = lpLocalName;
            AParm[1].lpcstr = lpProviderName; ,
        "SS",
        WNetGetConnection3W(
            UParm[0].lpwstr,
            UParm[1].lpwstr,
            dwLevel,
            lpBuffer,
            lpBufferSize
            );
        )
}



DWORD
WNetGetUniversalNameA (
    IN      LPCSTR  lpLocalPath,
    IN      DWORD   dwInfoLevel,
    OUT     LPVOID  lpBuffer,
    IN OUT  LPDWORD lpBufferSize
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[4];
    UNICODE_PARM    UParm[4];

    DWORD           dwStructSize =
        (dwInfoLevel == UNIVERSAL_NAME_INFO_LEVEL) ? sizeof(UNIVERSAL_NAME_INFO) :
        (dwInfoLevel == REMOTE_NAME_INFO_LEVEL)    ? sizeof(REMOTE_NAME_INFO)    :
        0;

    AParm[0].lpcstr  = lpLocalPath;
    AParm[1].lpvoid  = lpBuffer;
    AParm[2].lpdword = lpBufferSize;
    AParm[3].dword   = dwStructSize;

    status = InputParmsToUnicode("SBs", AParm, UParm, &tempBuffer);

    if (status == WN_SUCCESS)
    {
        status = WNetGetUniversalNameW(
                    UParm[0].lpwstr,
                    dwInfoLevel,
                    UParm[1].lpbyte,
                    &UParm[2].dword
                    );

        if (status == WN_SUCCESS || status == WN_CONNECTION_CLOSED)
        {
            DWORD tempStatus = WN_SUCCESS;
            ANSI_OUT_BUFFER Buf((LPBYTE) lpBuffer, *lpBufferSize);

            //
            // Copy the fixed-size part of the structure, including NULL pointers,
            // and/or add on the buffer space it would take
            //
            ASSERT(Buf.HasRoomFor(dwStructSize));
            RtlCopyMemory(Buf.Next(), UParm[1].lpbyte, dwStructSize);

            if (dwInfoLevel == REMOTE_NAME_INFO_LEVEL)
            {
                // -----------------------------------
                // REMOTE_NAME_INFO_LEVEL
                // -----------------------------------

                LPREMOTE_NAME_INFOW pRemoteNameInfoW =
                                    (LPREMOTE_NAME_INFOW) UParm[1].lpbyte;
                LPREMOTE_NAME_INFOA pRemoteNameInfoA =
                                    (LPREMOTE_NAME_INFOA) Buf.Next();
                Buf.AddUsed(dwStructSize);

                //
                // Convert the returned Unicode string and string size back to
                // ansi.
                //
                if (pRemoteNameInfoW->lpUniversalName != NULL)
                {
                    pRemoteNameInfoA->lpUniversalName = (LPSTR) Buf.Next();
                    tempStatus = OutputStringToAnsi(pRemoteNameInfoW->lpUniversalName, &Buf);
                }

                if (tempStatus == WN_SUCCESS && pRemoteNameInfoW->lpConnectionName != NULL)
                {
                    pRemoteNameInfoA->lpConnectionName = (LPSTR) Buf.Next();
                    tempStatus = OutputStringToAnsi(pRemoteNameInfoW->lpConnectionName, &Buf);
                }

                if (tempStatus == WN_SUCCESS && pRemoteNameInfoW->lpRemainingPath != NULL)
                {
                    pRemoteNameInfoA->lpRemainingPath = (LPSTR) Buf.Next();
                    tempStatus = OutputStringToAnsi(pRemoteNameInfoW->lpRemainingPath, &Buf);
                }
            }
            else
            {
                // -----------------------------------
                // Must be UNIVERSAL_NAME_INFO_LEVEL
                // -----------------------------------
                ASSERT(dwInfoLevel == UNIVERSAL_NAME_INFO_LEVEL);

                LPUNIVERSAL_NAME_INFOW pUniNameInfoW =
                                    (LPUNIVERSAL_NAME_INFOW) UParm[1].lpbyte;
                LPUNIVERSAL_NAME_INFOA pUniNameInfoA =
                                    (LPUNIVERSAL_NAME_INFOA) Buf.Next();
                Buf.AddUsed(dwStructSize);

                //
                // Convert the returned Unicode string and string size back to
                // ansi.
                //
                if (pUniNameInfoW->lpUniversalName != NULL)
                {
                    pUniNameInfoA->lpUniversalName = (LPSTR) Buf.Next();
                    tempStatus = OutputStringToAnsi(pUniNameInfoW->lpUniversalName, &Buf);
                }
            }

            //
            // Map the results to WNet API conventions
            //
            if (tempStatus != WN_SUCCESS)
            {
                status = tempStatus;
            }
            else if (Buf.Overflow())
            {
                *lpBufferSize = Buf.GetUsage();
                status = WN_MORE_DATA;
            }
        }
        else if (status == WN_MORE_DATA)
        {
            //
            // Adjust the required buffer size for ansi/DBCS.
            //
            // We don't know how many characters will be required so we have to
            // assume the worst case (all characters are DBCS characters).
            //
            *lpBufferSize = UParm[2].dword;
        }
    }

    LocalFree(tempBuffer);

    SET_AND_RETURN(status)
}



DWORD APIENTRY
WNetSetConnectionA(
    IN  LPCSTR    lpName,
    IN  DWORD     dwProperties,
    IN OUT LPVOID pvValues
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    //
    // pvValues points to various types of structures depending on the value
    // of dwProperties.
    // Currently there is only one valid value for dwProperties, and its
    // corresponding pvValues points to a DWORD, so we don't need to worry
    // about converting pvValues to Unicode.
    //
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpcstr = lpName; ,
        "S",
        WNetSetConnectionW(UParm[0].lpwstr, dwProperties, pvValues);
        )
}



DWORD APIENTRY
MultinetGetConnectionPerformanceA(
    IN  LPNETRESOURCEA          lpNetResource,
    OUT LPNETCONNECTINFOSTRUCT  lpNetConnectInfoStruct
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpNetResA = lpNetResource; ,
        "N" NETRES_LRP,
        MultinetGetConnectionPerformanceW(
                        UParm[0].lpNetResW,
                        lpNetConnectInfoStruct);
        )
}



DWORD APIENTRY
WNetOpenEnumA (
    IN  DWORD           dwScope,
    IN  DWORD           dwType,
    IN  DWORD           dwUsage,
    IN  LPNETRESOURCEA  lpNetResource,
    OUT LPHANDLE        lphEnum
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpNetResA = lpNetResource; ,
        "N" NETRES_RP,
        WNetOpenEnumW(dwScope, dwType, dwUsage, UParm[0].lpNetResW, lphEnum);
        )
}

DWORD APIENTRY
WNetEnumResourceA (
    IN      HANDLE  hEnum,
    IN OUT  LPDWORD lpcCount,
    OUT     LPVOID  lpBuffer,
    IN OUT  LPDWORD lpBufferSize
    )

/*++

Routine Description:

    This function calls the unicode version of WNetEnumResource and
    then converts the strings that are returned into ansi strings.
    Since the user provided buffer is used to contain the unicode strings,
    that buffer should be allocated with the size of unicode strings
    in mind.

Arguments:


Return Value:


--*/
{
    DWORD status = WNetEnumResourceW(
                        hEnum,
                        lpcCount,
                        lpBuffer,
                        lpBufferSize);

    if (status == WN_SUCCESS)
    {
        //
        // The output buffer contains an array of NETRESOURCEWs, plus strings.
        // Convert the Unicode strings pointed to by these NETRESOURCEWs
        // to Ansi strings, in place.
        //
        LPNETRESOURCEW lpNetResW = (LPNETRESOURCEW) lpBuffer;
        for (DWORD i=0; i<*lpcCount; i++, lpNetResW++)
        {
            for (UINT iField = 0;
                 iField < NUMBER_OF_NETRESFIELD;
                 iField++)
            {
                if (lpNetResW->*NRWField[iField] != NULL)
                {
                    status = OutputStringToAnsiInPlace(
                                    lpNetResW->*NRWField[iField]);

                    if (status != WN_SUCCESS)
                    {
                        MPR_LOG0(ERROR,"WNetEnumResourceA: Couldn't convert all structs\n");
                        status = WN_SUCCESS;
                        *lpcCount = i;
                        break; // breaks out of both loops
                    }
                }
            }
        }
    }

    SET_AND_RETURN(status)
}



DWORD APIENTRY
WNetGetResourceInformationA(
    IN      LPNETRESOURCEA  lpNetResource,
    OUT     LPVOID          lpBuffer,
    IN OUT  LPDWORD         lpBufferSize,
    OUT     LPSTR *         lplpSystem
    )
{
    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[4];
    UNICODE_PARM    UParm[4];

    AParm[0].lpNetResA  = lpNetResource;
    AParm[1].lpvoid     = lpBuffer;
    AParm[2].lpdword    = lpBufferSize;
    AParm[3].dword      = sizeof(NETRESOURCE);

    status = InputParmsToUnicode("N" NETRES_RP "Bs", AParm, UParm, &tempBuffer);

    if (status == WN_SUCCESS)
    {
        status = WNetGetResourceInformationW(
                    UParm[0].lpNetResW,
                    UParm[1].lpbyte,
                    &UParm[2].dword,
                    (LPWSTR *) lplpSystem
                    );

        if (status == WN_SUCCESS)
        {
            ANSI_OUT_BUFFER Buf((LPBYTE) lpBuffer, *lpBufferSize);

            //
            // Convert the Unicode netresource returned to Ansi
            //
            status = OutputNetResourceToAnsi(UParm[1].lpNetResW, &Buf);

            if (status == WN_SUCCESS)
            {
                //
                // Convert the Unicode string (*lplpSystem) returned to Ansi
                //
                LPWSTR lpSystemW = * (LPWSTR *) lplpSystem;
                if (lpSystemW != NULL)
                {
                    *lplpSystem = (LPSTR) Buf.Next();
                    status = OutputStringToAnsi(lpSystemW, &Buf);
                }
            }

            //
            // Map the results to WNet API conventions
            //
            if (status == WN_SUCCESS && Buf.Overflow())
            {
                *lpBufferSize = Buf.GetUsage();
                status = WN_MORE_DATA;
            }
        }
        else if (status == WN_MORE_DATA)
        {
            //
            // Adjust the required buffer size for ansi/DBCS.
            //
            // We don't know how many characters will be required so we have to
            // assume the worst case (all characters are DBCS characters).
            //
            *lpBufferSize = UParm[2].dword;
        }
    }

    LocalFree(tempBuffer);

    SET_AND_RETURN(status)
}


DWORD APIENTRY
WNetGetResourceParentA(
    IN      LPNETRESOURCEA  lpNetResource,
    OUT     LPVOID          lpBuffer,
    IN OUT  LPDWORD         lpBufferSize
    )
{
    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[4];
    UNICODE_PARM    UParm[4];

    AParm[0].lpNetResA  = lpNetResource;
    AParm[1].lpvoid     = lpBuffer;
    AParm[2].lpdword    = lpBufferSize;
    AParm[3].dword      = sizeof(NETRESOURCE);

    status = InputParmsToUnicode("N" NETRES_RP "Bs", AParm, UParm, &tempBuffer);

    if (status == WN_SUCCESS)
    {
        status = WNetGetResourceParentW(
                    UParm[0].lpNetResW,
                    UParm[1].lpbyte,
                    &UParm[2].dword
                    );

        if (status == WN_SUCCESS)
        {
            //
            // Convert the Unicode netresource returned to Ansi
            //
            status = OutputBufferToAnsi('N', UParm[1].lpbyte, lpBuffer, lpBufferSize);
        }
        else if (status == WN_MORE_DATA)
        {
            //
            // Adjust the required buffer size for ansi/DBCS.
            //
            // We don't know how many characters will be required so we have to
            // assume the worst case (all characters are DBCS characters).
            //
            *lpBufferSize = UParm[2].dword;
        }
    }

    LocalFree(tempBuffer);

    SET_AND_RETURN(status)
}



DWORD APIENTRY
WNetGetUserA (
    IN      LPCSTR    lpName,
    OUT     LPSTR     lpUserName,
    IN OUT  LPDWORD   lpnLength
    )

/*++

Routine Description:

    This function retreives the current default user name or the username
    used to establish a network connection.

Arguments:

    lpName - Points to a null-terminated string that specifies either the
        name or the local device to return the user name for, or a network
        name that the user has made a connection to.  If the pointer is
        NULL, the name of the current user is returned.

    lpUserName - Points to a buffer to receive the null-terminated
        user name.

    lpnLength - Specifies the size (in characters) of the buffer pointed
        to by the lpUserName parameter.  If the call fails because the
        buffer is not big enough, this location is used to return the
        required buffer size.

Return Value:


--*/
{
    ANSI_API_WITH_ANSI_OUTPUT(
        3,
            AParm[0].lpcstr  = lpName;
            AParm[1].lpvoid  = lpUserName;
            AParm[2].lpdword = lpnLength; ,
        "SB",
        WNetGetUserW(UParm[0].lpwstr, UParm[1].lpwstr, lpnLength); ,
        OutputBufferToAnsi('S', UParm[1].lpbyte, lpUserName, lpnLength);
        )
}


DWORD
RestoreConnectionA0 (
    IN  HWND    hwnd,
    IN  LPSTR   lpDevice
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpcstr = lpDevice; ,
        "S",
        WNetRestoreConnectionW(hwnd, UParm[0].lpwstr);
        )
}


DWORD
RestoreConnection2A0 (
    IN  HWND    hwnd,
    IN  LPSTR   lpDevice,
    IN  DWORD   dwFlags,
    OUT BOOL*   pfReconnectFailed
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpcstr = lpDevice; ,
        "S",
        WNetRestoreConnection2W(hwnd, UParm[0].lpwstr, dwFlags, pfReconnectFailed);
        )
}


DWORD
WNetGetDirectoryTypeA (
    IN  LPSTR   lpName,
    OUT LPINT   lpType,
    IN  BOOL    bFlushCache
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpcstr = lpName; ,
        "S",
        WNetGetDirectoryTypeW(UParm[0].lpwstr, lpType, bFlushCache);
        )
}

DWORD
WNetDirectoryNotifyA (
    IN  HWND    hwnd,
    IN  LPSTR   lpDir,
    IN  DWORD   dwOper
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpcstr = lpDir; ,
        "S",
        WNetDirectoryNotifyW(hwnd, UParm[0].lpwstr, dwOper);
        )
}

DWORD APIENTRY
WNetGetLastErrorA (
    OUT LPDWORD    lpError,
    OUT LPSTR      lpErrorBuf,
    IN  DWORD      nErrorBufSize,
    OUT LPSTR      lpNameBuf,
    IN  DWORD      nNameBufSize
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DWORD           status;

    //
    // We re-use the Ansi buffers for the Unicode API.
    // There are no input Ansi parameters to convert to Unicode.
    //
    // Call the Unicode version of the function.
    // Note: The sizes for the buffers that are passed in assume that
    // the returned unicode strings will return DBCS characters.
    //
    status = WNetGetLastErrorW(
                lpError,
                (LPWSTR) lpErrorBuf,
                nErrorBufSize / sizeof(WCHAR),
                (LPWSTR) lpNameBuf,
                nNameBufSize / sizeof(WCHAR)
                );

    //
    // Convert the returned strings to Ansi, in place.
    // There should be no buffer overflow.
    //
    if (status == WN_SUCCESS)
    {
        status = OutputStringToAnsiInPlace((LPWSTR) lpErrorBuf);

        if (status == WN_SUCCESS)
        {
            status = OutputStringToAnsiInPlace((LPWSTR) lpNameBuf);
        }
    }

    SET_AND_RETURN(status)
}



VOID
WNetSetLastErrorA(
    IN DWORD   err,
    IN LPSTR   lpError,
    IN LPSTR   lpProviders
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[2];
    UNICODE_PARM    UParm[2];

    AParm[0].lpcstr = lpError;
    AParm[1].lpcstr = lpProviders;

    status = InputParmsToUnicode("SS", AParm, UParm, &tempBuffer);

    if (status != WN_SUCCESS)
    {
        UParm[0].lpwstr = NULL;
        UParm[1].lpwstr = NULL;
    }

    WNetSetLastErrorW(err, UParm[0].lpwstr, UParm[1].lpwstr);

    LocalFree(tempBuffer);

    return;
}



DWORD APIENTRY
MultinetGetErrorTextA(
    OUT LPSTR       lpErrorTextBuf OPTIONAL,
    IN OUT LPDWORD  lpnErrorBufSize OPTIONAL,
    OUT LPSTR       lpProviderNameBuf OPTIONAL,
    IN OUT LPDWORD  lpnNameBufSize OPTIONAL
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    // CODEWORK: This could be simplified by re-using the Unicode buffers,
    // like WNetGetLastErrorA.

    DWORD           status;
    LPBYTE          tempBuffer = NULL;
    ANSI_PARM       AParm[4];
    UNICODE_PARM    UParm[4];

    AParm[0].lpvoid     = lpErrorTextBuf;
    AParm[1].lpdword    = lpnErrorBufSize;
    AParm[2].lpvoid     = lpProviderNameBuf;
    AParm[3].lpdword    = lpnNameBufSize;

    status = InputParmsToUnicode("BB", AParm, UParm, &tempBuffer);

    if (status == WN_SUCCESS)
    {
        // Remember the sizes before calling the function
        DWORD nErrorBufSize;
        DWORD nNameBufSize;
        if (ARGUMENT_PRESENT(lpErrorTextBuf))
        {
            nErrorBufSize = *lpnErrorBufSize;
        }
        if (ARGUMENT_PRESENT(lpProviderNameBuf))
        {
            nNameBufSize  = *lpnNameBufSize;
        }

        status = MultinetGetErrorTextW(
                        UParm[0].lpwstr,
                        lpnErrorBufSize,
                        UParm[2].lpwstr,
                        lpnNameBufSize
                        );

        if (status == WN_SUCCESS || status == WN_MORE_DATA)
        {
            if (ARGUMENT_PRESENT(lpErrorTextBuf) &&
                nErrorBufSize == *lpnErrorBufSize)
            {
                // The Unicode API must have written the error text buffer
                DWORD status2 = OutputBufferToAnsi(
                                      'S',
                                      UParm[0].lpbyte,
                                      lpErrorTextBuf,
                                      lpnErrorBufSize);

                if (status2 != WN_SUCCESS)
                {
                    status = status2;
                }
            }
        }

        if (status == WN_SUCCESS || status == WN_MORE_DATA)
        {
            if (ARGUMENT_PRESENT(lpProviderNameBuf) &&
                nNameBufSize  == *lpnNameBufSize)
            {
                // The Unicode API must have written the provider name buffer
                DWORD status2 = OutputBufferToAnsi(
                                      'S',
                                      UParm[2].lpbyte,
                                      lpProviderNameBuf,
                                      lpnNameBufSize);

                if (status2 != WN_SUCCESS)
                {
                    status = status2;
                }
            }
        }
    }

    LocalFree(tempBuffer);

    SET_AND_RETURN(status)
}



DWORD
WNetPropertyDialogA (
    HWND  hwndParent,
    DWORD iButton,
    DWORD nPropSel,
    LPSTR lpszName,
    DWORD nType
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITHOUT_ANSI_OUTPUT(
        1,
        AParm[0].lpcstr = lpszName; ,
        "S",
        WNetPropertyDialogW(hwndParent, iButton, nPropSel, UParm[0].lpwstr, nType);
        )
}


DWORD
WNetGetPropertyTextA (
    IN  DWORD iButton,
    IN  DWORD nPropSel,
    IN  LPSTR lpszName,
    OUT LPSTR lpszButtonName,
    IN  DWORD nButtonNameLen,
    IN  DWORD nType
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITH_ANSI_OUTPUT(
        3,
            AParm[0].lpcstr  = lpszName;
            AParm[1].lpvoid  = lpszButtonName;
            AParm[2].lpdword = &nButtonNameLen; ,
        "SB",
        WNetGetPropertyTextW(iButton, nPropSel, UParm[0].lpwstr,
            UParm[1].lpwstr, nButtonNameLen, nType); ,
        OutputBufferToAnsi('S', UParm[1].lpbyte, lpszButtonName, &nButtonNameLen);
        )
}



DWORD APIENTRY
WNetFormatNetworkNameA(
    IN     LPCSTR   lpProvider,
    IN     LPCSTR   lpRemoteName,
    OUT    LPSTR    lpFormattedName,
    IN OUT LPDWORD  lpnLength,         // In characters!
    IN     DWORD    dwFlags,
    IN     DWORD    dwAveCharPerLine
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ANSI_API_WITH_ANSI_OUTPUT(
        4,
            AParm[0].lpcstr  = lpProvider;
            AParm[1].lpcstr  = lpRemoteName;
            AParm[2].lpvoid  = lpFormattedName;
            AParm[3].lpdword = lpnLength; ,
        "SSB",
        WNetFormatNetworkNameW(
                    UParm[0].lpwstr,
                    UParm[1].lpwstr,
                    UParm[2].lpwstr,
                    lpnLength,
                    dwFlags,
                    dwAveCharPerLine
                    ); ,
        OutputBufferToAnsi('S', UParm[2].lpbyte, lpFormattedName, lpnLength);
        )
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\mprdbg.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mprdbg.h

Abstract:

    Contains definitions used in debugging the messenger service.

Author:

    Dan Lafferty    (danl)  07-Oct-1991

Environment:

    User Mode -Win32

Revision History:

    22-Jul-1992     Danl
        Added different debug macros based on the number of parameters.
        Make the macros resolve to nothing when DBG is not defined.

    24-May-1999     jschwart
        Have debug macros print out process number

--*/

#ifndef _MPRDBG_INCLUDED
#define _MPRDBG_INCLUDED

//
// Information levels used in switch statements.
//
#define LEVEL_0     0L
#define LEVEL_1     1L
#define LEVEL_2     2L

//
// Debug macros and constants.
//
#if DBG

#define DEBUG_STATE 1
#define STATIC

#else

#define DEBUG_STATE 0
#define STATIC static

#endif

extern DWORD    MprDebugLevel;

//
// The following allow debug print syntax to look like:
//
//   MPR_LOG(TRACE, "An error occured %x\n",status)
//

#if DBG

//
// debugging macros.
//
#define MPR_LOG0(level,string)                  \
    if( MprDebugLevel & (DEBUG_ ## level)){     \
        (VOID) DbgPrint("[MPR] %lx: " string, GetCurrentProcessId()); \
    }
#define MPR_LOG1(level,string,var)              \
    if( MprDebugLevel & (DEBUG_ ## level)){     \
        (VOID) DbgPrint("[MPR] %lx: " string,GetCurrentProcessId(),var); \
    }
#define MPR_LOG2(level,string,var1,var2)        \
    if( MprDebugLevel & (DEBUG_ ## level)){     \
        (VOID) DbgPrint("[MPR] %lx: " string,GetCurrentProcessId(),var1,var2); \
    }
#define MPR_LOG3(level,string,var1,var2,var3)   \
    if( MprDebugLevel & (DEBUG_ ## level)){     \
        (VOID) DbgPrint("[MPR] %lx: " string,GetCurrentProcessId(),var1,var2,var3); \
    }
#define MPR_LOG(level,string,var)               \
    if( MprDebugLevel & (DEBUG_ ## level)){     \
        (VOID) DbgPrint("[MPR] %lx: " string,GetCurrentProcessId(),var);   \
    }

#else  // DBG

#define MPR_LOG0(level,string)
#define MPR_LOG1(level,string,var)
#define MPR_LOG2(level,string,var1,var2)
#define MPR_LOG3(level,string,var1,var2,var3)
#define MPR_LOG(level,string,var)

#endif // DBG



#define DEBUG_NONE      0x00000000
#define DEBUG_ERROR     0x00000001
#define DEBUG_TRACE     0x00000002      // Miscellaneous trace info
#define DEBUG_LOCKS     0x00000004      // Multi-thread data locks
#define DEBUG_PS        0x00000008      // Thread and Process information
#define DEBUG_RESTORE   0x00000010      // Restore Connection information
#define DEBUG_CNOTIFY   0x00000020      // Connection Notify information
#define DEBUG_ANSI      0x00000040      // Ansi API thunks
#define DEBUG_ROUTE     0x00000080      // Routing of calls among providers

#define DEBUG_ALL       0xffffffff

#endif // _MPRDBG_INCLUDED

//
// Function Prototypes
//

VOID
PrintKeyInfo(
    HKEY  key);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\mprlock.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mprlock.cxx

Abstract:

    Contains code for the MPR provider database manager.  This file
    contains the following classes:
        CMPRProviderLock

Author:

    Jonathan Schwartz (jschwart)    19-May-1999

Environment:

    User Mode -Win32

Revision History:

    19-May-1999     jschwart
        Created, converted from \nt\private\windows\screg\sc\server\lock.cxx.

--*/

//
// INCLUDES
//

#include "precomp.hxx"

//
// Macros
//
#define LOCK_LOG(string)    MPR_LOG3(LOCKS, " %s" string " level = %ld\n", \
                                        _ShortName, _Name, CurrentLevel())

//
// Globals
//
CProviderLock    MPRProviderLock;


/*************************************************************************/
/* CCountingResource methods                                             */
/*************************************************************************/

#if DBG
void
CCountingResource::GetShared()
{
    LOCK_LOG(" Asking for %s lock shared...");
    ASSERT(!HaveExclusive());
    RtlAcquireResourceShared(&_Lock, TRUE);
    SetCurrentLevel(CurrentLevel() + 1);
    LOCK_LOG("+Acquired %s lock shared,");
}

void
CCountingResource::GetExclusive()
{
    LOCK_LOG(" Asking for %s lock exclusive...");
    ASSERT(!Have() || HaveExclusive());
    RtlAcquireResourceExclusive(&_Lock, TRUE);
    SetCurrentLevel(CurrentLevel() - 1);
    LOCK_LOG("+Acquired %s lock exclusive,");
}

void
CCountingResource::Release()
{
    LOCK_LOG("-Releasing %s lock...");
    ASSERT(Have());
    RtlReleaseResource( &_Lock );
    if (CurrentLevel() > 0)
    {
        SetCurrentLevel(CurrentLevel() - 1);
    }
    else
    {
        SetCurrentLevel(CurrentLevel() + 1);
    }
    LOCK_LOG(" Released %s lock,");
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\mprinit.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MPRINIT.CXX

Abstract:

    Contains the DLL initialization routine for the Mutiple-Provider
    Router.  The following are names of functions in this file:

        MprDllInit
        MprCheckProviders
        MprLevel1Init
        MprLevel2Init
        MprProcessDetach
        GetProviderCapabilities
        MprFreeGlobalProviderInfo
        MprMakeServiceKeyName
        MprGetOrderedList
        MprGetNumProviders
        MprExtractProviderInfo

    The router distinguishes between Providers and ActiveProviders.  It
    maintains global information about GlobalNumProviders and
    GlobalNumActiveProviders.  The two counts can be distinguished in the
    following ways:

    GlobalNumProviders - This determines the size of the provider database
        that mpr maintains.  This count reflects the number of providers for
        which we were able to obtain registry information.  A provider is
        added to the list if we are able to obtain its name and the
        name of its dll routine.

    GlobalNumActiveProviders - A provider becomes active when we are able
        to successfully load the dll, and obtain at least one entry point
        for it.


Author:

    Dan Lafferty (danl) 6-Oct-1991

Environment:

    User Mode - Win32

Notes:


Revision History:

    05-May-1999     jschwart
        Make provider addition/removal dynamic

    09-Aug-1996     AnirudhS
        Disabled thread library calls, since they cause extra paging and
        are 100% useless.  Fixed memory leak of error records on DLL unload.

    02-Mar-1995     AnirudhS
        Add test for WNNC_ENUM_CONTEXT capability.

    09-Aug-1994     Danl
        Only do PROCESS_DETACH cleanup work if the PROCESS_DETACH occurs
        because of a FreeLibrary.

    01-Mar-1994     Danl
        Created a seperate location for the Credential Managers GetCaps()
        function.  This way if a provider has both a credential manager
        dll and a network dll, we will be able to direct calls to the
        correct GetCaps() function.

    08-Apr-1993     Danl
        MprLevel1Init:  Created a tempOrderedString which will be used
        for incrementing through the buffer.  This way we can Free
        orderedString because it still points to the beginning of the buffer.

    24-Nov-1992     Danl
        Modified many things to allow for initialization to occur on
        first call rather than at DLL initialization time.  Also coded
        for the future possibility of Authentication Providers.

    02-Nov-1992     Danl
        Allow MPR to continue operation even if there are no providers, or
        if the network is not installed and provider info is not available
        in the registry.  Removed MprHack.

    31-Aug-1992     Danl
        Removed use of the list of active providers.  Now all providers
        in the Provider Order list are loaded at init time.

    06-Oct-1991     Danl
        Created

--*/

//
// Includes
//
#include "precomp.hxx"
#include <tstring.h>    // MEMCPY
#include <debugfmt.h>   // FORMAT_LPTSTR
#include "mprres.h"     // IDS_NETROOT
#include "connify.h"    // MprConnectNotifyInit()


//
// Local Function Prototypes
//

BOOL
MprProcessAttach(
    HANDLE DllHandle
    );

BOOL
MprProcessDetach(
    DWORD  dwInitLevel
    );

BOOL
GetProviderCapabilities(
    LPPROVIDER  Provider
    );

VOID
MprFreeGlobalProviderInfo(VOID);

BOOL
MprGetOrderedList(
    HKEY    ControlRootKey,
    LPTSTR  *OrderString
    );

DWORD
MprMakeServiceKeyName(
    IN OUT  LPTSTR  *OrderedNamePtr,
    OUT     LPTSTR  *NameBufferPtr,
    OUT     LPTSTR  *NamePtr
    );

DWORD
MprGetNumProviders(
    LPTSTR  OrderedString
    );

BOOL
MprExtractProviderInfo(
    HKEY        ProviderInfoKey,
    LPPROVIDER  Provider
    );

BOOL
MprInitializeProviderGlobals(
    VOID
    );

BOOL
MprGetLUIDDeviceMapsEnabled(
    PBOOL pResult
    );

//
// Constants
//
#define TEMP_SIZE       256

//
// Some registry path names
//
#define PROVIDER_KEY_NAME   TEXT("control\\NetworkProvider\\active")
#define PROVIDER_ORDER_KEY  TEXT("control\\NetworkProvider\\HwOrder")
#define SERVICES_KEY_NAME   TEXT("services\\")
#define SYSTEM_CONTROL_ROOT TEXT("system\\CurrentControlSet")
#define PROVIDER_PATH       TEXT("\\NetworkProvider")
#define VALUE_PATHNAME      TEXT("ProviderPath")
#define AUTHENT_PATHNAME    TEXT("AuthentProviderPath")
#define VALUE_CLASS         TEXT("Class")

//
// Defines for the DLL's init state
//
#define  MPR_PROVIDERLOCK_CREATED       0x00000001
#define  MPR_INITCRITSEC_CREATED        0x00000002
#define  MPR_ERRORCRITSEC_CREATED       0x00000004
#define  MPR_CACHE_CONSTRUCTED          0x00000008


//
// Global Data Structures
//

    LPPROVIDER          GlobalProviderInfo=NULL;   // A pointer to array of PROVIDER Structures
    DWORD               GlobalNumProviders=0;
    DWORD               GlobalNumActiveProviders=0;
    CRITICAL_SECTION    MprInitCritSec;
    HMODULE             hDLL;
    HANDLE              g_hProvidersChanged;       // Event set on provider addition/deletion
    HKEY                g_hProviderKey;            // Registry key of the provider list

    WCHAR               g_wszEntireNetwork[40];    // "Entire Network" string for top-level enum
    BOOL                g_LUIDDeviceMapsEnabled=FALSE; // LUID device map enabled/disabled

    //
    // GlobalInitLevel is a set of bit flags used to indicate how much
    // initialization work has been done.
    //
    volatile DWORD      GlobalInitLevel = 0;

    DWORD               MprDebugLevel;


extern "C"
BOOL
MprDllInit(
    IN  HINSTANCE   DllHandle,
    IN  DWORD       Reason,
    IN  PCONTEXT    pContext OPTIONAL
    )

/*++

Routine Description:

    This routine reads the registry to determine what network providers are
    available.  It then loads and initializes the Network Providers.  After
    this, a call is made to each of the providers to get a list of
    Capabilities (via WNetGetCaps).

Arguments:

    DllHandle - A handle for the DLL?

    Reason - The reason for which this routine is being called.  This might
        be one of the following:
            DLL_PROCESS_ATTACH
            DLL_THREAD_ATTACH
            DLL_THREAD_DETACH
            DLL_PROCESS_DETACH

    pContext - Pointer to a context structure


Return Value:


Note:


--*/
{
    //
    // We need to keep track of how far initialization went since
    // we may get called with DLL_PROCESS_DETACH if init fails and
    // don't want to clean up uninitialized data
    //
    static DWORD s_dwInitLevel;

    if (Reason == DLL_PROCESS_ATTACH) {

#if DBG == 1
        //
        // Read the debug message level from the registry
        //
        HKEY   MprKey;
        if (MprOpenKey(HKEY_LOCAL_MACHINE,
                   L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Mpr",
                   &MprKey,
                   0))
        {
            MprDebugLevel = (DWORD) MprGetKeyNumberValue(MprKey, L"DebugLevel", 0);

            RegCloseKey(MprKey);
        }
#endif

        //
        // create semaphore used to protect global data (DLL handles and
        // function pointers.
        //
        if ((MprLoadLibSemaphore = CreateSemaphore( NULL,1,1,NULL )) == NULL)
        {
            MPR_LOG1(ERROR,
                     "MprDllInit: CreateSemaphore FAILED %d\n",
                     GetLastError());

            return FALSE ;
        }

        if (!MprInitializeProviderGlobals())
        {
            return FALSE;
        }

        s_dwInitLevel |= MPR_PROVIDERLOCK_CREATED;

        MPR_LOG2(PS,"Process %#lx (%ws) attached to the DLL\n",
                    GetCurrentProcessId(), GetCommandLineW());

        //
        // Save the DLL handle, to be used in LoadString
        //
        hDLL = DllHandle;

        //
        // Create the critical section to synchronize access to global
        // data when doing init on first call.
        //
        InitializeCriticalSection(&MprInitCritSec);
        s_dwInitLevel |= MPR_INITCRITSEC_CREATED;

        //
        // Initialize critical section that protects the Linked list of
        // Error Records.
        //
        InitializeCriticalSection(&MprErrorRecCritSec);
        s_dwInitLevel |= MPR_ERRORCRITSEC_CREATED;

        CRoutedOperation::ConstructCache();
        s_dwInitLevel |= MPR_CACHE_CONSTRUCTED;

        DisableThreadLibraryCalls(DllHandle);
    }
    else if (Reason == DLL_PROCESS_DETACH) {

        //
        // Only do cleanup if detach was due to a FreeLibrary() call.
        // In this case pContext will be NULL.  Otherwise, this gets called
        // because the process is terminating.  We will let the process
        // cleanup code clean up everything.
        //
        if (pContext == NULL) {
            //
            // close handle for semaphore
            //
            CloseHandle(MprLoadLibSemaphore) ;
            MprLoadLibSemaphore = NULL ;

            MPR_LOG(PS,"Process %#lx detached from the DLL\n",GetCurrentProcessId());
            MPR_LOG(TRACE,"******************* CLEAN-UP  ********************\n",0);

            MprProcessDetach(s_dwInitLevel);

            if (s_dwInitLevel & MPR_CACHE_CONSTRUCTED)
            {
                CRoutedOperation::DestroyCache();
            }

            MPR_LOG(TRACE,"***************** CLEAN_UP END  ******************\n",0);
        }
    }
    else if (Reason == DLL_THREAD_ATTACH) {
        // This should never happen
        MPR_LOG2(PS,"Thread %#lx.%#lx attached to the DLL\n",
                    GetCurrentProcessId(), GetCurrentThreadId());
    }
    else if (Reason == DLL_THREAD_DETACH) {
        // This should never happen
        MPR_LOG2(PS,"Thread %#lx.%#lx detached from the DLL\n",
                    GetCurrentProcessId(), GetCurrentThreadId());
    }
    return(TRUE);

}


BOOL
MprInitializeProviderGlobals(
    VOID
    )
{
    g_hProvidersChanged = CreateEvent(NULL,    // Default security
                                      TRUE,    // Manual reset
                                      FALSE,   // Starts out unsignaled
                                      NULL);   // No name

    if (g_hProvidersChanged == NULL)
    {
        MPR_LOG1(ERROR,
                 "MprInitializeProviderGlobals: CreateEvent FAILED %d\n",
                 GetLastError());

        return FALSE;
    }

    //
    // NOTE:  Key handle must be global since RegNotifyChangeKeyValue
    //        fires when the handle is closed (done in MprProcessDetach)
    //
    if (!MprOpenKey(HKEY_LOCAL_MACHINE,
                    SYSTEM_CONTROL_ROOT L"\\" PROVIDER_ORDER_KEY,
                    &g_hProviderKey,
                    0))
    {
        MPR_LOG1(ERROR,
                 "MprInitializeProviderGlobals: MprOpenKey FAILED %d\n",
                 GetLastError());

        return FALSE;
    }

    if (RegNotifyChangeKeyValue(g_hProviderKey,              // Key
                                FALSE,                       // Don't watch subtree
                                REG_NOTIFY_CHANGE_LAST_SET,  // Watch for value changes
                                g_hProvidersChanged,         // Event to signal
                                TRUE)                        // Asynchronous

            != ERROR_SUCCESS)
    {
        //
        // If this call fails, we won't notice provider additions/deletions
        //
        MPR_LOG1(ERROR,
                 "MprInitializeProviderGlobals: RegNotifyChangeKeyValue FAILED %d\n",
                 GetLastError());
    }

    //
    // Check if LUID device maps are Enabled
    //
    MprGetLUIDDeviceMapsEnabled( &g_LUIDDeviceMapsEnabled );

    //
    // Create the lock that restricts access to the provider array
    //
    MPRProviderLock.Initialize("P", "Provider");

    return TRUE;
}


VOID
MprCheckProviders(
    VOID
    )
{
    ASSERT(!MPRProviderLock.Have());

    if (WaitForSingleObject(g_hProvidersChanged, 0) == WAIT_OBJECT_0)
    {
        //
        // The providers have changed -- grab the exclusive lock and
        // check again to avoid a race condition.  Note that there
        // is no need to acquire the MprInitCritsec since an API must
        // always acquire the critsec (via INIT_IF_NECESSARY) AFTER it
        // acquires the shared provider lock.
        //
        CProviderExclusiveLock    PLock;

        if (WaitForSingleObject(g_hProvidersChanged, 0) == WAIT_OBJECT_0)
        {
            //
            // Still set -- this is the first thread here.  Free up the provider
            // info and reset the init level so the next INIT_IF_NECESSARY call
            // will reinitialize the providers as necessary.
            //
            MPR_LOG0(TRACE,
                     "MprCheckProviders: Provider list changed -- reinitializing\n");

            MprDeleteIndexArray();
            MprFreeGlobalProviderInfo();

            GlobalInitLevel = 0;

            //
            // Flush the provider cache
            //
            CRoutedOperation::DestroyCache();
            CRoutedOperation::ConstructCache();

            ResetEvent(g_hProvidersChanged);

            if (RegNotifyChangeKeyValue(g_hProviderKey,              // Key
                                        FALSE,                       // Don't watch subtree
                                        REG_NOTIFY_CHANGE_LAST_SET,  // Watch for value changes
                                        g_hProvidersChanged,         // Event to signal
                                        TRUE)                        // Asynchronous

                    != ERROR_SUCCESS)
            {
                //
                // If this call fails we won't notice provider additions/deletions
                //
                MPR_LOG1(ERROR,
                         "MprCheckProviders: RegNotifyChangeKeyValue FAILED %d\n",
                         GetLastError());
            }
        }
    }
}


DWORD
MprLevel1Init(
    VOID
    )

/*++

Routine Description:

    This function looks into the registry to find the names of the providers
    and their associated DLLs.  A Global table of provider information is
    then allocated (GlobalProviderInfo).  This table is an array of provider
    information structures.  The number of elements in the array is stored
    in GlobalNumProviders.

    If the provider is in the registry ORDERED list, then it is assumed that
    complete provider information is stored in the "services" section of
    the registry for that provider.  This provider information includes such
    things as the pathname for the provider dll, and the provider type.
    The information is stored in the provider structure for use by the
    MprLevel2Init routine.

Arguments:


Return Value:



Note:


--*/
{
    DWORD       status;
    LPPROVIDER  provider;
    DWORD       i;
    HKEY        controlRootKey;
    HKEY        providerInfoKey;
    LPTSTR      orderedString = NULL;
    LPTSTR      tempOrderedString;
    LPTSTR      nameBuffer = NULL;          // system\LanmanRedirector\NetworkProvider
    LPTSTR      providerIdString = NULL;    // points to provider id in nameBuffer
    BOOL        oneInitialized = FALSE;


    EnterCriticalSection(&MprInitCritSec);
    MPR_LOG(TRACE,"******************* LEVEL 1 INIT ********************\n",0);
    //
    // If this level of initialization is already complete, then return.
    //
    if (GlobalInitLevel & FIRST_LEVEL) {
        LeaveCriticalSection(&MprInitCritSec);
        return(WN_SUCCESS);
    }

    //
    // This function had better be called first and only once
    //
    ASSERT(GlobalInitLevel == 0);

    //
    // Get a handle to the "current" services part of the registry
    //

    if(!MprOpenKey(
                HKEY_LOCAL_MACHINE,     // hKey
                SYSTEM_CONTROL_ROOT,    // lpSubKey
                &controlRootKey,        // Newly Opened Key Handle
                DA_READ)) {             // Desired Access

        MPR_LOG(ERROR,"MprLevel1Init: MprOpenKey (System) Error\n",0);
        LeaveCriticalSection(&MprInitCritSec);
        return(WN_NO_NETWORK);
    }
    MPR_LOG2(TRACE,"OpenKey %ws,0x%lx\n ",SYSTEM_CONTROL_ROOT,controlRootKey);

    //
    // Obtain the ordered list information.
    // (the orderedString buffer is allocated here)
    //
    // If this fails, we assume that there are no providers.
    //

    if (!MprGetOrderedList(controlRootKey, &orderedString)) {
        MPR_LOG(ERROR,"Could not get the ordered list of providers\n",0);
        RegCloseKey(controlRootKey);
        LeaveCriticalSection(&MprInitCritSec);
        return(WN_NO_NETWORK);
    }

    MPR_LOG1(TRACE,"ProviderOrderString = %ws\n",orderedString);

    GlobalNumProviders = MprGetNumProviders(orderedString);


    //
    // Allocate the database in which to store Provider Information.
    // This is to be an array of PROVIDER structures.  Memory is set
    // to zero so that all the provider entry points will be initialized to
    // zero.
    //

    GlobalProviderInfo = (LPPROVIDER) LocalAlloc(
                            LPTR,
                            sizeof(PROVIDER) * GlobalNumProviders);

    if (GlobalProviderInfo == NULL) {
        status = GetLastError();
        MPR_LOG(ERROR,"MprLevel1Init: provider array LocalAlloc Failed %d\n",
            status);
        LocalFree(orderedString);
        GlobalNumProviders = 0;
        RegCloseKey(controlRootKey);
        LeaveCriticalSection(&MprInitCritSec);
        return(status);
    }

    provider = GlobalProviderInfo;

    tempOrderedString = orderedString;

    for(i=0; i<GlobalNumProviders; i++,provider++) {

        //
        // Build the Service key name for the next Service/Driver.
        // NOTE:  This function allocates a nameBuffer.
        //
        status = MprMakeServiceKeyName(
                &tempOrderedString,
                &nameBuffer,
                &providerIdString );

        if (status != WN_SUCCESS) {
            goto SkipProvider;
        }

        //
        // Create the path name to the provider information in the
        // service's tree.
        //
        STRCAT(nameBuffer, PROVIDER_PATH);

        //
        // Open the provider portion of that service/driver's
        // node in the service tree.
        //

        if (!MprOpenKey( controlRootKey, nameBuffer, &providerInfoKey, DA_READ)){
            LocalFree(nameBuffer);
            goto SkipProvider;
        }

        MPR_LOG1(TRACE,"\n\t----%ws----\n",providerIdString);
        MPR_LOG3(TRACE,"\tOpenKey %ws,\n\t%ws\n,\t0x%lx\n",
            SYSTEM_CONTROL_ROOT,
            nameBuffer,
            providerInfoKey);


        //
        // Free the memory that was allocated for the name buffer.
        //

        LocalFree (nameBuffer);

        //
        // Get the data for the provider from the registry at the
        // location referenced by providerInfoKey.
        //

        if (!MprExtractProviderInfo(providerInfoKey, provider)) {

            MPR_LOG(TRACE,"CloseKey 0x%lx\n", providerInfoKey);
            RegCloseKey(providerInfoKey);
            goto SkipProvider;
        }

        //
        // Close the ProviderInfoKey.
        //

        MPR_LOG(TRACE,"CloseKey 0x%lx\n", providerInfoKey);
        RegCloseKey(providerInfoKey);

        //
        // We have information for at least one provider.
        //
        oneInitialized = TRUE;

SkipProvider:
        ;    // The complier needs to find something to go to.

    } // End For NumProviders

    MPR_LOG(TRACE,"CloseKey 0x%lx\n", controlRootKey);
    RegCloseKey(controlRootKey);

    if (orderedString != NULL) {
        LocalFree(orderedString);
    }

    GlobalInitLevel = FIRST_LEVEL;
    LeaveCriticalSection(&MprInitCritSec);

    if (oneInitialized == FALSE) {
        return(WN_NO_NETWORK);
    }
    return(WN_SUCCESS);
}

DWORD
MprLevel2Init(
    DWORD   InitLevel
    )
/*++

Routine Description:

    This routine initializes all providers of the class described by
    the InitLevel parameter.  We loop though all providers that meet
    this description, and load the dll and find the dll's function entry
    points.  If we were successful in getting this information for the
    provider, it will be added to our "active" list by having its provider
    index placed in the GlobalIndexArray (via MprInitIndexArray).


    NOTE:
    This routine can potentially be called once for each type of
    initialization that is supported.  For instance, it may be called for
    authentication initialization, and then called later for network
    initialization.
    Each time this routine is called, a new indexArray is created.
    After this array is filled in, it is merged with any existing
    indexArray left over from previous calls.  The merge is performed
    by MprInitIndexArray.  Locks on this array must be held in order to
    update it.

Arguments:

    InitLevel - This indicates the level of initialization.  This can be
        a NETWORK_LEVEL or CREDENTIAL_LEVEL initialization, or both.

Return Value:

    WN_SUCCESS - This is returned if we are able to obtain some entry point
        information for at least one provider.

    Otherwise, an appropriate error is returned.


--*/
{
    DWORD       status = WN_SUCCESS;
    LPPROVIDER  provider;
    DWORD       i;
    LPDWORD     indexArray = NULL;
    DWORD       numActive = 0;
    DWORD       InitClass = 0;

    //
    // Before we can do a level2 initialization, we must first check to
    // see if level 1 has been completed.
    //
    if (!(GlobalInitLevel & FIRST_LEVEL)) {
        status = MprLevel1Init();
        if (status != WN_SUCCESS) {
            return(status);
        }
    }

    EnterCriticalSection(&MprInitCritSec);
    MPR_LOG(TRACE,"******************* LEVEL 2 INIT ********************\n",0);

    //
    // If this level of initialization is already complete, then return.
    //
    if (GlobalInitLevel & InitLevel) {
        LeaveCriticalSection(&MprInitCritSec);
        return(WN_SUCCESS);
    }

    //
    // Translate InitLevel into an InitClass so it can be compared with the
    // provider class.
    //
    if (InitLevel & NETWORK_LEVEL)
    {
        InitClass |= NETWORK_TYPE;

        //
        // Load the "Entire Network" string (used by WNetEnumResource
        // for RESOURCE_CONNECTED).  Note that WNetEnumResource requires
        // only NETWORK_LEVEL initialization, so it's OK to load it
        // here and only here.
        //
        if (g_wszEntireNetwork[0] == L'\0')
        {
            int cch = LoadString(hDLL,
                                 IDS_NETROOT,
                                 g_wszEntireNetwork,
                                 LENGTH(g_wszEntireNetwork));
            ASSERT(cch > 0 && cch < LENGTH(g_wszEntireNetwork));
        }
    }
    if (InitLevel & CREDENTIAL_LEVEL)
    {
        InitClass |= CREDENTIAL_TYPE;
    }
    if (InitLevel & NOTIFIEE_LEVEL)
    {
        status = MprConnectNotifyInit();

        GlobalInitLevel |= InitLevel;
        LeaveCriticalSection(&MprInitCritSec);
        return(status);
    }

    provider = GlobalProviderInfo;

    //
    // Allocate storage for the ordered list of indices.  This storage is
    // freed by MprInitIndexArray.
    //
    indexArray = (LPDWORD) LocalAlloc(LPTR, sizeof(DWORD) * GlobalNumProviders);
    if (indexArray == NULL) {
        MPR_LOG(ERROR,"MprProcessAttach: indexArray LocalAlloc Failed %d\n",
            GetLastError());

        LeaveCriticalSection(&MprInitCritSec);
        return(GetLastError());
    }

    for(i=0; i<GlobalNumProviders; i++,provider++) {

        //
        // If this provider matches the init type for which we are
        // initializing, then load the library and get the entry points.
        // Then add the provider array index to the index array.
        //
        if (provider->InitClass & InitClass) {

            //
            // Load the DLL and free the memory for its name.
            //
            if (provider->AuthentDllName != NULL) {
                MPR_LOG1(TRACE,"MprLevel2Init: Loading %ws\n",provider->AuthentDllName);
                provider->AuthentHandle = LoadLibraryEx(
                                                provider->AuthentDllName,
                                                NULL,
                                                LOAD_WITH_ALTERED_SEARCH_PATH);
                if (provider->AuthentHandle == NULL) {
                    MPR_LOG(ERROR,"MprLevel2Init: LoadLibraryEx Failed %d\n",
                    GetLastError());
                }
                LocalFree(provider->AuthentDllName);
                provider->AuthentDllName = NULL;
            }
            if (provider->DllName != NULL) {
                MPR_LOG1(TRACE,"MprLevel2Init: Loading %ws\n",provider->DllName);
                provider->Handle = LoadLibraryEx(
                                            provider->DllName,
                                            NULL,
                                            LOAD_WITH_ALTERED_SEARCH_PATH);
                if (provider->Handle == NULL) {
                    MPR_LOG(ERROR,"MprLevel2Init: LoadLibraryEx Failed %d\n",
                    GetLastError());
                }

                //
                // Keep around the DLL name since we need to do another
                // LoadLibraryEx to refcount the DLL in WNetOpenEnum
                //
            }
            if ((provider->Handle != NULL) || (provider->AuthentHandle != NULL)) {
                MPR_LOG0(TRACE,"MprLevel2Init: LoadLibraryEx success\n");

                //
                // Obtain the various entry points for the library.
                // This is done based on the capabilities that are listed for the
                // provider.
                //

                if (GetProviderCapabilities(provider)) {
                    //
                    // Only providers for which we are able to successfully
                    // get the entry points are added to the active array.
                    //
                    // Since this provider information is now initialized, the
                    // provider is considered ACTIVE.  Put the index to the
                    // provider in the index array.
                    //

                    MPR_LOG1(TRACE,"MprLevel2Init: Successfully got "
                    "capabilities for %ws\n",provider->Resource.lpProvider);

                    indexArray[numActive] = i;
                    numActive++;
                }
            }
        } // End If InitLevel match
    } // End For NumProviders

    //
    // Store the information in this indexArray in the GlobalIndexArray.
    //

    MprInitIndexArray(indexArray, numActive);

    GlobalInitLevel |= InitLevel;
    LeaveCriticalSection(&MprInitCritSec);

    MPR_LOG(TRACE,"******************* END LEVEL 2 INIT ********************\n",0);
    return(WN_SUCCESS);
}


BOOL
MprProcessDetach(
    DWORD  dwInitLevel
    )

/*++

Routine Description:

    This function cleans up resources for a process when it detaches
    from the dll.

Arguments:

    none

Return Value:

    none

Note:


--*/
{
    MprDeleteIndexArray();
    MprFreeGlobalProviderInfo();
    GlobalNumProviders = 0;
    GlobalProviderInfo = NULL;

    if (dwInitLevel & MPR_INITCRITSEC_CREATED)
    {
        DeleteCriticalSection(&MprInitCritSec);
    }

    RegCloseKey(g_hProviderKey);
    CloseHandle(g_hProvidersChanged);

    if (dwInitLevel & MPR_PROVIDERLOCK_CREATED)
    {
        MPRProviderLock.Delete();
    }

    if (dwInitLevel & MPR_ERRORCRITSEC_CREATED)
    {
        MprFreeAllErrorRecords();
        DeleteCriticalSection(&MprErrorRecCritSec);
    }

    return(TRUE);
}



BOOL
GetProviderCapabilities(
    LPPROVIDER  Provider
    )

/*++

Routine Description:

    This function obtains the provider's capabilities and then gets the
    procedure entry point for all supported API.

Arguments:

    Provider - A pointer to a PROVIDER structure which will contain all
        information that must be maintained for a given provider.

Return Value:

    TRUE - If at least one capability is found for this provider.

    FALSE - If no capabilities are found for the provider.

History:

    Johnl   17-Jan-1992     Added Property dialog support

--*/

//
// The following macro is designed to work within the function
// GetProviderCapabilities().
//
#define GET_ADDRESS(apiName) Provider-> ## apiName = (PF_NP ## apiName) GetProcAddress(     \
                                                      Provider->Handle,      \
                                                      "NP"#apiName);         \
            if (Provider-> ## apiName == NULL) {                             \
                MPR_LOG(ERROR,                                               \
                    "GetProviderCapabilities: Can't get NP"#apiName " Address %d\n",\
                    GetLastError());                                         \
            }                                                                \
            else {                                                           \
                status = TRUE;                                               \
            }

#define GET_AUTH_ADDRESS(apiName) Provider-> ## apiName = (PF_NP ## apiName) GetProcAddress(  \
                                                      Provider->AuthentHandle, \
                                                      "NP"#apiName);           \
            if (Provider-> ## apiName == NULL) {                               \
                MPR_LOG(ERROR,                                                 \
                    "GetProviderCapabilities: Can't get NP"#apiName " Address %d\n",\
                    GetLastError());                                         \
            }                                                                \
            else {                                                           \
                status = TRUE;                                               \
            }

{
    DWORD   bitMask;
    BOOLEAN status=FALSE;


    GET_ADDRESS(GetCaps);
    if (status) {

        //
        // Get the Network Type
        //
        // CODEWORK:  Read the type from the registry when possible -- this
        // will allow us to avoid doing a Level 2 init in all the cases where
        // only the provider type is needed (e.g., MprFindProviderByType).
        //
        Provider->Type = Provider->GetCaps(WNNC_NET_TYPE);

        //
        // Reject providers that don't supply their type
        //
        if (Provider->Type == 0)
        {
            MPR_LOG(ERROR, "%ws provider reported a net type of 0\n",
                           Provider->Resource.lpProvider);
            ASSERT(!"Network provider didn't report its network type");
            return FALSE;
        }

        //
        // Does it support WNetGetUser?
        //
        bitMask = Provider->GetCaps(WNNC_USER);
        if (bitMask & WNNC_USR_GETUSER) {
            GET_ADDRESS(GetUser);
        }

        //
        // Connection Api Supported
        //
        bitMask = Provider->GetCaps(WNNC_CONNECTION);
        Provider->ConnectCaps = bitMask;

        if (bitMask & WNNC_CON_ADDCONNECTION) {
            GET_ADDRESS(AddConnection);
        }

        if (bitMask & WNNC_CON_ADDCONNECTION3) {
            DWORD   bitMask2;

            GET_ADDRESS(AddConnection3);
            GET_ADDRESS(GetReconnectFlags); // optional entry point

            //
            // Connection Api flags Supported
            //
            bitMask2 = Provider->GetCaps(WNNC_CONNECTION_FLAGS);

            if (bitMask2 == 0) {
                bitMask2 = WNNC_CF_DEFAULT;
            }
            bitMask2 &= WNNC_CF_MAXIMUM;

            Provider->ConnectFlagCaps = bitMask2;
        }

        if (bitMask & WNNC_CON_CANCELCONNECTION) {
            GET_ADDRESS(CancelConnection);
        }

        if (bitMask & WNNC_CON_GETCONNECTIONS) {
            GET_ADDRESS(GetConnection);
            GET_ADDRESS(GetConnection3);
            GET_ADDRESS(GetUniversalName);
        }

        if (bitMask & WNNC_CON_GETPERFORMANCE) {
            GET_ADDRESS(GetConnectionPerformance);
        }

        //
        // Enumeration Api Supported
        //
        bitMask = Provider->GetCaps(WNNC_ENUMERATION);

        if ((bitMask & WNNC_ENUM_GLOBAL) ||
            (bitMask & WNNC_ENUM_LOCAL) ||
            (bitMask & WNNC_ENUM_CONTEXT)) {
            GET_ADDRESS(OpenEnum);
            GET_ADDRESS(EnumResource);
            GET_ADDRESS(CloseEnum);
        }

        //
        // Admin Api Supported
        //
        bitMask = Provider->GetCaps(WNNC_ADMIN);

        if (bitMask & WNNC_ADM_GETDIRECTORYTYPE) {
            GET_ADDRESS(GetDirectoryType);
        }

        if (bitMask & WNNC_ADM_DIRECTORYNOTIFY) {
            GET_ADDRESS(DirectoryNotify);
        }

        //
        // Dialog API Support
        //
        bitMask = Provider->GetCaps(WNNC_DIALOG);

        if (bitMask & WNNC_DLG_PROPERTYDIALOG) {
            GET_ADDRESS(GetPropertyText);
            GET_ADDRESS(PropertyDialog);
        }

        if (bitMask & WNNC_DLG_SEARCHDIALOG) {
            GET_ADDRESS(SearchDialog);
        }

        if (bitMask & WNNC_DLG_FORMATNETWORKNAME) {
            GET_ADDRESS(FormatNetworkName);
        }

        if (bitMask & WNNC_DLG_PERMISSIONEDITOR) {
            GET_ADDRESS(FMXGetPermCaps);
            GET_ADDRESS(FMXEditPerm);
            GET_ADDRESS(FMXGetPermHelp);
        }

        if (bitMask & WNNC_DLG_GETRESOURCEPARENT) {
            GET_ADDRESS(GetResourceParent);
        }

        if (bitMask & WNNC_DLG_GETRESOURCEINFORMATION) {
            GET_ADDRESS(GetResourceInformation);
        }

    }
    else {
        if (Provider->GetAuthentCaps == NULL) {
            Provider->GetAuthentCaps = (PF_NPGetCaps)GetProcAddress(
                                        Provider->AuthentHandle,
                                        "NPGetCaps");
            if (Provider->GetAuthentCaps == NULL) {
                MPR_LOG(ERROR,
                    "GetProviderCapabilities: Can't get NPGetCaps %d\n",
                    GetLastError());
            }
            else {
                status = TRUE;
            }
        }

        //
        // If we couldn't get an address for GetCaps from either the
        // network provider dll or the authentication provider dll, then
        // we should return an error.  The rule is, this must be supported
        // by one of the providers.
        //
        if (status == FALSE) {
            return(FALSE);
        }
    }
    //
    // Get Authentication Provider entry points
    //
    if (Provider->InitClass & CREDENTIAL_TYPE) {
        if (Provider->AuthentHandle == NULL) {
            MPR_LOG0(TRACE,"GetProvCaps: CM provider in same DLL\n");
            GET_ADDRESS(LogonNotify);
            GET_ADDRESS(PasswordChangeNotify);
        }
        else {
            MPR_LOG0(TRACE,"GetProvCaps: CM provider in seperate DLL\n");
            GET_AUTH_ADDRESS(LogonNotify);
            GET_AUTH_ADDRESS(PasswordChangeNotify);

            if (Provider->GetAuthentCaps == NULL) {
                Provider->GetAuthentCaps = (PF_NPGetCaps)GetProcAddress(
                                            Provider->AuthentHandle,
                                            "NPGetCaps");
                if (Provider->GetAuthentCaps == NULL) {
                    MPR_LOG(ERROR,
                        "GetProviderCapabilities: Can't get NPGetCaps %d\n",
                        GetLastError());
                }
                else {
                    status = TRUE;
                }
            }
        }
    }

    return(status);
}



VOID
MprFreeGlobalProviderInfo(
    VOID
    )
/*++

Routine Description:

    This function walks through the array of provider structures, and
    frees up all the valid pointers to the provider name. Then if frees
    the GlobalProviderInfo array.

Arguments:

    none.

Return Value:

    none.

--*/
{
    LPPROVIDER  provider;
    DWORD       i;

    if (GlobalProviderInfo == NULL)
    {
        return;
    }

    provider = GlobalProviderInfo;

    //
    // Free all the valid pointers to the provider's name.
    //
    for(i = 0; i < GlobalNumProviders; i++, provider++)
    {
        MPR_LOG(TRACE, "Freeing Name for provider %d\n",i);

        if (provider->Handle != NULL)
        {
            MPR_LOG1(TRACE,
                     "Freeing Library for "FORMAT_LPTSTR" \n",
                     provider->Resource.lpProvider);

            FreeLibrary(provider->Handle);
        }

        LocalFree(provider->DllName);

        if (provider->AuthentHandle != NULL)
        {
            MPR_LOG1(TRACE,
                     "Freeing authentication library for "FORMAT_LPTSTR" \n",
                     provider->Resource.lpProvider);

            FreeLibrary(provider->AuthentHandle);
        }

        //
        // Should have been freed when the DLL was loaded
        //
        ASSERT(provider->AuthentDllName == NULL);

        LocalFree(provider->Resource.lpRemoteName);
    }

    //
    // Free the top level data structure and reinit the globals
    //
    MPR_LOG(TRACE, "Freeing GlobalProviderInfo\n",0);
    LocalFree(GlobalProviderInfo);

    GlobalProviderInfo       = NULL;
    GlobalNumProviders       = 0;
    GlobalNumActiveProviders = 0;
}

DWORD
MprMakeServiceKeyName(
    IN OUT  LPTSTR  *OrderedNamePtr,
    OUT     LPTSTR  *NameBufferPtr,
    OUT     LPTSTR  *NamePtr
    )

/*++

Routine Description:

    This function gets the name of the provider device driver key within
    the registry tree.  A buffer is allocated that is large enough for
    that name as well as the name of the key where the provider information
    is stored.

        For example, the following buffer is allocated and filled with
        only the path prefix followed by the LanmanRedirector name.

            NameBuffer = [services\LanmanRedirector                ]

        The buffer is sized so that it can be filled in later with the
        following information.

            NameBuffer = [services\LanmanRedirector\NetworkProvider]

        The Driver name is needed for comparison with the ordered list names.

Arguments:

    OrderedNamePtr - On entry this points to a location where there is a
        pointer to the the next name in the ordered list of providers.
        These names are seperated by commas.  The last entry is followed by
        a trailing NUL.
        On exit a pointer to the next name in the list is stored here.  If
        it is the last name, the pointer is NULL.

    NameBufferPtr - This is a pointer to a location where the pointer to the
        name buffer is to be placed.

    NamePtr - This is a a location where the pointer to the provider
        name is placed.  In the above example, this pointer would point
        to the beginnning of the LanmanRedirector portion of the string.

Return Value:

    TRUE - We successfully obtained the driver name.

    FALSE - We were unsuccessful in obtaining the driver name.

Note:


--*/

{
    LPTSTR  pNext;
    DWORD   bufferSize;     // number of BYTES in buffer
    DWORD   nameLength;     // number of CHARACTERS in string

    //
    // The OrderedNamePtr should always be valid.  If not there is a software
    // error in this code.
    //
    if (*OrderedNamePtr == NULL) {
        MPR_LOG(ERROR,"GetDriverName: The ordered Name Ptr was NULL.\n",0);
        return(WN_NO_NETWORK);
    }

    pNext = *OrderedNamePtr;

    //
    // Find the next NULL or COMMA.
    //
    while ( (*pNext != TEXT('\0')) &&
            (*pNext != TEXT(','))  ){
        pNext++;
    }

    //
    // Allocate a buffer for the name to be stored in
    //

    bufferSize = (DWORD)((LPBYTE)pNext - (LPBYTE)(*OrderedNamePtr));
    nameLength = bufferSize / sizeof(TCHAR);

    bufferSize = bufferSize + STRSIZE(PROVIDER_PATH) + STRSIZE(SERVICES_KEY_NAME);

    *NameBufferPtr = (LPTSTR) LocalAlloc(LPTR, bufferSize);
    if (*NameBufferPtr == NULL) {
        MPR_LOG(ERROR,"MprMakeServiceKeyName:LocalAllocFailed %d\n",GetLastError());
        return(GetLastError());
    }

    //
    // Copy the path prefix "services\\" followed by the name
    // into the buffer and terminate with a NULL character.
    //
    STRCPY(*NameBufferPtr, SERVICES_KEY_NAME);
    *NamePtr = (LPTSTR)(*NameBufferPtr + (STRLEN(*NameBufferPtr)));

    STRNCAT(*NameBufferPtr, *OrderedNamePtr, nameLength);
    *((*NamePtr) + nameLength) = TEXT('\0');



    if (*pNext == TEXT('\0')) {
        *OrderedNamePtr = NULL;
    }
    else {
        *OrderedNamePtr = pNext + 1;
    }

    return (WN_SUCCESS);
}


BOOL
MprGetOrderedList(
    HKEY    ControlRootKey,
    LPTSTR  *OrderString
    )

/*++

Routine Description:

    This function returns a pointer to a string that contains the
    ordered list of providers.  This ordered list is to be used when
    we go through the list of providers with a trial-and-error method
    when servicing a WINNET API call.

    ALLOCATES STORAGE:  This function allocates the buffer for the
    OrderString.

Arguments:

    OrderString - This is a pointer to a location where the pointer to
        the order string is to be placed.

Return Value:

    TRUE - The ordered list was found, and the string was returned.

    FALSE - A failure occured when attempting to find the ordered list.

--*/
{

    HKEY        orderKey;

    *OrderString = NULL;

    //
    // Get a handle to the key for the ordered provider information.
    //

    if(!MprOpenKey(
                ControlRootKey,         // hKey
                PROVIDER_ORDER_KEY,     // lpSubKey
                &orderKey,              // Newly Opened Key Handle
                DA_READ)) {             // Desired Access

        MPR_LOG(ERROR,"MprGetOrderedList: MprOpenKey (ActiveProviders) Error\n",0);
        return(FALSE);
    }


    //
    // Get the provider order string from the registry.
    //
    if (!MprGetKeyValue(orderKey, TEXT("ProviderOrder"), OrderString)) {

        MPR_LOG(ERROR,"MprGetOrderedList: MprGetKeyValue Error.\n", 0);

        RegCloseKey(orderKey);
        return(FALSE);
    }

    RegCloseKey(orderKey);

    return(TRUE);
}

DWORD
MprGetNumProviders(
    LPTSTR  OrderedString
    )

/*++

Routine Description:

    This routine finds the number of provider names in the string of
    ordered provider names.

Arguments:

    OrderedString - This is a pointer to a NUL terminated string of
        ordered provider names.  Names are seperated by commas.

Return Value:



--*/
{
    DWORD   count = 0;
    LPTSTR  pBegin;

    pBegin = OrderedString;

    while (*OrderedString != TEXT('\0')) {

        //
        // If a seperator has been found, and if there are characters
        // between it and the last seperator (or the beginning), then
        // increment the count.
        //
        if (*OrderedString == TEXT(',')) {
            if((OrderedString - pBegin) > 0) {
                count++;
            }
            pBegin = OrderedString + 1;
        }
        OrderedString++;
    }

    //
    // The last name is expected to be followed by a NUL rather than a
    // comma.
    //
    if ((OrderedString - pBegin) > 0) {
        count++;
    }
    return(count);
}

BOOL
MprExtractProviderInfo(
    HKEY        ProviderInfoKey,
    LPPROVIDER  Provider
    )

/*++

Routine Description:

    This function extracts information from the ProviderInfoKey location
    in the registry and stores it in the Provider data structure.

Arguments:

    ProviderInfoKey - This is a registry key handle for the location in
        the registry where we expect to obtain all the necessary
        information about a provider.

    Provider - This is a pointer to a provider structure that is to be
        filled in with the information from the registry.

Return Value:

    TRUE - The operation was completely successful.

    FALSE - The operation failed.

Note:


--*/
{

    LPTSTR      providerName = NULL;
    LPTSTR      fileName = NULL;
    DWORD       ValueType;
    DWORD       Class;
    DWORD       classSize = sizeof(DWORD);
    DWORD       status;

    MPR_LOG(TRACE,"In MprExtractProviderInfo....\n",0);

    //
    // Get Provider Name
    //

    if(!MprGetKeyValue(ProviderInfoKey, TEXT("name"), &providerName) ||
       providerName[0] == L'\0') {
        MPR_LOG0(ERROR,"MprExtractProviderInfo: Couldn't get provider name\n");
        return(FALSE);
    }


    //
    // Initialize all the fields in the resource structure.
    // NOTE: The reserved field in dwUsage is set to indicate this is
    // a top level structure.
    //
    Provider->Resource.lpProvider   = providerName;
    Provider->Resource.lpRemoteName = providerName;
    Provider->Resource.dwScope      = RESOURCE_GLOBALNET;
    Provider->Resource.dwType       = 0;
    Provider->Resource.dwDisplayType= RESOURCEDISPLAYTYPE_NETWORK;
    Provider->Resource.dwUsage      = RESOURCEUSAGE_CONTAINER | RESOURCEUSAGE_RESERVED;
    Provider->Resource.lpComment    = NULL;

    //
    // Get the Provider Class.  If there isn't a Class value in the
    // registry, assume it is a NetworkClass only.
    //

    status = RegQueryValueEx(
                ProviderInfoKey,    // hKey
                VALUE_CLASS,        // lpValueName
                NULL,               // lpTitleIndex
                &ValueType,         // lpType
                (LPBYTE)&Class,     // lpData
                &classSize);        // lpcbData

    if (status != NO_ERROR) {
        //
        // If we get an error we assume it is because there is no key - thus
        // indicating that this provider is a network provider only.
        //
        MPR_LOG0(TRACE,"Couldn't find Authenticator Class value "
            "- assume it is Network-type only\n");
        Class = WN_NETWORK_CLASS;
    }
    Provider->InitClass = Class;
    MPR_LOG1(TRACE,"MprExtractProviderInfo: Provider InitClass = %d\n",Class);



    //
    // Get the name of the provider's DLL routine
    //

    if(!MprGetKeyValue(ProviderInfoKey,VALUE_PATHNAME,&fileName)){
        MPR_LOG(ERROR,
            "MprExtractProviderInfo: Failed to get the Dll path from registry\n",0);

        //
        // If this is a network class provider, it MUST have a provider
        // dll.  Otherwise, we return a failure.
        //
        if (Class & WN_NETWORK_CLASS) {
            return(FALSE);
        }
        else {
            fileName = NULL;
        }
    }
    Provider->DllName = fileName;


    //
    // If this is a CREDENTIAL_CLASS or PRIMARY_AUTHENT_CLASS provider
    // then try to get the dll name for the authentication provider.
    //

    if (Class & (WN_CREDENTIAL_CLASS | WN_PRIMARY_AUTHENT_CLASS)) {
        //
        // Get the name of the provider's Credential Management DLL routine
        //
        if(!MprGetKeyValue(ProviderInfoKey,AUTHENT_PATHNAME,&fileName)){
            //
            // If we can't get a name for the Authentication Provider's DLL,
            // then we will assume the network provider dll exports the
            // Credential Management functions.
            //
            MPR_LOG0(ERROR,
                "MprExtractProviderInfo: Failed to get the Authenticator "
                "Dll path from registry\n");
            //
            // If we don't have a provider dll name, or an authent provider
            // dll name, then this is an error condition.
            //
            if (Provider->DllName == NULL) {
                return(FALSE);
            }
        }
        else {
            Provider->AuthentDllName = fileName;
        }
    }
    return(TRUE);
}


BOOL
MprGetLUIDDeviceMapsEnabled(
    PBOOL pResult
    )

/*++

Routine Description:

    This function calls NtQueryInformationProcess() to determine if
    LUID device maps are enabled


Arguments:

    pResult - returns the result of "Is LUID device maps are enabled?"
              TRUE - LUID device maps are enabled
              FALSE - LUID device maps are disabled

Return Value:

    TRUE - This is returned if we are able to determine if LUID device
                 maps are enabled/disabled.

    FALSE - Encountered an error

--*/

{

    NTSTATUS  Status;
    ULONG     LUIDDeviceMapsEnabled;
    BOOL      Result;

    if( pResult == NULL ) {
        return (FALSE);
    }

    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessLUIDDeviceMapsEnabled,
                                        &LUIDDeviceMapsEnabled,
                                        sizeof(LUIDDeviceMapsEnabled),
                                        NULL
                                      );

    if( !NT_SUCCESS(Status) ) {
        MPR_LOG(ERROR,"MprGetLUIDDeviceMapsEnabled: NtQueryInformationProcess (g_LUIDDeviceMapsEnabled) Error\n",0);
        return( FALSE );
    }
    else{
        Result = (LUIDDeviceMapsEnabled != 0);
    }

    *pResult = Result;

    return( TRUE );
}

extern "C" int __cdecl
_purecall(
    VOID
    )
{
   // Make it build... (the compiler will initialize all pure virtual
   // function pointers to point to this...  If we hit this function,
   // there's a really big problem.)
   RtlRaiseStatus(STATUS_NOT_IMPLEMENTED);
   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\mprbase.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mprbase.cxx

Abstract:

    Contains implementations of base classes that supply common code for
    Multi-Provider Router operations.
    Contains:
        CMprOperation::Perform
        CRoutedOperation::ValidateParameters
        CRoutedOperation::GetResult

Author:

    Anirudh Sahni (anirudhs)     11-Oct-1995

Environment:

    User Mode -Win32

Notes:

Revision History:

    11-Oct-1995     AnirudhS
        Created.

    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/

//
// Includes
//

#include "precomp.hxx"
#include <malloc.h>     // _alloca

//
// External Globals and Statics
//
extern  DWORD       GlobalNumActiveProviders;

CRoutedOperation::CPathCache CRoutedOperation::_PathCache;

//
// Defines
//


//
// Local Function Prototypes
//



//+-------------------------------------------------------------------------
//
//  Function:   CMprOperation::Perform
//
//  Purpose:    See header file
//
//  History:    11-Oct-95 AnirudhS  Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CMprOperation::Perform()
{
    DWORD status = WN_SUCCESS;

    __try
    {
        //
        // Ask the derived class to validate the API parameters
        //
        status = ValidateParameters();
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION)
        {
            MPR_LOG2(ERROR,"CMprOperation(%s): Unexpected exception %#lx\n",_OpName,status);
        }

        status = WN_BAD_POINTER;
    }

    if (status == WN_SUCCESS)
    {
        //
        // Ask the derived class to perform the operation
        //
        status = GetResult();
    }

    if (status != WN_SUCCESS)
    {
        SetLastError(status);
    }

    return status;
}


//+-------------------------------------------------------------------------
//
//  Function:   CRoutedOperation::Perform
//
//  Purpose:    See header file
//
//  History:    27-May-99 jschwart  Created.
//
//  Notes:      Since the CMprOperation should have no knowledge of
//              providers, deal with provider-related locking/checking
//              in the CRoutedOperation class, which is meant for
//              APIs that use the providers.
//
//--------------------------------------------------------------------------

DWORD CRoutedOperation::Perform(BOOL fCheckProviders)
{
    //
    // If an API that uses this class creates another instance of the class
    // (e.g., CGetConnectionPerformance uses CGetConnection), there needs
    // to be a way to prevent the second call from trying to acquire the
    // exclusive lock while the original call holds the shared lock.
    //
    if (fCheckProviders)
    {
        MprCheckProviders();
    }

    CProviderSharedLock    PLock;

    return CMprOperation::Perform();
}


//+-------------------------------------------------------------------------
//
//  Function:   CRoutedOperation::ValidateParameters
//
//  Purpose:    See header file
//
//  History:    11-Oct-95 AnirudhS  Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRoutedOperation::ValidateParameters()
{
    //
    // Ask the derived class to validate the API parameters.
    // Also, if the API caller passed in a specific NP name, the derived
    // class should pass it back here, to be validated here.  The provider
    // is looked up and stored in _pSpecifiedProvider.
    // If the API caller passed in a remote name that can be used as a
    // hint for routing, the derived class should pass it back here.  A
    // pointer to it is stored in _RemoteName and used later, in GetResult(),
    // to help pick an efficient provider routing order.
    //
    LPCWSTR pwszProviderName = NULL;
    LPCWSTR pwszRemoteName   = NULL;
    LPCWSTR pwszLocalName    = NULL;

    ASSERT(MPRProviderLock.Have());

    DWORD status = ValidateRoutedParameters(&pwszProviderName,
                                            &pwszRemoteName,
                                            &pwszLocalName);

    if (status == WN_SUCCESS)
    {
        //
        // Optimization: Store away the drive type.  In GetResult(),
        // we need only call the providers if the local name is
        // a remote drive.  _uDriveType is initialized to DRIVE_REMOTE
        //

        if (! IS_EMPTY_STRING(pwszLocalName) && pwszLocalName[1] == L':')
        {
            WCHAR wszRootPath[] = L" :\\";

            wszRootPath[0] = pwszLocalName[0];
            _uDriveType = GetDriveType(wszRootPath);
        }

        // This probes pwszRemoteName as well as saving its length
        RtlInitUnicodeString(&_RemoteName, pwszRemoteName);

        if (! IS_EMPTY_STRING(pwszProviderName))
        {
            //
            // Level 1 init for MprFindProviderByName
            //
            if (!(GlobalInitLevel & FIRST_LEVEL)) {
                status = MprLevel1Init();
                if (status != WN_SUCCESS) {
                   return status;
                }
            }

            _pSpecifiedProvider = MprFindProviderByName(pwszProviderName);
            if (_pSpecifiedProvider == NULL)
            {
                return WN_BAD_PROVIDER;
            }
        }
    }

    return status;
}


//+-------------------------------------------------------------------------
//
//  Function:   CRoutedOperation::GetResult
//
//  Purpose:    See header file
//
//  History:    11-Oct-95 AnirudhS  Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRoutedOperation::GetResult()
{
    DWORD       status = WN_SUCCESS;
    LPPROVIDER *ProviderArray;

    //
    // Only call the providers if it's a remote drive
    //

    if (_uDriveType != DRIVE_REMOTE)
    {
        return WN_NOT_CONNECTED;
    }

    INIT_IF_NECESSARY(NETWORK_LEVEL, status);

    //
    // If there are no providers, return NO_NETWORK
    //
    if (GlobalNumActiveProviders == 0)
    {
        return WN_NO_NETWORK;
    }

    // Array of pointers into the GlobalProviderInfo array.
    DWORD       numProviders;

    __try
    {
        ProviderArray = (LPPROVIDER *) _alloca(GlobalNumProviders * sizeof(LPPROVIDER));
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = WN_OUT_OF_MEMORY;
    }

    if (status != WN_SUCCESS)
    {
        return status;
    }

    //
    // Find the list of providers to call for this request.
    //
    if (_pSpecifiedProvider != NULL)
    {
        //
        // The caller requested a particular Provider
        //
        ProviderArray[0] = _pSpecifiedProvider;
        numProviders = 1;
    }
    else
    {
        //
        // A Provider name was not specified.  Therefore, we must
        // create an ordered list and pick the best one.
        //
        status = FindCallOrder(
                        &_RemoteName,
                        ProviderArray,
                        &numProviders,
                        NETWORK_TYPE
                        );
        if (status != WN_SUCCESS)
        {
            return status;
        }
    }

    //
    // Loop through the list of providers until one answers the request,
    // or the list is exhausted.
    //
    DWORD statusFlag = 0;               // Mask of combined error returns
    DWORD FirstNetPathError = WN_SUCCESS;     // First NO_NET or BAD_NAME error
    DWORD FirstSignificantError = WN_SUCCESS; // First "other" error, used in
                                              // aggressive routing only

    status = WN_NOT_SUPPORTED;          // Returned if no providers respond

    for (DWORD i=0; i<numProviders; i++)
    {
        _LastProvider = ProviderArray[i];

        if (_pProviderFunction != NULL &&
            _LastProvider->*_pProviderFunction == NULL)
        {
            //
            // The provider doesn't supply the required entry point.
            //
            status = WN_NOT_SUPPORTED;
        }
        else
        {
            //
            // Ask the derived class to try the provider.
            //
            __try
            {
                MPR_LOG2(ROUTE, "%s: trying %ws ...\n",
                         OpName(), _LastProvider->Resource.lpProvider);
                status = TestProvider(_LastProvider);
                MPR_LOG(ROUTE, "... provider returned %lu\n", status);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                status = GetExceptionCode();
                MPR_LOG(ROUTE, "... provider threw EXCEPTION %#lx\n", status);
                if (status != EXCEPTION_ACCESS_VIOLATION)
                {
                    MPR_LOG3(ERROR,
                            "%s: Unexpected Exception %#lx "
                                "calling %ws provider\n",
                            OpName(), status,
                            _LastProvider->Resource.lpProvider);
                }
                status = WN_BAD_POINTER;
            }
        }

        //
        // Decide whether to stop trying other providers and return the
        // error immediately, or continue trying other providers.
        // There are two algorithms for routing to providers, called
        // "lazy routing" and "aggressive routing".  In lazy routing,
        // we always stop routing, unless the error was an insignificant
        // one (such as WN_BAD_NETNAME) indicating that the call may be
        // meant for some other provider.  In aggressive routing, we
        // always continue routing, except on a few special errors (such
        // as WN_SUCCESS).
        //
        switch (status)
        {

        //////////////////////////////////////////////////////////////
        // Always stop routing on these errors, even if routing     //
        // aggressively                                             //
        //////////////////////////////////////////////////////////////

        case WN_SUCCESS:
        case WN_MORE_DATA:
            //
            // The provider successfully operated on this path, so add it
            // to the cache...
            //
            _PathCache.AddEntry(&_RemoteName, _LastProvider);
            //
            // ... and fall through
            //
        case WN_BAD_POINTER:
        case WN_ALREADY_CONNECTED:
        case WN_CANCEL:
            goto CleanExit;


        //////////////////////////////////////////////////////////////
        // Always continue routing on these errors                  //
        // Classify them so that if we later decide to return one   //
        // of them to the caller, we pick the most sensible one     //
        //////////////////////////////////////////////////////////////

        case WN_NOT_SUPPORTED:
            //
            // Ignore the error
            //
            break;

        case WN_NO_MORE_DEVICES:
            statusFlag |= NO_DEVICES;
            break;

        case WN_NOT_CONNECTED:
            statusFlag |= NOT_CONNECTED;
            break;

        case WN_NOT_CONTAINER:
            statusFlag |= NOT_CONTAINER;
            break;

        case WN_NO_NETWORK:
        case WN_FUNCTION_BUSY:
        case WN_NO_NET_OR_BAD_PATH:
        case WN_NOT_LOGGED_ON:
            statusFlag |= NO_NET;
            if (FirstNetPathError == WN_SUCCESS)
            {
                FirstNetPathError = status;
            }
            break;

        case WN_BAD_NETNAME:
        case ERROR_BAD_NETPATH:
        case WN_BAD_LOCALNAME:
        case WN_BAD_VALUE:
        case WN_BAD_LEVEL:
        case ERROR_REM_NOT_LIST:
            statusFlag |= BAD_NAME;
            if (FirstNetPathError == WN_SUCCESS)
            {
                FirstNetPathError = status;
            }
            break;


        //////////////////////////////////////////////////////////////
        // On other errors, stop routing if lazy, continue if       //
        // aggressive                                               //
        //////////////////////////////////////////////////////////////

        default:
            if (_AggressiveRouting)
            {
                // Remember the first one of these errors.  It will take
                // precedence over other errors.
                if (FirstSignificantError == WN_SUCCESS)
                {
                    FirstSignificantError = status;
                }
                break;

                // Note that if multiple providers return WN_EXTENDED_ERROR,
                // we'll return the error reported by the last one rather
                // than the first.
            }
            else
            {
                // Return this error immediately
                goto CleanExit;
            }
        } // switch
    } // for all providers

    //
    // If a specific provider was tried then return the error from that provider.
    // Otherwise, concoct the best return code from the errors returned.
    //
    if (numProviders > 1)
    {
        if (FirstSignificantError != WN_SUCCESS)
        {
            status = FirstSignificantError;
        }
        else if (statusFlag & NO_DEVICES)
        {
            status = WN_NO_MORE_DEVICES;
        }
        else if (statusFlag & NOT_CONNECTED)
        {
            status = WN_NOT_CONNECTED;
        }
        else if (statusFlag & NOT_CONTAINER)
        {
            status = WN_NOT_CONTAINER;
        }
        else if (statusFlag & (NO_NET | BAD_NAME))
        {
            if ((statusFlag & (NO_NET | BAD_NAME)) == (NO_NET | BAD_NAME))
            {
                //
                // Mix of special errors occured.
                // Pass back the combined error message.
                //
                status = WN_NO_NET_OR_BAD_PATH;
            }
            else
            {
                status = FirstNetPathError;
            }
        }
        else
        {
            ASSERT(status == WN_NOT_SUPPORTED);
        }
    }

CleanExit:

    MPR_LOG2(ROUTE, "CRoutedOperation(%s): returning %lu\n\n", OpName(), status);

    return status;
}



//+-------------------------------------------------------------------------
//
//  Function:   CRoutedOperation::CPathCache::Construct
//
//  Purpose:    Constructor, called explicitly to avoid dependence on CRT
//
//  History:    09-Apr-96 AnirudhS  Created.
//
//--------------------------------------------------------------------------

void CRoutedOperation::CPathCache::Construct()
{
    InitializeCriticalSection(&_Lock);
    RtlZeroMemory(_RecentPaths, sizeof(_RecentPaths));
    InitializeListHead(&_ListHead);
    _NumFree = PATH_CACHE_SIZE;
}


//+-------------------------------------------------------------------------
//
//  Function:   CRoutedOperation::CPathCache::Destroy
//
//  Purpose:    Destructor, called explicitly to avoid dependence on CRT
//
//  History:    09-Apr-96 AnirudhS  Created.
//
//--------------------------------------------------------------------------

void CRoutedOperation::CPathCache::Destroy()
{
    //
    // This is really needed only if the DLL is being unloaded because of
    // a FreeLibrary call, not if the process is exiting
    //
    for (DWORD i = _NumFree; i < PATH_CACHE_SIZE; i++)
    {
        LocalFree(_RecentPaths[i].Path.Buffer);
    }
    DeleteCriticalSection(&_Lock);
}


//+-------------------------------------------------------------------------
//
//  Function:   CRoutedOperation::CPathCache::AddEntry
//
//  Purpose:    Add an entry to the cache
//
//  History:    09-Apr-96 AnirudhS  Created.
//
//--------------------------------------------------------------------------

void CRoutedOperation::CPathCache::AddEntry(
    const UNICODE_STRING * Path,
    LPPROVIDER      Provider
    )
{
    if (Path->Length == 0 || Path->Length >= (MAX_PATH*sizeof(WCHAR)))
    {
        //
        // Don't add empty or too-long paths to the cache
        //
        return;
    }

    ASSERT(Path->MaximumLength == Path->Length + sizeof(UNICODE_NULL));

    EnterCriticalSection(&_Lock);

    CacheEntry *pEntry = NULL;  // Entry to write

    //
    // See if there's a matching path string in the cache already
    //
    for (PLIST_ENTRY pLinks = _ListHead.Flink;
         pLinks != &_ListHead;
         pLinks = pLinks->Flink)
    {
        pEntry = CONTAINING_RECORD(pLinks, CacheEntry, Links);

        if (RtlEqualUnicodeString(&pEntry->Path, (PUNICODE_STRING) Path, TRUE))
        {
            break;
        }

        pEntry = NULL;
    }

    if (pEntry == NULL)
    {
        //
        // No matching entry.
        // If there's a free entry in the array, use it.
        // Otherwise overwrite the last entry in the list.
        //
        if (_NumFree > 0)
        {
            _NumFree--;
            pEntry = &_RecentPaths[_NumFree];

            //
            // Add this new entry to the list.
            //
            InsertHeadList(&_ListHead, &pEntry->Links);
        }
        else
        {
            ASSERT(!IsListEmpty(&_ListHead));
            pEntry = CONTAINING_RECORD(_ListHead.Blink, CacheEntry, Links);
        }

        //
        // Copy the path string into the cache.  Re-use the string buffer,
        // unless it's too small.
        //
        if (pEntry->Path.MaximumLength < Path->MaximumLength)
        {
            //
            // Re-allocate the string buffer.  Allocate twice as much space
            // as needed, but never more than MAX_PATH Unicode characters.
            // Note, here we know that MaximumLength <= MAX_PATH characters.
            //
            HLOCAL NewBuffer = LocalAlloc(
                        0,
                        min(Path->MaximumLength * 2, MAX_PATH * sizeof(WCHAR))
                        );
            if (NewBuffer == NULL)
            {
                //
                // Couldn't allocate.  Don't add to the cache.
                // (If it was unused, this cache entry is lost forever.
                // CODEWORK try to recover it in this case?)
                //
                goto CleanExit;
            }

            LocalFree(pEntry->Path.Buffer);
            pEntry->Path.Buffer = (PWSTR) NewBuffer;
            pEntry->Path.MaximumLength = (USHORT)LocalSize(NewBuffer);
        }

        RtlCopyUnicodeString(&pEntry->Path, (PUNICODE_STRING) Path);
    }

    //
    // Remember the provider in the cache.  (This overwrites any previously
    // remembered provider for the path.)
    //
    pEntry->Provider = Provider;
    MPR_LOG2(ROUTE, "cache: cached %ws for %ws\n", Provider->Resource.lpProvider, Path->Buffer);

    //
    // Move this entry to the front of the list, if it isn't there already.
    //
    if (_ListHead.Flink != &pEntry->Links)
    {
        RemoveEntryList(&pEntry->Links);
        InsertHeadList(&_ListHead, &pEntry->Links);
    }

CleanExit:

    LeaveCriticalSection(&_Lock);
}


//+-------------------------------------------------------------------------
//
//  Function:   CRoutedOperation::CPathCache::FindEntry
//
//  Purpose:    Search for an entry in the cache
//
//  History:    09-Apr-96 AnirudhS  Created.
//
//--------------------------------------------------------------------------

LPPROVIDER CRoutedOperation::CPathCache::FindEntry(
    const UNICODE_STRING * Path
    )
{
    if (Path->Length == 0)
    {
        return NULL;
    }

    ASSERT(Path->MaximumLength == Path->Length + sizeof(UNICODE_NULL));

    EnterCriticalSection(&_Lock);

    //
    // Search forward in the list for a matching path string
    //
    LPPROVIDER Provider = NULL;
    for (PLIST_ENTRY pLinks = _ListHead.Flink;
         pLinks != &_ListHead;
         pLinks = pLinks->Flink)
    {
        CacheEntry *pEntry = CONTAINING_RECORD(pLinks, CacheEntry, Links);

        if (RtlEqualUnicodeString(&pEntry->Path, (PUNICODE_STRING) Path, TRUE))
        {
            Provider = pEntry->Provider;

            //
            // Move this entry to the front of the list, if it isn't there already.
            //
            if (_ListHead.Flink != &pEntry->Links)
            {
                RemoveEntryList(&pEntry->Links);
                InsertHeadList(&_ListHead, &pEntry->Links);
            }

            break;
        }
    }

    LeaveCriticalSection(&_Lock);

    MPR_LOG2(ROUTE, "cache: found %ws for %ws\n",
                    (Provider ? Provider->Resource.lpProvider : L"no cached provider"),
                    Path->Buffer);

    return Provider;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\mprprop.cxx ===
/**********************************************************************/
/**           Microsoft Windows/NT                                   **/
/**        Copyright(c) Microsoft Corp., 1992                        **/
/**********************************************************************/

/*
    MPRProp.cxx

    This file contains the implementation for the

    WNetGetPropertyTextW
    WNetPropertyDialogW




    FILE HISTORY:

    05-May-1999     jschwart
        Make provider addition/removal dynamic

    27-May-1994 danl
        WNetGetPropertyTextW & WNetPropertyDialogW:  If no provider
        claims the connection in question, then we try all providers.
        The actual rule is that we need to pass it to the lanman
        provider anyway (so it can check for a share).  But to play
        completely fair, we'll pass it to everyone.

    Johnl   07-Jan-1991 Boilerplated from Danl's code

*/


#include "precomp.hxx"


DWORD
WNetGetPropertyTextW (
    DWORD  iButton,
    DWORD  nPropSel,
    LPTSTR lpszName,
    LPTSTR lpszButtonName,
    DWORD  nButtonNameLength,
    DWORD  nType
    )
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD       status=WN_SUCCESS;
    LPPROVIDER  provider;
    BOOL        fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD       providerIndex;
    LPDWORD     index;
    DWORD       indexArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders;
    DWORD       statusFlag = 0; // used to indicate major error types
    DWORD       i;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    index = indexArray;

    //
    // Find the Provider Index associated with the drive letter in
    // the pathname (lpszName).
    // NOTE:  This function handles exceptions.
    //
    status = MprFindProviderForPath(lpszName, &providerIndex);
    if (status != WN_SUCCESS) {
        MPR_LOG1(ERROR,"WNetGetPropertyText: Couldn't find provider for this "
            "path.  Error = %d\n",status);

        //
        // Find the list of providers to call for this request.
        // Since no provider claimed this path, then
        // we need to at least try the lanman provider.
        // Actually we'll give them all a chance.
        //

        status = MprFindCallOrder(
                    NULL,
                    &index,
                    &numProviders,
                    NETWORK_TYPE);

        if (status != WN_SUCCESS) {
            return(status);
        }
    }
    else {
        numProviders = 1;
        index[0] = providerIndex;
    }

    //
    // Loop through the list of providers until one answers the request,
    // or the list is exhausted.
    //
    for (i=0; i<numProviders; i++) {
        //
        // Call the appropriate provider's API entry point
        //
        provider = GlobalProviderInfo + index[i];

        if (provider->GetPropertyText != NULL) {

            fcnSupported = TRUE;

            __try {
                status = provider->GetPropertyText(
                        iButton,
                        nPropSel,
                        lpszName,
                        lpszButtonName,
                        nButtonNameLength,
                        nType
                        );
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
                if (status != EXCEPTION_ACCESS_VIOLATION) {
                    MPR_LOG(ERROR,"WNetGetPropertyText:Unexpected Exception "
                    "0x%lx\n",status);
                }
                status = WN_BAD_POINTER;
            }

            if (status == WN_NO_NETWORK) {
                statusFlag |= NO_NET;
            }
            else if ((status == WN_NOT_CONNECTED)  ||
                     (status == WN_BAD_LOCALNAME)){

                statusFlag |= BAD_NAME;
            }
            else {
                //
                // If it wasn't one of those errors, then the provider
                // must have accepted responsiblity for the request.
                // so we exit and process the results.  Note that the
                // statusFlag is cleared because we want to ignore other
                // error information that we gathered up until now.
                //
                statusFlag = 0;
                break;
            }
        } // End if this provider supports GetPropertyText.
    }
    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (index != indexArray) {
        LocalFree(index);
    }

    //
    // Handle special errors.
    //
    if (statusFlag == (NO_NET | BAD_NAME)) {
        //
        // Check to see if there was a mix of special errors that occured.
        // If so, pass back the combined error message.  Otherwise, let the
        // last error returned get passed back.
        //
        status = WN_NO_NET_OR_BAD_PATH;
    }

    if (status != WN_SUCCESS){
        SetLastError(status);
    }

    //
    // Handle normal errors passed back from the provider
    //
    return(status);
}

DWORD
WNetPropertyDialogW (
    HWND  hwndParent,
    DWORD iButton,
    DWORD nPropSel,
    LPTSTR lpszName,
    DWORD nType
    )
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD       status=WN_SUCCESS;
    LPPROVIDER  provider;
    BOOL        fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD       providerIndex;
    LPDWORD     index;
    DWORD       indexArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders;
    DWORD       statusFlag = 0; // used to indicate major error types
    DWORD       i;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    index = indexArray;

    //
    // Find the Provider Index associated with the drive letter in
    // the pathname (lpszName).
    // NOTE:  This function handles exceptions.
    //
    status = MprFindProviderForPath(lpszName, &providerIndex);
    if (status != WN_SUCCESS) {
        MPR_LOG1(ERROR,"WNetPropertyDialog: Couldn't find provider for this "
            "path.  Error = %d\n",status);

        //
        // Find the list of providers to call for this request.
        // Since no provider claimed this path, then
        // we need to at least try the lanman provider.
        // Actually we'll give them all a chance.
        //
        status = MprFindCallOrder(
                    NULL,
                    &index,
                    &numProviders,
                    NETWORK_TYPE);

        if (status != WN_SUCCESS) {
            return(status);
        }
    }
    else {
        numProviders = 1;
        index[0] = providerIndex;
    }

    //
    // Loop through the list of providers until one answers the request,
    // or the list is exhausted.
    //
    for (i=0; i<numProviders; i++) {
        //
        // Call the appropriate provider's API entry point
        //
        provider = GlobalProviderInfo + index[i];

        if (provider->PropertyDialog != NULL) {

            fcnSupported = TRUE;

            __try {
                status = provider->PropertyDialog(
                         hwndParent,
                         iButton,
                         nPropSel,
                         lpszName,
                         nType
                          );
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
                if (status != EXCEPTION_ACCESS_VIOLATION) {
                    MPR_LOG(ERROR,"WNetPropertyDialog:Unexpected Exception "
                    "0x%lx\n",status);
                }
                status = WN_BAD_POINTER;
            }
            if (status == WN_NO_NETWORK) {
                statusFlag |= NO_NET;
            }
            else if ((status == WN_NOT_CONNECTED)  ||
                     (status == WN_BAD_LOCALNAME)){

                statusFlag |= BAD_NAME;
            }
            else {
                //
                // If it wasn't one of those errors, then the provider
                // must have accepted responsiblity for the request.
                // so we exit and process the results.  Note that the
                // statusFlag is cleared because we want to ignore other
                // error information that we gathered up until now.
                //
                statusFlag = 0;
                break;
            }
        } // End if this provider supports PropertyDialog
    }

    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (index != indexArray) {
        LocalFree(index);
    }

    //
    // Handle special errors.
    //
    if (statusFlag == (NO_NET | BAD_NAME)) {
        //
        // Check to see if there was a mix of special errors that occured.
        // If so, pass back the combined error message.  Otherwise, let the
        // last error returned get passed back.
        //
        status = WN_NO_NET_OR_BAD_PATH;
    }

    //
    // Handle normal errors passed back from the provider
    //
    if (status != WN_SUCCESS){
        SetLastError(status);
    }

    return(status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\mprdata.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mprdata.h

Abstract:

    Contains data structures and function prototypes that are internal to
    MPR.

Author:

    Dan Lafferty (danl)     07-Sept-1991

Environment:

    User Mode -Win32

Revision History:

    05-May-1999     jschwart
        Make provider addition/removal dynamic

    01-Mar-1994     Danl
        Created a separate location for the Credential Managers GetCaps()
        function.  This way if a provider has both a credential manager
        dll and a network dll, we will be able to direct calls to the
        correct GetCaps() function.

    07-Jan-1993     Danl
        Add NPLogonNotify and NPPasswordChangeNotify and AuthentDllName
        to PROVIDER structure.  Also added CREDENTIAL_TYPE InitClass.

    04-Aug-1992     chuckc
        added MprEnterLoadLibCritSect, MprLeaveLoadLibCritSect.

    07-Sept-1991    danl
        created

--*/

//
// Includes
//


//=======================
// Data Structures
//=======================
typedef struct _PROVIDER {
    NETRESOURCE             Resource;
    DWORD                   Type;           // WNNC_NET_MSNet, WNNC_NET_LanMan, WNNC_NET_NetWare
    HMODULE                 Handle;         // Handle to the provider DLL.
    LPTSTR                  DllName;        // set to NULL after loaded.
    HMODULE                 AuthentHandle;  // Handle to authenticator DLL.
    LPTSTR                  AuthentDllName; // Authenticator Dll.
    DWORD                   InitClass;      // Network or Authentication provider.
    DWORD                   ConnectCaps;    // Cached result of GetCaps(WNNC_CONNECTION)
    DWORD                   ConnectFlagCaps;// Cached result of GetCaps(WNNC_CONNECTION_FLAGS)
    PF_NPAddConnection      AddConnection;
    PF_NPAddConnection3     AddConnection3;
    PF_NPGetReconnectFlags  GetReconnectFlags;
    PF_NPCancelConnection   CancelConnection;
    PF_NPGetConnection      GetConnection;
    PF_NPGetConnection3     GetConnection3;
    PF_NPGetUser            GetUser;
    PF_NPOpenEnum           OpenEnum;
    PF_NPEnumResource       EnumResource;
    PF_NPCloseEnum          CloseEnum;
    PF_NPGetCaps            GetCaps;
    PF_NPGetDirectoryType   GetDirectoryType;
    PF_NPDirectoryNotify    DirectoryNotify;
    PF_NPPropertyDialog     PropertyDialog;
    PF_NPGetPropertyText    GetPropertyText;
    PF_NPSearchDialog       SearchDialog;
    PF_NPFormatNetworkName  FormatNetworkName;
    PF_NPLogonNotify            LogonNotify;
    PF_NPPasswordChangeNotify   PasswordChangeNotify;
    PF_NPGetCaps            GetAuthentCaps;
    PF_NPFMXGetPermCaps     FMXGetPermCaps;
    PF_NPFMXEditPerm        FMXEditPerm;
    PF_NPFMXGetPermHelp     FMXGetPermHelp;
    PF_NPGetUniversalName   GetUniversalName;
    PF_NPGetResourceParent  GetResourceParent;
    PF_NPGetResourceInformation     GetResourceInformation;
    PF_NPGetConnectionPerformance   GetConnectionPerformance;
}PROVIDER, *LPPROVIDER;


//=======================
// MACROS
//=======================

#define IS_EMPTY_STRING(pch) ( !pch || !*(pch) )

#define LENGTH(array)   (sizeof(array)/sizeof((array)[0]))

#define INIT_IF_NECESSARY(level,status)     ASSERT(MPRProviderLock.Have());     \
                                            if(!(GlobalInitLevel & level)) {    \
                                                status = MprLevel2Init(level);  \
                                                if (status != WN_SUCCESS) {     \
                                                    SetLastError(status);       \
                                                    return(status);             \
                                                }                               \
                                            }

#define MPR_IS_INITIALIZED(level)       (GlobalInitLevel & level ## _LEVEL)

#define ASSERT_INITIALIZED(level)       ASSERT(MPR_IS_INITIALIZED(level) && \
                                               MPRProviderLock.Have());

//=======================
// INLINE FUNCTIONS
//=======================

inline void
PROBE_FOR_WRITE(
    LPDWORD pdw
    )
// WARNING: This function can throw an exception.  It must be called from
// within a try-except block.
{
    *(volatile DWORD *)pdw = *(volatile DWORD *)pdw;
}

inline BOOL
IS_BAD_BYTE_BUFFER(
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize    // in bytes
    )
// WARNING: This function can throw an exception.  It must be called from
// within a try-except block.
{
    PROBE_FOR_WRITE(lpBufferSize);
    return IsBadWritePtr(lpBuffer, *lpBufferSize);
}

inline BOOL
IS_BAD_WCHAR_BUFFER(
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize    // in Unicode characters
    )
// WARNING: This function can throw an exception.  It must be called from
// within a try-except block.
{
    PROBE_FOR_WRITE(lpBufferSize);
    return IsBadWritePtr(lpBuffer, *lpBufferSize * sizeof(WCHAR));
}

//=======================
// CONSTANTS
//=======================
#define DEFAULT_MAX_PROVIDERS   25

// Bit masks for remembering error codes
#define BAD_NAME        0x00000001
#define NO_NET          0x00000002
#define NOT_CONNECTED   0x00000004
#define NOT_CONTAINER   0x00000008
#define NO_DEVICES      0x00000010
#define OTHER_ERRS      0xFFFFFFFF

#define REDIR_DEVICE    0x00000001
#define REMOTE_NAME     0x00000002
#define LOCAL_NAME      REDIR_DEVICE

#define DA_READ         0x00000001
#define DA_WRITE        0x00000002
#define DA_DELETE       0x00000004

//
// Timeout values for restoring connections and notifying
// Credential Managers.
//
#define DEFAULT_WAIT_TIME       60000   // Default timeout if providers don't
                                        // specify.

#define MAX_ALLOWED_WAIT_TIME   300000  // Max timeout a provider can specify

#define RECONNECT_SLEEP_INCREMENT 3000  // number of seconds to sleep

#define PROVIDER_WILL_NOT_START 0x00000000 // The provider will not be starting
#define NO_TIME_ESTIMATE        0xffffffff // The provider cannot predict the
                                           // amount of time it will take to
                                           // start.

#define NET_PROVIDER_KEY         TEXT("system\\CurrentControlSet\\Control\\NetworkProvider")
#define RESTORE_WAIT_VALUE       TEXT("RestoreTimeout")
#define RESTORE_CONNECTION_VALUE TEXT("RestoreConnection")
#define DEFER_CONNECTION_VALUE   TEXT("DeferConnection")


//
// GlobalInitLevels & InitClasses
//
// NOTE:  The WN_???_CLASS values are bit masks.
//
//  GlobalInitLevel
#define FIRST_LEVEL             0x00000001
#define NETWORK_LEVEL           0x00000002
#define CREDENTIAL_LEVEL        0x00000004
#define NOTIFIEE_LEVEL          0x00000008
//
//
//  InitClasses
#define NETWORK_TYPE        WN_NETWORK_CLASS
#define CREDENTIAL_TYPE     (WN_CREDENTIAL_CLASS | WN_PRIMARY_AUTHENT_CLASS)


// The path in the registry for user's persistent connections is found in
// the following key:
//
//      "\HKEY_CURRENT_USER\Network"
//
//  Subkeys of the network section listed by local drive names.  These
//  keys contain the following values:
//      RemotePath, Type, ProviderName, UserName
//
//              d:  RemotePath = \\cyclops\scratch
//                  Type = RESOURCE_TYPE_DISK
//                  ProviderName = LanMan
//                  UserName = Ernie

#define CONNECTION_KEY_NAME           TEXT("Network")

#define REMOTE_PATH_NAME              TEXT("RemotePath")
#define USER_NAME                     TEXT("UserName")
#define PROVIDER_NAME                 TEXT("ProviderName")
#define PROVIDER_TYPE                 TEXT("ProviderType")
#define PROVIDER_FLAGS                TEXT("ProviderFlags")
#define DEFER_FLAGS                   TEXT("DeferFlags")
#define CONNECTION_TYPE               TEXT("ConnectionType")

#define PRINT_CONNECTION_KEY_NAME     TEXT("Printers\\RestoredConnections")

//=======================
// Global data
//=======================
extern LPPROVIDER       GlobalProviderInfo;   // pArray of PROVIDER Structures
extern DWORD            GlobalNumProviders;
extern DWORD            MprDebugLevel;
extern HANDLE           MprLoadLibSemaphore;  // used to protect DLL handles
extern volatile DWORD   GlobalInitLevel;
extern CRITICAL_SECTION MprErrorRecCritSec;
extern WCHAR            g_wszEntireNetwork[40];

//==========================
// Functions from support.c
//==========================


VOID
MprDeleteIndexArray(
    VOID
    );

DWORD
MprFindCallOrder(
    IN  LPTSTR      NameInfo,
    OUT LPDWORD     *IndexArrayPtr,
    OUT LPDWORD     IndexArrayCount,
    IN  DWORD       InitClass
    );

DWORD
MprDeviceType(
    IN  LPCTSTR DeviceName
    );

BOOL
MprGetProviderIndex(
    IN  LPCTSTR ProviderName,
    OUT LPDWORD IndexPtr
    );

LPPROVIDER
MprFindProviderByName(
    IN  LPCWSTR ProviderName
    );

LPPROVIDER
MprFindProviderByType(
    IN  DWORD   ProviderType
    );

DWORD
MprFindProviderForPath(
    IN  LPWSTR  lpPathName,
    OUT LPDWORD lpProviderIndex
    );

VOID
MprInitIndexArray(
    LPDWORD     IndexArray,
    DWORD       NumEntries
    );

VOID
MprEndCallOrder(
    VOID
    );

VOID
MprFreeAllErrorRecords(
    VOID
    );

BOOL
MprNetIsAvailable(
    VOID) ;

//=========================
// Functions from mprreg.c
//=========================

BOOL
MprOpenKey(
    HKEY        hKey,
    LPTSTR      lpSubKey,
    PHKEY       phKeyHandle,
    DWORD       desiredAccess
    );

BOOL
MprGetKeyValue(
    HKEY    KeyHandle,
    LPTSTR  ValueName,
    LPTSTR  *ValueString
    );

BOOL
MprGetKeyDwordValue(
    IN  HKEY    KeyHandle,
    IN  LPCWSTR ValueName,
    OUT DWORD * Value
    );

LONG
MprGetKeyNumberValue(
    IN  HKEY    KeyHandle,
    IN  LPCWSTR ValueName,
    IN  LONG    Default
    );

DWORD
MprEnumKey(
    IN  HKEY    KeyHandle,
    IN  DWORD   SubKeyIndex,
    OUT LPTSTR  *SubKeyName,
    IN  DWORD   MaxSubKeyNameLen
    );

BOOL
MprGetKeyInfo(
    IN  HKEY    KeyHandle,
    OUT LPDWORD TitleIndex OPTIONAL,
    OUT LPDWORD NumSubKeys,
    OUT LPDWORD MaxSubKeyLen,
    OUT LPDWORD NumValues OPTIONAL,
    OUT LPDWORD MaxValueLen
    );

DWORD MprGetPrintKeyInfo(HKEY    KeyHandle,
                         LPDWORD NumValueNames,
                         LPDWORD MaxValueNameLength,
                         LPDWORD MaxValueLen) ;

BOOL
MprFindDriveInRegistry (
    IN  LPCTSTR DriveName,
    OUT LPTSTR  *RemoteName
    );

DWORD
MprSaveDeferFlags(
    IN HKEY     RegKey,
    IN DWORD    DeferFlags
    );

DWORD
MprSetRegValue(
    IN  HKEY    KeyHandle,
    IN  LPTSTR  ValueName,
    IN  LPCTSTR ValueString,
    IN  DWORD   LongValue
    );

DWORD
MprCreateRegKey(
    IN  HKEY    BaseKeyHandle,
    IN  LPCTSTR KeyName,
    OUT PHKEY   KeyHandlePtr
    );

BOOL
MprReadConnectionInfo(
    IN  HKEY            KeyHandle,
    IN  LPCTSTR         DriveName,
    IN  DWORD           Index,
    OUT LPDWORD         ProviderFlags,
    OUT LPDWORD         DeferFlags,
    OUT LPTSTR          *UserNamePtr,
    OUT LPNETRESOURCEW  NetResource,
    OUT HKEY            *SubKeyHandleOut,
    IN  DWORD           MaxSubKeyLen
    );

VOID
MprForgetRedirConnection(
    IN LPCTSTR  lpName
    );

DWORD
MprForgetPrintConnection(
    IN LPTSTR   lpName
    );

BOOL
MprGetRemoteName(
    IN      LPTSTR  lpLocalName,
    IN OUT  LPDWORD lpBufferSize,
    OUT     LPTSTR  lpRemoteName,
    OUT     LPDWORD lpStatus
    ) ;

//=========================
// Functions from strbuf.c
//=========================

BOOL
NetpCopyStringToBufferW (
    IN LPTSTR String OPTIONAL,
    IN DWORD CharacterCount,
    IN LPTSTR FixedDataEnd,
    IN OUT LPTSTR *EndOfVariableData,
    OUT LPTSTR *VariableDataPointer
    );

BOOL
NetpCopyStringToBufferA (
    IN LPTSTR String OPTIONAL,
    IN DWORD CharacterCount,
    IN LPBYTE FixedDataEnd,
    IN OUT LPTSTR *EndOfVariableData,
    OUT LPTSTR *VariableDataPointer
    );

#ifdef UNICODE
#define NetpCopyStringToBuffer  NetpCopyStringToBufferW
#else
#define NetpCopyStringToBuffer  NetpCopyStringToBufferA
#endif

//=========================
// Other functions
//=========================

VOID
MprCheckProviders(
    VOID
    );


DWORD
MprLevel1Init(
    VOID
    );


DWORD
MprLevel2Init(
    DWORD   InitClass
    );


DWORD
MprEnterLoadLibCritSect (
    VOID
    ) ;

DWORD
MprLeaveLoadLibCritSect (
    VOID
    ) ;

VOID
MprClearString (
    LPWSTR  lpString
    ) ;

DWORD
MprGetConnection (
    IN      LPCWSTR lpLocalName,
    OUT     LPWSTR  lpRemoteName,
    IN OUT  LPDWORD lpBufferSize,
    OUT     LPDWORD lpProviderIndex OPTIONAL
    ) ;


DWORD
OutputStringToAnsiInPlace(
    IN  LPWSTR      UnicodeIn
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\mprreg.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MPRREG.CXX

Abstract:

    Contains functions used by MPR to manipulate the registry.
        MprOpenKey
        MprGetKeyValue
        MprEnumKey
        MprGetKeyInfo
        MprFindDriveInRegistry
        I_MprSaveConn
        MprSaveDeferFlags
        MprSetRegValue
        MprCreateRegKey
        MprReadConnectionInfo
        MprForgetRedirConnection
        MprGetRemoteName


    QUESTIONS:
    1)  Do I need to call RegFlushKey after creating a new key?

Author:

    Dan Lafferty (danl) 12-Dec-1991

Environment:

    User Mode - Win32


Revision History:

    21-Feb-1997     AnirudhS
        Change MprRememberConnection to I_MprSaveConn and MprSaveDeferFlags
        for use by setup and by DEFER_UNKNOWN.

    12-Jun-1996     AnirudhS
        Got rid of the REMOVE_COLON/RESTORE_COLON scheme for converting
        device names to registry key names, since it caused writes to
        read-only input parameters.

    08-Mar-1996     AnirudhS
        Save the provider type, not the provider name, for persistent
        connections.  Fix old heap corruption bugs that show up when the
        user profile contains incomplete info.

    16-Jun-1995     AnirudhS
        Returned DWORDs rather than BOOLs from some functions; changed some
        formal parameters from LPWSTR to LPCWSTR.

    24-Nov-1992     Danl
        Fixed compiler warnings by always using HKEY rather than HANDLE.

    03-Sept-1992    Danl
        MprGetRemoteName:  Changed ERROR_BUFFER_OVERFLOW to WN_MORE_DATA.

    12-Dec-1991     danl
        Created

--*/

//
// Includes
//
#include "precomp.hxx"
#include <malloc.h>     // _alloca
#include <tstring.h>    // MEMCPY
#include <debugfmt.h>   // FORMAT_LPTSTR
#include <wincred.h>    // CRED_MAX_USERNAME_LENGTH


//
// Macros
//

//
// STACK_ALLOC
//
// Allocates space on the stack for a copy of an input string.  The result
// could be NULL if the string is too long to be copied on the stack.
//
#define STACK_ALLOC(str)  ((LPWSTR) _alloca((wcslen(str)+1)*sizeof(WCHAR)))



VOID
RemoveColon(
    LPWSTR  pszCopy,
    LPCWSTR pszSource
    )
/*++

Routine Description:

    This function makes a copy of a string and searches through the copy
    for a colon.  If a colon is found, it is replaced by a '\0'.

Arguments:

    pszCopy - Pointer to the space for the copy.

    pszSource - Pointer to the source string.

Return Value:

    None.

--*/
{
    wcscpy(pszCopy, pszSource);
    WCHAR * pColon = wcschr(pszCopy, L':');
    if (pColon != NULL)
    {
        *pColon = L'\0';
    }
}



BOOL
MprOpenKey(
    IN  HKEY    hKey,
    IN  LPTSTR  lpSubKey,
    OUT PHKEY   phKeyHandle,
    IN  DWORD   desiredAccess
    )

/*++

Routine Description:

    This function opens a handle to a key inside the registry.  The major
    handle and the path to the subkey are required as input.

Arguments:

    hKey - This is one of the well-known root key handles for the portion
        of the registry of interest.

    lpSubKey - A pointer a string containing the path to the subkey.

    phKeyHandle - A pointer to the location where the handle to the subkey
        is to be placed.

    desiredAccess - Desired Access (Either KEY_READ or KEY_WRITE or both).

Return Value:

    TRUE - The operation was successful

    FALSE - The operation was not successful.


--*/
{

    DWORD   status;
    REGSAM  samDesired = KEY_READ;
    HKEY HKCU ;

    if(desiredAccess & DA_WRITE) {
        samDesired = KEY_READ | KEY_WRITE;
    }
    else if (desiredAccess & DA_DELETE) {
        samDesired = DELETE;
    }

    HKCU = NULL ;

    if ( hKey == HKEY_CURRENT_USER ) {
        status = RegOpenCurrentUser(
                        MAXIMUM_ALLOWED,
                        &HKCU );

        if ( status != 0 )
        {
            return FALSE ;
        }

        hKey = HKCU ;
    }

    status = RegOpenKeyEx(
            hKey,                   // hKey
            lpSubKey,               // lpSubKey
            0L,                     // ulOptions (reserved)
            samDesired,             // desired access security mask
            phKeyHandle);           // Newly Opened Key Handle

    if ( HKCU )
    {
        RegCloseKey( HKCU );
    }

    if (status != NO_ERROR) {
        MPR_LOG3(ERROR,"MprOpenKey: RegOpenKeyEx(%#lx \"%ws\") failed %d\n",
                      hKey, lpSubKey, status);
        return (FALSE);
    }
    return(TRUE);
}

BOOL
MprGetKeyValue(
    IN  HKEY    KeyHandle,
    IN  LPTSTR  ValueName,
    OUT LPTSTR  *ValueString
    )

/*++

Routine Description:

    This function takes a key handle and a value name, and returns a value
    string that is associated with that name.

    NOTE:  The pointer to the ValueString is allocated by this function.

Arguments:

    KeyHandle - This is a handle for the registry key that contains the value.

    ValueName - A pointer to a string that identifies the value being
        obtained.

    ValueString - A pointer to a location that upon exit will contain the
        pointer to the returned value.

Return Value:

    TRUE - Success

    FALSE - A fatal error occured.

--*/
{
    DWORD       status;
    DWORD       maxValueLen;
    TCHAR       Temp[1];
    LPTSTR      TempValue;
    DWORD       ValueType;
    DWORD       NumRequired;
    DWORD       CharsReturned;

    //
    // Find the buffer size requirement for the value.
    //
    status = RegQueryValueEx(
                KeyHandle,          // hKey
                ValueName,          // lpValueName
                NULL,               // lpTitleIndex
                &ValueType,         // lpType
                NULL,               // lpData
                &maxValueLen);      // lpcbData

    if (status != NO_ERROR) {
        MPR_LOG2(ERROR,"MprGetKeyValue:RegQueryValueEx(\"%ws\") failed %d\n",
                        ValueName, status);
        *ValueString = NULL;
        return(FALSE);
    }

    //
    // Allocate buffer to receive the value string.
    //
    maxValueLen += sizeof(TCHAR);

    TempValue = (LPTSTR) LocalAlloc(LMEM_FIXED, maxValueLen);

    if(TempValue == NULL) {
        MPR_LOG(ERROR,"MprGetKeyValue:LocalAlloc failed\n", 0);
        *ValueString = NULL;
        return(FALSE);
    }

    //
    // Read the value.
    //
    status = RegQueryValueEx(
                KeyHandle,          // hKey
                ValueName,          // lpValueName
                NULL,               // lpTitleIndex
                &ValueType,         // lpType
                (LPBYTE)TempValue,  // lpData
                &maxValueLen);      // lpcbData

    if (status != NO_ERROR) {
        MPR_LOG2(ERROR,"MprGetKeyValue:RegQueryValueEx(\"%ws\") failed %d\n",
                        ValueName, status);
        LocalFree(TempValue);
        *ValueString = NULL;
        return(FALSE);
    }

    //
    // Make sure the value is null-terminated.  Strings obtained from
    // the registry may or may not be null-terminated.
    //
    TempValue [ maxValueLen / sizeof(TCHAR) ] = 0;

    //========================================================
    //
    // If the value is of REG_EXPAND_SZ type, then expand it.
    //
    //========================================================

    if (ValueType != REG_EXPAND_SZ) {
        *ValueString = TempValue;
        return(TRUE);
    }

    //
    // If the ValueType is REG_EXPAND_SZ, then we must call the
    // function to expand environment variables.
    //
    MPR_LOG(TRACE,"MprGetKeyValue: Must expand the string for "
        FORMAT_LPTSTR "\n", ValueName);

    //
    // Make the first call just to get the number of characters that
    // will be returned.
    //
    NumRequired = ExpandEnvironmentStrings (TempValue,Temp, 1);

    if (NumRequired > 1) {

        *ValueString = (LPTSTR) LocalAlloc(LPTR, (NumRequired+1)*sizeof(TCHAR));

        if (*ValueString == NULL) {

            MPR_LOG(ERROR, "MprGetKeyValue: LocalAlloc of numChar= "
                FORMAT_DWORD " failed \n",NumRequired );

            (void) LocalFree(TempValue);
            return(FALSE);
        }

        CharsReturned = ExpandEnvironmentStrings (
                            TempValue,
                            *ValueString,
                            NumRequired);

        (void) LocalFree(TempValue);

        if (CharsReturned > NumRequired || CharsReturned == 0) {
            MPR_LOG(ERROR, "MprGetKeyValue: ExpandEnvironmentStrings "
                " failed for " FORMAT_LPTSTR " \n", ValueName);

            (void) LocalFree(*ValueString);
            *ValueString = NULL;
            return(FALSE);
        }

        //
        // Now insert the NUL terminator.
        //
        (*ValueString)[CharsReturned] = 0;
    }
    else {
        //
        // This call should have failed because of our ridiculously small
        // buffer size.
        //

        MPR_LOG(ERROR, "MprGetKeyValue: ExpandEnvironmentStrings "
            " Should have failed because we gave it a BufferSize=1\n",0);

        //
        // This could happen if the string was a single character long and
        // didn't really have any environment values to expand.  In this
        // case, we return the TempValue buffer pointer.
        //
        *ValueString = TempValue;
    }

    return(TRUE);

}


BOOL
MprGetKeyDwordValue(
    IN  HKEY    KeyHandle,
    IN  LPCWSTR ValueName,
    OUT DWORD * Value
    )

/*++

Routine Description:

    This function takes a key handle and a value name, and returns a DWORD
    value that is associated with that name.

Arguments:

    KeyHandle - This is a handle for the registry key that contains the value.

    ValueName - A pointer to a string that identifies the value being
        obtained.  If this value does not have REG_DWORD type the function
        returns FALSE.

    Value - A pointer to a location that upon exit will contain the returned
        DWORD value.

Return Value:

    TRUE - Success

    FALSE - A fatal error occured.

--*/
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType;
    DWORD status = RegQueryValueEx(
                        KeyHandle,
                        ValueName,
                        0,      // reserved
                        &dwType,   // type
                        (LPBYTE) Value,
                        &dwSize);

    if (status)
    {
        MPR_LOG2(ERROR,"MprGetKeyDwordValue: RegQueryValueEx(\"%ws\") failed %ld\n",
                        ValueName, status);
        return FALSE;
    }
    else if (dwType != REG_DWORD || dwSize != sizeof(DWORD))
    {
        MPR_LOG3(ERROR,"MprGetKeyDwordValue: RegQueryValueEx(\"%ws\") returned "
                       "type %ld, size %ld\n", ValueName, dwType, dwSize);
        return FALSE;
    }

    return TRUE;
}


LONG
MprGetKeyNumberValue(
    IN  HKEY    KeyHandle,
    IN  LPCWSTR ValueName,
    IN  LONG    Default
    )

/*++

Routine Description:

    This function takes a key handle and a value name, and returns a numeric
    value that is associated with that name.  If an error occurs while
    retrieving the value, the specified Default value is returned.

    For compatibility, the behavior of this function is exactly the same as
    Win95's RegEntry::GetNumber function.  The value is assumed to be a 4-byte
    type, such as REG_BINARY or REG_DWORD.  If this is not the case, the
    function does exactly the same as Win95.

Arguments:

    KeyHandle - This is a handle for the registry key that contains the value.

    ValueName - A pointer to a string that identifies the value being
        obtained.

    Default - Value to return if one could not be obtained from the registry.

Return Value:

    Value retrieved from the registry, or default if an error occurs.

--*/
{
    LONG    dwNumber;
    DWORD   dwSize = sizeof(dwNumber);

    DWORD error = RegQueryValueEx(
                        KeyHandle,
                        ValueName,
                        0,      // reserved
                        NULL,   // type
                        (LPBYTE) &dwNumber,
                        &dwSize);

    if (error)
        dwNumber = Default;

    return dwNumber;
}


BOOL
MprGetKeyStringValue(
    IN  HKEY    KeyHandle,
    IN  LPCWSTR ValueName,
    IN  DWORD   cchMaxValueLength,
    OUT LPWSTR  *Value
    )

/*++

Routine Description:

    This function takes a key handle, a value name, and a max size and allocates/returns
    a string value that is associated with that name.

Arguments:

    KeyHandle - This is a handle for the registry key that contains the value.

    ValueName - A pointer to a string that identifies the value being
        obtained.  If this value does not have REG_SZ type the function
        returns FALSE.

    cchMaxValueLength - Size of the OUT buffer to allocate, in characters.

    Value - A pointer to a location that upon exit will contain the returned
        LPWSTR value.

Return Value:

    TRUE - Success

    FALSE - A fatal error occured.

--*/
{
    DWORD status;
    DWORD dwType;
    DWORD dwSize = (cchMaxValueLength + 1) * sizeof(WCHAR);

    *Value = (LPWSTR) LocalAlloc(LMEM_ZEROINIT, dwSize);

    if (*Value == NULL)
    {
        return FALSE;
    }

    status = RegQueryValueEx(KeyHandle,
                             ValueName,
                             0,      // reserved
                             &dwType,   // type
                             (LPBYTE) *Value,
                             &dwSize);

    if (status || (dwSize % 2) != 0)
    {
        LocalFree(*Value);
        *Value = NULL;
        return FALSE;
    }

    if (dwType != REG_SZ)
    {
        //
        // Legacy -- MPR writes out a NULL username as a DWORD 0x0.  Make sure
        // these values are NULL-terminated
        //

        (*Value)[cchMaxValueLength] = L'\0';
        return TRUE;
    }

    return TRUE;
}


DWORD
MprEnumKey(
    IN  HKEY    KeyHandle,
    IN  DWORD   SubKeyIndex,
    OUT LPTSTR  *SubKeyName,
    IN  DWORD   MaxSubKeyNameLen
    )

/*++

Routine Description:

    This function obtains a single name of a subkey from the registry.
    A key handle for the primary key is passed in.  Subkeys are enumerated
    one-per-call with the passed in index indicating where we are in the
    enumeration.

    NOTE:  This function allocates memory for the returned SubKeyName.

Arguments:

    KeyHandle - Handle to the key whose sub keys are to be enumerated.

    SubKeyIndex - Indicates the number (index) of the sub key to be returned.

    SubKeyName - A pointer to the location where the pointer to the
        subkey name string is to be placed.

    MaxSubKeyNameLen - This is the length of the largest subkey.  This value
        was obtained from calling MprGetKeyInfo.  The length is in number
        of characters and does not include the NULL terminator.

Return Value:

    WN_SUCCESS - The operation was successful.

    STATUS_NO_MORE_SUBKEYS - The SubKeyIndex value was larger than the
        number of subkeys.

    error returned from LocalAlloc


--*/
{
    DWORD       status;
    FILETIME    lastWriteTime;
    DWORD       bufferSize;

    //
    // Allocate buffer to receive the SubKey Name.
    //
    // NOTE: Space is allocated for an extra character because in the case
    //  of a drive name, we need to add the trailing colon.
    //
    bufferSize = (MaxSubKeyNameLen + 2) * sizeof(TCHAR);
    *SubKeyName = (LPTSTR) LocalAlloc(LMEM_FIXED, bufferSize);

    if(*SubKeyName == NULL) {
        MPR_LOG(ERROR,"MprEnumKey:LocalAlloc failed %d\n", GetLastError());
        return(WN_OUT_OF_MEMORY);
    }

    //
    // Get the Subkey name at that index.
    //
    status = RegEnumKeyEx(
                KeyHandle,          // hKey
                SubKeyIndex,        // dwIndex
                *SubKeyName,        // lpName
                &bufferSize,        // lpcbName
                NULL,               // lpTitleIndex
                NULL,               // lpClass
                NULL,               // lpcbClass
                &lastWriteTime);    // lpftLastWriteTime

    if (status != NO_ERROR) {
        MPR_LOG(ERROR,"MprEnumKey:RegEnumKeyEx failed %d\n",status);
        LocalFree(*SubKeyName);
        return(status);
    }
    return(WN_SUCCESS);
}

BOOL
MprGetKeyInfo(
    IN  HKEY    KeyHandle,
    OUT LPDWORD TitleIndex    OPTIONAL,
    OUT LPDWORD NumSubKeys,
    OUT LPDWORD MaxSubKeyLen,
    OUT LPDWORD NumValues     OPTIONAL,
    OUT LPDWORD MaxValueLen
    )

/*++

Routine Description:



Arguments:

    KeyHandle - Handle to the key for which we are to obtain information.

    NumSubKeys - This is a pointer to a location where the number
        of sub keys is to be placed.

    MaxSubKeyLen - This is a pointer to a location where the length of
        the longest subkey name is to be placed.

    NumValues - This is a pointer to a location where the number of
        key values is to be placed. This pointer is optional and can be
        NULL.

    MaxValueLen - This is a pointer to a location where the length of
        the longest data value is to be placed.


Return Value:

    TRUE - The operation was successful.

    FALSE - A failure occured.  The returned values are not to be believed.

--*/

{
    DWORD       status;
    DWORD       maxClassLength;
    DWORD       numValueNames;
    DWORD       maxValueNameLength;
    DWORD       securityDescLength;
    FILETIME    lastWriteTime;

    //
    // Get the Key Information
    //

    status = RegQueryInfoKey(
                KeyHandle,
                NULL,                   // Class
                NULL,                   // size of class buffer (in bytes)
                NULL,                   // DWORD to receive title index
                NumSubKeys,             // number of subkeys
                MaxSubKeyLen,           // length(chars-no null) of longest subkey name
                &maxClassLength,        // length of longest subkey class string
                &numValueNames,         // number of valueNames for this key
                &maxValueNameLength,    // length of longest ValueName
                MaxValueLen,            // length of longest value's data field
                &securityDescLength,    // lpcbSecurityDescriptor
                &lastWriteTime);        // the last time the key was modified

    if (status != 0)
    {
        MPR_LOG(ERROR,"MprGetKeyInfo: RegQueryInfoKey Error %d\n",status);
        return(FALSE);
    }

    if (NumValues != NULL) {
        *NumValues = numValueNames;
    }

    //
    // Support for title index has been removed from the Registry API.
    //
    if (TitleIndex != NULL) {
        *TitleIndex = 0;
    }

    return(TRUE);
}

BOOL
MprFindDriveInRegistry (
    IN     LPCTSTR  DriveName,
    IN OUT LPTSTR   *pRemoteName
    )

/*++

Routine Description:

    This function determines whether a particular re-directed drive
    name resides in the network connection section of the current user's
    registry path.  If the drive is already "remembered" in this section,
    this function returns TRUE.

Arguments:

    DriveName - A pointer to a string containing the name of the redirected
        drive.

    pRemoteName - If the DriveName is found in the registry, and if this
        is non-null, the remote name for the connection is read, and a
        pointer to the string is stored in this pointer location.
        If the remote name cannot be read from the registry, a NULL
        pointer is returned in this location.


Return Value:

    TRUE  - The redirected drive is "remembered in the registry".
    FALSE - The redirected drive is not saved in the registry.

--*/
{
    BOOL    bStatus = TRUE;
    HKEY    connectKey = NULL;
    HKEY    subKey = NULL;

    LPWSTR  KeyName = STACK_ALLOC(DriveName);
    if (KeyName == NULL) {
        return FALSE;
    }
    RemoveColon(KeyName, DriveName);

    //
    // Get a handle for the connection section of the user's registry
    // space.
    //
    if (!MprOpenKey(
            HKEY_CURRENT_USER,
            CONNECTION_KEY_NAME,
            &connectKey,
            DA_READ)) {

        MPR_LOG(ERROR,"MprFindDriveInRegistry: MprOpenKey Failed\n",0);
        return (FALSE);
    }

    if (!MprOpenKey(
            connectKey,
            KeyName,
            &subKey,
            DA_READ)) {

        MPR_LOG(TRACE,"MprFindDriveInRegistry: Drive %s Not Found\n",DriveName);
        bStatus = FALSE;
    }
    else {
        //
        // The drive was found in the registry, if the caller wants to have
        // the RemoteName, then get it.
        //
        if (pRemoteName != NULL) {

            //
            // Get the RemoteName (memory is allocated by this function)
            //

            if(!MprGetKeyValue(
                    subKey,
                    REMOTE_PATH_NAME,
                    pRemoteName)) {

                MPR_LOG(TRACE,"MprFindDriveInRegistry: Could not read "
                    "Remote path for Drive %ws \n",DriveName);
                pRemoteName = NULL;
            }
        }
    }

    if ( subKey )
        RegCloseKey(subKey);
    if ( connectKey )
        RegCloseKey(connectKey);

    return(bStatus);
}


DWORD
I_MprSaveConn(
    IN HKEY             HiveRoot,
    IN LPCWSTR          ProviderName,
    IN DWORD            ProviderType,
    IN LPCWSTR          UserName,
    IN LPCWSTR          LocalName,
    IN LPCWSTR          RemoteName,
    IN DWORD            ConnectionType,
    IN BYTE             ProviderFlags,
    IN DWORD            DeferFlags
    )
/*++

Routine Description:

    Writes the information about a connection to the network connection
    section of a user's registry path.

    NOTE:  If connection information is already stored in the registry for
    this drive, the current information will be overwritten with the new
    information.

Arguments:

    HiveRoot - A handle to the root of the user hive in which this
        information should be written, such as HKEY_CURRENT_USER.

    ProviderName - The provider that completed the connection.

    ProviderType - The provider type, if known.  If not known, zero should
        be passed, and a type will not be written to the registry.  (This
        is used by setup when upgrading from Win95 to NT.)

    UserName - The name of the user on whose behalf the connection was made.

    LocalName - The name of the local device that is redirected, with or
        without a trailing colon, such as "J" or "J:" or "LPT1".

    RemoteName - The network path to which the connection was made.

    ConnectionType - either RESOURCETYPE_DISK or RESOURCETYPE_PRINT.

    ProviderFlags - A byte of data to be saved along with the connection,
        and passed back to the provider when the connection is restored.

    DeferFlags - A DWORD to be saved in the connection's "Defer" value.  If
        this is zero, the value is not stored.
        The meaning of the bits of this DWORD are as follows:
        DEFER_EXPLICIT_PASSWORD - a password was explicitly specified when
        the connection was made.
        DEFER_UNKNOWN - it is not known whether a password was explicitly
        specified when the connection was made.
        DEFER_DEFAULT_CRED - The provider believes that default creds were
            used when the connection was made.

Return Value:

    ERROR_SUCCESS - If the operation was successful.

    Other Win32 errors - If the operation failed in any way.  If a failure
        occurs, the information is not stored in the registry.

--*/
{
    HKEY    connectKey;
    HKEY    localDevHandle;
    LPCTSTR pUserName;
    DWORD   status, IgnoredStatus;

    //
    // Remove the colon on the name since the registry doesn't like
    // this in a key name.
    //
    LPWSTR KeyName = STACK_ALLOC(LocalName);
    if (KeyName == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RemoveColon(KeyName, LocalName);

    //
    // Get a handle for the connection section of the user's registry
    // space.
    //
    if ((status = MprCreateRegKey(
            HiveRoot,
            CONNECTION_KEY_NAME,
            &connectKey)) != ERROR_SUCCESS) {

        MPR_LOG(ERROR,"I_MprSaveConn: \\HKEY_CURRENT_USER\\network "
                      "could not be opened or created, error %ld\n", status);
        return(status);
    }

    //
    // Get (or create) the handle for the local name (without colon).
    //
    if ((status = MprCreateRegKey(
            connectKey,
            KeyName,
            &localDevHandle)) != ERROR_SUCCESS) {

        MPR_LOG(ERROR,"I_MprSaveConn: MprCreateRegKey Failed, "
                      "error %ld\n", status);
        RegCloseKey(connectKey);
        return(status);
    }


    //
    // Now that the key is created, store away the appropriate values.
    //

    MPR_LOG(TRACE,"RememberConnection: Setting RemotePath\n",0);

    if((status = MprSetRegValue(
            localDevHandle,
            REMOTE_PATH_NAME,
            RemoteName,
            0)) != ERROR_SUCCESS) {

        MPR_LOG(ERROR,
            "I_MprSaveConn: MprSetRegValueFailed %lu - RemotePath\n",status);
        goto CleanExit;
    }

    MPR_LOG(TRACE,"RememberConnection: Setting User\n",0);

    pUserName = UserName;
    if (UserName == NULL) {
        pUserName = TEXT("");
    }
    if((status = MprSetRegValue(
            localDevHandle,
            USER_NAME,
            pUserName,
            0)) != ERROR_SUCCESS) {

        goto CleanExit;
    }

    MPR_LOG(TRACE,"RememberConnection: Setting ProviderName\n",0);
    if((status = MprSetRegValue(
            localDevHandle,
            PROVIDER_NAME,
            ProviderName,
            0)) != ERROR_SUCCESS) {

        goto CleanExit;
    }

    if (ProviderType != 0)
    {
        MPR_LOG(TRACE,"RememberConnection: Setting ProviderType\n",0);
        if((status = MprSetRegValue(
                localDevHandle,
                PROVIDER_TYPE,
                NULL,
                ProviderType)) != ERROR_SUCCESS) {

            goto CleanExit;
        }
    }
    // else RegDeleteValue -- not done because ProviderType is 0 only
    // during upgrade, while writing to a fresh user hive

    MPR_LOG(TRACE,"RememberConnection: Setting ConnectionType\n",0);
    if((status = MprSetRegValue(
            localDevHandle,
            CONNECTION_TYPE,
            NULL,
            ConnectionType)) != ERROR_SUCCESS) {

        goto CleanExit;
    }

    if (ProviderFlags != 0)
    {
        MPR_LOG(TRACE,"RememberConnection: Setting ProviderFlags\n",0);
        if((status = MprSetRegValue(
                localDevHandle,
                PROVIDER_FLAGS,
                NULL,
                ProviderFlags)) != ERROR_SUCCESS) {

            goto CleanExit;
        }
    }

    // We can't roll this back if something fails after it, so we
    // must do this last
    if ((status = MprSaveDeferFlags(localDevHandle, DeferFlags))
        != ERROR_SUCCESS) {

        goto CleanExit;
    }

    //
    // Flush the new key, and then close the handle to it.
    //

    MPR_LOG(TRACE,"RememberConnection: Flushing Registry Key\n",0);

    IgnoredStatus = RegFlushKey(localDevHandle);
    if (IgnoredStatus != NO_ERROR) {
        MPR_LOG(ERROR,"RememberConnection: Flushing Registry Key Failed %ld\n",
        IgnoredStatus);
    }

CleanExit:
    RegCloseKey(localDevHandle);
    if (status != ERROR_SUCCESS) {
        IgnoredStatus = RegDeleteKey(connectKey, KeyName);
        if (IgnoredStatus != NO_ERROR) {
            MPR_LOG(ERROR, "RememberConnection: RegDeleteKey Failed %d\n", IgnoredStatus);
        }
    }
    RegCloseKey(connectKey);
    return(status);

}


DWORD
MprSaveDeferFlags(
    IN HKEY     RegKey,
    IN DWORD    DeferFlags
    )
{
    DWORD status;

    if (DeferFlags == 0)
    {
        MPR_LOG0(TRACE,"Removing DeferFlags\n");
        status = RegDeleteValue(RegKey, DEFER_FLAGS);
        if (status == ERROR_FILE_NOT_FOUND)
        {
            status = ERROR_SUCCESS;
        }
    }
    else
    {
        MPR_LOG(TRACE,"Setting DeferFlags %#lx\n",DeferFlags);
        status = MprSetRegValue(
                    RegKey,
                    DEFER_FLAGS,
                    NULL,
                    DeferFlags);
    }

    return status;
}


DWORD
MprSetRegValue(
    IN  HKEY    KeyHandle,
    IN  LPTSTR  ValueName,
    IN  LPCTSTR ValueString,
    IN  DWORD   LongValue
    )

/*++

Routine Description:

    Stores a single ValueName and associated data in the registry for
    the key identified by the KeyHandle.  The data associated with the
    value can either be a string or a 32-bit LONG.  If the ValueString
    argument contains a pointer to a value, then the LongValue argument
    is ignored.

Arguments:

    KeyHandle - Handle of the key for which the value entry is to be set.

    ValueName - Pointer to a string that contains the name of the value
        being set.

    ValueString - Pointer to a string that is to become the data stored
        at that value name.  If this argument is not present, then the
        LongValue argument is the data stored at the value name.  If this
        argument is present, then LongValue is ignored.

    LongValue - A LONG sized data value that is to be stored at the
        value name.

Return Value:

    Win32 error from RegSetValueEx (0 = success)

--*/
{
    DWORD   status;
    const BYTE * valueData;
    DWORD   valueSize;
    DWORD   valueType;

    if( ARGUMENT_PRESENT(ValueString)) {
        valueData = (const BYTE *)ValueString;
        valueSize = STRSIZE(ValueString);
        valueType = REG_SZ;
    }
    else {
        valueData = (const BYTE *)&LongValue;
        valueSize = sizeof(DWORD);
        valueType = REG_DWORD;
    }
    status = RegSetValueEx(
                KeyHandle,      // hKey
                ValueName,      // lpValueName
                0,              // dwValueTitle (OPTIONAL)
                valueType,      // dwType
                valueData,      // lpData
                valueSize);     // cbData

    if(status != NO_ERROR) {
        MPR_LOG3(ERROR,"MprSetRegValue: RegSetValueEx(%#lx \"%ws\") Failed %ld\n",
                      KeyHandle, ValueName, status);
    }
    return(status);
}


DWORD
MprCreateRegKey(
    IN  HKEY    BaseKeyHandle,
    IN  LPCTSTR KeyName,
    OUT PHKEY   KeyHandlePtr
    )

/*++

Routine Description:

    Creates a key in the registry at the location described by KeyName.

Arguments:

    BaseKeyHandle - This is a handle for the base (parent) key - where the
        subkey is to be created.

    KeyName - This is a pointer to a string that describes the path to the
        key that is to be created.

    KeyHandle - This is a pointer to a location where the the handle for the
        newly created key is to be placed.

Return Value:

    Win32 error from RegCreateKeyEx (0 = success)

Note:


--*/
{
    DWORD       status;
    DWORD       disposition;


    //
    // Create the new key.
    //
    status = RegCreateKeyEx(
                BaseKeyHandle,          // hKey
                KeyName,                // lpSubKey
                0L,                     // dwTitleIndex
                TEXT("GenericClass"),   // lpClass
                0,                      // ulOptions
                KEY_WRITE,              // samDesired (desired access)
                NULL,                   // lpSecurityAttrubutes (Security Descriptor)
                KeyHandlePtr,           // phkResult
                &disposition);          // lpulDisposition

    if (status != NO_ERROR) {
        MPR_LOG3(ERROR,"MprCreateRegKey: RegCreateKeyEx(%#lx, \"%ws\") failed %d\n",
                    BaseKeyHandle, KeyName, status);
    }
    else {
        MPR_LOG(TRACE,"MprCreateRegKey: Disposition = 0x%x\n",disposition);
    }
    return(status);
}



BOOL
MprReadConnectionInfo(
    IN  HKEY            KeyHandle,
    IN  LPCTSTR         DriveName,
    IN  DWORD           Index,
    OUT LPDWORD         ProviderFlags,
    OUT LPDWORD         DeferFlags,
    OUT LPTSTR          *UserNamePtr,
    OUT LPNETRESOURCEW  NetResource,
    OUT HKEY            *SubKeyHandleOut,
    IN  DWORD           MaxSubKeyLen
    )

/*++

Routine Description:

    This function reads the data associated with a connection key.
    Buffers are allocated to store:

        UserName, RemoteName, LocalName, Provider

    Pointers to those buffers are returned.

    Also the connection type is read and stored in the NetResource structure.

    If the provider type is found in the registry, and a matching provider
    type is found in the GlobalProviderInfo array, the provider name is not
    read from the registry.  Instead it is read from the GlobalProviderInfo
    array.

    If the provider name is read from the registry and a matching provider
    name is found in the GlobalProviderInfo array, the provider type is
    written to the registry.

Arguments:

    KeyHandle - This is an already opened handle to the key whose
        sub-keys are to be enumerated.

    DriveName - This is the local name of the drive (eg. "f:") for which
        the connection information is to be obtained.  If DriveName is
        NULL, then the Index is used to enumerate the keyname.  Then
        that keyname is used.

    Index - This is the index that identifies the subkey for which we
        would like to receive information.

    ProviderFlags - This is a pointer to a location where the ProviderFlags
        value stored with the connection will be placed.  If this value
        cannot be retrieved, 0 will be placed here.

    DeferFlags - This is a pointer to a location where the DeferFlags
        value stored with the connection will be placed.  If this value
        cannot be retrieved, 0 will be placed here.

    UserNamePtr - This is a pointer to a location where the pointer to the
        UserName string is to be placed.  If there is no user name, a
        NULL pointer will be returned.

    NetResource - This is a pointer to a NETRESOURCE structure where
        information such as lpRemoteName, lpLocalName, lpProvider, and Type
        are to be placed.

    SubKeyHandleOut - This is a pointer to a location where the handle to
        the subkey that holds information about this connection will be
        placed.  This may be NULL.  If it is not NULL the caller must close
        the handle.

Return Value:



Note:


--*/
{
    DWORD           status = NO_ERROR;
    LPTSTR          driveName = NULL;
    HKEY            subKeyHandle = NULL;
    DWORD           cbData;
    DWORD           ProviderType = 0;
    LPPROVIDER      Provider;

    //
    // Initialize the Pointers that are to be updated.
    //
    *UserNamePtr = NULL;
    NetResource->lpLocalName = NULL;
    NetResource->lpRemoteName = NULL;
    NetResource->lpProvider = NULL;
    NetResource->dwType = 0L;

    //
    // If we don't have a DriveName, then get one by enumerating the
    // next key name.
    //

    if (DriveName == NULL) {
        //
        // Get the name of a subkey of the network connection key.
        // (memory is allocated by this function).
        //
        status = MprEnumKey(KeyHandle, Index, &driveName, MaxSubKeyLen);
        if (status != WN_SUCCESS) {
            return(FALSE);
        }
    }
    else {
        //
        // We have a drive name, alloc new space and copy it to that
        // location.
        //
        driveName = (LPTSTR) LocalAlloc(LMEM_FIXED, STRSIZE(DriveName));
        if (driveName == NULL) {
            MPR_LOG(ERROR, "MprReadConnectionInfo: Local Alloc Failed %d\n",
                GetLastError());
            return(FALSE);
        }

        RemoveColon(driveName, DriveName);
    }

    MPR_LOG1(TRACE,"MprReadConnectionInfo: LocalName = %ws\n",driveName);

    //
    // Open the sub-key
    //
    if (!MprOpenKey(
            KeyHandle,
            driveName,
            &subKeyHandle,
            DA_WRITE)){

        status = WN_BAD_PROFILE;
        MPR_LOG1(TRACE,"MprReadConnectionInfo: Could not open %ws Key\n",driveName);
        goto CleanExit;
    }

    //
    // Add the trailing colon to the driveName.
    //
    cbData = STRLEN(driveName);
    driveName[cbData]   = TEXT(':');
    driveName[cbData+1] = TEXT('\0');

    //
    // Store the drive name in the return structure.
    //
    NetResource->lpLocalName = driveName;

    //
    // Get the RemoteName (memory is allocated by this function)
    //

    if(!MprGetKeyValue(
            subKeyHandle,
            REMOTE_PATH_NAME,
            &(NetResource->lpRemoteName))) {

        status = WN_BAD_PROFILE;
        MPR_LOG0(TRACE,"MprReadConnectionInfo: Could not get RemoteName\n");
        goto CleanExit;
    }

    //
    // Get the UserName (memory is allocated by this function)
    //

    if(!MprGetKeyStringValue(
            subKeyHandle,
            USER_NAME,
            CRED_MAX_USERNAME_LENGTH,
            UserNamePtr))
    {
        status = WN_BAD_PROFILE;
        MPR_LOG0(TRACE,"MprReadConnectionInfo: Could not get UserName\n");
        goto CleanExit;
    }
    else
    {
        //
        // If there is no user name (the length is 0), then set the
        // return pointer to NULL.
        //
        if (STRLEN(*UserNamePtr) == 0) {
            LocalFree(*UserNamePtr);
            *UserNamePtr = NULL;
        }
    }

    //
    // Get the Provider Type and load the providers if necessary.  Both
    // MprGetConnection and a remembered enumeration can make it to this
    // point in this state and we don't want to do a Level 2
    // initialization every time one of those functions is called simply
    // because this case _might_ be hit.  For example, calling
    // MprGetConnection on an unconnected drive letter may or may not
    // have a name associated with it in the registry.  If so, there's
    // no need to load the providers to get information from them.  This
    // is equivalent to INIT_IF_NECESSARY(NETWORK_LEVEL,status)
    //
    if (MprGetKeyDwordValue(
            subKeyHandle,
            PROVIDER_TYPE,
            &ProviderType)
        &&
        (MprLevel2Init(NETWORK_LEVEL) == WN_SUCCESS)
        &&
        ((Provider = MprFindProviderByType(ProviderType)) != NULL))
    {
        MPR_LOG(RESTORE,"MprReadConnectionInfo: Found recognized provider type %#lx\n",
                        ProviderType);
        //
        // Got a recognized provider type from the registry.
        // If we have a name for this provider in memory, use it, rather than
        // reading the name from the registry.
        // (memory is allocated for the name)
        //
        if (Provider->Resource.lpProvider != NULL)
        {
            NetResource->lpProvider =
                    (LPWSTR) LocalAlloc(0, STRSIZE(Provider->Resource.lpProvider));

            if (NetResource->lpProvider == NULL)
            {
                status = WN_BAD_PROFILE;
                MPR_LOG(RESTORE,"MprReadConnectionInfo: LocalAlloc failed %ld\n",
                              GetLastError());
                goto CleanExit;
            }

            wcscpy(NetResource->lpProvider, Provider->Resource.lpProvider);
        }
    }

    //
    // If we haven't got a provider name yet, try to read it from the registry.
    // (Memory is allocated by this function.)
    // This could legitimately happen in 2 cases:
    // (1) We are reading a profile that was created by a Windows NT 3.51 or
    // earlier machine and has not yet been converted to a 4.0 or later
    // profile.  Windows NT versions 3.51 and earlier wrote only the provider
    // name to the registry, not the type.
    // (2) We are reading a floating profile that was written by another
    // machine which has a network provider installed that isn't installed on
    // this machine.  Or, a network provider was de-installed from this
    // machine.
    //
    if (NetResource->lpProvider == NULL)
    {
        if(!MprGetKeyValue(
                subKeyHandle,
                PROVIDER_NAME,
                &(NetResource->lpProvider)))
        {
            status = WN_BAD_PROFILE;
            MPR_LOG0(RESTORE,"MprReadConnectionInfo: Could not get ProviderName\n");
            goto CleanExit;
        }

        //
        // Got a provider name from the registry.
        // If we didn't read a provider type from the registry, but we
        // recognize the provider name, write the type now for future use.
        // (This would occur in case (1) above.)
        // Failure to write the type is ignored.
        // (Pathological cases in which we get an unrecognized type but a
        // recognized name are left untouched.)
        // Since it's possible to get to this point without having the
        // providers loaded, we'll init if necessary here (see reasoning
        // above). This is equivalent to INIT_IF_NECESSARY(NETWORK_LEVEL,status)
        //
        status = MprLevel2Init(NETWORK_LEVEL);

        if (status != WN_SUCCESS) {
            goto CleanExit;
        }

        Provider = MprFindProviderByName(NetResource->lpProvider);
        if (Provider != NULL && Provider->Type != 0 && ProviderType == 0)
        {
            MPR_LOG2(RESTORE,"MprReadConnectionInfo: Setting ProviderType %#lx for %ws\n",
                            Provider->Type, driveName);

            status = MprSetRegValue(
                            subKeyHandle,
                            PROVIDER_TYPE,
                            NULL,
                            Provider->Type);

            if (status != ERROR_SUCCESS)
            {
                MPR_LOG(RESTORE,"MprReadConnectionInfo: Couldn't set ProviderType, %ld\n",
                                status);
            }
        }
    }


    //
    // Get the ProviderFlags (failure is ignored)
    //
    cbData = sizeof(DWORD);

    status = RegQueryValueEx(
                subKeyHandle,                   // hKey
                PROVIDER_FLAGS,                 // lpValueName
                NULL,                           // lpTitleIndex
                NULL,                           // lpType
                (LPBYTE)ProviderFlags,          // lpData
                &cbData);                       // lpcbData

    if (status == NO_ERROR) {
        MPR_LOG2(RESTORE,"MprReadConnectionInfo: Got ProviderFlags %#lx for %ws\n",
                 *ProviderFlags, driveName);
    }
    else {
        *ProviderFlags = 0;
    }


    //
    // Get the DeferFlags (failure is ignored)
    //
    if (MprGetKeyDwordValue(
            subKeyHandle,
            DEFER_FLAGS,
            DeferFlags
            ))
    {
        MPR_LOG2(RESTORE,"MprReadConnectionInfo: Got DeferFlags %#lx for %ws\n",
                 *DeferFlags, driveName);
    }
    else
    {
        *DeferFlags = 0;
    }


    //
    // Get the Connection Type
    //
    cbData = sizeof(DWORD);

    status = RegQueryValueEx(
                subKeyHandle,                   // hKey
                CONNECTION_TYPE,                // lpValueName
                NULL,                           // lpTitleIndex
                NULL,                           // lpType
                (LPBYTE)&(NetResource->dwType), // lpData
                &cbData);                       // lpcbData

    if (status != NO_ERROR) {
        MPR_LOG1(ERROR,"MprReadConnectionInfo:RegQueryValueEx failed %d\n",
            status);

        MPR_LOG0(TRACE,"MprReadConnectionInfo: Could not get ConnectionType\n");
        status = WN_BAD_PROFILE;
    }


CleanExit:
    if (status != NO_ERROR) {
        LocalFree(driveName);
        LocalFree(NetResource->lpRemoteName);
        LocalFree(*UserNamePtr);
        LocalFree(NetResource->lpProvider);
        NetResource->lpLocalName = NULL;
        NetResource->lpRemoteName = NULL;
        NetResource->lpProvider = NULL;
        *UserNamePtr = NULL;
        if (subKeyHandle != NULL) {
            RegCloseKey(subKeyHandle);
        }
        return(FALSE);
    }
    else {
        if (SubKeyHandleOut == NULL) {
            RegCloseKey(subKeyHandle);
        }
        else {
            *SubKeyHandleOut = subKeyHandle;
        }
        return(TRUE);
    }
}



VOID
MprForgetRedirConnection(
    IN LPCTSTR  lpName
    )

/*++

Routine Description:

    This function removes a key for the specified redirected device from
    the current users portion of the registry.

Arguments:

    lpName - This is a pointer to a redirected device name.

Return Value:


Note:


--*/
{
    DWORD   status;
    HKEY    connectKey;

    MPR_LOG(TRACE,"In MprForgetConnection for %s\n", lpName);

    LPWSTR KeyName = STACK_ALLOC(lpName);
    if (KeyName == NULL) {
        return;
    }
    RemoveColon(KeyName, lpName);

    //
    // Get a handle for the connection section of the user's registry
    // space.
    //
    if (!MprOpenKey(
            HKEY_CURRENT_USER,
            CONNECTION_KEY_NAME,
            &connectKey,
            DA_READ)) {

        MPR_LOG(ERROR,"WNetForgetRedirCon: MprOpenKey #1 Failed\n",0);
        return;
    }

    status = RegDeleteKey(connectKey, KeyName);

    if (status != NO_ERROR) {
        MPR_LOG(ERROR, "WNetForgetRedirCon: NtDeleteKey Failed %d\n", status);
    }

    //
    // Flush the connect key, and then close the handle to it.
    //

    MPR_LOG(TRACE,"ForgetRedirConnection: Flushing Connection Key\n",0);

    status = RegFlushKey(connectKey);
    if (status != NO_ERROR) {
        MPR_LOG(ERROR,"RememberConnection: Flushing Connection Key Failed %ld\n",
        status);
    }

    RegCloseKey(connectKey);

    return;
}
BOOL
MprGetRemoteName(
    IN      LPTSTR  lpLocalName,
    IN OUT  LPDWORD lpBufferSize,
    OUT     LPTSTR  lpRemoteName,
    OUT     LPDWORD lpStatus
    )
/*++

Routine Description:

    This fuction Looks in the CURRENT_USER portion of the registry for
    connection information related to the lpLocalName passed in.

Arguments:

    lpLocalName - Pointer to a string containing the name of the device to
        look up.

    lpBufferSize - Pointer to a the size information for the buffer.
        On input, this contains the size of the buffer passed in.
        if lpStatus contain WN_MORE_DATA, this will contain the
        buffer size required to obtain the full string.

    lpRemoteName - Pointer to a buffer where the remote name string is
        to be placed.

    lpStatus - Pointer to a location where the proper return code is to
        be placed in the case where the connection information exists.

Return Value:

    TRUE - If the connection information exists.

    FALSE - If the connection information does not exist.  When FALSE is
        returned, none of output parameters are valid.

--*/
{
    HKEY            connectKey;
    DWORD           numSubKeys;
    DWORD           maxSubKeyLen;
    DWORD           maxValueLen;
    DWORD           status;
    DWORD           ProviderFlags;
    DWORD           DeferFlags;
    NETRESOURCEW    netResource;
    LPTSTR          userName;


    //
    // Get a handle for the connection section of the user's registry
    // space.
    //
    if (!MprOpenKey(
            HKEY_CURRENT_USER,
            CONNECTION_KEY_NAME,
            &connectKey,
            DA_READ)) {

        MPR_LOG(ERROR,"WNetGetConnection: MprOpenKey Failed\n",0);
        return(FALSE);
    }

    if(!MprGetKeyInfo(
        connectKey,
        NULL,
        &numSubKeys,
        &maxSubKeyLen,
        NULL,
        &maxValueLen)) {

        MPR_LOG(ERROR,"WNetGetConnection: MprGetKeyInfo Failed\n",0);
        RegCloseKey(connectKey);
        return(FALSE);
    }

    //
    // Read the connection information.
    // NOTE:  This function allocates buffers for UserName and the
    //        following strings in the net resource structure:
    //          lpRemoteName,
    //          lpLocalName,
    //          lpProvider
    //
    if (MprReadConnectionInfo(
            connectKey,
            lpLocalName,
            0,
            &ProviderFlags,
            &DeferFlags,
            &userName,
            &netResource,
            NULL,
            maxSubKeyLen)) {

        //
        // The read succeeded.  Therefore we have connection information.
        //

        if (*lpBufferSize >= STRSIZE(netResource.lpRemoteName)) {

            __try {
                STRCPY(lpRemoteName, netResource.lpRemoteName);
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
                if (status != EXCEPTION_ACCESS_VIOLATION) {
                    MPR_LOG(ERROR,"WNetGetConnection:Unexpected Exception 0x%lx\n",status);
                }
                status = WN_BAD_POINTER;
            }
            if (status != WN_BAD_POINTER) {

                //
                // We successfully copied the remote name to the users
                // buffer without an error.
                //
                status = WN_SUCCESS;
            }
        }
        else {
            *lpBufferSize = STRSIZE(netResource.lpRemoteName);
            status = WN_MORE_DATA;
        }

        //
        // Free up the resources allocated by MprReadConnectionInfo.
        //

        LocalFree(userName);
        LocalFree(netResource.lpLocalName);
        LocalFree(netResource.lpRemoteName);
        LocalFree(netResource.lpProvider);

        *lpStatus = status;
        RegCloseKey(connectKey);
        return(TRUE);
    }
    else {
        //
        // The read did not succeed.
        //
        RegCloseKey(connectKey);
        return(FALSE);
    }
}

DWORD
MprGetPrintKeyInfo(
    HKEY    KeyHandle,
    LPDWORD NumValueNames,
    LPDWORD MaxValueNameLength,
    LPDWORD MaxValueLen)

/*++

Routine Description:

    This function reads the data associated with a print reconnection key.

Arguments:

    KeyHandle - This is an already opened handle to the key whose
        info is rto be queried.

    NumValueNames - Used to return the number of values

    MaxValueNameLength - Used to return the max value name length

    MaxValueLen - Used to return the max value data length

Return Value:

    0 if success. Win32 error otherwise.


Note:

--*/
{
    DWORD       err;
    DWORD       maxClassLength;
    DWORD       securityDescLength;
    DWORD       NumSubKeys ;
    DWORD       MaxSubKeyLen ;
    FILETIME    lastWriteTime;

    //
    // Get the Key Information
    //

    err = RegQueryInfoKey(
              KeyHandle,
              NULL,                   // Class
              NULL,                   // size of class buffer (in bytes)
              NULL,                   // DWORD to receive title index
              &NumSubKeys,            // number of subkeys
              &MaxSubKeyLen,          // length of longest subkey name
              &maxClassLength,        // length of longest subkey class string
              NumValueNames,          // number of valueNames for this key
              MaxValueNameLength,     // length of longest ValueName
              MaxValueLen,            // length of longest value's data field
              &securityDescLength,    // lpcbSecurityDescriptor
              &lastWriteTime);        // the last time the key was modified

    return(err);
}

DWORD
MprForgetPrintConnection(
    IN LPTSTR   lpName
    )

/*++

Routine Description:

    This function removes a rememembered print reconnection value.

Arguments:

    lpName - name of path to forget

Return Value:

    0 if success. Win32 error otherwise.


Note:

--*/
{
    HKEY  hKey ;
    DWORD err ;

    if (!MprOpenKey(
            HKEY_CURRENT_USER,
            PRINT_CONNECTION_KEY_NAME,
            &hKey,
            DA_WRITE))
    {
        return (GetLastError()) ;
    }

    err = RegDeleteValue(hKey,
                         lpName) ;

    RegCloseKey(hKey) ;
    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\mprres.h ===
//
// Resource IDs for MPR.DLL
//

//
// This is the name of the root-of-network object that shows up in the
// network neighborhood.
//
#define IDS_NETROOT     70


//
// Last-ditch error text if MultinetGetErrorText can't get the message
// (text taken from Win9x's XERR_UNKNOWN)
//
#define IDS_XERR_UNKNOWN    75
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\mprui.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    mprui.cxx

Abstract:

    Contains the entry points for the UI pieces that live in a
    separate DLL. The entry points are made available here, but
    will not load the MPRUI.DLL until it is needed.

    Contains:

Author:

    Chuck Y Chan (chuckc)   20-Jul-1992

Environment:

    User Mode -Win32

Notes:

Revision History:

    20-Jul-1992     chuckc  created

    25-Oct-1992     CongpaY     added ShowReconnectDialog

    30-Nov-1992     Yi-HsinS    added WNetSupportGlobalEnum

    12-May-1993     Danl
        WNetClearConnections: Added code to free MPRUI.DLL after calling
        the MPRUI function to clear connections.  REASON:
        This code path is called by winlogon.  It causes mprui.dll
        to get loaded.  Mprui references MPR.DLL.  Because MPRUI.DLL was never
        getting freed, winlogon could never free MPR.DLL.

    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/

#include "precomp.hxx"


/*
 * global functions
 */

BOOL MprGetProviderIndexFromDriveName(LPWSTR lpDriveName, LPDWORD lpnIndex );


/*******************************************************************

    NAME:   WNetConnectionDialog1A

    SYNOPSIS:   calls thru to the superset function

    HISTORY:
    chuckc      29-Jul-1992    Created
    brucefo 18-May-1995 Created

********************************************************************/

DWORD
WNetConnectionDialog1A(
    LPCONNECTDLGSTRUCTA lpConnDlgStruct
    )
{
    return MPRUI_WNetConnectionDialog1A(lpConnDlgStruct);
}


/*******************************************************************

    NAME:   WNetConnectionDialog1W

    SYNOPSIS:   calls thru to the superset function

    HISTORY:
    chuckc      29-Jul-1992    Created
    brucefo 18-May-1995 Created

********************************************************************/

DWORD
WNetConnectionDialog1W(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct
    )
{
    return MPRUI_WNetConnectionDialog1W(lpConnDlgStruct);
}


/*******************************************************************

    NAME:   WNetDisconnectDialog1A

    SYNOPSIS:   calls thru to the superset function

    HISTORY:
    chuckc      29-Jul-1992    Created
    brucefo 18-May-1995 Created

********************************************************************/

DWORD
WNetDisconnectDialog1A(
    LPDISCDLGSTRUCTA lpDiscDlgStruct
    )
{
    return MPRUI_WNetDisconnectDialog1A(lpDiscDlgStruct);
}


/*******************************************************************

    NAME:   WNetDisconnectDialog1W

    SYNOPSIS:   calls thru to the superset function

    HISTORY:
    chuckc      29-Jul-1992    Created
    brucefo 18-May-1995 Created

********************************************************************/

DWORD
WNetDisconnectDialog1W(
    LPDISCDLGSTRUCTW lpDiscDlgStruct
    )
{
    return MPRUI_WNetDisconnectDialog1W(lpDiscDlgStruct);
}


/*******************************************************************

    NAME:   WNetConnectionDialog

    SYNOPSIS:   calls thru to the actual implementation in MPRUI.DLL

    HISTORY:
    chuckc  29-Jul-1992    Created

********************************************************************/

DWORD
WNetConnectionDialog(
    HWND  hwnd,
    DWORD dwType
    )
{
    return MPRUI_WNetConnectionDialog(hwnd, dwType);
}


/*******************************************************************

    NAME:   WNetConnectionDialog2

    SYNOPSIS:   calls thru to the actual implementation in MPRUI.DLL

    HISTORY:
    chuckc   29-Jul-1992    Created
    JSchwart 11-Mar-2001    Readded for winfile.exe support

********************************************************************/

DWORD
WNetConnectionDialog2(
    HWND   hwnd,
    DWORD  dwType,
    LPWSTR lpHelpFile,
    DWORD  nHelpContext
    )
{
    return WNetConnectionDialog(hwnd, dwType);
}


/*******************************************************************

    NAME:   WNetDisconnectDialog

    SYNOPSIS:   calls thru to the actual implementation in MPRUI.DLL

    HISTORY:
    chuckc  29-Jul-1992    Created

********************************************************************/

DWORD
WNetDisconnectDialog(
    HWND  hwnd,
    DWORD dwType
    )
{
    return MPRUI_WNetDisconnectDialog(hwnd, dwType);
}


/*******************************************************************

    NAME:   WNetConnectionDialog2

    SYNOPSIS:   calls thru to the actual implementation in MPRUI.DLL

    HISTORY:
    chuckc   29-Jul-1992    Created
    JSchwart 11-Mar-2001    Readded for winfile.exe support

********************************************************************/

DWORD
WNetDisconnectDialog2(
    HWND   hwnd,
    DWORD  dwType,
    LPWSTR lpHelpFile,
    DWORD  nHelpContext
    )
{
    return WNetDisconnectDialog(hwnd, dwType);
}


/*******************************************************************

    NAME:   WNetClearConnections

    SYNOPSIS:   calls thru to the actual implementation in MPRUI.DLL

    HISTORY:
    chuckc  29-Jul-1992    Created

********************************************************************/

DWORD
WNetClearConnections(
    HWND hWndParent
    )
{
    return MPRUI_WNetClearConnections(hWndParent);
}


/*******************************************************************

    NAME:   DoPasswordDialog

    SYNOPSIS:   calls thru to the actual implementation in MPRUI.DLL

    HISTORY:
    chuckc  29-Jul-1992    Created

********************************************************************/

DWORD
DoPasswordDialog(
    HWND          hwndOwner,
    LPWSTR        pchResource,
    LPWSTR        pchUserName,
    LPWSTR        pchPasswordReturnBuffer,
    ULONG         cbPasswordReturnBuffer, // bytes!
    BOOL *        pfDidCancel,
    DWORD         dwError
    )
{
    return MPRUI_DoPasswordDialog(hwndOwner,
                                  pchResource,
                                  pchUserName,
                                  pchPasswordReturnBuffer,
                                  cbPasswordReturnBuffer,
                                  pfDidCancel,
                                  dwError);
}


/*******************************************************************

    NAME:   DoProfileErrorDialog

    SYNOPSIS:   calls thru to the actual implementation in MPRUI.DLL

    HISTORY:
    chuckc  29-Jul-1992    Created

********************************************************************/

DWORD
DoProfileErrorDialog(
    HWND          hwndOwner,
    const TCHAR * pchDevice,
    const TCHAR * pchResource,
    const TCHAR * pchProvider,
    DWORD         dwError,
    BOOL          fAllowCancel,
    BOOL *        pfDidCancel,
    BOOL *        pfDisconnect,
    BOOL *        pfHideErrors
    )
{
    return MPRUI_DoProfileErrorDialog(hwndOwner,
                                      pchDevice,
                                      pchResource,
                                      pchProvider,
                                      dwError,
                                      fAllowCancel,
                                      pfDidCancel,
                                      pfDisconnect,
                                      pfHideErrors);
}


/*******************************************************************

    NAME:   ShowReconnectDialog

    SYNOPSIS:   calls thru to the actual implementation in MPRUI.DLL

    HISTORY:
    congpay 25-Oct-1992    Created

********************************************************************/

DWORD
ShowReconnectDialog(
    HWND          hwndParent,
    PARAMETERS    *Params
    )
{
    return MPRUI_ShowReconnectDialog(hwndParent, Params);
}


/*******************************************************************

    NAME:   WNetGetSearchDialog

    SYNOPSIS:   gets the pointer to NPSearchDialog() from named provider

    ENTRY:  Assumes the provider table in router has been setup,
        which is always the case after DLL init.

        lpProvider - name of provider to query

    EXIT:

    NOTES:

    HISTORY:
    chuckc  19-Mar-1992    Created

********************************************************************/

FARPROC WNetGetSearchDialog(LPWSTR lpProvider)
{
    ULONG   index ;
    BOOL    fOK ;
    DWORD   status;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    //
    // INIT_IF_NECESSARY
    //
    if (!(GlobalInitLevel & NETWORK_LEVEL)) {
        status = MprLevel2Init(NETWORK_LEVEL);
        if (status != WN_SUCCESS) {
            return(NULL);
        }
    }

    if (lpProvider == NULL)
        return NULL ;

    fOK =  MprGetProviderIndex(lpProvider, &index) ;

    if  (!fOK)
       return(NULL) ;

    return((FARPROC)GlobalProviderInfo[index].SearchDialog) ;
}

/*******************************************************************

    NAME:   WNetSupportGlobalEnum

    SYNOPSIS:   Check if the provider supports global enumeration

    ENTRY:  Assumes the provider table in router has been setup,
        which is always the case after DLL init.

        lpProvider - name of provider to query

    EXIT:

    NOTES:

    HISTORY:
    Yi-HsinS    30-Nov-1992    Created

********************************************************************/

BOOL WNetSupportGlobalEnum( LPWSTR lpProvider )
{
    MprCheckProviders();

    CProviderSharedLock    PLock;

    //
    // INIT_IF_NECESSARY
    //
    DWORD   status;
    if (!(GlobalInitLevel & NETWORK_LEVEL)) {
        status = MprLevel2Init(NETWORK_LEVEL);
        if (status != WN_SUCCESS) {
            return(FALSE);
        }
    }

    if ( lpProvider != NULL )
    {
        ULONG index;

        if (  MprGetProviderIndex( lpProvider, &index )
           && ( GlobalProviderInfo[index].GetCaps(WNNC_ENUMERATION)
                & WNNC_ENUM_GLOBAL )
           )
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*******************************************************************

    NAME:   WNetFMXGetPermCaps

    SYNOPSIS:  Gets the permission capabilites from the provider
               supporting the given drive.

    ENTRY:  Assumes the provider table in router has been setup,
        which is always the case after DLL init.

        lpDriveName - Name of drive

    EXIT:
        Returns a bitmask representing the permission capabilities
        of the provider.

    NOTES:

    HISTORY:
        YiHsinS  11-Apr-1994    Created

********************************************************************/

DWORD WNetFMXGetPermCaps( LPWSTR lpDriveName )
{
    ULONG   index ;
    BOOL    fOK ;
    DWORD   status;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    //
    // INIT_IF_NECESSARY
    //
    if (!(GlobalInitLevel & NETWORK_LEVEL))
    {
        status = MprLevel2Init(NETWORK_LEVEL);
        if (status != WN_SUCCESS)
            return 0;
    }

    if ( lpDriveName != NULL)
    {
        fOK = MprGetProviderIndexFromDriveName( lpDriveName, &index);

        if (  fOK
           && ( GlobalProviderInfo[index].FMXGetPermCaps != NULL )
           )
        {
            return( GlobalProviderInfo[index].FMXGetPermCaps( lpDriveName));
        }
    }

    return 0;
}

/*******************************************************************

    NAME:   WNetFMXEditPerm

    SYNOPSIS: Asks the provider supporting the given drive to pop up
              its own permission editor.

    ENTRY:  Assumes the provider table in router has been setup,
        which is always the case after DLL init.

        lpDriveName - Name of drive
        hwndFMX - Handle of the FMX window in File Manager
        nDialogType - Specify the type of permission dialog to bring up.
                      It can be one of the following values:
                          WNPERM_DLG_PERM
                          WNPERM_DLG_AUDIT
                          WNPERM_DLG_OWNER

    EXIT:
        Returns WN_SUCCESS or any error that occurred

    NOTES:

    HISTORY:
        YiHsinS  11-Apr-1994    Created

********************************************************************/

DWORD WNetFMXEditPerm( LPWSTR lpDriveName, HWND hwndFMX, DWORD nDialogType )
{
    ULONG   index ;
    BOOL    fOK ;
    DWORD   status = WN_SUCCESS;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    //
    // INIT_IF_NECESSARY
    //
    if (!(GlobalInitLevel & NETWORK_LEVEL))
    {
        status = MprLevel2Init(NETWORK_LEVEL);
        if (status != WN_SUCCESS)
            return status;
    }

    //
    // Check input parameters
    //
    if (  ( lpDriveName == NULL)
       || ( hwndFMX == NULL )
       || ( nDialogType != WNPERM_DLG_PERM
          && nDialogType != WNPERM_DLG_AUDIT
          && nDialogType != WNPERM_DLG_OWNER )
       )
    {
        status = WN_BAD_VALUE;
    }
    else
    {
        fOK = MprGetProviderIndexFromDriveName( lpDriveName, &index) ;

        if ( !fOK )
        {
            status = WN_NO_NET_OR_BAD_PATH;
        }
        else
        {
            if ( GlobalProviderInfo[index].FMXEditPerm == NULL )
                status = WN_NOT_SUPPORTED;

            else
                status = GlobalProviderInfo[index].FMXEditPerm( lpDriveName,
                                                                hwndFMX,
                                                                nDialogType );
        }
    }

    if ( status != WN_SUCCESS )
        SetLastError( status );

    return status;
}

/*******************************************************************

    NAME:   WNetFMXGetPermHelp

    SYNOPSIS: Requests the provider supporting the given drive for
              the help file name and help context for the menu item
              with the given type of permission dialog.
              i.e. the help when F1 is pressed when a menu item is
              selected.


    ENTRY:  Assumes the provider table in router has been setup,
        which is always the case after DLL init.

        lpDriveName - Name of drive
        nDialogType - Specify the type of help requested.
                      It can be one of the following values:
                          WNPERM_DLG_PERM
                          WNPERM_DLG_AUDIT
                          WNPERM_DLG_OWNER
        fDirectory - TRUE if the selected item is a directory, FALSE otherwise
        lpFileNameBuffer - Pointer to buffer that will receive the
                      help file name
        lpBufferSize   - Specify the size of lpBuffer
        lpnHelpContext - Points to a DWORD that will receive the help context

    EXIT:
        Returns WN_SUCCESS or any error that occurred

    NOTES:

    HISTORY:
        YiHsinS  11-Apr-1994    Created

********************************************************************/

DWORD WNetFMXGetPermHelp( LPWSTR  lpDriveName,
                          DWORD   nDialogType,
                          BOOL    fDirectory,
                          LPVOID  lpFileNameBuffer,
                          LPDWORD lpBufferSize,
                          LPDWORD lpnHelpContext )
{
    ULONG   index ;
    BOOL    fOK ;
    DWORD   status = WN_SUCCESS;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    //
    // INIT_IF_NECESSARY
    //
    if (!(GlobalInitLevel & NETWORK_LEVEL))
    {
        status = MprLevel2Init(NETWORK_LEVEL);
        if (status != WN_SUCCESS)
            return status;
    }

    //
    // Check input parameters
    //
    if (  ( lpDriveName == NULL)
       || ( nDialogType != WNPERM_DLG_PERM
          && nDialogType != WNPERM_DLG_AUDIT
          && nDialogType != WNPERM_DLG_OWNER )
       )
    {
        status = WN_BAD_VALUE;
    }
    else
    {
        fOK = MprGetProviderIndexFromDriveName( lpDriveName, &index) ;

        if ( !fOK )
        {
            status = WN_NO_NET_OR_BAD_PATH;
        }
        else
        {
            if ( GlobalProviderInfo[index].FMXGetPermHelp == NULL )
                status = WN_NOT_SUPPORTED;
            else
                status = GlobalProviderInfo[index].FMXGetPermHelp(
                                                       lpDriveName,
                                                       nDialogType,
                                                       fDirectory,
                                                       lpFileNameBuffer,
                                                       lpBufferSize,
                                                       lpnHelpContext );
        }
    }

    if ( status != WN_SUCCESS )
        SetLastError( status );

    return status;
}

/*******************************************************************

    NAME:  MprGetProviderIndexFromDriveName

    SYNOPSIS:  Gets the index of the provider in the provider array
               supporting the drive name connection.

    ENTRY:
        lpDriveName - Name of the drive
        lpnIndex    - Points to a DWORD that will receive the index

    EXIT:
        TRUE if we successfully retrieved the index, FALSE otherwise.

    NOTES:

    HISTORY:
        YiHsinS  11-Apr-1994    Created

********************************************************************/

BOOL MprGetProviderIndexFromDriveName(LPWSTR lpDriveName, LPDWORD lpnIndex )
{
    DWORD  status;
    WCHAR  szRemoteName[MAX_PATH];
    DWORD  nBufferSize = sizeof(szRemoteName);

    status = MprGetConnection( lpDriveName,
                               szRemoteName,
                               &nBufferSize,
                               lpnIndex );

    //
    // *lpnIndex will be correct if status is WN_SUCCESS or WN_MORE_DATA
    // and we don't really need the remote name. Hence, we don't need to
    // call MprGetConnection again with a bigger buffer if WN_MORE_DATA
    // is returned.
    //

    return ( status == WN_SUCCESS || status == WN_MORE_DATA );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\mprtest.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mprtest.cxx

Abstract:

    Test routine for MPR entry Points.

Author:

    Dan Lafferty (danl)     17-Dec-1991

Environment:

    User Mode -Win32

Revision History:

    17-Dec-1991     danl
        created
--*/

#include "precomp.hxx"
extern "C" {
#include <ntmsv1_0.h>
}
#include <stdlib.h>     // atoi
#include <stdio.h>      // printf
#include <conio.h>      // getch
#include <string.h>     // strcmp
#include <tstr.h>       // Unicode

#include <debugfmt.h>   // FORMAT_LPTSTR

//
// Defines
//

#define ERR_BUF_SIZE    260
#define NAME_BUF_SIZE   260

//
// Local Functions
//
BOOL
ProcessArgs(
    DWORD   argc,
    LPTSTR  argv[]
    );

VOID
RecursiveEnum(
    DWORD           RecursionLevel,
    DWORD           ResourceUsage,
    LPNETRESOURCE   EnumNetResource
    );

BOOL
ConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPSTR   AnsiIn
    );

BOOL
GetStringFromFile(
    LPDWORD     LoopCount,
    LPSTR       buffer
    );

BOOL
MakeArgsUnicode (
    DWORD           argc,
    PCHAR           argv[]
    );

VOID
TestAddConnect2(
    LPTSTR  RemoteName,
    LPTSTR  RedirName);

VOID
TestAddConnect3(
    LPTSTR  RemoteName,
    LPTSTR  RedirName);

VOID
TestGetConnect(
    LPTSTR  lpDeviceName,
    DWORD   bufferSize);

VOID
TestGetUniversal(
    LPTSTR  lpDeviceName,
    DWORD   level,
    DWORD   bufferSize);

VOID
TestGetUser(
    LPTSTR  lpDevice,
    DWORD   bufferSize);

VOID
TestEnumConnect(
    DWORD  scope,
    DWORD  type);

VOID
TestEnumNet(VOID);

VOID
TestSetError(VOID);

VOID
TestMultiError(VOID);

VOID
TestDirStuff(VOID);

VOID
TestRestoreConnect(
    LPTSTR  lpDrive);

VOID
TestLotsOfStuff(VOID);


VOID
DisplayExtendedError(VOID);

VOID
DisplayMultiError(VOID);


VOID
DisplayResourceArray(
    LPNETRESOURCE   NetResource,
    DWORD           NumElements
    );

VOID
DisplayResource(
    LPNETRESOURCE   NetResource
    );

VOID
TestClearConnect(
    VOID
    );

VOID
Usage(VOID);

VOID
InvalidParms(VOID);

LONG
wtol(
    IN LPWSTR string
    );

VOID
TestLogonNotify(
    LPTSTR  argv[],
    DWORD   argc
    );

VOID
TestChangePassword(
    LPTSTR  argv[],
    DWORD   argc
    );


VOID __cdecl
main (
    VOID
    )

/*++

Routine Description:

    Allows manual testing of the MPR API.

        mprtest



Arguments:



Return Value:



--*/
{
    UCHAR   i;
    DWORD   j;
    LPTSTR  *argv;
    CHAR    buffer[255];
    LPSTR   argvA[20];
    DWORD   argc=0;
    BOOL    KeepGoing;
    DWORD   LoopCount = 0;

    do {
        //
        // Get input from the user
        //
        buffer[0] = 90-2;

        if (LoopCount != 0) {
            GetStringFromFile(&LoopCount, buffer);
            printf("%s\n",buffer+2);
        }
        else {
            printf("\nwaiting for instructions... \n");
            cgets(buffer);
        }
        if (buffer[1] > 0) {
            //
            // put the string in argv/argc format.
            //
            buffer[1]+=2;       // make this an end offset
            argc=0;
            for (i=2,j=0; i<buffer[1]; i++,j++) {
                argc++;
                argvA[j] = &(buffer[i]);
                while ((buffer[i] != ' ') && (buffer[i] != '\0')) {
                    i++;
                }
                buffer[i] = '\0';
            }

            //
            // Make the arguments unicode if necessary.
            //
#ifdef UNICODE

            if (!MakeArgsUnicode(argc, argvA)) {
                return;
            }

#endif
            argv = (LPTSTR *)argvA;

            if (STRICMP (argv[0], TEXT("Loop")) == 0) {
                if (argc == 1) {
                    LoopCount=1;
                }
                else {
#ifdef UNICODE
                    LoopCount = wtol(argv[1]);
#else
                    LoopCount = atol(argv[1]);
#endif
                }
                KeepGoing  = TRUE;
            }
            else if (STRICMP (argv[0], TEXT("done")) == 0) {
                LoopCount=0;
                KeepGoing  = TRUE;
            }
            else {
                KeepGoing = ProcessArgs(argc, argv);
            }
#ifdef UNICODE
            //
            // Free up the unicode strings if there are any
            //
            for(j=0; j<argc; j++) {
                LocalFree(argv[j]);
            }
#endif
        }
    } while (KeepGoing);

    return;
}

BOOL
ProcessArgs(
    DWORD   argc,
    LPTSTR  argv[]
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD   status;
    LPTSTR  remoteName;
    LPTSTR  redirName;
    DWORD   i;
    DWORD   type;


    //
    // Check Arguments
    //
    if (*argv[0] == TEXT('\0')) {
        printf("ERROR: no function was requested!\n");
        Usage();
        return(TRUE);
    }

    //
    // Make the arguments unicode if necessary.
    //
    //**************
    // AddConnect1
    //**************
    if (STRICMP (argv[0], TEXT("AddConnect1")) == 0) {
        //
        // If the connection information was passed in, use it.  Otherwise,
        // use the default.
        //
        if (argc == 3) {
            remoteName = argv[2];
            redirName = argv[1];
        }
        else {
            remoteName = TEXT("\\\\popcorn\\public");
            redirName = TEXT("f:");
        }

        //
        // Add the Connection.
        //
        status = WNetAddConnection(
                    remoteName,
                    NULL,
                    redirName);

        if ( status != WN_SUCCESS) {
            printf("WNetAddConnection failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
        }
        else {
            printf("WNetAddConnection Success\n");
        }
    }

    //**************
    // AddConnect2
    //**************
    else if (STRICMP (argv[0], TEXT("AddConnect2")) == 0) {
        //
        // If the connection information was passed in, use it.  Otherwise,
        // use the default.
        //
        if (argc == 3) {
            remoteName = argv[2];
            redirName = argv[1];
        }
        else {
            remoteName = TEXT("\\\\popcorn\\public");
            redirName = TEXT("f:");
        }

        //
        // Call the test program
        //
        TestAddConnect2(remoteName, redirName);
        printf("Call it again without a redirected drive letter\n");
        TestAddConnect2(remoteName, NULL);
    }

    //**************
    // AddConnect3
    //**************
    else if (STRICMP (argv[0], TEXT("AddConnect3")) == 0) {
        //
        // If the connection information was passed in, use it.  Otherwise,
        // use the default.
        //
        if (argc == 3) {
            remoteName = argv[2];
            redirName = argv[1];
        }
        else {
            remoteName = TEXT("\\\\popcorn\\public");
            redirName = TEXT("f:");
        }

        //
        // Call the test program
        //
        TestAddConnect3(remoteName, redirName);
        printf("Call it again without a redirected drive letter\n");
        TestAddConnect3(remoteName, NULL);
    }

    //**************
    // CancelConnect
    //**************
    else if (STRICMP (argv[0], TEXT("CancelConnect")) == 0) {
        BOOL    rememberFlag = FALSE;
        BOOL    ForceFlag = FALSE;

        //
        // See if the redirected name was passed in.
        //
        if (argc >= 2) {
            redirName = argv[1];
        }
        else {
            redirName = TEXT("f:");
        }
        for (i=2; argc>i; i++) {
            if (STRICMP (argv[i], TEXT("r")) ==0) {
                rememberFlag = TRUE;
            }
            if (STRICMP (argv[i], TEXT("f")) ==0) {
                ForceFlag = TRUE;
            }
        }

        if (rememberFlag) {
            status = WNetCancelConnection(redirName, ForceFlag);
        }
        else {
            status = WNetCancelConnection2(redirName, 0, ForceFlag);
        }

        if ( status != WN_SUCCESS) {
            printf("WNetCancelConnection failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
        }
        else {
            printf("WNetCancelConnection Success\n");
        }
    }

    //**************
    // GetConnect
    //**************
    else if (STRICMP (argv[0], TEXT("GetConnect")) == 0) {

        LPTSTR  deviceName = NULL;
        DWORD   bufSize = NAME_BUF_SIZE;

        if (argc >= 2) {
            deviceName = argv[1];
        }
        if (argc >= 3) {
            bufSize = ATOL(argv[2]);
        }

        TestGetConnect( deviceName, bufSize);
    }

    //******************
    // GetUniversalName
    //******************
    else if (STRICMP (argv[0], TEXT("GetUniversalName")) == 0) {

        LPTSTR  deviceName = NULL;
        DWORD   bufSize = NAME_BUF_SIZE;
        DWORD   infoLevel = UNIVERSAL_NAME_INFO_LEVEL;

        if (argc >= 2) {
            deviceName = argv[1];
        }
        if (argc >= 3) {
            infoLevel = ATOL(argv[2]);
        }
        if (argc >= 4) {
            bufSize = ATOL(argv[3]);
        }

        TestGetUniversal( deviceName, infoLevel, bufSize);
    }

    //**************
    // GetUser
    //**************
    else if (STRICMP (argv[0], TEXT("GetUser")) == 0) {

        LPTSTR  deviceName = NULL;
        DWORD   bufSize = NAME_BUF_SIZE;

        i=1;
        while (argc > (i)) {

            if (STRICMP(argv[i], TEXT("bufSize=")) == 0) {
                bufSize = ATOL(argv[i+1]);
                i++;
            }
            if (STRICMP(argv[i], TEXT("device=")) == 0) {
                deviceName = argv[i+1];
                i++;
            }
            i++;
        }

        TestGetUser(deviceName,bufSize);

    }

    //**************
    // Enum
    //**************
    else if (STRICMP (argv[0], TEXT("EnumConnect")) == 0 ||
             STRICMP (argv[0], TEXT("EnumContext")) == 0) {

        DWORD scope = STRICMP (argv[0], TEXT("EnumConnect")) ?
                            RESOURCE_CONTEXT : RESOURCE_CONNECTED;
        type = RESOURCETYPE_ANY;

        for (i=1; i<argc; i++) {
            if (STRICMP(argv[i], TEXT("r")) == 0) {
                scope = RESOURCE_REMEMBERED;
            }
            else if (STRICMP(argv[i], TEXT("ANY")) == 0) {
                type = RESOURCETYPE_ANY;
            }
            else if (STRICMP(argv[i], TEXT("DISK")) == 0) {
                type = RESOURCETYPE_DISK;
            }
            else if (STRICMP(argv[i], TEXT("PRINT")) == 0) {
                type = RESOURCETYPE_PRINT;
            }
            else {
                printf("Bad argument\n");
                Usage();
                return(TRUE);
            }
        }
        TestEnumConnect(scope, type);

    }
    else if (STRICMP (argv[0], TEXT("EnumNet")) == 0) {
        RecursiveEnum(0, 0, NULL);
        //TestEnumNet();
    }
    //**************
    // SetLastError
    //**************
    else if (STRICMP (argv[0], TEXT("SetError")) == 0) {
        TestSetError();
    }

    //*********************
    // MultinetGetErrorText
    //*********************
    else if (STRICMP (argv[0], TEXT("MultiError")) == 0) {
        TestMultiError();
    }

    //************************************
    // GetDirectoryType & DirectoryNotify
    //************************************
    else if (STRICMP (argv[0], TEXT("DirApi")) == 0) {
        TestDirStuff();
    }

    //****************
    // RestoreConnect
    //****************
    else if (STRICMP (argv[0], TEXT("RestoreConnect")) == 0) {

        if (argc == 2) {
            TestRestoreConnect(argv[1]);
        }
        else {
            TestRestoreConnect(NULL);
        }
    }
    //****************
    // ClearConnect
    //****************
    else if (STRICMP (argv[0], TEXT("ClearConnect")) == 0) {

        TestClearConnect();
    }
    //****************
    // LogonNotify
    //****************
    else if (STRICMP (argv[0], TEXT("LogonNotify")) == 0) {

        TestLogonNotify(&argv[1],argc-1);
    }
    //****************
    // LogonNotify
    //****************
    else if (STRICMP (argv[0], TEXT("ChangePassword")) == 0) {

        TestChangePassword(&argv[1],argc-1);
    }
    //************************************
    // ALL
    //************************************
    else if (STRICMP (argv[0], TEXT("all")) == 0) {
        TestLotsOfStuff();
    }

    //****************
    // InvalidParms
    //****************
    else if (STRICMP (argv[0], TEXT("InvalidParms")) == 0) {
        InvalidParms();
    }

    //****************
    // Exit Program
    //****************
    else if (STRICMP (argv[0], TEXT("Exit")) == 0) {
        return(FALSE);
    }


    else {
        printf("Bad argument\n");
        Usage();
    }

    return(TRUE);
}

VOID
TestAddConnect2(
    LPTSTR   RemoteName,
    LPTSTR   RedirName)
{
    LPNETRESOURCE   netResource;
    DWORD           status;
    DWORD           numchars = 0;

    netResource = (LPNETRESOURCE) LocalAlloc(LPTR, sizeof(NETRESOURCE));

    if (netResource == NULL) {
        printf("TestAddConnect2:LocalAlloc Failed %d\n",GetLastError);
        return;
    }

    netResource->lpRemoteName = RemoteName;
    netResource->lpLocalName  = RedirName;

    if (RedirName != NULL) {
        numchars = STRLEN(RedirName);
    }

    if (numchars == 0) {
        netResource->dwType = RESOURCETYPE_ANY;
    }
    else if (numchars > 2) {
        netResource->dwType = RESOURCETYPE_PRINT;
    }
    else {
        netResource->dwType = RESOURCETYPE_DISK;
    }

    status = WNetAddConnection2(
                netResource,
                NULL,
                NULL,
                0L);

    if ( status != WN_SUCCESS) {
        printf("WNetAddConnection2 failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
    }
    else {
        printf("WNetAddConnection2 Success\n");
    }
    LocalFree(netResource);
    return;
}

VOID
TestAddConnect3(
    LPTSTR   RemoteName,
    LPTSTR   RedirName)
{
    LPNETRESOURCE   netResource;
    DWORD           status;
    DWORD           numchars = 0;

    netResource = (LPNETRESOURCE) LocalAlloc(LPTR, sizeof(NETRESOURCE));

    if (netResource == NULL) {
        printf("TestAddConnect3:LocalAlloc Failed %d\n",GetLastError);
        return;
    }

    netResource->lpRemoteName = RemoteName;
    netResource->lpLocalName  = RedirName;

    if (RedirName != NULL) {
        numchars = STRLEN(RedirName);
    }

    if (numchars == 0) {
        netResource->dwType = RESOURCETYPE_ANY;
    }
    else if (numchars > 2) {
        netResource->dwType = RESOURCETYPE_PRINT;
    }
    else {
        netResource->dwType = RESOURCETYPE_DISK;
    }

    status = WNetAddConnection3(
                (HWND)0x33113322,
                netResource,
                NULL,
                NULL,
                0L);

    if ( status != WN_SUCCESS) {
        printf("WNetAddConnection3 failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
    }
    else {
        printf("WNetAddConnection3 Success\n");
    }
    LocalFree(netResource);
    return;
}

VOID
TestGetConnect(
    LPTSTR   lpDeviceName,
    DWORD    bufferSize)
{
    LPTSTR  remoteName = NULL;
    DWORD   status;
    TCHAR   defaultDevice[]=TEXT("f:");
    LPTSTR  lpDevice;


    if (lpDeviceName == NULL) {
        lpDevice = defaultDevice;
    }
    else {
        lpDevice = lpDeviceName;
    }
    remoteName = (LPTSTR)LocalAlloc(LMEM_FIXED, bufferSize);
    if (remoteName == NULL) {
        printf("TestGetConnect: Couldn't allocate memory\n");
        return;
    }

    //
    // 1st Time
    //
    status = WNetGetConnection(
                lpDevice,
                remoteName,
                &bufferSize);

    if (( status != WN_SUCCESS) && (status != ERROR_CONNECTION_UNAVAIL)) {
        printf("WNetGetConnection failed %d\n",status);
        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        //
        // If insufficient buffer, display needed size.
        //
        if (status == WN_MORE_DATA) {
            printf("Insufficient buffer size.  Need %d bytes\n",bufferSize);
        }
    }
    else {
        if (status == ERROR_CONNECTION_UNAVAIL) {
            printf("Not Currently Connected, but it is remembered\n");
        }
        else {
            printf("WNetGetConnection Success\n");
        }
        printf(""FORMAT_LPTSTR" is connected to "FORMAT_LPTSTR"\n",lpDevice,remoteName);
    }

    //
    // 2nd Time
    //
    if (remoteName != NULL) {
        LocalFree(remoteName);
    }
    printf("Allocating a new buffer of %d bytes\n",bufferSize);
    remoteName = (LPTSTR)LocalAlloc(LMEM_FIXED, bufferSize);
    if (remoteName == NULL) {
        printf("TestGetConnect: Couldn't allocate memory(2nd time)\n");
        return;
    }

    status = WNetGetConnection(
                lpDevice,
                remoteName,
                &bufferSize);

    if (( status != WN_SUCCESS) && (status != ERROR_CONNECTION_UNAVAIL)) {
        printf("WNetGetConnection failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        //
        // If insufficient buffer, display needed size.
        //
        if (status == WN_MORE_DATA) {
            printf("Insufficient buffer size.  Need %d bytes\n",bufferSize);
        }
    }
    else {
        if (status == ERROR_CONNECTION_UNAVAIL) {
            printf("Not Currently Connected, but it is remembered\n");
        }
        else {
            printf("WNetGetConnection Success\n");
        }
        printf(""FORMAT_LPTSTR" is connected to "FORMAT_LPTSTR"\n",lpDevice,remoteName);
    }
    if (remoteName != NULL) {
        LocalFree(remoteName);
    }
    return;
}

VOID
TestGetUniversal(
    LPTSTR  lpDeviceName,
    DWORD   level,
    DWORD   bufferSize)
{
    LPBYTE  buffer = NULL;
    DWORD   status;
    TCHAR   defaultDevice[]=TEXT("");
    LPTSTR  lpDevice;
    LPTSTR  pNothing = TEXT("<nothing>");

    LPUNIVERSAL_NAME_INFO   pUniversalInfo = NULL;
    LPREMOTE_NAME_INFO      pRemoteInfo = NULL;


    if (lpDeviceName == NULL) {
        lpDevice = defaultDevice;
    }
    else {
        lpDevice = lpDeviceName;
    }

    buffer = (LPBYTE)LocalAlloc(LMEM_FIXED, bufferSize);
    if (buffer == NULL) {
        printf("TestGetConnect: Couldn't allocate memory\n");
        return;
    }

    //----------------
    // 1st Time
    //----------------
    status = WNetGetUniversalName(
                lpDevice,
                level,
                buffer,
                &bufferSize);

    if (( status != WN_SUCCESS) && (status != ERROR_CONNECTION_UNAVAIL)) {
        printf("WNetGetUniversalName failed %d\n",status);
        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        //
        // If insufficient buffer, display needed size.
        //
        if (status == WN_MORE_DATA) {
            printf("Insufficient buffer size.  Need %d bytes\n",bufferSize);
        }
    }
    else {
        if (status == ERROR_CONNECTION_UNAVAIL) {
            printf("Not Currently Connected, but it is remembered\n");
        }
        else {
            printf("WNetGetUniversalName Success\n");
        }
        switch (level) {
        case UNIVERSAL_NAME_INFO_LEVEL:

            pUniversalInfo = (LPUNIVERSAL_NAME_INFO)buffer;
            printf(""FORMAT_LPTSTR" is connected to "FORMAT_LPTSTR"\n",
                lpDevice,pUniversalInfo->lpUniversalName);

            break;
        case REMOTE_NAME_INFO_LEVEL:

            pRemoteInfo = (LPREMOTE_NAME_INFO)buffer;

            if (pRemoteInfo->lpUniversalName == NULL) {
                pRemoteInfo->lpUniversalName = pNothing;
            }

            printf(""FORMAT_LPTSTR" is connected to: \n"
                "  UniversalName  = "FORMAT_LPTSTR"\n"
                "  ConnectionName = "FORMAT_LPTSTR"\n"
                "  RemainingPath  = "FORMAT_LPTSTR"\n\n",
                lpDevice,
                pRemoteInfo->lpUniversalName,
                pRemoteInfo->lpConnectionName,
                pRemoteInfo->lpRemainingPath);

            break;

        default:
            printf("PROBLEM:   Invalid Level didn't produce an error\n");
        }
    }

    //---------------
    // 2nd Time
    //---------------
    if (buffer != NULL) {
        LocalFree(buffer);
    }
    printf("Allocating a new buffer of %d bytes\n",bufferSize);
    buffer = (LPBYTE)LocalAlloc(LMEM_FIXED, bufferSize);
    if (buffer == NULL) {
        printf("TestGetConnect: Couldn't allocate memory(2nd time)\n");
        return;
    }

    status = WNetGetUniversalName(
                lpDevice,
                level,
                buffer,
                &bufferSize);

    if (( status != WN_SUCCESS) && (status != ERROR_CONNECTION_UNAVAIL)) {
        printf("WNetGetUniversalName failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        //
        // If insufficient buffer, display needed size.
        //
        if (status == WN_MORE_DATA) {
            printf("Insufficient buffer size.  Need %d bytes\n",bufferSize);
        }
    }
    else {
        if (status == ERROR_CONNECTION_UNAVAIL) {
            printf("Not Currently Connected, but it is remembered\n");
        }
        else {
            printf("WNetGetUniversalName Success\n");
        }
        switch (level) {
        case UNIVERSAL_NAME_INFO_LEVEL:

            pUniversalInfo = (LPUNIVERSAL_NAME_INFO)buffer;
            printf(""FORMAT_LPTSTR" is connected to "FORMAT_LPTSTR"\n",
                lpDevice,pUniversalInfo->lpUniversalName);

            break;
        case REMOTE_NAME_INFO_LEVEL:

            pRemoteInfo = (LPREMOTE_NAME_INFO)buffer;

            if (pRemoteInfo->lpUniversalName == NULL) {
                pRemoteInfo->lpUniversalName = pNothing;
            }

            printf(""FORMAT_LPTSTR" is connected to: \n"
                "  UniversalName  = "FORMAT_LPTSTR"\n"
                "  ConnectionName = "FORMAT_LPTSTR"\n"
                "  RemainingPath  = "FORMAT_LPTSTR"\n\n",
                lpDevice,
                pRemoteInfo->lpUniversalName,
                pRemoteInfo->lpConnectionName,
                pRemoteInfo->lpRemainingPath);

            break;

        default:
            printf("PROBLEM:   Invalid Level didn't produce an error\n");
        }
    }
    if (buffer != NULL) {
        LocalFree(buffer);
    }
    return;
}

VOID
TestGetUser(
    LPTSTR   lpDevice,
    DWORD    cBuffer)
{
    DWORD   status;
    LPTSTR  userName = NULL;
    DWORD   saveBufSize;

    userName = (LPTSTR)LocalAlloc(LMEM_FIXED, cBuffer);
    if (userName == NULL) {
        printf("TestGetUser: Couldn't allocate memory\n");
        return;
    }
    saveBufSize = cBuffer;

    //
    // Get the currently logged on user
    //
    status = WNetGetUser (NULL, userName, &cBuffer);

    if ( status != WN_SUCCESS) {
        printf("WNetGetUser failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        //
        // If insufficient buffer, display needed size.
        //
        if (status == WN_MORE_DATA) {
            printf("Insufficient buffer size.  Need %d bytes\n",cBuffer);
        }
    }
    else {
        printf("WNetGetUser Success\n");
        printf("CurrentUser = "FORMAT_LPTSTR"\n", userName);
    }

    //
    // If there is a local device given, get the user for that.
    //

    if (lpDevice != NULL){

        cBuffer = saveBufSize;
        status = WNetGetUser (lpDevice, userName, &cBuffer);
        if ( status != WN_SUCCESS) {
            printf("WNetGetUser failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
            //
            // If insufficient buffer, display needed size.
            //
            if (status == WN_MORE_DATA) {
                printf("Insufficient buffer size.  Need %d bytes\n",cBuffer);
            }
        }
        else {
            printf("WNetGetUser Success\n");
            printf("User for "FORMAT_LPTSTR" is "FORMAT_LPTSTR"\n", lpDevice, userName);
        }
    }
    if (userName != NULL) {
        LocalFree(userName);
    }

    return;
}

VOID
TestEnumConnect(
    DWORD   dwScope,
    DWORD   type)
{
    DWORD           status;
    HANDLE          enumHandle;
    LPNETRESOURCE   netResource;
    DWORD           numElements;
    DWORD           bufferSize;

    //
    // Attempt to allow for 10 connections
    //
    bufferSize = (10*sizeof(NETRESOURCE))+1024;

    netResource = (LPNETRESOURCE) LocalAlloc(LPTR, bufferSize);

    if (netResource == NULL) {
        printf("TestEnum:LocalAlloc Failed %d\n",GetLastError);
        return;
    }

    //-----------------------------------
    // Get a handle for a top level enum
    //-----------------------------------
    status = WNetOpenEnum(
                dwScope,
                type,
                0,
                NULL,
                &enumHandle);

    if ( status != WN_SUCCESS) {
        printf("WNetOpenEnum failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        goto CleanExit;
    }
    else {
        printf("WNetOpenEnum Success\n");
    }

    //-----------------------------------
    // Enumerate the resources
    //-----------------------------------
    do
    {
        numElements = 0xffffffff;

        status = WNetEnumResource(
                        enumHandle,
                        &numElements,
                        netResource,
                        &bufferSize);

        if ( status == WN_SUCCESS )
        {
            CHAR    response;

            printf("WNetEnumResource Success - resources follow\n");
            DisplayResourceArray(netResource, numElements);

            printf("Get more resources? ");
            response = getch();
            response = toupper(response);
            if (response == 'N')
            {
                break;
            }
            printf("\r");
        }
        else if ( status == WN_NO_MORE_ENTRIES)
        {
            printf("WNetEnumResource Success - no more resources to display\n");
        }
        else
        {
            printf("WNetEnumResource failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR)
            {
                DisplayExtendedError();
            }
        }
    } while ( status == WN_SUCCESS );

    //------------------------------------------
    // Close the EnumHandle & print the results
    //------------------------------------------
    status = WNetCloseEnum(enumHandle);
    if (status != WN_SUCCESS) {
        printf("WNetCloseEnum failed %d\n",status);
        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        goto CleanExit;

    }


CleanExit:
    LocalFree(netResource);
    return;
}

VOID
TestEnumNet(VOID)
{
    DWORD           status;
    HANDLE          enumHandle;
    LPNETRESOURCE   netResource;
    DWORD           numElements;
    DWORD           bufferSize;
    DWORD           saveBufSize;
    DWORD           i;
    DWORD           numProviders=5;
    HANDLE          providerArray[5];

    //
    // Attempt to allow for 10 resource structures
    //
    saveBufSize = bufferSize = (10*sizeof(NETRESOURCE))+1024;

    netResource = (LPNETRESOURCE) LocalAlloc(LPTR, bufferSize);

    if (netResource == NULL) {
        printf("TestEnum:LocalAlloc Failed %d\n",GetLastError);
        return;
    }

    //-----------------------------------
    // Get a handle for a top level enum
    //-----------------------------------
    status = WNetOpenEnum(
                RESOURCE_GLOBALNET,
                RESOURCETYPE_ANY,
                0,
                NULL,
                &enumHandle);

    if ( status != WN_SUCCESS) {
        printf("WNetOpenEnum failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        goto CleanExit;
    }
    else {
        printf("WNetOpenEnum Success!\n");
    }

    //-----------------------------------
    // Enumerate the top level
    //-----------------------------------

    numElements = 0xffffffff;

    printf("\n*------------- TOP LEVEL ENUM ------------*\n");
    status = WNetEnumResource(
                    enumHandle,
                    &numElements,
                    netResource,
                    &bufferSize);

    if ( status != WN_SUCCESS) {
        printf("WNetEnumResource failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        WNetCloseEnum(enumHandle);
        goto CleanExit;
    }
    else {
        //
        // Success! Display the returned array
        // and close the top-level handle.
        //
        printf("WNetEnumResource Success\n");
        DisplayResourceArray(netResource, numElements);
        WNetCloseEnum(enumHandle);
    }

    //-------------------------------------------
    // Open a handle to the next level container
    //            *** DOMAINS ***
    //-------------------------------------------
    if (numElements < numProviders) {
        numProviders = numElements;
    }
    for (i=0; i<numProviders; i++ ) {


        status = WNetOpenEnum(
                    RESOURCE_GLOBALNET,
                    RESOURCETYPE_ANY,
                    RESOURCEUSAGE_CONTAINER,
                    netResource,
                    &enumHandle);

        if ( status != WN_SUCCESS) {
            printf("WNetOpenEnum 2 failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
            goto CleanExit;
        }
        else {
            printf("WNetOpenEnum 2 Success\n");
            providerArray[i]= enumHandle;
        }
    }

    //-----------------------------------------------------------------
    // Enumerate the next level
    //     *** DOMAINS ***
    //
    // providerArray contains handles for
    // all the providers.
    //
    //-----------------------------------------------------------------
    printf("\n*------------- 2nd LEVEL ENUM (Domains) ------------*\n");


    for (i=0; i<numProviders; i++) {

        numElements = 0xffffffff;

        bufferSize = saveBufSize;
        status = WNetEnumResource(
                        providerArray[i],
                        &numElements,
                        netResource,
                        &bufferSize);

        if ( status != WN_SUCCESS) {
            printf("WNetEnumResource 2 failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
            for (i=0; i<numProviders; i++ ) {
                WNetCloseEnum(providerArray[i]);
            }
            goto CleanExit;
        }
        else {
            //
            // Success! Display the returned array
            // and close the handle.
            //
            printf("*** WNetEnumResource 2 Success for provider %D ***\n",i);
            DisplayResourceArray(netResource, numElements);
            WNetCloseEnum(providerArray[i]);
        }
    }

    //-------------------------------------------
    // Open a handle to the next level container
    //            *** SERVERS ***
    //-------------------------------------------

    status = WNetOpenEnum(
                RESOURCE_GLOBALNET,
                RESOURCETYPE_ANY,
                RESOURCEUSAGE_CONTAINER,
                netResource,
                &enumHandle);

    if ( status != WN_SUCCESS) {
        printf("WNetOpenEnum 3 failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        goto CleanExit;
    }
    else {
        printf("WNetOpenEnum 3 Success\n");
    }

    //-----------------------------------
    // Enumerate the next level
    //     *** SERVERS ***
    //-----------------------------------
    numElements = 0xffffffff;

    printf("\n*------------- 3rd LEVEL ENUM (Servers) ------------*\n");
    status = WNetEnumResource(
                    enumHandle,
                    &numElements,
                    netResource,
                    &bufferSize);

    if ( status == WN_NO_MORE_ENTRIES) {
        //
        // Success! Display the returned array
        // and close the handle.
        //
        printf("WNetEnumResource 3 Success - no more data to display\n");
    }
    else if (status == WN_SUCCESS) {
        if (numElements != 0) {
            printf("WNetEnumResource 3 Success - but MORE DATA\n");
            DisplayResourceArray(netResource, numElements);
        }
        else
        {
            printf("WNetEnumResource 3 Success, and MORE DATA indicated --"
                    " but no data returned??\n");
        }
    }
    else {
        printf("WNetEnumResource 3 failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
    }

    WNetCloseEnum(enumHandle);

CleanExit:
    LocalFree(netResource);
    return;
}

VOID
TestSetError(VOID)
{

    //
    // Store and Get the 1st Error
    //
    printf("Setting Error WN_BAD_NETNAME.  Code = %d\n", WN_BAD_NETNAME);
    WNetSetLastError( WN_BAD_NETNAME, TEXT("WN_BAD_NETNAME"), TEXT("Dan's Provider"));
    DisplayExtendedError();

    //
    // Store and Get the 2nd Error
    //
    printf("Setting Error WN_NO_NETWORK.  Code = %d\n", WN_NO_NETWORK);
    WNetSetLastError( WN_NO_NETWORK, TEXT("WN_NO_NETWORK"), TEXT("Dan's Provider"));
    DisplayExtendedError();

    return;
}

VOID
TestMultiError(VOID)
{

    //
    // Store and Get the 1st Error
    //
    printf("Setting Error WN_BAD_NETNAME.  Code = %d\n", WN_BAD_NETNAME);
    WNetSetLastError( WN_BAD_NETNAME, TEXT("WN_BAD_NETNAME"), TEXT("Dan's Provider"));
    DisplayMultiError();

    //
    // Store and Get the 2nd Error
    //
    printf("Setting Error WN_NO_NETWORK.  Code = %d\n", WN_NO_NETWORK);
    WNetSetLastError( WN_NO_NETWORK, TEXT("WN_NO_NETWORK"), TEXT("Dan's Provider"));
    DisplayMultiError();

    //
    // Store and Get a non-WNet Error, with no text or provider
    //
    printf("Setting Error ERROR_SHARING_VIOLATION, no text or provider.  Code = %d\n", ERROR_SHARING_VIOLATION);
    WNetSetLastError( ERROR_SHARING_VIOLATION, NULL, NULL);
    DisplayMultiError();

    //
    // Store and Get an unknown Error, with no text
    //
    printf("Setting arbitrary error with no text.  Code = %d\n", 654321);
    WNetSetLastError( 654321, NULL, TEXT("Dan's Provider"));
    DisplayMultiError();

    return;
}

VOID
TestDirStuff(VOID)
{
    DWORD   status;
    INT     type;

    //
    // Test GetDirectoryType
    //
    status = WNetGetDirectoryType((LPTSTR)TEXT("f:\\"), (LPINT)&type, TRUE);

    if ( status != WN_SUCCESS) {
        printf("WNetGetDirectoryType failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
    }
    else {
        //
        // Success!
        //
        printf("WNetGetDirctoryType Success type = %d \n",type);
    }


    //
    // Test DirectoryNotify
    //
    status = WNetDirectoryNotify(0,TEXT("f:\\"), 2);

    if ( status != WN_SUCCESS) {
        printf("WNetDirectoryNotify failed %d\n",status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
    }
    else {
        //
        // Success!
        //
        printf("WNetDirectoryNotify Success \n");
    }

    return;
}

VOID
TestRestoreConnect(
    LPTSTR   lpDrive
    )
{
    DWORD   status;

#ifdef UNICODE
    status = WNetRestoreConnection(
                (HWND)0,
                lpDrive);
#else
    status = RestoreConnectionA0 (
                (HWND)0,
                lpDrive);
#endif

    if (status == NO_ERROR) {
        printf("WNetRestoreConnection success\n");
    }
    else {
        printf("WNetRestoreConnection failure %d\n",status);
    }
}

VOID
TestClearConnect(
    VOID
    )
{
    DWORD   status;


    status = WNetClearConnections(
                (HWND)0);

    if (status == NO_ERROR) {
        printf("WNetClearConnection success\n");
    }
    else {
        printf("WNetClearConnection failure %d\n",status);
    }
}

VOID
TestLotsOfStuff(VOID)
{
    DWORD   status;
    BOOL    KeepGoing=TRUE;

    do {


        printf("\n*** RUNNING TestAddConnect2 for g:\n");
        TestAddConnect2(TEXT("\\\\popcorn\\public"), TEXT("g:"));
        printf("\n*** RUNNING TestAddConnect2 for t:\n");
        TestAddConnect2(TEXT("\\\\products3\\release"), TEXT("t:"));
        printf("\n*** RUNNING TestAddConnect2 for k:\n");
        TestAddConnect2(TEXT("\\\\kernel\\razzle2"),   TEXT("k:"));

        printf("\n*** TESTING AddConnect1 for NP2 on z:\n");
        status = WNetAddConnection(TEXT("!Rastaman"),NULL,TEXT("z:"));
        if (status != WN_SUCCESS) {
            printf("AddConnect1 for NP2 failed %d"
            "- Do we have a 2nd provider?\n",status);
        }
        else {
            printf("AddConnect1 success\n");
        }

        printf("\n*** RUNNING TestGetConnect\n");
        TestGetConnect(TEXT("g:"),NAME_BUF_SIZE);
        printf("\n*** RUNNING TestSetError\n");
        TestSetError();
        printf("\n*** RUNNING TestMultiError\n");
        TestMultiError();
        printf("\n*** RUNNING TestGetUser\n");
        TestGetUser(NULL,NAME_BUF_SIZE);
        printf("\n*** RUNNING TestEnumConnect (non-remembered)\n");
        TestEnumConnect(RESOURCE_CONNECTED,RESOURCETYPE_DISK);

        printf("\n*** RUNNING TestEnumConnect (remembered)\n");
        TestEnumConnect(RESOURCE_REMEMBERED,RESOURCETYPE_DISK);

        printf("\n*** RUNNING TestEnumConnect (context)\n");
        TestEnumConnect(RESOURCE_CONTEXT,RESOURCETYPE_DISK);


        printf("\n*** ATTEMPT to Cancel connection to t:\n");
        status = WNetCancelConnection(TEXT("t:"),FALSE);

        if ( status != WN_SUCCESS) {
            printf("WNetCancelConnection failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
        }
        else {
            printf("WNetCancelConnection Success\n");
        }

        printf("\n*** ATTEMPT to Cancel connection to g:\n");
        WNetCancelConnection(TEXT("g:"),FALSE);
        if ( status != WN_SUCCESS) {
            printf("WNetCancelConnection failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
        }
        else {
            printf("WNetCancelConnection Success\n");
        }

        printf("\n*** ATTEMPT to Cancel connection to k:\n");
        WNetCancelConnection(TEXT("k:"),FALSE);
        if ( status != WN_SUCCESS) {
            printf("WNetCancelConnection failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
        }
        else {
            printf("WNetCancelConnection Success\n");
        }

        printf("\n*** ATTEMPT to Cancel connection to z:\n");
        WNetCancelConnection(TEXT("z:"),TRUE);
        if ( status != WN_SUCCESS) {
            printf("WNetCancelConnection failed %d\n",status);

            //
            // If there is an extended error, display it.
            //
            if (status == WN_EXTENDED_ERROR) {
                DisplayExtendedError();
            }
        }
        else {
            printf("WNetCancelConnection Success\n");
        }

        printf("\n*** RUNNING TestEnumNet\n");
        TestEnumNet();

        printf("     - Do it again?  (type 'n' to stop)\n");

        if (getch() == 'n') {
            KeepGoing = FALSE;
        }
    } while (KeepGoing);
    return;

}

VOID
DisplayExtendedError(VOID)
{
    TCHAR   errorBuf[ERR_BUF_SIZE];
    TCHAR   nameBuf[NAME_BUF_SIZE];
    DWORD   errorCode;
    DWORD   status;
    DWORD   smallErrorSize;
    DWORD   smallNameSize;

    status = WNetGetLastError(
                &errorCode,
                errorBuf,
                ERR_BUF_SIZE,
                nameBuf,
                NAME_BUF_SIZE);

    if(status != WN_SUCCESS) {
        printf("WNetGetLastError failed %d\n",status);
        return;
    }
    printf("EXTENDED ERROR INFORMATION:  (from GetLastError)\n");
    printf("   Code:        %d\n",errorCode);
    printf("   Description: "FORMAT_LPTSTR"\n",errorBuf);
    printf("   Provider:    "FORMAT_LPTSTR"\n\n",nameBuf);

    //---------------------------------------------------------
    // Now try it with a buffer that's one character too small.
    //---------------------------------------------------------
    printf("Try it with buffer that is one char too small\n");

    smallErrorSize = STRLEN(errorBuf);
    smallNameSize  = STRLEN(nameBuf);
    status = WNetGetLastError(
                &errorCode,
                errorBuf,
                smallErrorSize,
                nameBuf,
                smallNameSize);

    if(status != WN_SUCCESS) {
        printf("WNetGetLastError failed %d\n",status);
        return;
    }
    printf("EXTENDED ERROR INFORMATION (truncated):  (from GetLastError)\n");
    printf("   Code:        %d\n",errorCode);
    printf("   Description: "FORMAT_LPTSTR"\n",errorBuf);
    printf("   Provider:    "FORMAT_LPTSTR"\n\n",nameBuf);

    //---------------------------------------------------------
    // Now try it with a zero length buffer.
    //---------------------------------------------------------
    printf("Try it with zero length buffers\n");
    smallErrorSize = 0;
    smallNameSize  = 0;
    status = WNetGetLastError(
                &errorCode,
                errorBuf,
                smallErrorSize,
                nameBuf,
                smallNameSize);

    if(status != WN_SUCCESS) {
        printf("WNetGetLastError failed %d\n",status);
        return;
    }
    printf("EXTENDED ERROR INFORMATION (zero length):  (from GetLastError)\n");
    printf("   Code:        %d\n",errorCode);
    printf("   Description: "FORMAT_LPTSTR"\n",errorBuf);
    printf("   Provider:    "FORMAT_LPTSTR"\n\n",nameBuf);
    //---------------------------------------------------------
    // Now try it with invalid buffer.
    //---------------------------------------------------------
    printf("Try it with invalid buffers\n");
    smallErrorSize = 0;
    smallNameSize  = 0;
    status = WNetGetLastError(
                &errorCode,
                (LPTSTR)0xffffeeee,
                0,
                (LPTSTR)0xffffeeee,
                0);

    if(status != WN_SUCCESS) {
        printf("WNetGetLastError failed %d\n",status);
        return;
    }
    printf("EXTENDED ERROR INFORMATION (NO BUFFER):  (from GetLastError)\n");
    printf("   Code:        %d\n",errorCode);
    printf("   Description: "FORMAT_LPTSTR"\n",errorBuf);
    printf("   Provider:    "FORMAT_LPTSTR"\n\n",nameBuf);
    //---------------------------------------------------------
    // Now try it with invalid buffer & lie about size.
    //---------------------------------------------------------
    printf("Try it with invalid buffers\n");
    smallErrorSize = 0;
    smallNameSize  = 0;
    status = WNetGetLastError(
                &errorCode,
                (LPTSTR)0xffffeeee,
                2000,
                (LPTSTR)0xffffeeee,
                2000);

    if(status != WN_SUCCESS) {
        printf("WNetGetLastError failed %d\n",status);
        return;
    }
    printf("EXTENDED ERROR INFORMATION (NO BUFFER):  (from GetLastError)\n");
    printf("   Code:        %d\n",errorCode);
    printf("   Description: "FORMAT_LPTSTR"\n",errorBuf);
    printf("   Provider:    "FORMAT_LPTSTR"\n\n",nameBuf);
    return;
}

VOID
DisplayMultiError(VOID)
{
    TCHAR   errorBuf[ERR_BUF_SIZE];
    TCHAR   nameBuf[NAME_BUF_SIZE];
    DWORD   status;
    DWORD   smallErrorSize;
    DWORD   smallNameSize;
    DWORD   ErrorSize = ERR_BUF_SIZE;
    DWORD   NameSize = NAME_BUF_SIZE;

    status = MultinetGetErrorText(
                errorBuf,
                &ErrorSize,
                nameBuf,
                &NameSize);

    if(status != WN_SUCCESS) {
        printf("MultinetGetErrorText failed %d\n",status);
        return;
    }
    printf("EXTENDED ERROR INFORMATION:  (from MultinetGetErrorText)\n");
    printf("   Description: "FORMAT_LPTSTR"\n",errorBuf);
    printf("   Provider:    "FORMAT_LPTSTR"\n\n",nameBuf);

    //---------------------------------------------------------
    // Now try it with a buffer that's one character too small.
    //---------------------------------------------------------
    printf("Try it with buffer that is one char too small\n");

    smallErrorSize = STRLEN(errorBuf);
    smallNameSize  = STRLEN(nameBuf);
    status = MultinetGetErrorText(
                errorBuf,
                &smallErrorSize,
                nameBuf,
                &smallNameSize);

    if(status != WN_MORE_DATA) {
        printf("MultinetGetErrorText FAILED %d\n",status);
        return;
    }
    printf("EXTENDED ERROR INFORMATION (truncated):  (from MultinetGetErrorText)\n");
    printf("   Error size:  %d\n", smallErrorSize);
    printf("   Name  size:  %d\n", smallNameSize);

    //---------------------------------------------------------
    // Now try it with a zero length buffer.
    //---------------------------------------------------------
    printf("Try it with zero length buffers\n");
    smallErrorSize = 0;
    smallNameSize  = 0;
    status = MultinetGetErrorText(
                errorBuf,
                &smallErrorSize,
                nameBuf,
                &smallNameSize);

    if(status != WN_MORE_DATA) {
        printf("MultinetGetErrorText FAILED %d\n",status);
        return;
    }
    printf("EXTENDED ERROR INFORMATION (zero length):  (from MultinetGetErrorText)\n");
    printf("   Error size:  %d\n", smallErrorSize);
    printf("   Name  size:  %d\n", smallNameSize);
    //---------------------------------------------------------
    // Now try it with invalid buffer.
    //---------------------------------------------------------
    printf("Try it with invalid buffers\n");
    smallErrorSize = 0;
    smallNameSize  = 0;
    status = MultinetGetErrorText(
                (LPTSTR)0xffffeeee,
                &smallErrorSize,
                (LPTSTR)0xffffeeee,
                0);

    if(status != WN_BAD_POINTER) {
        printf("MultinetGetErrorText failed %d\n",status);
        return;
    }
    printf("Worked OK, returned WN_BAD_POINTER\n");
    //---------------------------------------------------------
    // Now try it with invalid buffer & lie about size.
    //---------------------------------------------------------
    printf("Try it with invalid buffers\n");
    smallErrorSize = 2000;
    smallNameSize  = 2000;
    status = MultinetGetErrorText(
                (LPTSTR)0xffffeeee,
                &smallErrorSize,
                (LPTSTR)0xffffeeee,
                &smallNameSize);

    if(status != WN_BAD_POINTER) {
        printf("MultinetGetErrorText failed %d\n",status);
        return;
    }
    printf("Worked OK, returned WN_BAD_POINTER\n");
    return;
}

VOID
DisplayResourceArray(
    LPNETRESOURCE   NetResource,
    DWORD           NumElements
    )
{
    DWORD   i;

    for (i=0; i<NumElements ;i++ ) {
        DisplayResource(&(NetResource[i]));
    }
    return;
}

VOID
DisplayResource(
    LPNETRESOURCE   NetResource
    )
{
    printf( "*** RESOURCE ***\n");
    printf( "Scope\t0x%x\n", NetResource->dwScope);
    printf( "Type\t0x%x\n",  NetResource->dwType);
    printf( "Usage\t0x%x\n", NetResource->dwUsage);

    printf( "LocalName\t"FORMAT_LPTSTR"\n",  NetResource->lpLocalName);
    printf( "RemoteName\t"FORMAT_LPTSTR"\n", NetResource->lpRemoteName);
    printf( "Comment\t"FORMAT_LPTSTR"\n",    NetResource->lpComment);
    printf( "Provider\t"FORMAT_LPTSTR"\n\n", NetResource->lpProvider);
}

BOOL
MakeArgsUnicode (
    DWORD           argc,
    PCHAR           argv[]
    )


/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD   i;

    //
    // ScConvertToUnicode allocates storage for each string.
    // We will rely on process termination to free the memory.
    //
    for(i=0; i<argc; i++) {

        if(!ConvertToUnicode( (LPWSTR *)&(argv[i]), argv[i])) {
            printf("Couldn't convert argv[%d] to unicode\n",i);
            return(FALSE);
        }


    }
    return(TRUE);
}

BOOL
ConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPSTR   AnsiIn
    )

/*++

Routine Description:

    This function translates an AnsiString into a Unicode string.
    A new string buffer is created by this function.  If the call to
    this function is successful, the caller must take responsibility for
    the unicode string buffer that was allocated by this function.
    The allocated buffer should be free'd with a call to LocalFree.

    NOTE:  This function allocates memory for the Unicode String.

Arguments:

    AnsiIn - This is a pointer to an ansi string that is to be converted.

    UnicodeOut - This is a pointer to a location where the pointer to the
        unicode string is to be placed.

Return Value:

    TRUE - The conversion was successful.

    FALSE - The conversion was unsuccessful.  In this case a buffer for
        the unicode string was not allocated.

--*/
{

    NTSTATUS        ntStatus;
    DWORD           bufSize;
    UNICODE_STRING  unicodeString;
    ANSI_STRING     ansiString;

    //
    // Allocate a buffer for the unicode string.
    //

    bufSize = (strlen(AnsiIn)+1) * sizeof(WCHAR);

    *UnicodeOut = (LPWSTR) LocalAlloc(LPTR, bufSize);

    if (*UnicodeOut == NULL) {
        printf("ScConvertToUnicode:LocalAlloc Failure %ld\n",GetLastError());
        return(FALSE);
    }

    //
    // Initialize the string structures
    //
    RtlInitAnsiString( &ansiString, AnsiIn);

    unicodeString.Buffer = *UnicodeOut;
    unicodeString.MaximumLength = (USHORT)bufSize;
    unicodeString.Length = 0;

    //
    // Call the conversion function.
    //
    ntStatus = RtlAnsiStringToUnicodeString (
                &unicodeString,     // Destination
                &ansiString,        // Source
                FALSE);             // Allocate the destination

    if (!NT_SUCCESS(ntStatus)) {

        printf("ScConvertToUnicode:RtlAnsiStringToUnicodeString Failure %lx\n",
        ntStatus);

        return(FALSE);
    }

    //
    // Fill in the pointer location with the unicode string buffer pointer.
    //
    *UnicodeOut = unicodeString.Buffer;

    return(TRUE);

}

VOID
InvalidParms(
    VOID
    )

/*++

Routine Description:

    Tests Invalid parameters sent to Winnet API.

Arguments:



Return Value:



--*/
{
    DWORD           status;
    DWORD           dwFlags;
    LPNETRESOURCE   netResource;
    HANDLE          enumHandle;
    DWORD           dwType;
    DWORD           dwScope;
    DWORD           dwUsage;
    NETRESOURCE     NetResource;

    netResource = (LPNETRESOURCE) LocalAlloc(LPTR, sizeof(NETRESOURCE));

    if (netResource == NULL) {
        printf("InvalidParms:LocalAlloc Failed %d\n",GetLastError);
        return;
    }

    netResource->lpRemoteName = TEXT("\\popcorn\\public");
    netResource->lpLocalName  = TEXT("p:");
    netResource->dwType = RESOURCETYPE_DISK;

    //==============================================
    // WNetAddConnect2 - set dwFlags to something other than 0 or
    // CONNECT_UPDATE_PROFILE.
    //==============================================
    dwFlags = CONNECT_UPDATE_PROFILE + 1;
    status = WNetAddConnection2(netResource,NULL,NULL,dwFlags);
    if (status == WN_BAD_VALUE) {
        printf("InvalidParms Test #1 success\n");
    }
    else {
        printf("InvalidParms Test #1 failed\n");
    }

    //==============================================
    // WNetAddConnect2 - dwType = RESOURCETYPE_ANY.
    //                   dwFlags != CONNECT_UPDATE_PROFILE.
    //==============================================

    netResource->dwType = RESOURCETYPE_DISK;
    dwFlags = CONNECT_UPDATE_PROFILE+1;
    status = WNetAddConnection2(netResource,NULL,NULL,dwFlags);

    if (status == WN_BAD_VALUE) {
        printf("InvalidParms Test #2 success\n");
    }
    else {
        printf("InvalidParms Test #2 failed\n");
    }


    //==============================================
    // WNetAddConnect2 - dwType = RESOURCETYPE_DISK.
    //                   dwFlags = 0
    //==============================================

    netResource->dwType = RESOURCETYPE_DISK;
    dwFlags = 0;
    status = WNetAddConnection2(netResource,NULL,NULL,dwFlags);

    if (status != WN_BAD_VALUE) {
        printf("InvalidParms Test #3 success\n");
    }
    else {
        printf("InvalidParms Test #3 failed\n");
    }


    //==============================================
    // WNetAddConnect2 - lpRemoteName = NULL
    //==============================================

    netResource->dwType = RESOURCETYPE_DISK;
    dwFlags = 0;
    netResource->lpRemoteName = NULL;
    status = WNetAddConnection2(netResource,NULL,NULL,dwFlags);

    if (status == WN_BAD_NETNAME) {
        printf("InvalidParms Test #4 success\n");
    }
    else {
        printf("InvalidParms Test #4 failed\n");
    }


    //======================================================================
    // WNetOpenEnum - dwScope = RESOURCE_CONNECTED | RESOURCE_GLOBALNET
    //======================================================================

    dwScope = RESOURCE_CONNECTED | RESOURCE_GLOBALNET | RESOURCE_REMEMBERED+1;
    dwType = RESOURCETYPE_ANY;

    status = WNetOpenEnum(
                dwScope,
                dwType,
                0,
                NULL,
                &enumHandle);


    if (status == WN_BAD_VALUE) {
        printf("InvalidParms Test #5 success\n");
    }
    else {
        printf("InvalidParms Test #5 failed\n");
    }


    //======================================================================
    // WNetOpenEnum - dwType = RESOURCETYPE_DISK | RESOURCETYPE_PRINT |
    //                         RESOURCETYPE_ANY + 1;
    //======================================================================

    dwScope = RESOURCE_CONNECTED;
    dwType = (RESOURCETYPE_DISK | RESOURCETYPE_PRINT | RESOURCETYPE_ANY)+1;

    status = WNetOpenEnum(
                dwScope,
                dwType,
                0,
                NULL,
                &enumHandle);


    if (status == WN_BAD_VALUE) {
        printf("InvalidParms Test #6 success\n");
    }
    else {
        printf("InvalidParms Test #6 failed\n");
    }


    //======================================================================
    // WNetOpenEnum - dwUsage = RESOURCEUSAGE_CONNECTABLE |
    //                          RESOURCEUSAGE_CONTAINER + 1
    //======================================================================

    dwScope = RESOURCE_GLOBALNET;
    dwType  = RESOURCETYPE_DISK;
    dwUsage = (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER) + 1;

    status = WNetOpenEnum(
                dwScope,
                dwType,
                dwUsage,
                NULL,
                &enumHandle);


    if (status == WN_BAD_VALUE) {
        printf("InvalidParms Test #7 success\n");
    }
    else {
        printf("InvalidParms Test #7 failed\n");
    }

    //======================================================================
    // WNetOpenEnum - NetResource Structure is filled with 0.
    //======================================================================

    memset(&NetResource, 0,sizeof(NetResource));
    dwScope = RESOURCE_GLOBALNET;
    dwType  = RESOURCETYPE_ANY;
    dwUsage = 0;

    status = WNetOpenEnum(
                dwScope,
                dwType,
                dwUsage,
                NULL,
                &enumHandle);


    if (status == WN_SUCCESS) {
        printf("InvalidParms Test #8 success\n");
        WNetCloseEnum(enumHandle);
    }
    else {
        printf("InvalidParms Test #8 failed\n");
    }

    //======================================================================
    // WNetCancelConnection2 - dwFlags != CONNECT_UPDATE_PROFILE | 0.
    //======================================================================

    status = WNetCancelConnection2(TEXT("p:"), CONNECT_UPDATE_PROFILE + 1, FALSE);
    if (status == WN_BAD_VALUE) {
        printf("InvalidParms Test #9 success\n");
    }
    else {
        printf("InvalidParms Test #9 failed\n");
    }
    printf("InvalidParms Test Complete\n");

    LocalFree(netResource);
    return;
}

VOID
RecursiveEnum(
    DWORD           RecursionLevel,
    DWORD           ResourceUsage,
    LPNETRESOURCE   EnumNetResource
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD           status;
    HANDLE          enumHandle;
    LPNETRESOURCE   netResource=NULL;
    DWORD           numElements;
    DWORD           bufferSize;
    DWORD           saveBufferSize;
    DWORD           i;
    DWORD           usage;
    CHAR            response;

    //-------------------------------------------
    // Open a handle to the next level container
    //-------------------------------------------

    status = WNetOpenEnum(
                RESOURCE_GLOBALNET,
                RESOURCETYPE_ANY,
                ResourceUsage,
                EnumNetResource,
                &enumHandle);

    if ( status != WN_SUCCESS) {
        printf("WNetOpenEnum %d failed %d\n",RecursionLevel,status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        return;
    }
    else {
        printf("WNetOpenEnum %d Success\n",RecursionLevel);
    }

    //-------------------------------------
    // Allocate memory for the enumeration
    //-------------------------------------
    //
    // Attempt to allow for 10 resource structures
    //
    bufferSize = (10*sizeof(NETRESOURCE))+2048;

    netResource = (LPNETRESOURCE) LocalAlloc(LPTR, bufferSize);

    if (netResource == NULL) {
        printf("TestEnum:LocalAlloc Failed %d\n",GetLastError);
        return;
    }
    saveBufferSize = bufferSize;

    //-----------------------------------
    // Enumerate the next level
    //-----------------------------------
    numElements = 0xffffffff;
    status = WNetEnumResource(
                    enumHandle,
                    &numElements,
                    netResource,
                    &bufferSize);

    if ((status == WN_NO_MORE_ENTRIES) ||
        (status == WN_SUCCESS) ) {
        if (numElements != 0) {
            //
            // Success! Display the returned array
            // and close the handle.
            //
            if (status == WN_SUCCESS){
                printf("WNetEnumResource %d Success - but MORE DATA\n",
                RecursionLevel);
            }
            else {
                printf("WNetEnumResource %d Success\n",RecursionLevel);
            }

            usage = RESOURCEUSAGE_CONTAINER;

            switch(RecursionLevel) {
            case 0:
                printf("\n*------------- NETWORK PROVIDERS  ------------*\n");
                break;
            case 1:
                printf("\n*------------- DOMAINS FOR "FORMAT_LPTSTR" PROVIDER  ------------*\n",
                EnumNetResource->lpRemoteName);
                break;
            case 2:
                printf("\n*------------- SERVERS ON "FORMAT_LPTSTR" DOMAIN  ------------*\n",
                EnumNetResource->lpRemoteName);
                break;
            case 3:
                printf("\n*------------- SHARES ON "FORMAT_LPTSTR" SERVER  ------------*\n",
                EnumNetResource->lpRemoteName);
                usage = RESOURCEUSAGE_CONNECTABLE;
                break;
            default:
                break;
            }

            printf("continue? ");
            response = getch();
            response = toupper(response);
            if (response == 'N') {
                WNetCloseEnum(enumHandle);
                return;
            }
            if (response == 'Q') {
                ExitProcess(0);
            }
            printf("\r");

            DisplayResourceArray(netResource, numElements);
            for (i=0;i<numElements ;i++ ) {
                RecursiveEnum(
                    RecursionLevel+1,
                    usage,
                    &(netResource[i]));
            }
        }
        else {
            printf("No entries to enumerate for "FORMAT_LPTSTR" rc=%d\n",
            EnumNetResource->lpRemoteName,status);
        }
    }
    else if (status == WN_MORE_DATA) {
        printf("The buffer (%d bytes) was too small for one entry, need %d bytes\n",
        saveBufferSize, bufferSize);

    }
    else {
        printf("WNetEnumResource %d failed %d\n",RecursionLevel,status);

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
    }

    WNetCloseEnum(enumHandle);
    if (netResource != NULL) {
        LocalFree(netResource);
    }
}

VOID
TestLogonNotify(
    LPTSTR  argv[],
    DWORD   argc
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD                       status;
    MSV1_0_INTERACTIVE_LOGON    NewLogon;
    MSV1_0_INTERACTIVE_LOGON    OldLogon;
    LUID                        LogonId;
    LPWSTR                      LogonScripts;
    LPWSTR                      pScript;


    NewLogon.MessageType = MsV1_0InteractiveLogon;

    RtlInitUnicodeString(&(NewLogon.LogonDomainName),L"Domain");
    RtlInitUnicodeString(&(NewLogon.UserName),L"SAMMY");
    RtlInitUnicodeString(&(NewLogon.Password),L"SECRET");

    OldLogon.MessageType = MsV1_0InteractiveLogon;

    RtlInitUnicodeString(&(OldLogon.LogonDomainName),L"Domain");
    RtlInitUnicodeString(&(OldLogon.UserName),L"SAMMY");
    RtlInitUnicodeString(&(OldLogon.Password),L"NEWSECRET");

    LogonId.HighPart = 5;
    LogonId.LowPart = 53;

    status = WNetLogonNotify(
                L"Windows NT Network Provider",
                &LogonId,
                L"MSV1_0:Interactive",
                &NewLogon,
                L"MSV1_0:Interactive",
                &OldLogon,
                L"Dan's Station",
                (LPVOID)L"POINTER",
                &LogonScripts);

    if (status == NO_ERROR) {
        printf("WNetLogonNotify Success\n");

        if (LogonScripts != NULL) {
            pScript = LogonScripts;

            do {
                printf("LogonScripts: %ws\n",pScript);
                pScript += (wcslen(pScript) + 1);
            }
            while (*pScript != L'\0');

            LocalFree(LogonScripts);
        }
    }
    else {
        printf("WNetLogonNotify Failure %d\n",status);
    }

    return;
}

VOID
TestChangePassword(
    LPTSTR  argv[],
    DWORD   argc
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD                       status;
    MSV1_0_INTERACTIVE_LOGON    NewLogon;
    MSV1_0_INTERACTIVE_LOGON    OldLogon;


    NewLogon.MessageType = MsV1_0InteractiveLogon;

    RtlInitUnicodeString(&(NewLogon.LogonDomainName),L"Domain");
    RtlInitUnicodeString(&(NewLogon.UserName),L"SAMMY");
    RtlInitUnicodeString(&(NewLogon.Password),L"SECRET");

    OldLogon.MessageType = MsV1_0InteractiveLogon;

    RtlInitUnicodeString(&(OldLogon.LogonDomainName),L"Domain");
    RtlInitUnicodeString(&(OldLogon.UserName),L"SAMMY");
    RtlInitUnicodeString(&(OldLogon.Password),L"NEWSECRET");

    status = WNetPasswordChangeNotify(
                L"Windows Nt Network Provider",
                L"MSV1_0:Interactive",
                &NewLogon,
                L"MSV1_0:Interactive",
                &OldLogon,
                L"Dan's Station",
                (LPVOID)L"POINTER",
                44);

    if (status == NO_ERROR) {
        printf("WNetPasswordChangeNotify Success\n");

    }
    else {
        printf("WNetPasswordChangeNotify Failure %d\n",status);
    }

    return;
}

BOOL
GetStringFromFile(
    LPDWORD     lpLoopCount,
    LPSTR       buffer
    )

/*++

Routine Description:

    The following behaviour is desired, however, I don't have time to
    write it right now:

    This function reads the next line of instructions from a file called
    "mprtest.txt".  When it reaches the end of the file, it begins again
    at the beginning of the file.  The first line in the file indicates how
    many times to pass through the file.  (Loop count).  When the last pass
    occurs, the instruction "done" is passed back in the buffer.



Arguments:


Return Value:


--*/
{
    if (*lpLoopCount == 0) {
        strcpy(buffer+2, "done");
        buffer[1]=strlen(buffer+2);
    }
    else {
        if (*lpLoopCount & 1) {
            buffer[1]=28;
            strcpy(buffer+2, "AddConnect1 x: \\\\danl1\\roote");
            buffer[1]=strlen(buffer+2);
        }
        else {
            strcpy(buffer+2, "CancelConnect x: r");
            buffer[1]=strlen(buffer+2);
        }
        (*lpLoopCount)--;
    }
    return(TRUE);
}

LONG
wtol(
    IN LPWSTR string
    )
{
    LONG value = 0;

    while((*string != L'\0')  &&
            (*string >= L'0') &&
            ( *string <= L'9')) {
        value = value * 10 + (*string - L'0');
        string++;
    }

    return(value);
}

VOID
Usage(VOID)
{

    printf("USAGE:\n");
    printf("<server> <function>\n");

    printf("SYNTAX EXAMPLES    \n");

    printf("AddConnect1 <drive> <remote name>  - "
            "these are remembered\n");
    printf("AddConnect2 <drive> <remote name>  - "
            "these are not remembered\n");
    printf("CancelConnect <drive> <r>\n");
    printf("GetConnect <connection> <buffer size>\n");
    printf("GetUniversalName <connection> <info level> <buffer size>\n");
    printf("GetUser <device= ?> <bufsize= ?>\n");
    printf("EnumConnect <type= ANY|DISK|PRINT> <r> \n");
    printf("EnumContext <type= ANY|DISK|PRINT> \n");
    printf("RestoreConnect <drive> \n");
    printf("EnumNet\n");
    printf("SetError\n");
    printf("MultiError\n");
    printf("DirApi\n");
    printf("ClearConnect\n");
    printf("LogonNotify\n");
    printf("ChangePassword\n");
    printf("ALL\n");
    printf("InvalidParms\n");
    printf("Loop <number>   -  Add and cancel n connections \n");
    printf("Exit\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\mprui.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    mprui.h

Abstract:

    Prototypes and manifests to support mprui.cxx.

Author:

    ChuckC    28-Jul-1992

Environment:

    User Mode -Win32

Notes:

Revision History:

    28-Jul-1992     Chuckc  Created

--*/

DWORD
DoPasswordDialog(
    HWND          hwndOwner,
    TCHAR *       pchResource,
    TCHAR *       pchUserName,
    TCHAR *       pchPasswordReturnBuffer,
    ULONG         cbPasswordReturnBuffer, // bytes!
    BOOL *        pfDidCancel,
    DWORD         dwError
    );

DWORD
DoProfileErrorDialog(
    HWND          hwndOwner,
    const TCHAR * pchDevice,
    const TCHAR * pchResource,
    const TCHAR * pchProvider,
    DWORD         dwError,
    BOOL          fAllowCancel,
    BOOL *        pfDidCancel,
    BOOL *        pfDisconnect,
    BOOL *        pfHideErrors
    );

DWORD
ShowReconnectDialog(
    HWND          hwndParent,
    PARAMETERS *  Params
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\netinfo.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    netinfo.cxx

Abstract:

    Contains entry points for Winnet API supported by the
    Multi-Provider Router.
    Contains:
        WNetGetNetworkInformationW
        WNetGetProviderNameW

Author:

    Anirudh Sahni  (anirudhs)  08-Jun-1995

Environment:

    User Mode -Win32

Notes:

Revision History:

    08-Jun-1995     anirudhs
        Created

    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <tstr.h>       // WCSSIZE

//
// EXTERNAL GLOBALS
//

//
// Defines
//


//
// Local Function Prototypes
//


DWORD
WNetGetNetworkInformationW(
    IN  LPCWSTR         lpProvider,
    OUT LPNETINFOSTRUCT lpNetInfoStruct
    )

/*++

Routine Description:

    This function returns extended information about a named network provider.

Arguments:

    lpProvider - Pointer to the name of the provider for which information is
        required.

    lpNetInfoStruct - Pointer to a structure that describes the behavior of
        the network.

Return Value:

    WN_SUCCESS - Call is successful.

    WN_BAD_PROVIDER - lpProvider does not match any active network provider.

    WN_BAD_VALUE - lpProvider->cbStructure does not contain a valid structure
        size.

Notes:

    Win 95's implementation of this API will accept a structure smaller than
    a NETINFOSTRUCT, and will fill in as many elements of the structure as
    will fit.  This strange feature is not documented and is not used in
    the shell, so we don't do it here.  It may be useful for future versions
    of this API that add fields to the NETINFOSTRUCT.

--*/

{
    DWORD       status = WN_SUCCESS;
    LPPROVIDER  Provider;

    if (!(ARGUMENT_PRESENT(lpProvider) &&
          ARGUMENT_PRESENT(lpNetInfoStruct)))
    {
        SetLastError(WN_BAD_POINTER);
        return WN_BAD_POINTER;
    }

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    __try
    {
        //
        // Validate the parameters that we can.
        //

        if (lpNetInfoStruct->cbStructure < sizeof(NETINFOSTRUCT))
        {
            status = WN_BAD_VALUE;
            __leave;
        }

        if (IsBadWritePtr(lpNetInfoStruct, lpNetInfoStruct->cbStructure))
        {
            status = WN_BAD_POINTER;
            __leave;
        }

        //
        // Look up the provider by name
        //
        DWORD i;
        if (!MprGetProviderIndex(lpProvider, &i))
        {
            status = WN_BAD_PROVIDER;
            __leave;
        }

        Provider = & GlobalProviderInfo[i];
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION)
        {
            MPR_LOG(ERROR,
                    "WNetGetNetworkInformationW: Unexpected Exception %#lx\n",
                    status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS)
    {
        SetLastError(status);
        return status;
    }

    //
    // Fill in the fields of the structure
    //

    lpNetInfoStruct->cbStructure = sizeof(NETINFOSTRUCT);

    lpNetInfoStruct->dwProviderVersion = Provider->GetCaps(WNNC_DRIVER_VERSION);

    switch (Provider->GetCaps(WNNC_START))
    {
        case 0x0:
            lpNetInfoStruct->dwStatus = WN_NO_NETWORK;
            break;

        case 0x1:
            lpNetInfoStruct->dwStatus = WN_SUCCESS;
            break;

        default:
            lpNetInfoStruct->dwStatus = WN_FUNCTION_BUSY;
            break;
    }

    // We don't support this field.  The shell doesn't use it.
    // Win 95 gets it by looking at registry entries created by the
    // provider.  If the registry entries don't exist it leaves the
    // dwCharacteristics field as 0, which means that the provider
    // doesn't require redirection of a local drive to make a connection.
    lpNetInfoStruct->dwCharacteristics = 0;

    lpNetInfoStruct->dwHandle = (ULONG_PTR) Provider->Handle;

    // Note, this is a WORD field, not a DWORD.
    // Why does Win 95 omit the LOWORD anyway?
    lpNetInfoStruct->wNetType = HIWORD(Provider->Type);

    // We don't support these 2 fields.  The shell doesn't use them.
    // Win 95 gets them by calling NPValidLocalDevices.  If this entry
    // point doesn't exist it looks in the registry.  If the registry
    // value doesn't exist it uses NPP_ALLVALID which is defined as
    // 0xffffffff.
    lpNetInfoStruct->dwPrinters = 0xffffffff;

    lpNetInfoStruct->dwDrives = 0xffffffff;

    return WN_SUCCESS;
}


DWORD
WNetGetProviderNameW(
    IN      DWORD   dwNetType,
    OUT     LPWSTR  lpProviderName,
    IN OUT  LPDWORD lpBufferSize
    )

/*++

Routine Description:

    This function returns the provider name for a specified type of network.

Arguments:

    dwNetType - The network type unique to the network.  Only the high word
        of the network type is used; the subtype in the low word is ignored.
        If two networks claim the same type, the first one loaded is returned.

    lpProviderName - Pointer to a buffer in which to return the provider name.

    lpBufferSize - On entry, size of the lpProviderName buffer in characters.
        On exit, iff the return code is WN_MORE_DATA, set to the required size
        to hold the provider name.

Return Value:

    WN_SUCCESS - Call is successful.

    WN_MORE_DATA - The buffer is too small to hold the provider name.

    WN_NO_NETWORK - lpProvider does not match any active network provider.

--*/

{
    DWORD   status = WN_SUCCESS;

    __try
    {
        //
        // Validate the parameters that we can.
        //
        if (IS_BAD_WCHAR_BUFFER(lpProviderName, lpBufferSize))
        {
            status = WN_BAD_POINTER;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION)
        {
            MPR_LOG(ERROR,
                    "WNetGetProviderNameW: Unexpected Exception %#lx\n",
                    status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS)
    {
        SetLastError(status);
        return status;
    }

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    //
    // Loop through the list of providers to find one with the specified
    // net type.
    //
    LPPROVIDER provider = MprFindProviderByType(dwNetType);

    if (provider == NULL)
    {
        status = WN_NO_NETWORK;
    }
    else
    {
        //
        // Copy the provider name to the caller's buffer
        //
        DWORD dwReqSize = wcslen(provider->Resource.lpProvider) + 1;
        if (*lpBufferSize < dwReqSize)
        {
            status = WN_MORE_DATA;
            *lpBufferSize = dwReqSize;
        }
        else
        {
            status = WN_SUCCESS;
            wcscpy(lpProviderName, provider->Resource.lpProvider);
        }
    }

    if (status != WN_SUCCESS)
    {
        SetLastError(status);
    }

    return status;
}



DWORD
WNetGetProviderTypeW(
    IN  LPCWSTR         lpProvider,
    OUT LPDWORD         lpdwNetType
    )

/*++

Routine Description:

    This function returns the network type for a named network provider.

Arguments:

    lpProvider - Pointer to the name of the provider for which information is
        required.

    lpdwNetType - Pointer to a network type value that is filled in.

Return Value:

    WN_SUCCESS - Call is successful.

    WN_BAD_PROVIDER - lpProvider does not match any active network provider.

    WN_BAD_POINTER - an illegal argument was passed in.

Notes:

    Since this is an internal, private API used only by the shell, we do
    minimal parameter validation, to make it as fast as possible.

--*/

{
    DWORD       status = WN_SUCCESS;

    if (!(ARGUMENT_PRESENT(lpProvider) &&
          ARGUMENT_PRESENT(lpdwNetType)))
    {
        SetLastError(WN_BAD_POINTER);
        return WN_BAD_POINTER;
    }

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    //
    // Look up the provider by name
    //
    LPPROVIDER provider = MprFindProviderByName(lpProvider);
    if (NULL == provider)
    {
        SetLastError(WN_BAD_PROVIDER);
        return WN_BAD_PROVIDER;
    }

    *lpdwNetType = provider->Type;
    return WN_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\resinfo.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    resinfo.cxx

Abstract:

    Contains the entry points for the WinNet Resource Info API supported
    by the Multi-Provider Router.  The following functions are in this file:

        WNetGetResourceInformationW
        WNetGetResourceParentW

Author:

    Anirudh Sahni (anirudhs) 27-Apr-1995

Environment:

    User Mode -Win32

Notes:


Revision History:

    27-Apr-1995     anirudhs
        Created
    16-Oct-1995     anirudhs
        Converted to use MPR base classes
    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/
//
// INCLUDES
//
#include "precomp.hxx"


//===================================================================
// WNetGetResourceInformationW
//===================================================================

class CGetResourceInformation : public CRoutedOperation
{
public:
                    CGetResourceInformation(
                        LPNETRESOURCEW  lpNetResource,
                        LPVOID          lpBuffer,
                        LPDWORD         lpBufferSize,
                        LPWSTR         *lplpSystem
                        ) :
                            CRoutedOperation(DBGPARM("GetResourceInformation")
                                             PROVIDERFUNC(GetResourceInformation)),
                            _lpNetResource(lpNetResource),
                            _lpBuffer     (lpBuffer),
                            _lpBufferSize (lpBufferSize),
                            _lplpSystem   (lplpSystem)
                        { }

private:

    LPNETRESOURCEW  _lpNetResource;
    LPVOID          _lpBuffer;
    LPDWORD         _lpBufferSize;
    LPWSTR *        _lplpSystem;

    DECLARE_CROUTED
};


DWORD
CGetResourceInformation::ValidateRoutedParameters(
    LPCWSTR *       ppProviderName,
    LPCWSTR *       ppRemoteName,
    LPCWSTR *       ppLocalName
    )
{
    if (!(ARGUMENT_PRESENT(_lpNetResource) &&
          ARGUMENT_PRESENT(_lpBufferSize) &&
          ARGUMENT_PRESENT(_lplpSystem)))
    {
        return WN_BAD_POINTER;
    }

    if (_lpNetResource->lpRemoteName == NULL)
    {
        return WN_BAD_NETNAME;
    }

    //
    // If there is an output buffer, probe it.
    //
    if (IS_BAD_BYTE_BUFFER(_lpBuffer, _lpBufferSize))
    {
        return WN_BAD_POINTER;
    }

    *_lplpSystem = NULL;

    //
    // Set parameters used by base class.
    //
    *ppProviderName = _lpNetResource->lpProvider;
    *ppRemoteName   = _lpNetResource->lpRemoteName;
    *ppLocalName    = NULL;

    return WN_SUCCESS;
}


DWORD
CGetResourceInformation::TestProvider(
    const PROVIDER * pProvider
    )
{
    ASSERT_INITIALIZED(NETWORK);

    return ( pProvider->GetResourceInformation(
                            _lpNetResource,
                            _lpBuffer,
                            _lpBufferSize,
                            _lplpSystem) );
}


DWORD
WNetGetResourceInformationW(
    LPNETRESOURCEW  lpNetResource,
    LPVOID          lpBuffer,
    LPDWORD         lpBufferSize,
    LPWSTR         *lplpSystem
    )
/*++

Routine Description:

    This API is used to find enumeration information for a resource (whose
    name is typically typed in by the user).

Arguments:

    lpNetResource -

    lpBuffer -

    lpBufferSize -

    lplpSystem -

Return Value:

    WN_SUCCESS - Indicates the operation was successful.

    Other errors -

--*/
{
    CGetResourceInformation GetResInfo(lpNetResource,
                                       lpBuffer,
                                       lpBufferSize,
                                       lplpSystem);

    return (GetResInfo.Perform(TRUE));
}


//===================================================================
// WNetGetResourceParentW
//===================================================================

class CGetResourceParent : public CRoutedOperation
{
public:
                    CGetResourceParent(
                        LPNETRESOURCEW  lpNetResource,
                        LPVOID          lpBuffer,
                        LPDWORD         lpBufferSize
                        ) :
                            CRoutedOperation(DBGPARM("GetResourceParent")
                                             PROVIDERFUNC(GetResourceParent)),
                            _lpNetResource(lpNetResource),
                            _lpBuffer     (lpBuffer),
                            _lpBufferSize (lpBufferSize)
                        { }

private:

    LPNETRESOURCEW  _lpNetResource;
    LPVOID          _lpBuffer;
    LPDWORD         _lpBufferSize;

    DECLARE_CROUTED
};


DWORD
CGetResourceParent::ValidateRoutedParameters(
    LPCWSTR *       ppProviderName,
    LPCWSTR *       ppRemoteName,
    LPCWSTR *       ppLocalName
    )
{
    if (!(ARGUMENT_PRESENT(_lpNetResource) &&
          ARGUMENT_PRESENT(_lpBufferSize)))
    {
        return WN_BAD_POINTER;
    }

    if (_lpNetResource->lpRemoteName == NULL)
    {
        return WN_BAD_NETNAME;
    }

    //
    // Unlike Win95, we require a provider name.  This allows our providers
    // to make several simplifying assumptions.
    //
    if (IS_EMPTY_STRING(_lpNetResource->lpProvider))
    {
        return WN_BAD_PROVIDER;
    }

    //
    // If there is an output buffer, probe it.
    //
    if (IS_BAD_BYTE_BUFFER(_lpBuffer, _lpBufferSize))
    {
        return WN_BAD_POINTER;
    }

    //
    // Set parameters used by base class.
    //
    *ppProviderName = _lpNetResource->lpProvider;
    *ppRemoteName   = _lpNetResource->lpRemoteName;
    *ppLocalName    = NULL;

    return WN_SUCCESS;
}


DWORD
CGetResourceParent::TestProvider(
    const PROVIDER * pProvider
    )
{
    ASSERT_INITIALIZED(NETWORK);

    return ( pProvider->GetResourceParent(
                            _lpNetResource,
                            _lpBuffer,
                            _lpBufferSize) );
}


DWORD
WNetGetResourceParentW(
    LPNETRESOURCEW  lpNetResource,
    LPVOID          lpBuffer,
    LPDWORD         lpBufferSize
    )
/*++

Routine Description:

    This API is used to find enumeration information for a resource (whose
    name is typically typed in by the user).

Arguments:

    lpNetResource -

    lpBuffer -

    lpBufferSize -

Return Value:

    WN_SUCCESS - Indicates the operation was successful.

    Other errors -

--*/
{
    CGetResourceParent GetResParent(lpNetResource, lpBuffer, lpBufferSize);

    return (GetResParent.Perform(TRUE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\strbuf.cxx ===
#include "precomp.hxx"
#include <wchar.h>      // wcsncpy
#include <tstring.h>


BOOL
NetpCopyStringToBufferW (
    IN LPWSTR String OPTIONAL,
    IN DWORD CharacterCount,
    IN LPWSTR FixedDataEnd,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    )

/*++

Routine Description:

    This routine puts a single variable-length string into an output buffer.
    The string is not written if it would overwrite the last fixed structure
    in the buffer.

    The code is swiped from svcsupp.c written by DavidTr.

    Sample usage:

            LPBYTE FixedDataEnd = OutputBuffer + sizeof(WKSTA_INFO_202);
            LPTSTR EndOfVariableData = OutputBuffer + OutputBufferSize;

            //
            // Copy user name
            //

            NetpCopyStringToBuffer(
                UserInfo->UserName.Buffer;
                UserInfo->UserName.Length;
                FixedDataEnd,
                &EndOfVariableData,
                &WkstaInfo->wki202_username
                );

Arguments:

    String - Supplies a pointer to the source string to copy into the
        output buffer.  If String is null then a pointer to a zero terminator
        is inserted into output buffer.

    CharacterCount - Supplies the length of String, not including zero
        terminator.  (This in units of characters - not bytes).

    FixedDataEnd - Supplies a pointer to just after the end of the last
        fixed structure in the buffer.

    EndOfVariableData - Supplies an address to a pointer to just after the
        last position in the output buffer that variable data can occupy.
        Returns a pointer to the string written in the output buffer.

    VariableDataPointer - Supplies a pointer to the place in the fixed
        portion of the output buffer where a pointer to the variable data
        should be written.

Return Value:

    Returns TRUE if string fits into output buffer, FALSE otherwise.

--*/
{

//  The following line has been removed.  Since we are manipulating
//  either LPSTR or LPWSTR, the pointer arithmetic automatically deals with
//  either bytes or words.  It is therefore only proper to deal in terms
//  of characters needed.  Not Bytes needed.  Therefore, the symbol has
//  been changed from BytesNeeded to CharsNeeded.
//
//    DWORD BytesNeeded = (CharacterCount + 1) * sizeof(WCHAR);
//
//
    DWORD CharsNeeded = (CharacterCount + 1);


#ifdef remove
    DbgPrint("NetpStringToBuffer: String at " FORMAT_POINTER
                ", CharacterCount=" FORMAT_DWORD
                ",\n  FixedDataEnd at " FORMAT_POINTER
                ", *EndOfVariableData at " FORMAT_POINTER
                ",\n  VariableDataPointer at " FORMAT_POINTER
                ", CharsNeeded=" FORMAT_DWORD ".\n",
                String, CharacterCount, FixedDataEnd, *EndOfVariableData,
                VariableDataPointer, CharsNeeded);
#endif
    //
    // Determine if string will fit, allowing for a zero terminator.  If no,
    // just set the pointer to NULL.
    //

    if ((*EndOfVariableData - CharsNeeded) >= FixedDataEnd) {

        //
        // It fits.  Move EndOfVariableData pointer up to the location where
        // we will write the string.
        //

        *EndOfVariableData -= CharsNeeded;

        //
        // Copy the string to the buffer if it is not null.
        //

        if (CharacterCount > 0 && String != NULL) {

            wcsncpy(*EndOfVariableData, String, CharacterCount);
        }

        //
        // Set the zero terminator.
        //

        *(*EndOfVariableData + CharacterCount) = (WCHAR) '\0';

        //
        // Set up the pointer in the fixed data portion to point to where the
        // string is written.
        //

        *VariableDataPointer = *EndOfVariableData;

        return TRUE;

    }
    else {

        //
        // It doesn't fit.  Set the offset to NULL.
        //

        *VariableDataPointer = NULL;

        return FALSE;
    }
} // NetpCopyStringToBuffer


BOOL
NetpCopyStringToBufferA (
    IN LPTSTR String OPTIONAL,
    IN DWORD CharacterCount,
    IN LPBYTE FixedDataEnd,
    IN OUT LPTSTR *EndOfVariableData,
    OUT LPTSTR *VariableDataPointer
    )

/*++

Routine Description:

    This routine puts a single variable-length string into an output buffer.
    The string is not written if it would overwrite the last fixed structure
    in the buffer.

    The code is swiped from svcsupp.c written by DavidTr.

    Sample usage:

            LPBYTE FixedDataEnd = OutputBuffer + sizeof(WKSTA_INFO_202);
            LPTSTR EndOfVariableData = OutputBuffer + OutputBufferSize;

            //
            // Copy user name
            //

            NetpCopyStringToBuffer(
                UserInfo->UserName.Buffer;
                UserInfo->UserName.Length;
                FixedDataEnd,
                &EndOfVariableData,
                &WkstaInfo->wki202_username
                );

Arguments:

    String - Supplies a pointer to the source string to copy into the
        output buffer.  If String is null then a pointer to a zero terminator
        is inserted into output buffer.

    CharacterCount - Supplies the length of String, not including zero
        terminator.

    FixedDataEnd - Supplies a pointer to just after the end of the last
        fixed structure in the buffer.

    EndOfVariableData - Supplies an address to a pointer to just after the
        last position in the output buffer that variable data can occupy.
        Returns a pointer to the string written in the output buffer.

    VariableDataPointer - Supplies a pointer to the place in the fixed
        portion of the output buffer where a pointer to the variable data
        should be written.

Return Value:

    Returns TRUE if string fits into output buffer, FALSE otherwise.

--*/
{
    DWORD BytesNeeded = (CharacterCount + 1) * sizeof(TCHAR);

#ifdef remove
    DbgPrint("NetpStringToBuffer: String at " FORMAT_POINTER
            ", CharacterCount=" FORMAT_DWORD
            ",\n  FixedDataEnd at " FORMAT_POINTER
            ", *EndOfVariableData at " FORMAT_POINTER
            ",\n  VariableDataPointer at " FORMAT_POINTER
            ", BytesNeeded=" FORMAT_DWORD ".\n",
            String, CharacterCount, FixedDataEnd, *EndOfVariableData,
            VariableDataPointer, BytesNeeded);

#endif
    //
    // Determine if string will fit, allowing for a zero terminator.  If no,
    // just set the pointer to NULL.
    //

    if ((*EndOfVariableData - BytesNeeded) >= (LPTSTR)FixedDataEnd) {

        //
        // It fits.  Move EndOfVariableData pointer up to the location where
        // we will write the string.
        //

        *EndOfVariableData -= BytesNeeded;

        //
        // Copy the string to the buffer if it is not null.
        //

        if (CharacterCount > 0 && String != NULL) {

            STRNCPY(*EndOfVariableData, String, CharacterCount);
        }

        //
        // Set the zero terminator.
        //

        *(*EndOfVariableData + CharacterCount) = (TCHAR) '\0';

        //
        // Set up the pointer in the fixed data portion to point to where the
        // string is written.
        //

        *VariableDataPointer = *EndOfVariableData;

        return TRUE;

    }
    else {

        //
        // It doesn't fit.  Set the offset to NULL.
        //

        *VariableDataPointer = NULL;

        return FALSE;
    }
} // NetpCopyStringToBufferA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\support.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    support.cxx

Abstract:

    Contains functions that are used by all MPR API.
        MprFindCallOrder
        MprInitIndexArray
        MprDeleteIndexArray
        MprDeviceType
        MprGetProviderIndex
        MprFindProviderByName
        MprFindProviderByType
        MprEnterLoadLibCritSect
        MprLeaveLoadLibCritSect
        MprGetUserName

Author:

    Dan Lafferty (danl)     09-Oct-1991

Environment:

    User Mode -Win32

Notes:



Revision History:

    05-May-1999     jschwart
        Make provider addition/removal dynamic

    15-Jan-1996     anirudhs
        Add MprGetUserName.

    22-Jan-1993     danl
        FindCallOrder:  This code was going through the global array of
        providers, rather than looking at only "Active" providers.  It should
        have been using the GlobalIndexArray which is an array of the indices
        for the "Active" providers only.

    02-Nov-1992     danl
        Fail with NO_NETWORK if there are no providers.

    09-Oct-1991     danl
        created

--*/

//
// INCLUDES
//
#include "precomp.hxx"
#include <string.h>     // memcmp
#include <tstring.h>    // STRCMP
#include <debugfmt.h>   // FORMAT_LPTSTR
#include <lmcons.h>     // NET_API_FUNCTION
#include <lmerr.h>      // NET_API_STATUS

//
// EXTERNALS
//
    extern DWORD        GlobalNumActiveProviders;
    extern CRITICAL_SECTION MprInitCritSec;



#define DEFAULT_ERROR_BUF_SIZE  1024

//
// MprLoadLibSemaphore global var is used to protect the DLL
// handle and Entry point addresses for delayed loading of MPRUI.DLL.
// It is initialized at process attach time.
//
HANDLE MprLoadLibSemaphore = NULL ;

//
// This is where the pointer to the array of provider indices is stored.
//
/* static */ LPDWORD   GlobalIndexArray;



DWORD
MprFindCallOrder(
    IN     LPTSTR      NameInfo,
    IN OUT LPDWORD     *IndexArrayPtr,
    OUT    LPDWORD     IndexArrayCount,
    IN     DWORD       InitClass
    )

/*++

Routine Description:

    This function determines the proper order in which to call the
    various providers.

    This order is based on the ordered list that is stored in the
    registry.

    Because the provider structures are kept in an array, the indices can
    be used to index into that array.

    IMPORTANT! : Memory may be allocated for this array, so it
    is the responsibility of the caller to free the memory when it is
    finished.


Arguments:

    NameInfo - This is a pointer to a string that is most likely to
        contain the name of the network resource being addressed.  If a
        NULL pointer, or a pointer to a NULL string is passed in, this
        information will be ignored. (Note: Currently this information is
        not used).

    IndexArrayPtr - This is a pointer to a location where the pointer to
        the array of indices resides.  On entry, the pointer in this
        location points to an array allocated by the caller.  This array
        is expected to be DEFAULT_MAX_PROVIDERS long.  If a larger array
        is required, this function will allocate space for it and
        replace this pointer with the new one.

    IndexArrayCount - This is a pointer to a location where the number of
        elements in the returned array is to be placed.

    InitClass - This indicates what type of providers we want listed in the
        array.  The choices are either CREDENTIAL_TYPE or NETWORK_TYPE
        providers.

Return Value:

     WN_SUCCESS - If the operation was successful.

     WN_OUT_OF_MEMORY - If this function was unable to allocate memory for
        the return buffer.

     WN_NO_NETWORK - If there are no providers available, or none of the
        providers support this InitClass.

--*/
{

    DWORD   i,j;

    UNREFERENCED_PARAMETER(NameInfo);
    //
    // If there are no Providers, then return WN_NO_NETWORK
    //
    ASSERT(MPR_IS_INITIALIZED(NETWORK) || MPR_IS_INITIALIZED(CREDENTIAL));
    ASSERT(MPRProviderLock.Have());

    if (GlobalNumActiveProviders == 0) {
        return(WN_NO_NETWORK);
    }

    //
    // We cannot interact with active provider information unless we
    // have obtained synchronized access.  Otherwise we would risk
    // trying to read data while it is being modified.
    //
    EnterCriticalSection(&MprInitCritSec);

    if (GlobalNumActiveProviders > DEFAULT_MAX_PROVIDERS) {
        *IndexArrayPtr = (LPDWORD) LocalAlloc(LPTR,
                            GlobalNumProviders*sizeof(DWORD));

        if (*IndexArrayPtr == NULL) {
           MPR_LOG1(ERROR,"FindCallOrder: LocalAlloc Failed %d\n",GetLastError());

           LeaveCriticalSection(&MprInitCritSec);
           return (WN_OUT_OF_MEMORY);
        }
    }

    //
    // Fill in the array with the order that was obtained from the ordered
    // list at initialization time.  (Stored in GlobalIndexArray).
    //


    MPR_LOG0(TRACE,"CallOrder - \n");

    for( i=j=0; i<GlobalNumActiveProviders; i++) {

        if (GlobalProviderInfo[GlobalIndexArray[i]].InitClass & InitClass) {
            (*IndexArrayPtr)[j] = GlobalIndexArray[i];
            j++;
        }

        MPR_LOG1(TRACE,"\tprovider index: %d  \n",GlobalIndexArray[i]);
    }

    MPR_LOG0(TRACE,"\n");

    LeaveCriticalSection(&MprInitCritSec);
    if (j == 0) {
        return(WN_NO_NETWORK);
    }
    *IndexArrayCount = j;


    return(WN_SUCCESS);
}



//+-------------------------------------------------------------------------
//
//  Function:   CRoutedOperation::FindCallOrder (static)
//
//  Purpose:    This function determines the proper order in which to call the
//              various providers.
//              This order is based on the ordered list that is stored in the
//              registry.
//
//  Arguments:
//
//      NameInfo - This is a pointer to a string that is most likely to
//          contain the name of the network resource being addressed.  If a
//          NULL pointer, or a pointer to a NULL string is passed in, this
//          information will be ignored.
//
//      ProviderArray - This is a pointer to an array of LPPROVIDERs.
//          This array is expected to be GlobalNumProviders long.
//
//      ProviderArrayCount - This is a pointer to a location where the number of
//          elements in the returned array is to be placed.
//
//      InitClass - This indicates what type of providers we want listed in the
//          array.  The choices are either CREDENTIAL_TYPE or NETWORK_TYPE
//          providers.
//
//  Return Value:
//
//       WN_SUCCESS - If the operation was successful.
//
//       WN_NO_NETWORK - If there are no providers available, or none of the
//          providers support this InitClass.
//
//
//  History:    08-Apr-96 AnirudhS  Created from MprFindCallOrder
//
//  Notes:      CODEWORK This should replace MprFindCallOrder.
//
//--------------------------------------------------------------------------

DWORD CRoutedOperation::FindCallOrder(
    IN     const UNICODE_STRING * NameInfo,
    OUT    LPPROVIDER  ProviderArray[],
    OUT    LPDWORD     ProviderArrayCount,
    IN     DWORD       InitClass
    )
{
    //
    // If there are no Providers, then return WN_NO_NETWORK
    //
    ASSERT(MPR_IS_INITIALIZED(NETWORK) || MPR_IS_INITIALIZED(CREDENTIAL));
    ASSERT(MPRProviderLock.Have());

    if (GlobalNumActiveProviders == 0)
    {
        return WN_NO_NETWORK;
    }

    //
    // We cannot interact with active provider information unless we
    // have obtained synchronized access.  Otherwise we would risk
    // trying to read data while it is being modified.
    //
    EnterCriticalSection(&MprInitCritSec);

    //
    // If a provider previously responded for the specified path, put it
    // first in the array.
    //
    DWORD j = 0;    // index into ProviderArray
    LPPROVIDER CachedProvider = _PathCache.FindEntry(NameInfo);
    if (CachedProvider != NULL && (CachedProvider->InitClass & InitClass))
    {
        ProviderArray[j] = CachedProvider;
        j++;
    }

    //
    // Fill in the array with the order that was obtained from the ordered
    // list at initialization time.  (Stored in GlobalIndexArray).
    //
    for (DWORD i=0; i<GlobalNumActiveProviders; i++)
    {
        LPPROVIDER Provider = &GlobalProviderInfo[GlobalIndexArray[i]];
        if ((Provider->InitClass & InitClass) &&
            Provider != CachedProvider)
        {
            ProviderArray[j] = Provider;
            j++;
        }
    }

    LeaveCriticalSection(&MprInitCritSec);

    if (j == 0)
    {
        return WN_NO_NETWORK;
    }

    *ProviderArrayCount = j;

    return WN_SUCCESS;
}


VOID
MprInitIndexArray(
    LPDWORD     IndexArray,
    DWORD       NumEntries
    )

/*++

Routine Description:

    This function stores data from the passed in IndexArray in a global
    IndexArray.  If a global index array already exists when this function
    is called, then the two arrays need to be merged.  This function also
    updates the GlobalNumActiveProviders.

    NOTE:  The array of provider structures is always created in the
    order specified by the ordered provider list.  Therefore, it is reasonable
    to merge these lists by putting the array of indices in increasing order.

    It is expected that the MprInitCritSec lock is held prior to entering
    this function.

    This function will free the memory pointed to by IndexArray, if it is
    no longer needed.


Arguments:

    IndexArray - This is a pointer to an array of DWORDs which are indices
        to the various providers.  The buffer for this array is always
        large enough to hold indices for all providers; active, or inactive.

    NumEntries - This contains the number of entries in the IndexArray.


Return Value:

    none

--*/
{
    DWORD       newNumEntries=0;
    DWORD       dest,s1,s2;         // index for Destination, Source1, and Source2.
    DWORD       tempBuffer[16];
    LPDWORD     tempArray;


    if (NumEntries == 0) {
        return;
    }

    if (GlobalIndexArray == NULL) {
        GlobalNumActiveProviders = NumEntries;
        GlobalIndexArray = IndexArray;
    }
    else {

        //
        // An list already exists.  Therefore we need to create a new
        // list of ordered indices.
        //

        //
        // Copy the GlobalIndexArray data into a temporary buffer.  We
        // will try to use a buffer on the stack.  If that isn't large
        // enough, we will try to allocate a buffer.
        //
        tempArray = tempBuffer;
        if (GlobalNumProviders > 16) {
            tempArray = (LPDWORD)LocalAlloc(LPTR, GlobalNumProviders);
            if (tempArray == NULL) {
                MPR_LOG1(ERROR,"MprInitIndexArray: LocalAlloc failed %d\n",GetLastError());
                LocalFree(IndexArray);
                return;
            }
        }
        memcpy(tempArray, GlobalIndexArray, GlobalNumActiveProviders*sizeof(DWORD));


        //
        // Now copy an ordered list of indices into the GlobalIndexArray.
        // We assume that the two seperate lists are already ordered in
        // ascending order.  Therefore, we compare elements in both lists
        // one at a time - incrementing the index only for the array
        // containing the element that we move to the GlobalIndexArray.
        //
        dest=s1=s2=0;

        while ((s1 < GlobalNumActiveProviders) &&
               (s2 < NumEntries)) {

            if (tempArray[s1] < IndexArray[s2]) {
                GlobalIndexArray[dest] = tempArray[s1++];
            }
            else if (tempArray[s1] > IndexArray[s2]) {
                GlobalIndexArray[dest] = IndexArray[s2++];
            }
            else {
                GlobalIndexArray[dest] = IndexArray[s2];
                s1++;
                s2++;
            }
            dest++;
        }

        //
        // One of the arrays has reached its limit.  Therefore, the elements
        // from the remaining array must be moved.
        //
        if (s1 < GlobalNumActiveProviders) {
            do {
                GlobalIndexArray[dest++] = tempArray[s1++];
            } while (s1 < GlobalNumActiveProviders);
        }
        else if (s2 < NumEntries) {
            do  {
                GlobalIndexArray[dest++] = IndexArray[s2++];
            } while (s2 < NumEntries);
        }


        GlobalNumActiveProviders = dest;

        //
        // If we had to allocate a temporary buffer, then free it here.
        //
        if (tempArray != tempBuffer) {
            LocalFree(tempArray);
        }
        LocalFree(IndexArray);
    }

    return;
}

VOID
MprDeleteIndexArray(
    VOID
    )

/*++

Routine Description:

    This function frees up global resources used in the support routines.

Arguments:

    none

Return Value:

    none

--*/
{
    LocalFree(GlobalIndexArray);
    GlobalIndexArray = NULL;
    return;
}



DWORD
MprDeviceType(
    IN  LPCTSTR DeviceName
    )

/*++

Routine Description:

    This function determines if the device name is for a redirected device
    (port or drive), or if it is a name of a remote share point.

Arguments:

    DeviceName - This is the name that is passed in.  It is either the
        name of a redirected device (ie. c: lpt2: lpt3:) or it is
        the name of a share point (\\cyclops\scratch).

Return Value:

    REDIR_DEVICE - The name is for a redirected device

    REMOTE_NAME - The name is that of a remote connection.

--*/
{
    if (memcmp(DeviceName, TEXT("\\\\"), 2*sizeof(TCHAR)) == 0) {
        return(REMOTE_NAME);
    }

    if ((STRLEN(DeviceName) == 2)       &&
        (DeviceName[1] == TEXT(':')))   {

        if ((TEXT('a') <= DeviceName[0]) && (DeviceName[0] <= TEXT('z'))) {
            return(REDIR_DEVICE);
        }
        else if ((TEXT('A') <= DeviceName[0]) && (DeviceName[0] <= TEXT('Z'))) {
            return(REDIR_DEVICE);
        }

    }
    else if (STRLEN(DeviceName) > 3) {

        if (STRNICMP(DeviceName, TEXT("LPT"), 3) == 0) {
            return(REDIR_DEVICE);
        }
        if (STRNICMP(DeviceName, TEXT("COM"), 3) == 0) {
            return(REDIR_DEVICE);
        }
    }

    return(REMOTE_NAME);
}



BOOL
MprGetProviderIndex(
    IN  LPCTSTR ProviderName,
    OUT LPDWORD IndexPtr
    )

/*++

Routine Description:

    This function looks in the provider database for a Provider name that
    will match the name passed in.  When it is found, the index to that
    provider is stored in the location pointed to by IndexPtr.

Arguments:

    ProviderName - This is a pointer to a string that contains the
        name which identifies a provider.

    IndexPtr - This is a pointer to a location where the index for the
        provider information is to be placed.

Return Value:

    TRUE - The operation was successful.

    FALSE - A failure occured.  IndexPtr is not updated.

--*/
{
    LPPROVIDER  lpProvider;
    DWORD       i;

    ASSERT_INITIALIZED(FIRST);

    //
    // Point to the top of the array of provider structures.
    //
    lpProvider = GlobalProviderInfo;

    //
    // Loop through each provider in the database until the list is
    // exhausted, or until a match with the provider name is found.
    //
    for(i=0; i<GlobalNumProviders; i++,lpProvider++) {

        if (lpProvider->Resource.lpProvider != NULL) {
            if(STRICMP(lpProvider->Resource.lpProvider, ProviderName) == 0) {
                //
                // A match is found, return the pointer to the provider
                // structure.
                //
                *IndexPtr = i;
                return(TRUE);
            }
        }
    }
    //
    // The list of provider structures was exhausted and no provider match
    // was found.  Return a NULL pointer.
    //
    return(FALSE);
}

LPPROVIDER
MprFindProviderByName(
    IN  LPCWSTR ProviderName
    )

/*++

Routine Description:

    This function searches the provider database for the first provider
    whose provider name matches the name passed in, and returns a pointer
    to the provider structure.

Arguments:

    ProviderName - The provider name to look for.

Return Value:

    Pointer to the provider structure if a match was found, NULL if not.

--*/
{
    ASSERT(ProviderName != NULL);
    ASSERT_INITIALIZED(FIRST);

    for (LPPROVIDER lpProvider = GlobalProviderInfo;
         lpProvider < GlobalProviderInfo + GlobalNumProviders;
         lpProvider++)
    {
        if (lpProvider->Resource.lpProvider != NULL &&
            STRICMP(lpProvider->Resource.lpProvider, ProviderName) == 0)
        {
            return lpProvider;
        }
    }

    return NULL;
}


LPPROVIDER
MprFindProviderByType(
    IN  DWORD   ProviderType
    )

/*++

Routine Description:

    This function searches the provider database for the first provider
    whose provider type matches the type passed in, and returns a pointer
    to the provider structure.

Arguments:

    ProviderType - The network type to look for.  Only the HIWORD is used;
        the LOWORD is ignored.

Return Value:

    Pointer to the provider structure if a match was found, NULL if not.

--*/
{
    ASSERT(MPR_IS_INITIALIZED(NETWORK) || MPR_IS_INITIALIZED(CREDENTIAL));
    ASSERT(MPRProviderLock.Have());

    for (LPPROVIDER lpProvider = GlobalProviderInfo;
         lpProvider < GlobalProviderInfo + GlobalNumProviders;
         lpProvider++)
    {
        //
        // if (HIWORD(lpProvider->Type) == HIWORD(ProviderType))
        //
        if (((lpProvider->Type ^ ProviderType) & 0xFFFF0000) == 0 &&
            (lpProvider->InitClass & NETWORK_TYPE) != 0)
        {
            return lpProvider;
        }
    }

    return NULL;
}


DWORD
MprEnterLoadLibCritSect (
    VOID
    )
/*++

Routine Description:

    This function enters the critical section defined by
    MprLoadLibrarySemaphore.

Arguments:

    none

Return Value:

    0 - The operation was successful.

    error code otherwise.

--*/

#define LOADLIBRARY_TIMEOUT 10000L
{
    switch( WaitForSingleObject( MprLoadLibSemaphore, LOADLIBRARY_TIMEOUT ))
    {
    case 0:
    return 0 ;

    case WAIT_TIMEOUT:
    return WN_FUNCTION_BUSY ;

    case 0xFFFFFFFF:
    return (GetLastError()) ;

    default:
    return WN_WINDOWS_ERROR ;
    }
}

DWORD
MprLeaveLoadLibCritSect (
    VOID
    )
/*++

Routine Description:

    This function leaves the critical section defined by
    MprLoadLibrarySemaphore.

Arguments:

    none

Return Value:

    0 - The operation was successful.

    error code otherwise.

--*/
{
    if (!ReleaseSemaphore( MprLoadLibSemaphore, 1, NULL ))
        return (GetLastError()) ;

    return 0 ;
}

VOID
MprClearString (
    LPWSTR  lpString
    )
/*++

Routine Description:

    This function clears the string by setting it to all zero.

Arguments:

    lpString - string to NULL out

Return Value:

    none

--*/
{
    DWORD dwLen ;

    if (lpString)
    {
        dwLen = wcslen(lpString) ;
        memset(lpString, 0, dwLen * sizeof(WCHAR)) ;
    }
}

DWORD
MprFindProviderForPath(
    IN  LPWSTR  lpPathName,
    OUT LPDWORD lpProviderIndex
    )

/*++

Routine Description:

    This function attempts to find the provider index for the provider that is
    responsible for the pathname that is passed in.  Only the drive letter is
    examined.  Then MprGetConnection is called to find the provider for that
    drive.

Arguments:

    lpPathName - This is a pointer to the pathname string.  It is expected to
        be of the format <drive:><path>.  (ie.  f:\nt\system32>.

    lpProviderIndex - This is a pointer to the location where the provider index
        is to be returned.  If an error is returned, this index is garbage.


Return Value:

    WN_SUCCESS - If the operation is successful.  In this case the provider
        index will always be correct.

    otherwise - An error occured, the provider index will not be correct.

--*/
{
    DWORD       status=WN_SUCCESS;
    WCHAR       lpDriveName[3];
    WCHAR       lpRemoteName[MAX_PATH];
    DWORD       bufSize = MAX_PATH * sizeof(WCHAR);

    //
    // Get the drive letter out of the lpDriveName.
    //
    __try {
        if (lpPathName[1] != L':') {
            return(WN_BAD_VALUE);
        }
        lpDriveName[0] = lpPathName[0];
        lpDriveName[1] = lpPathName[1];
        lpDriveName[2] = L'\0';

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetGetPropertyText:Unexpected Exception "
            "0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }
    if (status != WN_SUCCESS) {
        return(status);
    }

    //
    // Find out which provider owns the drive by calling MprGetConnection.
    //
    status = MprGetConnection(
                lpDriveName,
                lpRemoteName,
                &bufSize,
                lpProviderIndex);

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\idl\winsimp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Pradeep Bahl 	Apr-1992 

Revision History:


--*/



#include <windef.h>
#ifdef MIDL_PASS
#define va_list char		//required so that I can include winsbase.h
				//in winsintf.h (to get def of SYSTEMTIME
#ifdef UNICODE
#define LPTSTR [string] wchar_t*
#else
#define LPTSTR [string] LPTSTR
#endif
#define LPSTR [string] LPSTR
#define RPC_BOOL DWORD
#else
#include <stdarg.h>		//for definition of va_list
#endif
#include <winsintf.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\mib\winsmib.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    winsmib.h

Abstract:

    Sample SNMP Extension Agent for Windows NT.

    These files (winsmibm.c, winsmib.c, and winsmib.h) provide an example of 
    how to structure an Extension Agent DLL which works in conjunction with 
    the SNMP Extendible Agent for Windows NT.

    Extensive comments have been included to describe its structure and
    operation.  See also "Microsoft Windows/NT SNMP Programmer's Reference".

Created:

    13-Jun-1991

Revision History:

--*/

#ifndef winsmib_h
#define winsmib_h

static char *winsmib__h = "@(#) $Logfile:   N:/xtest/vcs/winsmib.h_v  $ $Revision:   1.2  $";


// Necessary includes.

#include <snmp.h>


// MIB Specifics.

#define MIB_PREFIX_LEN            MIB_OidPrefix.idLength
#define MAX_STRING_LEN            255


// Ranges and limits for specific MIB variables.





#define NON_ASN_USED_RANGE_START	0xe0	//high 3 bits not used by
						//ASN
//
// MIB function actions.
//

#define MIB_GET         ASN_RFC1157_GETREQUEST
#define MIB_SET         ASN_RFC1157_SETREQUEST
#define MIB_GETNEXT     ASN_RFC1157_GETNEXTREQUEST
#define MIB_GETFIRST	(ASN_PRIVATE | ASN_CONSTRUCTOR | 0x0)


// MIB Variable access privileges.

#define MIB_ACCESS_READ        0
#define MIB_ACCESS_WRITE       1
#define MIB_ACCESS_READWRITE   2
#define MIB_NOACCESS  	       3	


// Macro to determine number of sub-oid's in array.

#define OID_SIZEOF( Oid )      ( sizeof Oid / sizeof(UINT) )


// MIB variable ENTRY definition.  This structure defines the format for
// each entry in the MIB.

typedef struct mib_entry
           {
	   AsnObjectIdentifier Oid;
	   void *              Storage;
	   BYTE                Type;
	   UINT                Access;
	   UINT                (*MibFunc)( UINT, struct mib_entry *,
	                                   RFC1157VarBind * );
	   struct mib_entry *  MibNext;
	   } MIB_ENTRY, *PMIB_ENTRY;

typedef struct table_entry
           {
	   UINT                (*MibFunc)( UINT, struct mib_entry *,
	                                   RFC1157VarBind * );
	   struct mib_entry *  Mibptr;
	   } TABLE_ENTRY, *PTABLE_ENTRY;


// Internal MIB structure.

extern UINT      MIB_num_variables;
extern BOOL	 fWinsMibWinsStatusCnfCalled;
extern BOOL	 fWinsMibWinsStatusStatCalled;

// Prefix to every variable in the MIB.

extern AsnObjectIdentifier MIB_OidPrefix;
extern CRITICAL_SECTION	   WinsMibCrtSec;
extern HKEY		   WinsMibWinsKey;
extern BOOL		   fWinsMibWinsKeyOpen;

//extern MIB_ENTRY	Mib[];
extern MIB_ENTRY	*pWinsMib;
// Function Prototypes.

extern
UINT ResolveVarBind(
        IN OUT RFC1157VarBind *VarBind, // Variable Binding to resolve
	IN UINT PduAction               // Action specified in PDU
	);

extern
VOID WinsMibInit(
	VOID
	);

#if 0
extern
VOID
WinsMibInitTables();
#endif

#endif /* winsmib_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\mib\winsmib.c ===
//
// TODO: Make it multithreaded
//

/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    winsmib.c

Abstract:

    Sample SNMP Extension Agent for Windows NT.

    These files (testdll.c, winsmib.c, and winsmib.h) provide an example of
    how to structure an Extension Agent DLL which works in conjunction with
    the SNMP Extendible Agent for Windows NT.

    Extensive comments have been included to describe its structure and
    operation.  See also "Microsoft Windows/NT SNMP Programmer's Reference".

Created:

    7-Oct-1991

Revision History:

--*/


#ifdef UNICODE
#undef UNICODE
#endif

// This Extension Agent implements the Internet toaster MIB.  It's
// definition follows here:
//
//

// Necessary includes.

#include "wins.h"
#include <malloc.h>

#include <snmp.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <search.h>
#include <winsock2.h>
#include "nmsdb.h"
//#include "winsif.h"
#include "winsintf.h"
#include "winscnf.h"
#include "nmsmsgf.h"


// Contains definitions for the table structure describing the MIB.  This
// is used in conjunction with winsmib.c where the MIB requests are resolved.

#include "winsmib.h"


// If an addition or deletion to the MIB is necessary, there are several
// places in the code that must be checked and possibly changed.
//
// The last field in each MIB entry is used to point to the NEXT
// leaf variable.  If an addition or deletetion is made, these pointers
// may need to be updated to reflect the modification.

#define _WINS_CNF_KEY         TEXT("System\\CurrentControlSet\\Services\\Wins")
#define _WINS_PARAMETERS_KEY       TEXT("Parameters")
#define _WINS_PARTNERS_KEY         TEXT("Partners")
#define _WINS_DATAFILES_KEY        TEXT("Datafiles")
#define _WINS_PULL_KEY             TEXT("Pull")
#define _WINS_PUSH_KEY             TEXT("Push")

#define NO_FLDS_IN_PULLADD_KEY      8  //Flds are ip add, time interval, sp time
#define NO_FLDS_IN_PUSHADD_KEY      2  //Flds are ip add, update count
#define NO_FLDS_IN_DR               5  //Flds in a data record

#define LOCAL_ADD                     "127.0.0.1"
#define WINSMIB_FILE_INFO_SIZE         255

#define WINSMIB_DR_CACHE_TIME        (120)                //2 minutes
BOOL  fWinsMibWinsKeyOpen           = FALSE;

HKEY  WinsMibWinsKey;

STATIC HKEY  sParametersKey;
STATIC HKEY  sPartnersKey;
STATIC HKEY  sPullKey;
STATIC HKEY  sPushKey;
STATIC HKEY  sDatafilesKey;

STATIC BOOL  sfParametersKeyOpen = FALSE;
STATIC BOOL  sfPartnersKeyOpen   = FALSE;
STATIC BOOL  sfDatafilesKeyOpen  = FALSE;
STATIC BOOL  sfPullKeyOpen       = FALSE;
STATIC BOOL  sfPushKeyOpen       = FALSE;

STATIC time_t  sDRCacheInitTime = 0;

//
// The prefix to all of the WINS MIB variables is 1.3.6.1.4.1.311.1.2
//
// The last digit -- 2 is for the WINS MIB
//

UINT OID_Prefix[] = { 1, 3, 6, 1, 4, 1, 311, 1 , 2};
AsnObjectIdentifier MIB_OidPrefix = { OID_SIZEOF(OID_Prefix), OID_Prefix };
BOOL        fWinsMibWinsStatusCnfCalled;
BOOL        fWinsMibWinsStatusStatCalled;

WINSINTF_BIND_DATA_T        sBindData;
WINSINTF_RECS_T                sRecs = {0};



//
// Definition of the Wins MIB  (not used)
//

//UINT MIB_Wins[]  = { 2 };

//
// OID definitions for MIB
//

//
// Definition of group and leaf variables under the wins group
// All leaf variables have a zero appended to their OID to indicate
// that it is the only instance of this variable and it exists.
//

UINT MIB_Parameters[]                        = { 1 };
UINT MIB_WinsStartTime[]                     = { 1, 1, 0 };
UINT MIB_LastPScvTime[]                        = { 1, 2, 0 };
UINT MIB_LastATScvTime[]                = { 1, 3, 0 };
UINT MIB_LastTombScvTime[]                = { 1, 4, 0 };
UINT MIB_LastVerifyScvTime[]                = { 1, 5, 0 };
UINT MIB_LastPRplTime[]                        = { 1, 6, 0 };
UINT MIB_LastATRplTime[]                = { 1, 7, 0 };
UINT MIB_LastNTRplTime[]                = { 1, 8, 0 };
UINT MIB_LastACTRplTime[]                = { 1, 9, 0 };
UINT MIB_LastInitDbTime[]                = { 1, 10, 0 };
UINT MIB_LastCounterResetTime[]                = { 1, 11, 0 };
UINT MIB_WinsTotalNoOfReg[]             = { 1, 12, 0 };
UINT MIB_WinsTotalNoOfQueries[]         = { 1, 13, 0 };
UINT MIB_WinsTotalNoOfRel[]             = { 1, 14, 0 };
UINT MIB_WinsTotalNoOfSuccRel[]         = { 1, 15, 0 };
UINT MIB_WinsTotalNoOfFailRel[]         = { 1, 16, 0 };
UINT MIB_WinsTotalNoOfSuccQueries[]         = { 1, 17, 0 };
UINT MIB_WinsTotalNoOfFailQueries[]         = { 1, 18, 0 };
UINT MIB_RefreshInterval[]                 = { 1, 19, 0 };
UINT MIB_TombstoneInterval[]                 = { 1, 20, 0 };
UINT MIB_TombstoneTimeout[]                 = { 1, 21, 0 };
UINT MIB_VerifyInterval[]                 = { 1, 22, 0 };
UINT MIB_VersCounterStartVal_LowWord[]        = { 1, 23, 0 };
UINT MIB_VersCounterStartVal_HighWord[] = { 1, 24, 0 };
UINT MIB_RplOnlyWCnfPnrs[]                 = { 1, 25, 0 };
UINT MIB_StaticDataInit[]                 = { 1, 26, 0 };
UINT MIB_LogFlag[]                          = { 1, 27, 0 };
UINT MIB_LogFileName[]                        = { 1, 28, 0 };
UINT MIB_BackupDirPath[]                = { 1, 29, 0 };
UINT MIB_DoBackupOnTerm[]                = { 1, 30, 0 };
UINT MIB_MigrateOn[]                        = { 1, 31, 0 };

//
// Pull mib vars
//
UINT MIB_Pull[]                                = { 2 };
UINT MIB_PullInitTime[]                        = { 2, 1, 0 };
UINT MIB_CommRetryCount[]                = { 2, 2, 0 };
UINT MIB_PullPnrTable[]                        = { 2, 3};
UINT MIB_PullPnrTableEntry[]                = { 2, 3, 1};

//
// Push mib vars
//
UINT MIB_Push[]                                = { 3 };
UINT MIB_PushInitTime[]                        = { 3, 1, 0 };
UINT MIB_RplOnAddChg[]                         = { 3, 2, 0 };
UINT MIB_PushPnrTable[]                        = { 3, 3};
UINT MIB_PushPnrTableEntry[]                = { 3, 3, 1};


//
// Datafile mib vars
//
UINT MIB_Datafiles[]                        = { 4 };
UINT MIB_DatafilesTable[]                = { 4 , 1};
UINT MIB_DatafilesTableEntry[]                = { 4 , 1, 1};

//
// Cmd mib Vars
UINT MIB_Cmd[]                                = { 5 };
UINT MIB_PullTrigger[]                        = { 5, 1, 0};
UINT MIB_PushTrigger[]                        = { 5, 2, 0};
UINT MIB_DeleteWins[]                        = { 5, 3, 0};
UINT MIB_DoScavenging[]                        = { 5, 4, 0};
UINT MIB_DoStaticInit[]                        = { 5, 5, 0};
UINT MIB_NoOfWrkThds[]                        = { 5, 6, 0};
UINT MIB_PriorityClass[]                = { 5, 7, 0};
UINT MIB_ResetCounters[]                = { 5, 8, 0};
UINT MIB_DeleteDbRecs[]                        = { 5, 9, 0};
UINT MIB_GetDbRecs[]                        = { 5, 10, 0};
UINT MIB_DbRecsTable[]                        = { 5, 11};
UINT MIB_DbRecsTableEntry[]                = { 5, 11, 1};
UINT MIB_MaxVersNo_LowWord[]                 = { 5, 12, 0 };
UINT MIB_MaxVersNo_HighWord[]                 = { 5, 13, 0 };

//
//                             //
// Storage definitions for MIB //
//                             //

// Parameters group
char       MIB_WinsStartTimeStore[80];
char MIB_LastPScvTimeStore[80];
char MIB_LastATScvTimeStore[80];
char MIB_LastTombScvTimeStore[80];
char MIB_LastVerifyScvTimeStore[80];
char MIB_LastPRplTimeStore[80];
char MIB_LastATRplTimeStore[80];
char MIB_LastNTRplTimeStore[80];
char MIB_LastACTRplTimeStore[80];
char MIB_LastInitDbTimeStore[80];
char MIB_LastCounterResetTimeStore[80];

AsnCounter MIB_WinsTotalNoOfRegStore                             = 0;
AsnCounter MIB_WinsTotalNoOfQueriesStore                  = 0;
AsnCounter MIB_WinsTotalNoOfRelStore                      = 0;
AsnCounter MIB_WinsTotalNoOfSuccRelStore                  = 0;
AsnCounter MIB_WinsTotalNoOfFailRelStore                  = 0;
AsnCounter MIB_WinsTotalNoOfSuccQueriesStore            = 0;
AsnCounter MIB_WinsTotalNoOfFailQueriesStore            = 0;
AsnInteger MIB_RefreshIntervalStore                          = 0;
AsnInteger MIB_TombstoneIntervalStore                        = 0;
AsnInteger MIB_TombstoneTimeoutStore                         = 0;
AsnInteger MIB_VerifyIntervalStore                           = 0;
AsnCounter MIB_VersCounterStartVal_HighWordStore        = 0;
AsnCounter MIB_VersCounterStartVal_LowWordStore         = 0;
AsnInteger MIB_RplOnlyWCnfPnrsStore                          = 0;
AsnInteger MIB_StaticDataInitStore                          = 0;
AsnInteger MIB_LogFlagStore                                  = 1;

char MIB_LogFileNameStore[256];

char       MIB_BackupDirPathStore[256];
AsnInteger MIB_DoBackupOnTermStore                        = 0;
AsnInteger MIB_MigrateOnStore                                = 0;

//Pull
AsnInteger MIB_PullInitTimeStore        = 1 ;
AsnInteger MIB_CommRetryCountStore        = 0 ;

//PullPnr
char MIB_SpTimeStore[256];
AsnInteger MIB_TimeIntervalStore        = 0 ;
AsnInteger MIB_MemberPrecStore                = 0 ;

//Push
AsnInteger MIB_RplOnAddChgStore         = 0;

//PushPnr
AsnInteger MIB_PushInitTimeStore        = 0 ;
AsnInteger MIB_UpdateCountStore                = 0 ;

//
// Cmd
//
char                MIB_PullTriggerStore[10];   // double the size to store the old value in case of failure
char                MIB_PushTriggerStore[10];   // double the size to store the old value in case of failure
char                MIB_DeleteWinsStore[10];
AsnInteger        MIB_DoScavengingStore;
char                MIB_DoStaticInitStore[WINSMIB_FILE_INFO_SIZE] = {EOS};
AsnInteger        MIB_NoOfWrkThdsStore;
AsnInteger        MIB_PriorityClassStore;
AsnInteger        MIB_ResetCountersStore;
char                MIB_DeleteDbRecsStore[10];
char                MIB_GetDbRecsStore[5] = {0};
AsnInteger         MIB_MaxVersNo_LowWordStore;
AsnInteger         MIB_MaxVersNo_HighWordStore;

CRITICAL_SECTION WinsMibCrtSec;

//
// Value Id.
//
// NOTE NOTE NOTE:  The sequence must be the same as in VarInfo[]
//
typedef enum _VAL_ID_E {

//values for the Parameters Key
                REF_INTVL_E = 0,
                TOMB_INTVL_E,
                TOMB_TMOUT_E,
                VER_INTVL_E,
                VERS_COUNT_LW_E,
                VERS_COUNT_HW_E,
                RPL_ONLY_W_CNF_PNRS_E,
                STATIC_DATA_INIT_E,
                LOG_FLAG_E,
                LOG_FILE_NAME_E,
                BACKUP_DIR_PATH_E,
                DO_BACKUP_ON_TERM_E,
                MIGRATE_ON_E,

//values for the Pull Key
                COMM_RETRY_E,
                PULL_INIT_TIME_E,

//values for pnrs under the pull key
                SP_TIME_E,
                TIME_INTVL_E,
                MEMBER_PREC_E,

//values for the Push Key
                PUSH_INIT_TIME_E,

//values for pnrs under the push key
                RPL_ON_ADD_CHG_E,
                UPD_CNT_E


                } VAL_ID_E, *PVAL_ID_E;


//
// Holds information about partners (pull/push) used for accessing the
// Pull and Push partner tables
//
typedef struct _ADD_KEY_T {
        BYTE        asIpAddress[20];
        DWORD        IpAdd;
        BYTE        asSpTime[20];
        BOOL        fSpTimeSet;
        union {
                DWORD TimeInterval;
                DWORD UpdateCount;
             };
        BOOL  fTimeIntOrUpdCntSet;
        DWORD        MemberPrec;
        DWORD        NoOfRpls;
        DWORD        NoOfCommFails;
        WINSINTF_VERS_NO_T        VersNo;
                } ADD_KEY_T, *PADD_KEY_T;


typedef struct _DATAFILE_INFO_T {
        TCHAR        FileNm[WINSMIB_FILE_INFO_SIZE];
        DWORD   StrType;
        TCHAR   ValNm[10];
                } DATAFILE_INFO_T, *PDATAFILE_INFO_T;


#define DATAFILE_INFO_SZ        sizeof(DATAFILE_INFO_T)

//
// holds info about variable used when accessing registry.
//
typedef struct _VAR_INFO_T {
        LPDWORD                pId;                //Oid under WINS
        LPBYTE                pName;
        LPVOID                 pStorage;
        VAL_ID_E        Val_Id_e;
        DWORD                ValType;
        DWORD                SizeOfData;
        HKEY                *pRootKey;
        } VARINFO_T, *PVARINFO_T;

//
// This array comprises of stuff that needs to be read from/written to
// the registry.
//
VARINFO_T VarInfo[] = {
                        {
                          &MIB_RefreshInterval[1],
                          { WINSCNF_REFRESH_INTVL_NM },
                          &MIB_RefreshIntervalStore,
                          REF_INTVL_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_TombstoneInterval[1],
                          WINSCNF_TOMBSTONE_INTVL_NM,
                          &MIB_TombstoneIntervalStore,
                          TOMB_INTVL_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_TombstoneTimeout[1],
                          WINSCNF_TOMBSTONE_TMOUT_NM,
                          &MIB_TombstoneTimeoutStore,
                          TOMB_TMOUT_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_VerifyInterval[1],
                          WINSCNF_VERIFY_INTVL_NM,
                          &MIB_VerifyIntervalStore,
                          VER_INTVL_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_VersCounterStartVal_LowWord[1],
                          WINSCNF_INIT_VERSNO_VAL_LW_NM,
                          &MIB_VersCounterStartVal_LowWordStore,
                          VERS_COUNT_LW_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_VersCounterStartVal_HighWord[1],
                          WINSCNF_INIT_VERSNO_VAL_HW_NM,
                          &MIB_VersCounterStartVal_HighWordStore,
                          VERS_COUNT_HW_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_RplOnlyWCnfPnrs[1],
                          WINSCNF_RPL_ONLY_W_CNF_PNRS_NM,
                          &MIB_RplOnlyWCnfPnrsStore,
                          RPL_ONLY_W_CNF_PNRS_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_StaticDataInit[1],
                          WINSCNF_STATIC_INIT_FLAG_NM,
                          &MIB_StaticDataInitStore,
                          STATIC_DATA_INIT_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_LogFlag[1],
                          WINSCNF_LOG_FLAG_NM,
                          &MIB_LogFlagStore,
                          LOG_FLAG_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_LogFileName[1],
                          WINSCNF_LOG_FILE_PATH_NM,
                          &MIB_LogFileNameStore,
                          LOG_FILE_NAME_E,
                          REG_EXPAND_SZ,
                          sizeof(MIB_LogFileNameStore),
                          &sParametersKey
                        },
                        {
                          &MIB_BackupDirPath[1],
                          WINSCNF_BACKUP_DIR_PATH_NM,
                          &MIB_BackupDirPathStore,
                          BACKUP_DIR_PATH_E,
                          REG_EXPAND_SZ,
                          sizeof(MIB_BackupDirPathStore),
                          &sParametersKey
                        },
                        {
                          &MIB_DoBackupOnTerm[1],
                          WINSCNF_DO_BACKUP_ON_TERM_NM,
                          &MIB_DoBackupOnTermStore,
                          DO_BACKUP_ON_TERM_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },
                        {
                          &MIB_MigrateOn[1],
                          WINSCNF_MIGRATION_ON_NM,
                          &MIB_MigrateOnStore,
                          MIGRATE_ON_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sParametersKey
                        },

                        {
                          &MIB_CommRetryCount[1],
                          WINSCNF_RETRY_COUNT_NM,
                          &MIB_CommRetryCountStore,
                          COMM_RETRY_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sPullKey
                        },
                        {
                          &MIB_PullInitTime[1],
                          WINSCNF_INIT_TIME_RPL_NM,
                          &MIB_PullInitTimeStore,
                          PULL_INIT_TIME_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sPullKey
                        },
                        {
                          NULL, //&MIB_SpTime[1]
                          WINSCNF_SP_TIME_NM,
                          &MIB_SpTimeStore,
                          SP_TIME_E,
                          REG_SZ,
                          sizeof(MIB_SpTimeStore),
                          &sPullKey
                        },

                        {
                          NULL, //&MIB_TimeInterval[1]
                          WINSCNF_RPL_INTERVAL_NM,
                          &MIB_TimeIntervalStore,
                          TIME_INTVL_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sPullKey
                        },
                        {
                          NULL,
                          WINSCNF_MEMBER_PREC_NM,
                          &MIB_MemberPrecStore,
                          MEMBER_PREC_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sPullKey
                        },
                        {
                          &MIB_PushInitTime[1],
                          WINSCNF_INIT_TIME_RPL_NM,
                          &MIB_PushInitTimeStore,
                          PUSH_INIT_TIME_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sPushKey
                        },
                        {
                          &MIB_RplOnAddChg[1],
                          WINSCNF_ADDCHG_TRIGGER_NM,
                          &MIB_RplOnAddChgStore,
                          RPL_ON_ADD_CHG_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sPushKey
                        },
                        {
                          NULL, //&MIB_UpdateCount[1]
                          WINSCNF_UPDATE_COUNT_NM,
                          &MIB_UpdateCountStore,
                          UPD_CNT_E,
                          REG_DWORD,
                          sizeof(DWORD),
                          &sPushKey
                        }
        };

//
// Type of key
//
typedef enum _KEY_TYPE_E {
        PARAMETERS_E_KEY,
        PARTNERS_E_KEY,
        DATAFILES_E_KEY,
        PULL_E_KEY,
        PUSH_E_KEY,
        IPADD_E_KEY
        } KEY_TYPE_E, *PKEY_TYPE_E;

//
// Determines if the MIB variable falls in the range requiring access to the
// the registry
//
#define PARAMETERS_VAL_M(pMib)                (  \
                ((pMib)->Oid.ids[0] == 1)  \
                        &&                   \
                ((pMib)->Oid.ids[1] >= 19) \
                        &&                   \
                ((pMib)->Oid.ids[1] <= 31) \
                                )

//
// All MIB variables in the common group have 1 as their first id
//
#define COMMON_VAL_M(pMib)         ((pMib)->Oid.ids[0] == 1)

//
// All MIB variables in the common group have 2 as their first id
//
#define PULL_VAL_M(pMib)         ((pMib)->Oid.ids[0] == 2)

//
// All MIB variables in the common group have 3 as their first id
//
#define PUSH_VAL_M(pMib)         ((pMib)->Oid.ids[0] == 3)

//
//  Finds the enumerator corresponding to the registry parameter
//
#define PARAMETERS_ID_M(pMib, Val_Id_e) { \
if(pMib->Storage==&MIB_RefreshIntervalStore) { Val_Id_e = REF_INTVL_E; }else{\
if(pMib->Storage==&MIB_TombstoneIntervalStore){ Val_Id_e=TOMB_INTVL_E;}else{\
if(pMib->Storage==&MIB_TombstoneTimeoutStore) { Val_Id_e=TOMB_TMOUT_E; }else{\
if(pMib->Storage==&MIB_VerifyIntervalStore) { Val_Id_e = VER_INTVL_E; } else{\
if (pMib->Storage==&MIB_VersCounterStartVal_LowWordStore) { Val_Id_e = VERS_COUNT_LW_E; } else{ \
  if (pMib->Storage == &MIB_VersCounterStartVal_HighWordStore) { Val_Id_e = VERS_COUNT_HW_E; } else{ \
  if (pMib->Storage == &MIB_RplOnlyWCnfPnrsStore) { Val_Id_e = RPL_ONLY_W_CNF_PNRS_E; } else {\
  if (pMib->Storage == &MIB_StaticDataInitStore) { Val_Id_e = STATIC_DATA_INIT_E; } else {\
  if (pMib->Storage == &MIB_LogFlagStore)     { Val_Id_e = LOG_FLAG_E; } else {\
  if (pMib->Storage == &MIB_LogFileNameStore) { Val_Id_e = LOG_FILE_NAME_E; } else {\
  if (pMib->Storage == &MIB_BackupDirPathStore) { Val_Id_e = BACKUP_DIR_PATH_E; } else {\
  if (pMib->Storage == &MIB_DoBackupOnTermStore) { Val_Id_e = DO_BACKUP_ON_TERM_E; } else {\
  if (pMib->Storage == &MIB_MigrateOnStore) { Val_Id_e = MIGRATE_ON_E; } else {\
  }}}}}}}}}}}}}}

//
//  Finds the enumerator corresponding to the pull group's parameter
//
#define PULL_ID_M(pMib, Val_Id_e) { \
  if (pMib->Storage == &MIB_CommRetryCountStore) { Val_Id_e = COMM_RETRY_E; }else{\
  if (pMib->Storage == &MIB_PullInitTimeStore) { Val_Id_e = PULL_INIT_TIME_E;} else{\
 }}}

//
//  Finds the enumerator corresponding to the push group's parameter
//
#define PUSH_ID_M(pMib, Val_Id_e) { \
  if (pMib->Storage == &MIB_RplOnAddChgStore) { Val_Id_e = RPL_ON_ADD_CHG_E;} else{\
  if (pMib->Storage == &MIB_PushInitTimeStore) { Val_Id_e = PUSH_INIT_TIME_E;}else{ \
 }}}

STATIC
UINT
HandleCmd(
        IN UINT           Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind
        );
STATIC
UINT
ExecuteCmd(
  IN PMIB_ENTRY pMibPtr
        );

STATIC
UINT
MIB_RWReg(
        IN UINT           Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind
        );

STATIC
UINT
PullPnrs(
        IN UINT Action,
        IN PMIB_ENTRY pMibPtr,
        IN RFC1157VarBind *VarBind
        );

STATIC
UINT
PushPnrs(
        IN UINT Action,
        IN PMIB_ENTRY pMibPtr,
        IN RFC1157VarBind *VarBind
        );
STATIC
UINT
MIB_Table(
        IN DWORD           Index,
        IN UINT            Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind,
        IN KEY_TYPE_E           KeyType_e
        );

STATIC
UINT
MIB_PullTable(
        IN UINT           Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind
                );
STATIC
UINT
MIB_PushTable(
        IN UINT           Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind
                );
STATIC
UINT
MIB_DFTable(
        IN UINT           Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind
                );

STATIC
UINT
MIB_DRTable(
        IN UINT           Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind
);

STATIC
UINT
WriteDFValue(
        IN RFC1157VarBind         *pVarBind,
        PDATAFILE_INFO_T          pDFKey,
        DWORD                         Index
        );

STATIC
UINT
MIB_leaf_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN RFC1157VarBind *VarBind
        );


STATIC
UINT
MIB_Stat(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN RFC1157VarBind *VarBind
        );
//
// MIB definiton
//

MIB_ENTRY Mib[] = {
//parameters
      { { OID_SIZEOF(MIB_Parameters), MIB_Parameters },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_NOACCESS, NULL, &Mib[1] },

      { { OID_SIZEOF(MIB_WinsStartTime), MIB_WinsStartTime },
        &MIB_WinsStartTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[2] },

      { { OID_SIZEOF(MIB_LastPScvTime), MIB_LastPScvTime },
        &MIB_LastPScvTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[3] },

      { { OID_SIZEOF(MIB_LastATScvTime), MIB_LastATScvTime },
        &MIB_LastATScvTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[4] },

      { { OID_SIZEOF(MIB_LastTombScvTime), MIB_LastTombScvTime },
        &MIB_LastTombScvTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[5] },

      { { OID_SIZEOF(MIB_LastVerifyScvTime), MIB_LastVerifyScvTime },
        &MIB_LastVerifyScvTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[6] },

      { { OID_SIZEOF(MIB_LastPRplTime), MIB_LastPRplTime },
        &MIB_LastPRplTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[7] },

      { { OID_SIZEOF(MIB_LastATRplTime), MIB_LastATRplTime },
        &MIB_LastATRplTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[8] },

      { { OID_SIZEOF(MIB_LastNTRplTime), MIB_LastNTRplTime },
        &MIB_LastNTRplTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[9] },

      { { OID_SIZEOF(MIB_LastACTRplTime), MIB_LastACTRplTime },
        &MIB_LastACTRplTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[10] },

      { { OID_SIZEOF(MIB_LastInitDbTime), MIB_LastInitDbTime },
        &MIB_LastInitDbTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[11] },

      { { OID_SIZEOF(MIB_LastCounterResetTime), MIB_LastCounterResetTime },
        &MIB_LastCounterResetTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[12] },

      { { OID_SIZEOF(MIB_WinsTotalNoOfReg), MIB_WinsTotalNoOfReg },
        &MIB_WinsTotalNoOfRegStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[13] },

      { { OID_SIZEOF(MIB_WinsTotalNoOfQueries), MIB_WinsTotalNoOfQueries },
        &MIB_WinsTotalNoOfQueriesStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[14] },

      { { OID_SIZEOF(MIB_WinsTotalNoOfRel), MIB_WinsTotalNoOfRel },
        &MIB_WinsTotalNoOfRelStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[15] },

      { { OID_SIZEOF(MIB_WinsTotalNoOfSuccRel), MIB_WinsTotalNoOfSuccRel },
        &MIB_WinsTotalNoOfSuccRelStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[16] },

      { { OID_SIZEOF(MIB_WinsTotalNoOfFailRel), MIB_WinsTotalNoOfFailRel },
        &MIB_WinsTotalNoOfFailRelStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[17] },

      { { OID_SIZEOF(MIB_WinsTotalNoOfSuccQueries),
                                  MIB_WinsTotalNoOfSuccQueries },
        &MIB_WinsTotalNoOfSuccQueriesStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[18] },

      { { OID_SIZEOF(MIB_WinsTotalNoOfFailQueries),
                                   MIB_WinsTotalNoOfFailQueries },
        &MIB_WinsTotalNoOfFailQueriesStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[19] },

      { { OID_SIZEOF(MIB_RefreshInterval), MIB_RefreshInterval },
        &MIB_RefreshIntervalStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[20] },

      { { OID_SIZEOF(MIB_TombstoneInterval), MIB_TombstoneInterval },
        &MIB_TombstoneIntervalStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[21] },

      { { OID_SIZEOF(MIB_TombstoneTimeout), MIB_TombstoneTimeout },
        &MIB_TombstoneTimeoutStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[22] },

      { { OID_SIZEOF(MIB_VerifyInterval), MIB_VerifyInterval },
        &MIB_VerifyIntervalStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[23] },

      { { OID_SIZEOF(MIB_VersCounterStartVal_LowWord),
                        MIB_VersCounterStartVal_LowWord },
        &MIB_VersCounterStartVal_LowWordStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[24] },

      { { OID_SIZEOF(MIB_VersCounterStartVal_HighWord),
                        MIB_VersCounterStartVal_HighWord },
        &MIB_VersCounterStartVal_HighWordStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[25] },

      { { OID_SIZEOF(MIB_RplOnlyWCnfPnrs),  MIB_RplOnlyWCnfPnrs },
        &MIB_RplOnlyWCnfPnrsStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[26] },

      { { OID_SIZEOF(MIB_StaticDataInit),  MIB_StaticDataInit },
        &MIB_StaticDataInitStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[27] },


      { { OID_SIZEOF(MIB_LogFlag), MIB_LogFlag },
        &MIB_LogFlagStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[28] },

      { { OID_SIZEOF(MIB_LogFileName), MIB_LogFileName },
        &MIB_LogFileNameStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[29] },

      { { OID_SIZEOF(MIB_BackupDirPath), MIB_BackupDirPath },
        &MIB_BackupDirPathStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[30] },

      { { OID_SIZEOF(MIB_DoBackupOnTerm), MIB_DoBackupOnTerm },
        &MIB_DoBackupOnTermStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[31] },

      { { OID_SIZEOF(MIB_MigrateOn), MIB_MigrateOn },
        &MIB_MigrateOnStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[32] },

//
// Pull
//
      { { OID_SIZEOF(MIB_Pull), MIB_Pull },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_NOACCESS, NULL, &Mib[33] },

      { { OID_SIZEOF(MIB_PullInitTime), MIB_PullInitTime },
        &MIB_PullInitTimeStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[34] },

      { { OID_SIZEOF(MIB_CommRetryCount), MIB_CommRetryCount },
        &MIB_CommRetryCountStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[35] },

      { { OID_SIZEOF(MIB_PullPnrTable), MIB_PullPnrTable },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_ACCESS_READWRITE, NULL, &Mib[36] },

      { { OID_SIZEOF(MIB_PullPnrTableEntry), MIB_PullPnrTableEntry },
        NULL, ASN_SEQUENCE,
        MIB_ACCESS_READWRITE, MIB_PullTable, &Mib[37] },

//
// Push
//
      { { OID_SIZEOF(MIB_Push), MIB_Push },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_NOACCESS, NULL, &Mib[38] },


      { { OID_SIZEOF(MIB_PushInitTime), MIB_PushInitTime },
        &MIB_PushInitTimeStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[39] },

      { { OID_SIZEOF(MIB_RplOnAddChg),
                        MIB_RplOnAddChg },
        &MIB_RplOnAddChgStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, MIB_RWReg, &Mib[40] },

      { { OID_SIZEOF(MIB_PushPnrTable), MIB_PushPnrTable },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_ACCESS_READWRITE, NULL, &Mib[41] },

      { { OID_SIZEOF(MIB_PushPnrTableEntry), MIB_PushPnrTableEntry },
        NULL, ASN_SEQUENCE,
        MIB_ACCESS_READWRITE, MIB_PushTable, &Mib[42] },

//
// Datafiles
//
      { { OID_SIZEOF(MIB_Datafiles), MIB_Datafiles },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_NOACCESS, NULL, &Mib[43] },

      { { OID_SIZEOF(MIB_DatafilesTable), MIB_DatafilesTable },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_ACCESS_READWRITE, NULL, &Mib[44] },

      { { OID_SIZEOF(MIB_DatafilesTableEntry), MIB_DatafilesTableEntry },
        NULL, ASN_SEQUENCE,
        MIB_ACCESS_READWRITE, MIB_DFTable, &Mib[45] },

//
// Cmds
//
      { { OID_SIZEOF(MIB_Cmd), MIB_Cmd },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_NOACCESS, NULL, &Mib[46] },

      { { OID_SIZEOF(MIB_PullTrigger), MIB_PullTrigger },
        &MIB_PullTriggerStore, ASN_RFC1155_IPADDRESS,
        MIB_ACCESS_READWRITE, HandleCmd, &Mib[47] },

      { { OID_SIZEOF(MIB_PushTrigger), MIB_PushTrigger },
        &MIB_PushTriggerStore, ASN_RFC1155_IPADDRESS,
        MIB_ACCESS_READWRITE, HandleCmd, &Mib[48] },

      // NOTE: The following command was changed from READWRITE
      // to READ only due to security reason.
      // Anyone with access to SNMP agent, could delete
      // the wins database with this sigle command.
      { { OID_SIZEOF(MIB_DeleteWins), MIB_DeleteWins },
        &MIB_DeleteWinsStore, ASN_RFC1155_IPADDRESS,
        MIB_ACCESS_READ, HandleCmd, &Mib[49] },

      { { OID_SIZEOF(MIB_DoScavenging), MIB_DoScavenging },
        &MIB_DoScavengingStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, HandleCmd, &Mib[50] },

      { { OID_SIZEOF(MIB_DoStaticInit), MIB_DoStaticInit },
        &MIB_DoStaticInitStore, ASN_OCTETSTRING,
        MIB_ACCESS_READWRITE, HandleCmd, &Mib[51] },

      { { OID_SIZEOF(MIB_NoOfWrkThds), MIB_NoOfWrkThds },
        &MIB_NoOfWrkThdsStore, ASN_INTEGER,
        MIB_ACCESS_READ, HandleCmd, &Mib[52] },

      { { OID_SIZEOF(MIB_PriorityClass), MIB_PriorityClass},
        &MIB_PriorityClassStore, ASN_INTEGER,
        MIB_ACCESS_READ, HandleCmd, &Mib[53] },

      { { OID_SIZEOF(MIB_ResetCounters), MIB_ResetCounters},
        &MIB_ResetCountersStore, ASN_INTEGER,
        MIB_ACCESS_READWRITE, HandleCmd, &Mib[54] },

      { { OID_SIZEOF(MIB_DeleteDbRecs), MIB_DeleteDbRecs},
        &MIB_DeleteDbRecsStore, ASN_RFC1155_IPADDRESS,
        MIB_ACCESS_READWRITE, HandleCmd, &Mib[55] },

      { { OID_SIZEOF(MIB_GetDbRecs), MIB_GetDbRecs},
        &MIB_GetDbRecsStore, ASN_RFC1155_IPADDRESS,
        MIB_ACCESS_READWRITE, HandleCmd, &Mib[56] },

      { { OID_SIZEOF(MIB_DbRecsTable), MIB_DbRecsTable },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_ACCESS_READWRITE, NULL, &Mib[57] },

      { { OID_SIZEOF(MIB_DbRecsTableEntry), MIB_DbRecsTableEntry },
        NULL, ASN_SEQUENCE,
        MIB_ACCESS_READWRITE, MIB_DRTable, &Mib[58] },

      { { OID_SIZEOF(MIB_MaxVersNo_LowWord), MIB_MaxVersNo_LowWord },
        &MIB_MaxVersNo_LowWordStore, ASN_INTEGER,
        MIB_ACCESS_READ, HandleCmd, &Mib[59] },

      { { OID_SIZEOF(MIB_MaxVersNo_HighWord), MIB_MaxVersNo_HighWord },
        &MIB_MaxVersNo_HighWordStore, ASN_INTEGER,
        MIB_ACCESS_READ, HandleCmd, NULL }
      };


//
//  defines pertaining to tables
//
#define PNR_OIDLEN                 (MIB_PREFIX_LEN + OID_SIZEOF(MIB_PullPnrTableEntry))
#define PULLPNR_OIDLEN                PNR_OIDLEN
#define PUSHPNR_OIDLEN                PNR_OIDLEN
#define DR_OIDLEN                 (MIB_PREFIX_LEN + OID_SIZEOF(MIB_DbRecsTableEntry))
#define DF_OIDLEN                 (MIB_PREFIX_LEN + OID_SIZEOF(MIB_DatafilesTableEntry))

#define PULL_TABLE_INDEX        0
#define PUSH_TABLE_INDEX        1
#define DF_TABLE_INDEX                2
#define DR_TABLE_INDEX                3
#define NUM_TABLES                sizeof(Tables)/sizeof(TAB_INFO_T)

UINT MIB_num_variables = sizeof Mib / sizeof( MIB_ENTRY );

//
// table structure containing the functions to invoke for different actions
// on the table
//
typedef struct _TAB_INFO_T {
        UINT (*ti_get)(
                RFC1157VarBind *VarBind,
                DWORD                NoOfKeys,
                LPVOID                pKey
                     );
        UINT (*ti_getf)(
                RFC1157VarBind *VarBind,
                PMIB_ENTRY        pMibEntry,
                KEY_TYPE_E        KeyType_e
                     );
        UINT (*ti_getn)(
                RFC1157VarBind *VarBind,
                PMIB_ENTRY        pMibEntry,
                KEY_TYPE_E        KeyType_e
                    );
        UINT (*ti_set)(
                RFC1157VarBind *VarBind
                    );

        PMIB_ENTRY pMibPtr;
        } TAB_INFO_T, *PTAB_INFO_T;



STATIC
UINT
WriteReg(
        PMIB_ENTRY pMib
        );
STATIC
UINT
ReadReg(
        PMIB_ENTRY pMib
        );
STATIC
UINT
SetVal(
        PVARINFO_T        pVarInfo
);

STATIC
UINT
GetVal(
        PVARINFO_T        pVarInfo
);


STATIC
UINT
OpenKey(
        KEY_TYPE_E        Key_e,
        LPBYTE                pKeyStr,
        HKEY                *ptrNewKey,
        HKEY                *pRootKey,
        BOOL                fCreateAllowed
);

STATIC
UINT
OpenReqKey(
        PMIB_ENTRY  pMib,
        PVAL_ID_E  pVal_Id_e,
        BOOL           fCreateAllowed
);

STATIC
UINT
CloseReqKey(
        VOID
        );

STATIC
UINT
GetKeyInfo(
        IN  HKEY                   Key,
        OUT LPDWORD                  pNoOfSubKeys,
        OUT LPDWORD                pNoOfVals
        );


STATIC
UINT
PnrGetNext(
       IN RFC1157VarBind *VarBind,
       IN PMIB_ENTRY          pMibPtr,
       IN KEY_TYPE_E         KeyType_e
        );


STATIC
UINT
PullGet(
       IN RFC1157VarBind *VarBind,
       IN DWORD          NumKeys,
       IN LPVOID         pAddKey
);

STATIC
UINT
PushGet(
       IN RFC1157VarBind *VarBind,
       IN DWORD          NumKeys,
       IN LPVOID         pAddKey
);

STATIC
UINT
PnrGetFirst(
       IN RFC1157VarBind *VarBind,
       IN PMIB_ENTRY         pMibPtr,
       IN KEY_TYPE_E         KeyType_e
        );
STATIC
UINT
PullSet(
       IN RFC1157VarBind *VarBind
);

STATIC
UINT
PushSet(
       IN RFC1157VarBind *VarBind
);

STATIC
UINT
PnrMatch(
       IN RFC1157VarBind *VarBind,
       DWORD                 NoOfKeys,
       IN PADD_KEY_T         pAddKey,
       IN LPDWORD         pIndex,
       IN LPDWORD         pField,
       IN KEY_TYPE_E         KeyType_e,
       IN UINT                 PduAction,
       IN LPBOOL        pfFirst
        );

extern
UINT
PnrFindNext(
        INT           AddKeyNo,
        DWORD           NumAddKeys,
        PADD_KEY_T pAddKey
        );
STATIC
UINT
EnumAddKeys(
             KEY_TYPE_E        KeyType_e,
        PADD_KEY_T        *ppAddKey,
        LPDWORD                pNumAddKeys
          );
STATIC
UINT
EnumDataFileKeys(
        PDATAFILE_INFO_T        *ppDFValues,
        LPDWORD                        pNumDFValues
          );
STATIC
UINT
DFSet(
       IN RFC1157VarBind *VarBind
);

STATIC
UINT
DFGet(
       IN RFC1157VarBind                  *VarBind,
       IN DWORD                           NumValues,
       IN LPVOID                          pKey
    );

STATIC
UINT
DFGetFirst(
       IN RFC1157VarBind *VarBind,
       IN PMIB_ENTRY        pMibPtr,
       IN KEY_TYPE_E        KeyType_e
        );
STATIC
UINT
DFGetNext(
       IN RFC1157VarBind *VarBind,
       IN PMIB_ENTRY          pMibPtr,
       IN KEY_TYPE_E         KeyType_e
          );
STATIC
DWORD
PopulateDRCache(
        VOID
        );
STATIC
UINT
DRGetNext(
       IN RFC1157VarBind *VarBind,
       IN PMIB_ENTRY          pMibPtr,
       IN KEY_TYPE_E         KeyType_e
        );

STATIC
UINT
DRMatch(
       IN RFC1157VarBind *VarBind,
       IN PWINSINTF_RECORD_ACTION_T         *ppRow,
       IN LPDWORD         pIndex,
       IN LPDWORD         pField,
       IN UINT                 PduAction,
       OUT LPBOOL         pfFirst
        );

STATIC
int
__cdecl
CompareIndexes(
        const VOID *pKey1,
        const VOID *pKey2
        );

STATIC
int
__cdecl
CompareNames(
        const VOID *pKey1,
        const VOID *pKey2
        );
// NOTE:
//
// Info passed for 2nd and 3rd param is different from other table's GET
// functions
//
STATIC
UINT
DRGet(
       IN RFC1157VarBind *VarBind,
       IN DWORD          FieldParam,
       IN LPVOID         pRowParam
);

STATIC
UINT
DRGetFirst(
       IN RFC1157VarBind *VarBind,
       IN PMIB_ENTRY        pMibPtr,
       IN KEY_TYPE_E        KeyType_e
        );
STATIC
UINT
DRSet(
       IN RFC1157VarBind *VarBind
);

STATIC
UINT
WriteKeyNValues(
        KEY_TYPE_E        KeyType_e,
        PADD_KEY_T        pAddKey,
        DWORD                FieldNo
        );
STATIC
VOID
GetSpTimeData(
        HKEY                  SubKey,
        PADD_KEY_T          pAddKey
);

STATIC
int
__cdecl
CompareAdd(
        const VOID *pKey1,
        const VOID *pKey2
        );

STATIC
UINT
GetNextVar(
        IN RFC1157VarBind *pVarBind,
        IN PMIB_ENTRY          pMibPtr
);

TAB_INFO_T Tables[] = {
                {
                        PullGet,
                        PnrGetFirst,
                        PnrGetNext,
                        PullSet,
                        &Mib[36]
                },
                {
                        PushGet,
                        PnrGetFirst,
                        PnrGetNext,
                        PushSet,
                        &Mib[41]
                },
                {

                        DFGet,
                        DFGetFirst,
                        DFGetNext,
                        DFSet,
                        &Mib[44]
                },
                {

                        DRGet,
                        DRGetFirst,
                        DRGetNext,
                        DRSet,
                        &Mib[57]
                }
        };



UINT
ResolveVarBind(
        IN OUT RFC1157VarBind *VarBind, // Variable Binding to resolve
        IN UINT PduAction               // Action specified in PDU
        )
//
// ResolveVarBind
//    Resolves a single variable binding.  Modifies the variable on a GET
//    or a GET-NEXT.
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
{
   MIB_ENTRY            *MibPtr;
   AsnObjectIdentifier  TempOid;
   int                  CompResult;
   UINT                 I;
   UINT                 nResult;
   DWORD TableIndex;
   BOOL  fTableMatch = FALSE;

//    SNMPDBG ((SNMP_LOG_TRACE,
//              "WINSMIB: Entering ResolveVarBind.\n"));

   // initialize MibPtr to NULL. When this becomes not null, it means we found a match (table or scalar)
   MibPtr = NULL;

   //
   // Check the Tables array
   //
   // See if the prefix of the variable matches the prefix of
   // any of the tables
   //
   for (TableIndex = 0; TableIndex < NUM_TABLES; TableIndex++)
   {
        //
           // Construct OID with complete prefix for comparison purposes
        //
           SNMP_oidcpy( &TempOid, &MIB_OidPrefix );
           if (TempOid.ids == NULL)
           {
                nResult = SNMP_ERRORSTATUS_GENERR;
                goto Exit;
           }
           SNMP_oidappend( &TempOid,  &Tables[TableIndex].pMibPtr->Oid );

        //
        // is there a match with the prefix oid of a table entry
        //
        if (
                SnmpUtilOidNCmp(
                            &VarBind->name,
                             &TempOid,
                             MIB_PREFIX_LEN +
                                Tables[TableIndex].pMibPtr->Oid.idLength
                               )  == 0
           )
        {

                //
                // the prefix string of the var. matched the oid
                // of a table.
                //
                MibPtr = Tables[TableIndex].pMibPtr;
                fTableMatch = TRUE;
                break;
        }

           // Free OID memory before checking with another table entry
           SNMP_oidfree( &TempOid );
   }
   //
   // There was an exact match with a table entry's prefix.
   //
   if ( fTableMatch)
   {

        if (
                (SnmpUtilOidCmp(
                        &VarBind->name,
                        &TempOid
                               ) == 0)
           )
           {
           //
           // The oid specified is a prefix of a table entry. if the operation
           // is not GETNEXT, return NOSUCHNAME
           //
           if (PduAction != MIB_GETNEXT)
           {
                           SNMP_oidfree( &TempOid );
                             nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
                              goto Exit;
           }
           else
           {
                UINT           TableEntryIds[1];
                AsnObjectIdentifier TableEntryOid = {
                                OID_SIZEOF(TableEntryIds), TableEntryIds };
                //
                // Replace var bind name with new name
                //

                //
                // A sequence item oid always starts with a field no.
                // The first item has a field no of 1.
                //
                TableEntryIds[0] = 1;
                SNMP_oidappend( &VarBind->name, &TableEntryOid);

                //
                // Get the first entry in the table
                //
                PduAction = MIB_GETFIRST;
           }
        }
           SNMP_oidfree( &TempOid );
        //
        //  if there was no exact match with a prefix entry, then we
        //  don't touch the PduAction value specified.
        //
   }
   else
   {

      //
      // There was no match with any table entry.  Let us see if there is
      // a match with a group entry, a table, or a leaf variable
      //

      //
      // Search for var bind name in the MIB
      //
      I      = 0;
      while ( MibPtr == NULL && I < MIB_num_variables )
      {

         //
         // Construct OID with complete prefix for comparison purposes
         //
         SNMP_oidcpy( &TempOid, &MIB_OidPrefix );
         SNMP_oidappend( &TempOid, &Mib[I].Oid );

         //
         //Check for OID in MIB - On a GET-NEXT the OID does not have to exactly
         // match a variable in the MIB, it must only fall under the MIB root.
         //
         CompResult = SNMP_oidcmp( &VarBind->name, &TempOid );

        //
        // If CompResult is negative, the only valid operation is GET_NEXT
        //
        if (  CompResult  < 0)
        {

                //
                // This could be the oid of a leaf (without a 0)
                // or it could be  an invalid oid (in between two valid oids)
                // The next oid might be that of a group or a table or table
                // entry.  In that case, we do not change the PduAction
                //
                if (PduAction == MIB_GETNEXT)
                {
                       MibPtr = &Mib[I];
                             SNMP_oidfree( &VarBind->name );
                       SNMP_oidcpy( &VarBind->name, &MIB_OidPrefix );
                       SNMP_oidappend( &VarBind->name, &MibPtr->Oid );
                       if (MibPtr->Type != ASN_RFC1155_OPAQUE)
                       {
                           PduAction = (MibPtr->Type == ASN_SEQUENCE)? MIB_GETFIRST : MIB_GET;
                       }
                }
                else
                {
                  nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
                        SNMP_oidfree( &TempOid );
                  goto Exit;
                }

                      SNMP_oidfree( &TempOid );
                break;
      }
      else
      {
         //
         // An exact match was found ( a group, table, or leaf).
         //
         if ( CompResult == 0)
         {
            MibPtr = &Mib[I];
         }
      }

      //
      // Free OID memory before checking another variable
      //
      SNMP_oidfree( &TempOid );
      I++;
    } // while
   } // end of else

   //
   // if there was a match
   //
   if (MibPtr != NULL)
   {

//        SNMPDBG ((SNMP_LOG_TRACE,
//              "WINSMIB: Found MibPtr.\n"));
        //
        // the function will be NULL only if the match was with a group
        // or a sequence (table). If the match was with a table entry
        // (entire VarBind string match or partial string match), we
        // function would be a table function
        //
        if (MibPtr->MibFunc == NULL)
        {
                if(PduAction != MIB_GETNEXT)
                {
                              nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
                              goto Exit;
                }
                else
                {
                        //
                        // Get the next variable which allows access
                        //
                         nResult = GetNextVar(VarBind, MibPtr);
                        goto Exit;
                }
        }
   }
   else
   {
              nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
              goto Exit;
   }

//   SNMPDBG ((SNMP_LOG_TRACE,
//              "WINSMIB: Diving in OID handler.\n"));
   //
   // Call function to process request.  Each MIB entry has a function pointer
   // that knows how to process its MIB variable.
   //
   nResult = (*MibPtr->MibFunc)( PduAction, MibPtr, VarBind );

Exit:
   return nResult;
} // ResolveVarBind

//
// MIB_leaf_func
//    Performs generic actions on LEAF variables in the MIB.
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
UINT MIB_leaf_func(
        IN UINT            Action,
        IN MIB_ENTRY            *MibPtr,
        IN RFC1157VarBind  *VarBind
        )

{
   UINT   ErrStat;

   switch ( Action )
   {
      case MIB_GETNEXT:
         //
         // If there is no GET-NEXT pointer, this is the end of this MIB
         //
         if ( MibPtr->MibNext == NULL )
         {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
         }
         ErrStat = GetNextVar(VarBind, MibPtr);
         if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
         {
                goto Exit;
         }
         break;

      case MIB_GETFIRST: // fall through
      case MIB_GET:

         // Make sure that this variable's ACCESS is GET'able
         if ( MibPtr->Access != MIB_ACCESS_READ &&
              MibPtr->Access != MIB_ACCESS_READWRITE )
         {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
         }

         // Setup varbind's return value
         VarBind->value.asnType = MibPtr->Type;
         switch ( VarBind->value.asnType )
         {
            case ASN_RFC1155_COUNTER:
               VarBind->value.asnValue.number = *(AsnCounter *)(MibPtr->Storage);
               break;
            case ASN_RFC1155_GAUGE:
            case ASN_INTEGER:
               VarBind->value.asnValue.number = *(AsnInteger *)(MibPtr->Storage);
               break;

            case ASN_RFC1155_IPADDRESS:
                // continue as for ASN_OCTETSTRING

            case ASN_OCTETSTRING:
               if (VarBind->value.asnType == ASN_RFC1155_IPADDRESS)
               {
                               VarBind->value.asnValue.string.length = 4;
               }
               else
               {
                               VarBind->value.asnValue.string.length =
                                 strlen( (LPSTR)MibPtr->Storage );
               }

               if ( NULL ==
                    (VarBind->value.asnValue.string.stream =
                    SNMP_malloc(VarBind->value.asnValue.string.length *
                           sizeof(char))) )
               {
                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                  goto Exit;
               }

               memcpy( VarBind->value.asnValue.string.stream,
                       (LPSTR)MibPtr->Storage,
                       VarBind->value.asnValue.string.length );
               VarBind->value.asnValue.string.dynamic = TRUE;

               break;



            default:
               ErrStat = SNMP_ERRORSTATUS_GENERR;
               goto Exit;
         }

         break;

      case MIB_SET:

         // Make sure that this variable's ACCESS is SET'able
         if ( MibPtr->Access != MIB_ACCESS_READWRITE &&
              MibPtr->Access != MIB_ACCESS_WRITE )
         {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
         }

         // Check for proper type before setting
         if ( MibPtr->Type != VarBind->value.asnType )
         {
            ErrStat = SNMP_ERRORSTATUS_BADVALUE;
            goto Exit;
         }

         // Save value in MIB
         switch ( VarBind->value.asnType )
         {
            case ASN_RFC1155_COUNTER:
               *(AsnCounter *)(MibPtr->Storage) = VarBind->value.asnValue.number;
               break;
            case ASN_RFC1155_GAUGE:
            case ASN_INTEGER:
               *(AsnInteger *)(MibPtr->Storage) = VarBind->value.asnValue.number;
               break;

            case ASN_RFC1155_IPADDRESS:
               if (MibPtr->Storage == &MIB_PullTriggerStore ||
                   MibPtr->Storage == &MIB_PushTriggerStore ||
                   MibPtr->Storage == &MIB_DeleteDbRecsStore ||
                   MibPtr->Storage == &MIB_DeleteWinsStore)
               {
                   int backupSize = (MibPtr->Storage == &MIB_PullTriggerStore) ?
                                    sizeof(MIB_PullTriggerStore)/2 :
                                    sizeof(MIB_PushTriggerStore)/2 ;
                   // those variables are ASN_RFC1155_IPADDRESS
                   // their old values have to be stored as the WinsTrigger() might fail
                   // in which case the old values will be restored
                   // each of these variables has 10 octets, the payload being of 5 octets.
                   // the last 5 = for backup
                   memcpy( (LPSTR)MibPtr->Storage + backupSize, (LPSTR)MibPtr->Storage, backupSize);
               }

            case ASN_OCTETSTRING:
               // The storage must be adequate to contain the new string
               // including a NULL terminator.
               memcpy( (LPSTR)MibPtr->Storage,
                       VarBind->value.asnValue.string.stream,
                       VarBind->value.asnValue.string.length );

               ((LPSTR)MibPtr->Storage)[VarBind->value.asnValue.string.length] =
                                                                          '\0';
#if 0
               if ( VarBind->value.asnValue.string.dynamic)
               {
                  SNMP_free( VarBind->value.asnValue.string.stream);
               }
#endif
               break;

            default:
               ErrStat = SNMP_ERRORSTATUS_GENERR;
               goto Exit;
            }

         break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
         goto Exit;
      } // switch

   // Signal no error occurred
   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_leaf_func


#define TMST(x)        sResults.WinsStat.TimeStamps.x.wHour,\
                sResults.WinsStat.TimeStamps.x.wMinute,\
                sResults.WinsStat.TimeStamps.x.wSecond,\
                sResults.WinsStat.TimeStamps.x.wMonth,\
                sResults.WinsStat.TimeStamps.x.wDay,\
                sResults.WinsStat.TimeStamps.x.wYear

#define PRINTTIME(Var, x)      sprintf(Var, "%02u:%02u:%02u on %02u:%02u:%04u.\n", TMST(x))

static  WINSINTF_RESULTS_T        sResults;

//
// MIB_Stat
//    Performs specific actions on the different MIB variable
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
UINT MIB_Stat(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
        )

{
//WINSINTF_RESULTS_T        Results;
DWORD                        Status;
UINT                           ErrStat;
handle_t                BindHdl;


   switch ( Action )
   {
      case MIB_SET:
                   ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );
                break;
      case MIB_GETNEXT:
                   ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );
                break;

      case MIB_GETFIRST:
#if 0
                //
                // If it is an OPAQUE type (i.e. aggregate)
                //
                if (MibPtr->Type == ASN_RFC1155_OPAQUE)
                {
                      ErrStat = MIB_leaf_func( MIB_GETNEXT, MibPtr, VarBind );
                   break;
                }
#endif

                //
                // fall through
                //
      case MIB_GET:

        if (!fWinsMibWinsStatusStatCalled)
        {
          //
          // Call the WinsStatus function to get the statistics
          //
          BindHdl = WinsBind(&sBindData);
          sResults.WinsStat.NoOfPnrs = 0;
          sResults.WinsStat.pRplPnrs = NULL;
          if ((Status = WinsStatus(BindHdl, WINSINTF_E_STAT, &sResults)) !=
                                        WINSINTF_SUCCESS)
          {
             SNMPDBG((
                SNMP_LOG_ERROR,
                "WINSMIB: Error from WinsStatus = (%d).\n",
                Status
                ));
             WinsFreeMem(sResults.WinsStat.pRplPnrs);
             ErrStat = SNMP_ERRORSTATUS_GENERR;
             goto Exit;
          }
          else
          {
            fWinsMibWinsStatusStatCalled = TRUE;
          }
          WinsFreeMem(sResults.WinsStat.pRplPnrs);
          WinsUnbind(&sBindData, BindHdl);
        }

        if (MibPtr->Storage  == &MIB_WinsStartTimeStore)
        {
                PRINTTIME(MIB_WinsStartTimeStore, WinsStartTime);
                goto LEAF1;
        }

        if (MibPtr->Storage  == &MIB_LastPScvTimeStore)
        {
                PRINTTIME(MIB_LastPScvTimeStore, LastPScvTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastATScvTimeStore)
        {
                PRINTTIME(MIB_LastATScvTimeStore, LastATScvTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastTombScvTimeStore)
        {
                PRINTTIME(MIB_LastTombScvTimeStore, LastTombScvTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastVerifyScvTimeStore)
        {
                PRINTTIME(MIB_LastVerifyScvTimeStore, LastVerifyScvTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastPRplTimeStore)
        {
                PRINTTIME(MIB_LastPRplTimeStore, LastPRplTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastATRplTimeStore)
        {
                PRINTTIME(MIB_LastATRplTimeStore, LastATRplTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastNTRplTimeStore)
        {
                PRINTTIME(MIB_LastNTRplTimeStore, LastNTRplTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastACTRplTimeStore)
        {
                PRINTTIME(MIB_LastACTRplTimeStore, LastACTRplTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastInitDbTimeStore)
        {
                PRINTTIME(MIB_LastInitDbTimeStore, LastInitDbTime);
                goto LEAF1;
        }
        if (MibPtr->Storage  == &MIB_LastCounterResetTimeStore)
        {
                PRINTTIME(MIB_LastCounterResetTimeStore, CounterResetTime);
                goto LEAF1;
        }

        if (MibPtr->Storage == &MIB_WinsTotalNoOfRegStore)
        {
                MIB_WinsTotalNoOfRegStore =
                        sResults.WinsStat.Counters.NoOfUniqueReg +
                                sResults.WinsStat.Counters.NoOfGroupReg;
                goto LEAF1;
        }

        if (MibPtr->Storage == &MIB_WinsTotalNoOfQueriesStore)
        {
                MIB_WinsTotalNoOfQueriesStore =
                        sResults.WinsStat.Counters.NoOfQueries;
                goto LEAF1;
        }

        if (MibPtr->Storage == &MIB_WinsTotalNoOfRelStore)
        {
                MIB_WinsTotalNoOfRelStore = sResults.WinsStat.Counters.NoOfRel;
                goto LEAF1;
        }

        if (MibPtr->Storage == &MIB_WinsTotalNoOfSuccRelStore)
        {
                MIB_WinsTotalNoOfSuccRelStore =
                        sResults.WinsStat.Counters.NoOfSuccRel;
                goto LEAF1;
        }
        if (MibPtr->Storage == &MIB_WinsTotalNoOfFailRelStore)
        {
                MIB_WinsTotalNoOfFailRelStore =
                        sResults.WinsStat.Counters.NoOfFailRel;
                goto LEAF1;
        }
        if (MibPtr->Storage == &MIB_WinsTotalNoOfSuccQueriesStore)
        {
                MIB_WinsTotalNoOfSuccQueriesStore =
                        sResults.WinsStat.Counters.NoOfSuccQueries;
                goto LEAF1;
         }
         if (MibPtr->Storage == &MIB_WinsTotalNoOfFailQueriesStore)
         {
                MIB_WinsTotalNoOfFailQueriesStore =
                        sResults.WinsStat.Counters.NoOfFailQueries;
        //        goto LEAF1;
         }

LEAF1:
         // Call the more generic function to perform the action
         ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );

         break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
         goto Exit;
      } // switch

Exit:
   return ErrStat;
} // MIB_Stat



//
// MIB_RWReg
//    Performs specific actions on the different MIB variable
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
UINT MIB_RWReg(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN RFC1157VarBind *VarBind
        )

{
WINSINTF_RESULTS_T         Results;
DWORD                        Status;
UINT                           ErrStat = SNMP_ERRORSTATUS_NOERROR;
handle_t                BindHdl;

//   SNMPDBG ((SNMP_LOG_TRACE,
//              "WINSMIB: Entering MIB_RWReg.\n"));
        

   switch ( Action )
      {
      case MIB_SET:
                   if (MIB_leaf_func( Action, MibPtr, VarBind )
                        == SNMP_ERRORSTATUS_NOERROR)
                {
                        ErrStat = WriteReg(MibPtr);
                }
                break;

      case MIB_GETFIRST:
#if 0
                //
                // If it is an OPAQUE type (i.e. aggregate)
                //
                if (MibPtr->Type == ASN_RFC1155_OPAQUE)
                {
                      ErrStat = MIB_leaf_func( MIB_GETNEXT, MibPtr, VarBind );
                   break;
                }

#endif
                //
                // fall through
                //
      case MIB_GET:
        //
        // Call the WinsStatus function to get the statistics
        //
        if (
                (MibPtr->Storage  == &MIB_RefreshIntervalStore)
                        ||
                (MibPtr->Storage  == &MIB_TombstoneIntervalStore)
                        ||
                (MibPtr->Storage  == &MIB_TombstoneTimeoutStore)
                        ||
                (MibPtr->Storage  == &MIB_VerifyIntervalStore)

            )
        {

                   BindHdl = WinsBind(&sBindData);
                Results.WinsStat.NoOfPnrs = 0;
                Results.WinsStat.pRplPnrs = NULL;
                if ((Status = WinsStatus(BindHdl, WINSINTF_E_CONFIG, &Results))
                        == WINSINTF_SUCCESS)
                {
                        MIB_RefreshIntervalStore   = Results.RefreshInterval;
                        MIB_TombstoneIntervalStore = Results.TombstoneInterval;
                        MIB_TombstoneTimeoutStore  = Results.TombstoneTimeout;
                        MIB_VerifyIntervalStore    = Results.VerifyInterval;

                }
                 else
                 {
                           SNMPDBG((
                                SNMP_LOG_ERROR,
                                "WINSMIB: Error from WinsStatus = (%d).\n",
                                Status
                                ));
                           ErrStat = SNMP_ERRORSTATUS_GENERR;
                 }
                 WinsUnbind(&sBindData, BindHdl);
        }
        else
        {
                //
                // If a value could not be read
                // then the storage for the mib variable would have been
                // initialized to 0.
                //
                ErrStat = ReadReg(MibPtr);
        }
      //
      // fall through
      //
      case MIB_GETNEXT:

        //
        // Call the more generic function to perform the action
        //
        ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );
        break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
         goto Exit;
      } // switch

Exit:
   return ErrStat;
} // MIB_RWReg


UINT
OpenReqKey(
        MIB_ENTRY *pMib,
        VAL_ID_E  *pVal_Id_e,
        BOOL           fCreateAllowed
        )


/*++

Routine Description:
        The function opens the required keys for the parameter indicated
        by the structure pointed to by pMib

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        UINT Status = SNMP_ERRORSTATUS_GENERR;

//        SNMPDBG ((SNMP_LOG_TRACE,
//              "WINSMIB: Entering OpenReqKey.\n"));

        //
        // if it is a parameter value, open the parameters key
        //
        if (PARAMETERS_VAL_M(pMib))
        {

                Status = OpenKey(PARAMETERS_E_KEY, NULL, NULL, NULL, fCreateAllowed);
                if (Status == SNMP_ERRORSTATUS_NOERROR)
                {
                //        sfParametersKeyOpen = TRUE;
                        PARAMETERS_ID_M(pMib, *pVal_Id_e);
                }

        }
        else
        {
                //
                //  if it is a Pull key value, open the partner and
                //  pull keys
                //
                if (PULL_VAL_M(pMib))
                {
                        Status = OpenKey(PARTNERS_E_KEY, NULL, NULL, NULL, fCreateAllowed);
                        if (Status == SNMP_ERRORSTATUS_NOERROR)
                        {
                                //sfPartnersKeyOpen = TRUE;
                                Status = OpenKey(PULL_E_KEY, NULL, NULL, NULL, fCreateAllowed);
                                if (Status == SNMP_ERRORSTATUS_NOERROR)
                                {
                                        PULL_ID_M(pMib, *pVal_Id_e);
                                }
                        }
                }
                else
                {
                   //
                   //  if it is a Push key value, open the partner and
                   //  pull keys
                   //
                   if (PUSH_VAL_M(pMib))
                   {
                        Status = OpenKey(PARTNERS_E_KEY, NULL, NULL, NULL, fCreateAllowed);
                        if (Status == SNMP_ERRORSTATUS_NOERROR)
                        {
                                sfPartnersKeyOpen = TRUE;
                                Status = OpenKey(PUSH_E_KEY, NULL, NULL, NULL, fCreateAllowed);
                                if (Status == SNMP_ERRORSTATUS_NOERROR)
                                {
                                        PUSH_ID_M(pMib, *pVal_Id_e);
                                }
                        }
                   }
                }
        }

        return(Status);
}
UINT
CloseReqKey(
        VOID
        )
/*++

Routine Description:

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        UINT Status = SNMP_ERRORSTATUS_NOERROR;
        if (sfParametersKeyOpen)
        {
                if (sfDatafilesKeyOpen)
                {
                        SNMPDBG((
                            SNMP_LOG_VERBOSE,
                            "WINSMIB: Closing sDatafilesKey 0x%08lx (fKeyOpen=TRUE).\n",
                            sDatafilesKey
                            ));
                        RegCloseKey(sDatafilesKey);
                        sfDatafilesKeyOpen = FALSE;
                }
                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "WINSMIB: Closing sParametersKey 0x%08lx (fKeyOpen=TRUE).\n",
                    sParametersKey
                    ));
                RegCloseKey(sParametersKey);
                sfParametersKeyOpen = FALSE;
        }
        else
        {
                if (sfPartnersKeyOpen)
                {
                        if (sfPullKeyOpen)
                        {
                                SNMPDBG((
                                    SNMP_LOG_VERBOSE,
                                    "WINSMIB: Closing sPullKey 0x%08lx (fKeyOpen=TRUE).\n",
                                    sPullKey
                                    ));
                                RegCloseKey(sPullKey);
                                sfPullKeyOpen = FALSE;
                        }
                        else
                        {
                                if (sfPushKeyOpen)
                                {
                                        SNMPDBG((
                                            SNMP_LOG_VERBOSE,
                                            "WINSMIB: Closing sPushKey 0x%08lx (fKeyOpen=TRUE).\n",
                                            sPushKey
                                            ));
                                        RegCloseKey(sPushKey);
                                        sfPushKeyOpen = FALSE;
                                }
                        }
                        SNMPDBG((
                            SNMP_LOG_VERBOSE,
                            "WINSMIB: Closing sPartnersKey 0x%08lx (fKeyOpen=TRUE).\n",
                            sPartnersKey
                            ));
                        RegCloseKey(sPartnersKey);
                        sfPartnersKeyOpen = FALSE;
                }
        }
        return(Status);
}

UINT
ReadReg(
        MIB_ENTRY *pMib
        )
{
        UINT Status = SNMP_ERRORSTATUS_NOERROR;
        VAL_ID_E  Val_Id_e;

//        SNMPDBG ((SNMP_LOG_TRACE,
//              "WINSMIB: Entering ReadReg.\n"));
        
        Status = OpenReqKey(pMib, &Val_Id_e, FALSE);
        if (Status == SNMP_ERRORSTATUS_NOERROR)
        {
          Status = GetVal(&VarInfo[Val_Id_e]);
        }
        CloseReqKey();

        return(Status);
}

UINT
WriteReg(
        MIB_ENTRY *pMib
        )
{
        UINT Status = SNMP_ERRORSTATUS_NOERROR;
        VAL_ID_E Val_Id_e;

        Status = OpenReqKey(pMib, &Val_Id_e, TRUE);
        if (SNMP_ERRORSTATUS_NOERROR == Status) {
            Status = SetVal(&VarInfo[Val_Id_e]);
            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "WINSMIB: Closing sParametersKey 0x%08lx (fKeyOpen=%s).\n",
                sParametersKey, sfParametersKeyOpen ? "TRUE" : "FALSE"
                ));

        }
        CloseReqKey();
        //RegCloseKey(sParametersKey);
        return(Status);
}


UINT
OpenKey(
        KEY_TYPE_E        Key_e,
        LPBYTE                ptrKeyStr,
           HKEY            *ptrNewKey,
        HKEY                *pRootKey,
        BOOL                fCreateAllowed
)
{
   LONG    RetVal;
   DWORD   NewKeyInd;
   HKEY    RootKey;
   LPBYTE  pKeyStr;
   HKEY    *pNewKey;
   LPBOOL  pfNewKeyOpen;


   if (!fWinsMibWinsKeyOpen)
   {
      SNMPDBG((
         SNMP_LOG_VERBOSE,
         "WINSMIB: Creating/opening Wins key.\n",
         WinsMibWinsKey
         ));

     RetVal = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,        //predefined key value
                _WINS_CNF_KEY,                //subkey for WINS
                0,                        //must be zero (reserved)
                TEXT("Class"),                //class -- may change in future
                REG_OPTION_NON_VOLATILE, //non-volatile information
                KEY_ALL_ACCESS,                //we desire all access to the keyo
                NULL,                         //let key have default sec. attributes
                &WinsMibWinsKey,                //handle to key
                &NewKeyInd                //is it a new key (out arg)
                );



      if (RetVal != ERROR_SUCCESS)
      {
         SNMPDBG((
            SNMP_LOG_ERROR,
            "WINSMIB: Error creating/opening Wins key 0x%08lx.\n",
            GetLastError()
            ));
         return(SNMP_ERRORSTATUS_GENERR);
      }

      fWinsMibWinsKeyOpen = TRUE;
   }

    SNMPDBG((
       SNMP_LOG_VERBOSE,
       "WINSMIB: WinsMibWinsKey=0x%08lx, opening %s.\n",
       WinsMibWinsKey,
       (Key_e == PARAMETERS_E_KEY)
            ? "PARAMETERS_E_KEY"
            : (Key_e == PARTNERS_E_KEY)
                ? "PARTNERS_E_KEY"
                : (Key_e == PULL_E_KEY)
                    ? "PULL_E_KEY"
                    : (Key_e == PUSH_E_KEY)
                        ? "PUSH_E_KEY"
                        : (Key_e == DATAFILES_E_KEY)
                            ? "DATAFILES_E_KEY"
                            : "IPADD_E_KEY"
                            ));

    switch(Key_e)
    {
        case(PARAMETERS_E_KEY):
                RootKey = WinsMibWinsKey;
                pKeyStr = _WINS_PARAMETERS_KEY;
                pNewKey = &sParametersKey;
                pfNewKeyOpen = &sfParametersKeyOpen;
                break;

        case(PARTNERS_E_KEY):
                RootKey = WinsMibWinsKey;
                pKeyStr = _WINS_PARTNERS_KEY;
                pNewKey = &sPartnersKey;
                pfNewKeyOpen = &sfPartnersKeyOpen;
                break;
        case(PULL_E_KEY):
                RootKey = sPartnersKey;
                pKeyStr = _WINS_PULL_KEY;
                pNewKey = &sPullKey;
                pfNewKeyOpen = &sfPullKeyOpen;
                break;
        case(PUSH_E_KEY):
                RootKey = sPartnersKey;
                pKeyStr = _WINS_PUSH_KEY;
                pNewKey = &sPushKey;
                pfNewKeyOpen = &sfPushKeyOpen;
                break;
        case(DATAFILES_E_KEY):
                RootKey = sParametersKey;
                pKeyStr = _WINS_DATAFILES_KEY;
                pNewKey = &sDatafilesKey;
                pfNewKeyOpen = &sfDatafilesKeyOpen;
                break;
        case(IPADD_E_KEY):
                RootKey = *pRootKey;
                pKeyStr = ptrKeyStr;
                pNewKey = ptrNewKey;
                break;
        default:
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "WINSMIB: Error in key type.\n"
                    ));
                 return(SNMP_ERRORSTATUS_GENERR);
     }

    if (fCreateAllowed)
    {
      RetVal = RegCreateKeyEx(
                  RootKey,        //predefined key value
                  pKeyStr,        //subkey for WINS
                  0,                //must be zero (reserved)
                  TEXT("Class"),        //class -- may change in future
                  REG_OPTION_NON_VOLATILE, //non-volatile information
                  KEY_ALL_ACCESS,        //we desire all access to the keyo
                  NULL,                 //let key have default sec. attributes
                  pNewKey,                //handle to key
                  &NewKeyInd                //is it a new key (out arg)
                  );
    }
    else
    {

      RetVal = RegOpenKeyEx(
                  RootKey,        //predefined key value
                  pKeyStr,        //subkey for WINS
                  0,                //must be zero (reserved)
                  KEY_READ,        //we desire read access to the keyo
                  pNewKey        //handle to key
                  );
    }


     if (RetVal != ERROR_SUCCESS)
     {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "WINSMIB: Error creating/opening Wins/Parameters key 0x%08lx.\n",
            GetLastError()
            ));
         return(SNMP_ERRORSTATUS_GENERR);
     }

    SNMPDBG((
       SNMP_LOG_VERBOSE,
       "WINSMIB: Opened %s=0x%08lx (fKeyOpen=TRUE).\n",
       (Key_e == PARAMETERS_E_KEY)
            ? "sParametersKey"
            : (Key_e == PARTNERS_E_KEY)
                ? "sPartnersKey"
                : (Key_e == PULL_E_KEY)
                    ? "sPullKey"
                    : (Key_e == PUSH_E_KEY)
                        ? "sPushKey"
                        : (Key_e == DATAFILES_E_KEY)
                            ? "sDatafilesKey"
                            : "ipAddKey", *pNewKey
                            ));

     if (Key_e != IPADD_E_KEY)
     {
       if (ptrNewKey != NULL)
       {
         *ptrNewKey = *pNewKey;
       }
       *pfNewKeyOpen = TRUE;
     }

     return(SNMP_ERRORSTATUS_NOERROR);
}


UINT
SetVal(
        PVARINFO_T        pVarInfo

)
{
        UINT Status = SNMP_ERRORSTATUS_NOERROR;
        LONG  RetVal;

        RetVal = RegSetValueEx(
                                *(pVarInfo->pRootKey),
                                pVarInfo->pName,
                                0,         //reserved -- must be 0
                                pVarInfo->ValType,
                                pVarInfo->pStorage,
                                pVarInfo->ValType == REG_DWORD ?
                                        pVarInfo->SizeOfData :
                                        strlen(pVarInfo->pStorage)
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                        SNMPDBG((
                            SNMP_LOG_ERROR,
                            "WINSMIB: Could not set value of %s.\n",
                            pVarInfo->pName
                            ));
                        Status = SNMP_ERRORSTATUS_GENERR;
        }

        return(Status);
}

UINT
GetVal(
        PVARINFO_T        pVarInfo
)
{
        LONG        RetVal;
        UINT        ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD   ValType;
        DWORD   Sz;

//        SNMPDBG ((SNMP_LOG_TRACE,
//             "WINSMIB: GetVal(%s).\n",
//              pVarInfo->pName));

        Sz = pVarInfo->SizeOfData;
        RetVal = RegQueryValueEx(
                *(pVarInfo->pRootKey),
                pVarInfo->pName,
                NULL,
                &ValType,
                pVarInfo->pStorage,
                &Sz
                );

//        SNMPDBG ((SNMP_LOG_TRACE,
//               "WINSMIB: GetVal()->%d\n",
//               RetVal));

        if (RetVal != ERROR_SUCCESS)
        {
                (VOID)RtlFillMemory(pVarInfo->pStorage, pVarInfo->SizeOfData, 0);
                ErrStat = SNMP_ERRORSTATUS_GENERR;
        }
        return(ErrStat);

}
#if 0
//
// PullPnrs
//    Performs specific actions on the PullPnrs table
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
UINT
PullPnrs(
       IN UINT                  Action,
       IN MIB_ENTRY          *MibPtr,
       IN RFC1157VarBind *VarBind,
       IN PTABLE_ENTRY         *TablePtr
        )
{
   WINSINTF_RESULTS_T         Results;
   DWORD                Status = WINSINTF_SUCCESS;
   UINT                   ErrStat = SNMP_ERRORSTATUS_NOERROR;
   handle_t                BindHdl;



   BindHdl = WinsBind(&sBindData);
   switch ( Action )
      {
      case MIB_SET:
                break;
      case MIB_GETNEXT:

      case MIB_GET:
                ErrStat = TableMatch(MibPtr, VarBind, TablePtr);
                if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
                {
                        return(ErrStat);
                }
        //
        // Call the WinsStatus function to get the statistics
        //
        if (
                (MibPtr->Storage  == &MIB_RefreshIntervalStore)
                        ||
                (MibPtr->Storage  == &MIB_TombstoneIntervalStore)
                        ||
                (MibPtr->Storage  == &MIB_TombstoneTimeoutStore)
                        ||
                (MibPtr->Storage  == &MIB_VerifyIntervalStore)

            )
        {

                Status = WinsStatus(WINSINTF_E_CONFIG, &Results);

                if (Status == WINSINTF_SUCCESS)
                {
                        MIB_RefreshIntervalStore   = Results.RefreshInterval;
                        MIB_TombstoneIntervalStore = Results.TombstoneInterval;
                        MIB_TombstoneTimeoutStore  = Results.TombstoneTimeout;
                        MIB_VerifyIntervalStore    = Results.VerifyInterval;

                }
                 else
                 {
                           SNMPDBG((
                                SNMP_LOG_ERROR,
                                "WINSMIB: Error from WinsStatus = (%d).\n",
                                Status
                                ));
                           ErrStat = SNMP_ERRORSTATUS_GENERR;
                 }
        }
        else
        {
                if ((ErrStat = ReadReg(MibPtr)) != SNMP_ERRORSTATUS_NOERROR)
                {
                        break;
                }
        }

        // Call the more generic function to perform the action
        ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );
         break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
         goto Exit;
      } // switch

Exit:
   WinsUnbind(&sBindData, BindHdl);
   return ErrStat;
} //PullPnrs
#endif

UINT
PnrGetNext(
       IN RFC1157VarBind *VarBind,
       IN MIB_ENTRY          *MibPtr,
       IN KEY_TYPE_E         KeyType_e
          )
{
     DWORD          OidIndex;
     DWORD          NumAddKeys;
     INT            Index;
     PADD_KEY_T  pAddKey = NULL;
     DWORD         FieldNo;
     UINT         ErrStat = SNMP_ERRORSTATUS_NOERROR;
     BOOL         fFirst;

     //
     // Read in all ip address keys. For each key, the values of its fields
     // is stored in the ADD_KEY_T structure.  The number of Address
     // keys are stored in NumAddKeys and in the TABLE_INFO structure
     //
     ErrStat = EnumAddKeys(KeyType_e, &pAddKey, &NumAddKeys);
     if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
     {
                return ErrStat;
     }

     //
     // Check if the name passed matches any in the table (i.e. table of
     // of ADD_KEY_T structures.  If there is a match, the address
     // of the ip address key and the matching field's no. are returned
     //
     ErrStat = PnrMatch(VarBind,  NumAddKeys, pAddKey, &Index,
                                &FieldNo, KeyType_e, MIB_GETNEXT, &fFirst);
     if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
     {
                goto Exit;
               // return(ErrStat);
     }

     //
     // We were passed an oid that is less than all oids in the table. Set
     // the Index to -1 so that we retrieve the first record in the table
     //
     if (fFirst)
     {
        Index = -1;
     }
     //
     // Since the operation is GETNEXT, get the next IP address (i.e. one
     // that is lexicographically bigger.  If there is none, we must increment
     // the field value and move back to the lexically first item in the table
     // If the new field value is more than the largest supported, we call
     // the MibFunc of the next MIB entry.
     //
     if ((Index = PnrFindNext(Index, NumAddKeys, pAddKey)) < 0)
     {

          //
          // if we were trying to retrieve the second or subsequent record
          // we must increment the field number nd get the first record in
          // the table.  If we were retrieving the first record, then
          // we should get the next var.
          //
          if (!fFirst)
          {
            Index = PnrFindNext(-1, NumAddKeys, pAddKey);
          }
          else
          {
                HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pAddKey);
                return(GetNextVar(VarBind, MibPtr));
          }

          //
          // If either there is no entry in the table or if we have
          // exhausted all fields of the entry, call the function
          // of the next mib entry.
          //
          if (
                (++FieldNo > (DWORD)((KeyType_e == PULL_E_KEY)
                                ? NO_FLDS_IN_PULLADD_KEY
                                : NO_FLDS_IN_PUSHADD_KEY)) || (Index < 0)
             )
          {
                HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pAddKey);
                return(GetNextVar(VarBind, MibPtr));
          }
     }

     //
     // The fixed part of the objid is corect. Update the rest.
     //

     //
     // If there is not enough space, deallocate what is currently
     // there and allocate.
     //
     if (VarBind->name.idLength <= (PNR_OIDLEN + 4))
     {
         UINT TableEntryIds[5];  //field and Ip address have a length of 5
         AsnObjectIdentifier  TableEntryOid = {OID_SIZEOF(TableEntryIds),
                                             TableEntryIds };
         SNMP_oidfree( &VarBind->name);
         SNMP_oidcpy(&VarBind->name, &MIB_OidPrefix);
         SNMP_oidappend(&VarBind->name, &MibPtr->Oid);
         TableEntryIds[0] = (UINT)FieldNo;
         OidIndex = 1;
         TableEntryIds[OidIndex++] = (UINT)((pAddKey + Index)->IpAdd >> 24);
         TableEntryIds[OidIndex++] = (UINT)((pAddKey + Index)->IpAdd >> 16 & 0xFF);
         TableEntryIds[OidIndex++] = (UINT)((pAddKey + Index)->IpAdd >> 8 & 0xFF);
         TableEntryIds[OidIndex++]   = (UINT)((pAddKey + Index)->IpAdd & 0xFF);
         TableEntryOid.idLength            = OidIndex;
         SNMP_oidappend(&VarBind->name, &TableEntryOid);
     }
     else
     {
          OidIndex = PNR_OIDLEN;
          VarBind->name.ids[OidIndex++] = (UINT)FieldNo;
          VarBind->name.ids[OidIndex++] = (UINT)((pAddKey + Index)->IpAdd >> 24);
          VarBind->name.ids[OidIndex++] = (UINT)((pAddKey + Index)->IpAdd >> 16 & 0xFF);
          VarBind->name.ids[OidIndex++] = (UINT)((pAddKey + Index)->IpAdd >> 8 & 0xFF);
          VarBind->name.ids[OidIndex++] = (UINT)((pAddKey + Index)->IpAdd & 0xFF);
          VarBind->name.idLength = OidIndex;

     }

     //
     // Get the value
     //
     if (KeyType_e == PULL_E_KEY)
     {
        ErrStat = PullGet(VarBind, NumAddKeys, pAddKey);
     }
     else
     {
        ErrStat = PushGet(VarBind, NumAddKeys, pAddKey);
     }

     //
     // Let us free the memory that was allocated earlier.  No need to
     // check whether pAddKey is NULL.  It just can not be otherwise we
     // would have returned from this function earlier.
     //
Exit:
     HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pAddKey);
     return(ErrStat);
}

UINT
PullGet(
       IN RFC1157VarBind *VarBind,
       IN DWORD          NumKeys,
       IN LPVOID         pKey
    )
{
        UINT                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD           Field;
        DWORD                Index;
        DWORD           NumAddKeys = NumKeys;
        IN PADD_KEY_T         pAddKey = pKey;

        if (pAddKey == NULL)
        {
           //
           // Call EnumAddresses only if we have not been invoked by PnrGetNext
           //
           EnumAddKeys(PULL_E_KEY, &pAddKey, &NumAddKeys);
        }

        ErrStat = PnrMatch(VarBind, NumAddKeys, pAddKey, &Index, &Field,
                                        PULL_E_KEY, MIB_GET, NULL);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
                goto Exit;
                //return(ErrStat);
        }

        switch(Field)
        {
                case 1:                //IP address itself

                      VarBind->value.asnType        = ASN_RFC1155_IPADDRESS;
                      VarBind->value.asnValue.string.length = sizeof(ULONG);

                      if ( NULL ==  (VarBind->value.asnValue.string.stream =
                                   SNMP_malloc(VarBind->value.asnValue.string.length
                                   )) )
                      {
                                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                                  goto Exit;
                      }

                      VarBind->value.asnValue.string.stream[0] =
                                        (BYTE)((pAddKey + Index)->IpAdd >> 24);
                      VarBind->value.asnValue.string.stream[1] =
                                (BYTE)(((pAddKey + Index)->IpAdd >> 16) & 0xFF);
                      VarBind->value.asnValue.string.stream[2] =
                                (BYTE)(((pAddKey + Index)->IpAdd >> 8) & 0xFF);
                      VarBind->value.asnValue.string.stream[3] =
                                (BYTE)((pAddKey + Index)->IpAdd & 0xFF );
                      VarBind->value.asnValue.address.dynamic = TRUE;
#if 0
                      memcpy( VarBind->value.asnValue.string.stream,
                                       (LPSTR)(&((pAddKey + Index)->IpAdd)),
                                       VarBind->value.asnValue.string.length );
                        *((ULONG *)VarBind->value.asnValue.address.stream)
                                = (ULONG)(pAddKey + Index)->IpAdd;
#endif
#if 0
                               VarBind->value.asnValue.string.length =
                                 strlen( (LPSTR)((pAddKey + Index)->asIpAddress));

                               if ( NULL ==
                                    (VarBind->value.asnValue.string.stream =
                                    SNMP_malloc(VarBind->value.asnValue.string.length *
                                   sizeof(char))) )
                          {
                                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                                  goto Exit;
                          }

                               memcpy( VarBind->value.asnValue.string.stream,
                                       (LPSTR)((pAddKey + Index)->asIpAddress),
                                       VarBind->value.asnValue.string.length );
#endif
                        break;
                case 2:                // SpTime
                      VarBind->value.asnType        = ASN_RFC1213_DISPSTRING;
                      if (((pAddKey + Index)->asSpTime[0]) != EOS)
                      {
                           VarBind->value.asnValue.string.length =
                             strlen( (LPSTR)((pAddKey + Index)->asSpTime));

                           if ( NULL ==
                                    (VarBind->value.asnValue.string.stream =
                                    SNMP_malloc(VarBind->value.asnValue.string.length *
                                   sizeof(char))) )
                           {
                                    ErrStat = SNMP_ERRORSTATUS_GENERR;
                                    goto Exit;
                           }
                           memcpy( VarBind->value.asnValue.string.stream,
                                       (LPSTR)((pAddKey + Index)->asSpTime),
                                       VarBind->value.asnValue.string.length );
                    }
                    else
                    {
                                 VarBind->value.asnValue.string.length = 0;
                                 VarBind->value.asnValue.string.stream = NULL;
                    }
                    VarBind->value.asnValue.address.dynamic = TRUE;
                    break;

                case 3:                // TimeInterval
                        VarBind->value.asnType        = ASN_INTEGER;
                               VarBind->value.asnValue.number =
                                        (AsnInteger)((pAddKey + Index)->
                                                                TimeInterval);
                               break;

                case 4:   //Member Precedence
                        VarBind->value.asnType        = ASN_INTEGER;
                               VarBind->value.asnValue.number =
                                        (AsnInteger)((pAddKey + Index)->
                                                                MemberPrec);

                               break;

                case 5:   //No of successful replications
                        VarBind->value.asnType        = ASN_RFC1155_COUNTER;
                               VarBind->value.asnValue.number =
                                        (AsnCounter)((pAddKey + Index)->
                                                                NoOfRpls);

                               break;

                case 6:   //No of replication failures due to comm failures
                        VarBind->value.asnType        = ASN_RFC1155_COUNTER;
                               VarBind->value.asnValue.number =
                                        (AsnCounter)((pAddKey + Index)->
                                                                NoOfCommFails);

                        break;
                case 7:   //Low part of the highest vers. no of owned records
                        VarBind->value.asnType        = ASN_RFC1155_COUNTER;
                               VarBind->value.asnValue.number =
                                        (AsnCounter)((pAddKey + Index)->
                                                        VersNo.LowPart);

                        break;
                case 8:   //High part of the highest vers. no of owned records
                        VarBind->value.asnType        = ASN_RFC1155_COUNTER;
                               VarBind->value.asnValue.number =
                                        (AsnCounter)((pAddKey + Index)->
                                                        VersNo.HighPart);

                        break;

                default:
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        break;

        }
Exit:
        //
        // if we allocated memory here, free it
        //
        if ((pKey == NULL) && (pAddKey != NULL))
        {
                HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pAddKey);
        }
        return(ErrStat);
}


UINT
PnrMatch(
       IN RFC1157VarBind *VarBind,
       DWORD                 NoOfKeys,
       IN PADD_KEY_T         pAddKey,
       IN LPDWORD         pIndex,
       IN LPDWORD         pField,
       IN KEY_TYPE_E         KeyType_e,
       IN UINT                 PduAction,
       IN LPBOOL        pfFirst
        )
{
        DWORD OidIndex;
        DWORD Index;
        DWORD AddIndex;
        DWORD  Add = 0;
        UINT ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD AddLen;

        ASSERT(PduAction != MIB_SET);

        if (pfFirst != NULL)
        {
                *pfFirst = FALSE;
        }
        //
        // If there are no keys, return error
        //
        if (NoOfKeys == 0)
        {
                return(SNMP_ERRORSTATUS_NOSUCHNAME);
        }

        //
        // fixed part of the PullPnr table entries
        //
        OidIndex = PNR_OIDLEN;

        //
        // if the field specified is more than the max. in the table entry
        // barf
        //
        if (
                (NoOfKeys == 0)
                        ||
                ((*pField = VarBind->name.ids[OidIndex++]) >
                        (DWORD)
                   ((KeyType_e == PULL_E_KEY) ? NO_FLDS_IN_PULLADD_KEY
                                        : NO_FLDS_IN_PUSHADD_KEY))
           )
        {
                if (PduAction == MIB_GETNEXT)
                {
                        if (NoOfKeys == 0)
                        {
                                *pfFirst = TRUE;
                        }
                        else
                        {
                                *pIndex = NoOfKeys - 1;
                        }
                }
                else
                {
                        ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
                }
                goto Exit;
        }

        //
        // get the length of key specified
        //
        AddLen = VarBind->name.idLength - (PNR_OIDLEN + 1);

        AddIndex = OidIndex;
        for (Index = 0; Index < AddLen; Index++)
        {
           Add = Add | (((BYTE)(VarBind->name.ids[AddIndex++])) << (24 - (Index * 8)));
        }

        //
        // Check if the address specified matches with one of the keys
        //
        for (Index = 0; Index < NoOfKeys; Index++, pAddKey++)
        {
                if (Add == pAddKey->IpAdd)
                {
                        *pIndex = Index;
                        return(SNMP_ERRORSTATUS_NOERROR);
                }
                else
                {
                        //
                        // if passed in value is greater, continue on to
                        // the next item.  The list is in ascending order
                        //
                        if (Add > pAddKey->IpAdd)
                        {
                                continue;
                        }
                        else
                        {
                                //
                                // the list element is > passed in value,
                                // break out of the loop
                                //
                                break;
                        }
                }
        }

        //
        // if no match, but field is GetNext, return the (highest index - 1)
        // reached above.  This is because, PnrFindNext will be called by
        // the caller
        //
        if (PduAction == MIB_GETNEXT)
        {
                if (Index == 0)
                {
                        *pfFirst = TRUE;
                }
                else
                {
                        *pIndex = Index - 1;
                }
                ErrStat =  SNMP_ERRORSTATUS_NOERROR;
                goto Exit;
        }
        else
        {
                ErrStat =  SNMP_ERRORSTATUS_NOSUCHNAME;
        }
Exit:
        return(ErrStat);
}

UINT
PnrFindNext(
        INT           AddKeyNo,
        DWORD           NumAddKeys,
        PADD_KEY_T pAddKey
        )
{
        DWORD i;
        LONG  nextif;

        //
        // if AddKeyNo is 0  or more, search for the key next to
        // the key passed.
        //
        for (nextif =  -1, i = 0 ; i < NumAddKeys; i++)
        {
                if (AddKeyNo >= 0)
                {
                        if ( (pAddKey + i)->IpAdd <=
                                                (pAddKey + AddKeyNo)->IpAdd)
                        {
                          //
                          // This item is lexicographically less or equal,
                          // continue
                          //
                          continue;
                        }
                        else
                        {
                                nextif = i;
                                break;
                        }
                }
                else
                {
                        //
                        // We want the first key
                        //
                        nextif = 0;
                        break;
                }

#if 0
                //
                // if we want the first entry, then continue until
                // we get an entry that is lexicographically same or
                // greater
                //
                if (
                        (nextif < 0)
                           ||
                        (pAddKey + (i - 1))->IpAdd < (pAddKey + nextif)->IpAdd
                   )
                {
                        nextif = i;
                }
#endif

        }
        return(nextif);
}

UINT
PnrGetFirst(
       IN RFC1157VarBind *VarBind,
       IN MIB_ENTRY        *MibPtr,
       IN KEY_TYPE_E        KeyType_e
        )
{

        PADD_KEY_T pAddKey = NULL;
        DWORD      NumAddKeys;
        INT        Iface;
        UINT       TableEntryIds[5];
        AsnObjectIdentifier        TableEntryOid = { OID_SIZEOF(TableEntryIds),
                                                        TableEntryIds };
        UINT   ErrStat;

        //
        // Get all the address key information
        //
        EnumAddKeys(KeyType_e, &pAddKey, &NumAddKeys);

        //
        // If there is no entry in the table, go to the next MIB variable
        //
        if (NumAddKeys == 0)
        {
                 return(GetNextVar(VarBind, MibPtr));
        }
        //
        // Get the first entry in the table
        //
        Iface = PnrFindNext(-1, NumAddKeys, pAddKey);


        //
        // Write the object Id into the binding list and call get
        // func
        //
        SNMP_oidfree( &VarBind->name );
        SNMP_oidcpy( &VarBind->name, &MIB_OidPrefix );
        SNMP_oidappend( &VarBind->name, &MibPtr->Oid );

        //
        // The fixed part of the objid is correct. Update the rest.
        //

        TableEntryIds[0] = 1;
        TableEntryIds[1] = (UINT)((pAddKey + Iface)->IpAdd >> 24);
        TableEntryIds[2] = (UINT)(((pAddKey + Iface)->IpAdd >> 16)
                                                                & 0xFF);
        TableEntryIds[3] = (UINT)(((pAddKey + Iface)->IpAdd >> 8)
                                                                & 0xFF);
        TableEntryIds[4] = (UINT)((pAddKey + Iface)->IpAdd & 0xFF);
        SNMP_oidappend( &VarBind->name, &TableEntryOid );

        ErrStat =         (KeyType_e == PULL_E_KEY)
                ? PullGet(VarBind, NumAddKeys, pAddKey)
                : PushGet(VarBind, NumAddKeys, pAddKey);

        HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pAddKey);
        return(ErrStat);
}

UINT
PullSet(
       IN RFC1157VarBind *VarBind
)
{
        UINT                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD           Field;
        ADD_KEY_T        AddKey;
#if 0
        LPBYTE                pTmpB;
#endif
        struct in_addr  InAddr;

        //
        // Extract the field that needs to be set
        //
        Field = VarBind->name.ids[PULLPNR_OIDLEN];

        AddKey.IpAdd  = (VarBind->name.ids[PNR_OIDLEN  + 1] << 24);
        AddKey.IpAdd |= (VarBind->name.ids[PNR_OIDLEN + 2] << 16);
        AddKey.IpAdd |= (VarBind->name.ids[PNR_OIDLEN + 3] << 8);
        AddKey.IpAdd |= VarBind->name.ids[PNR_OIDLEN + 4];
        InAddr.s_addr = htonl(AddKey.IpAdd);

        //
        // The storage must be adequate to contain the new
        // string including a NULL terminator.
        //
        strcpy( (LPSTR)AddKey.asIpAddress, inet_ntoa(InAddr) );
        switch(Field)
        {
                case 1:

                        if (VarBind->value.asnType != ASN_RFC1155_IPADDRESS)
                        {
                                return(SNMP_ERRORSTATUS_BADVALUE);
                        }
#if 0
                        pTmpB =
                            VarBind->value.asnValue.string.stream;

                        NMSMSGF_RETRIEVE_IPADD_M(pTmpB, AddKey.IpAdd);
                        InAddr.s_addr = htonl(AddKey.IpAdd);


                        //
                               // The storage must be adequate to contain the new
                        // string including a NULL terminator.
                        //
                        strcpy(
                                        (LPSTR)AddKey.asIpAddress,
                                inet_ntoa(InAddr)
                                );
#endif
#if 0
                               memcpy( (LPSTR)AddKey.asIpAddress,
                            VarBind->value.asnValue.string.stream,
                            VarBind->value.asnValue.string.length );

                               ((LPSTR)AddKey.asIpAddress)
                                [VarBind->value.asnValue.string.length] = '\0';
#endif
                               break;

                case 2:                // SpTime
                        if (VarBind->value.asnType != ASN_RFC1213_DISPSTRING)
                        {
                                return(SNMP_ERRORSTATUS_BADVALUE);
                        }
                               // The storage must be adequate to contain the new
                        // string including a NULL terminator.
                               memcpy( (LPSTR)AddKey.asSpTime,
                            VarBind->value.asnValue.string.stream,
                            VarBind->value.asnValue.string.length );

                               ((LPSTR)AddKey.asSpTime)
                                [VarBind->value.asnValue.string.length] = '\0';

                               break;

                case 3:                // TimeInterval
                        if (VarBind->value.asnType != ASN_INTEGER)
                        {
                                return(SNMP_ERRORSTATUS_BADVALUE);
                        }
                               (AsnInteger)(AddKey.TimeInterval) =
                                        VarBind->value.asnValue.number;
                               break;
                case 4:                // MemberPrec
                        if (VarBind->value.asnType != ASN_INTEGER)
                        {
                                return(SNMP_ERRORSTATUS_BADVALUE);
                        }
                               (AsnInteger)(AddKey.MemberPrec) =
                                        VarBind->value.asnValue.number;
                               break;
                case 5:        //fall through
                case 6: //fall through
                case 7: //fall through
                case 8: //fall through
                        ErrStat = SNMP_ERRORSTATUS_READONLY;
                        break;
                default:
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        break;

        }

        if (ErrStat == SNMP_ERRORSTATUS_NOERROR)
        {
                ErrStat = WriteKeyNValues(PULL_E_KEY, &AddKey, Field);
        }
        return(ErrStat);
} //PullSet


UINT
WriteKeyNValues(
        KEY_TYPE_E        KeyType_e,
        PADD_KEY_T        pAddKey,
        DWORD                FieldNo
        )
{

        HKEY        AddKeyHdl;
        HKEY        RootKeyHdl;
        UINT        ErrStat = SNMP_ERRORSTATUS_NOERROR;

        //
        // Open the Parameters key and the key under that
        //
        ErrStat = OpenKey(PARTNERS_E_KEY, NULL, NULL, NULL, TRUE);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
           return(ErrStat);
        }
        ErrStat = OpenKey(KeyType_e, NULL, &RootKeyHdl, NULL, TRUE);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
           return(ErrStat);
        }
        ErrStat = OpenKey(IPADD_E_KEY, pAddKey->asIpAddress, &AddKeyHdl, &RootKeyHdl, TRUE);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
            return(ErrStat);
        }

        switch(FieldNo)
        {
                case(1):
                        //
                        // for this field, we don't need to do anything.
                        // The field (actually the key) has already been
                        // created.
                        //
                        break;

                case(2):
                        if (KeyType_e == PUSH_E_KEY)
                        {
                                MIB_UpdateCountStore =
                                        pAddKey->UpdateCount;
                                VarInfo[UPD_CNT_E].pRootKey = &AddKeyHdl;
                                SetVal(&VarInfo[UPD_CNT_E]);

                        }
                        else
                        {
                           strcpy(MIB_SpTimeStore, pAddKey->asSpTime);
                           VarInfo[SP_TIME_E].SizeOfData = strlen(pAddKey->asSpTime);
                           VarInfo[SP_TIME_E].pRootKey = &AddKeyHdl;
                           SetVal(&VarInfo[SP_TIME_E]);
                        }
                        break;
                case(3):
                        MIB_TimeIntervalStore =   pAddKey->TimeInterval;
                        VarInfo[TIME_INTVL_E].pRootKey = &AddKeyHdl;
                        SetVal(&VarInfo[TIME_INTVL_E]);
                        break;
                case(4):
                        MIB_MemberPrecStore =   pAddKey->MemberPrec;
                        VarInfo[MEMBER_PREC_E].pRootKey = &AddKeyHdl;
                        SetVal(&VarInfo[MEMBER_PREC_E]);
                        break;
                default:
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        break;
        }

        //
        // Let us close the keys that we opened/created
        //
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "WINSMIB: Closing AddKeyHdl 0x%08lx.\n",
            AddKeyHdl
            ));
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "WINSMIB: Closing RootKeyHdl 0x%08lx.\n",
            RootKeyHdl
            ));
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "WINSMIB: Closing sParametersKey 0x%08lx (fKeyOpen=%s).\n",
            sParametersKey, sfParametersKeyOpen ? "TRUE" : "FALSE"
            ));
        RegCloseKey(AddKeyHdl);
        CloseReqKey();
/*
        RegCloseKey(RootKeyHdl);
        RegCloseKey(sParametersKey);
*/

        return(SNMP_ERRORSTATUS_NOERROR);
}

UINT
MIB_PullTable(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
)
{
        //
        // if the length indicates a 0 or partial key, then only the get next
        // operation is allowed.  The field and the full key
        // have a length of 5
        //
        if (VarBind->name.idLength <= (PULLPNR_OIDLEN + 4))
        {
                if ((Action == MIB_GET) || (Action == MIB_SET))
                {
                        return(SNMP_ERRORSTATUS_NOSUCHNAME);
                }
        }
        return(
          MIB_Table(PULL_TABLE_INDEX, Action, MibPtr, VarBind, PULL_E_KEY)
             );
}

UINT
MIB_PushTable(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
)
{
        //
        // if the length indicates a 0 or partial key, then only the get next
        // operation is allowed. The field and the full key
        // have a length of 5.
        //
        if (VarBind->name.idLength <= (PUSHPNR_OIDLEN + 4))
        {
                if ((Action == MIB_GET) || (Action == MIB_SET))
                {
                        return(SNMP_ERRORSTATUS_NOSUCHNAME);
                }
        }
        return(
           MIB_Table(PUSH_TABLE_INDEX, Action, MibPtr, VarBind, PUSH_E_KEY)
              );
}
UINT
MIB_DFTable(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
)
{
        //
        // if the length indicates a 0 or partial key, then only the get next
        // operation is allowed.  Actually, the length can never
        // be < DF_OIDLEN + 1
        //
        if (VarBind->name.idLength <= (DF_OIDLEN + 1))
        {
                if ((Action == MIB_GET) || (Action == MIB_SET))
                {
                        return(SNMP_ERRORSTATUS_NOSUCHNAME);
                }
                Action = MIB_GETFIRST;
        }
        return(
           MIB_Table(DF_TABLE_INDEX, Action, MibPtr, VarBind, PUSH_E_KEY)
              );
}

UINT
MIB_DRTable(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
)
{
        time_t        CurrentTime;
        DWORD   RetStat = WINSINTF_SUCCESS;

        if (Action == MIB_SET)
        {
                return(SNMP_ERRORSTATUS_READONLY);

        }
        //
        // if the length indicates a 0 or partial key, then only the get next
        // operation is allowed.  Actually, the length can never
        // be < DR_OIDLEN + 1
        //
        if (VarBind->name.idLength <= (DR_OIDLEN + 1))
        {
                if ((Action == MIB_GET) || (Action == MIB_SET))
                {
                        return(SNMP_ERRORSTATUS_NOSUCHNAME);
                }
        }
        (void)time(&CurrentTime);
        if ((CurrentTime - sDRCacheInitTime) > WINSMIB_DR_CACHE_TIME)
        {
                if ((RetStat = PopulateDRCache()) == WINSINTF_SUCCESS)
                {
                        sDRCacheInitTime = CurrentTime;
                }

                if ((RetStat != WINSINTF_SUCCESS) || (sRecs.NoOfRecs == 0))
                {
                        if (Action == MIB_GETNEXT)
                        {
                                    return(GetNextVar(VarBind, MibPtr));
                        }
                        else
                        {
                                return(SNMP_ERRORSTATUS_NOSUCHNAME);
                        }
                }
        }
        return(
          MIB_Table(DR_TABLE_INDEX, Action, MibPtr, VarBind, PUSH_E_KEY)
             );
}
UINT
MIB_Table(
        IN DWORD          Index,
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind,
        IN KEY_TYPE_E          KeyType_e
       )
{
        UINT        ErrStat;
        switch(Action)
        {
                case(MIB_GET):
                        ErrStat = (*Tables[Index].ti_get)(VarBind, 0, NULL);
                        break;

                case(MIB_GETFIRST):
                        ErrStat = (*Tables[Index].ti_getf)(VarBind, MibPtr, KeyType_e);
                        break;

                case(MIB_GETNEXT):
                        ErrStat = (*Tables[Index].ti_getn)(VarBind, MibPtr, KeyType_e);
                        break;
                case(MIB_SET):
                        ErrStat = (*Tables[Index].ti_set)(VarBind);
                        break;
                default:
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                        break;

        }

        return(ErrStat);

}  //MIB_Table



UINT
PushSet(
       IN RFC1157VarBind *VarBind
)
{
        UINT                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD           Field;
        ADD_KEY_T        AddKey;
        LPBYTE                pTmpB;
        struct in_addr  InAddr;

        Field = VarBind->name.ids[PUSHPNR_OIDLEN];
        AddKey.IpAdd  = VarBind->name.ids[PNR_OIDLEN + 1] << 24;
        AddKey.IpAdd |= (VarBind->name.ids[PNR_OIDLEN + 2] << 16);
        AddKey.IpAdd |= (VarBind->name.ids[PNR_OIDLEN + 3] << 8);
        AddKey.IpAdd |= VarBind->name.ids[PNR_OIDLEN + 4];
        InAddr.s_addr = htonl(AddKey.IpAdd);


        //
        // The storage must be adequate to contain the new
        // string including a NULL terminator.
        //
        pTmpB = inet_ntoa(InAddr);
        if (NULL == pTmpB) {
            return SNMP_ERRORSTATUS_GENERR;
        }
        strcpy( (LPSTR)AddKey.asIpAddress, pTmpB);
        switch(Field)
        {
               case 1:
                        if (VarBind->value.asnType != ASN_RFC1155_IPADDRESS)
                        {
                                return(SNMP_ERRORSTATUS_BADVALUE);
                        }
                               break;


                case 2:                // UpdateCount
                        if (VarBind->value.asnType != ASN_INTEGER)
                        {
                                return(SNMP_ERRORSTATUS_BADVALUE);
                        }
                               (AsnInteger)(AddKey.UpdateCount) =
                                        VarBind->value.asnValue.number;

                               break;

                default:
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        break;

        }

        if (ErrStat == SNMP_ERRORSTATUS_NOERROR)
        {
                ErrStat = WriteKeyNValues(PUSH_E_KEY, &AddKey, Field);
        }
        return(ErrStat);
} //PushSet

UINT
PushGet(
       IN RFC1157VarBind *VarBind,
       IN DWORD          NumKeys,
       IN LPVOID         pKey
    )
{
        UINT                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD           Field;
        DWORD                Index;
        DWORD           NumAddKeys = NumKeys;
        IN PADD_KEY_T         pAddKey = pKey;

        if (pAddKey == NULL)
        {
           //
           // Call EnumAddresses only if we have not been invoked by PnrGetNext
           //
           EnumAddKeys(PUSH_E_KEY, &pAddKey, &NumAddKeys);
        }

        ErrStat = PnrMatch(VarBind, NumAddKeys, pAddKey, &Index, &Field,
                                        PUSH_E_KEY, MIB_GET, NULL);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
                return(ErrStat);
        }

        switch(Field)
        {
                case 1:                //IP address itself

                        VarBind->value.asnType        = ASN_RFC1155_IPADDRESS;
                        VarBind->value.asnValue.string.length = sizeof(ULONG);

                        if ( NULL ==
                                    (VarBind->value.asnValue.string.stream =
                                    SNMP_malloc(VarBind->value.asnValue.string.length
                                   )) )
                        {
                                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                                  goto Exit;
                        }

                        //
                        // SNMP expects the MSB to be in the first byte, MSB-1
                        // to be in the second, ....
                        //
                        VarBind->value.asnValue.string.stream[0] =
                                        (BYTE)((pAddKey + Index)->IpAdd >> 24);
                        VarBind->value.asnValue.string.stream[1] =
                                (BYTE)(((pAddKey + Index)->IpAdd >> 16) & 0xFF);
                        VarBind->value.asnValue.string.stream[2] =
                                (BYTE)(((pAddKey + Index)->IpAdd >> 8) & 0xFF);
                        VarBind->value.asnValue.string.stream[3] =
                                (BYTE)((pAddKey + Index)->IpAdd & 0xFF );
                        VarBind->value.asnValue.address.dynamic = TRUE;
                        break;

                case 2:                // UpdateCount
                        VarBind->value.asnType        = ASN_INTEGER;
                               VarBind->value.asnValue.number =
                                        (AsnInteger)((pAddKey + Index)->
                                                                UpdateCount);
                               break;

                default:
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        break;

        }
Exit:
        if ((pKey == NULL) && (pAddKey != NULL))
        {
              HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pAddKey);
        }
        return(ErrStat);
} // PushGet

UINT
EnumAddKeys(
        KEY_TYPE_E        KeyType_e,
        PADD_KEY_T        *ppAddKey,
        LPDWORD           pNumAddKeys
          )
{


  LONG                 RetVal;
  TCHAR                KeyName[20];  // will hold name of subkey of
                                     // PULL/PUSH records. These keys are IP
                                     // addresses for which 20 is a
                                     // big enough size

#ifdef UNICODE
  CHAR                 AscKeyName[20];
#endif
  DWORD                KeyNameSz;
  FILETIME             LastWrite;
  DWORD                BuffSize;
  HKEY                 SubKey;
  DWORD                ValTyp;
  DWORD                Sz;
  DWORD                NoOfPnrs = 0;        //# of PULL or PUSH pnrs
  DWORD                NoOfVals;
  HKEY                 KeyHdl;
  UINT                 ErrStat = SNMP_ERRORSTATUS_NOERROR;
  PADD_KEY_T           pAddKey;
  PADD_KEY_T           pAddKeySave;
  DWORD                IndexOfPnr;
  HANDLE               PrHeapHdl;

  *pNumAddKeys = 0;             //init to 0
  PrHeapHdl = GetProcessHeap();

   /*
   *  Open the key (PARTNERS)
   */
   ErrStat = OpenKey(PARTNERS_E_KEY, NULL, NULL, NULL, FALSE);

   if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
   {
        return(ErrStat);
   }

   //
   // Open the Pull/Push key
   //
   ErrStat = OpenKey(KeyType_e, NULL, &KeyHdl, NULL, FALSE);
   if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
   {
        CloseReqKey();
        return(ErrStat);
   }
   else   //key was successfully opened
   {

        /*
         *   Query the key.  The subkeys are IP addresses of PULL
         *   partners.
        */
        GetKeyInfo(
                        KeyHdl,
                        &NoOfPnrs,
                        &NoOfVals   //ignored
                      );

        if (NoOfPnrs == 0)
        {
                *ppAddKey = NULL;

        }
        else
        {

                 //
                 // Allocate buffer big enough to hold data for
                 // the number of subkeys found under the PULL key
                 //
                 BuffSize  = sizeof(ADD_KEY_T) * NoOfPnrs;
                 *ppAddKey = HeapAlloc(
                                        PrHeapHdl,
                                        HEAP_NO_SERIALIZE |
                                          HEAP_GENERATE_EXCEPTIONS |
                                          HEAP_ZERO_MEMORY,
                                         BuffSize
                                     );
                if (NULL == *ppAddKey) {
                    
                    return SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
                }
                pAddKey   = *ppAddKey;
                pAddKeySave = pAddKey;

                /*
                 *   For each key, get the values
                */
                for(
                        IndexOfPnr = 0;
                        IndexOfPnr < NoOfPnrs;
                        IndexOfPnr++
                         )
                {
                     KeyNameSz = sizeof(KeyName);  //init before every call
                     RetVal = RegEnumKeyEx(
                                KeyHdl,             //handle of Push/Pull key
                                IndexOfPnr,        //key
                                KeyName,
                                &KeyNameSz,
                                NULL,                //reserved
                                NULL,          //don't need class name
                                NULL,          //ptr to var. to hold class name
                                &LastWrite     //not looked at by us
                                );

                     if (RetVal != ERROR_SUCCESS)
                     {
                                break;
                     }

#ifdef UNICODE
                     if (wcstombs(AscKeyName, KeyName, KeyNameSz) == -1)
                        {
                                DBGPRINT0(ERR,
                           "Conversion not possible in the current locale\n");
                        }
                        AscKeyName[KeyNameSz] = EOS;

NONPORT("Call a comm function to do this")
                        pAddKey->IpAdd = inet_addr(AscKeyName);
                        strcpy(pAddKey->asIpAddress, AscKeyName);
#else
                        pAddKey->IpAdd = inet_addr(KeyName);
                        strcpy(pAddKey->asIpAddress, KeyName);
#endif


                        //
                        // inet_addr returns bytes in network byte order
                        // (Left to
                        // Right).  Let us convert this into host order.  This
                        // will avoid confusion later on. All formatting
                        // functions
                        // expect address to be in host order.
                        //
                        pAddKey->IpAdd = ntohl( pAddKey->IpAdd );

                        RetVal = RegOpenKeyEx(
                                                KeyHdl,
                                                KeyName,
                                                0,        //reserved; must be 0
                                                KEY_READ,
                                                &SubKey
                                                    );

                        if (RetVal != ERROR_SUCCESS)
                        {
                                CloseReqKey();

                                HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, 
                                            *ppAddKey);
                                *ppAddKey = NULL;

                                return(SNMP_ERRORSTATUS_GENERR);
                        }


                        if (KeyType_e == PULL_E_KEY)
                        {

                           //
                           // Read in specific time for replication if one
                           // has been specified
                           //
                           GetSpTimeData(SubKey, pAddKey);

                           Sz = sizeof(pAddKey->TimeInterval);
                           RetVal = RegQueryValueEx(
                                               SubKey,
                                               WINSCNF_RPL_INTERVAL_NM,
                                               NULL,        //reserved; must be NULL
                                               &ValTyp,
                                               (LPBYTE)&(pAddKey->TimeInterval),
                                               &Sz
                                                );

                           if (RetVal != ERROR_SUCCESS)
                           {
                                pAddKey->TimeInterval              = 0;
                                pAddKey->fTimeIntOrUpdCntSet =  FALSE;
                           }
                           else  // a value was read in
                           {
                                pAddKey->fTimeIntOrUpdCntSet =  TRUE;
                           }
                           Sz = sizeof(pAddKey->MemberPrec);
                           RetVal = RegQueryValueEx(
                                               SubKey,
                                               WINSCNF_MEMBER_PREC_NM,
                                               NULL,        //reserved; must be NULL
                                               &ValTyp,
                                               (LPBYTE)&(pAddKey->MemberPrec),
                                               &Sz
                                                );

                           if (RetVal != ERROR_SUCCESS)
                           {
                                pAddKey->MemberPrec              = 0;
                           }
                        }
                        else  // it is a PUSH record
                        {

                                //
                                // Currently, we don't support periodic
                                // or specific time replication for Push
                                // records
                                //

                                Sz = sizeof(pAddKey->UpdateCount);
                                RetVal = RegQueryValueEx(
                                                SubKey,
                                                WINSCNF_UPDATE_COUNT_NM,
                                                NULL,
                                                &ValTyp,
                                                (LPBYTE)&(pAddKey->UpdateCount),
                                                &Sz
                                                        );

                                if (RetVal != ERROR_SUCCESS)
                                {
                                    pAddKey->UpdateCount          = 0;
                                    pAddKey->fTimeIntOrUpdCntSet =  FALSE;
                                }
                                else
                                {
                                     pAddKey->fTimeIntOrUpdCntSet =  TRUE;
                                }


                        }

                        pAddKey->NoOfRpls      = 0;
                        pAddKey->NoOfCommFails = 0;
                        WINS_ASSIGN_INT_TO_VERS_NO_M(pAddKey->VersNo, 0);
                        RegCloseKey(SubKey);


                        pAddKey++;
                 } // end of for {..} for looping over subkeys of PULL

                 NoOfPnrs = IndexOfPnr;

                 /*
                  * Close the  key
                 */
         //        RegCloseKey(KeyHdl);
   } //end of else  (key could not be opened)


   if ((NoOfPnrs > 0) && (KeyType_e == PULL_E_KEY))
   {
          DWORD                    Status;
          DWORD                    i, j;
          WINSINTF_RESULTS_NEW_T   ResultsN;
          WINSINTF_RESULTS_T       Results;
          handle_t                 BindHdl;
          PWINSINTF_RPL_COUNTERS_T pTmp;
          PWINSINTF_ADD_VERS_MAP_T pTmp2;
          BOOL                     fOld = FALSE;

//          pAddKey = *ppAddKey;
          BindHdl = WinsBind(&sBindData);

          ResultsN.WinsStat.NoOfPnrs = 0;
          ResultsN.WinsStat.pRplPnrs = NULL;
          ResultsN.pAddVersMaps = NULL;

          if ((Status = WinsStatusNew(BindHdl, WINSINTF_E_STAT, &ResultsN)) ==
                         RPC_S_PROCNUM_OUT_OF_RANGE)
          {
              Results.WinsStat.NoOfPnrs = 0;
              Results.WinsStat.pRplPnrs = NULL;
              Status = WinsStatus(BindHdl, WINSINTF_E_STAT, &Results);
              fOld = TRUE;
          }
PERF("Can be speeded up by restructuring the data structure and code on the")
PERF("Wins side")

          if (Status == WINSINTF_SUCCESS)
          {
                DWORD NoOfRplPnrs;
                DWORD NoOfOwners;
                //
                // Get the stats for comm. with pnrs.   For this we
                // compare each member that we found in the registry
                // with all members returned in the WinsStat structure
                // until there is a match.  If there is no match, we
                // make the values of the stats 0.
                //
                NoOfRplPnrs   = fOld ? Results.WinsStat.NoOfPnrs :
                                        ResultsN.WinsStat.NoOfPnrs;
                if (NoOfRplPnrs > 0)
                {
                  pTmp = fOld ? Results.WinsStat.pRplPnrs :
                                ResultsN.WinsStat.pRplPnrs;

                  for (j=0; j < NoOfRplPnrs; j++, pTmp++)
                  {
                        pAddKey = pAddKeySave;  //init to the first element
                        for (i = 0; i < NoOfPnrs; i++, pAddKey++)
                        {
                           if (pAddKey->IpAdd == pTmp->Add.IPAdd)
                           {

                                pAddKey->NoOfRpls = pTmp->NoOfRpls;
                                pAddKey->NoOfCommFails =
                                                pTmp->NoOfCommFails;
                                break;
                           }
                        }

                  }

                  // WinsFreeMem(fOld ? Results.WinsStat.pRplPnrs : ResultsN.WinsStat.pRplPnrs); // deallocation at the end of the if branch - bug #187206
                 }

                 //
                 // Add the highest vers. no. for each pnr
                 //
                 pTmp2 = fOld ? &Results.AddVersMaps[1] :
                               (ResultsN.pAddVersMaps + 1);

                 NoOfOwners = fOld ? Results.NoOfOwners : ResultsN.NoOfOwners;

NOTE("This is an assumption that we should not rely on in the future")
                  //
                  // We start from 1 since 0 is always the local WINS.
                  //
                  for (i = 1; i < NoOfOwners; i++, pTmp2++)
                  {
                        pAddKey = pAddKeySave;
                        for (j = 0; j < NoOfPnrs; j++, pAddKey++)
                        {
                           if (pAddKey->IpAdd == pTmp2->Add.IPAdd)
                           {
                                pAddKey->VersNo = pTmp2->VersNo;
                                break;
                           }
                        }
                  }
                  if (!fOld)
                  {
                    WinsFreeMem( ResultsN.pAddVersMaps);
                  }
                  WinsFreeMem( fOld? Results.WinsStat.pRplPnrs : ResultsN.WinsStat.pRplPnrs );
         }

         WinsUnbind(&sBindData, BindHdl);

     }
     if (NoOfPnrs > 1)
     {
        qsort((LPVOID)*ppAddKey,(size_t)NoOfPnrs,sizeof(ADD_KEY_T),CompareAdd );
    }

 }
     CloseReqKey();
     *pNumAddKeys = NoOfPnrs;
     if ((*pNumAddKeys == 0) && (*ppAddKey != NULL))
     {
          HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, *ppAddKey);
          *ppAddKey = NULL;
     }
     return (ErrStat);
} // EnumAddKeys



UINT
GetKeyInfo(
        IN  HKEY                   Key,
        OUT LPDWORD                  pNoOfSubKeys,
        OUT LPDWORD                pNoOfVals
        )

/*++

Routine Description:
        This function is called to get the number of subkeys under a key

Arguments:
        Key         - Key whose subkey count has to be determined
        KeyType_e
        pNoOfSubKeys

Externals Used:
        None


Return Value:

        None
Error Handling:

Called by:
        GetPnrInfo()

Side Effects:

Comments:
        None
--*/

{
          TCHAR    ClsStr[40];
          DWORD    ClsStrSz = sizeof(ClsStr);
          DWORD    LongestKeyLen;
          DWORD    LongestKeyClassLen;
          DWORD    LongestValueNameLen;
          DWORD    LongestValueDataLen;
          DWORD    SecDesc;
        LONG         RetVal;

          FILETIME LastWrite;
        UINT  ErrStat = SNMP_ERRORSTATUS_NOERROR;
          /*
                Query the key.
          */
          RetVal = RegQueryInfoKey(
                        Key,
                        ClsStr,
                        &ClsStrSz,
                        NULL,                        //must be NULL, reserved
                        pNoOfSubKeys,
                        &LongestKeyLen,
                        &LongestKeyClassLen,
                        pNoOfVals,
                        &LongestValueNameLen,
                        &LongestValueDataLen,
                        &SecDesc,
                        &LastWrite
                                );

          if (RetVal != ERROR_SUCCESS)
          {
                ErrStat = SNMP_ERRORSTATUS_GENERR;
        }
        return (ErrStat);
}


VOID
GetSpTimeData(
        HKEY                  SubKey,
        PADD_KEY_T          pAddKey
)
/*++

Routine Description:
        This function is called to get the specific time and period information
        for a PULL/PUSH record.

Arguments:
        SubKey   - Key of a WINS under the Pull/Push key

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_NO_SP_TIME

Error Handling:

Called by:
        GetPnrInfo

Side Effects:

Comments:
        None
--*/

{
          DWORD     ValTyp;
        DWORD          Sz;
        LONG          RetVal;


        pAddKey->fSpTimeSet = FALSE;

FUTURES("Do internationalization of strings here")

            Sz = sizeof(pAddKey->asSpTime);
            RetVal = RegQueryValueEx(
                             SubKey,
                             WINSCNF_SP_TIME_NM,
                             NULL,        //reserved; must be NULL
                             &ValTyp,
                             pAddKey->asSpTime,
                             &Sz
                                );

//PERF(If memory is initialized to 0, we don't need to do the following
            //
            // If the user has not specifed a specific time, then we use
            // the current time as the specific time.  For current time,
            // the interval is 0
            //
            if (RetVal == ERROR_SUCCESS)
            {
                pAddKey->fSpTimeSet = TRUE;
            }
            else
            {
                pAddKey->asSpTime[0] = EOS;
            }

            return;
}

int
__cdecl
CompareAdd(
        const VOID *pKey1,
        const VOID *pKey2
        )

{
        const PADD_KEY_T        pAddKey1 = (PADD_KEY_T)pKey1;
        const PADD_KEY_T        pAddKey2 = (PADD_KEY_T)pKey2;

        return(pAddKey1->IpAdd - pAddKey2->IpAdd);
}

UINT
GetNextVar(
        IN RFC1157VarBind *pVarBind,
        IN MIB_ENTRY          *pMibPtr
)
{
       UINT                ErrStat;

       while (pMibPtr != NULL)
       {
         if (pMibPtr->MibNext != NULL)
         {
            //
            // Setup var bind name of NEXT MIB variable
            //
            SNMP_oidfree( &pVarBind->name );
            SNMP_oidcpy( &pVarBind->name, &MIB_OidPrefix );
            SNMP_oidappend( &pVarBind->name, &pMibPtr->MibNext->Oid );

            //
            // If the func. ptr is  NULL and the type of the mib variable
            // is anything but OPAQUE, call function to process the
            // MIB variable
            //
            if (
                 (pMibPtr->MibNext->MibFunc != NULL)
                        &&
                 (pMibPtr->MibNext->Type !=  ASN_RFC1155_OPAQUE)
               )

            {
                ErrStat = (*pMibPtr->MibNext->MibFunc)( MIB_GETFIRST,
                                                pMibPtr->MibNext, pVarBind );
                if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
                {
                        goto Exit;
                }
                break;
            }
            else
            {
                pMibPtr = pMibPtr->MibNext;
            }
          }
          else
          {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            break;
          }
         }

         if (pMibPtr == NULL)
         {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
         }
Exit:
        return(ErrStat);
}

UINT
EnumDFValues(
        PDATAFILE_INFO_T                *ppDFValues,
        LPDWORD                                pNumDFValues
          )

/*++

Routine Description:
        This function gets the names of all the datafiles that need to
        be used for initializing WINS.

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        LONG             RetVal;
        DWORD            BuffSize;
        STATUS          RetStat = WINS_SUCCESS;
        DWORD          NoOfSubKeys;
        DWORD          NoOfDFValues;
        UINT          ErrStat;
        DWORD          n;

        *pNumDFValues = 0;
        *ppDFValues = NULL;
        n = 0;
        ErrStat = OpenKey(PARAMETERS_E_KEY, NULL, NULL, NULL, FALSE);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
                return(ErrStat);
        }
        ErrStat = OpenKey(DATAFILES_E_KEY, NULL, &sDatafilesKey, NULL, FALSE);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
                CloseReqKey();
                return(ErrStat);
        }

try {
        //
        // Get the count of data files listed under the DATAFILES
        // key
        //
        GetKeyInfo(
                        sDatafilesKey,
                        &NoOfSubKeys,  //ignored
                        &NoOfDFValues
                  );

        if (NoOfDFValues > 0)
        {

                DWORD                          Index;
                PDATAFILE_INFO_T pTmp;
#if 0
                TCHAR ValNmBuff[MAX_PATH];
#endif
                DWORD ValNmBuffSz;


                  //
                  // Allocate buffer big enough to hold data for
                // the number of values found under the Datafiles key
                  //
                  BuffSize = DATAFILE_INFO_SZ * NoOfDFValues;
                    pTmp          = HeapAlloc(
                                GetProcessHeap(),
                                HEAP_NO_SERIALIZE |
                                HEAP_GENERATE_EXCEPTIONS |
                                HEAP_ZERO_MEMORY,
                                BuffSize
                                   );

                if (pTmp != NULL)
                {
                        *ppDFValues = pTmp;
                }
                else
                {
                        Index = 0;
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                        goto Exit;
                }

                   /*
                    *   Get the values
                     */
                     for(
                        Index = 0, n = 0;
                        Index <  NoOfDFValues;
                        Index++
                         )
                {
                        ValNmBuffSz = sizeof(pTmp->ValNm);  //init before
                                                            // every call
                        BuffSize  = WINSMIB_FILE_INFO_SIZE;
                          RetVal = RegEnumValue(
                                    sDatafilesKey,
                                    Index,                        //value index
                                    pTmp->ValNm,
                                    &ValNmBuffSz,
                                    (LPDWORD)NULL,                //reserved
                                    &pTmp->StrType,
                                    (LPBYTE)(pTmp->FileNm),//ptr to var. to
                                                           //hold name of
                                                           //datafile
                                    &BuffSize        //not looked at by us
                                            );
                        if (RetVal != ERROR_SUCCESS)
                        {
                                continue;
                        }
                        pTmp->FileNm[BuffSize] = EOS;

                        //
                        // if StrType is not REG_SZ or REG_EXPAND_SZ, go to
                        // the next  Value
                        //
                        if  (
                                (pTmp->StrType != REG_EXPAND_SZ)
                                        &&
                                   (pTmp->StrType != REG_SZ)
                                )
                        {
                                continue;
                        }

                        n++;
                        pTmp = (PDATAFILE_INFO_T)((LPTCH)pTmp +
                                                      DATAFILE_INFO_SZ);
                }

Exit:
                if (n > 1)
                {
                          qsort(
                        (LPVOID)*ppDFValues,
                        (size_t)n,
                        sizeof(DATAFILE_INFO_T),
                        CompareIndexes
                                );
                }
                *pNumDFValues = n;
        }
 } // end of try ..
except (EXCEPTION_EXECUTE_HANDLER) {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "WINSMIB: WinsCnfGetNamesOfDataFiles. Exception = (%d).\n",
                    GetExceptionCode()
                    ));
                ErrStat = SNMP_ERRORSTATUS_GENERR;
        }

        CloseReqKey();

        if ((*pNumDFValues == 0) && (*ppDFValues != NULL))
        {
                HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, *ppDFValues);
        }
        return(ErrStat);
}


UINT
DFGet(
       IN RFC1157VarBind                  *VarBind,
       IN DWORD                           NumValues,
       IN LPVOID                          pValues
    )
{
        UINT                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD                Index;
        DWORD                i;
        DWORD           NumDFValues = NumValues;
        PDATAFILE_INFO_T         pDFValues;
        PVOID       pDFValuesSv;
        INT                iValNm;

        //
        // Get the index of the file to get.  If the Index is more than
        // the # of files, we return an error.
        //
        Index =  VarBind->name.ids[VarBind->name.idLength - 1];
        if (Index == 0)
        {
            return(SNMP_ERRORSTATUS_NOSUCHNAME);
        }

        EnumDFValues(&pDFValues, &NumDFValues);
        pDFValuesSv = pDFValues;
        for (i=0; i < NumDFValues; i++, pDFValues++)
        {
           //
           // atoi returns a 0 if it can not do a conversion, so if
           // somebody other than an snmp agent messes with the
           // registry names and introduces alphabets, atoi will return
           // 0 and we will not see a match
           //
           iValNm = atoi(pDFValues->ValNm);
           if (iValNm == (INT)Index)
           {
                break;
           }

        }
        if (i == NumDFValues)
        {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
        }

        //
        // Initialize VarBind fields with the type, length, and value
        //
        VarBind->value.asnType        = ASN_RFC1213_DISPSTRING;
        VarBind->value.asnValue.string.length =
                                strlen((LPSTR)(pDFValues->FileNm));

        if ( NULL ==  (VarBind->value.asnValue.string.stream =
                                   SNMP_malloc(VarBind->value.asnValue.string.length *
                                   sizeof(CHAR))) )
        {
                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                goto Exit;
        }

        memcpy( VarBind->value.asnValue.string.stream,
                                       (LPSTR)(pDFValues->FileNm),
                                       VarBind->value.asnValue.string.length );

        VarBind->value.asnValue.string.dynamic = TRUE;

Exit:
        //
        // If we allocated memory for storing datafiles info, deallocate it
        // now
        //
        if (pDFValuesSv != NULL)
        {
                HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pDFValuesSv);
        }
        return(ErrStat);
}

UINT
DFGetNext(
       IN RFC1157VarBind *VarBind,
       IN MIB_ENTRY          *MibPtr,
       IN KEY_TYPE_E         KeyType_e
          )
{
     DWORD          NumDFValues;
     INT            Index;
     PDATAFILE_INFO_T  pDFValues;
     PVOID             pDFValuesSv;
     UINT         ErrStat = SNMP_ERRORSTATUS_NOERROR;
     DWORD          i;
     INT         iValNm;
     BOOL         fMatch = FALSE;

     UNREFERENCED_PARAMETER(KeyType_e);
     //
     // Read in all ip address keys. For each key, the values of its fields
     // is stored in the PDATAFILE_INFO structure.  The number of
     // files found is stored in NumDFValues
     //
     EnumDFValues(&pDFValues, &NumDFValues);
     pDFValuesSv = pDFValues;

     //
     // Check if the name passed matches any in the table (i.e. table of
     // of ADD_KEY_T structures.  If there is a match, the address
     // of the ip address key and the matching field's no. are returned
     //
     Index =  VarBind->name.ids[DF_OIDLEN + 1];
//     Index =  VarBind->name.ids[VarBind->name.idLength - 1];
     for (i=0; i < NumDFValues; i++, pDFValues++)
     {
           iValNm = atoi(pDFValues->ValNm);
           if (iValNm == Index)
           {
                fMatch = TRUE;
                break;
           }
           if (iValNm > Index)
           {
                break;
           }
     }
     //
     // if the index specified is higher than all existing indices or if
     // match was with the last entry in the list, get to next var.
     //
     if ((i == 0) || (i >= (NumDFValues - 1)))
     {
            if (pDFValuesSv != NULL)
            {
              HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pDFValuesSv);
            }
            return(GetNextVar(VarBind, MibPtr));
     }

     //
     // Since the operation is GET_NEXT, get the next Value number
     // If there is no next file, we call the MibFunc of the next MIB entry.
     // Put the index of the next datafile
     //
     if (fMatch)
     {
        ++pDFValues;
     }
     VarBind->name.ids[VarBind->name.idLength - 1] = atoi(pDFValues->ValNm);

     //
     // Get the value
     //
        //
        // Initialize VarBind fields with the type, length, and value
        //
        VarBind->value.asnType        = ASN_RFC1213_DISPSTRING;
        VarBind->value.asnValue.string.length =
                                strlen((LPSTR)(pDFValues->FileNm));

        if ( NULL ==  (VarBind->value.asnValue.string.stream =
                                   SNMP_malloc(VarBind->value.asnValue.string.length *
                                   sizeof(CHAR))) )
        {
                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                goto Exit;
        }

        memcpy( VarBind->value.asnValue.string.stream,
                                       (LPSTR)(pDFValues->FileNm),
                                       VarBind->value.asnValue.string.length );

Exit:
      
     if (pDFValuesSv != NULL)
     {
        HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pDFValuesSv);
     }
     return(ErrStat);
}

UINT
DFGetFirst(
       IN RFC1157VarBind *VarBind,
       IN MIB_ENTRY        *MibPtr,
       IN KEY_TYPE_E        KeyType_e
        )
{

        PDATAFILE_INFO_T pDFValues;
        DWORD           NumDFValues;
        UINT           TableEntryId[2];
        AsnObjectIdentifier        TableEntryOid = { OID_SIZEOF(TableEntryId),
                                                        TableEntryId };
        UINT   ErrStat = SNMP_ERRORSTATUS_NOERROR;

        UNREFERENCED_PARAMETER(KeyType_e);

        //
        // Get all the address key information
        //
PERF("Get the first entry only. Since we won't have very many entries, this")
PERF("is ok.  When a cache is implemented, this will serve to populate the")
PERF("cache")
             EnumDFValues(&pDFValues, &NumDFValues);

        //
        // If there is no entry in the table, go to the next MIB variable
        //
        if (NumDFValues == 0)
        {
                 return(GetNextVar(VarBind, MibPtr));
        }


        //
        // Write the object Id into the binding list and call get
        // func
        //
        SNMP_oidfree( &VarBind->name );
        SNMP_oidcpy( &VarBind->name, &MIB_OidPrefix );
        SNMP_oidappend( &VarBind->name, &MibPtr->Oid );

        //
        // The fixed part of the objid is correct. Update the rest.
        //

        TableEntryId[0] = 2;        //put 2 to access the datafile name
#if 0
        TableEntryId[1] = 1;        //put 1 (for the datafile index).  This is
                                //used for indexing the row of the table
#endif
        TableEntryId[1] = atoi(pDFValues->ValNm);
        SNMP_oidappend( &VarBind->name, &TableEntryOid );

        //
        // Initialize VarBind fields with the type, length, and value
        //
        VarBind->value.asnType        = ASN_RFC1213_DISPSTRING;
        VarBind->value.asnValue.string.length =
                                strlen((LPSTR)(pDFValues->FileNm));

        if ( NULL ==  (VarBind->value.asnValue.string.stream =
                                   SNMP_malloc(VarBind->value.asnValue.string.length *
                                   sizeof(CHAR))) )
        {
                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                goto Exit;
        }

        (void)memcpy( VarBind->value.asnValue.string.stream,
                                       (LPSTR)(pDFValues->FileNm),
                                       VarBind->value.asnValue.string.length );
#if 0
        //
        // get the file name
        //
        ErrStat = DFGet(VarBind, NumDFValues, pDFValues);
#endif
Exit:
        HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, pDFValues);
        return(ErrStat);
}
UINT
DFSet(
       IN RFC1157VarBind *pVarBind
)
{
        UINT                                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD                           Index;
        DATAFILE_INFO_T                DFValue;
#if 0
        PDATAFILE_INFO_T        pDFValues;
#endif

             Index =  pVarBind->name.ids[pVarBind->name.idLength - 1];

             if (Index == 0)
             {
            return(SNMP_ERRORSTATUS_NOSUCHNAME);
             }

        if ( pVarBind->value.asnType != ASN_RFC1213_DISPSTRING)
        {
                return(SNMP_ERRORSTATUS_BADVALUE);
        }

#if 0
               // The storage must be adequate to contain the new
        // string including a NULL terminator.
               memcpy( (LPSTR)DFValue.FileNm,
                            pVarBind->value.asnValue.string.stream,
                            pVarBind->value.asnValue.string.length );

        ((LPSTR)DFValue.FileNm)[pVarBind->value.asnValue.string.length] = '\0';
#endif

        ErrStat = WriteDFValue(pVarBind, &DFValue, Index);
        return(ErrStat);

} //DFSet

UINT
WriteDFValue(
        IN RFC1157VarBind          *pVarBind,
        PDATAFILE_INFO_T          pDFValue,
        DWORD                         Index
        )
{

//
// remove pDFValue as an argument. Use local
//
        TCHAR   ValNmBuff[MAX_PATH];
        DWORD   ValNmBuffSz         = MAX_PATH;
        UINT    ErrStat         = SNMP_ERRORSTATUS_NOERROR;
        LONG          RetVal;

        if (pVarBind->value.asnType != ASN_RFC1213_DISPSTRING)
        {
                return(SNMP_ERRORSTATUS_BADVALUE);
        }

        if (
                pVarBind->value.asnValue.string.stream[0] == '%')
        {
                pDFValue->StrType = REG_EXPAND_SZ;
        }
        else
        {
                pDFValue->StrType = REG_SZ;
        }

        //
        // Open the Parameters key and the Datafiles key under that
        //
        ErrStat = OpenKey(PARAMETERS_E_KEY, NULL, NULL, NULL, TRUE);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
           return(ErrStat);
        }
        ErrStat = OpenKey(DATAFILES_E_KEY, NULL, NULL, NULL, TRUE);
        if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
        {
           return(ErrStat);
        }

        //
        // If the index is within the range that we have in the registry,
        // let us get the name of the value that stores the datafile name
        //
        // We get the name because we don't know what it is.  If we have
        // to overwrite the name, we need to know what it is first.
        //
        sprintf(ValNmBuff, "%d",  Index);

        //
        // Set the name
        //
        RetVal = RegSetValueEx(
                                sDatafilesKey,
                                ValNmBuff,
                                0,         //reserved -- must be 0
                                pDFValue->StrType,
                                pVarBind->value.asnValue.string.stream,
                                pVarBind->value.asnValue.string.length
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "WINSMIB: Could not set value of %s.\n",
                    pVarBind->value.asnValue.string.stream
                    ));
                ErrStat = SNMP_ERRORSTATUS_GENERR;
        }


        //
        // Let us close the keys that we opened/created
        //
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "WINSMIB: Closing sParametersKey 0x%08lx (fKeyOpen=%s).\n",
            sParametersKey, sfParametersKeyOpen ? "TRUE" : "FALSE"
            ));
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "WINSMIB: Closing sDatafilesKey 0x%08lx (fKeyOpen=%s).\n",
            sDatafilesKey, sfDatafilesKeyOpen ? "TRUE" : "FALSE"
            ));
       CloseReqKey();
/*
        RegCloseKey(sParametersKey);
        RegCloseKey(sDatafilesKey);
*/

        return(ErrStat);
}

//
// HandleCmd
//    Performs specific actions on the different Cmd MIB variable
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
UINT HandleCmd(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN RFC1157VarBind *VarBind
        )

{
WINSINTF_RESULTS_T         Results;
handle_t                BindHdl;
DWORD                        Status;
UINT                           ErrStat = SNMP_ERRORSTATUS_NOERROR;

   switch ( Action )
   {
      case MIB_SET:
                   if ((ErrStat = MIB_leaf_func( Action, MibPtr, VarBind ))
                        == SNMP_ERRORSTATUS_NOERROR)
                {

                        ErrStat = ExecuteCmd(MibPtr);
                }
                break;

      case MIB_GETFIRST:
                //
                // fall through
                //
      case MIB_GET:
                if (
                        (MibPtr->Storage == &MIB_NoOfWrkThdsStore)
                                        ||
                        (MibPtr->Storage == &MIB_PriorityClassStore)
                                        ||
                        (MibPtr->Storage == &MIB_MaxVersNo_LowWordStore)
                                        ||
                        (MibPtr->Storage == &MIB_MaxVersNo_HighWordStore)

                   )

                {
                  if (!fWinsMibWinsStatusCnfCalled)
                  {
                    Results.WinsStat.NoOfPnrs = 0;
                    Results.WinsStat.pRplPnrs = NULL;
                       BindHdl                 = WinsBind(&sBindData);
                    Status = WinsStatus(BindHdl, WINSINTF_E_CONFIG, &Results);
                    if (Status != WINSINTF_SUCCESS)
                    {
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                        WinsUnbind(&sBindData, BindHdl);
                        goto Exit;
                    }

                    MIB_NoOfWrkThdsStore   = Results.NoOfWorkerThds;
                    if (Results.WinsPriorityClass == NORMAL_PRIORITY_CLASS)
                    {
                       MIB_PriorityClassStore = 0;
                    }
                    else
                    {
                       MIB_PriorityClassStore = 1;
                    }
                    MIB_MaxVersNo_LowWordStore = Results.AddVersMaps[0].VersNo.LowPart;
                    MIB_MaxVersNo_HighWordStore = Results.AddVersMaps[0].VersNo.HighPart;
                    fWinsMibWinsStatusCnfCalled = TRUE;
                    WinsUnbind(&sBindData, BindHdl);

                  }
                }
                      //
                      // fall through
                      //
      case MIB_GETNEXT:

        //
        // Call the more generic function to perform the action
        //
        ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );
        break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
         goto Exit;
  } // switch

Exit:
   return ErrStat;
} // HandleCmd

UINT
ExecuteCmd(
  IN MIB_ENTRY *pMibPtr
        )
{
        UINT                        ErrStat = SNMP_ERRORSTATUS_NOERROR;
        WINSINTF_ADD_T                WinsAdd;
        LPBYTE                        pStorage;
        handle_t                BindHdl;
        DWORD                        Status;
        WinsAdd.Len        = 4;
        WinsAdd.Type        = 0;


           BindHdl                 = WinsBind(&sBindData);

        //
        // For Performance, arrange the following in the order of
        // expected frequency.
        //
        if ( pMibPtr->Storage  == &MIB_PullTriggerStore )
        {
                pStorage = MIB_PullTriggerStore;
                WinsAdd.IPAdd = ntohl(*(DWORD*)pStorage);
                //NMSMSGF_RETRIEVE_IPADD_M(pStorage, WinsAdd.IPAdd);
                Status = WinsTrigger(BindHdl, &WinsAdd, WINSINTF_E_PULL);
                if (Status != WINSINTF_SUCCESS)
                {
                        int backupSize = sizeof(MIB_PullTriggerStore) / 2;
                        // setting back the original value
                        memcpy( (LPSTR)pMibPtr->Storage, (LPSTR)pMibPtr->Storage + backupSize, backupSize);
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_PushTriggerStore )
        {
                pStorage = MIB_PushTriggerStore;
                WinsAdd.IPAdd = ntohl(*(DWORD*)pStorage);
                //NMSMSGF_RETRIEVE_IPADD_M(pStorage, WinsAdd.IPAdd);
                Status = WinsTrigger(BindHdl, &WinsAdd, WINSINTF_E_PUSH);
                if (Status != WINSINTF_SUCCESS)
                {
                        int backupSize = sizeof(MIB_PushTriggerStore) / 2;
                        // setting back the original value
                        memcpy( (LPSTR)pMibPtr->Storage, (LPSTR)pMibPtr->Storage + backupSize, backupSize);
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_DoScavengingStore )
        {
                if (MIB_DoScavengingStore == 1)
                {
                  Status = WinsDoScavenging(BindHdl);
                  if (Status != WINSINTF_SUCCESS)
                  {
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                  }
                }
                else
                {
                        if (MIB_DoScavengingStore != 0)
                        {
                                MIB_DoScavengingStore = 0;
                                ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        }
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_DoStaticInitStore )
        {
                LPBYTE pDataFile = MIB_DoStaticInitStore;
                WCHAR UcDataFile[WINSMIB_FILE_INFO_SIZE];
                if (MIB_DoStaticInitStore[0] == EOS)
                {
                        UcDataFile[0] = (WCHAR)NULL;
                }
                else
                {
                        MultiByteToWideChar(        CP_ACP, 0,
                                                pDataFile, -1, UcDataFile,
                                                WINSMIB_FILE_INFO_SIZE
                                           );
                }
                Status = WinsDoStaticInit(BindHdl, UcDataFile, FALSE);
                if (Status != WINSINTF_SUCCESS)
                {
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_NoOfWrkThdsStore )
        {
                if (
                        (MIB_NoOfWrkThdsStore < 1)
                                ||
                        (MIB_NoOfWrkThdsStore > 4)
                   )
                {
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        goto Exit;
                }
                Status = WinsWorkerThdUpd(BindHdl, (DWORD)MIB_NoOfWrkThdsStore);
                if (Status != WINSINTF_SUCCESS)
                {
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_PriorityClassStore )
        {
                if (
                        (MIB_PriorityClassStore < 0)
                                ||
                        (MIB_PriorityClassStore > 1)

                   )
                {
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        goto Exit;
                }
                Status = WinsSetPriorityClass(
                                BindHdl,
                                (DWORD)MIB_PriorityClassStore);
                if (Status != WINSINTF_SUCCESS)
                {
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_ResetCountersStore )
        {
                Status = WinsResetCounters(BindHdl);
                if (Status != WINSINTF_SUCCESS)
                {
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_DeleteDbRecsStore )
        {
                WINSINTF_VERS_NO_T        MaxVersNo, MinVersNo;
                WINS_ASSIGN_INT_TO_VERS_NO_M(MaxVersNo, 0);
                WINS_ASSIGN_INT_TO_VERS_NO_M(MinVersNo, 0);

                pStorage = MIB_DeleteDbRecsStore;
                WinsAdd.IPAdd = ntohl(*(DWORD*)pStorage);
                //NMSMSGF_RETRIEVE_IPADD_M(pStorage, WinsAdd.IPAdd);
                Status = WinsDelDbRecs(BindHdl, &WinsAdd, MinVersNo, MaxVersNo);
                if (Status != WINSINTF_SUCCESS)
                {
                        int backupSize = sizeof(MIB_DeleteDbRecsStore) / 2;
                        // setting back the original value
                        memcpy( (LPSTR)pMibPtr->Storage, (LPSTR)pMibPtr->Storage + backupSize, backupSize);

                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_GetDbRecsStore )
        {
                if (PopulateDRCache() == WINSINTF_SUCCESS)
                {
                        (VOID)time(&sDRCacheInitTime);

                }
                else
                {
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        if ( pMibPtr->Storage  == &MIB_DeleteWinsStore )
        {

                pStorage = MIB_DeleteWinsStore;
                WinsAdd.IPAdd = ntohl(*(DWORD*)pStorage);
                //NMSMSGF_RETRIEVE_IPADD_M(pStorage, WinsAdd.IPAdd);
                Status = WinsDeleteWins(BindHdl, &WinsAdd);
                if (Status != WINSINTF_SUCCESS)
                {
                    int backupSize = sizeof(MIB_DeleteWinsStore) / 2;
                    // setting back the original value
                    memcpy( (LPSTR)pMibPtr->Storage, (LPSTR)pMibPtr->Storage + backupSize, backupSize);

                    ErrStat = SNMP_ERRORSTATUS_GENERR;
                }
                goto Exit;
        }
        ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;


Exit:
   WinsUnbind(&sBindData, BindHdl);
   return ErrStat;
}


VOID
WinsMibInit(
        VOID
)
{
#if 0
        DWORD           i;
        MIB_ENTRY *pMib;
#endif
        //
        // We use named pipe to communicate with WINS when it is on
        // the same machine since it is faster than TCP/IP.  We don't
        // use LRPC since WINS does not listen on that (to minimize
        // on thread usage)
        //
           sBindData.fTcpIp     =  TRUE;
           sBindData.pServerAdd =  LOCAL_ADD;
           sBindData.pPipeName  =  NULL;
//        InitializeCriticalSection(&WinsMibCrtSec);
#if 0
        pMib = Mib;
        for (i=1; i < (MIB_num_variables + 1); i++, pMib++)
        {
                if (pMib->
                pMib->MibNext = &Mib[i];
        }

        for (i=0; i < NUM_TABLES; i++)
        {

        }
#endif
        return;
}

UINT
DRGet(
       IN RFC1157VarBind *VarBind,
       IN DWORD          FieldParam,
       IN LPVOID         pRowParam
    )
{
        UINT                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD           Field;
        PWINSINTF_RECORD_ACTION_T        pRow = NULL;
        DWORD                i, n;
        LPBYTE                pTmp;


        //
        // if the row was passed (for instance from DRGetNext), skip
        // the search part
        //
        if (pRowParam == NULL)
        {
          ErrStat = DRMatch(VarBind, &pRow, &i /*not used*/ , &Field,
                                MIB_GET, NULL);
               if (
                        (ErrStat != SNMP_ERRORSTATUS_NOERROR)
                                ||
                        (pRow == NULL)
                                ||
                        (pRow->State_e == WINSINTF_E_DELETED)
             )
               {
//              bug #235928 - if the first condition in the above if is true, then the
//              derefferencing pRow causes a first chance exception!
//              if (pRow->State_e == WINSINTF_E_DELETED)
                if (ErrStat == SNMP_ERRORSTATUS_NOERROR)
                {
                        ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
                }
                return(ErrStat);
               }
        }
        else
        {
                pRow  = pRowParam;
                Field = FieldParam;
        }

        switch(Field)
        {
                case 1:                //name

                        VarBind->value.asnType        = ASN_OCTETSTRING;
                               VarBind->value.asnValue.string.length = pRow->NameLen;

                               if ( NULL ==
                                    (VarBind->value.asnValue.string.stream =
                                     SNMP_malloc(VarBind->value.asnValue.string.length
                                   )) )
                          {
                                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                                  goto Exit;
                          }

                               memcpy( VarBind->value.asnValue.string.stream,
                                       (LPSTR)(pRow->pName),
                                       VarBind->value.asnValue.string.length );

                               VarBind->value.asnValue.string.dynamic = TRUE;

                        break;
                case 2:                // address(es)
                        VarBind->value.asnType        = ASN_OCTETSTRING;
                        if (
                                (pRow->TypOfRec_e == WINSINTF_E_UNIQUE)
                                          ||
                                (pRow->TypOfRec_e == WINSINTF_E_NORM_GROUP)
                           )
                        {
                                       VarBind->value.asnValue.string.length = 4;
                        }
                        else
                        {
                                       VarBind->value.asnValue.string.length =
                                                4 * pRow->NoOfAdds;
                        }


                               if ( NULL ==
                                    (VarBind->value.asnValue.string.stream =
                                    SNMP_malloc(VarBind->value.asnValue.string.length *
                                   sizeof(char))) )
                          {
                                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                                  goto Exit;
                          }

                        pTmp =  VarBind->value.asnValue.string.stream;

                        if (
                                (pRow->TypOfRec_e == WINSINTF_E_UNIQUE)
                                          ||
                                (pRow->TypOfRec_e == WINSINTF_E_NORM_GROUP)
                           )
                        {
                                NMSMSGF_INSERT_IPADD_M(pTmp,pRow->Add.IPAdd);
                        }
                        else
                        {
                         for (i = 0, n = 0; i < pRow->NoOfAdds/2; i++)
                         {
                                NMSMSGF_INSERT_IPADD_M(pTmp,
                                                (pRow->pAdd + n)->IPAdd);
                                n++;

                                NMSMSGF_INSERT_IPADD_M(pTmp,
                                                (pRow->pAdd + n)->IPAdd);
                                n++;
                         }
                        }
                               VarBind->value.asnValue.string.dynamic = TRUE;
                        break;
                case 3:                // Record Type
                        VarBind->value.asnType        = ASN_INTEGER;
                               VarBind->value.asnValue.number =
                                (AsnInteger)(pRow->TypOfRec_e);
                               break;

                case 4:   //Persistence Type
                        VarBind->value.asnType        = ASN_INTEGER;
                               VarBind->value.asnValue.number =
                                (AsnInteger)pRow->fStatic;

                               break;

                case 5:   //State
                        VarBind->value.asnType        = ASN_INTEGER;
                               VarBind->value.asnValue.number =
                                (AsnInteger)pRow->State_e;

                               break;


                default:
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        break;

        }
Exit:
        return(ErrStat);
}
UINT
DRGetNext(
       IN RFC1157VarBind *VarBind,
       IN MIB_ENTRY          *MibPtr,
       IN KEY_TYPE_E         KeyType_e
          )
{
     DWORD          OidIndex;
     DWORD         FieldNo;
     UINT         ErrStat = SNMP_ERRORSTATUS_NOERROR;
     DWORD       Index;
     DWORD         i;
     LPBYTE      pNameChar;
     UINT         TableEntryIds[NMSDB_MAX_NAM_LEN];
     BOOL         fFirst;
     AsnObjectIdentifier        TableEntryOid = { OID_SIZEOF(TableEntryIds),
                                                        TableEntryIds };

     PWINSINTF_RECORD_ACTION_T        pRow;


     //
     // If there is no entry in the table, go to the next MIB variable
     //
     if (sRecs.NoOfRecs == 0)
     {
           return(GetNextVar(VarBind, MibPtr));
     }
     //
     // Check if the name passed matches any in the table (i.e. table of
     // of WINSINTF_RECORD_ACTION_T structures.  If there is a match, the
     // address of the structure and the matching field's no. are returned
     //
     ErrStat = DRMatch(VarBind, &pRow, &Index,  &FieldNo, MIB_GETNEXT, &fFirst);
     if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
     {
        return(ErrStat);
     }

     //
     // Since the operation is GETNEXT, get the next name  (i.e. one
     // that is lexicographically bigger.  If there is none, we must increment
     // the field value and move back to the lexically first item in the table
     // If the new field value is more than the largest supported, we call
     // the MibFunc of the next MIB entry.
     //
     // sRecs.NoOfRecs > 0 since otherwise we won't be here.
     //
     //
     // If we are at the last record and this is not that case where no name
     // was passed to us, then increment the field and if it is still within
     // bounds, get the first record in the cache
     //
     //
     if  ((Index == (sRecs.NoOfRecs - 1))  && !fFirst)
     {
                     if (++FieldNo > NO_FLDS_IN_DR)
                {
                    return(GetNextVar(VarBind, MibPtr));
                }
                else
                {
                        Index = 0;
                        pRow  = (PWINSINTF_RECORD_ACTION_T)sRecs.pRow;
                }
     }
     else
     {
         //
         // no name was passed, so we need to get the field of the first
         // record in the table
         //
         if (fFirst)
         {
                pRow = (PWINSINTF_RECORD_ACTION_T)sRecs.pRow;
         }
         else
         {
           //
           // Get the field of the next record in the cache
           //
           Index++;
           pRow++;
         }

         while(pRow->State_e == WINSINTF_E_DELETED)
         {
                     if (Index == (sRecs.NoOfRecs - 1))
                     {
                       if (++FieldNo > NO_FLDS_IN_DR)
                  {
                        return(GetNextVar(VarBind, MibPtr));
                       }
                  else
                  {
                        Index = 0;
                        pRow  = (PWINSINTF_RECORD_ACTION_T)sRecs.pRow;
                  }
                }
                else
                {
                  pRow++;
                  Index++;
                }
         }
      }

      //
      // Write the object Id into the binding list and call get
      // func
      //
      SNMP_oidfree( &VarBind->name );
      SNMP_oidcpy( &VarBind->name, &MIB_OidPrefix );
      SNMP_oidappend( &VarBind->name, &MibPtr->Oid );

      TableEntryIds[0] = FieldNo;
      OidIndex =  1;
      pNameChar = pRow->pName;

     //
     // The fixed part of the objid is correct. Update the rest.
     //
     for (i = 0; i < pRow->NameLen; i++)
     {
              TableEntryIds[OidIndex++] = (UINT)*pNameChar++;
     }
     TableEntryOid.idLength = OidIndex;
     SNMP_oidappend( &VarBind->name, &TableEntryOid );

     //
     // Get the value
     //
     ErrStat = DRGet(VarBind, FieldNo, pRow);

     return(ErrStat);
}
//
// The rpc function WinsRecordAction has changed in that now it takes
// the address of a pointer.  On return the buffer allocated by RPC has
// to be freed. Modify this function to account for that.  Currently,
// we never call this function so this work is being deferred - 4/28/94.
//
UINT
DRSet(
       IN RFC1157VarBind *VarBind
)
{
        UINT                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD           Field;
        LPBYTE                pName;
        DWORD                NameLen;
        PWINSINTF_RECORD_ACTION_T        pRow;
        PWINSINTF_RECORD_ACTION_T        pSvRow;
        DWORD                Index;
        DWORD                FieldNo;
        handle_t        BindHdl;
        DWORD                i;
        BOOL                fFound = FALSE;

        //
        // Extract the field that needs to be set
        //
        Field = VarBind->name.ids[DR_OIDLEN];

        switch(Field)
        {
                //
                // Only the state field is settable
                //
                case 5:
                        if ( VarBind->value.asnType != ASN_INTEGER)
                        {
                                return(SNMP_ERRORSTATUS_BADVALUE);
                        }
                        if (
                                (VarBind->value.asnValue.number != WINSINTF_E_RELEASED)
                                        &&
                                (VarBind->value.asnValue.number != WINSINTF_E_DELETED)
                           )
                        {

                                return(SNMP_ERRORSTATUS_BADVALUE);

                        }

                        if (sRecs.NoOfRecs == 0)
                            return (SNMP_ERRORSTATUS_NOSUCHNAME);

                        NameLen = VarBind->name.idLength - (DR_OIDLEN + 1);
                        if ( NULL ==  (pName = SNMP_malloc(NameLen * sizeof(char))) )
                        {
                            return(SNMP_ERRORSTATUS_GENERR);
                        }


                        ErrStat = DRMatch(VarBind,  &pRow, &Index,  &FieldNo, MIB_SET, NULL);

                        if (ErrStat == SNMP_ERRORSTATUS_NOERROR)
                        {
                            fFound = TRUE;
                        }
                        else
                        {
                            LPBYTE      pNameChar = pRow->pName;
                            DWORD       n = DR_OIDLEN + 1;

                            for (i=0; i<NameLen;i++)
                            {
                                *pNameChar = (BYTE)
                                VarBind->name.ids[n++];
                            }
                            pRow->NameLen        = NameLen;
                        }

                        pRow->fStatic = 1;
                        if ( VarBind->value.asnValue.number ==
                                        WINSINTF_E_RELEASED)
                        {
                           pRow->Cmd_e = WINSINTF_E_RELEASE;

                        }
                        else
                        {
                           pRow->Cmd_e = WINSINTF_E_DELETE;

                        }
                        BindHdl = WinsBind(&sBindData);
                        pSvRow  = pRow;
                        if ( WinsRecordAction(BindHdl, &pSvRow) != WINSINTF_SUCCESS)
                        {
                                ErrStat = SNMP_ERRORSTATUS_GENERR;
                                  goto Exit;
                        }
                        WinsFreeMem(pSvRow->pName);
                        WinsFreeMem(pSvRow->pAdd);
                        WinsFreeMem(pSvRow);
                        pRow->State_e = VarBind->value.asnValue.number;

                               break;

                case(1):
                case(2):
                case(3):
                case(4):
                        ErrStat = SNMP_ERRORSTATUS_READONLY;
                        break;

                default:
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        break;

        }

Exit:
        WinsUnbind(&sBindData, BindHdl);
        return(ErrStat);
} //DRSet

UINT
DRGetFirst(
       IN RFC1157VarBind *VarBind,
       IN MIB_ENTRY        *MibPtr,
       IN KEY_TYPE_E        KeyType_e
        )
{

        DWORD           OidIndex;
        UINT           TableEntryIds[NMSDB_MAX_NAM_LEN];
        AsnObjectIdentifier        TableEntryOid = { OID_SIZEOF(TableEntryIds),
                                                        TableEntryIds };
           UINT             ErrStat;
        PTUCHAR          pNameChar;
        PWINSINTF_RECORD_ACTION_T        pRow = (PWINSINTF_RECORD_ACTION_T)sRecs.pRow;
        DWORD        i;

        if (sRecs.NoOfRecs == 0)
        {
           return(GetNextVar(VarBind, MibPtr));
        }

        //
        // Write the object Id into the binding list and call get
        // func
        //
        SNMP_oidfree( &VarBind->name );
        SNMP_oidcpy( &VarBind->name, &MIB_OidPrefix );
        SNMP_oidappend( &VarBind->name, &MibPtr->Oid );

        //
        // The fixed part of the objid is corect. Update the rest.
        //
        //OidIndex = VarBind->name.idLength;

        TableEntryIds[0] = 1;
        OidIndex = 1;
        pNameChar = pRow->pName;
        for (i = 0; i < pRow->NameLen; i++)
        {
              TableEntryIds[OidIndex++] = (UINT)*pNameChar++;
        }
        TableEntryOid.idLength = OidIndex;

        SNMP_oidappend( &VarBind->name, &TableEntryOid );

        ErrStat = DRGet(VarBind, 0, NULL);
        return(ErrStat);
}

UINT
DRMatch(
       IN RFC1157VarBind *VarBind,
       IN PWINSINTF_RECORD_ACTION_T         *ppRow,
       IN LPDWORD         pIndex,
       IN LPDWORD         pField,
       IN UINT                 PduAction,
       OUT LPBOOL         pfFirst
        )
{
        DWORD NameLen;
        BYTE  Name[NMSDB_MAX_NAM_LEN];
        LPBYTE pNameChar = Name;
        DWORD NameIndex = DR_OIDLEN + 1;
        UINT *pTmp = &VarBind->name.ids[NameIndex];
        DWORD i;
        PWINSINTF_RECORD_ACTION_T        pRow = (PWINSINTF_RECORD_ACTION_T)sRecs.pRow;
        UINT        ErrStat = SNMP_ERRORSTATUS_NOERROR;
        INT        CmpVal;

        if (pfFirst != NULL)
        {
                *pfFirst = FALSE;
             }


        NameLen = VarBind->name.idLength - (DR_OIDLEN + 1);
        *pField = VarBind->name.ids[DR_OIDLEN];

        //
        // if a name has been specified, get it into Name array
        //
        if (NameLen > 0)
        {
          for(i=0; i<NameLen; i++)
          {
                *pNameChar++ = (BYTE)*pTmp++;
          }

          //
          // Compare the name with names in the cache (in ascending order)
          //
          for (i=0; i < sRecs.NoOfRecs; i++, pRow++)
          {

                //
                // replace with RtlCompareMemory
                //
                CmpVal = memcmp(Name, pRow->pName, NameLen);

                if (CmpVal == 0)
                {
                          *pIndex = i;
                          *ppRow  = pRow;
                         return(SNMP_ERRORSTATUS_NOERROR);
                }
                else
                {
                        //
                        // Passed in name is lexicographically > than
                        // name being looked at, continue on
                        //
                        if (CmpVal > 0)
                        {
                                continue;
                        }
                        else
                        {
                                //
                                // Passed in name is lexicographically < than
                                // name being looked at, continue on
                                //
                                break;
                        }
                }
          }

          //
          // if the action is not GETNEXT, we return an error, since we
          // did not find a matching name
          //
          if (PduAction != MIB_GETNEXT)
          {
                return(SNMP_ERRORSTATUS_NOSUCHNAME);
          }
          else
          {
                //
                // Either the name is lexicographically > than all names
                // or we reached a name in the list that is lexicographically
                // < it.  In the first case, i needs to be decremented by
                // 1. *ppRow  needs to be initialized to either the last
                // row in the table or to the element before the one we
                // found to be lexicographically greater.
                //
                  *pIndex = i - 1;
                  *ppRow  = --pRow;
                return(SNMP_ERRORSTATUS_NOERROR);
          }

        }
        else  // NameLen == 0
        {
                //
                // The action has got to be GETNEXT (see MIB_DRTable)
                // which means that pfFirst is not NULL
                //
                //--ft: prefix bug #444993
                *pIndex = 0;
                if (pfFirst != NULL)
                    *pfFirst = TRUE;
        }
        return(ErrStat);
}

int
__cdecl
CompareNames(
        const VOID *pKey1,
        const VOID *pKey2
        )
{
        const PWINSINTF_RECORD_ACTION_T        pRow1 = (PWINSINTF_RECORD_ACTION_T)pKey1;
        const PWINSINTF_RECORD_ACTION_T        pRow2 = (PWINSINTF_RECORD_ACTION_T)pKey2;
        ULONG CmpVal;
        DWORD LenToCmp =  min(pRow1->NameLen, pRow2->NameLen);


PERF("replace with RtlCompareMemory")
        CmpVal = memcmp(pRow1->pName, pRow2->pName, LenToCmp);
        if (CmpVal == LenToCmp)
        {
                return(pRow1->NameLen - pRow2->NameLen);
        }
        else
        {
                return(CmpVal);
        }

}

int
__cdecl
CompareIndexes(
        const VOID *pKey1,
        const VOID *pKey2
        )
{
        const PDATAFILE_INFO_T        pRow1 = (PDATAFILE_INFO_T)pKey1;
        const PDATAFILE_INFO_T        pRow2 = (PDATAFILE_INFO_T)pKey2;

PERF("replace with RtlCompareMemory")
        return(strcmp(pRow1->ValNm, pRow2->ValNm));
}

DWORD
PopulateDRCache(
        VOID
        )
{
        DWORD                        RetStat = WINSINTF_SUCCESS;
        WINSINTF_VERS_NO_T        MaxVersNo, MinVersNo;
        handle_t                BindHdl;
        WINSINTF_ADD_T                WinsAdd;
        DWORD                        SvNoOfRecs;
        LPVOID                        pSvRplPnrs;
           LPBYTE                  pStorage;

        WINS_ASSIGN_INT_TO_VERS_NO_M(MaxVersNo, 0);
        WINS_ASSIGN_INT_TO_VERS_NO_M(MinVersNo, 0);
        WinsAdd.Len        = 4;
        WinsAdd.Type        = 0;
        pSvRplPnrs     = sRecs.pRow;
        SvNoOfRecs     = sRecs.NoOfRecs;
        sRecs.pRow     = NULL;
        sRecs.NoOfRecs = 0;
        pStorage = MIB_GetDbRecsStore;
        WinsAdd.IPAdd = ntohl(*(DWORD*)pStorage);
        //NMSMSGF_RETRIEVE_IPADD_M(pStorage, WinsAdd.IPAdd);
        BindHdl = WinsBind(&sBindData);
        RetStat = WinsGetDbRecs(BindHdl, &WinsAdd, MinVersNo, MaxVersNo, &sRecs);
        WinsUnbind(&sBindData, BindHdl);

        if (RetStat == WINSINTF_SUCCESS)
        {
              if (sRecs.NoOfRecs > 1)
              {
                      qsort(
                        (LPVOID)sRecs.pRow,
                        (size_t)sRecs.NoOfRecs,
                        sizeof(WINSINTF_RECORD_ACTION_T),
                        CompareNames
                                );
              }

              if (pSvRplPnrs != NULL)
              {
                WinsFreeMem(pSvRplPnrs);
              }

        }
        else
        {
                sRecs.NoOfRecs = SvNoOfRecs;
                sRecs.pRow     = pSvRplPnrs;
        }
        return(RetStat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\uniname.cxx ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    UNINAME.CXX

Abstract:



Author:

    Dan Lafferty (danl)     24-Apr-1994

Environment:

    User Mode -Win32

Revision History:

    24-Apr-1994     danl
        Created

    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <tstr.h>       // STRLEN

//
// PROTOTYPES
//
DWORD
MprTranslateRemoteName(
    LPREMOTE_NAME_INFOW pRemoteNameInfo,
    LPDWORD             lpBufferSize,
    LPWSTR              pRemoteName,
    LPCWSTR             pRemainingPath
    );


DWORD
WNetGetUniversalNameW (
    IN      LPCTSTR  lpLocalPath,
    IN      DWORD   dwInfoLevel,
    OUT     LPVOID  lpBuffer,
    IN OUT  LPDWORD lpBufferSize
    )

/*++

Routine Description:


Arguments:

    lpLocalPath - This is a pointer to the string that contains the local path.
        This is a path that contains a drive-letter prefixed path string.
        "X:" is a valid local path.  "X:\nt\system32" is a valid local path.
        "\\popcorn\public\nt" is not a valid local path.

    dwInfoLevel - This DWORD indicates what information is to be stored in
        the return buffer.  Currently the following levels are supported:
        INFOLEVEL_UNIVERSAL_NAME
        INFOLEVEL_REMOTE_NAME

    lpBuffer - This is a pointer to the buffer where the requested information
        is to be placed.

    lpBufferSize - This is a pointer to the size of the buffer in bytes.
        If the buffer is not large enough, then the required buffer size
        Will be placed in this location upon return with WN_MORE_DATA.

Return Value:


--*/
{
    DWORD       status = WN_SUCCESS;
    LPDWORD     indexArray;
    DWORD       localArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders;
    LPPROVIDER  provider;
    DWORD       statusFlag = 0; // used to indicate major error types
    BOOL        fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD       i;
    WCHAR       pDriveLetter[4];
    LPWSTR      pRemoteName = (LPWSTR)((LPBYTE)lpBuffer + sizeof(REMOTE_NAME_INFOW));

    //
    // Validate the drive portion of the local path. Make sure its a valid
    // device.
    //
    __try {
        pDriveLetter[0] = lpLocalPath[0];
        pDriveLetter[1] = lpLocalPath[1];
        pDriveLetter[2] = L'\0';
        if (MprDeviceType(pDriveLetter) != REDIR_DEVICE) {
            status = WN_BAD_LOCALNAME;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetGetUniversalNameW:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS) {
        SetLastError(status);
        return(status);
    }

    if ((dwInfoLevel != UNIVERSAL_NAME_INFO_LEVEL) &&
        (dwInfoLevel != REMOTE_NAME_INFO_LEVEL)) {
        SetLastError(ERROR_INVALID_LEVEL);
        return(ERROR_INVALID_LEVEL);
    }

    MprCheckProviders();

    CProviderSharedLock    PLock;

    //
    // Check to see if this is a remote drive to begin with. If not, we can
    // fail it quickly.
    //
    pDriveLetter[2] = L'\\';
    pDriveLetter[3] = L'\0';
    if (GetDriveType(pDriveLetter) != DRIVE_REMOTE) {
        status = WN_NOT_CONNECTED;
    }
    pDriveLetter[2] = L'\0';

    if (status == WN_SUCCESS) {

        INIT_IF_NECESSARY(NETWORK_LEVEL,status);

        //
        // Find the list of providers to call for this request.
        //
        indexArray = localArray;

        status = MprFindCallOrder(
                    NULL,
                    &indexArray,
                    &numProviders,
                    NETWORK_TYPE);

        if (status != WN_SUCCESS) {
            SetLastError(status);
            return(status);
        }

        //
        // Loop through the list of providers until one answers the request,
        // or the list is exhausted.
        //
        for (i=0; i<numProviders; i++) {

            //
            // Call the appropriate providers API entry point
            // If the provider doesn't support GetUniversalName
            // then see if that provider owns the connection by
            // calling GetConnection.
            //
            provider = GlobalProviderInfo + indexArray[i];

            if (provider->GetUniversalName != NULL) {

                //--------------------------------------
                // Call Provider with GetUniversalName
                //--------------------------------------

                fcnSupported = TRUE;

                __try {

                    status = provider->GetUniversalName(
                                lpLocalPath,
                                dwInfoLevel,
                                lpBuffer,
                                lpBufferSize);
                }

                __except(EXCEPTION_EXECUTE_HANDLER) {
                    status = GetExceptionCode();
                    if (status != EXCEPTION_ACCESS_VIOLATION) {
                        MPR_LOG(ERROR,"WNetGetUniversalNameW:Unexpected Exception 0x%lx\n",status);
                    }
                    status = WN_BAD_POINTER;
                }
            }

            //
            // Try GetConnection for a Remote name.  Note that we
            // don't do this for a Universal name since providers
            // are not required to support it (i.e., the name in
            // the registry might not be universal).
            //
            else if ((dwInfoLevel == REMOTE_NAME_INFO_LEVEL) &&
                     (provider->GetConnection != NULL)) {

                //--------------------------------------
                // Call Provider with GetConnection
                //--------------------------------------
                DWORD   buflen = 0;

                __try {

                    if (*lpBufferSize > sizeof(REMOTE_NAME_INFOW)) {
                        //
                        // Remember, GetConnection is looking for the size of the
                        // buffer in characters - not bytes.
                        //
                        buflen = ((*lpBufferSize) - sizeof(REMOTE_NAME_INFOW))/sizeof(WCHAR);
                    }

                    status = provider->GetConnection(
                                pDriveLetter,
                                pRemoteName,
                                &buflen
                                );

                    if (status == WN_SUCCESS) {

                        //
                        // We got the RemoteName.  See if there's enough room
                        // in the buffer for the portion of the local path that
                        // follows the drive letter and colon.  If there's
                        // enough room, then store the remaining path in the
                        // buffer and fill in the structure.
                        //
                        status = MprTranslateRemoteName(
                                    (LPREMOTE_NAME_INFOW)lpBuffer,
                                    lpBufferSize,
                                    pRemoteName,
                                    &(lpLocalPath[2]));

                        fcnSupported = TRUE;

                    }
                    else if (status == WN_MORE_DATA) {
                        //
                        // The buflen we get back from GetConnection will account
                        // for the RemoteName portion, but not the remaining path
                        // portion.  So we have to add that to the size calculation.
                        //
                        *lpBufferSize = sizeof(REMOTE_NAME_INFOW) +
                                        (WCSSIZE(&(lpLocalPath[2])))    +
                                        (buflen * sizeof(WCHAR));

                        fcnSupported = TRUE;
                    }
                }

                __except(EXCEPTION_EXECUTE_HANDLER) {
                    status = GetExceptionCode();
                    if (status != EXCEPTION_ACCESS_VIOLATION) {
                        MPR_LOG(ERROR,"WNetGetUniversalNameW:Unexpected Exception 0x%lx\n",status);
                    }
                    status = WN_BAD_POINTER;
                }
            }
            else {
                //----------------------------------
                // NEITHER FUNCTION IS SUPPORTED!
                // Go to the next provider.
                //----------------------------------
                continue;
            }

            if (status == WN_NO_NETWORK) {
                statusFlag |= NO_NET;
            }
            else if ((status == WN_NOT_CONNECTED)  ||
                     (status == WN_BAD_LOCALNAME)){
                //
                // WN_NOT_CONNECTED means that lpLocalPath is not a
                // redirected device for this provider.
                //
                statusFlag |= BAD_NAME;
            }
            else {
                //
                // If it wasn't one of those errors, then the provider
                // must have accepted responsiblity for the request.
                // so we exit and process the results.  Note that the
                // statusFlag is cleared because we want to ignore other
                // error information that we gathered up until now.
                //
                statusFlag = 0;
                break;
            }

        } // End for each provider.

        if (fcnSupported == FALSE) {
            //
            // No providers in the list support the API function.  Therefore,
            // we assume that no networks are installed.
            //
            status = WN_NOT_SUPPORTED;
        }

        //
        // If memory was allocated by MprFindCallOrder, free it.
        //
        if (indexArray != localArray) {
            LocalFree(indexArray);
        }

        //
        // Handle special errors.
        //
        if (statusFlag == (NO_NET | BAD_NAME)) {
            //
            // Check to see if there was a mix of special errors that occured.
            // If so, pass back the combined error message.  Otherwise, let the
            // last error returned get passed back.
            //
            status = WN_NO_NET_OR_BAD_PATH;
        }
    }

    //
    // Handle normal errors passed back from the provider
    //
    // NOTE: INIT_IF_NECESSARY may not have been executed by this point.
    // Use caution when modifying code below.  For example, this affects
    // the behavior of MprGetRemoteName.
    //
    if (status != WN_SUCCESS)
    {
        if (status == WN_NOT_CONNECTED
             &&
            dwInfoLevel == REMOTE_NAME_INFO_LEVEL)
        {
            DWORD   bufSize;

            //
            // If not connected, but there is an entry for the LocalName
            // in the registry, then return the remote name that was stored
            // with it.  Note that we don't do this for a Universal name
            // since providers are not required to support it (i.e., the
            // name in the registry might not be universal).
            //
            bufSize = *lpBufferSize - sizeof(REMOTE_NAME_INFOW);

            if (MprGetRemoteName(
                    pDriveLetter,
                    &bufSize,
                    pRemoteName,
                    &status)) {

                if (status == WN_SUCCESS)
                {
                    status = MprTranslateRemoteName(
                                (LPREMOTE_NAME_INFOW)lpBuffer,
                                lpBufferSize,
                                pRemoteName,
                                &(lpLocalPath[2]));

                    if (status == WN_SUCCESS)
                    {
                        status = WN_CONNECTION_CLOSED;
                    }
                }
            }
        }

        SetLastError(status);
    }

    return(status);
}

DWORD
MprTranslateRemoteName(
    LPREMOTE_NAME_INFOW pRemoteNameInfo,
    LPDWORD             lpBufferSize,
    LPWSTR              pRemoteName,
    LPCWSTR             pRemainingPath
    )

/*++

Routine Description:

    This function adds the remaining path string to the buffer and places
    the pointer to it into the structure.


Arguments:

    pRemoteNameInfo - Pointer to a buffer which will contain the
        REMOTE_NAME_INFO structure followed by the strings pointed
        to in the structure.

    lpBufferSize - Pointer to a DWORD that indicates the size of the
        pRemoteNameInfo buffer.

    pRemoteName - Pointer to the location in the pRemoteNameInfo buffer
        where the remote name string can be placed.

    pRemainingPath - Pointer to the remaining path string.


Return Value:

    WN_MORE_DATA - If the buffer was not large enough to hold all the data.
        When this is returned, the required buffer size is stored at the
        location pointed to by lpBufferSize.

    WN_SUCCESS - If the operation was completely successful.

Note:


--*/
{
    DWORD               bufSize = *lpBufferSize - sizeof(REMOTE_NAME_INFOW);
    DWORD               remoteNameLen;
    DWORD               remainingPathLen;
    DWORD               sizeRequired;

    //
    // We got the RemoteName.  See if there's enough room
    // in the buffer for the portion of the local path that
    // follows the drive letter and colon.  If there's
    // enough room, then store the remaining path in the
    // buffer and fill in the structure.
    //
    remoteNameLen = wcslen(pRemoteName);
    remainingPathLen = wcslen(pRemainingPath);

    sizeRequired = sizeof(REMOTE_NAME_INFOW) +
                   ((remoteNameLen + remainingPathLen + 2) *
                   sizeof(WCHAR));

    if (*lpBufferSize < sizeRequired) {
        *lpBufferSize = sizeRequired;
        return(WN_MORE_DATA);
    }
    else {
        pRemoteNameInfo->lpUniversalName  = NULL;
        pRemoteNameInfo->lpConnectionName = pRemoteName;
        pRemoteNameInfo->lpRemainingPath  = pRemoteName+remoteNameLen+sizeof(WCHAR);
        wcscpy(pRemoteNameInfo->lpRemainingPath, pRemainingPath);
    }
    return(WN_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\userdir.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    userdir.cxx

Abstract:

    This file contains the API entry points for the following functions:

        WNetGetUserW
        WNetGetDirectoryTypeW
        WNetDirectoryNotifyW
        WNetGetHomeDirectoryW

Author:

    Dan Lafferty (danl) 17-Oct-1991

Environment:

    User Mode - Win32

Revision History:

    05-May-1999     jschwart
        Make provider addition/removal dynamic

    12-Jul-1995 anirudhs
        Add WNetGetHomeDirectory.

    17-Jun-1994 danl
        WNetGetDirectoryTypeW:  Cache the drive letter and provider index
        to make file manager faster.

    27-May-1994 danl
        WNetGetDirectoryTypeW & WNetDirectoryNotifyW:  If no provider
        claims the connection in question, then we try all providers.
        The actual rule is that we need to pass it to the lanman
        provider anyway (so it can check for a share).  But to play
        completely fair, we'll pass it to everyone.

    28-Aug-1992 danl
        When GetUsername returns the name, it didn't handle the case where
        the buffer was too small.  (This may have been a bug in GetUserName).
        Now this code copies it into a temp buffer (MAX_PATH) and determines
        the size.

    03-Aug-1992 danl
        WNetGetUser now calls GetUsername when the device name parameter
        is NULL.

    17-Oct-1991 danl
        Created


--*/
//
// INCLUDES
//

#include "precomp.hxx"
#include <tstring.h>    // STRCPY

//
// DEFINES
//



DWORD
WNetGetUserW (
    IN      LPCWSTR  lpName,
    OUT     LPWSTR   lpUserName,
    IN OUT  LPDWORD  lpBufferSize
    )

/*++

Routine Description:

    Returns the user name that is associated with making a particular
    connection.  If no connection is specified, the current username
    for the process is returned.

Arguments:

    lpName - This is a pointer to a device name string.  If NULL, the
        username for the current user of this process is returned.

    lpUserName - This is a pointer to the buffer that will receive the
        username string.

    lpBufferSize - This is the size (in characters) of the buffer that
        will receive the username.

Return Value:


Note:


--*/
{
    DWORD       status = WN_SUCCESS;
    DWORD       indexArray[DEFAULT_MAX_PROVIDERS];
    LPDWORD     index = indexArray;
    DWORD       numProviders;
    DWORD       statusFlag = 0;       // used to indicate major error types
    BOOL        fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD       i;
    WCHAR       pDriveLetter[4];
    UINT        uDriveType;
    DWORD       providerIndex;    // ignored

    //
    // If the device or network name is NULL then we 
    // will return the name of the current user.
    //
    __try
    {
        if (IS_EMPTY_STRING(lpName)) {

            //
            // GetUserName modifies *lpBufferSize on success -- we don't
            //
            DWORD dwTempSize = *lpBufferSize;

            lpName = NULL;

            if (!GetUserName(lpUserName, &dwTempSize))
            {
                status = GetLastError();
                MPR_LOG(ERROR,"WNetGetUserW: GetUserName Failed %d\n",status);
                if (status == ERROR_INSUFFICIENT_BUFFER)
                {
                    *lpBufferSize = dwTempSize;
                    status = WN_MORE_DATA;
                }
            }
        }
        else {

            //
            // As long as we're already in a try-except block,
            // try setting up the check to see if lpName is
            // a local drive.
            //
            pDriveLetter[0] = lpName[0];
            pDriveLetter[1] = lpName[1];
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetGetUser:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (lpName == NULL || status != WN_SUCCESS) {
        goto CleanExit;
    }

    pDriveLetter[2] = L'\\';
    pDriveLetter[3] = L'\0';

    uDriveType = GetDriveType(pDriveLetter);

    //
    // Eliminate all cases of drives that aren't connected to
    // a network resource.  Note that network provider names
    // and UNC shares return DRIVE_NO_ROOT_DIR, so we need to
    // make sure it's a valid drive name in that case.
    //
    if (uDriveType == DRIVE_REMOVABLE ||
        uDriveType == DRIVE_FIXED     ||
        uDriveType == DRIVE_CDROM     ||
        uDriveType == DRIVE_RAMDISK   ||
        (uDriveType == DRIVE_NO_ROOT_DIR && pDriveLetter[1] == L':'))

    {
        status = WN_NOT_CONNECTED;
        goto CleanExit;
    }

    {
        MprCheckProviders();

        CProviderSharedLock    PLock;

        //
        // If the device or network name is the name of a network
        // provider, then we will return the name of the current user.
        // Only a Level 1 init is needed for MprGetProviderIndex
        //
        if (!(GlobalInitLevel & FIRST_LEVEL)) {
            status = MprLevel1Init();
            if (status != WN_SUCCESS) {
                return(status);
            }
        }

        if (MprGetProviderIndex(lpName, &providerIndex))
        {
            lpName = NULL;

            if (!GetUserName(lpUserName, lpBufferSize))
            {
                status = GetLastError();
                MPR_LOG(ERROR,"WNetGetUserW: GetUserName Failed %d\n",status);
                if (status == ERROR_INSUFFICIENT_BUFFER)
                {
                    status = WN_MORE_DATA;
                }
            }
        }

        if (lpName == NULL || status != WN_SUCCESS) {
            goto CleanExit;
        }

        //
        // Find the list of providers to call for this request.
        // If there are no active providers, MprFindCallOrder returns
        // WN_NO_NETWORK.
        //
        INIT_IF_NECESSARY(NETWORK_LEVEL,status);

        status = MprFindCallOrder(
                    NULL,
                    &index,
                    &numProviders,
                    NETWORK_TYPE);

        if (status != WN_SUCCESS) {
            goto CleanExit;
        }

        //
        // if none of them are started, return error
        //
        if (!MprNetIsAvailable())
        {
            status = WN_NO_NETWORK;
            goto CleanExit;
        }

        //
        // Loop through the list of providers until one answers the request,
        // or the list is exhausted.
        //
        for (i=0; i<numProviders; i++) {

            //
            // Call the appropriate providers API entry point
            //
            LPPROVIDER provider = &GlobalProviderInfo[ index[i] ];

            if (provider->GetUser != NULL) {

                fcnSupported = TRUE;

                __try {
                    status = provider->GetUser(
                                (LPWSTR) lpName,
                                lpUserName,
                                lpBufferSize);
                }
                __except(EXCEPTION_EXECUTE_HANDLER) {
                    status = GetExceptionCode();
                    if (status != EXCEPTION_ACCESS_VIOLATION) {
                        MPR_LOG(ERROR,"WNetGetUser:Unexpected Exception 0x%lx\n",status);
                    }
                    status = WN_BAD_POINTER;
                }

                //
                // WN_CONNECTED_OTHER_PASSWORD_DEFAULT will be returned when user X mapped a
                // drive as user Y and the credentials for user Y were stored in CredMan when
                // the connection was made.  Since the username is correctly filled in with
                // user Y in this case, simply massage the return code to success.
                //

                if (status == WN_CONNECTED_OTHER_PASSWORD_DEFAULT)
                {
                    status = WN_SUCCESS;
                }

                if (status == WN_NO_NETWORK) {
                    statusFlag |= NO_NET;
                }
                else if ((status == WN_NOT_CONNECTED)  ||
                         (status == WN_BAD_LOCALNAME)){

                    statusFlag |= BAD_NAME;
                }
                else {
                    //
                    // If it wasn't one of those errors, then the provider
                    // must have accepted responsibility for the request.
                    // so we exit and process the results.  Note that the
                    // statusFlag is cleared because we want to ignore other
                    // error information that we gathered up until now.
                    //
                    statusFlag = 0;
                    break;
                }
            }
        }
    }

    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // Handle special errors.
    //
    if (statusFlag == (NO_NET | BAD_NAME)) {
        //
        // Check to see if there was a mix of special errors that occured.
        // If so, pass back the combined error message.  Otherwise, let the
        // last error returned get passed back.
        //
        status = WN_NO_NET_OR_BAD_PATH;
    }

CleanExit:
    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (index != indexArray) {
        LocalFree(index);
    }

    if (status != WN_SUCCESS){
        SetLastError(status);
    }

    return(status);
}


DWORD
WNetGetDirectoryTypeW (
    IN  LPTSTR  lpName,
    OUT LPINT   lpType,
    IN  BOOL    bFlushCache
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD       status = WN_SUCCESS;
    LPDWORD     index;
    DWORD       indexArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders = 0;
    DWORD       providerIndex;
    DWORD       statusFlag = 0; // used to indicate major error types
    WCHAR       lpDriveName[4];
    UINT        uDriveType;

    index = indexArray;

    //
    // Probe the drive letter portion of the lpName.
    //
    __try {

        lpDriveName[0] = lpName[0];
        lpDriveName[1] = lpName[1];
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetGetDirectoryType:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS) {
        return(status);
    }

    lpDriveName[2] = L'\\';
    lpDriveName[3] = L'\0';

    uDriveType = GetDriveType(lpDriveName);

    if (uDriveType == DRIVE_REMOVABLE ||
        uDriveType == DRIVE_FIXED     ||
        uDriveType == DRIVE_CDROM     ||
        uDriveType == DRIVE_RAMDISK)
    {
        *lpType = 0;        // 0 means a non-network drive
        return WN_SUCCESS;
    }

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    //
    // Find the Provider Index associated with the drive letter in
    // the pathname (lpszName).
    // NOTE:  This function handles exceptions.
    //

    status = MprFindProviderForPath(lpName, &providerIndex);
    if (status != WN_SUCCESS) {
        MPR_LOG1(ERROR,"WNetGetDirectoryType: Couldn't find provider for this "
            "path.  Error = %d\n",status);

        //
        // Find the list of providers to call for this request.
        // Since no provider claimed this path, then
        // we need to at least try the lanman provider.
        // Actually we'll give them all a chance.
        //

        status = MprFindCallOrder(
                    NULL,
                    &index,
                    &numProviders,
                    NETWORK_TYPE);

        if (status != WN_SUCCESS) {
            return(status);
        }
    }
    else {
        numProviders = 1;
        index[0] = providerIndex;
    }

    //
    // Loop through the list of providers until one answers the request,
    // or the list is exhausted.
    //
    BOOL    fcnSupported = FALSE; // Is fcn supported by a provider?
    for (DWORD i=0; i<numProviders; i++) {
        //
        // Call the appropriate provider's API entry point
        //
        LPPROVIDER provider = &GlobalProviderInfo[ index[i] ];

        if (provider->GetDirectoryType != NULL) {

            fcnSupported = TRUE;

            __try {
                status = provider->GetDirectoryType(
                            lpName,
                            lpType,
                            bFlushCache) ;
            }

            __except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
                if (status != EXCEPTION_ACCESS_VIOLATION) {
                    MPR_LOG(ERROR,"WNetGetDirectoryType:Unexpected Exception 0x%lx\n",status);
                }
                status = WN_BAD_POINTER;
            }
            if (status == WN_NO_NETWORK) {
                statusFlag |= NO_NET;
            }
            else if ((status == WN_NOT_CONNECTED)  ||
                     (status == WN_BAD_LOCALNAME)){

                statusFlag |= BAD_NAME;
            }
            else {
                //
                // If it wasn't one of those errors, then the provider
                // must have accepted responsibility for the request.
                // so we exit and process the results.  Note that the
                // statusFlag is cleared because we want to ignore other
                // error information that we gathered up until now.
                //
                statusFlag = 0;
                break;
            }
        }
    }
    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (index != indexArray) {
        LocalFree(index);
    }

    //
    // Handle special errors.
    //
    if (statusFlag == (NO_NET | BAD_NAME)) {
        //
        // Check to see if there was a mix of special errors that occured.
        // If so, pass back the combined error message.  Otherwise, let the
        // last error returned get passed back.
        //
        status = WN_NO_NET_OR_BAD_PATH;
    }

    if (status != WN_SUCCESS){
        SetLastError(status);
    }

    return(status);
}


DWORD
WNetDirectoryNotifyW (
    IN  HWND    hwnd,
    IN  LPTSTR  lpDir,
    IN  DWORD   dwOper
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD       providerIndex;
    DWORD       status;
    LPDWORD     index;
    DWORD       indexArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders;
    LPPROVIDER  provider;
    DWORD       statusFlag = 0; // used to indicate major error types
    BOOL        fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD       i;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    index = indexArray;

    //
    // Find the Provider Index associated with the drive letter in
    // the pathname (lpszName).
    // NOTE:  This function handles exceptions.
    //
    status = MprFindProviderForPath(lpDir, &providerIndex);
    if (status != WN_SUCCESS) {
        MPR_LOG1(TRACE,"WNetDirectoryNotify: Couldn't find provider for this "
            "path.  Error = %d\n",status);

        //
        // Find the list of providers to call for this request.
        // Since no provider claimed this path, then
        // we need to at least try the lanman provider.
        // Actually we'll give them all a chance.
        //

        status = MprFindCallOrder(
                    NULL,
                    &index,
                    &numProviders,
                    NETWORK_TYPE);

        if (status != WN_SUCCESS) {
            MPR_LOG(ERROR,"WNetDirectoryNotifyW: FindCallOrder Failed\n",0);
            return(status);
        }
    }
    else {
        numProviders = 1;
        index[0] = providerIndex;
    }

    //
    // Loop through the list of providers until one answers the request,
    // or the list is exhausted.
    //
    for (i=0; i<numProviders; i++) {
        //
        // Call the appropriate provider's API entry point
        //
        provider = GlobalProviderInfo + index[i];

        if (provider->DirectoryNotify != NULL) {

            fcnSupported = TRUE;

            __try {
                status = provider->DirectoryNotify(
                            hwnd,
                            lpDir,
                            dwOper);
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
                if (status != EXCEPTION_ACCESS_VIOLATION) {
                    MPR_LOG(ERROR,"WNetDirectoryNotify:Unexpected Exception 0x%lx\n",status);
                }
                status = WN_BAD_POINTER;
            }
            if (status == WN_NO_NETWORK) {
                statusFlag |= NO_NET;
            }
            else if ((status == WN_NOT_CONNECTED)  ||
                     (status == WN_BAD_LOCALNAME)){

                statusFlag |= BAD_NAME;
            }
            else {
                //
                // If it wasn't one of those errors, then the provider
                // must have accepted responsibility for the request.
                // so we exit and process the results.  Note that the
                // statusFlag is cleared because we want to ignore other
                // error information that we gathered up until now.
                //
                statusFlag = 0;
                break;
            }
        }
    }
    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (index != indexArray) {
        LocalFree(index);
    }

    //
    // Handle special errors.
    //
    if (statusFlag == (NO_NET | BAD_NAME)) {
        //
        // Check to see if there was a mix of special errors that occured.
        // If so, pass back the combined error message.  Otherwise, let the
        // last error returned get passed back.
        //
        status = WN_NO_NET_OR_BAD_PATH;
    }

    //
    // Handle normal errors passed back from the provider
    //
    if (status != WN_SUCCESS){
        MPR_LOG(TRACE,"WNetDirectoryNotifyW: Call Failed %d\n",status);
        SetLastError(status);
    }

    return(status);
}


DWORD
WNetGetHomeDirectoryW (
    IN      LPCWSTR  lpProviderName,
    OUT     LPWSTR   lpDirectory,
    IN OUT  LPDWORD  lpBufferSize
    )

/*++

Routine Description:

    Returns the user's home directory.

Arguments:

    lpProviderName - Specifies the name of the network provider for which the
        home directory is retrieved.  This parameter exists for Win95 compati-
        bility, and is ignored.

    lpDirectory - Buffer in which to return the directory path.  This will be
        in either UNC or drive-relative form.

    lpBufferSize - Specifies the size of the lpDirectory buffer, in characters.
        If the call fails because the buffer is not big enough, this will be
        set to the required buffer size.

Return Value:

    WN_SUCCESS - successful

    WN_MORE_DATA - buffer not large enough

    WN_NOT_SUPPORTED - user doesn't have a home directory

Note:

    This is an unpublished function, so it doesn't catch exceptions.

    The path is obtained from environment variables and equals
        %HOMESHARE%%HOMEPATH% if the %HOMESHARE% variable is set, else
        %HOMEDIR%%HOMEPATH% .

--*/
{
    //
    // If HOMESHARE is set, use it in preference to HOMEDRIVE
    //
    LPWSTR  ExpandString = L"%HOMEDRIVE%%HOMEPATH%";
    if (GetEnvironmentVariable(L"HOMESHARE", NULL, 0))
    {
        ExpandString = L"%HOMESHARE%%HOMEPATH%";
    }

    //
    // Expand the environment variables into the buffer
    //
    DWORD cchReturned = ExpandEnvironmentStrings(
                                ExpandString,
                                lpDirectory,
                                *lpBufferSize
                                );

    if (cchReturned == 0)
    {
        // ExpandEnvironmentStrings failed
        return GetLastError();
    }

    if (cchReturned > *lpBufferSize)
    {
        // Buffer too small; cchReturned is the required size
        *lpBufferSize = cchReturned;
        return WN_MORE_DATA;
    }

    //
    // Fail if HOMEDRIVE or HOMEPATH is not set - detected by the result
    // string beginning with %HOMEDRIVE% or ending with %HOMEPATH%
    //
    if (wcsncmp(lpDirectory, L"%HOMEPATH%", sizeof("%HOMEPATH%") - 1) == 0 ||
        (cchReturned > sizeof("%HOMEPATH%") &&
         wcscmp(&lpDirectory[cchReturned-sizeof("%HOMEPATH%")], L"%HOMEPATH%") == 0))
    {
        return WN_NOT_SUPPORTED;
    }

    return WN_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\mib\util.h ===
//
//  Copyright (c) 1991  Microsoft Corporation
//

#ifndef util_h
#define util_h

//-------------------------- MODULE DESCRIPTION ----------------------------
//
//  util.h
//
//---------------------------------------------------------------------------
//
//  Declarations, constants, and prototypes for SNMP utility functions.
//
//---------------------------------------------------------------------------

//--------------------------- VERSION INFO ----------------------------------

static char *util__h = "@(#) $Logfile:   N:/agent/common/vcs/util.h_v  $ $Revision:   1.5  $";

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define SNMP_MAX_OID_LEN     0x7f00 // Max number of elements in obj id


//--------------------------- PUBLIC STRUCTS --------------------------------

#include <winsock.h>

typedef SOCKET SockDesc;


//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

//--------------------------- PUBLIC PROTOTYPES -----------------------------

//
// Debugging functions
//

#define DBGCONSOLEBASEDLOG   0x1
#define DBGFILEBASEDLOG      0x2
#define DBGEVENTLOGBASEDLOG  0x4

VOID dbgprintf(
        IN INT nLevel,
        IN LPSTR szFormat,
        IN ...
        );

//
// Internal OID routines
//

void SNMP_oiddisp(
        IN AsnObjectIdentifier *Oid // OID to display
	);

//
// Buffer manipulation
//

void SNMP_bufrev(
        IN OUT BYTE *szStr, // Buffer to reverse
	IN UINT nLen        // Length of buffer
	);

void SNMP_bufcpyrev(
        OUT BYTE *szDest,  // Destination buffer
	IN BYTE *szSource, // Source buffer
	IN UINT nLen       // Length of buffers
	);

//------------------------------- END ---------------------------------------

#endif /* util_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\tstring.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tstring.h

Abstract:

    This include file contains manifests and macros to be used to integrate
    the TCHAR and LPTSTR definitions

    Note that our naming convention is that a "size" indicates a number of
    bytes whereas a "length" indicates a number of characters.

Author:

    Richard Firth (rfirth) 02-Apr-1991

Environment:

    Portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    22-May-1991 Danl
        Added STRSIZE macro
    19-May-1991 JohnRo
        Changed some parm names to make things easier to read.
    15-May-1991 rfirth
        Added TCHAR_SPACE and MAKE_TCHAR() macro
    15-Jul-1991 RFirth
        Added STRING_SPACE_REQD() and DOWN_LEVEL_STRSIZE
    05-Aug-1991 JohnRo
        Added MEMCPY macro.
    19-Aug-1991 JohnRo
        Added character type stuff: ISDIGIT(), TOUPPER(), etc.
    20-Aug-1991 JohnRo
        Changed strnicmp to _strnicmp to keep PC-LINT happy.  Ditto stricmp.
    13-Sep-1991 JohnRo
        Need UNICODE STRSIZE() too.
    13-Sep-1991 JohnRo
        Added UNICODE STRCMP() and various others.
    07-May-1992 beng
        Use official wchar.h header file

--*/

#ifndef _TSTRING_H_INCLUDED
#define _TSTRING_H_INCLUDED

#include <ctype.h>              // isdigit(), iswdigit() eventually, etc.


#ifdef LM20_COMPATIBLE
#define MAKE_STR_FUNCTION(s)    s##f
#else
#define MAKE_STR_FUNCTION(s)    s
#endif


#if defined(UNICODE)

#include <wchar.h>              // wcslen(), etc.

//
// function macro prototypes
//

#define ISALNUM(tchar)      iswalnum(tchar)   // locale-dependent.
#define ISALPHA(tchar)      iswalpha(tchar)   // locale-dependent.
#define ISCNTRL(tchar)      iswcntrl(tchar)   // locale-dependent.
#define ISDIGIT(tchar)      iswdigit(tchar)
#define ISGRAPH(tchar)      iswgraph(tchar)   // locale-dependent.
#define ISLOWER(tchar)      iswlower(tchar)   // locale-dependent.
#define ISPRINT(tchar)      iswprint(tchar)   // locale-dependent.
#define ISPUNCT(tchar)      iswpunct(tchar)   // locale-dependent.
#define ISSPACE(tchar)      iswspace(tchar)   // locale-dependent.
#define ISUPPER(tchar)      iswupper(tchar)   // locale-dependent.
#define ISXDIGIT(tchar)     iswxdigit(tchar)

#define STRCAT(dest, src)   wcscat((dest), (src))
#define STRCHR(s1, c)       (LPTSTR)MAKE_STR_FUNCTION(wcschr)((s1), (c))
#define STRCPY(dest, src)   wcscpy((dest), (src))
#define STRCSPN(s, c)       (DWORD)MAKE_STR_FUNCTION(wcscspn)((s), (c))
// STRLEN: Get character count of s.
#define STRLEN(s)           wcslen(s)
#define STRNCAT(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(wcsncat)((dest), (src), (n))
#define STRNCPY(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(wcsncpy)((dest), (src), (n))
#define STRSPN(s1, s2)      (DWORD)MAKE_STR_FUNCTION(wcsspn)((s1), (s2))
#define STRRCHR             (LPTSTR)MAKE_STR_FUNCTION(wcsrchr)
#define STRTAIL(s1, s2)     (LPTSTR)MAKE_STR_FUNCTION(wcstail)((s1), (s2))
#define STRUPR(s)           (LPTSTR)MAKE_STR_FUNCTION(wcsupr)(s)

// these don't have formal parameters because we want to take the address of
// the mapped function in certain cases.  Modify as appropriate.
// Note that for these functions, lengths are in characters.

// compare functions: len is maximum number of characters being compared.
#define STRCMP              wcscmp
#define STRICMP             (LONG)MAKE_STR_FUNCTION(_wcsicmp)
#define STRNCMP             (LONG)MAKE_STR_FUNCTION(wcsncmp)
#define STRNICMP            (LONG)MAKE_STR_FUNCTION(_wcsnicmp)

#define TOLOWER(tchar)      towlower(tchar)   // locale-dependent.
#define TOUPPER(tchar)      towupper(tchar)   // locale-dependent.

//
// manifests
//

#define _CHAR_TYPE  WCHAR

#else   // not UNICODE

#include <string.h>             // strlen(), etc.

//
// function macro prototypes
//

#define ISALNUM(tchar)      isalnum(tchar)   // locale-dependent.
#define ISALPHA(tchar)      isalpha(tchar)   // locale-dependent.
#define ISCNTRL(tchar)      iscntrl(tchar)   // locale-dependent.
#define ISDIGIT(tchar)      isdigit(tchar)
#define ISGRAPH(tchar)      isgraph(tchar)   // locale-dependent.
#define ISLOWER(tchar)      islower(tchar)   // locale-dependent.
#define ISPRINT(tchar)      isprint(tchar)   // locale-dependent.
#define ISPUNCT(tchar)      ispunct(tchar)   // locale-dependent.
#define ISSPACE(tchar)      isspace(tchar)   // locale-dependent.
#define ISUPPER(tchar)      isupper(tchar)   // locale-dependent.
#define ISXDIGIT(tchar)     isxdigit(tchar)

#define STRCAT(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(strcat)((dest), (src))
#define STRNCAT(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(strncat)((dest), (src), (n))
// STRLEN: Get character count of s.
#define STRLEN(s)           (DWORD)MAKE_STR_FUNCTION(strlen)(s)
#define STRSPN(s1, s2)      (DWORD)MAKE_STR_FUNCTION(strspn)((s1), (s2))
#define STRCSPN(s, c)       (DWORD)MAKE_STR_FUNCTION(strcspn)((s), (c))
#define STRCPY(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(strcpy)((dest), (src))
#define STRNCPY(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(strncpy)((dest), (src), (n))
#define STRCHR(s1, c)       (LPTSTR)MAKE_STR_FUNCTION(strchr)((s1), (c))
#define STRRCHR             (LPTSTR)MAKE_STR_FUNCTION(strrchr)
#define STRTAIL(s1, s2)     (LPTSTR)MAKE_STR_FUNCTION(strtail)((s1), (s2))
#define STRUPR(s)           (LPTSTR)MAKE_STR_FUNCTION(strupr)(s)

// these don't have formal parameters because we want to take the address of
// the mapped function in certain cases.  Modify as appropriate.
// Note that for these functions, lengths are in characters.

// compare functions: len is maximum number of characters being compared.
#define STRCMP              (LONG)MAKE_STR_FUNCTION(strcmp)
#define STRICMP             (LONG)MAKE_STR_FUNCTION(_stricmp)
#define STRNCMP             (LONG)MAKE_STR_FUNCTION(strncmp)
#define STRNICMP            (LONG)MAKE_STR_FUNCTION(_strnicmp)

#define TOLOWER(tchar)      tolower(tchar)   // locale-dependent.
#define TOUPPER(tchar)      toupper(tchar)   // locale-dependent.

//
// manifests
//

#define _CHAR_TYPE  TCHAR

#endif // not UNICODE


//
// For the memory routines, the counts are always BYTE counts.
//
#define MEMCPY                  memcpy
#define MEMMOVE                 memmove

//
// This is used to determine the number of bytes (including the NUL
// terminator) in a unicode string.  This will generally be used when
// calculating the size of a string for allocation purposes.
//

#define STRSIZE(p)              ((STRLEN(p)+1) * sizeof(TCHAR))


//
// character literals (both types)
//

#define TCHAR_EOS       ((_CHAR_TYPE)'\0')
#define TCHAR_STAR      ((_CHAR_TYPE)'*')
#define TCHAR_BACKSLASH ((_CHAR_TYPE)'\\')
#define TCHAR_FWDSLASH  ((_CHAR_TYPE)'/')
#define TCHAR_COLON     ((_CHAR_TYPE)':')
#define TCHAR_DOT       ((_CHAR_TYPE)'.')
#define TCHAR_SPACE     ((_CHAR_TYPE)' ')

//
// General purpose macro for casting character types to whatever type in vogue
// (as defined in this file)
//

#define MAKE_TCHAR(c)   ((_CHAR_TYPE)(c))

//
// IS_PATH_SEPARATOR
//
// lifted from curdir.c and changed to use TCHAR_ character literals, checks
// if a character is a path separator i.e. is a member of the set [\/]
//

#define IS_PATH_SEPARATOR(ch) ((ch == TCHAR_BACKSLASH) || (ch == TCHAR_FWDSLASH))

//
// The following 2 macros lifted from I_Net canonicalization files
//

#define IS_DRIVE(c)             ISALPHA(c)
#define IS_NON_ZERO_DIGIT(c)    (((c) >= MAKE_TCHAR('1')) && ((c) <= MAKE_TCHAR('9')))

//
// STRING_SPACE_REQD returns a number (of bytes) corresponding to the space
// required in which (n) characters can be accomodated
//

#define STRING_SPACE_REQD(n)    ((n) * sizeof(_CHAR_TYPE))

//
// DOWN_LEVEL_STRLEN returns the number of single-byte characters necessary to
// store a converted _CHAR_TYPE string. This will be WCHAR (or wchar_t) if
// UNICODE is defined or TCHAR (or char) otherwise
//

#define DOWN_LEVEL_STRSIZE(n)   ((n) / sizeof(_CHAR_TYPE))

#endif  // _TSTRING_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\netsh\common.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/

#ifndef _COMMON_H_
#define _COMMON_H_

#define is                          ==
#define isnot                       !=
#define and                         &&
#define or                          ||

#define FUTURES(x)
#define MCAST       1

#define MAX_DLL_NAME                48
#define WINS_HELPER_VERSION         1

#define MAX_IP_STRING_LEN           15
#define MAX_MSG_LENGTH  5120

#define MAX_HELPER_NAME             MAX_DLL_NAME
#define MAX_NAME_LEN                MAX_DLL_NAME
#define MAX_ENTRY_PT_NAME           MAX_DLL_NAME

#define MAX_STRING_LEN  256
#define TMSTN                       ResultsN.WinsStat.TimeStamps
#define TMST                        Results.WinsStat.TimeStamps

#define ARRAY_SIZE(x)       (sizeof(x)/sizeof((x)[0]))

#define TIME_ARGSN(x)        \
 TMSTN.x.wMonth, TMSTN.x.wDay, TMSTN.x.wYear, TMSTN.x.wHour, TMSTN.x.wMinute, TMSTN.x.wSecond

#define TIME_ARGS(x)         \
 TMST.x.wMonth, TMST.x.wDay, TMST.x.wYear, TMST.x.wHour, TMST.x.wMinute, TMST.x.wSecond    

#ifdef UNICODE
#define STRICMP(x, y)    _wcsicmp(x, y)
#else
#define STRICMP(x, y)    _stricmp(x, y)
#endif  //UNICODE

#ifdef UNICODE
#define STRTOUL(x, y, z)    wcstoul(x, y, z)
#else
#define STRTOUL(x, y, z)    strtoul(x, y, z)
#endif  //UNICODE

#ifdef UNICODE
#define STRCHR(x, y)        wcschr(x, y)
#else
#define STRCHR(x, y)        strchr(x, y)
#endif  //UNICODE

#ifdef UNICODE
#define STRCAT(x, y)        wcscat(x, y)
#else
#define STRCAT(x, y)        strcat(x, y)
#endif  //UNICODE

#ifdef UNICODE
#define STRLEN(x)        wcslen(x)
#else
#define STRCAT(x)        strlen(x)
#endif  //UNICODE

#ifdef UNICODE
#define ATOI(x)        _wtoi(x)
#else
#define ATOI(x)        atoi(x)
#endif  //UNICODE

#ifdef NT5
#define CHKNULL(Str) ((Str)?(Str):TEXT("<None>"))
#endif  //NT5

#ifdef UNICODE
#define IpAddressToString   WinsIpAddressToDottedStringW
#else
#define IpAddressToString   WinsIpAddressToDottedString
#endif //UNICODE

#ifdef UNICODE
#define StringToIpAddress   WinsDottedStringToIpAddressW
#else
#define StringToIpAddress   WinsDottedStringToIpAddress
#endif //UNICODE

#ifndef _DEBUG
#define DEBUG(s)
#define DEBUG1(s1,s2)
#define DEBUG2(s1,s2)
#else
#define DEBUG(s) wprintf(L"%s\n", L##s)
#define DEBUG1(s1,s2) wprintf(L##s1, L##s2)
#define DEBUG2(s1,s2) wprintf(L##s1, L##s2)
#endif

#define LiLtr(a, b)           ((a).QuadPart < (b).QuadPart)
#define LiAdd(a,b)            ((a).QuadPart + (b).QuadPart)

#define MAX_COMPUTER_NAME_LEN   256

//
//
//Wins registry entry definitions

#define WINSROOT    TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins")
#define CCROOT      TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins\\Parameters\\ConsistencyCheck")
#define CC          TEXT("ConsistencyCheck")
#define PARAMETER   TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins\\Parameters")
#define DEFAULTROOT TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins\\Parameters\\Defaults")
#define DEFAULTPULL TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins\\Parameters\\Defaults\\Pull")
#define DEFAULTPUSH TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins\\Parameters\\Defaults\\Push")
#define PARTNERROOT TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins\\Partners")
#define PULLROOT    TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins\\Partners\\Pull")
#define PUSHROOT    TEXT("SYSTEM\\CurrentControlSet\\Services\\Wins\\Partners\\Push")
#define NETBIOSNAME TEXT("NetBiosName")
#define PERSISTENCE TEXT("PersistentRplOn")
#define PNGSERVER   TEXT(WINSCNF_PERSONA_NON_GRATA_NM)
#define PGSERVER    TEXT(WINSCNF_PERSONA_GRATA_NM)

//These definitions copied from rnraddrs.h 
#define TTL_SUBNET_ONLY 1         // no routing
#define TTL_REASONABLE_REACH 2    // across one router
#define TTL_MAX_REACH  6          // Default max diameter. This may
                                  // be overriden via the Registry.
//
//For determining Systems version
//
#define SERVERVERSION   TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion")
#define WINSVERSION     TEXT("CurrentVersion")
#define SPVERSION       TEXT("CSDVersion")
#define BUILDNUMBER     TEXT("CurrentBuildNumber")   

//different default settings...

#define NAMERECORD_REFRESH_DEFAULT   6*24*60*60
#define NAMERECORD_EXTMOUT_DEFAULT   6*24*60*60
#define NAMERECORD_EXINTVL_DEFAULT   6*24*60*60
#define NAMERECORD_VERIFY_DEFAULT   24*24*60*60
#define ONE_YEAR                   365*24*60*60

#define MAX_PATH_LEN 100
#define WINSTEST_FOUND            0
#define WINSTEST_NOT_FOUND        1
#define WINSTEST_NO_RESPONSE      2

#define WINSTEST_VERIFIED         0
#define WINSTEST_OUT_OF_MEMORY    3
#define WINSTEST_BAD_IP_ADDRESS   4
#define WINSTEST_HOST_NOT_FOUND   5
#define WINSTEST_NOT_VERIFIED     6

#define WINSTEST_INVALID_ARG      7
#define WINSTEST_OPEN_FAILED      8

#define  _NBT_CFG_ADAPTERS_KEY              TEXT("System\\CurrentControlSet\\Services\\NetBT\\Adapters")

#define  RPL_E_PULL 0
#define  RPL_E_PUSH 1

#define RE_QUERY_REGISTRY_COUNT 10



ULONG   LocalIpAddress;
CHAR    pScope[128];


#define MAX_WINS    1000

//
// <Server> - <Owner> Table - [SO] Table
//
extern LARGE_INTEGER  **  SO_Table;

//
// Lookaside table to map IP addrs to the index into the SO_Table
//

extern WCHAR   ** LA_Table;
extern ULONG   LA_TableSize;

VOID
DumpSOTable(
    IN DWORD    MasterOwners,
    IN BOOL     fFile,
    IN FILE *   pFile
    );

VOID
DumpLATable(
    IN DWORD    MasterOwners,
    IN BOOL     fFile,
    IN FILE  *  pFile
    ); 

typedef struct _WINSMON_SUBCONTEXT_TABLE_ENTRY
{
    //
    // Name of the context
    //

    LPWSTR                  pwszContext;
    //
    //Short command help
    DWORD                   dwShortCmdHlpToken;
    
    //Detail command help
    DWORD                   dwCmdHlpToken;

    PNS_CONTEXT_ENTRY_FN    pfnEntryFn;    

}WINSMON_SUBCONTEXT_TABLE_ENTRY,*PWINSMON_SUBCONTEXT_TABLE_ENTRY;

PVOID WinsAllocateMemory(DWORD dwSize);
VOID WinsFreeMemory(PVOID Memory);

extern HANDLE   g_hModule;
extern BOOL     g_bCommit;
extern BOOL     g_hConnect;
extern BOOL     g_fServer;
extern DWORD    g_dwNumTableEntries;
extern PWCHAR   g_pwszServer;

extern ULONG    g_ulInitCount;
extern ULONG    g_ulNumTopCmds;
extern ULONG    g_ulNumGroups;

extern DWORD    g_dwMajorVersion;
extern DWORD    g_dwMinorVersion;
 
extern LPWSTR g_ServerNameUnicode;
extern LPSTR  g_ServerNameAnsi;
extern CHAR   g_ServerIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern WCHAR  g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
extern HKEY   g_hServerRegKey;
extern WCHAR  g_ServerNetBiosName[MAX_COMPUTER_NAME_LEN];

extern handle_t                    g_hBind;
extern WINSINTF_BIND_DATA_T        g_BindData;

extern WCHAR   wszUnknown[50];
extern WCHAR   wszEnable[50];
extern WCHAR   wszDisable[50];
extern WCHAR   wszRandom[150];
extern WCHAR   wszOwner[150];
extern WCHAR   wszInfinite[100];
extern WCHAR   wszPush[50];
extern WCHAR   wszPull[50];
extern WCHAR   wszPushpull[50];
extern WCHAR   wszHigh[50];
extern WCHAR   wszNormal[50];
extern WCHAR   wszDeleted[150];
extern WCHAR   wszOK[50];
extern WCHAR   wszFailure[50];
extern WCHAR   wszReadwrite[50];
extern WCHAR   wszRead[50];
extern WCHAR   wszNo[50];
extern WCHAR   wszNameVerify[100];
//
// The format of Adapter Status responses
//
typedef struct
{
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER    Names[32];
} tADAPTERSTATUS;

extern WCHAR *messages[];



#define MAX_NB_NAMES            1000
#define MAX_SERVERS             1000
#define BUFF_SIZE               650
#define MAX_SIZE                1024
#define INFINITE_EXPIRATION     0x7FFFFFFF


#define MAX(a, b) ( ( (a) > (b) ) ? (a) : (b) )
#define MIN(a, b) ( ( (a) > (b) ) ? (b) : (a) )

extern SOCKET  sd;
extern WSADATA WsaData;

struct sockaddr_in myad;
struct sockaddr_in recvad;
int addrlen;
u_short TranID;
extern u_long NonBlocking;


extern int     NumWinServers;
extern int     NumNBNames;
extern u_char  **NBNames;
u_long  VerifiedAddress[MAX_NB_NAMES];

typedef struct
{
    BOOLEAN         fQueried;
    struct in_addr  Server;
    struct in_addr  RetAddr;
    int             Valid;
    int             Failed;
    int             Retries;
    int             LastResponse;
    int             Completed;
} WINSERVERS;

extern WINSERVERS * WinServers;

#define NBT_NONCODED_NMSZ   17
#define NBT_NAMESIZE        34

ULONG   NetbtIpAddress;

typedef struct _NameResponse
{
    u_short TransactionID;
    u_short Flags;
    u_short QuestionCount;
    u_short AnswerCount;
    u_short NSCount;
    u_short AdditionalRec;
    u_char  AnswerName[NBT_NAMESIZE];
    u_short AnswerType;
    u_short AnswerClass;
    u_short AnswerTTL1;
    u_short AnswerTTL2;
    u_short AnswerLength;
    u_short AnswerFlags;
    u_short AnswerAddr1;
    u_short AnswerAddr2;
} NameResponse;

#define NAME_RESPONSE_BUFFER_SIZE sizeof(NameResponse) * 10

DWORD
FormatDateTimeString( IN  time_t  time,
                      IN  BOOL    fShort,
                      OUT LPWSTR  pwszBuffer,
                      IN  DWORD  *pdwBuffLen);

INT
CheckNameConsistency();



DWORD
DisplayErrorMessage(
    IN DWORD   dwMsgID,
    IN DWORD   dwErrID,
    ...
);


BOOL
IsIpAddress(
    IN LPCWSTR  pwszAddress
);

UCHAR  StringToHexA(IN LPCWSTR pwcString);

BOOL
IsPureNumeric(
    IN LPCWSTR pwszStr
);

BOOL
IsValidServer(
    IN LPCWSTR    pwszServer
);

BOOL
IsLocalServer( VOID );

DWORD
CreateDumpFile(
    IN  LPCWSTR pwszName,
    OUT PHANDLE phFile
);


VOID
CheckVersionNumbers(
                    IN  LPCSTR  pStartIp,
                    IN  BOOL    fFile,
                    OUT FILE *  pFile
                   );

DWORD 
ControlWINSService(IN BOOL bStop);

VOID
CloseDumpFile(
    IN HANDLE  hFile
);


LPWSTR
WinsOemToUnicodeN(
    IN      LPCSTR  Ansi,
    IN OUT  LPWSTR  Unicode,
    IN      USHORT  cChars
    );

LPWSTR
WinsOemToUnicode(
    IN      LPCSTR Ansi,
    IN OUT  LPWSTR Unicode
    );

LPSTR
WinsUnicodeToOem(
    IN      LPCWSTR Unicode,
    IN OUT  LPSTR   Ansi
    );

LPWSTR
WinsAnsiToUnicode(
    IN      LPCSTR Ansi,
    IN OUT  LPWSTR Unicode
    );

LPSTR
WinsUnicodeToAnsi(
    IN      LPCWSTR Unicode,
    IN OUT  LPSTR   Ansi
    );

LPSTR
WinsAnsiToOem(
    IN      LPCSTR   Ansi
    );
VOID

WinsHexToString(
    OUT LPWSTR Buffer,
    IN  const BYTE * HexNumber,
    IN  DWORD Length
    );

VOID
WinsHexToAscii(
    OUT LPSTR Buffer,
    IN  const BYTE * HexNumber,
    IN  DWORD Length
    );

VOID
WinsDecimalToString(
    OUT LPWSTR Buffer,
    IN  BYTE Number
    );

DWORD
WinsDottedStringToIpAddress(
    IN LPCSTR String
    );

LPSTR
WinsIpAddressToDottedString(
    IN DWORD IpAddress
    );

DWORD
WinsStringToHwAddress(
    IN LPCSTR AddressBuffer,
    IN LPCSTR AddressString
    );

LPWSTR
MakeTimeString(
               IN DWORD dwTime
);

LPWSTR
MakeDayTimeString(
                  IN DWORD dwTime
);


DWORD
WinsDottedStringToIpAddressW(
    IN LPCWSTR pwszString
);

LPWSTR
WinsIpAddressToDottedStringW(
    IN DWORD   IpAddress
);

DWORD
GetVersionData(
               IN LPWSTR               pwszVers,
               IN WINSINTF_VERS_NO_T   *Version
);


DWORD
ImportStaticMappingsFile(IN LPWSTR strFile,
                         IN BOOL fDelete
);

DWORD
PreProcessCommand(
      IN OUT      LPWSTR           *ppwcArguments,
      IN          DWORD             dwArgCount,
      IN          DWORD             dwCurrentIndex,
      IN OUT      PTAG_TYPE         pTagTable,
      IN OUT      PDWORD            pdwTagCount,
      OUT         PDWORD            pdwTagType,
      OUT         PDWORD            pdwTagNum
);

DWORD
GetStatus(
        IN BOOL            fPrint,
        LPVOID          pResultsA,
        BOOL            fNew,
        BOOL            fShort,
        LPCSTR           pStartIp
);


DWORD
GetDbRecs(
   WINSINTF_VERS_NO_T LowVersNo,
   WINSINTF_VERS_NO_T HighVersNo,
   PWINSINTF_ADD_T    pWinsAdd,
   LPBYTE             pTgtAdd,
   BOOL               fSetFilter,
   LPBYTE             pFilterName,
   DWORD              Len,
   BOOL               fAddFilter,
   DWORD              AddFilter,
   BOOL               fCountRec,
   BOOL               fCase,
   BOOL               fFile,
   LPWSTR             pwszFile
);

DWORD
WinsDumpServer(IN LPCWSTR               pwszServerIp,
               IN LPCWSTR               pwszNetBiosName,
               IN handle_t             hBind,
               IN WINSINTF_BIND_DATA_T BindData
              );

NS_CONTEXT_DUMP_FN WinsDump;

VOID
ChkAdd(
        PWINSINTF_RECORD_ACTION_T pRow,
        DWORD                     Add,
        BOOL                      fFile,
        FILE  *                   pFile,
        DWORD                     OwnerIP,
        LPBOOL                    pfMatch
);

VOID
DumpMessage(
            HANDLE      hModule,
            FILE *      pFile,            
            DWORD       dwMsgId,
            ...
           );


#if DBG



VOID
WinsPrintRoutine(
    IN DWORD DebugFlag,
    IN LPCSTR Format,
    ...
);

VOID
WinsAssertFailed(
    IN LPCSTR FailedAssertion,
    IN LPCSTR FileName,
    IN DWORD LineNumber,
    IN LPCSTR Message
    );

#define WinsPrint(_x_)   WinsPrintRoutine _x_


#define WinsAssert(Predicate) \
    { \
        if (!(Predicate)) \
            WinsAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#define WinsVerify(Predicate) \
    { \
        if (!(Predicate)) \
            WinsAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#else

#define WinsAssert(_x_)
#define WinsDumpMessage(_x_, _y_)
#define WinsVerify(_x_) (_x_)

#endif // not DBG
#endif	//_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\netsh\check.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/

#include "precomp.h"


#define WCHARTONUM(wchr) (iswalpha(wchr)?(towlower(wchr)-L'a')+10:wchr-L'0')

UCHAR  StringToHexA(IN LPCWSTR pwcString)
{
    UCHAR   ch = (CHAR)0x00;

    if( pwcString is NULL )
        return ch;

    while(*pwcString != L'\0')
    {
        ch <<= 4;
        ch |= WCHARTONUM(*pwcString);
        pwcString++;
    }

   return ch;
}



ULONG LA_TableSize = 0;

VOID
FreeLATable(ULONG TableSize)
{
    DWORD i = 0;

    if( IsBadReadPtr((void *)LA_Table, TableSize) is FALSE && 
        TableSize > 0 )
    {
        for( i=0; i<TableSize; i++ )
        {
            if( IsBadStringPtr(LA_Table[i], 20*sizeof(WCHAR)) is FALSE )
            {
                WinsFreeMemory((PVOID)LA_Table[i]);
                LA_Table[i] = NULL;
            }
        }

        WinsFreeMemory((PVOID)LA_Table);
        LA_Table = NULL;
    }
}

VOID
FreeSOTable(ULONG TableSize)
{
    DWORD i = 0;

    if( SO_Table )
    {
        for( i=0; i<TableSize; i++ )
        {
            if( SO_Table[i] )
            {
                WinsFreeMemory((PVOID)SO_Table[i]);
                SO_Table[i] = NULL;
            }
        }

        WinsFreeMemory((PVOID)SO_Table);
        SO_Table = NULL;
    }
}

VOID
DumpSOTable(
    IN DWORD MasterOwners,
    IN BOOL     fFile,
    IN FILE *   pFile
    )
{
    ULONG   i;
    ULONG   j;

    DisplayMessage(g_hModule, 
                   MSG_WINS_SOTABLE_HEADER);
    if( fFile is TRUE )
    {
        DumpMessage(g_hModule,
                    pFile,
                    FMSG_WINS_SOTABLE_HEADER);
    }


    for (i = 0; i < MasterOwners; i++) 
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_MASTEROWNER_INDEX,
                       i);
        if( fFile )
        {
            DumpMessage(g_hModule,
                        pFile,
                        FMSG_WINS_MASTEROWNER_INDEX,
                        i);
        }
    }

    DisplayMessage(g_hModule,
                   WINS_FORMAT_LINE);
    if( fFile )
    {
        DumpMessage(g_hModule,
                    pFile,
                    WINS_FORMAT_LINE);
    }

    for (i = 0; i < MasterOwners; i++) 
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_MASTEROWNER_INDEX1,
                       i);
        if( fFile )
        {
            DumpMessage(g_hModule,
                        pFile,
                        FMSG_WINS_MASTEROWNER_INDEX1,
                        i);
        }
        for (j = 0; j < MasterOwners; j++) 
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_MASTEROWNER_INDEX,
                           SO_Table[i][j]);
            if( fFile )
            {
                DumpMessage(g_hModule,
                            pFile,
                            FMSG_WINS_MASTEROWNER_INDEX,
                            SO_Table[i][j]);
            }
        }

        DisplayMessage(g_hModule,
                       WINS_FORMAT_LINE);
        if( fFile )
        {
            DumpMessage(g_hModule,
                        pFile,
                        WINS_FORMAT_LINE);
        }
    }

    
    DisplayMessage(g_hModule,
                   MSG_WINS_MAP_SOURCE);

    if( fFile )
    {
        DumpMessage(g_hModule,
                    pFile,
                    FMSG_WINS_MAP_SOURCE);
    }

    DumpLATable(MasterOwners, fFile, pFile);
}

VOID
DumpLATable(
    IN DWORD MasterOwners,
    IN BOOL     fFile,
    IN FILE  *  pFile
    )
{
    ULONG   i;
    ULONG   j;

    
    DisplayMessage(g_hModule,
                   MSG_WINS_INDEXTOIP_TABLE);

    if( fFile )
    {
        DumpMessage(g_hModule,
                    pFile,
                    FMSG_WINS_INDEXTOIP_TABLE);

    }
    for (i = 0; i < MasterOwners; i++) 
    {
        if (LA_Table[i][0] == '0') 
        {
            break;
        }
    
        DisplayMessage(g_hModule,
                       MSG_WINS_INDEXTOIP_ENTRY,
                       i,
                       LA_Table[i]);

        if( pFile )
        {
            DumpMessage(g_hModule,
                        pFile,
                        FMSG_WINS_INDEXTOIP_ENTRY,
                        i,
                        LA_Table[i]);
        }

    }
    
    DisplayMessage(g_hModule,
                   WINS_FORMAT_LINE);
    if( fFile )
    {
        DumpMessage(g_hModule,
                    pFile,
                    WINS_FORMAT_LINE);
    }
}

LONG
IPToIndex(
    IN  LPWSTR  IpAddr,
    DWORD   NoOfOwners
    )
{
    ULONG   i=0;
    WCHAR **pTempLA = NULL;
    //
    // Get the Row #
    //
    for ( i = 0; i < NoOfOwners; i++) {
        if (wcscmp(LA_Table[i], IpAddr) == 0) {
            return i;
        }
        //
        // The first NULL entry indicates end
        //
        if (LA_Table[i][0] is L'0') {
            break;
        }
    }

    //
    // Entry not found - add
    //
    
    wcscpy(LA_Table[i], IpAddr);
    
    LA_TableSize = i+1;
    return i;
}

//
// Check if the diagonal elements are the max in their cols.
//
VOID
CheckSOTableConsistency(
    DWORD   MasterOwners
    )
{
    ULONG   i;
    ULONG   j;
    BOOLEAN fProblem = FALSE;

    for (i = 0; i < MasterOwners; i++) 
    {

        //
        // Is the diagonal element at i the largest in its column?
        //
        for (j = 0; j < MasterOwners; j++) 
        {
            if (i == j) 
            {
                continue;
            }

            //
            // Compare only non-zero values
            //
            if (SO_Table[i][i].QuadPart &&
                SO_Table[j][i].QuadPart &&
                (SO_Table[i][i].QuadPart < SO_Table[j][i].QuadPart))
            {
                 
                DisplayMessage(g_hModule, EMSG_WINS_VERSION_HIGHER, LA_Table[j], LA_Table[i]);
                fProblem = TRUE;
            }
        }
    }

    if ( fProblem is FALSE ) 
    {
        DisplayMessage(g_hModule, EMSG_WINS_VERSION_CORRECT);
    }
}

DWORD
InitLATable(
    PWINSINTF_ADD_VERS_MAP_T  pAddVersMaps,
    DWORD   MasterOwners,           // 0 first time
    DWORD   NoOfOwners
    )
{
    ULONG   i, j, k;

    if( LA_Table is NULL )
    {
        LA_Table = WinsAllocateMemory(MAX_WINS*sizeof(LPWSTR));
        if( LA_Table is NULL )
        {
             return 0;
        }    

        for( i=0; i< MAX_WINS; i++ )
        {
            LA_Table[i] = WinsAllocateMemory(20*sizeof(WCHAR));
            if( LA_Table[i] is NULL )
            {
                FreeLATable(i);
                return 0;
            }

        }
    }

    if (MasterOwners == 0) 
    {
        //
        // first time - init the LA table
        //
        for (i = 0; i < NoOfOwners; i++, pAddVersMaps++) 
        {
            struct in_addr            InAddr;

            LPWSTR  pwsz = IpAddressToString(pAddVersMaps->Add.IPAdd);
            if( pwsz is NULL )
            {
                FreeLATable(MAX_WINS);
                return 0;
            }

            wcscpy(LA_Table[i], pwsz);
            
            WinsFreeMemory(pwsz);
            pwsz = NULL;

        }
    } 
    else 
    {
        //
        // More came in this time - add them to the LA table after the others
        //
        for (i = 0; i < NoOfOwners; i++, pAddVersMaps++) 
        {
            LPWSTR pwszIp = IpAddressToString(pAddVersMaps->Add.IPAdd);

            if( pwszIp is NULL )
            {
                FreeLATable(MAX_WINS);
                return 0;
            }
            //
            // If this entry is not in the LA table, insert
            //
            for (j = 0; j < MasterOwners; j++) 
            {
                if (wcscmp(LA_Table[j], pwszIp) is 0 ) 
                {
                    WinsFreeMemory(pwszIp);
                    pwszIp = NULL;
                    break;
                }
            }

            if (j == MasterOwners) 
            {
                //
                // Insert
                //


                wcscpy(LA_Table[MasterOwners], pwszIp);
                MasterOwners++;
            }

            if( pwszIp )
            {
                WinsFreeMemory(pwszIp);
                pwszIp = NULL;
            }
        }
    }
    
    if( SO_Table is NULL )
    {
        SO_Table = WinsAllocateMemory((MAX_WINS+1)*sizeof(LARGE_INTEGER *));
        if (SO_Table == NULL)
        {
            FreeLATable(MAX_WINS);
            return 0;
        }
    
        for( i=0; i<MAX_WINS+1; i++ )
        {
            SO_Table[i] = WinsAllocateMemory((MAX_WINS+1)*sizeof(LARGE_INTEGER));
            if( SO_Table[i] is NULL )
            {
                FreeLATable(MAX_WINS);
                FreeSOTable(MAX_WINS+1);
                return 0;
            }
        }
    }

    LA_TableSize = NoOfOwners;
    return MasterOwners;
}



VOID
AddSOTableEntry (
    IN  LPWSTR  IpAddr,
    PWINSINTF_ADD_VERS_MAP_T  pMasterMaps,
    DWORD   NoOfOwners,
    DWORD   MasterOwners
    )
{
    ULONG   i;
    LONG   Row;
    struct in_addr            InAddr;

    Row = IPToIndex(IpAddr, MasterOwners);

    //
    // Fill the row
    //
    for ( i = 0; i < NoOfOwners; i++, pMasterMaps++) 
    {
        LONG    col;
        LPTSTR  pstr;

        InAddr.s_addr = htonl(pMasterMaps->Add.IPAdd);

        pstr = IpAddressToString(pMasterMaps->Add.IPAdd);
        if (pstr == NULL)
            break;

        col = IPToIndex(pstr, MasterOwners);
        //
        // Place only a non-deleted entry
        //
        if (!((pMasterMaps->VersNo.HighPart == MAXLONG) &&
              (pMasterMaps->VersNo.LowPart == MAXULONG))) {

            //
            // Also if the entry above us was 0, write 0 there so as to make the fail case stand out
            //
            if (Row && SO_Table[Row-1][col].QuadPart == 0) 
            {
                SO_Table[Row][col].QuadPart = 0;
            } 
            else 
            {
                SO_Table[Row][col] = pMasterMaps->VersNo;
            }

        }
    }
}

VOID
RemoveFromSOTable(
    IN  LPWSTR  IpAddr,
    IN  DWORD   MasterOwners
    )
{
    ULONG   i;
    LONG   Row;
    struct in_addr            InAddr;

    Row = IPToIndex(IpAddr, MasterOwners);

    //
    // Mark the row and col as down (0's)
    //
    for (i = 0; i < MasterOwners; i++) 
    {
        SO_Table[Row][i].QuadPart = SO_Table[i][Row].QuadPart = 0;
    }
}


//
// Get the <owner address> - <version #> [OV table] mapping tables from each WINS server on the net and check for inconsistencies.
//
VOID
CheckVersionNumbers( 
                    IN  LPCSTR  pStartIp,
                    IN  BOOL    fFile,
                    OUT FILE *  pFile
                   )
{
    DWORD                     Status = NO_ERROR;
    ULONG                     i, k;
    PWINSINTF_ADD_VERS_MAP_T  pAddVersMaps;
    PWINSINTF_ADD_VERS_MAP_T  pMasterMaps;  // master OV maps used to place into the OV table
    DWORD                     NoOfOwners=0;
    DWORD                     MasterOwners=0;
    struct in_addr            InAddr;
    WINSINTF_RESULTS_NEW_T    ResultsN;
    DWORD                     ret;
    handle_t                  hBindTemp = g_hBind;
    WINSINTF_BIND_DATA_T      BindDataTemp = g_BindData;
    LPWSTR                    wszStartIp = NULL;
    
    if( pStartIp is NULL )
        return;
    
    wszStartIp = WinsOemToUnicode(pStartIp, NULL);  
    
    if( wszStartIp is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_OUT_OF_MEMORY);
        return;
    }

    //
    // Get the OV table from this server
    //
    if (NO_ERROR isnot (Status = GetStatus(TRUE, &ResultsN, TRUE, FALSE, pStartIp)) )
    {
        DisplayErrorMessage(EMSG_SRVR_CHECK_VERSION,
                            Status);
          
        WinsFreeMemory(wszStartIp);
        wszStartIp = NULL;
        return;
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_GETSTATUS_SUCCESS);

        DisplayMessage(g_hModule,
                       WINS_FORMAT_LINE);
    }

    MasterOwners = NoOfOwners = ResultsN.NoOfOwners;

    pMasterMaps = pAddVersMaps = ResultsN.pAddVersMaps;

    ret = InitLATable(pAddVersMaps, 0, NoOfOwners);
    
    if( LA_Table is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_OUT_OF_MEMORY);
        WinsFreeMemory(wszStartIp);
        wszStartIp = NULL;
        return;
    }

    if( SO_Table is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_OUT_OF_MEMORY);
        FreeLATable(MAX_WINS);    
        WinsFreeMemory(wszStartIp);
        wszStartIp = NULL;
        return;
    }

    AddSOTableEntry(wszStartIp, pMasterMaps, NoOfOwners, MasterOwners);


    if( ResultsN.pAddVersMaps )
    {
        WinsFreeMem(ResultsN.pAddVersMaps);
        ResultsN.pAddVersMaps = NULL;
    }



    //
    // For each server X (other than Start addr) in the LA table:
    //
    for ( i = 0; i < MasterOwners; i++) 
    {
        LPSTR   pszName = NULL;

        if( wcscmp(LA_Table[i], wszStartIp) is 0 )
        {
            continue;
        }

        //
        // Get X's OV table
        //
        pszName = WinsUnicodeToOem(LA_Table[i], NULL);

        if( pszName is NULL )
        {
            DisplayMessage(g_hModule,
                           EMSG_WINS_OUT_OF_MEMORY);
            if( SO_Table )
            {
                FreeSOTable(MAX_WINS+1);
            }
            if( wszStartIp )
            {
                WinsFreeMemory(wszStartIp);
                wszStartIp = NULL;
            }
            
            if( LA_Table )
            {
                FreeLATable(MAX_WINS);
            }
            return;

        }

        if( NO_ERROR isnot (Status = GetStatus(TRUE, &ResultsN, TRUE, FALSE, pszName) ) )
        {
            RemoveFromSOTable(LA_Table[i], MasterOwners);
            if( pszName )
            {
                WinsFreeMemory(pszName);
                pszName = NULL;
            }
            if( ResultsN.pAddVersMaps )
            {
                WinsFreeMem(ResultsN.pAddVersMaps);
                ResultsN.pAddVersMaps = NULL;
            }
            DisplayErrorMessage(EMSG_WINS_GETSTATUS_FAILED,
                                Status);
            continue;
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_GETSTATUS_SUCCESS);
        }
        
        if (MasterOwners < ResultsN.NoOfOwners) 
        {

            ret = InitLATable(ResultsN.pAddVersMaps, MasterOwners, ResultsN.NoOfOwners);
            if( LA_Table is NULL or
                SO_Table is NULL )
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_OUT_OF_MEMORY);
                if( pszName )
                {
                    WinsFreeMemory(pszName);
                    pszName = NULL;
                }
                if( ResultsN.pAddVersMaps )
                {
                    WinsFreeMem(ResultsN.pAddVersMaps);
                    ResultsN.pAddVersMaps = NULL;
                }
                
                if( SO_Table )
                {
                    WinsFreeMemory(SO_Table);
                    SO_Table = NULL;
                }
                if( LA_Table )
                {
                    WinsFreeMemory(LA_Table);
                    LA_Table = NULL;
                }

                if( wszStartIp )
                {
                    WinsFreeMemory(wszStartIp);
                    wszStartIp = NULL;
                }

                return;
            }

            MasterOwners = ret;
        }

        //
        // Place entry in the SO Table in proper order
        //
        AddSOTableEntry(LA_Table[i], ResultsN.pAddVersMaps, ResultsN.NoOfOwners, MasterOwners);
        if( pszName )
        {
            WinsFreeMemory(pszName);
            pszName = NULL;
        }

        if( ResultsN.pAddVersMaps )
        {
            WinsFreeMem(ResultsN.pAddVersMaps);
            ResultsN.pAddVersMaps = NULL;
        }

    }

    //
    // Check if diagonal elements in the [SO] table are the highest in their cols.
    //
    CheckSOTableConsistency(MasterOwners);
    
    DumpSOTable(MasterOwners,
                fFile,
                pFile);

    //
    // Destroy SO table
    //
    FreeSOTable(MasterOwners+1);
    FreeLATable(MasterOwners);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\mib\winstst.c ===
//
//
//  Copyright (c) 1991  Microsoft Corporation
//

//-------------------------- MODULE DESCRIPTION ----------------------------
//  
//  winsmain.c
//  
//---------------------------------------------------------------------------


//--------------------------- WINDOWS DEPENDENCIES --------------------------

#include <windows.h>

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <malloc.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <util.h>
#include "winsmib.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

typedef AsnObjectIdentifier View; // temp until view is defined...

_cdecl main(
    IN int  argumentCount,
    IN char *argumentVector[])
{
    HANDLE  hExtension;
    FARPROC initAddr;
    FARPROC queryAddr;
    FARPROC trapAddr;

    DWORD  timeZeroReference;
    HANDLE hPollForTrapEvent;
    View   supportedView;
    UINT   Val;
    DWORD  Choice;
    DWORD  Oper;
    BYTE   Name[255];

    INT numQueries = 10;

    extern INT nLogLevel;
    extern INT nLogType;

    nLogLevel = 15;
    nLogType  = 1;

    // avoid compiler warning...
    UNREFERENCED_PARAMETER(argumentCount);
    UNREFERENCED_PARAMETER(argumentVector);

    timeZeroReference = GetCurrentTime();

    // load the extension agent dll and resolve the entry points...
    if (GetModuleHandle("winsmib.dll") == NULL)
    {
        if ((hExtension = LoadLibrary("winsmib.dll")) == NULL)
        {
            dbgprintf(1, "error on LoadLibrary %d\n", GetLastError());

        }
        else 
	{
	    if ((initAddr = GetProcAddress(hExtension, 
                 		"SnmpExtensionInit")) == NULL)
            {
              dbgprintf(1, "error on GetProcAddress %d\n", GetLastError());
            }
            else 
	    {
	      if ((queryAddr = GetProcAddress(hExtension, 
                 		"SnmpExtensionQuery")) == NULL)
              {
                    dbgprintf(1, "error on GetProcAddress %d\n", 
                              GetLastError());

              }
              else 
	      {
		if ((trapAddr = GetProcAddress(hExtension, 
                                   "SnmpExtensionTrap")) == NULL)
                {
                   dbgprintf(1, "error on GetProcAddress %d\n", 
                      GetLastError());
                }
         	else
                {
                  // initialize the extension agent via its init entry point...
                  (*initAddr)(
                       timeZeroReference,
                       &hPollForTrapEvent,
                    &supportedView);
                }
	     }
	   }
	}
      } // end if (Already loaded)

      {
         RFC1157VarBindList varBinds;
         AsnInteger         errorStatus;
         AsnInteger         errorIndex;
         UINT OID_Prefix[] = { 1, 3, 6, 1, 4, 1, 311, 1 };
	 UINT OID_Suffix1[] = { 1, 2, 0};
	 UINT OID_Suffix2[] = { 1, 3, 0};
	 UINT OID_Suffix3[] = { 1, 4, 0};
         AsnObjectIdentifier MIB_OidPrefix = { OID_SIZEOF(OID_Prefix), OID_Prefix };
	 AsnObjectIdentifier Sf1Oid = { OID_SIZEOF(OID_Suffix1), OID_Suffix1};
	 AsnObjectIdentifier Sf2Oid = { OID_SIZEOF(OID_Suffix2), OID_Suffix2};
	 AsnObjectIdentifier Sf3Oid = { OID_SIZEOF(OID_Suffix3), OID_Suffix3};


	 errorStatus = 0;
	 errorIndex  = 0;
         varBinds.list = (RFC1157VarBind *)SNMP_malloc( sizeof(RFC1157VarBind));
//         varBinds.list = (RFC1157VarBind *)SNMP_malloc( sizeof(RFC1157VarBind) * 4);
//         varBinds.len = 4;
         varBinds.len = 1;
         SNMP_oidcpy( &varBinds.list[0].name, &MIB_OidPrefix );
         varBinds.list[0].value.asnType = ASN_NULL;

#if 0
         SNMP_oidcpy( &varBinds.list[1].name, &MIB_OidPrefix );
	 SNMP_oidappend(  &varBinds.list[1].name, &Sf1Oid ); 
         varBinds.list[1].value.asnType = ASN_NULL;

         SNMP_oidcpy( &varBinds.list[2].name, &MIB_OidPrefix );
	 SNMP_oidappend(  &varBinds.list[2].name, &Sf2Oid ); 
         varBinds.list[2].value.asnType = ASN_NULL;

         SNMP_oidcpy( &varBinds.list[3].name, &MIB_OidPrefix );
	 SNMP_oidappend(  &varBinds.list[3].name, &Sf3Oid ); 
         varBinds.list[3].value.asnType = ASN_NULL;

#endif
	 printf("Walk ? (1 for yes) -- ");
	 scanf("%d", &Choice);
	 if (Choice == 1)
	 {
          do
          {
	    printf( "\nGET-NEXT of:  " ); SNMP_oiddisp( &varBinds.list[0].name );
                                        printf( "   " );
            (*queryAddr)( (AsnInteger)ASN_RFC1157_GETNEXTREQUEST,
                          &varBinds,
		          &errorStatus,
		          &errorIndex
                          );
            printf( "\n  is  " ); SNMP_oiddisp( &varBinds.list[0].name );
	    if ( errorStatus )
	       {
               printf( "\nErrorstatus:  %lu\n\n", errorStatus );
	       }
	    else
	       {
               printf( "\n  =  " ); SNMP_printany( &varBinds.list[0].value );
	       }
//            putchar( '\n' );

         } while ( varBinds.list[0].name.ids[MIB_PREFIX_LEN-1] == 1 );

         // Free the memory
         SNMP_FreeVarBindList( &varBinds );
	 }
       } // block


       {


       char String[80];
       DWORD i;
       RFC1157VarBindList varBinds;
       UINT OID_Prefix[] = { 1, 3, 6, 1, 4, 1, 311, 1 };
       UINT TempOid[255];
       AsnObjectIdentifier MIB_OidPrefix = { OID_SIZEOF(OID_Prefix), OID_Prefix };
       AsnObjectIdentifier MIB_Suffix = { OID_SIZEOF(TempOid), TempOid};
       AsnInteger errorStatus;
       AsnInteger errorIndex;
       UINT	Code;


        varBinds.list = (RFC1157VarBind *)SNMP_malloc( sizeof(RFC1157VarBind) );
        varBinds.len = 1;
Loop:
       printf("Enter Code for Group \nPar\t1\nPull\t2\nPush\t3\nDF\t4\nCmd\t5\nCode is --");
       scanf("%d", &TempOid[0]);
       if (TempOid[0] < 1 || TempOid[0] > 5)
       {
	  goto Loop;
       }
LoopLT:
       printf("Leaf or Table access (0/1) -- ");
       scanf("%d", &Code);
       if (Code != 0 && Code != 1)
       {
	  goto LoopLT;

       }
       printf("Enter Code for var. --");
        scanf("%d", &TempOid[1]);
       if (Code == 0)
       {
        TempOid[2] = 0;
	MIB_Suffix.idLength = 3;
       }
       else
       {
	TempOid[2] = 1;
        printf("Enter Code for field --");
        scanf("%d", &TempOid[3]);
	switch(TempOid[0])
	{
		case(2):
		case(3):
			printf("Input IP address in host order\n");
			for (i=0; i< 4; i++)
			{
			  printf("\nByte (%d) -- ", i);
			  scanf("%d", &TempOid[4 + i]);
			}
			MIB_Suffix.idLength = 8;
			break;
		case(4):
			printf("Index of file ? -- ");
			scanf("%d", &TempOid[4]);
			MIB_Suffix.idLength = 5;
		case(5):
			printf("name -- ");
			scanf("%s", Name);
			for (i=0; i<strlen(Name); i++)
			{
				TempOid[4+i] = (UINT)Name[i];
			}
			TempOid[4+i] = 0;
			MIB_Suffix.idLength = 4 + i + 1;
			break;
			
	}
	 

       }
	//
	// Construct OID with complete prefix for comparison purposes
	//
	SNMP_oidcpy( &varBinds.list[0].name, &MIB_OidPrefix );
	SNMP_oidappend( &varBinds.list[0].name, &MIB_Suffix );
 
       	//printf( "SET:  " ); 
	SNMP_oiddisp( &varBinds.list[0].name );
Loop1:
	printf("\nSET/GET/GET_NEXT - 0/1/? -- ");
	scanf("%d", &Oper);
	printf("\nEnter Type (1 - Integer, 2-Octet String, 3 -IP address, 4 -Counter -- ");
	scanf("%d",&Choice);
        if (Choice < 1 || Choice > 4)
	{
	  goto Loop1;
        }
	switch(Choice)
	{
		case(1):
       			varBinds.list[0].value.asnType = ASN_INTEGER;
			if (Oper == 0)
			{
			printf("\nInteger Value -- ");
			scanf("%d", &Val);
       			varBinds.list[0].value.asnValue.number = Val;
			}
			break;
		case(2):
       			varBinds.list[0].value.asnType = ASN_OCTETSTRING;
			if (Oper == 0)
			{
			printf("\nCharacter array -- ");
			scanf("%s", String);
		  	varBinds.list[0].value.asnValue.string.length =
                    		strlen( (LPSTR)String );

       			varBinds.list[0].value.asnValue.string.stream = String;

  			varBinds.list[0].value.asnValue.string.dynamic = FALSE;
			}
	
			break;
		case(3):
       			varBinds.list[0].value.asnType = ASN_RFC1155_IPADDRESS;
			if (Oper == 0)
			{
			printf("\nInput ip address bytes in network byte order\n");
			for (i=0; i< 4; i++)
			{
			  printf("\nByte (%d) -- ", i);
			  scanf("%d", &String[i]);
			}
			String[4] = 0;
		  	varBinds.list[0].value.asnValue.string.length =
                    		strlen( (LPSTR)String );

       			varBinds.list[0].value.asnValue.string.stream = String;

  			varBinds.list[0].value.asnValue.string.dynamic = TRUE;
			}
			break;
		case(4):
       			varBinds.list[0].value.asnType = ASN_RFC1155_COUNTER;
			if (Oper == 0)
			{
			printf("\nInteger Value -- ");
			scanf("%d", &Val);
       			varBinds.list[0].value.asnValue.number = Val;

			}
			break;
		default:
			printf("wrong type\n");
			break;
       }		

       errorStatus       = 0;
       errorIndex        = 0;

	switch(Oper)
	{
		case(0): 
			Code = ASN_RFC1157_SETREQUEST;
       			printf( "SET:  " ); SNMP_oiddisp( &varBinds.list[0].name );
       			printf( " to " ); SNMP_printany( &varBinds.list[0].value );
			break;
		case(1):
			Code = ASN_RFC1157_GETREQUEST;
       			printf( "GET:  " ); SNMP_oiddisp( &varBinds.list[0].name );
			break;
		default:
       			printf( "GETNEXT:  " ); SNMP_oiddisp( &varBinds.list[0].name );
			Code = ASN_RFC1157_GETNEXTREQUEST;
			break;


	}
       (*queryAddr)( (BYTE)Code,
                              &varBinds,
			      &errorStatus,
			      &errorIndex
                              );
       printf( "\n Errorstatus:  %lu\n\n", errorStatus );
       if (Code != ASN_RFC1157_SETREQUEST)
       {
          if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
          {
            printf( "Value:  " );
	    SNMP_printany( &varBinds.list[0].value ); putchar( '\n' );
	    SNMP_oidfree(&varBinds.list[0].name);
	  }
       }
	
#if 0
       varBinds.list = (RFC1157VarBind *)SNMP_malloc( sizeof(RFC1157VarBind) );
       varBinds.len = 1;
       varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
       varBinds.list[0].name.ids = (UINT *)SNMP_malloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
       memcpy( varBinds.list[0].name.ids, &itemn,
               sizeof(UINT)*varBinds.list[0].name.idLength );
       varBinds.list[0].value.asnType = ASN_INTEGER;
       printf("Value ? -- ");
       scanf("%d", &Val);
       varBinds.list[0].value.asnValue.number = Val;
       printf( "SET:  " ); SNMP_oiddisp( &varBinds.list[0].name );
       printf( " to " ); SNMP_printany( &varBinds.list[0].value );
       (*queryAddr)( ASN_RFC1157_SETREQUEST,
                              &varBinds,
			      &errorStatus,
			      &errorIndex
                              );
       printf( "\nSET Errorstatus:  %lu\n\n", errorStatus );

       (*queryAddr)( ASN_RFC1157_GETREQUEST,
                              &varBinds,
			      &errorStatus,
			      &errorIndex
                              );
       if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
       {
          printf( "Value:  " );
	  SNMP_printany( &varBinds.list[0].value ); putchar( '\n' );
	  SNMP_oidfree(&varBinds.list[0].name);
	}
       printf( "\nGET Errorstatus:  %lu\n\n", errorStatus );

#endif
#if 0
       // Free the memory
       SNMP_FreeVarBindList( &varBinds );
#endif
       
       printf( "\n\n" );
       printf("Enter 1 to exit -- ");
       scanf("%d", &Choice);
       if (Choice != 1)
       {
       		goto Loop;
       }
    }

    return 0;

} // end main()


//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\mib\winsmibm.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    winsmibm.c

Abstract:

    Sample SNMP Extension Agent for Windows NT.

    These files (winsdll.c, winsmib.c, and winsmib.h) provide an example of 
    how to structure an Extension Agent DLL which works in conjunction with 
    the SNMP Extendible Agent for Windows NT.

    Extensive comments have been included to describe its structure and
    operation.  See also "Microsoft Windows/NT SNMP Programmer's Reference".

Created:

    28-Jun-1991

Revision History:

--*/


static char *vcsid = "@(#) $Logfile:   N:/xtest/vcs/winsdll.c_v  $ $Revision:   1.6  $";

#ifdef UNICODE
#undef UNICODE
#endif

// General notes:
//
//   Microsoft's Extendible Agent for Windows NT is implemented by dynamically
// linking to Extension Agent DLLs that implement portions of the MIB.  These
// Extension Agents are configured in the Windows NT Registration Database.
// When the Extendible Agent Service is started, it queries the registry to
// determine which Extension Agent DLLs have been installed and need to be
// loaded and initialized.  The Extendible Agent invokes various DLL entry
// points (examples follow in this file) to request MIB queries and obtain
// Extension Agent generated traps.


// Necessary includes.

#include <windows.h>
#include <malloc.h>
#include <tchar.h>
#include <snmp.h>


// Contains definitions for the table structure describing the MIB.  This
// is used in conjunction with winsmib.c where the MIB requests are resolved.

#include "winsmib.h"


// Extension Agent DLLs need access to elapsed time agent has been active.
// This is implemented by initializing the Extension Agent with a time zero
// reference, and allowing the agent to compute elapsed time by subtracting
// the time zero reference from the current system time.  This example
// Extension Agent implements this reference with dwTimeZero.

DWORD dwTimeZero = 0;


// Extension Agent DLLs that generate traps must create a Win32 Event object
// to communicate occurence of traps to the Extendible Agent.  The event
// handle is given to the Extendible Agent when the Extension Agent is 
// initialized, it should be NULL if traps will not be generated.  This
// example Extension Agent simulates the occurance of traps with hSimulateTrap.

HANDLE hSimulateTrap = NULL;

// The following variables are needed in order to figure out if the WINS service
// is installed and running on the box. If this is not true, the subagent should
// return SNMP_ERRORSTATUS_NOSUCHNAME for any query, instead of failing later with
// SNMP_ERRORSTATUS_GENERR.
#define WINS_SVC_NAME   _T("WINS")
SC_HANDLE hSvcController = NULL;
SC_HANDLE hWinsSvc = NULL;

// This call returns true if the WINS service is installed and running and
// false otherwise. If WINS is not running, the subagent should fail with
// SNMP_ERRORSTATUS_NOSUCHNAME or should return the first OID out of the MIB view
// instead of an SNMP_ERRORSTATUS_GENERR.
BOOL CheckWinsServiceUp(
    OUT AsnInteger *errorStatus)
{
    SERVICE_STATUS winsSvcStatus;

    // at first request, open the service controller handle
    if (hSvcController == NULL)
    {
        hSvcController = OpenSCManager(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);
        // if unsuccessful this is a real genErr case (any app should be able to do so)
        if (hSvcController == NULL)
        {
            *errorStatus = SNMP_ERRORSTATUS_GENERR;
            return FALSE;
        }
    }

    // at first request, open the Wins service handle
    if (hWinsSvc == NULL)
    {
        hWinsSvc = OpenService(hSvcController, WINS_SVC_NAME, SERVICE_QUERY_STATUS);
        // if unsuccessful it might be that the service is not installed. In this case,
        // return noSuchName, otherwise there is a genErr case
        if (hWinsSvc == NULL)
        {
            *errorStatus = (GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST) ?
                                SNMP_ERRORSTATUS_NOSUCHNAME :
                                SNMP_ERRORSTATUS_GENERR;
            return FALSE;
        }
    }

    // we have both the service controller and the wins service handle, just query for the status
    if (!QueryServiceStatus(hWinsSvc, &winsSvcStatus))
    {
        // if querying the status of the service failed, this is a case of genErr
        *errorStatus = SNMP_ERRORSTATUS_GENERR;
        return FALSE;
    }


    // if WINS is in any other state than 'running', will handle as the service is stopped
    // and return NOSUCHNAME (allowing a possible MIB walk to continue)
    if (winsSvcStatus.dwCurrentState != SERVICE_RUNNING)
    {
       *errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
       return FALSE;
    }

    // at this point the service is up and running
    *errorStatus = SNMP_ERRORSTATUS_NOERROR;
    return TRUE;
}

// This is a standard Win32 DLL entry point.  See the Win32 SDK for more
// information on its arguments and their meanings.  This example DLL does 
// not perform any special actions using this mechanism.

BOOL WINAPI DllMain(
    HANDLE hDll,
    DWORD  dwReason,
    LPVOID lpReserved)
    {
    switch(dwReason)
        {
        case DLL_PROCESS_ATTACH:
        case DLL_PROCESS_DETACH:
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            break;

        } // end switch()

    return TRUE;

    } // end DllEntryPoint()


// Extension Agent DLLs provide the following entry point to coordinate the
// initializations of the Extension Agent and the Extendible Agent.  The
// Extendible Agent provides the Extension Agent with a time zero reference;
// and the Extension Agent provides the Extendible Agent with an Event handle 
// for communicating occurence of traps, and an object identifier representing
// the root of the MIB subtree that the Extension Agent supports.

BOOL SnmpExtensionInit(
    IN  DWORD               dwTimeZeroReference,
    OUT HANDLE              *hPollForTrapEvent,
    OUT AsnObjectIdentifier *supportedView)
    {

    // Record the time reference provided by the Extendible Agent.

    dwTimeZero = dwTimeZeroReference;


    // Create an Event that will be used to communicate the occurence of traps
    // to the Extendible Agent.  The Extension Agent will assert this Event
    // when a trap has occured.  This is explained further later in this file.

    if ((*hPollForTrapEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
        {
        // Indicate error?, be sure that NULL is returned to Extendible Agent.
        }


    // Indicate the MIB view supported by this Extension Agent, an object
    // identifier representing the sub root of the MIB that is supported.

    *supportedView = MIB_OidPrefix; // NOTE!  structure copy


    // Record the trap Event.  This example Extension Agent simulates traps by 
    // generating a trap after every given number of processed requests.

    hSimulateTrap = *hPollForTrapEvent;

    WinsMibInit();

    // Indicate that Extension Agent initialization was sucessfull.

    return TRUE;

    } // end SnmpExtensionInit()


// Extension Agent DLLs provide the following entry point to communcate traps
// to the Extendible Agent.  The Extendible Agent will query this entry point
// when the trap Event (supplied at initialization time) is asserted, which
// indicates that zero or more traps may have occured.  The Extendible Agent 
// will repetedly call this entry point until FALSE is returned, indicating 
// that all outstanding traps have been processed.

BOOL SnmpExtensionTrap(
    OUT AsnObjectIdentifier *enterprise,
    OUT AsnInteger          *genericTrap,
    OUT AsnInteger          *specificTrap,
    OUT AsnTimeticks        *timeStamp,
    OUT RFC1157VarBindList  *variableBindings)
    {
    // The body of this routine is an extremely simple example/simulation of
    // the trap functionality.  A real implementation will be more complex.


    // The following define data inserted into the trap below.  The Lan Manager
    // bytesAvailAlert from the Lan Manager Alerts-2 MIB is generated with an
    // empty variable bindings list.

    static UINT OidList[]  = { 1, 3, 6, 1, 4, 1, 311, 1, 2 };
    static UINT OidListLen = 9;


    // The following variable is used for the simulation, it allows a single
    // trap to be generated and then causes FALSE to be returned indicating
    // no more traps.

    static whichTime = 0;


    // The following if/else support the simulation.

    if (whichTime == 0)
        {
        whichTime = 1;    // Supports the simulation.


        // Communicate the trap data to the Extendible Agent.

        enterprise->idLength = OidListLen;
        enterprise->ids = (UINT *)SNMP_malloc(sizeof(UINT) * OidListLen);
        memcpy(enterprise->ids, OidList, sizeof(UINT) * OidListLen);

        *genericTrap      = SNMP_GENERICTRAP_ENTERSPECIFIC;

        *specificTrap     = 1;                    // the bytesAvailAlert trap

        *timeStamp        = GetCurrentTime() - dwTimeZero;

        variableBindings->list = NULL;
        variableBindings->len  = 0;


        // Indicate that valid trap data exists in the parameters.

        return TRUE;
        }
    else
        {
        whichTime = 0;    // Supports the simulation.


        // Indicate that no more traps are available and parameters do not
        // refer to any valid data.

        return FALSE;
        }

    } // end SnmpExtensionTrap()


// Extension Agent DLLs provide the following entry point to resolve queries
// for MIB variables in their supported MIB view (supplied at initialization
// time).  The requestType is Get/GetNext/Set.

BOOL SnmpExtensionQuery(
    IN BYTE                   requestType,
    IN OUT RFC1157VarBindList *variableBindings,
    OUT AsnInteger            *errorStatus,
    OUT AsnInteger            *errorIndex)
{
    static unsigned long requestCount = 0;  // Supports the trap simulation.
    UINT    I;


//    EnterCriticalSection(&WinsMibCrtSec);
try {
    //
    // Iterate through the variable bindings list to resolve individual
    // variable bindings.
    //

    fWinsMibWinsStatusCnfCalled  = FALSE;
    fWinsMibWinsStatusStatCalled = FALSE;
    for ( I=0;I < variableBindings->len;I++ )
    {
        // resolve the variables only if WINS is up and running.
        if (CheckWinsServiceUp(errorStatus))
        {
            *errorStatus = ResolveVarBind( &variableBindings->list[I],
                                           requestType );
        }


	//
        // Test and handle case where Get Next past end of MIB view supported
        // by this Extension Agent occurs.  Special processing is required to 
        // communicate this situation to the Extendible Agent so it can take 
        // appropriate action, possibly querying other Extension Agents.
	//

        if ( *errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME &&
             requestType == MIB_GETNEXT )
           {
           *errorStatus = SNMP_ERRORSTATUS_NOERROR;


           // Modify variable binding of such variables so the OID points
           // just outside the MIB view supported by this Extension Agent.
           // The Extendible Agent tests for this, and takes appropriate
           // action.

           SNMP_oidfree( &variableBindings->list[I].name );
           SNMP_oidcpy( &variableBindings->list[I].name, &MIB_OidPrefix );
           variableBindings->list[I].name.ids[MIB_PREFIX_LEN-1] ++;
           }


        // If an error was indicated, communicate error status and error
        // index to the Extendible Agent.  The Extendible Agent will ensure
        // that the origional variable bindings are returned in the response
        // packet.

        if ( *errorStatus != SNMP_ERRORSTATUS_NOERROR )
        {
	   *errorIndex = I+1;
	//   goto Exit;
	}
	else
	{
		*errorIndex = 0;
	}
   }

} // end of try
except(EXCEPTION_EXECUTE_HANDLER) {
	//
	// for now do nothing
	//	
	}
   // LeaveCriticalSection(&WinsMibCrtSec);

#if 0
    // Supports the trap simulation.

    if (++requestCount % 3 == 0 && hSimulateTrap != NULL)
        SetEvent(hSimulateTrap);


    // Indicate that Extension Agent processing was sucessfull.


#if 0
      if (*errorStatus != SNMP_ERRORSTATUS_NOERROR)
      {
	 return(FALSE);
      }	

    return TRUE;
#endif
#endif
    if (fWinsMibWinsKeyOpen)
    {
	RegCloseKey(WinsMibWinsKey);
	fWinsMibWinsKeyOpen = FALSE;
    }
    return SNMPAPI_NOERROR;

} // end SnmpExtensionQuery()

VOID
SnmpExtensionClose()
{
    // close the Wins service handle if it was previously opened
    if (hWinsSvc != NULL)
    {
        CloseServiceHandle(hWinsSvc);
    }

    // close the service controller handle if it was previously opened
    if (hSvcController != NULL)
    {
        CloseServiceHandle(hSvcController);
    }
}

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\netsh\check.h ===
/*++

Copyright (C) 1999 Microsoft Corporation


--*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wtypes.h>


#include <fcntl.h>
#include <sys/stropts.h>
#include <ctype.h>

#include <windows.h>
#include <tdi.h>
#include <sys\uio.h>

#include <winsock.h>
#include <wsahelp.h>

#include <sockets\resolv.h>
#include <nb30.h>
#include <nbtioctl.h>

#include "winsintf.h"

#include "common.h"

#define MAX_PATH_LEN 100
#define WINSTEST_FOUND            0
#define WINSTEST_NOT_FOUND        1
#define WINSTEST_NO_RESPONSE      2

#define WINSTEST_VERIFIED         0
#define WINSTEST_OUT_OF_MEMORY    3
#define WINSTEST_BAD_IP_ADDRESS   4
#define WINSTEST_HOST_NOT_FOUND   5
#define WINSTEST_NOT_VERIFIED     6

#define WINSTEST_INVALID_ARG      7
#define WINSTEST_OPEN_FAILED      8

#define  _WINS_CFG_PULL_KEY              TEXT("System\\CurrentControlSet\\Services\\Wins\\Partners\\Pull")
#define  _WINS_CFG_PUSH_KEY              TEXT("System\\CurrentControlSet\\Services\\Wins\\Partners\\Push")
#define  WINSCNF_ONLY_DYN_RECS_NM           TEXT("OnlyDynRecs")

#define  _NBT_CFG_ADAPTERS_KEY              TEXT("System\\CurrentControlSet\\Services\\NetBT\\Adapters")

#define  RPL_E_PULL 0
#define  RPL_E_PUSH 1

#define RE_QUERY_REGISTRY_COUNT 10

#define MAX_NB_NAMES 1000
#define MAX_SERVERS  1000
#define BUFF_SIZE    650

#define MY_PRINT0(_continuous, _str) { \
    MY_FPRINT(_continuous, _str); \
    }

#define MY_PRINT1(_continuous, _str, _v1) { \
    UCHAR   __str[500]; \
    sprintf(__str, _str, _v1); \
    MY_FPRINT(_continuous, __str); \
    }

#define MY_PRINT2(_continuous, _str, _v1, _v2) { \
    UCHAR   __str[500]; \
    sprintf(__str, _str, _v1, _v2); \
    MY_FPRINT(_continuous, __str); \
    }

#define MY_PRINT3(_continuous, _str, _v1, _v2, _v3) { \
    UCHAR   __str[500]; \
    sprintf(__str, _str, _v1, _v2, _v3); \
    MY_FPRINT(_continuous, __str); \
    }

#define MY_PRINT4(_continuous, _str, _v1, _v2, _v3, _v4) { \
    UCHAR   __str[500]; \
    sprintf(__str, _str, _v1, _v2, _v3, _v4); \
    MY_FPRINT(_continuous, __str); \
    }

#define MY_FPRINT(_continuous, __str_) \
    if (_continuous) { \
        fprintf (fp1, __str_); \
    } else { \
        fprintf (fp, __str_); \
        if (Interactive) { \
            printf (__str_);  \
        }\
    }

typedef struct  _PUSH_PULL_ENTRY {
    ULONG   PE_IpAddr;
    UCHAR   PE_Name[MAX_PATH_LEN];
    struct  _PUSH_PULL_ENTRY *PE_Next;
} PUSH_PULL_ENTRY, *PPUSH_PULL_ENTRY;

typedef struct  _NODE_INFO {
    ULONG   NI_IpAddr;
    UCHAR   NI_Name[MAX_PATH_LEN];
    PPUSH_PULL_ENTRY   NI_Lists[2]; // 0 - RPL_E_PULL - PULL list; 1 - RPL_E_PUSH - PUSH list
    struct  _NODE_INFO  *NI_Next;
    struct  _NODE_INFO  *NI_DoneNext;
} NODE_INFO, *PNODE_INFO;

PNODE_INFO   GlobalListHead=NULL;
PNODE_INFO   GlobalListTail=NULL;
PNODE_INFO   GlobalDoneListHead=NULL;
PNODE_INFO   GlobalDoneListTail=NULL;

ULONG   LocalIpAddress;
CHAR    pScope[128];

#define PUSH_BUT_NOT_PULL_LOCAL 0
#define PULL_BUT_NOT_PUSH 1
#define PUSH_BUT_NOT_PULL 2
#define PULL_BUT_NOT_PUSH_LOCAL 3

#define MAX_WINS    1000

//
// <Server> - <Owner> Table - [SO] Table
//
//LARGE_INTEGER    SO_Table[MAX_WINS][MAX_WINS];
LARGE_INTEGER   **SO_Table = NULL;

//
// Lookaside table to map IP addrs to the index into the SO_Table
//


UCHAR   LA_Table[MAX_WINS][20];
ULONG   LA_TableSize;

#define ME_PULL 0x1
#define ME_PUSH 0x2

//
// Push/Pull matrix
//
typedef struct _MATRIX_ENTRY {
    BOOLEAN ME_Down;        // 0 - UP; 1 - Down
    USHORT  ME_Entry;       // 1 - Pull; 2 - Push
} MATRIX_ENTRY, *PMATRIX_ENTRY;

MATRIX_ENTRY   PP_Matrix[MAX_WINS][MAX_WINS];

VOID
DumpSOTable(
    IN DWORD    MasterOwners,
    IN BOOL     fFile,
    IN FILE *   pFile
    );

VOID
DumpLATable(
    IN DWORD    MasterOwners,
    IN BOOL     fFile,
    IN FILE  *  pFile
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\netsh\dump.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/
#include "precomp.h"
#include "strdefs.h"


DWORD
WinsDumpServer(IN LPCWSTR              pwszServerIp,
               IN LPCWSTR              pwszNetBiosName,
               IN handle_t             hBind,
               IN WINSINTF_BIND_DATA_T BindData
              )
{
    DWORD           Status = NO_ERROR;
    HKEY            hServer = NULL,
                    hWins = NULL,
                    hParameter = NULL,
                    hDefault = NULL,
                    hDefaultPull = NULL,
                    hDefaultPush = NULL,
                    hPartner = NULL,
                    hCheck = NULL,
                    hPullPart = NULL,
                    hPushPart = NULL;

    DWORD           dwType = 0,
                    dwSize = 1024*sizeof(WCHAR),
                    dwData = 0;

    LPWSTR          pwszData = NULL,
                    pTemp = NULL;

    WCHAR           wcData[1024] = {L'\0'};
    BOOL            fBackDir = TRUE;

    Status = RegConnectRegistry(pwszNetBiosName,
                                HKEY_LOCAL_MACHINE,
                                &hServer);

    if( Status isnot NO_ERROR )
    {
        goto RETURN;
    }

    Status = RegOpenKeyEx(hServer,
                          PARAMETER,
                          0,
                          KEY_READ,//KEY_ALL_ACCESS,
                          &hParameter);

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegOpenKeyEx(hServer,
                          PARTNERROOT,
                          0,
                          KEY_READ, //KEY_ALL_ACCESS,
                          &hPartner);

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegOpenKeyEx(hServer,
                          PULLROOT,
                          0,
                          KEY_READ, //KEY_ALL_ACCESS,
                          &hPullPart);

    if( Status isnot NO_ERROR )
        goto RETURN;



    Status = RegOpenKeyEx(hServer,
                          PUSHROOT,
                          0,
                          KEY_READ, //KEY_ALL_ACCESS,
                          &hPushPart);

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegOpenKeyEx(hServer,
                          DEFAULTPULL,
                          0,
                          KEY_READ, //KEY_ALL_ACCESS,
                          &hDefaultPull);

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegOpenKeyEx(hServer,
                          DEFAULTPUSH,
                          0,
                          KEY_READ, //KEY_ALL_ACCESS,
                          &hDefaultPush);

    if( Status isnot NO_ERROR )
        goto RETURN;

    //Set Backuppath, Display only when Backup path is set.

    Status = NO_ERROR;

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_BACKUP_DIR_PATH_NM,
                             NULL,
                             &dwType,
                             NULL,
                             &dwSize);

    
    if( Status is NO_ERROR and
        dwSize >= sizeof(WCHAR) )
    {
        pwszData = WinsAllocateMemory(dwSize);

        if( pwszData is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto RETURN;
        }

        Status = NO_ERROR;
    
        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_BACKUP_DIR_PATH_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)pwszData,
                                 &dwSize);
        
        if( Status isnot NO_ERROR )
        {
            if( pwszData )
            {
                WinsFreeMemory(pwszData);
                pwszData = NULL;
            }
            goto RETURN;
        }

        if( wcscmp(pwszData, L" ") is 0 or
            wcslen(pwszData) < 1 )
        {
            fBackDir = FALSE;
        }

        if( !ExpandEnvironmentStrings(pwszData, wcData, 1023) )
        {
            if( pwszData )
            {
                WinsFreeMemory(pwszData);
                pwszData = NULL;
            }
            Status = GetLastError();
            goto RETURN;
        }
    }
    else if( Status is ERROR_FILE_NOT_FOUND || 
             dwSize < sizeof(WCHAR) )
    {
        fBackDir = FALSE;
    }
    else if( Status isnot NO_ERROR ) 
    {
        goto RETURN;
    }
    else
    {
        fBackDir = FALSE;
    }
         

    dwSize = sizeof(DWORD);

    Status = NO_ERROR;

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_DO_BACKUP_ON_TERM_NM,
                             NULL,
                             &dwType,
                             (LPBYTE)&dwData,
                             &dwSize);

    if( Status isnot NO_ERROR )
        goto RETURN;

    if( dwData > 0 )
        dwData = 1;

    if( fBackDir )
    {
        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_BACKUPPATH,
                       pwszServerIp,
                       wcData,
                       dwData);
    }
    else
    {
        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_BACKUPTERM,
                       pwszServerIp,
                       dwData);
    }  

    memset(wcData, 0x00, 1024*sizeof(WCHAR));

    //Set Name record
    {

        WINSINTF_RESULTS_T      Results = {0};
        WINSINTF_RESULTS_NEW_T  ResultsN = {0};
        BOOL                    fNew = TRUE;
        

		ResultsN.WinsStat.NoOfPnrs = 0;
		ResultsN.WinsStat.pRplPnrs = NULL;
		ResultsN.NoOfWorkerThds = 1;

        Status = WinsStatusNew(g_hBind,
                               WINSINTF_E_CONFIG,
                               &ResultsN);

        if( Status is RPC_S_PROCNUM_OUT_OF_RANGE )
        {
            //Try old API
            Results.WinsStat.NoOfPnrs = 0;
            Results.WinsStat.pRplPnrs = 0;
            Status = WinsStatus(g_hBind, WINSINTF_E_CONFIG, &Results);
            fNew = FALSE;
        }
        
        if( Status is NO_ERROR )
        {
            if( fNew )
            {
                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_NAMERECORD,
                               pwszServerIp,
                               ResultsN.RefreshInterval,
                               ResultsN.TombstoneInterval,
                               ResultsN.TombstoneTimeout,
                               ResultsN.VerifyInterval);
                               
            }
            else
            {
                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_NAMERECORD,
                               pwszServerIp,
                               Results.RefreshInterval,
                               Results.TombstoneInterval,
                               Results.TombstoneTimeout,
                               Results.VerifyInterval);                
            }

        }
        else
        {
               DisplayMessage(g_hModule,
                               DMP_SRVR_SET_NAMERECORD,
                               pwszServerIp,
                               NAMERECORD_REFRESH_DEFAULT,
                               NAMERECORD_EXINTVL_DEFAULT,
                               NAMERECORD_EXTMOUT_DEFAULT,
                               NAMERECORD_VERIFY_DEFAULT);
        }

                            
    }


    //Set Periodic DB Checking 
    {
        DWORD   dwMaxRec = 30000,
                dwUseRpl = 0,
                dwTimeIntvl = 24,
                dwState = 0,
                dwStart = 2*60*60;        
        LPWSTR  pwcTemp = NULL;
        
        Status = NO_ERROR;
        
        Status = RegOpenKeyEx(hServer,
                              CCROOT,
                              0,
                              KEY_READ, //KEY_ALL_ACCESS,
                              &hCheck);

        if( Status is NO_ERROR )
        {
            dwState = 1;
            dwData = 0;
            dwSize = sizeof(DWORD);
        
            Status = RegQueryValueEx(hCheck,
                                     WINSCNF_CC_MAX_RECS_AAT_NM,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwSize);

            if( Status is NO_ERROR )
                dwMaxRec = dwData;

            dwData = 0;
            Status = RegQueryValueEx(hCheck,
                                     WINSCNF_CC_USE_RPL_PNRS_NM,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwSize);

            if( Status is NO_ERROR )
                dwUseRpl = dwData;

            if( dwUseRpl > 1 )
                dwUseRpl = 1;

            dwData = 0;
            Status = RegQueryValueEx(hCheck,
                                     WINSCNF_CC_INTVL_NM,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwSize);

            if( Status is NO_ERROR )
            {
                dwTimeIntvl = dwData/(60*60);
            }
            
            dwSize = 1024*sizeof(WCHAR);

            Status = RegQueryValueEx(hCheck,
                                     WINSCNF_SP_TIME_NM,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)&wcData,
                                     &dwSize);

            if( Status is NO_ERROR )
            {
                WCHAR wcHr[3] = {L'\0'},
                      wcMt[3] = {L'\0'},
                      wcSc[3] = {L'\0'};

                wcsncpy(wcHr, wcData, 2);

                wcsncpy(wcMt, wcData+3, 2);
                wcsncpy(wcSc, wcData+6, 2);

                dwStart = wcstoul(wcHr, NULL, 10)*60*60 + 
                          wcstoul(wcMt, NULL, 10)*60 + 
                          wcstoul(wcSc, NULL, 10);
            }

        }

        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_PERIODICDBCHECKING,
                       pwszServerIp,
                       dwState,
                       dwMaxRec,
                       dwUseRpl,
                       dwTimeIntvl,
                       dwStart);

        if( hCheck )
        {
            RegCloseKey(hCheck);
            hCheck = NULL;
        }
    }
    
    //Set replicate flag
    dwSize = sizeof(DWORD);
    dwData = 0;
    
    Status = NO_ERROR;
    
    Status = RegQueryValueEx(hParameter,
                             WINSCNF_RPL_ONLY_W_CNF_PNRS_NM,
                             NULL,
                             &dwType,
                             (LPBYTE)&dwData,
                             &dwSize);
    
    if( Status isnot NO_ERROR )
    {
        dwData = 0;
    }
    
    if( dwData > 1 )
        dwData = 1;

    DisplayMessage(g_hModule,
                   DMP_SRVR_SET_REPLICATEFLAG,
                   pwszServerIp,
                   dwData);

    //Set Migrate flag
    dwSize = sizeof(DWORD);
    dwData = 0;

    Status = NO_ERROR;

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_MIGRATION_ON_NM,
                             NULL,
                             &dwType,
                             (LPBYTE)&dwData,
                             &dwSize);
    
    if( Status isnot NO_ERROR )
    {
        dwData = 0;
    }
    
    if( dwData > 1 )
        dwData = 1;

    DisplayMessage(g_hModule,
                   DMP_SRVR_SET_MIGRATEFLAG,
                   pwszServerIp,
                   dwData);

    //Set PullParam
    {
        DWORD   dwState = 0,
                dwStartUp = 0,
                dwStart = 0,
                dwRepIntvl = 0,
                dwRetry = 0;

        Status = NO_ERROR;

        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hDefaultPull,
                                 WINSCNF_RPL_INTERVAL_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
           dwRepIntvl = dwData;

        dwSize = 1024*sizeof(WCHAR);

        Status = RegQueryValueEx(hDefaultPull,
                                 WINSCNF_SP_TIME_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)wcData,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            WCHAR wcHr[3] = {L'\0'},
                  wcMt[3] = {L'\0'},
                  wcSc[3] = {L'\0'};

            wcsncpy(wcHr, wcData, 2);

            wcsncpy(wcMt, wcData+3, 2);
            wcsncpy(wcSc, wcData+6, 2);
            dwStart = wcstoul(wcHr, NULL, 10)*60*60 + 
                      wcstoul(wcMt, NULL, 10)*60 + 
                      wcstoul(wcSc, NULL, 10);
        }

        dwSize = sizeof(DWORD);
        dwData = 0;

        Status = RegQueryValueEx(hPullPart,
                                 PERSISTENCE,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            dwState = dwData;
        }

        if( dwState > 1 )
            dwState = 1;

        dwData = 0;
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hPullPart,
                                 WINSCNF_RETRY_COUNT_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);
        
        if(Status is NO_ERROR )
        {
            dwRetry = dwData;
        }

        dwData = 0;
        dwSize = sizeof(DWORD);
        Status = RegQueryValueEx(hPullPart,
                                 WINSCNF_INIT_TIME_RPL_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            dwStartUp = dwData;
        }

        if( dwStartUp > 1 )
            dwStartUp = 1;

        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_PULLPARAM,
                       pwszServerIp,
                       dwState,
                       dwStartUp,
                       dwStart,
                       dwRepIntvl,
                       dwRetry);

    }
    

    //Set PushParam
    {
        DWORD   dwState = 0,
                dwAddChng = 0,
                dwStartUp = 0,
                dwUpdate = 0;
        
        dwData = 0;
        dwSize = sizeof(DWORD);

        Status = NO_ERROR;
    
        Status = RegQueryValueEx(hDefaultPush,
                                 WINSCNF_UPDATE_COUNT_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
            dwUpdate = dwData;

        dwData = 0;
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hPushPart,
                                 WINSCNF_INIT_TIME_RPL_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
            dwStartUp = dwData;

        if( dwStartUp > 1 )
            dwStartUp = 1;

        dwSize = sizeof(DWORD);
        dwData = 0;

        Status = RegQueryValueEx(hPushPart,
                                 PERSISTENCE,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            dwState = dwData;
        }

        if( dwState > 1 )
            dwState = 1;


        dwData = 0;
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hPushPart,
                                 WINSCNF_ADDCHG_TRIGGER_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
            dwAddChng = dwData;

        if( dwAddChng > 1 )
        {
            dwAddChng = 1;
        }

        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_PUSHPARAM,
                       pwszServerIp,
                       dwState,
                       dwStartUp,
                       dwAddChng,
                       dwUpdate);
    }

    //Add PNG Server List
    while( TRUE )
    {
        LPBYTE  pbData = NULL;
        DWORD   dwCount = 0,
                dw = 0;

        Status = NO_ERROR;

        Status = RegQueryValueEx(hPartner,
                                 WinsOemToUnicode(WINSCNF_PERSONA_NON_GRATA_NM, NULL),
                                 NULL,
                                 &dwType,
                                 pbData,
                                 &dwSize);

        if( Status isnot NO_ERROR )
            break;

        if( dwSize < 7 )
            break;

        pbData = WinsAllocateMemory(dwSize);
    
        if( pbData is NULL )
            break;

        Status = RegQueryValueEx(hPartner,
                                 WinsOemToUnicode(WINSCNF_PERSONA_NON_GRATA_NM, NULL),
                                 NULL,
                                 &dwType,
                                 pbData,
                                 &dwSize);
        if( Status isnot NO_ERROR )
        {
            WinsFreeMemory(pbData);
            pbData = NULL;
            break;
        }

        pTemp = (LPWSTR)pbData;

        for( dw=0; dw<dwSize/sizeof(WCHAR); dw++ )
        {
            if( pTemp[dw] is L'\0' and
                pTemp[dw+1] isnot L'\0' )
            {
                pTemp[dw] = L',';
            }
        }

        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_PGMODE,
                       pwszServerIp,
                       PERSMODE_NON_GRATA);

        DisplayMessage(g_hModule,
                       DMP_SRVR_ADD_PNGSERVER,
                       pwszServerIp,
                       pTemp);

        WinsFreeMemory(pbData);
        pbData = NULL;

        break;
    }

    //Add PG Server List
    while( TRUE )
    {
        LPBYTE  pbData = NULL;
        DWORD   dwCount = 0,
                dw = 0;

        Status = NO_ERROR;

        Status = RegQueryValueEx(hPartner,
                                 WinsOemToUnicode(WINSCNF_PERSONA_GRATA_NM, NULL),
                                 NULL,
                                 &dwType,
                                 pbData,
                                 &dwSize);

        if( Status isnot NO_ERROR )
            break;

        if( dwSize < 7 )
            break;

        pbData = WinsAllocateMemory(dwSize);
    
        if( pbData is NULL )
            break;

        Status = RegQueryValueEx(hPartner,
                                 WinsOemToUnicode(WINSCNF_PERSONA_GRATA_NM, NULL),
                                 NULL,
                                 &dwType,
                                 pbData,
                                 &dwSize);
        if( Status isnot NO_ERROR )
        {
            WinsFreeMemory(pbData);
            pbData = NULL;
            break;
        }

        pTemp = (LPWSTR)pbData;

        for( dw=0; dw<dwSize/sizeof(WCHAR); dw++ )
        {
            if( pTemp[dw] is L'\0' and
                pTemp[dw+1] isnot L'\0' )
            {
                pTemp[dw] = L',';
            }
        }

        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_PGMODE,
                       pwszServerIp,
                       PERSMODE_GRATA);

        DisplayMessage(g_hModule,
                       DMP_SRVR_ADD_PGSERVER,
                       pwszServerIp,
                       pTemp);

        WinsFreeMemory(pbData);
        pbData = NULL;

        break;
    }

    //Set the PGMode
    {
        DWORD   dwPGMode = PERSMODE_NON_GRATA;

        Status = NO_ERROR;

        dwSize = sizeof(DWORD);
        Status = RegQueryValueEx(hPartner,
                                 WinsOemToUnicode(WINSCNF_PERSONA_MODE_NM, NULL),
                                 NULL,
                                 &dwType,
                                 (LPVOID)&dwPGMode,
                                 &dwSize);

        if (dwPGMode != PERSMODE_GRATA)
            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_PGMODE,
                           pwszServerIp,
                           dwPGMode);
    }

    //Set AutoPartner config
    {
        DWORD   dwState = 0,
                dwInterval = 0,
                dwTTL = 2;

        dwData = 0;
        dwSize = sizeof(DWORD);

        Status = NO_ERROR;

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_USE_SELF_FND_PNRS_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            dwState = dwData;
        }
        if( dwState > 1 )
            dwState = 0;

        dwData = 0;
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_MCAST_TTL_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
            dwTTL = dwData;

        dwData = 0;
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_MCAST_INTVL_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);


        if( Status is NO_ERROR )
            dwInterval = dwData;

        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_AUTOPARTNERCONFIG,
                       pwszServerIp,
                       dwState,
                       dwInterval,
                       dwTTL);
        
    }

    Status = NO_ERROR;
    //Set Burst Handling parameters
    {
        DWORD    dwState = 0;
        
        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_BURST_HANDLING_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwState,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            dwSize = sizeof(DWORD);

            Status = RegQueryValueEx(hParameter,
                                     WINSCNF_BURST_QUE_SIZE_NM,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwSize);

            if( Status isnot NO_ERROR )
            {
                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_BURSTPARAM,
                               pwszServerIp,
                               dwState);
            }
            else
            {
                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_BURSTPARAM_ALL,
                               pwszServerIp,
                               dwState,
                               dwData);
            }

        }
        else
        {
            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_BURSTPARAM,
                           pwszServerIp,
                           dwState);
        }

    }

    Status = NO_ERROR;

    //Set Log Parameter
    {
        DWORD   dwLog = 0;
        
        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);
        dwData = 0;

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_LOG_FLAG_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwLog,
                                 &dwSize);

        
        dwSize = sizeof(DWORD);
        dwType = REG_DWORD;

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_LOG_DETAILED_EVTS_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_LOGPARAM,
                       pwszServerIp,
                       dwLog,
                       dwData);

    }
    
    Status = NO_ERROR;

    //Start Version count
    {
        DWORD   dwHigh = 0;
        dwData = 0;
        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_INIT_VERSNO_VAL_HW_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwHigh,
                                 &dwSize);

        if( Status isnot NO_ERROR )
            dwHigh = 0;

        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_INIT_VERSNO_VAL_LW_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);
        
        if( Status isnot NO_ERROR )
            dwData = 0;

        DisplayMessage(g_hModule,
                       DMP_SRVR_SET_STARTVERSION,
                       pwszServerIp,
                       dwHigh,
                       dwData);

    }

    Status = NO_ERROR;
    //For all partners, set PullPersistentConnections
    {
        DWORD    i, dwSubKey = 0;
        HKEY     hKey = NULL;
        WCHAR    wcIp[MAX_IP_STRING_LEN+1] = {L'\0'};
        DWORD    dwBuffer = MAX_IP_STRING_LEN+1;

        Status = NO_ERROR;

        while( TRUE )
        {
            Status = RegQueryInfoKey(hPullPart,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &dwSubKey,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);

            if( Status isnot NO_ERROR )
                break;

            if ( dwSubKey is 0 )
                break;

            for( i=0; i<dwSubKey; i++ )
            {
                DWORD   dwState = 0,
                        dwIntvl = 0,
                        dwStart = 0;
                
                dwBuffer = MAX_IP_STRING_LEN+1;

                dwSize = sizeof(DWORD);
                
                dwData = 0;

                Status = RegEnumKeyEx(hPullPart,
                                      i,
                                      wcIp,
                                      &dwBuffer,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL);

                if( Status isnot NO_ERROR )
                    continue;
                
                DisplayMessage(g_hModule,
                               DMP_SRVR_ADD_PARTNER,
                               pwszServerIp,
                               wcIp,
                               0);

                Status = RegOpenKeyEx(hPullPart,
                                      wcIp,
                                      0,
                                      KEY_READ, //KEY_ALL_ACCESS,
                                      &hKey);

                if( Status isnot NO_ERROR )
                    continue;
                
                Status = RegQueryValueEx(hKey,
                                         PERSISTENCE,
                                         NULL,
                                         &dwType,
                                         (LPBYTE)&dwData,
                                         &dwSize);

                if( Status isnot NO_ERROR )
                {
                    Status = RegQueryValueEx(hPullPart,
                                             PERSISTENCE,
                                             NULL,
                                             &dwType,
                                             (LPBYTE)&dwData,
                                             &dwSize);
                }

                if( Status is NO_ERROR )
                {
                    dwState = dwData;
                    if( dwState > 1 )
                        dwState = 1;
                }

                dwData = 0;
                dwSize = sizeof(DWORD);

                Status = RegQueryValueEx(hKey,
                                         WINSCNF_RPL_INTERVAL_NM,
                                         NULL,
                                         &dwType,
                                         (LPBYTE)&dwData,
                                         &dwSize);

                if( Status isnot NO_ERROR )
                {
                    Status = RegQueryValueEx(hDefaultPull,
                                             WINSCNF_RPL_INTERVAL_NM,
                                             NULL,
                                             &dwType,
                                             (LPBYTE)&dwData,
                                             &dwSize);

                }
                
                if( Status is NO_ERROR )
                {
                    dwIntvl = dwData;
                }

                dwSize = 1024*sizeof(WCHAR);

                Status = RegQueryValueEx(hKey,
                                         WINSCNF_SP_TIME_NM,
                                         NULL,
                                         &dwType,
                                         (LPBYTE)wcData,
                                         &dwSize);

                if( Status isnot NO_ERROR )
                {
                    dwSize = 1024*sizeof(WCHAR);

                    Status = RegQueryValueEx(hDefaultPull,
                                             WINSCNF_SP_TIME_NM,
                                             NULL,
                                             &dwType,
                                             (LPBYTE)wcData,
                                             &dwSize);
                }
                
                if( Status is NO_ERROR )
                {
                    WCHAR wcHr[3] = {L'\0'},
                          wcMt[3] = {L'\0'},
                          wcSc[3] = {L'\0'};

                    wcsncpy(wcHr, wcData, 2);

                    wcsncpy(wcMt, wcData+3, 2);
                    wcsncpy(wcSc, wcData+6, 2);
                    dwStart = wcstoul(wcHr, NULL, 10)*60*60 + 
                              wcstoul(wcMt, NULL, 10)*60 + 
                              wcstoul(wcSc, NULL, 10);
                }

                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_PULLPERSISTENTCONNECTION,
                               pwszServerIp,
                               dwState,
                               wcIp,
                               dwStart,
                               dwIntvl);

                RegCloseKey(hKey);
                hKey = NULL;
            }
            break;
        }
    }

    //Set PushPersistentConnection
    {
        DWORD    i, dwSubKey = 0;
        HKEY     hKey = NULL;
        WCHAR    wcIp[MAX_IP_STRING_LEN+1] = {L'\0'};
        DWORD    dwBuffer = MAX_IP_STRING_LEN+1;

        Status = NO_ERROR;

        while( TRUE )
        {
            Status = RegQueryInfoKey(hPushPart,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &dwSubKey,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);

            if( Status isnot NO_ERROR )
                break;

            if ( dwSubKey is 0 )
                break;

            for( i=0; i<dwSubKey; i++ )
            {
                DWORD   dwState = 0,
                        dwUpdate = 0;

                dwBuffer = MAX_IP_STRING_LEN+1;
                dwSize = sizeof(DWORD);
                dwData = 0;

                Status = RegEnumKeyEx(hPushPart,
                                      i,
                                      wcIp,
                                      &dwBuffer,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL);

                if( Status isnot NO_ERROR )
                    continue;
                
                DisplayMessage(g_hModule,
                               DMP_SRVR_ADD_PARTNER,
                               pwszServerIp,
                               wcIp,
                               1);

                Status = RegOpenKeyEx(hPushPart,
                                      wcIp,
                                      0,
                                      KEY_READ, //KEY_ALL_ACCESS,
                                      &hKey);

                if( Status isnot NO_ERROR )
                    continue;
                
                Status = RegQueryValueEx(hKey,
                                         PERSISTENCE,
                                         NULL,
                                         &dwType,
                                         (LPBYTE)&dwData,
                                         &dwSize);

                if( Status isnot NO_ERROR )
                {
                    Status = RegQueryValueEx(hPushPart,
                                             PERSISTENCE,
                                             NULL,
                                             &dwType,
                                             (LPBYTE)&dwData,
                                             &dwSize);
                }

                if( Status is NO_ERROR )
                {
                    dwState = dwData;
                    if( dwState > 1 )
                        dwState = 1;
                }

                dwData = 0;
                dwSize = sizeof(DWORD);

                Status = RegQueryValueEx(hKey,
                                         WINSCNF_UPDATE_COUNT_NM,
                                         NULL,
                                         &dwType,
                                         (LPBYTE)&dwData,
                                         &dwSize);

                if( Status isnot NO_ERROR )
                {
                    Status = RegQueryValueEx(hDefaultPush,
                                             WINSCNF_UPDATE_COUNT_NM,
                                             NULL,
                                             &dwType,
                                             (LPBYTE)&dwData,
                                             &dwSize);

                }
                
                if( Status is NO_ERROR )
                {
                    dwUpdate = dwData;
                }


                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_PUSHPERSISTENTCONNECTION,
                               pwszServerIp,
                               dwState,
                               wcIp,
                               dwUpdate);

                RegCloseKey(hKey);
                hKey = NULL;
            }
            break;
        }

        if( Status is 2 )
            Status = NO_ERROR;

    }


RETURN:
    
    if( pwszData )
    {
        WinsFreeMemory(pwszData);
        pwszData = NULL;
    }

    if( hPushPart )
    {
        RegCloseKey(hPushPart);
        hPushPart = NULL;
    }

    if( hPullPart )
    {
        RegCloseKey(hPullPart);
        hPullPart = NULL;
    }

    if( hPartner )
    {
        RegCloseKey(hPartner);
        hPartner = NULL;
    }

    if( hCheck )
    {
        RegCloseKey(hCheck);
        hCheck = NULL;
    }
    
    if( hDefault )
    {
        RegCloseKey(hDefault);
        hDefault = NULL;
    }

    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( hWins )
    {
        RegCloseKey(hWins);
        hWins = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }
    return Status;
}


DWORD
WINAPI
WinsDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    DWORD                   Status = NO_ERROR;
    
    WCHAR                   wcServerIp[MAX_IP_STRING_LEN+1] = {L'\0'};
    CHAR                    cServerIp[MAX_IP_STRING_LEN+1] = {'\0'};
    LPWSTR                  pwcServerName = NULL;
    WCHAR                   wcNetBios[MAX_COMPUTER_NAME_LEN+1] = {L'\0'};
    struct hostent *        lpHostEnt = NULL;         
    
    handle_t                hServer = NULL;
    WINSINTF_BIND_DATA_T    BindData={0};

    LPWSTR                  pwszComputerName = NULL;
    LPSTR                   pszComputerName = NULL,
                            pTemp = NULL,
                            pTemp1 = NULL;

    DWORD                   dwComputerNameLen = 0,
                            dwTempLen = 0,
                            nLen = 0, i = 0;
    BYTE                    pbAdd[4] = {0x00};
    char                    szAdd[4] = {'\0'};
    DWORD                   Access = 0;

    wcNetBios[0] = L'\\';
    wcNetBios[1] = L'\\';

    if( !GetComputerNameEx(ComputerNameDnsFullyQualified,
                          NULL,
                          &dwComputerNameLen) )
    {
        
        pwszComputerName = WinsAllocateMemory((dwComputerNameLen+1)*sizeof(WCHAR));

        if(pwszComputerName is NULL)
        {
            return FALSE;
        }
        
        dwComputerNameLen++;
        if( !GetComputerNameEx(ComputerNameDnsFullyQualified,
                               pwszComputerName,
                               &dwComputerNameLen) )
        {
            WinsFreeMemory(pwszComputerName);
            pwszComputerName = NULL;
            return GetLastError();
        }

    }
    else
    {
        return GetLastError();
    }
 
    //Now process the Computer name and convert it to ANSI because
    //gethostbyname requires ANSI character string.

    //pszComputerName = WinsUnicodeToOem(pwszComputerName, NULL);
    pszComputerName = WinsUnicodeToAnsi(pwszComputerName, NULL);
    if( pszComputerName is NULL )
        return ERROR_NOT_ENOUGH_MEMORY;
    
    //Now get the server IP Address
    lpHostEnt = gethostbyname(pszComputerName);

    //Not a valid server name
    if( lpHostEnt is NULL )
    {
        DisplayMessage(g_hModule, EMSG_WINS_INVALID_COMPUTERNAME);
        if( pszComputerName )
        {
            WinsFreeMemory(pszComputerName);
            pszComputerName = NULL;
        }
        return WSAGetLastError();        
    }

    //Get the IP Address from the returned struct...
    memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
    nLen = 0;
    for( i=0; i<4; i++)
    {

        _itoa((int)pbAdd[i], szAdd, 10);
        memcpy(cServerIp+nLen, szAdd, strlen(szAdd));
        nLen += strlen(szAdd);
        *(cServerIp+nLen) = '.';
        nLen++;
    
    }
    *(cServerIp+nLen-1) = '\0';

    {
        LPWSTR pwstrServerIp;

        pwstrServerIp = WinsAnsiToUnicode(cServerIp, NULL);
        if (pwstrServerIp == NULL)
            return ERROR_NOT_ENOUGH_MEMORY;

        wcscpy(wcServerIp, pwstrServerIp);
        wcscpy(wcNetBios+2, wcServerIp);
        WinsFreeMemory(pwstrServerIp);
    }

    if(pTemp1)
    {
        WinsFreeMemory(pTemp1);
        pTemp1 = NULL;
    }

    pwcServerName = WinsAllocateMemory((strlen(lpHostEnt->h_name) + 1)*sizeof(WCHAR));

    if( pwcServerName is NULL ) 
    {
        if( pszComputerName )
        {
            WinsFreeMemory(pszComputerName);
            pszComputerName = NULL;
        }
        if( pwszComputerName )
        {
            WinsFreeMemory(pwszComputerName);
            pwszComputerName = NULL;
        }
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if( pszComputerName )
    {
        WinsFreeMemory(pszComputerName);
        pszComputerName = NULL;
    }
    if( pwszComputerName )
    {
        WinsFreeMemory(pwszComputerName);
        pwszComputerName = NULL;
    }
    
    wcscpy(pwcServerName, WinsOemToUnicode(lpHostEnt->h_name, NULL));

    //Bind the server
    BindData.fTcpIp = TRUE;
    BindData.pServerAdd = (LPBYTE)wcServerIp;
    BindData.pPipeName = (LPBYTE)pwcServerName;
    hServer = WinsBind(&BindData);

    if (hServer is NULL)
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_BIND_FAILED,
                       pwcServerName);
        WinsFreeMemory(pwcServerName);
        pwcServerName = NULL;
        return ERROR_INVALID_PARAMETER;

    }
   
    //find out what type of access do we have
    Access = WINS_NO_ACCESS;
    Status = WinsCheckAccess(hServer, &Access);

    if (WINSINTF_SUCCESS == Status) 
    {
        DisplayMessage(g_hModule, 
                       MSG_WINS_ACCESS,
                       (Access ? (Access == WINS_CONTROL_ACCESS ? wszReadwrite : wszRead)
                        : wszNo),
                       pwcServerName);
        if( Access is WINS_NO_ACCESS )
        {
            WinsUnbind(&BindData, hServer);
            hServer = NULL;
        }
    }
    else
    {
        DisplayErrorMessage(EMSG_WINS_GETSTATUS_FAILED,
                            Status);
        WinsFreeMemory(pwcServerName);
        pwcServerName = NULL;
        return Status;
    }

    //Now dump the configuration information for this server.

    Status = WinsDumpServer(wcServerIp,
                            wcNetBios,
                            hServer,
                            BindData);

    DisplayMessage(g_hModule,
                   WINS_FORMAT_LINE);


    WinsFreeMemory(pwcServerName);
    pwcServerName = NULL;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\netsh\common.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    common.c

Abstract:

    This module contains miscellaneous utility routines used by the
    DHCP server service. Code is hacked from convert.c

Author:

    Shubho Bhattacharya (a-sbhatt) 11/17/98

Revision History:

   

--*/

#include <precomp.h>

WCHAR    *messages[] = {
                        L"success",
                        L"name not found",
                        L"no response",
                        L"out of memory",
                        L"bad ip address",
                        L"host not found",
                        L"host address not verified",
                        L"invalid argument",
                        L"failed to open NBT driver"
                     };

SOCKET  sd;
WSADATA WsaData;

u_long NonBlocking = 1;

int     NumWinServers=0;
int     NumNBNames=0;

LPWSTR
WinsAnsiToUnicode(
    IN      LPCSTR Ansi,
    IN OUT  LPWSTR Unicode
    )
{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitString( &AnsiString, Ansi );

    UnicodeString.MaximumLength = 
        (USHORT)RtlAnsiStringToUnicodeSize( &AnsiString );

    if( Unicode == NULL ) {
        UnicodeString.Buffer =
            WinsAllocateMemory( UnicodeString.MaximumLength );
    }
    else {
        UnicodeString.Buffer = Unicode;
    }

    if ( UnicodeString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlAnsiStringToUnicodeString( &UnicodeString,
                                                  &AnsiString,
                                                  FALSE))){
        if( Unicode == NULL ) {
            WinsFreeMemory( UnicodeString.Buffer );
            UnicodeString.Buffer = NULL;
        }
        return NULL;
    }

    return UnicodeString.Buffer;
}

LPSTR
WinsUnicodeToAnsi(
    IN      LPCWSTR  Unicode,
    IN OUT  LPSTR   Ansi
)
{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, Unicode );

    AnsiString.MaximumLength =
        (USHORT) RtlUnicodeStringToAnsiSize( &UnicodeString );

    if( Ansi == NULL ) 
    {
        AnsiString.Buffer = WinsAllocateMemory( AnsiString.MaximumLength ); 
    }
    else 
    {
        AnsiString.Buffer = Ansi;
    }

    if ( AnsiString.Buffer == NULL ) 
    {
        return NULL;
    }

    if(!NT_SUCCESS( RtlUnicodeStringToAnsiString( &AnsiString,
                                                  &UnicodeString,
                                                  FALSE))){
        if( Ansi == NULL ) {
            WinsFreeMemory( AnsiString.Buffer );
            AnsiString.Buffer = NULL;
        }

        return NULL;
    }

    return AnsiString.Buffer;
}

LPSTR
WinsAnsiToOem(
    IN      LPCSTR   Ansi
    )
{
    LPSTR   Oem = NULL;
    LPWSTR  Unicode = NULL;

    Unicode = WinsAnsiToUnicode(Ansi, NULL);

    if( Unicode is NULL )
        return NULL;

    Oem = WinsUnicodeToOem(Unicode, NULL);

    WinsFreeMemory(Unicode);
    Unicode = NULL;

    return Oem;

}

LPWSTR
WinsOemToUnicodeN(
    IN      LPCSTR   Ansi,
    IN OUT  LPWSTR  Unicode,
    IN      USHORT  cChars
    )
{

    
    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitString( &AnsiString, Ansi );

    UnicodeString.MaximumLength =
        cChars;

    if( Unicode == NULL ) {
        UnicodeString.Buffer =
            WinsAllocateMemory( UnicodeString.MaximumLength );
    }
    else {
        UnicodeString.Buffer = Unicode;
    }

    if ( UnicodeString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlOemStringToUnicodeString( &UnicodeString,
                                                  &AnsiString,
                                                  FALSE))){
        if( Unicode == NULL ) {
            WinsFreeMemory( UnicodeString.Buffer );
            UnicodeString.Buffer = NULL;
        }
        return NULL;
    }

    return UnicodeString.Buffer;
}



LPWSTR
WinsOemToUnicode(
    IN      LPCSTR Ansi,
    IN OUT  LPWSTR Unicode
    )
{
    OEM_STRING  AnsiString;

    RtlInitString( &AnsiString, Ansi );

    return WinsOemToUnicodeN(
                Ansi,
                Unicode,
                (USHORT) RtlOemStringToUnicodeSize( &AnsiString )
                );
}

/*++

Routine Description:

    Convert an OEM (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Ansi - Specifies the ASCII zero terminated string to convert.

    Unicode - Specifies the pointer to the unicode buffer. If this
        pointer is NULL then this routine allocates buffer using
        DhcpAllocateMemory and returns. The caller should freeup this
        memory after use by calling DhcpFreeMemory.

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer can be freed using DhcpFreeMemory.

--*/



LPSTR
WinsUnicodeToOem(
    IN     LPCWSTR Unicode,
    IN OUT LPSTR   Ansi
    )

/*++

Routine Description:

    Convert an UNICODE (zero terminated) string to the corresponding OEM
    string.

Arguments:

    Ansi - Specifies the UNICODE zero terminated string to convert.

    Ansi - Specifies the pointer to the oem buffer. If this
        pointer is NULL then this routine allocates buffer using
        DhcpAllocateMemory and returns. The caller should freeup this
        memory after use by calling DhcpFreeMemory.

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated OEM string in
    an allocated buffer.  The buffer can be freed using DhcpFreeMemory.

--*/

{

    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, Unicode );

    AnsiString.MaximumLength =
        (USHORT) RtlUnicodeStringToOemSize( &UnicodeString );

    if( Ansi == NULL ) 
    {
        AnsiString.Buffer = WinsAllocateMemory( AnsiString.MaximumLength ); 
    }
    else 
    {
        AnsiString.Buffer = Ansi;
    }

    if ( AnsiString.Buffer == NULL ) 
    {
        return NULL;
    }

    if(!NT_SUCCESS( RtlUnicodeStringToOemString( &AnsiString,
                                                  &UnicodeString,
                                                  FALSE))){
        if( Ansi == NULL ) {
            WinsFreeMemory( AnsiString.Buffer );
            AnsiString.Buffer = NULL;
        }

        return NULL;
    }

    return AnsiString.Buffer;

}



VOID
WinsHexToString(
    OUT LPWSTR Buffer,
    IN  const BYTE * HexNumber,
    IN  DWORD Length
    )
/*++

Routine Description:

    This functions converts are arbitrary length hex number to a Unicode
    string.  The string is not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least Length * 2 characters in size.

    HexNumber - The hex number to convert.

    Length - The length of HexNumber, in bytes.


Return Value:

    None.

--*/
{
    DWORD i;
    int j;

    for (i = 0; i < Length * 2; i+=2 ) {

        j = *HexNumber & 0xF;
        if ( j <= 9 ) {
            Buffer[i+1] = j + L'0';
        } else {
            Buffer[i+1] = j + L'A' - 10;
        }

        j = *HexNumber >> 4;
        if ( j <= 9 ) {
            Buffer[i] = j + L'0';
        } else {
            Buffer[i] = j + L'A' - 10;
        }

        HexNumber++;
    }

    return;
}



VOID
WinsHexToAscii(
    OUT LPSTR Buffer,
    IN  const BYTE * HexNumber,
    IN  DWORD Length
    )
/*++

Routine Description:

    This functions converts are arbitrary length hex number to an ASCII
    string.  The string is not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least Length * 2 characters in size.

    HexNumber - The hex number to convert.

    Length - The length of HexNumber, in bytes.

Return Value:

    None.

--*/
{
    DWORD i;
    int j;

    for (i = 0; i < Length; i+=1 ) {

        j = *HexNumber & 0xF;
        if ( j <= 9 ) {
            Buffer[i+1] = j + '0';
        } else {
            Buffer[i+1] = j + 'A' - 10;
        }

        j = *HexNumber >> 4;
        if ( j <= 9 ) {
            Buffer[i] = j + '0';
        } else {
            Buffer[i] = j + 'A' - 10;
        }

        HexNumber++;
    }

    return;
}



VOID
WinsDecimalToString(
    OUT LPWSTR Buffer,
    IN  BYTE Number
    )
/*++

Routine Description:

    This functions converts a single byte decimal digit to a 3 character
    Unicode string.  The string not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least 3 characters in size.

    Number - The number to convert.

Return Value:

    None.

--*/
{
    Buffer[2] = Number % 10 + L'0';
    Number /= 10;

    Buffer[1] = Number % 10 + L'0';
    Number /= 10;

    Buffer[0] = Number + L'0';

    return;
}



DWORD
WinsDottedStringToIpAddress(
    IN LPCSTR String
    )
/*++

Routine Description:

    This functions converts a dotted decimal form ASCII string to a
    Host order IP address.

Arguments:

    String - The address to convert.

Return Value:

    The corresponding IP address.

--*/
{
    struct in_addr addr;

    addr.s_addr = inet_addr( String );
    return( ntohl(*(LPDWORD)&addr) );
}



LPSTR
WinsIpAddressToDottedString(
    IN DWORD IpAddress
    )
/*++

Routine Description:

    This functions converts a Host order IP address to a dotted decimal
    form ASCII string.

Arguments:

    IpAddress - Host order IP Address.

Return Value:

    String for IP Address.

--*/
{
    DWORD NetworkOrderIpAddress;

    NetworkOrderIpAddress = htonl(IpAddress);
    return(inet_ntoa( *(struct in_addr *)&NetworkOrderIpAddress));
}



#if DBG

VOID
WinsAssertFailed(
    IN LPCSTR FailedAssertion,
    IN LPCSTR FileName,
    IN DWORD LineNumber,
    IN LPCSTR Message
    )
/*++

Routine Description:

    Assertion failed.

Arguments:

    FailedAssertion :

    FileName :

    LineNumber :

    Message :

Return Value:

    none.

--*/
{
#ifndef DHCP_NOASSERT
    RtlAssert(
            (LPVOID)FailedAssertion,
            (LPVOID)FileName,
            (ULONG) LineNumber,
            (PCHAR) Message);
#endif

    WinsPrint(( 0, "Assert @ %s \n", FailedAssertion ));
    WinsPrint(( 0, "Assert Filename, %s \n", FileName ));
    WinsPrint(( 0, "Line Num. = %ld.\n", LineNumber ));
    WinsPrint(( 0, "Message is %s\n", Message ));

}

VOID
WinsPrintRoutine(
    IN DWORD  DebugFlag,
    IN LPCSTR Format,
    ...
)

{

#define WSTRSIZE( wsz ) ( ( wcslen( wsz ) + 1 ) * sizeof( WCHAR ) )

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

#if DBG
    WinsAssert(length <= MAX_PRINTF_LEN);
#endif //DBG


    //
    // Output to the debug terminal,
    //

    DbgPrint( "%s", OutputBuffer);
}

#endif // DBG

DWORD
CreateDumpFile(
    IN  LPCWSTR pwszName,
    OUT PHANDLE phFile
    )
{
    HANDLE  hFile;

    *phFile = NULL;

    hFile = CreateFileW(pwszName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if(hFile == INVALID_HANDLE_VALUE)
        return GetLastError();

    *phFile = hFile;

    return NO_ERROR;
}

VOID
CloseDumpFile(
    HANDLE  hFile
)
{
    if( hFile )
        CloseHandle(hFile);
}





DWORD
WinsDottedStringToIpAddressW(
    IN LPCWSTR pwszString
)
{
    DWORD dwStrlen = 0;
    DWORD dwLen = 0;
    DWORD dwRes = INADDR_NONE;
    LPSTR pszString = NULL;
    if( pwszString == NULL )
        return dwRes;

    pszString = WinsUnicodeToOem(pwszString, NULL);
    if( pszString )
    {
        dwRes = WinsDottedStringToIpAddress(pszString);
        WinsFreeMemory(pszString);
        pszString = NULL;
    }
    
    return dwRes;
}


LPWSTR
WinsIpAddressToDottedStringW(
    DWORD   IpAddress
)
{
    DWORD dwStrlen = 0;
    DWORD dwLen = 0;
    DWORD dwRes = 0;
    LPWSTR pwszString = NULL;
    LPSTR  pszString = NULL;
    
    pszString = WinsIpAddressToDottedString(IpAddress);

    pwszString = WinsOemToUnicode(pszString, NULL);

    return pwszString;
}

BOOL
IsIpAddress(
    IN LPCWSTR pwszAddress
)
{
    LPSTR  pszAdd = NULL;
    LPSTR  pszTemp = NULL;
    

    if( IsBadStringPtr(pwszAddress, MAX_IP_STRING_LEN+1) is TRUE )
        return FALSE;
    if( wcslen(pwszAddress) < 3 )
        return FALSE;
    
    if( wcslen(pwszAddress) > 16 )
        return FALSE;
    pszAdd = WinsUnicodeToOem(pwszAddress, NULL);

    if( pszAdd is NULL )
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    pszTemp = strtok(pszAdd, ".");
    while(pszTemp isnot NULL )
    {
        DWORD i=0;
      
        for(i=0; i<strlen(pszTemp); i++)
        {
            if( tolower(pszTemp[i]) < L'0' or
                tolower(pszTemp[i]) > L'9' )
            return FALSE;
        }

        if( atol(pszTemp) < 0 or
            atol(pszTemp) > 255 )
        {
            return FALSE;
        }
        pszTemp = strtok(NULL, ".");
    }


    if( INADDR_NONE is inet_addr(pszAdd) )
    {
        WinsFreeMemory(pszAdd);
        pszAdd = NULL;
        return FALSE;
    }
    else
    {
        WinsFreeMemory(pszAdd);
        pszAdd = NULL;
        return TRUE;
    }
}

BOOL
IsValidServer(
    IN LPCWSTR pwszServer
)
{

    struct  hostent * lpHostEnt = NULL;
    DWORD             dwIpAddress = 0;
    
    LPSTR pszServer = NULL;

    if( pwszServer is NULL )
        return FALSE;

    pszServer = WinsUnicodeToAnsi(pwszServer, NULL);
    
    if( pszServer is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_OUT_OF_MEMORY);
        return FALSE;
    }

    //Is it an IPAddress?
    if( IsIpAddress(pwszServer) )
    {   
        dwIpAddress = inet_addr(pszServer);

        lpHostEnt = gethostbyaddr((char *)&dwIpAddress, 4, AF_INET);
    }
    else if( wcslen(pwszServer) > 2 and
             _wcsnicmp(pwszServer, L"\\\\", 2) is 0 )
    {
        lpHostEnt = gethostbyname(pszServer+2);

    }

    WinsFreeMemory(pszServer);

    return (lpHostEnt != NULL);
}

LPWSTR
MakeTimeString(
               DWORD dwTime
)
{
    LPWSTR  pwszTime = NULL;
    WCHAR   wcHr[3] = {L'\0'},
            wcMt[3] = {L'\0'},
            wcSc[3] = {L'\0'};
    DWORD   dwHr = 0,
            dwMt = 0,
            dwSc = 0,
            dw = 0;
    
    pwszTime = WinsAllocateMemory(9*sizeof(WCHAR));
    if( pwszTime )
    {
        for( dw=0; dw<8; dw++ )
            pwszTime[dw] = L'0';
        
        pwszTime[2] = pwszTime[5] = L':';

        dwHr = dwTime/(60*60);
        dwTime = dwTime - dwHr*60*60;
        dwMt = dwTime/60;
        dwTime = dwTime - dwMt*60;
        dwSc = dwTime;
        
        _itow((int)dwHr, wcHr, 10);
        _itow((int)dwMt, wcMt, 10);
        _itow((int)dwSc, wcSc, 10);

        if( dwHr isnot 0 )
        {
            wcsncpy(pwszTime+2-wcslen(wcHr), wcHr, wcslen(wcHr));
        }
        
        if( dwMt isnot 0 )
        {
            wcsncpy(pwszTime+5-wcslen(wcMt), wcMt, wcslen(wcMt));
        }

        wcsncpy(pwszTime+8-wcslen(wcSc), wcSc, wcslen(wcSc));

    }
    return pwszTime;
}

LPWSTR
MakeDayTimeString(
               DWORD dwTime
)
{
    LPWSTR  pwszTime = NULL;
    WCHAR   wcDay[4] = {L'\0'},
            wcHr[3] = {L'\0'},
            wcMt[3] = {L'\0'};
    DWORD   dwDay = 0,
            dwHr = 0,
            dwMt = 0,
            dw = 0;
    
    pwszTime = WinsAllocateMemory(10*sizeof(WCHAR));
    if( pwszTime )
    {
        for( dw=0; dw < 10; dw++ )
            pwszTime[dw] = L'0';

        
        pwszTime[3] = L':';
        pwszTime[6] = L':';
        pwszTime[9] = L'\0';

        dwDay = dwTime/(24*60*60);
        dwTime = dwTime - dwDay*24*60*60;

        dwHr = dwTime/(60*60);
        dwTime = dwTime - dwHr*60*60;
        
        dwMt = dwTime/60;
        dwTime = dwTime - dwMt*60;
       
        _itow(dwDay, wcDay,10);
        _itow(dwHr, wcHr, 10);
        _itow(dwMt, wcMt, 10);

        if( dwDay isnot 0 )
        {
            wcsncpy(pwszTime+3-wcslen(wcDay), wcDay, wcslen(wcDay));
        }

        if( dwHr isnot 0 )
        {
            wcsncpy(pwszTime+6-wcslen(wcHr), wcHr, wcslen(wcHr));
        }

        if( dwMt isnot 0 )
        {
            wcsncpy(pwszTime+9-wcslen(wcMt), wcMt, wcslen(wcMt));
        }
    }
    return pwszTime;
}


DWORD
ImportStaticMappingsFile(LPWSTR strFile,
                         BOOL fDelete
)
{
	DWORD   Status = NO_ERROR;
    WCHAR ws[256];

	Status = WinsDoStaticInit(g_hBind,
			     			 strFile,
							 fDelete);


	return Status;
}

BOOL
IsLocalServer(VOID)
{
    BOOL    fReturn = TRUE;
    WCHAR   wcName[MAX_COMPUTER_NAME_LEN+1] = {L'\0'};
    DWORD   dwLen = MAX_COMPUTER_NAME_LEN;

    fReturn = GetComputerNameEx(ComputerNameNetBIOS,
                                wcName,
                                &dwLen);
    if( fReturn is TRUE )
    {
        if( _wcsnicmp(wcName, g_ServerNameUnicode, dwLen ) is 0 )
        {
            return TRUE;
        }
        else
            return FALSE;
    }
    else
    {
        return FALSE;
    }
    
}

BOOL
IsPureNumeric(IN LPCWSTR pwszStr)
{
    DWORD   dwLen = 0,
            i;

    if( pwszStr is NULL )
        return FALSE;

    dwLen = wcslen(pwszStr);

    for(i=0; i<dwLen; i++ )
    {
        if( pwszStr[i] >= L'0' and
            pwszStr[i] <= L'9' )
        {
            continue;
        }
        else
            return FALSE;
            
    }
    return TRUE;
}


DWORD
DisplayErrorMessage(
    DWORD   dwMsgID,
    DWORD   dwErrID,
    ...
)
{
    LPWSTR  pwszErrorMsg = NULL;
    WCHAR   rgwcInput[MAX_MSG_LENGTH + 1] = {L'\0'};
    DWORD   dwMsgLen = 0;
    HANDLE  hWinsEvnt = NULL;
    va_list arglist;
    
    va_start(arglist, dwErrID);

    switch(dwErrID)
    {
    case ERROR_INVALID_PARAMETER:
        {
            DisplayMessage(g_hModule, EMSG_WINS_INVALID_PARAMETER);
            return dwErrID;
        }
    case ERROR_NOT_ENOUGH_MEMORY:
        {
            DisplayMessage(g_hModule, EMSG_WINS_OUT_OF_MEMORY);
            return dwErrID;
        }
    case ERROR_NO_MORE_ITEMS:
        {
            DisplayMessage(g_hModule, EMSG_WINS_NO_MORE_ITEMS);
            return dwErrID;
        }
    case ERROR_MORE_DATA:
        {
            DisplayMessage(g_hModule, EMSG_WINS_MORE_DATA);
            return dwErrID;
        }
    case ERROR_ACCESS_DENIED:
        {
            DisplayMessage(g_hModule, EMSG_WINS_ACCESS_DENIED);
            return dwErrID;
        }
    case ERROR_INVALID_DB_VERSION:
        {
            DisplayMessage(g_hModule, EMSG_INVALID_DB_VERSION);
            return dwErrID;
        }
    case ERROR_INVALID_IPADDRESS:
        {
            DisplayMessage(g_hModule, EMSG_INVALID_IPADDRESS);
            return dwErrID;
        }
    case ERROR_INVALID_PARTNER_NAME:
        {
            DisplayMessage(g_hModule, EMSG_INVALID_PARTNER_NAME);
            return dwErrID;
        }
    case ERROR_NO_PARTNER_EXIST:
        {
            DisplayMessage(g_hModule, EMSG_NO_PARTNER_EXIST);
            return dwErrID;
        }
    case ERROR_WINS_BIND_FAILED:
        {
            DisplayMessage(g_hModule, EMSG_WINS_BIND_FAILED, arglist);
            return dwErrID;
        }
    case ERROR_INVALID_PARAMETER_SPECIFICATION:
        {
            DisplayMessage(g_hModule, EMSG_INVALID_PARAMETER_SPECIFICATION);
            return dwErrID;
        }
    default:
        break;
    }

    //Is it Wins specific message ?

    hWinsEvnt = LoadLibrary(TEXT("WinsEvnt.dll"));
    
    if( hWinsEvnt is NULL )
    {
        DisplayMessage(g_hModule, MSG_DLL_LOAD_FAILED, TEXT("WinsEvnt.dll"));
        goto System;
    }

    if( !LoadStringW(hWinsEvnt,
                     dwErrID,
                     rgwcInput,
                     MAX_MSG_LENGTH) )
    {
        goto System;
    }

    dwMsgLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |FORMAT_MESSAGE_FROM_STRING,
                              rgwcInput,
                              0,
                              0L,         // Default country ID.
                              (LPWSTR)&pwszErrorMsg,
                              0,
                              NULL);
    if( dwMsgLen isnot 0)
    {
        DisplayMessage(g_hModule, dwMsgID, pwszErrorMsg);
        goto Cleanup;
    }


    //Might be a system error returned by GetLastError();
System:
    dwMsgLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,
                              dwErrID,
                              0L,
                              (LPWSTR)&pwszErrorMsg,
                              0,
                              NULL);

    if( dwMsgLen isnot 0)
    {
        DisplayMessage(g_hModule, dwMsgID, pwszErrorMsg);
        goto Cleanup;
    }

    _itow(dwErrID, rgwcInput, 10);
    DisplayMessage(g_hModule, dwMsgID, rgwcInput);

Cleanup:
    if (hWinsEvnt)
        FreeLibrary(hWinsEvnt);

    if (pwszErrorMsg)
        LocalFree(pwszErrorMsg);

    return dwMsgLen;
}

/*---------------------------------------------------------------------------
	ControlWINSService(LPCTSTR pszName, BOOL bStop)
		Stops ot starts the WINS service on the local machine
    //Code hacked from the WINS MMC code
---------------------------------------------------------------------------*/


DWORD 
ControlWINSService(BOOL bStop)
{
    DWORD           dwState = bStop ? SERVICE_STOPPED : SERVICE_RUNNING;
    DWORD           dwPending = bStop ? SERVICE_STOP_PENDING : SERVICE_START_PENDING;
    DWORD           err = ERROR_SUCCESS;
	int             i;
    SERVICE_STATUS  ss;
    DWORD           dwControl;
    BOOL            fSuccess;
	SC_HANDLE       hService = NULL;
    SC_HANDLE       hScManager = NULL;

	// oepmnt he service control manager
    hScManager = OpenSCManager(g_ServerNameUnicode, NULL, SC_MANAGER_ALL_ACCESS);
    if (hScManager == NULL)
    {
        err = GetLastError();
        goto Error;
    }

	// get the handle to the WINS service
    hService = OpenService(hScManager, _T("WINS"), SERVICE_ALL_ACCESS);
    if (hService == NULL)
    {
        err = GetLastError();
        goto Error;
    }

	// if stop requested
	if (bStop)
	{
		dwControl = SERVICE_CONTROL_STOP;
		fSuccess = ControlService(hService, dwControl, &ss);
	    if (!fSuccess)
	    {
	        err = GetLastError();
            goto Error;
	    }
    }
	// otherwise start the service
	else
	{
		fSuccess = StartService(hService, 0, NULL);
	    if (!fSuccess)
	    {
	        err = GetLastError();
            goto Error;
	    }
	}

#define LOOP_TIME   5000
#define NUM_LOOPS   600

    // wait for the service to start/stop.  
    for (i = 0; i < NUM_LOOPS; i++)
    {
        QueryServiceStatus(hService, &ss);

        // check to see if we are done6
        if (ss.dwCurrentState == dwState)
        {
            int time = LOOP_TIME * i;
            DisplayMessage(g_hModule, MSG_WINS_SERVICE_TIME, time);
            break;
        }
        
        // now see if something bad happened
        if (ss.dwCurrentState != dwPending)
        {
            int time = LOOP_TIME * i;
            DisplayMessage(g_hModule, MSG_WINS_SERVICE_TIME, time);
            break;
        }

        Sleep(LOOP_TIME);
    }

    if (i == NUM_LOOPS)
        DisplayMessage(g_hModule, EMSG_WINS_SERVICE_FAILED);

    if (ss.dwCurrentState != dwState)
        err = ERROR_SERVICE_REQUEST_TIMEOUT;

Error:
    // close the respective handles
	if (hService)
        CloseServiceHandle(hService);

    if (hScManager)
        CloseServiceHandle(hScManager);

	return err;
}

VOID
OEMprintf(
    FILE * pFile,
    IN  PWCHAR  pwszUnicode
    )
{
    PCHAR achOem;
    DWORD dwLen;

    dwLen = WideCharToMultiByte( CP_OEMCP,
                         0,
                         pwszUnicode,
                         -1,
                         NULL,
                         0,
                         NULL,
                         NULL );

    achOem = malloc(dwLen);
    if (achOem) 
    {
        WideCharToMultiByte( CP_OEMCP,
                             0,
                             pwszUnicode,
                             -1,
                             achOem,
                             dwLen,
                             NULL,
                             NULL );
    
        fprintf( stdout, "%hs", achOem );
    
        free(achOem);
    }
}

VOID
MyDisplayMessage(
    IN  FILE     *pFile,
    IN  PWCHAR   pwszFormat,
    IN  va_list *parglist
    )
{
    DWORD        dwMsgLen = 0;
    PWCHAR       pwszOutput = NULL;
    LPSTR        pszOutput = NULL;

    do
    {
        dwMsgLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER 
                                  |FORMAT_MESSAGE_FROM_STRING,
                                  pwszFormat,
                                  0,
                                  0L,         // Default country ID.
                                  (LPWSTR)&pwszOutput,
                                  0,
                                  parglist);

        if(dwMsgLen == 0)
        {
            fwprintf( pFile, L"Error %d in FormatMessageW()\n", GetLastError());            

            ASSERT(pwszOutput == NULL);

            break;
        }
        
        pszOutput = WinsUnicodeToOem(pwszOutput, NULL );
        if( pszOutput is NULL )
        {
            fwprintf(pFile, pwszOutput);
        }
        else
        {
            fprintf(pFile, pszOutput);
            WinsFreeMemory(pszOutput);
            pszOutput = NULL;
        }


    } while ( FALSE );

    if ( pwszOutput) { LocalFree( pwszOutput ); }

    return;
}

VOID
DumpMessage(
            HANDLE      hModule,
            FILE      * pFile,           
            DWORD       dwMsgId,
            ...
           )
{
    DWORD        dwMsgLen = 0;
    PWCHAR       pwszOutput = NULL;
    WCHAR        rgwcInput[MAX_MSG_LENGTH + 1];
    va_list      arglist;

    if ( !LoadStringW(hModule,
                      dwMsgId,
                      rgwcInput,
                      MAX_MSG_LENGTH) )
    {
        return;
    }

    va_start(arglist, dwMsgId);

    MyDisplayMessage(pFile,
                     rgwcInput,
                     &arglist);
    return;

}

VOID
TimeToFileTime(time_t time,
               LPFILETIME pftTime)
{
    LONGLONG longval = (LONGLONG)0;

    longval = Int32x32To64(time, 10000000) + 116444736000000000;
    pftTime->dwLowDateTime = (DWORD)longval;

    longval = (longval & 0xFFFFFFFF00000000);
    longval >>= 32;
    pftTime->dwHighDateTime = (DWORD)longval;
}

DWORD
GetDateTimeInfo(LCTYPE          lcType,
                LPSYSTEMTIME    lpSystemTime,
                LPWSTR          pwszBuffer,
                DWORD           *pdwBufferLen)
{
    DWORD   dwError = NO_ERROR;
    BOOL    fQueryLen = FALSE;
    int     cchFormat = 0,
            cchData = 0;
    
    PVOID   pfnPtr = NULL;
    DWORD   dwBuff = 0,
            dwInputBuff = 0;


    LPWSTR  pwszFormat = NULL,
            pwszData = NULL;


    if( pdwBufferLen is NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwInputBuff = *pdwBufferLen;
    *pdwBufferLen = 0;

    if( pwszBuffer is NULL or
        dwInputBuff is 0 )
    {
        fQueryLen = TRUE;
    }

    cchFormat = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT,
                            lcType,
                            NULL,
                            0);

    if( cchFormat is 0 )
    {
        dwError = GetLastError();
        goto RETURN;
    }

    pwszFormat = WinsAllocateMemory(cchFormat*sizeof(WCHAR));
    if( pwszFormat is NULL )
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto RETURN;
    }

    cchFormat = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT,
                              lcType,
                              pwszFormat,
                              cchFormat);

    if( cchFormat is 0 )
    {
        dwError = GetLastError();
        goto RETURN;
    }
    
    if( lcType isnot LOCALE_STIMEFORMAT )
    {
        cchData = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                0,
                                lpSystemTime,
                                pwszFormat,
                                NULL,
                                0);

        if( cchData is 0 )
        {
            dwError = GetLastError();
            goto RETURN;
        }
    
        if( fQueryLen is FALSE )
        {    
            if( cchData > (int)dwInputBuff )
            {
                dwError = ERROR_INSUFFICIENT_BUFFER;
                goto RETURN;
            }

            cchData = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                    0,
                                    lpSystemTime,
                                    pwszFormat,
                                    pwszBuffer,
                                    (int)dwInputBuff);

            if( cchData is 0 )
            {
                dwError = GetLastError();
                goto RETURN;
            }   
        }
    }
    else
    {
        cchData = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                                0,
                                lpSystemTime,
                                pwszFormat,
                                NULL,
                                0);

        if( cchData is 0 )
        {
            dwError = GetLastError();
            goto RETURN;
        }
    
        if( fQueryLen is FALSE )
        {    
            if( cchData > (int)dwInputBuff )
            {
                dwError = ERROR_INSUFFICIENT_BUFFER;
                goto RETURN;
            }

            cchData = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                                    0,
                                    lpSystemTime,
                                    pwszFormat,
                                    pwszBuffer,
                                    (int)dwInputBuff);

            if( cchData is 0 )
            {
                dwError = GetLastError();
                goto RETURN;
            }   
        }
    }

    dwBuff += cchData;
    *pdwBufferLen = dwBuff;

RETURN:
    if( pwszFormat )
    {
        WinsFreeMemory(pwszFormat);
        pwszFormat = NULL;
    }
    return dwError;

}

DWORD
FormatDateTimeString( time_t  time,
                      BOOL    fShort,
                      LPWSTR  pwszBuffer,
                      DWORD  *pdwBuffLen)
{
    BOOL        fQueryLen = FALSE;
    DWORD       dwError = NO_ERROR,
                dwBufferLen = 0;
    DWORD       dwBuff = 0,
                dwInputBuff = 0;
    FILETIME    ftTime = {0},
                ftLocalTime = {0};
    SYSTEMTIME  stTime = {0};

    if( pdwBuffLen is NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    dwInputBuff = *pdwBuffLen;

    if( pwszBuffer is NULL or
        dwInputBuff is 0 )
    {
        fQueryLen = TRUE;
    }
    
    TimeToFileTime(time, &ftTime);

    if( !FileTimeToLocalFileTime(&ftTime, &ftLocalTime) )
    {
        dwError = GetLastError();
        goto RETURN;
    }

    if( !FileTimeToSystemTime(&ftLocalTime, &stTime) )
    {
        dwError = GetLastError();
        goto RETURN;
    }
    
    if( fQueryLen is TRUE )
    {
        dwError = GetDateTimeInfo(fShort ? LOCALE_SSHORTDATE : LOCALE_SLONGDATE,
                                  &stTime,
                                  NULL,
                                  &dwBuff);

        if( dwError isnot NO_ERROR )
            goto RETURN;

    }
    else
    {
        dwBuff = dwInputBuff;
        dwError = GetDateTimeInfo(fShort ? LOCALE_SSHORTDATE : LOCALE_SLONGDATE,
                                  &stTime,
                                  pwszBuffer,
                                  &dwBuff);
        if( dwError isnot NO_ERROR )
            goto RETURN;
    }

    dwBufferLen += dwBuff;

    //Increment to add a space between date and time
    dwBufferLen ++;

    if( fQueryLen is TRUE )
    {
        dwBuff = 0;
        dwError = GetDateTimeInfo(LOCALE_STIMEFORMAT,
                                  &stTime,
                                  NULL,
                                  &dwBuff);
        if( dwError isnot NO_ERROR )
            goto RETURN;
    }
    else
    {
        if( dwBufferLen > dwInputBuff )
        {
            dwError = ERROR_INSUFFICIENT_BUFFER;
            goto RETURN;
        }

        wcscat( pwszBuffer, L" ");
        dwBuff = dwInputBuff - dwBufferLen;
        dwError = GetDateTimeInfo(LOCALE_STIMEFORMAT,
                                  &stTime,
                                  pwszBuffer + dwBufferLen - 1,
                                  &dwBuff);
        if( dwError isnot NO_ERROR )
            goto RETURN;
    }

    dwBufferLen += dwBuff;
    
    *pdwBuffLen = dwBufferLen;
    
RETURN:
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\netsh\precomp.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <signal.h>
#include <memory.h>
#include <malloc.h>

#include <fcntl.h>
#include <stropts.h>

#include <tdi.h>
#include <uio.h>

#include <winsock.h>
#include <wsahelp.h>

#include <nb30.h>
#include <nbtioctl.h>
#include <time.h>
#include <tchar.h>
#include <wchar.h>
#include <sys\types.h>
#include <sys\stat.h>

#include <netsh.h>
#include <netshp.h>

#include "winsintf.h"

#define PRSCONN 1

#include "common.h"
#include "winscnst.h"
#include "winsmon.h"
#include "winshndl.h"

#include "srvrmon.h"
#include "srvrhndl.h"

#include "strdefs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\netsh\srvrmon.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/
#ifndef _SRVRMON_H_
#define _SRVRMON_H_

DWORD
WINAPI
SrvrCommit(
    IN  DWORD   dwAction
);

NS_CONTEXT_ENTRY_FN SrvrMonitor;

DWORD
WINAPI
SrvrUnInit(
    IN  DWORD   dwReserved
);

#endif //_SRVRMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\netsh\strdefs.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/
#ifndef _STRDEFS_H_
#define _STRDEFS_H_

#define     WINS_FORMAT_LINE                        1001
#define     WINS_FORMAT_TAB                         1002
#define     WINS_MSG_NULL                           1003

#define     MSG_HELP_START                         _T("%1!-14s! - ")

#define     WINS_TOKEN_SERVER                       L"server"
#define     WINS_TOKEN_ID                           L"id"
#define     WINS_TOKEN_DESC                         L"desc"
#define     WINS_TOKEN_NAME                         L"name"
#define     WINS_TOKEN_ENDCHAR                      L"endchar"
#define     WINS_TOKEN_SCOPE                        L"scope"
#define     WINS_TOKEN_RECORDTYPE                   L"rectype"
#define     WINS_TOKEN_GROUP                        L"group"
#define     WINS_TOKEN_NODE                         L"node"
#define     WINS_TOKEN_IP                           L"ip"
#define     WINS_TOKEN_TYPE                         L"type"
#define     WINS_TOKEN_SERVERS                      L"servers"
#define     WINS_TOKEN_NAMEFILE                     L"namefile"
#define     WINS_TOKEN_NAMELIST                     L"namelist"
#define     WINS_TOKEN_SERVERFILE                   L"serverfile"
#define     WINS_TOKEN_SERVERLIST                   L"serverlist"
#define     WINS_TOKEN_MINVER                       L"minver"
#define     WINS_TOKEN_MAXVER                       L"maxver"
#define     WINS_TOKEN_OP                           L"op"
#define     WINS_TOKEN_PARTNER                      L"partnername"
#define     WINS_TOKEN_DIR                          L"dir"
#define     WINS_TOKEN_FILE                         L"file"
#define     WINS_TOKEN_PARTNERTYPE                  L"partnertype"
#define     WINS_TOKEN_INTERVAL                     L"interval"
#define     WINS_TOKEN_TTL                          L"ttl"
#define     WINS_TOKEN_ATSHUTDOWN                   L"shutdown"
#define     WINS_TOKEN_STATE                        L"state"
#define     WINS_TOKEN_RENEW                        L"renew"
#define     WINS_TOKEN_EXTINCTION                   L"extinction"
#define     WINS_TOKEN_EXTIMEOUT                    L"extimeout"
#define     WINS_TOKEN_VERIFICATION                 L"verification"
#define     WINS_TOKEN_MAXRECORDCOUNT               L"maxrecordcount"
#define     WINS_TOKEN_CHECKAGAINST                 L"checkagainst"
#define     WINS_TOKEN_CHECKEVERY                   L"checkevery"
#define     WINS_TOKEN_START                        L"start"
#define     WINS_TOKEN_STARTUP                      L"strtup"
#define     WINS_TOKEN_RETRY                        L"retry"
#define     WINS_TOKEN_ADDRESSCHANGE                L"addchange"
#define     WINS_TOKEN_VERSION                      L"version"
#define     WINS_TOKEN_MODE                         L"mode"
#define     WINS_TOKEN_PROPAGATION                  L"propagation"
#define     WINS_TOKEN_RECCOUNT                     L"count"
#define     WINS_TOKEN_CONFIRM                      L"confirm"
#define     WINS_TOKEN_CASE                         L"case"
#define     WINS_TOKEN_OWNER                        L"owner"
#define     WINS_TOKEN_UPDATE                       L"update"
#define     WINS_TOKEN_NETBIOS                      L"netbios"
#define     WINS_TOKEN_DBCHANGE                     L"dbchange"
#define     WINS_TOKEN_EVENT                        L"event"
#define     WINS_TOKEN_VALUE                        L"value"
#define     WINS_TOKEN_INCLPARTNER                  L"inclpartner"
#define     WINS_TOKEN_ALL                          L"all"
#define     WINS_TOKEN_FORCE                        L"force"

#define     CMD_GROUP_ADD                           L"add"
#define     CMD_GROUP_CHECK                         L"check"
#define     CMD_GROUP_DELETE                        L"delete"
#define     CMD_GROUP_INIT                          L"init"
#define     CMD_GROUP_RESET                         L"reset"
#define     CMD_GROUP_SET                           L"set"
#define     CMD_GROUP_SHOW                          L"show"


#define     CMD_WINS_HELP1                          L"help"
#define     CMD_WINS_HELP2                          L"?"
#define     CMD_WINS_HELP3                          L"/?"
#define     CMD_WINS_HELP4                          L"-?"
#define     CMD_WINS_DUMP                           L"dump"


#define     CMD_WINS_ADD_SERVER                     L"add    server"
#define     CMD_WINS_DELETE_SERVER                  L"delete server"
#define     CMD_WINS_SHOW_SERVER                    L"show   server"


#define     HLP_WINS_HELP1                          2601
#define     HLP_WINS_HELP1_EX                       2602
#define     HLP_WINS_HELP2                          2604
#define     HLP_WINS_HELP2_EX                       2605
#define     HLP_WINS_HELP3                          2606
#define     HLP_WINS_HELP3_EX                       2607
#define     HLP_WINS_HELP4                          2608
#define     HLP_WINS_HELP4_EX                       2609
#define     HLP_WINS_DUMP                           2612
#define     HLP_WINS_DUMP_EX                        2613


#define     HLP_WINS_ADD_SERVER                     2701
#define     HLP_WINS_ADD_SERVER_EX                  2702
#define     HLP_WINS_CONTEXT_SERVER                 2703
#define     HLP_WINS_CONTEXT_SERVER_EX              2704

#define     HLP_WINS_DELETE_SERVER                  2711
#define     HLP_WINS_DELETE_SERVER_EX               2712


#define     HLP_WINS_SHOW_SERVER                    2721
#define     HLP_WINS_SHOW_SERVER_EX                 2722


#define     HLP_GROUP_ADD                           2801
#define     HLP_GROUP_CHECK                         2802
#define     HLP_GROUP_DELETE                        2803
#define     HLP_GROUP_INIT                          2804
#define     HLP_GROUP_RESET                         2805
#define     HLP_GROUP_SET                           2806
#define     HLP_GROUP_SHOW                          2807


#define     CMD_SRVR_HELP1                          2901
#define     CMD_SRVR_HELP2                          2902
#define     CMD_SRVR_HELP3                          2903
#define     CMD_SRVR_HELP4                          2904
#define     CMD_SRVR_LIST                           2905
#define     CMD_SRVR_DUMP                           2906

#define     HLP_SRVR_ADD_FILTER                     3001
#define     HLP_SRVR_ADD_FILTER_EX                  3002
#define     HLP_SRVR_ADD_NAME                       3003
#define     HLP_SRVR_ADD_NAME_EX                    3004
#define     HLP_SRVR_ADD_PARTNER                    3005
#define     HLP_SRVR_ADD_PARTNER_EX                 3006
#define     HLP_SRVR_ADD_PNGSERVER                  3007
#define     HLP_SRVR_ADD_PNGSERVER_EX               3008
#define     HLP_SRVR_ADD_PGSERVER                   3009
#define     HLP_SRVR_ADD_PGSERVER_EX                3010

#define     HLP_SRVR_CHECK_DATABASE                 3021
#define     HLP_SRVR_CHECK_DATABASE_EX              3022
#define     HLP_SRVR_CHECK_NAME                     3023
#define     HLP_SRVR_CHECK_NAME_EX                  3024
#define     HLP_SRVR_CHECK_VERSION                  3025
#define     HLP_SRVR_CHECK_VERSION_EX               3026

#define     HLP_SRVR_DELETE_NAME                    3041
#define     HLP_SRVR_DELETE_NAME_EX                 3042
#define     HLP_SRVR_DELETE_RECORDS                 3043
#define     HLP_SRVR_DELETE_RECORDS_EX              3044
#define     HLP_SRVR_DELETE_PARTNER                 3045
#define     HLP_SRVR_DELETE_PARTNER_EX              3046
#define     HLP_SRVR_DELETE_WINS                    3047
#define     HLP_SRVR_DELETE_WINS_EX                 3048
#define     HLP_SRVR_DELETE_PNGSERVER               3049
#define     HLP_SRVR_DELETE_PNGSERVER_EX            3050
#define     HLP_SRVR_DELETE_PGSERVER                3051
#define     HLP_SRVR_DELETE_PGSERVER_EX             3052

#define     HLP_SRVR_INIT_BACKUP                    3061
#define     HLP_SRVR_INIT_BACKUP_EX                 3062
#define     HLP_SRVR_INIT_COMPACT                   3063
#define     HLP_SRVR_INIT_COMPACT_EX                3064
#define     HLP_SRVR_INIT_EXPORT                    3065
#define     HLP_SRVR_INIT_EXPORT_EX                 3066
#define     HLP_SRVR_INIT_IMPORT                    3067
#define     HLP_SRVR_INIT_IMPORT_EX                 3068
#define     HLP_SRVR_INIT_PULL                      3069
#define     HLP_SRVR_INIT_PULL_EX                   3070
#define     HLP_SRVR_INIT_PUSH                      3071
#define     HLP_SRVR_INIT_PUSH_EX                   3072
#define     HLP_SRVR_INIT_REPLICATE                 3073
#define     HLP_SRVR_INIT_REPLICATE_EX              3074
#define     HLP_SRVR_INIT_RESTORE                   3075
#define     HLP_SRVR_INIT_RESTORE_EX                3076
#define     HLP_SRVR_INIT_SCAVENGE                  3077
#define     HLP_SRVR_INIT_SCAVENGE_EX               3078
#define     HLP_SRVR_INIT_SEARCH                    3079
#define     HLP_SRVR_INIT_SEARCH_EX                 3080
#define     HLP_SRVR_INIT_PULLRANGE                 3181
#define     HLP_SRVR_INIT_PULLRANGE_EX              3182

#define     HLP_SRVR_RESET_COUNTER                  3085
#define     HLP_SRVR_RESET_COUNTER_EX               3086

#define     HLP_SRVR_SET_AUTOPARTNERCONFIG          3091
#define     HLP_SRVR_SET_AUTOPARTNERCONFIG_EX       3092
#define     HLP_SRVR_SET_AUTOREFRESH                3093
#define     HLP_SRVR_SET_AUTOREFRESH_EX             3094
#define     HLP_SRVR_SET_BACKUPPATH                 3095
#define     HLP_SRVR_SET_BACKUPPATH_EX              3096
#define     HLP_SRVR_SET_FILTER                     3097
#define     HLP_SRVR_SET_FILTER_EX                  3098
#define     HLP_SRVR_SET_MIGRATEFLAG                3099
#define     HLP_SRVR_SET_MIGRATEFLAG_EX             3100
#define     HLP_SRVR_SET_NAMERECORD                 3101
#define     HLP_SRVR_SET_NAMERECORD_EX              3102
#define     HLP_SRVR_SET_PERIODICDBCHECKING         3103
#define     HLP_SRVR_SET_PERIODICDBCHECKING_EX      3104
#define     HLP_SRVR_SET_PULLPERSISTENTCONNECTION   3105
#define     HLP_SRVR_SET_PULLPERSISTENTCONNECTION_EX 3106
#define     HLP_SRVR_SET_PUSHPERSISTENTCONNECTION   3107
#define     HLP_SRVR_SET_PUSHPERSISTENTCONNECTION_EX 3108
#define     HLP_SRVR_SET_PULLPARAM                  3109
#define     HLP_SRVR_SET_PULLPARAM_EX               3110
#define     HLP_SRVR_SET_PUSHPARAM                  3111
#define     HLP_SRVR_SET_PUSHPARAM_EX               3112
#define     HLP_SRVR_SET_REPLICATEFLAG              3113
#define     HLP_SRVR_SET_REPLICATEFLAG_EX           3114
#define     HLP_SRVR_SET_LOGPARAM                   3115
#define     HLP_SRVR_SET_LOGPARAM_EX                3116
#define     HLP_SRVR_SET_BURSTPARAM                 3117
#define     HLP_SRVR_SET_BURSTPARAM_EX              3118
#define     HLP_SRVR_SET_STARTVERSION               3119
#define     HLP_SRVR_SET_STARTVERSION_EX            3120
#define		HLP_SRVR_SET_DEFAULTPARAM				3121
#define		HLP_SRVR_SET_DEFAULTPARAM_EX			3122
#define     HLP_SRVR_SET_PGMODE                     3123
#define     HLP_SRVR_SET_PGMODE_EX                  3124

#define     HLP_SRVR_SHOW_DATABASE                  3131
#define     HLP_SRVR_SHOW_DATABASE_EX               3132
#define     HLP_SRVR_SHOW_FILTERS                   3133
#define     HLP_SRVR_SHOW_FILTERS_EX                3134
#define     HLP_SRVR_SHOW_INFO                      3135
#define     HLP_SRVR_SHOW_INFO_EX                   3136
#define     HLP_SRVR_SHOW_PARTNER                   3137
#define     HLP_SRVR_SHOW_PARTNER_EX                3138
#define     HLP_SRVR_SHOW_NAME                      3139
#define     HLP_SRVR_SHOW_NAME_EX                   3140
#define     HLP_SRVR_SHOW_SERVER                    3141
#define     HLP_SRVR_SHOW_SERVER_EX                 3142
#define     HLP_SRVR_SHOW_SERVERSTATISTICS          3143
#define     HLP_SRVR_SHOW_SERVERSTATISTICS_EX       3144
#define     HLP_SRVR_SHOW_VERSION                   3145
#define     HLP_SRVR_SHOW_VERSION_EX                3146
#define     HLP_SRVR_SHOW_VERSIONMAP                3147
#define     HLP_SRVR_SHOW_VERSIONMAP_EX             3148
#define     HLP_SRVR_SHOW_BYNAME                    3149
#define     HLP_SRVR_SHOW_BYNAME_EX                 3150
#define     HLP_SRVR_SHOW_BYVERSION                 3151
#define     HLP_SRVR_SHOW_BYVERSION_EX              3152
#define     HLP_SRVR_SHOW_PARTNERPROPERTIES         3153
#define     HLP_SRVR_SHOW_PARTNERPROPERTIES_EX      3154
#define     HLP_SRVR_SHOW_PULLPARTNERPROPERTIES     3155
#define     HLP_SRVR_SHOW_PULLPARTNERPROPERTIES_EX  3156
#define     HLP_SRVR_SHOW_PUSHPARTNERPROPERTIES     3157
#define     HLP_SRVR_SHOW_PUSHPARTNERPROPERTIES_EX  3158
#define     HLP_SRVR_SHOW_DOMAIN                    3159
#define     HLP_SRVR_SHOW_DOMAIN_EX                 3160
#define     HLP_SRVR_SHOW_RECCOUNT                  3161
#define     HLP_SRVR_SHOW_RECCOUNT_EX               3162
#define     HLP_SRVR_SHOW_RECBYVERSION              3163
#define     HLP_SRVR_SHOW_RECBYVERSION_EX           3164


#define     CMD_SRVR_ADD_FILTER                     L"add    filter"
#define     CMD_SRVR_ADD_NAME                       L"add    name"
#define     CMD_SRVR_ADD_PARTNER                    L"add    partner"
#define     CMD_SRVR_ADD_PNGSERVER                  L"add    pngserver"
#define     CMD_SRVR_ADD_PGSERVER                   L"add    pgserver"

#define     CMD_SRVR_CHECK_DATABASE                 L"check  database"
#define     CMD_SRVR_CHECK_NAME                     L"check  name"
#define     CMD_SRVR_CHECK_VERSION                  L"check  version"


#define     CMD_SRVR_DELETE_NAME                    L"delete name"
#define     CMD_SRVR_DELETE_RECORDS                 L"delete records"
#define     CMD_SRVR_DELETE_PARTNER                 L"delete partner"
#define     CMD_SRVR_DELETE_WINS                    L"delete owners"
#define     CMD_SRVR_DELETE_PNGSERVER               L"delete pngserver"
#define     CMD_SRVR_DELETE_PGSERVER                L"delete pgserver"

#define     CMD_SRVR_RESET_COUNTER                  L"reset  statistics"

#define     CMD_SRVR_INIT_BACKUP                    L"init   backup"
#define     CMD_SRVR_INIT_COMPACT                   L"init   compact"
#define     CMD_SRVR_INIT_EXPORT                    L"init   export"
#define     CMD_SRVR_INIT_IMPORT                    L"init   import"
#define     CMD_SRVR_INIT_PULL                      L"init   pull"
#define     CMD_SRVR_INIT_PULLRANGE                 L"init   pullrange"
#define     CMD_SRVR_INIT_PUSH                      L"init   push"
#define     CMD_SRVR_INIT_REPLICATE                 L"init   replicate"
#define     CMD_SRVR_INIT_RESTORE                   L"init   restore"
#define     CMD_SRVR_INIT_SCAVENGE                  L"init   scavenge"
#define     CMD_SRVR_INIT_SEARCH                    L"init   search"

#define     CMD_SRVR_SET_AUTOPARTNERCONFIG          L"set    autopartnerconfig"
#define     CMD_SRVR_SET_AUTOREFRESH                L"set    autorefresh"
#define     CMD_SRVR_SET_BACKUPPATH                 L"set    backuppath"
#define		CMD_SRVR_SET_DEFAULTPARAM				L"set	 defaultparam"
#define     CMD_SRVR_SET_FILTER                     L"set    filter"
#define     CMD_SRVR_SET_MIGRATEFLAG                L"set    migrateflag"
#define     CMD_SRVR_SET_NAMERECORD                 L"set    namerecord"
#define     CMD_SRVR_SET_PERIODICDBCHECKING         L"set    periodicdbchecking"
#define     CMD_SRVR_SET_PULLPERSISTENTCONNECTION   L"set    pullpartnerconfig"
#define     CMD_SRVR_SET_PUSHPERSISTENTCONNECTION   L"set    pushpartnerconfig"
#define     CMD_SRVR_SET_PULLPARAM                  L"set    pullparam"
#define     CMD_SRVR_SET_PUSHPARAM                  L"set    pushparam"
#define     CMD_SRVR_SET_REPLICATEFLAG              L"set    replicateflag"
#define     CMD_SRVR_SET_LOGPARAM                   L"set    logparam"
#define     CMD_SRVR_SET_BURSTPARAM                 L"set    burstparam"
#define     CMD_SRVR_SET_STARTVERSION               L"set    startversion"
#define     CMD_SRVR_SET_PGMODE                     L"set    pgmode"

#define     CMD_SRVR_SHOW_DATABASE                  L"show   database"
#define     CMD_SRVR_SHOW_DOMAIN                    L"show   browser"
#define     CMD_SRVR_SHOW_FILTERS                   L"show   filters"
#define     CMD_SRVR_SHOW_INFO                      L"show   info"
#define     CMD_SRVR_SHOW_PARTNER                   L"show   partner"
#define     CMD_SRVR_SHOW_NAME                      L"show   name"
#define     CMD_SRVR_SHOW_SERVER                    L"show   server"
#define     CMD_SRVR_SHOW_SERVERSTATISTICS          L"show   statistics"
#define     CMD_SRVR_SHOW_VERSION                   L"show   version"
#define     CMD_SRVR_SHOW_VERSIONMAP                L"show   versionmap"
#define     CMD_SRVR_SHOW_PARTNERPROPERTIES         L"show   partnerproperties"
#define     CMD_SRVR_SHOW_PULLPARTNERPROPERTIES     L"show   pullpartnerconfig"
#define     CMD_SRVR_SHOW_PUSHPARTNERPROPERTIES     L"show   pushpartnerconfig"
#define     CMD_SRVR_SHOW_RECCOUNT                  L"show   reccount"
#define     CMD_SRVR_SHOW_RECBYVERSION              L"show   recbyversion"

#define     EMSG_WINS_ADD_SERVER                    4500
#define     EMSG_WINS_DELETE_SERVER                 4501
#define     EMSG_WINS_SHOW_SERVER                   4502
#define     EMSG_WINS_REQUIRED_PARAMETER            4503


#define     ERROR_INVALID_DB_VERSION                25001
#define     ERROR_INVALID_IPADDRESS                 25002
#define     ERROR_INVALID_PARTNER_NAME              25003
#define     ERROR_NO_PARTNER_EXIST                  25004
#define     ERROR_WINS_BIND_FAILED                  25005
#define     ERROR_INVALID_PARAMETER_SPECIFICATION   25006

#define     EMSG_INVALID_DB_VERSION                 35001
#define     EMSG_INVALID_IPADDRESS                  35002
#define     EMSG_INVALID_PARTNER_NAME               35003
#define     EMSG_NO_PARTNER_EXIST                   35004
#define     EMSG_INVALID_PARAMETER_SPECIFICATION    35006
#define     EMSG_SRVR_ATLEAST_ONE_PNG               35007
#define     EMSG_SRVR_ATLEAST_ONE_PG                35008

#define     EMSG_WINS_ERROR_SUCCESS                 7000
#define     EMSG_WINS_INCOMPLETE_COMMAND            7001
#define     EMSG_WINS_UNKNOWN_SERVER                7002
#define     EMSG_WINS_INVALID_COMPUTERNAME          7003
#define     EMSG_WINS_NOT_ENOUGH_MEMORY             7004
#define     EMSG_WINS_FAILED                        7005
#define     EMSG_WINS_INVALID_SERVER_HANDLE         7006
#define     EMSG_WINS_INVALID_COMPUTER_NAME         7007
#define     EMSG_WINS_OWNERDB_FAILED                7008
#define     EMSG_WINS_INVALID_PULLPARTNER           7009
#define     EMSG_WINS_INVALID_PUSHPARTNER           7010
#define     EMSG_WINS_SERVERPROP_FAILED             7011
#define     EMSG_WINS_VERSION_HIGHER                7012
#define     EMSG_WINS_VERSION_CORRECT               7013
#define     EMSG_WINS_BIND_FAILED                   7014
#define     EMSG_WINS_INVALID_NAME                  7015
#define     EMSG_WINS_VALUE_OUTOFRANGE              7016
#define     EMSG_WINS_INVALID_FILENAME              7017
#define     EMSG_WINS_FILEREAD_FAILED               7018
#define     EMSG_WINS_EMPTY_FILE                    7019
#define     EMSG_WINS_INVALID_IPADDRESS             7020
#define     EMSG_WINS_NO_NAMES                      7021
#define     EMSG_WINS_NO_SERVERS                    7022
#define     EMSG_WINS_DISPLAY_STRING                7023
#define     EMSG_WINS_PULL_FAILED                   7024
#define     EMSG_WINS_PUSH_FAILED                   7025
#define     EMSG_WINS_NO_PULLPARTNER                7026
#define     EMSG_WINS_NO_PUSHPARTNER                7027
#define     EMSG_WINS_INVALID_PARAMETER             7028
#define     EMSG_WINS_OUT_OF_MEMORY                 7029
#define     EMSG_WINS_NO_MORE_ITEMS                 7030
#define     EMSG_WINS_MORE_DATA                     7031
#define     EMSG_WINS_SERVICE_FAILED                7032
#define     EMSG_WINS_DELETE_FILE                   7033
#define     EMSG_WINS_LOCAL_SERVER                  7034
#define     EMSG_WINS_ACCESS_DENIED                 7035
#define     EMSG_WINS_RESTORE_IMPROPER              7036
#define     EMSG_WINS_REGCONNECT_FAILED             7037
#define     EMSG_WINS_REGOPEN_FAILED                7038
#define     EMSG_WINS_REGSETVAL_FAILED              7039
#define     EMSG_WINS_VERIFY_ADDRESS                7040
#define     EMSG_WINS_ONE_INVALID_PARAMETER         7041
#define     EMSG_SRVR_BURST_PARAM_OUTOFRANGE        7042
#define     EMSG_WINS_OPERATION_FAILED              7043

#define     EMSG_SRVR_ADD_NAME                      7101
#define     EMSG_SRVR_ADD_PARTNER                   7102
#define     EMSG_SRVR_ADD_PNGSERVER                 7103
#define     EMSG_SRVR_ADD_PGSERVER                  7104
#define     EMSG_SRVR_DELETE_NAME                   7105
#define     EMSG_SRVR_DELETE_PARTNER                7106
#define     EMSG_SRVR_DELETE_PNGSERVER              7107
#define     EMSG_SRVR_DELETE_PGSERVER               7108
#define     EMSG_SRVR_DELETE_RECORDS                7109
#define     EMSG_SRVR_DELETE_WINS                   7110
#define     EMSG_SRVR_CHECK_NAME                    7111
#define     EMSG_SRVR_CHECK_DATABASE                7112
#define     EMSG_SRVR_CHECK_VERSION                 7113
#define     EMSG_SRVR_INIT_BACKUP                   7114
#define     EMSG_SRVR_INIT_COMPACT                  7115
#define     EMSG_SRVR_INIT_EXPORT                   7116
#define     EMSG_SRVR_INIT_IMPORT                   7117
#define     EMSG_SRVR_INIT_PULL                     7118
#define     EMSG_SRVR_INIT_PUSH                     7119
#define     EMSG_SRVR_INIT_REPLICATE                7120
#define     EMSG_SRVR_INIT_RESTORE                  7121
#define     EMSG_SRVR_INIT_SCAVENGE                 7122
#define     EMSG_SRVR_INIT_SEARCH                   7123
#define     EMSG_SRVR_SET_AUTOPARTNERCONFIG         7124
#define     EMSG_SRVR_SET_AUTOREFRESH               7125
#define     EMSG_SRVR_SET_BACKUPPATH                7126
#define     EMSG_SRVR_SET_FILTER                    7127
#define     EMSG_SRVR_SET_MIGRATEFLAG               7128
#define     EMSG_SRVR_SET_NAMERECORD                7129
#define     EMSG_SRVR_SET_PERIODICDBCHECKING        7130
#define     EMSG_SRVR_SET_PULLPERSISTENTCONNECTION  7131
#define     EMSG_SRVR_SET_PUSHPERSISTENTCONNECTION  7132
#define     EMSG_SRVR_SET_PULLPARAM                 7133
#define     EMSG_SRVR_SET_PUSHPARAM                 7134
#define     EMSG_SRVR_SET_REPLICATEFLAG             7135
#define     EMSG_SRVR_SHOW_DATABASE                 7136
#define     EMSG_SRVR_SHOW_FILTERS                  7137
#define     EMSG_SRVR_SHOW_INFO                     7138
#define     EMSG_SRVR_SHOW_PARTNER                  7139
#define     EMSG_SRVR_SHOW_NAME                     7140
#define     EMSG_SRVR_SHOW_SERVER                   7141
#define     EMSG_SRVR_SHOW_STATISTICS               7142
#define     EMSG_SRVR_SHOW_VERSION                  7143
#define     EMSG_SRVR_SHOW_VERSIONMAP               7144
#define     EMSG_SRVR_SHOW_BYNAME                   7145
#define     EMSG_SRVR_SHOW_BYVERSION                7146
#define     EMSG_SRVR_SHOW_PARTNERPROPERTIES        7147
#define     EMSG_SRVR_SHOW_PULLPARTNERPROPERTIES    7148
#define     EMSG_SRVR_SHOW_PUSHPARTNERPROPERTIES    7149
#define     EMSG_SRVR_SHOW_DOMAIN                   7150
#define     EMSG_SRVR_INIT_PULLRANGE                7151
#define     EMSG_WINS_DUMP                          7152
#define     EMSG_SRVR_DUMP                          7153
#define     EMSG_SRVR_SHOW_RECCOUNT                 7154
#define     EMSG_SRVR_SHOW_RECBYVERSION             7155
#define     EMSG_SRVR_SET_LOGPARAM                  7156
#define     EMSG_SRVR_SET_BURSTPARAM                7157
#define     EMSG_SRVR_SET_STARTVERSION              7158
#define     EMSG_WINS_FILEOPEN_FAILED               7159
#define     EMSG_WINS_GETSTATUS_FAILED              7160
#define     EMSG_SRVR_NO_REPLPARTNERS               7161
#define     EMSG_SRVR_RETRIEVEDB_FAILED             7162
#define     EMSG_SRVR_ERROR_MESSAGE                 7163
#define     EMSG_WINS_RETRIEVEDB_PARTIAL            7164
#define     EMSG_ACCESS_NOT_DETERMINED              7165
#define     EMSG_SRVR_NOBACKUP_PATH                 7166
#define     EMSG_SRVR_UNABLE_BIND                   7167
#define     EMSG_WINS_GET_WINSSTATUS                7168
#define     EMSG_WINS_OWNER_DATABASE                7169
#define     EMSG_WINS_UNABLE_VERIFY                 7170
#define     EMSG_WINS_SENDTO_FAILED                 7171
#define     EMSG_WINS_GETRESPONSE_FAILED            7172
#define     EMSG_WINS_NAMECHECK_FAILED              7173
#define     EMSG_WINS_NAME_NOT_FOUND                7174
#define     EMSG_WINS_NO_RESPONSE                   7175
#define     EMSG_WINS_NAME_INCONSISTENCY            7176
#define     EMSG_WINS_VERIFIED_ADDRESS              7177
#define     EMSG_WINS_NAMEQUERY_RESULT              7178
#define     EMSG_WINS_WINS_NEVERRESPONDED           7179
#define     EMSG_WINS_WINS_INCOMPLETE               7180
#define     EMSG_WINS_ADDRESS_VERIFY_FAILED         7181
#define     EMSG_WINS_ADMIN_INSTALL                 7182
#define		EMSG_WINS_NOT_CONFIGURED				7183
#define		EMSG_SRVR_SET_DEFAULTPARAM				7184
#define     EMSG_SRVR_INVALID_PARTNER               7185
#define     EMSG_SRVR_IP_DISCARD                    7186
#define     EMSG_SRVR_NO_IP_ADDED_PNG               7187
#define     EMSG_SRVR_NO_IP_ADDED_PG                7188
#define     EMSG_SRVR_NOT_TAGGED                    7189
#define     EMSG_SRVR_NOT_UNTAGGED                  7190
#define     EMSG_SRVR_NO_VALID_IP                   7191
#define     EMSG_SRVR_NAME_NOT_VERIFIED             7192
#define     EMSG_SRVR_RENEW_INTERVAL                7193
#define     EMSG_SRVR_TOMBSTONE_TIMEOUT             7194
#define     EMSG_SRVR_TOMBSTONE_INTERVAL            7195
#define     EMSG_SRVR_VERIFY_INTERVAL               7196
#define     EMSG_WINS_NAME_VERIFIED                 7197
#define     EMSG_SRVR_DUPLICATE_DISCARD             7198
#define     EMSG_SRVR_INVALID_NETBIOS_NAME          7199
#define     EMSG_SRVR_PG_INVALIDOP                  7200
#define     EMSG_SRVR_PNG_INVALIDOP                 7201
#define     EMSG_SRVR_SET_PGMODE                    7202


#define     MSG_WINS_ACCESS                         8000
#define     MSG_WINS_DISPLAY_NAME                   8001
#define     MSG_WINS_IPADDRESS_STRING               8002
#define     MSG_WINS_OWNER_ADDRESS                  8003
#define     MSG_WINS_MEMBER_ADDRESS                 8004
#define     MSG_WINS_VERSION_INFO                   8005
#define     MSG_WINS_SERVER_NAME                    8006
#define     MSG_WINS_REFRESH_INTERVAL               8007
#define     MSG_WINS_TOMBSTONE_INTERVAL             8008
#define     MSG_WINS_TOMBSTONE_TIMEOUT              8009
#define     MSG_WINS_VERIFY_INTERVAL                8010
#define     MSG_WINS_PRIORITY_CLASS                 8011
#define     MSG_WINS_WORKER_THREAD                  8012
#define     MSG_WINS_OWNER_TABLE                    8013
#define     MSG_WINS_OWNER_INFO                     8014
#define     MSG_WINS_NO_RECORDS                     8015
#define     MSG_WINS_OWNER_INFO_MAX                 8016
#define     MSG_WINS_TIMESTAMP                      8017
#define     MSG_WINS_LAST_INIT                      8018
#define     MSG_WINS_PLANNED_SCV                    8019
#define     MSG_WINS_TRIGGERED_SCV                  8020
#define     MSG_WINS_TOMBSTONE_SCV                  8021
#define     MSG_WINS_REPLICA_VERIFICATION           8022
#define     MSG_WINS_PLANNED_REPLICATION            8023
#define     MSG_WINS_TRIGGERED_REPLICATION          8024
#define     MSG_WINS_RESET_COUNTER                  8025
#define     MSG_WINS_COUNTER_INFORMATION            8026
#define     MSG_WINS_PARTNER_TABLE                  8027
#define     MSG_WINS_PARTNER_INFO                   8028
#define     MSG_WINS_RECORDS_COUNT                  8029
#define     MSG_WINS_RECORDS_RETRIEVED              8030
#define     MSG_WINS_RECORD_LINE                    8031
#define     MSG_WINS_MEMBER_COUNT                   8032
#define     MSG_WINS_NODE_ADDRESS                   8033
#define     MSG_WINS_RECORD_INFO                    8034
#define     MSG_WINS_SEARCHING_STATUS               8035
#define     MSG_SRVR_REPLICATE_STATE                8036
#define     MSG_SRVR_MIGRATE_STATE                  8037
#define     MSG_SRVR_SELFFINDPNRS_STATE             8038
#define     MSG_SRVR_MCAST_INTERVAL                 8039
#define     MSG_SRVR_MCAST_TTL                      8040
#define     MSG_SRVR_PULL_PERSISTENCE_STATE         8041
#define     MSG_SRVR_PUSH_PERSISTENCE_STATE         8042
#define     MSG_SRVR_PULL_INITTIMEREPL_STATE        8043
#define     MSG_SRVR_PUSH_INITTIMEREPL_STATE        8044
#define     MSG_SRVR_PULL_STARTTIME                 8045
#define     MSG_WINS_PULL_REPLINTERVAL              8046
#define     MSG_WINS_PULL_RETRYCOUNT                8047
#define     MSG_SRVR_PUSH_INFO                      8048
#define     MSG_SRVR_PULL_INFO                      8049
#define     MSG_SRVR_PUSH_ONADDCHANGE               8050
#define     MSG_SRVR_PUSH_UPDATECOUNT               8051
#define     MSG_SRVR_AUTOCONFIGURE                  8052
#define     MSG_WINS_PULLPARTNER_INFO               8053
#define     MSG_WINS_PUSHPARTNER_INFO               8054
#define     MSG_WINS_PARTNERLIST_TABLE              8055
#define     MSG_WINS_PARTNERLIST_ENTRY              8056
#define     MSG_WINS_DATABASE_BACKUPPARAM           8057
#define     MSG_WINS_DATABASE_BACKUPDIR             8058
#define     MSG_WINS_DATABASE_BACKUPONTERM          8059
#define     MSG_WINS_NAMERECORD_SETTINGS            8060
#define     MSG_WINS_NAMERECORD_REFRESHINTVL        8061
#define     MSG_WINS_NAMERECORD_TOMBSTONEINTVL      8062
#define     MSG_WINS_NAMERECORD_TOMBSTONETMOUT      8063
#define     MSG_WINS_NAMERECORD_VERIFYINTVL         8064
#define     MSG_WINS_DBCC_PARAM                     8065
#define     MSG_WINS_DBCC_STATE                     8066
#define     MSG_WINS_DBCC_MAXCOUNT                  8067
#define     MSG_WINS_DBCC_CHECKAGAINST              8068
#define     MSG_WINS_DBCC_CHECKEVERY                8069
#define     MSG_WINS_DBCC_STARTAT                   8070
#define     MSG_WINS_LOGGING_PARAM                  8071
#define     MSG_WINS_LOGGING_FLAG                   8072
#define     MSG_WINS_LOGGING_DETAILS                8073
#define     MSG_WINS_BURSTHNDL_PARAM                8074
#define     MSG_WINS_BURSTHNDL_STATE                8075
#define     MSG_WINS_BURSTHNDL_SIZE                 8076
#define     MSG_WINS_TIME_WARNING                   8077
#define     MSG_WINS_SEND_PUSH                      8078
#define     MSG_WINS_SEND_PULL                      8079
#define     MSG_WINS_TRIGGER_DONE                   8080
#define     MSG_DLL_LOAD_FAILED                     8081
#define     MSG_WINS_SERVICE_TIME                   8082
#define     MSG_WINS_SEARCHDB_COUNT                 8083
#define     MSG_WINS_NO_RECORD                      8084
#define     MSG_WINS_RECORDS_SEARCHED               8085
#define     MSG_WINS_RECORD_TABLE                   8086
#define     MSG_WINS_RECORD_ENTRY                   8087
#define     MSG_WINS_RECORD_IPADDRESS               8088
#define     MSG_WINS_RECORD_DESC                    8089
#define     MSG_WINS_NO_PARTNER                     8090
#define     MSG_WINS_PARTNER_COUNT                  8091
#define     MSG_WINS_PNGSERVER_TABLE                8092
#define     MSG_WINS_PNGSERVER_ENTRY                8093
#define     MSG_WINS_NO_PNGSERVER                   8094
#define     MSG_WINS_CONFIRMATION_DENIED            8095
#define     MSG_WINS_COMMAND_QUEUED                 8096
#define     MSG_WINS_DOMAIN_COUNT                   8097
#define     MSG_WINS_DOMAIN_TABLE                   8098
#define     MSG_WINS_DOMAIN_ENTRY                   8099
#define     MSG_WINS_DELETING_RECORD                8101
#define     MSG_WINS_TOMBSTONE_RECORD               8102
#define     MSG_SRVR_FILTER_RECCOUNT                8103
#define     MSG_WINS_RECORDS_COUNT_OWNER            8104
#define     MSG_SRVR_START_VERSION                  8105
#define     MSG_SRVR_RECORD_MATCH                   8106
#define     MSG_WINS_SOTABLE_HEADER                 8107
#define     MSG_WINS_MASTEROWNER_INDEX              8108
#define     MSG_WINS_MASTEROWNER_INDEX1             8109
#define     MSG_WINS_MAP_SOURCE                     8110
#define     MSG_WINS_INDEXTOIP_TABLE                8111
#define     MSG_WINS_INDEXTOIP_ENTRY                8112
#define     MSG_SRVR_MAPTABLE_HEADER                8113
#define     MSG_WINS_GETSTATUS_SUCCESS              8114
#define     MSG_SRVR_SEARCH_COUNT                   8115
#define     MSG_NO_DEFAULT_PULL                     8116
#define     MSG_NO_DEFAULT_PUSH                     8117
#define     MSG_WINS_OWNER_RECCOUNT                 8118
#define     MSG_WINS_GET_MAPTABLE                   8119
#define     MSG_WINS_SEND_NAMEQUERY                 8120
#define     MSG_WINS_PASS_COUNT                     8121
#define     MSG_WINS_DISPLAY_STRING                 8122
#define     MSG_SRVR_NAME_VERIFIED                  8123
#define     MSG_WINS_RESULTS                        8124
#define     MSG_WINS_FINAL_RESULTS                  8125
#define     MSG_SRVR_TOTAL_RECCOUNT                 8126
#define     MSG_SRVR_RETRIEVE_DATABASE              8127
#define     MSG_WINS_PGSERVER_TABLE                 8128
#define     MSG_WINS_PGSERVER_ENTRY                 8129
#define     MSG_WINS_NO_PGSERVER                    8130

#define     FMSG_WINS_RECORDS_INFO                  8501
#define     FMSG_WINS_IPADDRESS_STRING              8502
#define     FMSG_WINS_OWNER_ADDRESS                 8603
#define     FMSG_WINS_RECORD_TABLE                  8604
#define     FMSG_WINS_IPADDRESS_LIST                8605
#define     FMSG_WINS_RECORD_IPADDRESS              8606
#define     FMSG_WINS_RECORD_ENTRY                  8607
#define     FMSG_WINS_RECORDS_TABLE                 8608
#define     FMSG_WINS_SOTABLE_HEADER                8609
#define     FMSG_WINS_MASTEROWNER_INDEX             8610
#define     FMSG_WINS_MASTEROWNER_INDEX1            8611
#define     FMSG_WINS_MAP_SOURCE                    8612
#define     FMSG_WINS_INDEXTOIP_TABLE               8613
#define     FMSG_WINS_INDEXTOIP_ENTRY               8614


#define     DMP_SRVR_SET_BACKUPPATH                 9101
#define     DMP_SRVR_SET_NAMERECORD                 9102
#define     DMP_SRVR_SET_PERIODICDBCHECKING         9103
#define     DMP_SRVR_SET_REPLICATEFLAG              9104
#define     DMP_SRVR_SET_MIGRATEFLAG                9105
#define     DMP_SRVR_SET_PULLPARAM                  9106
#define     DMP_SRVR_SET_PUSHPARAM                  9107
#define     DMP_SRVR_ADD_PARTNER                    9108
#define     DMP_SRVR_SET_PULLPERSISTENTCONNECTION   9109
#define     DMP_SRVR_SET_PUSHPERSISTENTCONNECTION   9110
#define     DMP_SRVR_SET_AUTOPARTNERCONFIG          9111
#define     DMP_SRVR_SET_PGMODE                     9112
#define     DMP_SRVR_ADD_PNGSERVER                  9113
#define     DMP_SRVR_ADD_PGSERVER                   9114
#define     DMP_SRVR_SET_BURSTPARAM                 9115
#define     DMP_SRVR_SET_BURSTPARAM_ALL             9116
#define     DMP_SRVR_SET_LOGPARAM                   9117
#define     DMP_SRVR_SET_STARTVERSION               9118
#define     DMP_SRVR_SET_BACKUPTERM                 9119


#define     WINS_TYPE_STATIC                        9500
#define     WINS_TYPE_DYNAMIC                       9501

#define     WINS_STATE_ACTIVE                       9505
#define     WINS_STATE_RELEASED                     9506
#define     WINS_STATE_TOMBSTONE                    9507

#define     WINS_GROUP_UNIQUE                       9510
#define     WINS_GROUP_GROUP                        9511
#define     WINS_GROUP_DOMAIN                       9512
#define     WINS_GROUP_INTERNET                     9513
#define     WINS_GROUP_MULTIHOMED                   9514


#define     WINS_GENERAL_UNKNOWN                    9520
#define     WINS_GENERAL_ENABLE                     9521
#define     WINS_GENERAL_DISABLE                    9522
#define     WINS_GENERAL_RANDOM                     9523
#define     WINS_GENERAL_OWNER                      9524
#define     WINS_GENERAL_INFINITE                   9525
#define     WINS_GENERAL_PUSH                       9526
#define     WINS_GENERAL_PULL                       9527
#define     WINS_GENERAL_PUSHPULL                   9528
#define     WINS_GENERAL_NORMAL                     9529
#define     WINS_GENERAL_HIGH                       9530
#define     WINS_GENERAL_DELETED                    9531
#define     WINS_GENERAL_OK                         9532
#define     WINS_GENERAL_FAILURE                    9533
#define     WINS_GENERAL_READWRITE                  9534
#define     WINS_GENERAL_READ                       9535
#define     WINS_GENERAL_NOREAD                     9536 
#define     WINS_GENERAL_NAMENOTVERIFIED            9537                    



#endif //_STRDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\netsh\srvrmon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\wins\srvrmon.c

Abstract:

    WINS Server Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 12/14/98

--*/

#include "precomp.h"

LPWSTR                  g_ServerNameUnicode = NULL;
LPSTR                   g_ServerNameAnsi = NULL;
CHAR                    g_ServerIpAddressAnsiString[MAX_IP_STRING_LEN+1] = {'\0'};
WCHAR                   g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1] = {L'\0'};
HKEY                    g_hServerRegKey = NULL;
WCHAR                   g_ServerNetBiosName[MAX_COMPUTER_NAME_LEN] = {L'\0'};


handle_t                g_hBind = NULL;
WINSINTF_BIND_DATA_T    g_BindData;

BOOL    g_fServer = FALSE;

CMD_ENTRY g_SrvrAddCmdTable[] =
{
    CREATE_CMD_ENTRY(SRVR_ADD_NAME, HandleSrvrAddName),
    CREATE_CMD_ENTRY(SRVR_ADD_PARTNER, HandleSrvrAddPartner),
    CREATE_CMD_ENTRY(SRVR_ADD_PNGSERVER, HandleSrvrAddPersona),
    CREATE_CMD_ENTRY(SRVR_ADD_PGSERVER, HandleSrvrAddPersona)
};

CMD_ENTRY g_SrvrCheckCmdTable[] =
{
    CREATE_CMD_ENTRY(SRVR_CHECK_DATABASE, HandleSrvrCheckDatabase),
    CREATE_CMD_ENTRY(SRVR_CHECK_NAME, HandleSrvrCheckName),
    CREATE_CMD_ENTRY(SRVR_CHECK_VERSION, HandleSrvrCheckVersion),
};

CMD_ENTRY g_SrvrDeleteCmdTable[] =
{
    CREATE_CMD_ENTRY(SRVR_DELETE_NAME, HandleSrvrDeleteName),
    CREATE_CMD_ENTRY(SRVR_DELETE_PARTNER, HandleSrvrDeletePartner),
    CREATE_CMD_ENTRY(SRVR_DELETE_RECORDS, HandleSrvrDeleteRecords),
    CREATE_CMD_ENTRY(SRVR_DELETE_WINS, HandleSrvrDeleteWins),
    CREATE_CMD_ENTRY(SRVR_DELETE_PNGSERVER, HandleSrvrDeletePersona),
    CREATE_CMD_ENTRY(SRVR_DELETE_PGSERVER, HandleSrvrDeletePersona)
};

CMD_ENTRY g_SrvrInitCmdTable[] =
{
    CREATE_CMD_ENTRY(SRVR_INIT_BACKUP, HandleSrvrInitBackup),
    CREATE_CMD_ENTRY(SRVR_INIT_IMPORT, HandleSrvrInitImport),
    CREATE_CMD_ENTRY(SRVR_INIT_PULL, HandleSrvrInitPull),
    CREATE_CMD_ENTRY(SRVR_INIT_PULLRANGE, HandleSrvrInitPullrange),
    CREATE_CMD_ENTRY(SRVR_INIT_PUSH, HandleSrvrInitPush),
    CREATE_CMD_ENTRY(SRVR_INIT_REPLICATE, HandleSrvrInitReplicate),
    CREATE_CMD_ENTRY(SRVR_INIT_RESTORE, HandleSrvrInitRestore),
    CREATE_CMD_ENTRY(SRVR_INIT_SCAVENGE, HandleSrvrInitScavenge),
    CREATE_CMD_ENTRY(SRVR_INIT_SEARCH, HandleSrvrInitSearch),
};

CMD_ENTRY g_SrvrResetCmdTable[] =
{
    CREATE_CMD_ENTRY(SRVR_RESET_COUNTER, HandleSrvrResetCounter),
};

CMD_ENTRY g_SrvrSetCmdTable[] =
{
    CREATE_CMD_ENTRY(SRVR_SET_AUTOPARTNERCONFIG, HandleSrvrSetAutopartnerconfig),
    CREATE_CMD_ENTRY(SRVR_SET_BACKUPPATH, HandleSrvrSetBackuppath),
    CREATE_CMD_ENTRY(SRVR_SET_BURSTPARAM, HandleSrvrSetBurstparam),
	CREATE_CMD_ENTRY(SRVR_SET_DEFAULTPARAM, HandleSrvrSetDefaultparam),
    CREATE_CMD_ENTRY(SRVR_SET_LOGPARAM, HandleSrvrSetLogparam),
    CREATE_CMD_ENTRY(SRVR_SET_MIGRATEFLAG, HandleSrvrSetMigrateflag),
    CREATE_CMD_ENTRY(SRVR_SET_NAMERECORD, HandleSrvrSetNamerecord),
    CREATE_CMD_ENTRY(SRVR_SET_PERIODICDBCHECKING, HandleSrvrSetPeriodicdbchecking),
    CREATE_CMD_ENTRY(SRVR_SET_PULLPERSISTENTCONNECTION, HandleSrvrSetPullpersistentconnection),
    CREATE_CMD_ENTRY(SRVR_SET_PUSHPERSISTENTCONNECTION, HandleSrvrSetPushpersistentconnection),
    CREATE_CMD_ENTRY(SRVR_SET_PULLPARAM, HandleSrvrSetPullparam),
    CREATE_CMD_ENTRY(SRVR_SET_PUSHPARAM, HandleSrvrSetPushparam),
    CREATE_CMD_ENTRY(SRVR_SET_REPLICATEFLAG, HandleSrvrSetReplicateflag),   
    CREATE_CMD_ENTRY(SRVR_SET_STARTVERSION, HandleSrvrSetStartversion),
    CREATE_CMD_ENTRY(SRVR_SET_PGMODE, HandleSrvrSetPersMode)
};

CMD_ENTRY g_SrvrShowCmdTable[] =
{
    CREATE_CMD_ENTRY(SRVR_SHOW_DOMAIN, HandleSrvrShowDomain),
    CREATE_CMD_ENTRY(SRVR_SHOW_DATABASE, HandleSrvrShowDatabase),
    CREATE_CMD_ENTRY(SRVR_SHOW_INFO, HandleSrvrShowInfo),
    CREATE_CMD_ENTRY(SRVR_SHOW_NAME, HandleSrvrShowName),
    CREATE_CMD_ENTRY(SRVR_SHOW_PARTNER, HandleSrvrShowPartner),
    CREATE_CMD_ENTRY(SRVR_SHOW_PARTNERPROPERTIES, HandleSrvrShowPartnerproperties),
    CREATE_CMD_ENTRY(SRVR_SHOW_PULLPARTNERPROPERTIES, HandleSrvrShowPullpartnerproperties),
    CREATE_CMD_ENTRY(SRVR_SHOW_PUSHPARTNERPROPERTIES, HandleSrvrShowPushpartnerproperties),
    CREATE_CMD_ENTRY(SRVR_SHOW_RECCOUNT, HandleSrvrShowReccount),
    CREATE_CMD_ENTRY(SRVR_SHOW_RECBYVERSION, HandleSrvrShowRecbyversion),
    CREATE_CMD_ENTRY(SRVR_SHOW_SERVER, HandleSrvrShowServer),
    CREATE_CMD_ENTRY(SRVR_SHOW_SERVERSTATISTICS, HandleSrvrShowStatistics),
    CREATE_CMD_ENTRY(SRVR_SHOW_VERSION, HandleSrvrShowVersion),
    CREATE_CMD_ENTRY(SRVR_SHOW_VERSIONMAP, HandleSrvrShowVersionmap),
};

CMD_GROUP_ENTRY g_SrvrCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_SrvrAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_CHECK, g_SrvrCheckCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_SrvrDeleteCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_INIT, g_SrvrInitCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_RESET, g_SrvrResetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_SrvrSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_SrvrShowCmdTable),
};


CMD_ENTRY g_SrvrCmds[] = 
{
    CREATE_CMD_ENTRY(WINS_DUMP, HandleSrvrDump),
    CREATE_CMD_ENTRY(WINS_HELP1, HandleSrvrHelp),
    CREATE_CMD_ENTRY(WINS_HELP2, HandleSrvrHelp),
    CREATE_CMD_ENTRY(WINS_HELP3, HandleSrvrHelp),
    CREATE_CMD_ENTRY(WINS_HELP4, HandleSrvrHelp),
};


ULONG g_ulSrvrNumTopCmds = sizeof(g_SrvrCmds)/sizeof(CMD_ENTRY);
ULONG g_ulSrvrNumGroups = sizeof(g_SrvrCmdGroups)/sizeof(CMD_GROUP_ENTRY);


DWORD
WINAPI
SrvrCommit(
    IN  DWORD   dwAction
)
{
   BOOL    bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. Srvr current state is commit, then
            // nothing to be done.
            //

            if(g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    return NO_ERROR;
}


DWORD
WINAPI
SrvrMonitor(
    IN      LPCWSTR     pwszMachine,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      DWORD       dwFlags,
    IN      LPCVOID     pvData,
    OUT     LPWSTR      pwcNewContext
    )
{
    DWORD                   dwError = NO_ERROR;
    DWORD                   dwIndex, i, j, k;
    BOOL                    bFound = FALSE;
    PFN_HANDLE_CMD          pfnHandler = NULL;
    PNS_CONTEXT_ENTRY_FN    pfnHelperEntryPt;
    PNS_CONTEXT_DUMP_FN     pfnHelperDumpPt;
    WCHAR                   wcSvrTemp[MAX_IP_STRING_LEN+1] = {L'\0'};
    BOOL                    fTemp = FALSE;
    DWORD                   dwNumMatched;
    DWORD                   dwCmdHelpToken = 0;

    if(dwArgCount is 1)
    {
        //Hmm! Hasn't passed any Server Info. Set the server to the value pwsRouter
        WCHAR ServerInfo[1000] = L"\\\\";

        if( pwszMachine and
            wcslen(pwszMachine) > 2 and
            wcsncmp(pwszMachine, L"\\\\", 2) and
            IsIpAddress(pwszMachine) is FALSE )
        {
            wcscpy(&ServerInfo[2], pwszMachine );
            pwszMachine = ServerInfo;

        }
        
        if( FALSE is SetServerInfo(pwszMachine) )
        {
            return GetLastError();
        }
        else
        {
            // wcscpy(pwcNewContext, L"wins server");
            g_fServer = TRUE;
            return ERROR_CONTEXT_SWITCH;
        }
    }

    dwIndex = 1;

    //If it is a help for server command
    if( IsHelpToken(ppwcArguments[dwIndex]) is TRUE and
        g_fServer is FALSE )
    {
        DisplayMessage(g_hModule, HLP_WINS_CONTEXT_SERVER_EX);
        dwError = NO_ERROR;
        goto CleanUp;
    }
    //Is it a servername or address?
    if( IsValidServer(ppwcArguments[dwIndex]) )
    {
        if( g_fServer is TRUE and
            dwArgCount > 2 )
        {
            wcscpy(wcSvrTemp, g_ServerIpAddressUnicodeString);
            fTemp = TRUE;
        }
        if( FALSE is SetServerInfo(ppwcArguments[dwIndex]) )
        {
            dwError = GetLastError();
            goto CleanUp;
        }

        pwcNewContext[wcslen(pwcNewContext)- wcslen(ppwcArguments[dwIndex]) -1 ] = L'\0';
   
        dwIndex++;
        g_fServer = TRUE;

    }
    else if( g_fServer is FALSE )
    {
        WCHAR ServerInfo[1000] = L"\\\\";

        if( pwszMachine and
            wcslen(pwszMachine) > 2 and
            wcsncmp(pwszMachine, L"\\\\", 2) and
            IsIpAddress(pwszMachine) is FALSE )
        {
            wcscpy(&ServerInfo[2], pwszMachine );
            pwszMachine = ServerInfo;
        }

        if( FALSE is SetServerInfo(pwszMachine) )
        {
            dwError = GetLastError();
            goto CleanUp;
        }
        g_fServer = TRUE;
    }

    
    if( dwIndex >= dwArgCount )
    {            
        dwError = ERROR_CONTEXT_SWITCH;
        //wcscpy(pwcNewContext, L"wins server");
        goto CleanUp;
    }

    //Is it a top level(non Group command)?
    for(i=0; i<g_ulSrvrNumTopCmds; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_SrvrCmds[i].pwszCmdToken))
        {
            bFound = TRUE;

            pfnHandler = g_SrvrCmds[i].pfnCmdHandler;

            dwCmdHelpToken = g_SrvrCmds[i].dwCmdHlpToken;
            
            dwIndex++;

            break;
        }
    }


    if(bFound)
    {
        if(dwArgCount > 3 && IsHelpToken(ppwcArguments[dwIndex]))
        {
            DisplayMessage(g_hModule, dwCmdHelpToken);

            dwError = NO_ERROR;
            goto CleanUp;
        }
        
        dwIndex++;

        dwError = (*pfnHandler)(pwszMachine, ppwcArguments, dwIndex, dwArgCount,
                                dwFlags, pvData, &bFound);

        goto CleanUp;
    }
 
    bFound = FALSE;

    //It is not a non Group Command. Then is it a config command for the manager?
    for(i = 0; (i < g_ulSrvrNumGroups) and !bFound; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_SrvrCmdGroups[i].pwszCmdGroupToken))
        {
            //
            // Command matched entry i, so look at the table of sub commands 
            // for this command
            //
            if( dwArgCount > dwIndex+1 )
            {
                for (j = 0; j < g_SrvrCmdGroups[i].ulCmdGroupSize; j++)
                {
                    if (MatchCmdLine(ppwcArguments+dwIndex,
                                      dwArgCount - 1,
                                      g_SrvrCmdGroups[i].pCmdGroup[j].pwszCmdToken,
                                      &dwNumMatched))
                    {
                        bFound = TRUE;
                
                        pfnHandler = g_SrvrCmdGroups[i].pCmdGroup[j].pfnCmdHandler;
                
                        dwCmdHelpToken = g_SrvrCmdGroups[i].pCmdGroup[j].dwCmdHlpToken;

                        //
                        // break out of the for(j) loop
                        //
                        dwIndex+=dwNumMatched;
                        break;
                    }
                }
            }

            if(!bFound)
            {
                //
                // We matched the command group token but none of the
                // sub commands
                //

                DisplayMessage(g_hModule, 
                               EMSG_WINS_INCOMPLETE_COMMAND);

                for (j = 0; j < g_SrvrCmdGroups[i].ulCmdGroupSize; j++)
                {
                    DisplayMessage(g_hModule, 
                             g_SrvrCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);
                    
					DisplayMessage(g_hModule, WINS_FORMAT_LINE);
                }

                dwError = ERROR_INVALID_PARAMETER;
                goto CleanUp;
            }
            else
            {
                //
                // quit the for(i)
                //

                break;
            }
        }
    }




    if (!bFound)
    {
        //
        // Command not found. 
        //
        if( _wcsicmp(ppwcArguments[dwIndex], L"..") is 0 )
        {
            if(g_ServerNameUnicode)
            {
                WinsFreeMemory(g_ServerNameUnicode);
                g_ServerNameUnicode = NULL;
            }
            memset(g_ServerIpAddressUnicodeString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));
            memset(g_ServerIpAddressAnsiString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(CHAR));
            g_fServer = FALSE;
        }

        dwError = ERROR_CMD_NOT_FOUND;
        goto CleanUp;
    }

    //
    // See if it is a request for help.
    //

    if (dwNumMatched < (dwArgCount - 1) and
        wcslen(ppwcArguments[dwNumMatched+1]) > 0 and
        IsHelpToken(ppwcArguments[dwNumMatched + 1]))
    {
        DisplayMessage(g_hModule, dwCmdHelpToken);

        dwError = NO_ERROR;
        goto CleanUp;
    }
    
    //
    // Call the parsing routine for the command
    //

    dwError = (*pfnHandler)(pwszMachine, ppwcArguments, dwIndex, 
                            dwArgCount, dwFlags, pvData, &bFound);

    if( dwError is ERROR_CONTEXT_SWITCH )
    {
        goto CleanUp;
    }
CleanUp:
    if( fTemp )
    {
        fTemp = SetServerInfo(wcSvrTemp);
    }

    return dwError;
}


DWORD
WINAPI
SrvrUnInit(
    IN  DWORD   dwReserved
)
{
    return NO_ERROR;
}

BOOL
SetServerInfo(
    IN  LPCWSTR  pwszServerInfo
)
{
    BOOL    fReturn = TRUE;
    DWORD   dwComputerNameLen = 0;
    LPSTR   pszComputerName = NULL;
    LPWSTR  pwszComputerName = NULL;
    struct  hostent * lpHostEnt = NULL;
    BYTE    pbAdd[4];
    char    szAdd[4];
    DWORD   dwHostName = 0;
    DWORD   dwIpAddress = 0;
    DWORD   i = 0, nLen = 0;
    DWORD   Status = 0;
    DWORD   Access = 0;
    CHAR    *pTemp = NULL,
            *pTemp1 = NULL;
    DWORD   dwTempLen = 0;
    CHAR    cTempIp[MAX_IP_STRING_LEN+1] = {L'\0'};
    WCHAR   wTempIp[MAX_IP_STRING_LEN+1] = {'\0'};
    LPWSTR  pwszTempServer = NULL;
    LPSTR   pszTempServer = NULL;
    WCHAR   wTempNetBios[MAX_COMPUTER_NAME_LEN] = {L'\0'};

    handle_t                hTempBind = NULL;
    WINSINTF_BIND_DATA_T    TempBindData;

    LPWSTR  pwsz = NULL;
    LPSTR   psz = NULL;
    
    
    if( g_ServerNameUnicode isnot NULL and
        IsIpAddress(g_ServerIpAddressUnicodeString) is TRUE )
    {
        strcpy(cTempIp, g_ServerIpAddressAnsiString);
        wcscpy(wTempIp, g_ServerIpAddressUnicodeString);
        pwszTempServer = g_ServerNameUnicode;
        pszTempServer = g_ServerNameAnsi;
        wcscpy(wTempNetBios, g_ServerNetBiosName);
    }

    memset(g_ServerNetBiosName, 0x00, MAX_COMPUTER_NAME_LEN*sizeof(WCHAR));

    g_ServerNetBiosName[0] = L'\\';
    g_ServerNetBiosName[1] = L'\\';

    
    if( pwszServerInfo is NULL )
    {
        if( !GetComputerNameEx(ComputerNameDnsFullyQualified,
                              NULL,
                              &dwComputerNameLen) )
        {
            
            pwszComputerName = WinsAllocateMemory((dwComputerNameLen+1)*sizeof(WCHAR));

            if(pwszComputerName is NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                fReturn = FALSE;
                goto RETURN;
            }
            
            dwComputerNameLen++;
            if( !GetComputerNameEx(ComputerNameDnsFullyQualified,
                                   pwszComputerName,
                                   &dwComputerNameLen) )
            {
                fReturn = FALSE;
                goto RETURN;
            }

        }
        else
        {
            fReturn = FALSE;
            goto RETURN;
        }
    }

    else    //might be a computer name or IP address. Determine what.
    {
        if( wcslen(pwszServerInfo) > 2 and
            _wcsnicmp(pwszServerInfo, L"\\\\", 2) is 0 )
        {

            pwszComputerName = WinsAllocateMemory((wcslen(pwszServerInfo) - 1)*sizeof(WCHAR));
            if( pwszComputerName is NULL )
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                fReturn = FALSE;
                goto RETURN;
            }
            
            memcpy(pwszComputerName, 
                   (pwszServerInfo+2), 
                   (wcslen(pwszServerInfo) - 1)*sizeof(WCHAR));
        }
        else if( IsIpAddress(pwszServerInfo) is TRUE )    //it is an IP Address
        {

            memset(g_ServerIpAddressUnicodeString, 0x00, 
                   (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));
            

            wcscpy(g_ServerIpAddressUnicodeString, 
                    pwszServerInfo);


            memset(g_ServerIpAddressAnsiString, 0x00, 
                   (MAX_IP_STRING_LEN+1)*sizeof(CHAR));

            psz = WinsUnicodeToAnsi(g_ServerIpAddressUnicodeString, NULL);

            if( psz )
            {
                strcpy(g_ServerIpAddressAnsiString, psz);
                WinsFreeMemory(psz);
                psz = NULL;
            }
           
            dwIpAddress = inet_addr(g_ServerIpAddressAnsiString);


            lpHostEnt = gethostbyaddr((char *)&dwIpAddress, 4, AF_INET);
            
            if( lpHostEnt is NULL )
            {
                DisplayMessage(g_hModule, EMSG_WINS_UNKNOWN_SERVER);
                fReturn = FALSE;
                goto RETURN;
            }

            dwHostName = strlen(lpHostEnt->h_name);

            g_ServerNameAnsi = WinsAllocateMemory(dwHostName+1);

            if (g_ServerNameAnsi == NULL)
                goto RETURN;

            strcpy(g_ServerNameAnsi, lpHostEnt->h_name);
            
            g_ServerNameUnicode = WinsAllocateMemory((dwHostName+1)*sizeof(WCHAR));
         
            wcscpy(g_ServerNameUnicode, WinsAnsiToUnicode(lpHostEnt->h_name, NULL));
            //Bind the server
            
            if( hTempBind )
            {
                //Unbind any previous server
                WinsUnbind(&TempBindData, hTempBind);
                hTempBind = NULL;
            }

            TempBindData.fTcpIp = TRUE;
            TempBindData.pServerAdd = (LPBYTE)g_ServerIpAddressUnicodeString;
            TempBindData.pPipeName = (LPBYTE)g_ServerNameUnicode;
            hTempBind = WinsBind(&TempBindData);

            if (hTempBind == NULL)
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_BIND_FAILED,
                               g_ServerNameUnicode);
                fReturn = FALSE;
                goto RETURN;
            }


            //Make sure this is the correct address for the WINS
            {
                WINSINTF_ADD_T  WinsAdd = {0};
                UCHAR           pName[256] = {'\0'};

                Status = WinsGetNameAndAdd(hTempBind,
                                           &WinsAdd,
                                           pName);

                if( Status is NO_ERROR )
                {
                    LPWSTR  pAdd = IpAddressToString(WinsAdd.IPAdd);

                    if( pAdd is NULL )
                    {
                        fReturn = FALSE;
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        goto RETURN;

                    }
                    wcscpy(g_ServerIpAddressUnicodeString,
                           pAdd);
                    
                    psz = WinsUnicodeToAnsi(g_ServerIpAddressUnicodeString, NULL);

                    if( psz )
                    {
                        strcpy(g_ServerIpAddressAnsiString, psz );
                        WinsFreeMemory(psz);
                        psz = NULL;
                    }
                    
                    pwsz = WinsAnsiToUnicode(pName, NULL);
                    if( pwsz )
                    {
                        wcscpy( g_ServerNetBiosName+2, g_ServerIpAddressUnicodeString);
                        WinsFreeMemory(pwsz);
                        pwsz = NULL;
                    }
                    else
                    {
                        DisplayMessage(g_hModule,
                                       EMSG_WINS_OUT_OF_MEMORY);
                        fReturn = FALSE;
                        WinsFreeMemory(pAdd);
                        pAdd = NULL;
                        goto RETURN;
                    }
                    WinsFreeMemory(pAdd);
                    pAdd = NULL;
                }
                else
                {
                    DisplayErrorMessage(EMSG_WINS_VERIFY_ADDRESS,
                                        Status);
                }


            }

            //find out what type of access do we have
            Access = WINS_NO_ACCESS;
            Status = WinsCheckAccess(hTempBind, &Access);

            if( Status is RPC_S_PROCNUM_OUT_OF_RANGE )
            {
                DisplayMessage(g_hModule,
                               EMSG_ACCESS_NOT_DETERMINED,
                               g_ServerNameUnicode);
 
                if( g_hBind )
                {
                    WinsUnbind(&g_BindData, g_hBind);
                }
        
                g_hBind = hTempBind;
                g_BindData = TempBindData;
                fReturn = TRUE;
                goto RETURN;
            }
            else if (WINSINTF_SUCCESS == Status) 
            {
                  DisplayMessage(g_hModule, 
                                 MSG_WINS_ACCESS,
                                 (Access ? (Access == WINS_CONTROL_ACCESS ? wszReadwrite : wszRead )
                                 : wszNo ),
                                 g_ServerNameUnicode);
                  
                  if( Access is WINS_NO_ACCESS )                  
                  {
                      fReturn = FALSE;
                      goto RETURN;
                  }

                  if( g_hBind )
                  {
                      WinsUnbind(&g_BindData, g_hBind);
                  }
                  g_hBind = hTempBind;
                  g_BindData = TempBindData;

                  fReturn = TRUE;
                  goto RETURN;
            }
            else
            {
                DisplayErrorMessage(EMSG_WINS_GETSTATUS_FAILED,
                                    Status);
                {
                    fReturn = FALSE;
                    goto RETURN;
                }
            }
            
            fReturn = TRUE;
            goto RETURN;
        }

    }
    
    //Now process the Computer name and convert it to ANSI because
    //gethostbyname requires ANSI character string.

    {
        int dw = 0;
        
        dw = WideCharToMultiByte(CP_ACP,
                                 0,
                                 pwszComputerName,
                                 wcslen(pwszComputerName),
                                 pszComputerName,
                                 0,
                                 NULL,
                                 NULL);

        if( dw is 0 )
        {
            fReturn = FALSE;
            return FALSE;
        }

        pszComputerName = WinsAllocateMemory((dw+1)*sizeof(CHAR));

        if( pszComputerName is NULL )
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            fReturn = FALSE;
            goto RETURN;
        }

        dw = WideCharToMultiByte(CP_ACP,
                                 0,
                                 pwszComputerName,
                                 wcslen(pwszComputerName),
                                 pszComputerName,
                                 dw+1,
                                 NULL,
                                 NULL);

        if( dw is 0 )
        {
            fReturn = FALSE;
            goto RETURN;
        }

    }

    //Now get the server IP Address
    lpHostEnt = gethostbyname(pszComputerName);

    //Not a valid server name
    if( lpHostEnt is NULL )
    {
        DisplayMessage(g_hModule, EMSG_WINS_INVALID_COMPUTERNAME);
        if( pszComputerName )
        {
            WinsFreeMemory(pszComputerName);
            pszComputerName = NULL;
        }
        fReturn = FALSE;        
        goto RETURN;
    }

    //Get the IP Address from the returned struct...
    memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
    nLen = 0;
    for( i=0; i<4; i++)
    {

        _itoa((int)pbAdd[i], szAdd, 10);
        memcpy(g_ServerIpAddressAnsiString+nLen, szAdd, strlen(szAdd));
        nLen += strlen(szAdd);
        *(g_ServerIpAddressAnsiString+nLen) = '.';
        nLen++;
    
    }
    *(g_ServerIpAddressAnsiString+nLen-1) = '\0';

    dwIpAddress = WinsDottedStringToIpAddress(g_ServerIpAddressAnsiString);
    dwHostName = strlen(g_ServerIpAddressAnsiString);

    //Convert IP Address to a Unicode string and store it to the global variable.


    memset(g_ServerIpAddressUnicodeString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));

    pwsz = WinsAnsiToUnicode(g_ServerIpAddressAnsiString, NULL);

    if( pwsz )
    {
        wcscpy(g_ServerIpAddressUnicodeString, pwsz);
        WinsFreeMemory(pwsz);
        pwsz = NULL;
    }
    else
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_OUT_OF_MEMORY);
        fReturn = FALSE;
        goto RETURN;
    }

    g_ServerNameAnsi = WinsAllocateMemory(strlen(lpHostEnt->h_name)+1);

    g_ServerNameUnicode = WinsAllocateMemory((strlen(lpHostEnt->h_name) + 1)*sizeof(WCHAR));

    if( ( g_ServerNameUnicode is NULL ) or
        ( g_ServerNameAnsi is NULL ) )
    {
        DisplayMessage(g_hModule, EMSG_WINS_NOT_ENOUGH_MEMORY);
        if( pszComputerName )
        {
            WinsFreeMemory(pszComputerName);
            pszComputerName = NULL;
        }
        if( pwszComputerName )
        {
            WinsFreeMemory(pwszComputerName);
            pwszComputerName = NULL;
        }

        fReturn = FALSE;
        goto RETURN;
    }
    
    strcpy(g_ServerNameAnsi, lpHostEnt->h_name);

    {
        int dw = 0;
        dw = MultiByteToWideChar(CP_ACP, 
                                 0, 
                                 lpHostEnt->h_name, 
                                 strlen(lpHostEnt->h_name),
                                 g_ServerNameUnicode,
                                 (strlen(lpHostEnt->h_name)+1)*sizeof(WCHAR));

        if ( dw = 0 )
        {
            fReturn = FALSE;
            goto RETURN;
        }
    }
    //Bind the server
    TempBindData.fTcpIp = TRUE;
    TempBindData.pServerAdd = (LPBYTE)g_ServerIpAddressUnicodeString;
    TempBindData.pPipeName = (LPBYTE)g_ServerNameUnicode;
    hTempBind = WinsBind(&TempBindData);

    if (hTempBind == NULL)
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_BIND_FAILED,
                       g_ServerIpAddressUnicodeString);

        SetLastError(ERROR_INVALID_PARAMETER);
        fReturn = FALSE;
        goto RETURN;
    }

    //Make sure this is the correct address for the WINS
    {
        WINSINTF_ADD_T  WinsAdd = {0};
        UCHAR           pName[256] = {'\0'};

        Status = WinsGetNameAndAdd(hTempBind,
                                   &WinsAdd,
                                   pName);

        if( Status is NO_ERROR )
        {
            LPWSTR  pAdd = IpAddressToString(WinsAdd.IPAdd);

            if( pAdd is NULL )
            {
                fReturn = FALSE;
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto RETURN;

            }
            wcscpy(g_ServerIpAddressUnicodeString,
                   pAdd);
            
            psz = WinsUnicodeToOem(pAdd, NULL);
            if( psz )
            {
                strcpy(g_ServerIpAddressAnsiString, psz);
                WinsFreeMemory(psz);
                psz = NULL;
            }
            
            pwsz = WinsOemToUnicode(pName, NULL);
            if( pwsz )
            {
                wcscpy( g_ServerNetBiosName+2, g_ServerIpAddressUnicodeString);
                WinsFreeMemory(pwsz);
                pwsz = NULL;
            }
            else
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_OUT_OF_MEMORY);
                fReturn = FALSE;
                goto RETURN;
            }
           
            WinsFreeMemory(pAdd);
            pAdd = NULL;
        }
        else
        {
            DisplayErrorMessage(EMSG_WINS_VERIFY_ADDRESS,
                                Status);
        }


    }

    //find out what type of access do we have
    Access = WINS_NO_ACCESS;
    Status = WinsCheckAccess(hTempBind, &Access);

    if( Status is RPC_S_PROCNUM_OUT_OF_RANGE )
    {
        DisplayMessage(g_hModule,
                       EMSG_ACCESS_NOT_DETERMINED,
                       g_ServerNameUnicode);
 
        if( g_hBind )
        {
            WinsUnbind(&g_BindData, g_hBind);
        }
        
        g_hBind = hTempBind;
        g_BindData = TempBindData;
        fReturn = TRUE;
        goto RETURN;
    }
    else if (WINSINTF_SUCCESS == Status) 
    {
        DisplayMessage(g_hModule, 
                       MSG_WINS_ACCESS,
                       (Access ? (Access == WINS_CONTROL_ACCESS ? wszReadwrite : wszRead )
                        : wszNo ),
                       g_ServerNameUnicode);
        
        if( Access is WINS_NO_ACCESS )
        {
            fReturn = FALSE;
            goto RETURN;
        }

        if( g_hBind )
        {
            WinsUnbind(&g_BindData, g_hBind);
        }
        g_hBind = hTempBind;
        g_BindData = TempBindData;
        fReturn = TRUE;
        goto RETURN;

    }
    else
    {
        DisplayErrorMessage(EMSG_WINS_GETSTATUS_FAILED,
                            Status);
        fReturn = FALSE;
        goto RETURN;
    }

RETURN:
    if( pszComputerName)
    {
        WinsFreeMemory(pszComputerName);
        pszComputerName = NULL;
    }

    if( pwszComputerName )
    {
        WinsFreeMemory(pwszComputerName);
        pwszComputerName = NULL;
    }

    if( pTemp1 )
    {
        WinsFreeMemory(pTemp1);
        pTemp1 = NULL;
    }

    if( fReturn is FALSE )
    {
        wcscpy(g_ServerIpAddressUnicodeString, wTempIp);
        strcpy(g_ServerIpAddressAnsiString, cTempIp);
        g_ServerNameUnicode = pwszTempServer;
        g_ServerNameAnsi = pszTempServer;
        wcscpy(g_ServerNetBiosName, wTempNetBios);
    }
    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\netsh\srvrhndl.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/
#ifndef _WINSSRVR_H_
#define _WINSSRVR_H_

FN_HANDLE_CMD  HandleSrvrHelp;
FN_HANDLE_CMD  HandleSrvrContexts;
FN_HANDLE_CMD  HandleSrvrDump;

FN_HANDLE_CMD  HandleSrvrAddName;
FN_HANDLE_CMD  HandleSrvrAddPartner;
FN_HANDLE_CMD  HandleSrvrAddPersona;

FN_HANDLE_CMD  HandleSrvrCheckDatabase;
FN_HANDLE_CMD  HandleSrvrCheckVersion;
FN_HANDLE_CMD  HandleSrvrCheckName;

FN_HANDLE_CMD  HandleSrvrDeleteName;
FN_HANDLE_CMD  HandleSrvrDeleteRecords;
FN_HANDLE_CMD  HandleSrvrDeleteWins;
FN_HANDLE_CMD  HandleSrvrDeletePartner;
FN_HANDLE_CMD  HandleSrvrDeletePersona;

FN_HANDLE_CMD  HandleSrvrInitBackup;
//FN_HANDLE_CMD  HandleSrvrInitCompact;
//FN_HANDLE_CMD  HandleSrvrInitExport;
FN_HANDLE_CMD  HandleSrvrInitImport;
FN_HANDLE_CMD  HandleSrvrInitPush;
FN_HANDLE_CMD  HandleSrvrInitPullrange;
FN_HANDLE_CMD  HandleSrvrInitPull;
FN_HANDLE_CMD  HandleSrvrInitReplicate;
FN_HANDLE_CMD  HandleSrvrInitRestore;
FN_HANDLE_CMD  HandleSrvrInitScavenge;
FN_HANDLE_CMD  HandleSrvrInitSearch;

FN_HANDLE_CMD  HandleSrvrResetCounter;


FN_HANDLE_CMD  HandleSrvrSetAutopartnerconfig;
FN_HANDLE_CMD  HandleSrvrSetBackuppath;
FN_HANDLE_CMD  HandleSrvrSetBurstparam;
FN_HANDLE_CMD  HandleSrvrSetDefaultparam;
FN_HANDLE_CMD  HandleSrvrSetLogparam;
FN_HANDLE_CMD  HandleSrvrSetMigrateflag;
FN_HANDLE_CMD  HandleSrvrSetNamerecord;
FN_HANDLE_CMD  HandleSrvrSetPeriodicdbchecking;
FN_HANDLE_CMD  HandleSrvrSetPullpersistentconnection;
FN_HANDLE_CMD  HandleSrvrSetPushpersistentconnection;
FN_HANDLE_CMD  HandleSrvrSetPullparam;
FN_HANDLE_CMD  HandleSrvrSetPushparam;
FN_HANDLE_CMD  HandleSrvrSetReplicateflag;
FN_HANDLE_CMD  HandleSrvrSetStartversion;
FN_HANDLE_CMD  HandleSrvrSetPersMode;


FN_HANDLE_CMD  HandleSrvrShowDatabase;
FN_HANDLE_CMD  HandleSrvrShowInfo;
FN_HANDLE_CMD  HandleSrvrShowPartner;
FN_HANDLE_CMD  HandleSrvrShowName;
FN_HANDLE_CMD  HandleSrvrShowServer;
FN_HANDLE_CMD  HandleSrvrShowStatistics;
FN_HANDLE_CMD  HandleSrvrShowVersion;
FN_HANDLE_CMD  HandleSrvrShowVersionmap;
FN_HANDLE_CMD  HandleSrvrShowPartnerproperties;
FN_HANDLE_CMD  HandleSrvrShowPullpartnerproperties;
FN_HANDLE_CMD  HandleSrvrShowPushpartnerproperties;
FN_HANDLE_CMD  HandleSrvrShowDomain;
FN_HANDLE_CMD  HandleSrvrShowReccount;
FN_HANDLE_CMD  HandleSrvrShowRecbyversion;

#endif //_WINSSRVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\netsh\winshndl.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/
#ifndef _WINSHNDL_H_
#define _WINSHNDL_H_

FN_HANDLE_CMD  HandleWinsHelp;
FN_HANDLE_CMD  HandleWinsContexts;
FN_HANDLE_CMD  HandleWinsDump;

FN_HANDLE_CMD  HandleWinsAddServer;

FN_HANDLE_CMD  HandleWinsDeleteServer;

FN_HANDLE_CMD  HandleWinsShowServer;

#endif //_WINSHNDL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\netsh\winshndl.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\wins\winshndl.c

Abstract:

    WINS Server Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 12/14/98

--*/

#include "precomp.h"

extern ULONG g_ulNumTopCmds;
extern ULONG g_ulNumSubContext;

extern WINSMON_SUBCONTEXT_TABLE_ENTRY  g_WinsSubContextTable[];
extern CMD_ENTRY                        g_WinsCmds[];

DWORD
HandleWinsDump(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD Status = NO_ERROR;

    if( dwArgCount > dwCurrentIndex )
    {
        if( IsHelpToken(ppwcArguments[dwCurrentIndex]) is TRUE )
        {
            DisplayMessage(g_hModule,
                           HLP_WINS_DUMP_EX);
        }
    }
    
    Status = WinsDump(NULL, ppwcArguments, dwArgCount, pvData);

    if( Status is NO_ERROR )
        DisplayMessage(g_hModule,
                       EMSG_WINS_ERROR_SUCCESS);
    else if( Status is ERROR_FILE_NOT_FOUND )
        DisplayMessage(g_hModule,
                       EMSG_WINS_NOT_CONFIGURED);
    else
        DisplayErrorMessage(EMSG_WINS_DUMP,
                            Status);

    return Status;

        
}


DWORD
HandleWinsHelp(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    i, j;

    for(i = 0; i < g_ulNumTopCmds -2; i++)
    {
        if ((g_WinsCmds[i].dwCmdHlpToken == WINS_MSG_NULL)
         || !g_WinsCmds[i].pwszCmdToken[0] )
        {
            continue;
        }

        DisplayMessage(g_hModule, 
                       g_WinsCmds[i].dwShortCmdHelpToken);
    }
    
    for(i=0; i < g_ulNumSubContext; i++)
    {
        DisplayMessage(g_hModule, g_WinsSubContextTable[i].dwShortCmdHlpToken);
        DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    }    
    
    DisplayMessage(g_hModule, WINS_FORMAT_LINE);

    return NO_ERROR;
}

DWORD
HandleWinsAddServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
	DWORD		dwError = NO_ERROR;
	DWORD		i, j, dwNumArg;
    PDWORD		pdwTagType = NULL;
	TAG_TYPE	pttTags[] = {{WINS_TOKEN_SERVER, TRUE, FALSE}};
	

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_WINS_ADD_SERVER_EX);
        return ERROR_INVALID_PARAMETER;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

	pdwTagType = WinsAllocateMemory(dwNumArg*sizeof(DWORD));

    if( pdwTagType is NULL )
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    //See if the first argument has tag. If so, then assume all arguments have tag.
    if( wcsstr(ppwcArguments[dwCurrentIndex], NETSH_ARG_DELIMITER) )
    {
        dwError = MatchTagsInCmdLine(g_hModule,
                            ppwcArguments,
                            dwCurrentIndex,
                            dwArgCount,
                            pttTags,
                            NUM_TAGS_IN_TABLE(pttTags),
                            pdwTagType);

        if (dwError isnot NO_ERROR)
        {
            dwError = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

    }
    else
    {
                //
        // No tags in arguments. So assume order of arguments
        // 

        for ( i = 0; i < dwNumArg; i++)
        {
            pdwTagType[i] = i;
        }
    }

CommonReturn:
    if( dwError is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    return dwError;
ErrorReturn:
    DisplayErrorMessage(EMSG_WINS_ADD_SERVER,
                        dwError);

    goto CommonReturn;
}


DWORD
HandleWinsDeleteServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return NO_ERROR;
}


DWORD
HandleWinsShowServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\netsh\srvrhndl.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\wins\srvrhndl.c

Abstract:

    WINS Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 12/10/98

--*/

#include "precomp.h"


extern ULONG g_ulSrvrNumTopCmds;
extern ULONG g_ulSrvrNumGroups;

extern CMD_GROUP_ENTRY                  g_SrvrCmdGroups[];
extern CMD_ENTRY                        g_SrvrCmds[];

DWORD  g_dwSearchCount = 0;
BOOL   g_fHeader = FALSE;

WCHAR          **LA_Table = NULL;
LARGE_INTEGER  **SO_Table = NULL;
u_char         **NBNames = NULL;
WINSERVERS      * WinServers = NULL;


LPWSTR
GetDateTimeString(DWORD_PTR TimeStamp,
                  BOOL      fShort,
                  int      *piType);

DWORD
HandleSrvrDump(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description :
        Dumps the current configuration of the Wins Server.

Arguments :
        Does not take any arguments.

Return Value:
        Returns the status of the operation.

--*/

{
    DWORD   Status = NO_ERROR;

    if( dwArgCount > dwCurrentIndex )
    {
        if( IsHelpToken(ppwcArguments[dwCurrentIndex]) is TRUE )
        {
            DisplayMessage(g_hModule,
                           HLP_WINS_DUMP_EX);
        }
    }

    Status = WinsDumpServer(g_ServerIpAddressUnicodeString,
                            g_ServerNetBiosName,
                            g_hBind,
                            g_BindData);
    if( Status is NO_ERROR )
	{
        DisplayMessage(g_hModule,
                       EMSG_WINS_ERROR_SUCCESS);
	}
    else if( Status is ERROR_FILE_NOT_FOUND )
	{
		DisplayMessage(g_hModule,
					   EMSG_WINS_NOT_CONFIGURED);
	}
	else
	{
        DisplayErrorMessage(EMSG_SRVR_DUMP,
                            Status);
	}
    return Status;

}


DWORD
HandleSrvrHelp(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the help for Wins Server context.

Arguments :
        Does not take any arguments.

Return Value:
        Returns the status of the operation. NO_ERROR always. 

--*/

{
    DWORD    i, j;

    for(i = 0; i < g_ulSrvrNumTopCmds -2; i++)
    {
        if ((g_SrvrCmds[i].dwCmdHlpToken == WINS_MSG_NULL)
         || !g_SrvrCmds[i].pwszCmdToken[0] )
        {
            continue;
        }

        DisplayMessage(g_hModule, 
                       g_SrvrCmds[i].dwShortCmdHelpToken);

    }

    for(i = 0; i < g_ulSrvrNumGroups; i++)
    {
        if ((g_SrvrCmdGroups[i].dwShortCmdHelpToken == WINS_MSG_NULL)
         || !g_SrvrCmdGroups[i].pwszCmdGroupToken[0] )
        {
            continue;
        }

        DisplayMessage(g_hModule, g_SrvrCmdGroups[i].dwShortCmdHelpToken);
    }
      
    DisplayMessage(g_hModule, WINS_FORMAT_LINE);

    return NO_ERROR;
}


DWORD
HandleSrvrAddName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Adds and registers a name record to the WINS server
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory, Record Name and Ip Address
        Optional,   Endchar, Scope, RecordType, NodeType, GroupType
        Note : GroupType is ignored if EndChar is specified.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount = 0;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_NAME, TRUE, FALSE},
                                {WINS_TOKEN_ENDCHAR, FALSE, FALSE},
                                {WINS_TOKEN_SCOPE, FALSE, FALSE},
                                {WINS_TOKEN_RECORDTYPE, FALSE, FALSE},
                                {WINS_TOKEN_GROUP, FALSE, FALSE},
                                {WINS_TOKEN_NODE, FALSE, FALSE},
                                {WINS_TOKEN_IP, TRUE, FALSE},
                            };
    PDWORD      pdwTagNum = NULL,
                pdwTagType = NULL;

    WCHAR       wszName[MAX_STRING_LEN+1] = {L'\0'};
    BOOL        fEndChar = FALSE;
    BOOL        fDomain = FALSE;
    CHAR        ch16thChar = 0x00;

    BOOL        fScope = FALSE;
    WCHAR       wszScope[MAX_STRING_LEN] = {L'\0'};
    BOOL        fStatic = TRUE;
    DWORD       dwRecType = WINSINTF_E_UNIQUE;
    
    BYTE        rgbNodeType = WINSINTF_E_PNODE;
    PDWORD      pdwIpAddress = NULL;
    DWORD       dwIpCount = 0;
    DWORD       dwStrLen = 0;
    LPWSTR      pwszTemp = NULL;
    WINSINTF_RECORD_ACTION_T    RecAction = {0};
    PWINSINTF_RECORD_ACTION_T   pRecAction = NULL;
    LPSTR       pszTempName = NULL;

    memset(&RecAction, 0x00, sizeof(WINSINTF_RECORD_ACTION_T));
    RecAction.fStatic = fStatic;

    //We need at least Name and Ip for the record.
    if( dwArgCount < dwCurrentIndex + 2 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_ADD_NAME_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //Start processing the arguments passed by ppwcArguments and dwArgCount

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;
    
    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    i = dwTagCount;
    for( j=0; j<i; j++ )
    {
        switch(pdwTagType[j])
        {
        //Name of the record ( Compulsory )
        case 0:
            {
               DWORD dwLen = 0;
                
               dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dwLen = ( 255 < dwLen ) ? 255 : dwLen;
                memcpy(wszName, 
                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 
                       dwLen*sizeof(WCHAR));
                wszName[dwLen] = L'\0';               
                break;
            }
        //End Char or 16th Character( Optional )
        case 1:
            {
                DWORD dwLen = 0, k=0;
                fEndChar = TRUE;
                dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen > 2 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                        
                }
                
                for( k=0; k<dwLen; k++ )
                {
                    WCHAR  wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][k];
                    
                    if( towlower(wc) >= L'a' and
                        towlower(wc) <= L'z' )
                    {
                        if( towlower(wc) > L'f' )
                        {
                            Status = ERROR_INVALID_PARAMETER;
                            goto ErrorReturn;
                        }
                    }
                }

                ch16thChar = StringToHexA(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);

                break;
            }
        //Scope ( Optional )
        case 2:
            {
                DWORD dwLen;
                
                dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                fScope = TRUE;
                if( dwLen is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dwLen = ( 255 < dwLen ) ? 255 : dwLen;
                memcpy(wszScope,
                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 
                       dwLen*sizeof(WCHAR));
                wszScope[dwLen] = L'\0';   
                break;
            }
        //Record Type ie Static or Dynamic ( Optional )
        case 3:
            {
              
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 1 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                else
                {
                    WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                    if( wc is L'1' )
                        fStatic = FALSE;
                    else if( wc is L'0' )
                        fStatic = TRUE;
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                }
                break;
            }
        // Group Type ( Optional )
        case 4:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                switch(dw)
                {
                case 0:
                    {
                        dwRecType = WINSINTF_E_UNIQUE;
                        break;
                    }
                case 1:
                    {
                        dwRecType = WINSINTF_E_NORM_GROUP;
                        break;
                    }
                case 2:
                    {
                        dwRecType = WINSINTF_E_SPEC_GROUP;
                        break;
                    }
                case 3:
                    {
                        dwRecType = WINSINTF_E_MULTIHOMED;
                        break;
                    }
                case 4:
                    {
                        fDomain = TRUE;
                        dwRecType = WINSINTF_E_SPEC_GROUP;
                        break;
                    }
                default:
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                }
                break;
            }
        //Node Type( Optional )
        case 5:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);

                switch(dw)
                {
                case 0:
                    {
                        rgbNodeType = WINSINTF_E_BNODE;
                        break;
                    }
                case 1:
                    {
                        rgbNodeType = WINSINTF_E_PNODE;
                        break;
                    }
                case 3:
                    {
                        rgbNodeType = WINSINTF_E_HNODE;
                        break;
                    }
                default:
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                }
                break;
            }
        //IP Address corresponding to the record( Compulsory )
        case 6:
            {
                LPWSTR  pszIps = NULL;
                DWORD   dwIpLen = 0;
                LPWSTR  pTemp = NULL;
                
                dwIpCount = 0;

               
                dwIpLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwIpLen is 0 )
                {
                    break;
                }
                pszIps = WinsAllocateMemory((dwIpLen+1)*sizeof(WCHAR));
                if( pszIps is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }

                wcscpy(pszIps, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( pszIps[0] isnot L'{' or 
                    pszIps[dwIpLen-1] isnot L'}')
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                
                pTemp = pszIps+1;                               
                pszIps[dwIpLen-1] = L'\0';

                pTemp = wcstok(pTemp, L",");
                
                while(( pTemp isnot NULL ) && (dwIpCount < WINSINTF_MAX_MEM ) )
                {
                    PDWORD  pdwTemp = NULL;
                    if( IsIpAddress(pTemp) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }

                    dwIpCount++;

                    pdwTemp = WinsAllocateMemory(dwIpCount*sizeof(DWORD));
                    if( pdwTemp is NULL )
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }
                    if( pdwIpAddress )
                    {
                        memcpy(pdwTemp, pdwIpAddress, (dwIpCount-1)*sizeof(DWORD));
                        WinsFreeMemory(pdwIpAddress);
                        pdwIpAddress = NULL;
                    }
                    
                    pdwTemp[dwIpCount-1] = StringToIpAddress(pTemp);
                    pdwIpAddress = pdwTemp;
                    pTemp = wcstok(NULL, L",");
                }
                WinsFreeMemory(pszIps);
                pszIps = NULL;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
    
    //Process Name, Scope and Endchar if specified.

    _wcsupr(wszName);
    _wcsupr(wszScope);

    RecAction.pName = WinsAllocateMemory(273);
    if( RecAction.pName is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }
    
    pszTempName = WinsUnicodeToOem(wszName, NULL);

    if( pszTempName is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwStrLen = strlen(pszTempName);

    if( dwStrLen >= 16 )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_NETBIOS_NAME);
        Status = ERROR_INVALID_PARAMETER;
        WinsFreeMemory(pszTempName);
        pszTempName = NULL;
        goto ErrorReturn;
    }

    strncpy(RecAction.pName, pszTempName, ( 16 > dwStrLen ) ? dwStrLen : 16);

    WinsFreeMemory(pszTempName);
    pszTempName = NULL;


    if( fDomain is TRUE &&
        fEndChar is FALSE )
    {
        ch16thChar = StringToHexA(L"1C");
        fEndChar = TRUE;
    }

 
    for( j=dwStrLen; j<16; j++ )
    {
        RecAction.pName[j] = ' ';
    }
    if( fEndChar is TRUE )
    {
        RecAction.pName[15] = (CHAR)ch16thChar;
    }
    RecAction.pName[16] = '\0';

    dwStrLen = 16;

    if( fScope )
    {
        DWORD dwLen;
    
        RecAction.pName[dwStrLen] = '.';

        pszTempName = WinsUnicodeToOem(wszScope, NULL);
        if( pszTempName is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        dwLen = strlen(pszTempName);
        dwLen = ( 255 - dwStrLen < dwLen ) ? 255 - dwStrLen : dwLen;

        strncpy(RecAction.pName+dwStrLen+1, pszTempName, dwLen); 
        
        WinsFreeMemory(pszTempName);
        pszTempName = NULL;

        RecAction.pName[dwStrLen+dwLen+1] = '\0';
    
        dwStrLen = strlen(RecAction.pName);

        if( fEndChar and 
            ch16thChar is 0x00 )
            dwStrLen++;      
    }


    RecAction.NameLen = dwStrLen;
    RecAction.Cmd_e      = WINSINTF_E_INSERT;
    RecAction.fStatic = fStatic;
    

    if( pdwIpAddress is NULL )
    {
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
  
    if( dwRecType isnot WINSINTF_E_NORM_GROUP and
        dwRecType isnot WINSINTF_E_SPEC_GROUP)
    {
        RecAction.NodeTyp = rgbNodeType;
    }


    //Treat each of the rectype when no endchar is specified specially.
    //This part of the code needs to be cleaned up after Beta3
    if( fEndChar is FALSE )
    {
        if( dwRecType is WINSINTF_E_SPEC_GROUP or
            dwRecType is WINSINTF_E_MULTIHOMED )
        {
            RecAction.pAdd = WinsAllocateMemory(dwIpCount*sizeof(WINSINTF_ADD_T));
            if( RecAction.pAdd is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            for( j=0; j<dwIpCount; j++ )
            {
                (RecAction.pAdd+j)->IPAdd = pdwIpAddress[j];
                (RecAction.pAdd+j)->Type = 0;
                (RecAction.pAdd+j)->Len = 4;
            }
            RecAction.NoOfAdds = dwIpCount;
        }
        else
        {
            RecAction.Add.IPAdd = pdwIpAddress[0];
            RecAction.Add.Type = 0;
            RecAction.Add.Len = 4;
        }

        switch(dwRecType)
        {
        case WINSINTF_E_UNIQUE:
            {
                CHAR Type[]={0x03, 0x20, 0x00};

                for( i=0; i<3; i++ )
                {
                    *(RecAction.pName + 15) = Type[i];
                    if( Type[i] is 0x00 )
                    {
                        RecAction.pName[16] = '\0';
                        RecAction.NameLen = 16;
                    }
                    RecAction.TypOfRec_e = dwRecType;
                    pRecAction = &RecAction;
        
                    Status = WinsRecordAction(g_hBind, &pRecAction);
                    if( Status isnot NO_ERROR )
                        goto ErrorReturn;
                }
                break;
            }
        case WINSINTF_E_NORM_GROUP:
            {             
                RecAction.pName[15] = (CHAR)0x1E;
                pRecAction = &RecAction;
                RecAction.TypOfRec_e = dwRecType;
                Status = WinsRecordAction(g_hBind, &pRecAction);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;

                break;
            }

        case WINSINTF_E_SPEC_GROUP:
            {           
                RecAction.pName[15] = (CHAR)0x20;
                pRecAction = &RecAction;
                RecAction.TypOfRec_e = dwRecType;
                Status = WinsRecordAction(g_hBind, &pRecAction);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;
            }

        case WINSINTF_E_MULTIHOMED:
            {
                CHAR Type[]={0x03, 0x20, 0x00};
                for( i=0; i<3; i++ )
                {
                    *(RecAction.pName + 15) = Type[i];
                    if( Type[i] is 0x00 )
                    {
                        *(RecAction.pName+16) = '\0';
                        RecAction.NameLen = 16;
                    }

                    RecAction.TypOfRec_e = dwRecType;
                    pRecAction = &RecAction;
                    RecAction.NodeTyp = WINSINTF_E_PNODE;
                    Status = WinsRecordAction(g_hBind, &pRecAction);
                    if( Status isnot NO_ERROR )
                        goto ErrorReturn;
                }
                break;
            }
        }
    }

    //Otherwise when Endchar is specified
    else
    {        
        //if endchar is 0x00, ignore the scope if spcefied
        if( RecAction.pName[15] is 0x00 )
        {
            RecAction.NameLen = 16;
        }
        //If endchar is 0x1C
        if( RecAction.pName[15] is 0x1C )
        {
            RecAction.TypOfRec_e = WINSINTF_E_SPEC_GROUP;
            RecAction.NodeTyp = 0;
        }
        //else if EndChar is 0x1E or 0x1D
        else if( RecAction.pName[15] is 0x1E or
                 RecAction.pName[15] is 0x1D )
        {
            RecAction.TypOfRec_e = WINSINTF_E_NORM_GROUP;
            RecAction.NodeTyp = 0;
        }        

        if( RecAction.TypOfRec_e is WINSINTF_E_SPEC_GROUP )
            
        {
            RecAction.pAdd = WinsAllocateMemory(dwIpCount*sizeof(WINSINTF_ADD_T));
            if( RecAction.pAdd is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            for( j=0; j<dwIpCount; j++ )
            {
                (RecAction.pAdd+j)->IPAdd = pdwIpAddress[j];
                (RecAction.pAdd+j)->Type = 0;
                (RecAction.pAdd+j)->Len = 4;
            }
            RecAction.NoOfAdds = dwIpCount;
        }
        else
        {
            RecAction.Add.IPAdd = pdwIpAddress[0];
            RecAction.Add.Type = 0;
            RecAction.Add.Len = 4;
        }
    
        pRecAction = &RecAction;

        Status = WinsRecordAction(g_hBind, &pRecAction );

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
    }

CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( pszTempName )
    {
        WinsFreeMemory(pszTempName);
        pszTempName = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( RecAction.pName )
    {
        WinsFreeMemory(RecAction.pName);
        RecAction.pName = NULL;
    }
    
    if( RecAction.pAdd )
    {
        WinsFreeMemory(RecAction.pAdd);
        RecAction.pAdd = NULL;
    }

    if( pdwIpAddress )
    {
        WinsFreeMemory(pdwIpAddress);
        pdwIpAddress = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_ADD_NAME, Status);
    goto CommonReturn;

}


DWORD
HandleSrvrAddPartner(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Adds a partner ( either Push or Pull or Both ) to the WINS server
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory, ServerIpAddress
        Optional,   ServerNetBios name and PartnerType.
        Note : Server NetBios name is required when Ip address can not be resolved
               to a name. 
               PartherType by default is both. Otherwise whatever specified.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_SERVER, TRUE, FALSE},
                                {WINS_TOKEN_NETBIOS, FALSE, FALSE},
                                {WINS_TOKEN_TYPE, FALSE, FALSE},
                            };
    LPWSTR      pwszServerName = NULL;
    WCHAR       wcServerIpAdd[MAX_IP_STRING_LEN+1] = {L'\0'};
    PDWORD      pdwTagType=NULL, pdwTagNum=NULL;
    BOOL        fPush = TRUE,
                fPull = TRUE;
 
    HKEY        hServer = NULL,
                hPartner = NULL,
                hDefault = NULL,
                hKey = NULL;

    LPWSTR      pTemp = NULL;
    DWORD       dwKeyLen = 0;
    DWORD       dwData = 0, 
                dwDataLen = 0,
                dwType = 0;

    BOOL        fIsNetBios = TRUE;

    //Need at least the server Ip Address
    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_ADD_PARTNER_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    //Start processing the arguments based on ppwcArguments and dwArgCount and dwCurrnetIndex
    dwNumArgs = dwArgCount - dwCurrentIndex;
    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++)
    {
        switch(pdwTagType[j])
        {
        //Server IP Address. Try to resolve the IP to a name
        case 0:
            {
                struct  hostent * lpHostEnt = NULL;
                CHAR    cAddr[16];
                BYTE    pbAdd[4];
                char    szAdd[4];
                int     k = 0, l=0;
                DWORD   dwLen,nLen = 0;
                CHAR    *pTemp = NULL;
                CHAR    *pNetBios = NULL;
                
                if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) is FALSE )
                {
                    Status = ERROR_INVALID_IPADDRESS;
                    goto ErrorReturn;
                }

                //if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) )
                else
                {
                    DWORD dwIp = inet_addr(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL));
                    lpHostEnt = gethostbyaddr((char *)&dwIp, 4, AF_INET);
                    if(lpHostEnt isnot NULL )//Valid IP Address
                    {
                        wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    }
                    else
                    {
                        wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                        fIsNetBios = FALSE;                                       
                        break;
                    }
                }

                dwLen = strlen(lpHostEnt->h_name);
                pTemp = WinsAllocateMemory(dwLen+1);
                if( pTemp is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }

                strcpy(pTemp, lpHostEnt->h_name);
                pNetBios = strchr(pTemp, '.');

                if( pNetBios isnot NULL )
                {
                    dwLen = (DWORD)(pNetBios - pTemp);
                    pTemp[dwLen] = '\0';
                }
                

                pwszServerName = WinsAllocateMemory((dwLen+1)*sizeof(WCHAR));
                if( pwszServerName is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
 
                wcscpy(pwszServerName, WinsAnsiToUnicode(pTemp, NULL));

                if( pTemp )
                {
                    WinsFreeMemory(pTemp);
                    pTemp = NULL;
                }
                break;
            }
        //Server NetBios Name. Required only when Ip can not be resolved to a name.
        //Otherwise ignored.
        case 1:
            {
                if( fIsNetBios is FALSE )
                {
                    pwszServerName = WinsAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]])+1)*sizeof(WCHAR));
                    if( pwszServerName is NULL )
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }

                    wcscpy(pwszServerName, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    fIsNetBios = TRUE;
                    
                }
                break;
            }
        //Partner Type. Default is BOTH
        case 2:
            {
                DWORD dwType = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dwType = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                switch(dwType)
                {
                case 0:
                    {
                        fPull = TRUE;
                        fPush = FALSE;
                        break;
                    }
                case 1:
                    {
                        fPull = FALSE;
                        fPush = TRUE;
                        break;
                    }
                case 2:
                default:
                    {
                        fPull = TRUE;
                        fPush = TRUE;
                        break;
                    }
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }

        }
    }

    if( fIsNetBios is FALSE )
    {
        Status = ERROR_INVALID_IPADDRESS;
        goto ErrorReturn;
    }
    //Add the partner information to the registry and set the appropriate parameter
    {
        
        if( wcslen(g_ServerNetBiosName) > 0 )
        {
            pTemp = g_ServerNetBiosName;
        }
        
        Status = RegConnectRegistry(pTemp,
                                    HKEY_LOCAL_MACHINE,
                                    &hServer);

        if( Status isnot ERROR_SUCCESS )
            goto ErrorReturn;

        //Add the pull partner information
        if( fPull )
        {
            DWORD dwDisposition = 0;
            Status = RegCreateKeyEx(hServer,
                                    PULLROOT,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hPartner,
                                    &dwDisposition);
            if( Status isnot NO_ERROR )
            {
                if( fPush )
                    goto PUSH;
                goto ErrorReturn;
            }

            Status = RegCreateKeyEx(hPartner,
                                    wcServerIpAdd,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hKey,
                                    NULL);
            if( Status isnot NO_ERROR )
            {
                if( fPush )
                    goto PUSH;
                goto ErrorReturn;
            }
            
            Status = RegSetValueEx(hKey,
                                   NETBIOSNAME,
                                   0,
                                   REG_SZ,
                                   (LPBYTE)pwszServerName,
                                   (wcslen(pwszServerName)+1)*sizeof(WCHAR));
            if(Status isnot NO_ERROR )
            {
                if( fPush )
                    goto PUSH;
                goto ErrorReturn;
            }
            
            dwType = REG_DWORD;
            dwData = 0;
            dwDataLen = sizeof(DWORD);


            Status = RegQueryValueEx(
                                     hPartner,
                                     PERSISTENCE,
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwDataLen);
            if( Status isnot NO_ERROR )
            {
                dwData = 0;
                dwDataLen = sizeof(DWORD);
            }
            
            Status = RegSetValueEx(hKey,
                                   PERSISTENCE,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwData,
                                   dwDataLen);
            
            if( Status isnot NO_ERROR )
            {
                if( fPush )
                    goto PUSH;
                goto ErrorReturn;
            }

            dwType = REG_DWORD;
            dwData = 0;
            dwDataLen = sizeof(DWORD);

            Status = RegQueryValueEx(hPartner,
                                     WINSCNF_SELF_FND_NM,
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwDataLen);

            if( Status isnot NO_ERROR )
            {
                dwData = 0;
                dwDataLen = sizeof(DWORD);
            }

            Status = RegSetValueEx(hKey,
                                   WINSCNF_SELF_FND_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwData,
                                   dwDataLen);

            if( Status isnot NO_ERROR )
            {
                if( fPush )
                    goto PUSH;
                goto ErrorReturn;
            }

            Status = RegOpenKeyEx(hServer,
                                  DEFAULTPULL,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hDefault);
            if( Status is NO_ERROR )
            {
                dwType = REG_DWORD;
                dwData = 0;
                dwDataLen = sizeof(DWORD);
                Status = RegQueryValueEx(hDefault,
                                         WINSCNF_RPL_INTERVAL_NM,
                                         0,
                                         &dwType,
                                         (LPBYTE)&dwData,
                                         &dwDataLen);
                if(Status isnot NO_ERROR )
                {
                    dwData = 1800;
                    dwDataLen = sizeof(DWORD);
                }
            }
            else
            {
                dwData = 1800;
                dwDataLen = sizeof(DWORD);
            }
         
            Status = RegSetValueEx(hKey,
                                   WINSCNF_RPL_INTERVAL_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwData,
                                   dwDataLen);

            if( Status isnot NO_ERROR )
            {
                if( fPush )
                    goto PUSH;
                goto ErrorReturn;
            }
        }

        //Add the push partner information
PUSH:   if( hKey )
        {
            RegCloseKey(hKey);
            hKey = NULL;
        }
        
        if( hDefault )
        {
            RegCloseKey(hDefault);
            hDefault = NULL;
        }

        if( hPartner )
        {
            RegCloseKey(hPartner);
            hPartner = NULL;
        }
    
        if( fPush )
        {
            DWORD dwDisposition = 0;
            Status = RegCreateKeyEx(hServer,
                                    PUSHROOT,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hPartner,
                                    &dwDisposition);
            if( Status isnot NO_ERROR )
            {
                goto ErrorReturn;
            }
            Status = RegCreateKeyEx(hPartner,
                                    wcServerIpAdd,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hKey,
                                    NULL);
            if( Status isnot NO_ERROR )
            {
                goto ErrorReturn;
            }
            
            Status = RegSetValueEx(hKey,
                                   NETBIOSNAME,
                                   0,
                                   REG_SZ,
                                   (LPBYTE)pwszServerName,
                                   (wcslen(pwszServerName)+1)*sizeof(WCHAR));
            if(Status isnot NO_ERROR )
            {
                goto ErrorReturn;
            }

            dwType = REG_DWORD;
            dwData = 0;
            dwDataLen = sizeof(DWORD);            
            
            Status = RegQueryValueEx(
                                     hPartner,
                                     PERSISTENCE,
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwDataLen);
            if( Status isnot NO_ERROR )
            {
                dwData = 0;
                dwDataLen = sizeof(DWORD);
            }

            Status = RegSetValueEx(hKey,
                                   PERSISTENCE,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwData,
                                   dwDataLen);
            
            if( Status isnot NO_ERROR )
            {
                goto ErrorReturn;
            }

            dwType = REG_DWORD;
            dwData = 0;
            dwDataLen = sizeof(DWORD);

            Status = RegQueryValueEx(hPartner,
                                     WINSCNF_SELF_FND_NM,
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwDataLen);

            if( Status isnot NO_ERROR )
            {
                dwData = 0;
                dwDataLen = sizeof(DWORD);
            }

            Status = RegSetValueEx(hKey,
                                   WINSCNF_SELF_FND_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwData,
                                   dwDataLen);

            if( Status isnot NO_ERROR )
                goto ErrorReturn;

            Status = RegOpenKeyEx(hServer,
                                  DEFAULTPUSH,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hDefault);
            if( Status is NO_ERROR )
            {
                dwType = REG_DWORD;
                dwData = 0;
                dwDataLen = sizeof(DWORD);
            
                Status = RegQueryValueEx(hDefault,
                                         WINSCNF_UPDATE_COUNT_NM,
                                         0,
                                         &dwType,
                                         (LPBYTE)&dwData,
                                         &dwDataLen);
                if(Status isnot NO_ERROR )
                {
                    dwData = 0;
                    dwDataLen = sizeof(DWORD);
                }
            }
            else
            {
                dwData = 0;
                dwDataLen = sizeof(DWORD);
            }
         
            Status = RegSetValueEx(hKey,
                                   WINSCNF_UPDATE_COUNT_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwData,
                                   dwDataLen);

            if( Status isnot NO_ERROR )
            {
                goto ErrorReturn;
            }

            if( hKey )
            {
                RegCloseKey(hKey);
                hKey = NULL;
            }
            
            if( hDefault )
            {
                RegCloseKey(hDefault);
                hDefault = NULL;
            }

            if( hPartner )
            {
                RegCloseKey(hPartner);
                hPartner = NULL;
            }

        }
    }
     
CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    if( pwszServerName )
    {
        WinsFreeMemory(pwszServerName);
        pwszServerName = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }
    if( hDefault )
    {
        RegCloseKey(hDefault);
        hDefault = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_ADD_PARTNER, Status);

    if( hKey )
    {
        RegCloseKey(hKey);
        hKey = NULL;
    }

    if( hPartner )
    {
        RegDeleteKey(hPartner, g_ServerIpAddressUnicodeString);
        RegCloseKey(hPartner);
        hPartner = NULL;
    }


    goto CommonReturn;

}

BOOL CheckValidPgOp(HKEY hPartner, BOOL fGrata)
/*++

Routine Description :
        Check whether Persona Mode allows operation for persona grata (fGrata) or non-grata (!fGrata)
Arguments :
        hPartner = opened handle to the 'Partners' registry key
        fGrata specifies whether the check is done for a persona Grata (TRUE) operation or of
        a persona Non-Grata (FALSE) operation
Return Value:
        Returns TRUE if the operation is allowed, FALSE otherwise.

--*/
{
    DWORD dwPersMode = 0;   // default (entry not existant) = Persona Non-Grata
    DWORD dwType;
    DWORD dwSize = sizeof(DWORD);

    // don't chare about the return code. If something goes wrong (entry not existant)
    // consider Persona Mode as being 'Persona Non-Grata'.
    RegQueryValueExA(hPartner,
                    WINSCNF_PERSONA_MODE_NM,
                    NULL,
                    &dwType,
                    (LPVOID)&dwPersMode,
                    &dwSize);

    return dwPersMode ? fGrata : !fGrata;
}

DWORD
HandleSrvrAddPersona(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Add Persona Non Grata servers for the WINS Server
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory, List of Server Ip addresses seperated by commas and enclosed
        by {} ( curly braces )
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                               {WINS_TOKEN_SERVERS, TRUE, FALSE},
                            };
    DWORD       dwTagType = 0,
                dwTagNum = 0;
    DWORD       dwSize = 0,
                dwType = REG_MULTI_SZ,
                dwPngIp = 0,
                dwTotal = 0;
                
    LPWSTR      pwszPngIp = NULL;
    LPWSTR      pTemp = NULL;
    LPWSTR      pwszTempKey = NULL;
    LPBYTE      pbByte = NULL;
    HKEY        hServer = NULL,
                hPartner = NULL;
    LPDWORD     pdwPngIp = NULL;
    DWORD       dwLenCount = 0,
                dwTemp = 0;
    BOOL        fGrata;

    fGrata = (wcsstr(CMD_SRVR_ADD_PNGSERVER, ppwcArguments[dwCurrentIndex-1]) == NULL);

    //Needs a parameter always
    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, fGrata ? HLP_SRVR_ADD_PGSERVER_EX : HLP_SRVR_ADD_PNGSERVER_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;


    if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp,
                                HKEY_LOCAL_MACHINE,
                                &hServer);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegOpenKeyEx(hServer,
                          PARTNERROOT,
                          0,
                          KEY_ALL_ACCESS,
                          &hPartner);
    
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    if (!CheckValidPgOp(hPartner, fGrata))
    {
        DisplayMessage(g_hModule, fGrata ? EMSG_SRVR_PG_INVALIDOP : EMSG_SRVR_PNG_INVALIDOP);
        Status = ERROR_INVALID_PARAMETER;
        goto CommonReturn;
    }

    if (fGrata)
        pwszTempKey = WinsOemToUnicode(WINSCNF_PERSONA_GRATA_NM, NULL);
    else
        pwszTempKey = WinsOemToUnicode(WINSCNF_PERSONA_NON_GRATA_NM, NULL);

    if( pwszTempKey is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    Status = RegQueryValueEx(hPartner,
                             pwszTempKey,
                             NULL,
                             &dwType,
                             pbByte,
                             &dwSize);

    
    WinsFreeMemory(pwszTempKey);
    pwszTempKey = NULL;

    if( Status isnot NO_ERROR and
        Status isnot 2 )
        goto ErrorReturn;

    if( dwSize > 7 )
    {
        LPWSTR  pwszPng = NULL;
        pbByte = WinsAllocateMemory(dwSize+2);

        dwSize+=2;

        if( pbByte is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        
        Status = RegQueryValueEx(hPartner,
                                 fGrata ? PGSERVER : PNGSERVER,
                                 NULL,
                                 &dwType,
                                 pbByte,
                                 &dwSize);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        pwszPng = (LPWSTR)pbByte;

        pwszPngIp = WinsAllocateMemory(dwSize);

        if( pwszPngIp is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        memcpy(pwszPngIp, pbByte, dwSize);

        for( i=0; i<(dwSize+2)/sizeof(WCHAR); i++ )
        {
            if( pwszPng[i] is L'\0' and
                pwszPng[i+1] isnot L'\0')
            {
                pwszPng[i] = L',';
                i++;
            }
        }

        dwPngIp = 0;
        
        pTemp = wcstok(pwszPng, L",");
        
        while(pTemp isnot NULL )
        {
            LPDWORD     pdwTemp = pdwPngIp;
            
            dwPngIp++;
            
            dwLenCount += wcslen(pTemp);
            pdwPngIp = WinsAllocateMemory(dwPngIp*sizeof(DWORD));

            if( pdwPngIp is NULL )
            {
                WinsFreeMemory(pdwTemp);
                pdwTemp = NULL;
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            if( pdwTemp isnot NULL )
            {
                memcpy(pdwPngIp, pdwTemp, (dwPngIp-1)*sizeof(DWORD));
                WinsFreeMemory(pdwTemp);
                pdwTemp = NULL;
            }
            
            pdwPngIp[dwPngIp-1] = StringToIpAddress(pTemp);

            pTemp = wcstok(NULL, L","); 
            dwLenCount++;

        }
    }


    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               &dwTagType,
                               &dwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(dwTagType)
        {
        //Server Ip Address List
        case 0:
            {
                DWORD   dwIpLen = 0;
                LPWSTR  pwszIps = NULL;
                dwIpLen = wcslen(ppwcArguments[dwCurrentIndex+dwTagNum]);

                if( ppwcArguments[dwCurrentIndex+dwTagNum][0] isnot L'{' or 
                    ppwcArguments[dwCurrentIndex+dwTagNum][dwIpLen-1] isnot L'}')
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                
                ppwcArguments[dwCurrentIndex+dwTagNum][dwIpLen-1] =L'\0';

                dwIpLen--;

                pwszIps = WinsAllocateMemory((dwIpLen)*sizeof(WCHAR));

                if( pwszIps is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                
                memcpy(pwszIps, ppwcArguments[dwCurrentIndex+dwTagNum]+1, (dwIpLen-1)*sizeof(WCHAR));
               
                i=0;
                pTemp = wcstok(pwszIps, L",");
                while(pTemp isnot NULL)
                {       
                    BOOL  fPresent = FALSE;
                    DWORD dw = 0;

                    if( IsIpAddress(pTemp) is FALSE )
                    {
                        DisplayMessage(g_hModule,
                                       EMSG_SRVR_IP_DISCARD,
                                       pTemp);
                        pTemp = wcstok(NULL, L",");
                        continue;
                    }
                    else
                    {
                        dw = StringToIpAddress(pTemp);

                        for( j=0; j<dwPngIp; j++ )
                        {           
                            if( dw is INADDR_NONE )
                            {
                                continue;
                            }
                            if( pdwPngIp[j] is dw )
                            {
                                fPresent = TRUE;
                                break;
                            }
                            else
                            {
                                continue;
                            }
                        }
                        if( fPresent is FALSE )
                        {
                            LPDWORD pdwTemp = pdwPngIp;

                            pdwPngIp = WinsAllocateMemory((dwPngIp+1)*sizeof(DWORD));
                        
                            if( pdwTemp )
                            {
                                memcpy(pdwPngIp, pdwTemp, dwPngIp*sizeof(DWORD));
                                WinsFreeMemory(pdwTemp);
                                pdwTemp = NULL;
                            }

                            pdwPngIp[dwPngIp] = dw;
                            dwPngIp++;
                            dwTotal++;
                        }
                        else
                        {
                            DisplayMessage(g_hModule,
                                           EMSG_SRVR_DUPLICATE_DISCARD,
                                           pTemp);
                        }
                    }
                    pTemp = wcstok(NULL, L",");
                }

                
                if( pwszIps )
                {
                    WinsFreeMemory(pwszIps);
                    pwszIps = NULL;
                }
                break;            
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
    
    if( pwszPngIp )
    {
        WinsFreeMemory(pwszPngIp);
        pwszPngIp = NULL;
    }

    pwszPngIp = WinsAllocateMemory((dwPngIp*(MAX_IP_STRING_LEN+1)+2)*sizeof(WCHAR));

    if( pwszPngIp is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }
    
    dwTemp = 0;

    for( i=0; i<dwPngIp; i++ )
    {
        LPWSTR pwIp = IpAddressToString(pdwPngIp[i]);
        
        if( pwIp is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwszPngIp+dwTemp, pwIp);
        dwTemp+= wcslen(pwIp);

        dwTemp++;
        WinsFreeMemory(pwIp);
        pwIp = NULL;
    }
 
    pwszPngIp[dwTemp] = L'\0';
    pwszPngIp[dwTemp+1] = L'\0';

    Status = RegSetValueEx(hPartner,
    fGrata? PGSERVER : PNGSERVER,
                           0,
                           REG_MULTI_SZ,
                           (LPBYTE)pwszPngIp,
                           (dwTemp+1)*sizeof(WCHAR));


    if( Status isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Status is NO_ERROR )
    {
        if( dwTotal is 0 )
        {
            DisplayMessage(g_hModule,
                            fGrata ? EMSG_SRVR_NO_IP_ADDED_PG : EMSG_SRVR_NO_IP_ADDED_PNG);
        }
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }
    
    if( hPartner )
    {
        RegCloseKey(hPartner);
        hPartner = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pwszPngIp )
    {
        WinsFreeMemory(pwszPngIp);
        pwszPngIp = NULL;
    }

    if( pdwPngIp )
    {
        WinsFreeMemory(pdwPngIp);
        pdwPngIp = NULL;
    }

    if( pbByte )
    {
        WinsFreeMemory(pbByte);
        pbByte = NULL;
    }


    return Status;
ErrorReturn:
    DisplayErrorMessage(fGrata ? EMSG_SRVR_ADD_PGSERVER : EMSG_SRVR_ADD_PNGSERVER, Status);
    goto CommonReturn;                    

}


DWORD
HandleSrvrCheckDatabase(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Checks the consistency of the database
Arguments :
        No arguments
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_ALL, FALSE, FALSE},
                                {WINS_TOKEN_FORCE, FALSE, FALSE},
                            };

    BOOL        fAll = FALSE, fForce = FALSE;
    LPDWORD     pdwTagType = NULL, pdwTagNum = NULL;

  	WINSINTF_SCV_REQ_T ScvReq;

    if( dwArgCount > dwCurrentIndex )
    {
        //Start processing the arguments
        dwNumArgs = dwArgCount - dwCurrentIndex;

        pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
        pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

        if( pdwTagType is NULL or
            pdwTagNum is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

        Status = PreProcessCommand(ppwcArguments,
                                   dwArgCount,
                                   dwCurrentIndex,
                                   pttTags,
                                   &dwTagCount,
                                   pdwTagType,
                                   pdwTagNum);
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        for( j=0; j<dwTagCount; j++ )
        {
            switch(pdwTagType[j])
            {
            //Consistency check all or those older than verify interval
            case 0:
                {
                    DWORD dw = 0;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }                    

                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                    if( dw == 1 )
                    {
                        fAll = TRUE;
                    }
                    else if( dw == 0 )
                    {
                        fAll = FALSE;
                    }
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    break;
                }
            //Override wins checking in overloaded condition
            case 1 :
                {
                    DWORD dw = 0;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }                    

                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                    if( dw == 1 )
                    {
                        fForce = TRUE;
                    }
                    else if( dw == 0 )
                    {
                        fForce = FALSE;
                    }
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    break;
                }
            default:
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
            }
        }
    }
    if( fAll )
        ScvReq.Age = 0;				// check all the replicas
    else
        ScvReq.Age = 1;

    if( fForce )
        ScvReq.fForce = TRUE;
    else
	    ScvReq.fForce = FALSE;

	ScvReq.Opcode_e = WINSINTF_E_SCV_VERIFY;

	Status = WinsDoScavengingNew(g_hBind, &ScvReq);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;
    
    DisplayMessage(g_hModule, MSG_WINS_COMMAND_QUEUED);

CommonReturn:
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_CHECK_DATABASE, 
                        Status);
    goto CommonReturn;
}


DWORD
HandleSrvrCheckName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Checks a list of names against a list of WINS servers
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory, either a list of names or a file which contains the list of names.
        Names should be in the format (name)*(16th char) and either a list of server
        IP addresses, separated by commas and enclosed by {} or a file that contains
        the list of ip address in comma seperated format.
        Optional, to include all partners in the server list.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_NAMELIST, FALSE, FALSE},
                                {WINS_TOKEN_NAMEFILE, FALSE, FALSE},
                                {WINS_TOKEN_SERVERLIST, FALSE, FALSE},
                                {WINS_TOKEN_SERVERFILE, FALSE, FALSE},
                                {WINS_TOKEN_INCLPARTNER, FALSE, FALSE},
                            };
    BOOL        fNameFile = FALSE,
                fServerFile = FALSE;
    LPWSTR      pwszNameFile = NULL,
                pwszServerFile = NULL;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;
    PDWORD      pdwIpAddress = NULL;
    LPWSTR      *ppNames = NULL;
    BOOL        fInclPartner = FALSE,
                fIpEmpty = TRUE;

    //Need at least a list of names either directly or thro' file and
    //a list of server Ip either direcly or thro' file.
    if( dwArgCount < dwCurrentIndex + 2 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_CHECK_NAME_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //Start processing the arguments
    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    if( ( pttTags[0].bPresent is TRUE and
          pttTags[1].bPresent is TRUE ) or
        ( pttTags[2].bPresent is TRUE  and
          pttTags[3].bPresent is TRUE ) )
    {
        Status = ERROR_INVALID_PARAMETER_SPECIFICATION;
        goto ErrorReturn;
    }
    
    WinServers = WinsAllocateMemory(MAX_SERVERS*sizeof(*WinServers));

    if( WinServers is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    NBNames = (u_char ** )WinsAllocateMemory(MAX_NB_NAMES*sizeof(u_char*));

    if( NBNames is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0://NameList
            {
                LPWSTR  pwszToken = L",\r\n\t ";
                LPWSTR  pwszName = NULL;
                LPWSTR  pwszTemp = NULL;
                int     ilen = 0;
                LPWSTR  pTemp = NULL;
                BOOL    fPresent = FALSE;
                DWORD   dw = 0,
                        dwType = 0;
                DWORD   dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                

                if( dwLen < 2 )
                {
                    NumNBNames = 0;
                    break;
                }
                if( ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0] isnot L'{' or
                    ppwcArguments[dwCurrentIndex+pdwTagNum[j]][dwLen-1] isnot L'}' )
                {
                    NumNBNames = 0;
                    break;
                }

                pwszTemp = WinsAllocateMemory((dwLen)*sizeof(WCHAR));

                if(pwszTemp is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                
                for( ilen=0; ilen<NumNBNames; ilen++ )
                {
                    if( NBNames[ilen] isnot NULL )
                    {
                        WinsFreeMemory(NBNames[ilen]);
                        NBNames[ilen] = NULL;
                    }
                }
                NumNBNames = 0;

                wcscpy(pwszTemp, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+1);
                pwszTemp[dwLen-2] = L'\0';
                
                pwszName = wcstok(pwszTemp, pwszToken);
                
                while(pwszName isnot NULL )
                {                    
                    dw = wcslen(pwszName);
                    
                    if( dw < 1 or
                        dw > 18 )
                    {
                        DisplayMessage(g_hModule, EMSG_WINS_INVALID_NAME, pwszName);

                    }
                    else
                    {
                        pTemp = wcsstr(pwszName, L"*");
                        if( pTemp is NULL )
                        {
                            DisplayMessage(g_hModule, EMSG_WINS_INVALID_NAME, pwszName);
                        }
                        else
                        {
                            CHAR   chEnd = 0x00;
                            dw = (DWORD)(pTemp - pwszName + 1);
                            
                            if( dw > 16 )
                            {
                                DisplayMessage(g_hModule,
                                               EMSG_SRVR_INVALID_NETBIOS_NAME);
                                goto ErrorReturn;
                            }
                            pwszName[dw-1] = L'\0';
                            
                            chEnd = StringToHexA(pTemp+1);

                            if( dwType > 255 )
                            {
                                DisplayMessage(g_hModule, EMSG_WINS_VALUE_OUTOFRANGE);
                            }
                            else
                            {
                                LPWSTR   pwcTemp = WinsAllocateMemory((NBT_NONCODED_NMSZ+1)*sizeof(WCHAR));
                                LPWSTR pwTemp = NULL;
                                if( pwcTemp is NULL )
                                {
                                    Status = ERROR_NOT_ENOUGH_MEMORY;
                                    if( pwszTemp isnot NULL )
                                    {
                                        WinsFreeMemory(pwszTemp );
                                        pwszTemp = NULL;
                                    }
                                    goto ErrorReturn;                            
                                }
                                
                                wcscpy(pwcTemp, pwszName);
                                wcsncat(pwcTemp,
                                        L"                ",
                                        (16 - wcslen(pwszName)));
                                pwcTemp[15] = chEnd;
                                                                
                                for( ilen=0; ilen<NumNBNames; ilen++)
                                {
                                    pwTemp = WinsOemToUnicode(NBNames[ilen], NULL);
                                    if( pwTemp is NULL )
                                    {
                                        Status = ERROR_NOT_ENOUGH_MEMORY;
                                        goto ErrorReturn;
                                    }
                                    if(_wcsicmp(pwTemp, pwcTemp) is 0 )
                                    {
                                        fPresent = TRUE;
                                        break;
                                    }
                                    WinsFreeMemory(pwTemp);
                                    pwTemp = NULL;
                                }
                                if( pwTemp )
                                {
                                    WinsFreeMemory(pwTemp);
                                    pwTemp = NULL;
                                }
                                
                                if( fPresent is FALSE )
                                {
                                    LPSTR pcTemp = NULL;

                                    NBNames[NumNBNames] = WinsAllocateMemory(17);
                                    if( NBNames[NumNBNames] is NULL )
                                    {
                                        if( pwszTemp isnot NULL )
                                        {
                                            WinsFreeMemory(pwszTemp );
                                            pwszTemp = NULL;
                                        }
                                        Status = ERROR_NOT_ENOUGH_MEMORY;
                                        goto ErrorReturn;
                                    }
                                    pcTemp = WinsUnicodeToOem(pwcTemp, NULL);
                                    if( pcTemp is NULL )
                                    {
                                        Status = ERROR_NOT_ENOUGH_MEMORY;
                                        goto ErrorReturn;
                                    }
                                    strncpy(NBNames[NumNBNames], pcTemp, 16);
                                    NBNames[NumNBNames][15] = (CHAR)chEnd;
                                    NBNames[NumNBNames][16] = '\0';
                                    NumNBNames++;
                                    WinsFreeMemory(pcTemp);
                                    pcTemp = NULL;
                                }
                                if( pwcTemp )
                                {
                                    WinsFreeMemory(pwcTemp);
                                    pwcTemp = NULL;
                                }

                            }
                        }
                    }
                    pwszName = wcstok(NULL, pwszToken);

                }
                
                if( pwszTemp )
                {
                    WinsFreeMemory(pwszTemp);
                    pwszTemp = NULL;
                }

                break;
            }
        case 1://NameFile
            {
                HANDLE  hFile = NULL;
                DWORD   dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]),
                        dwFileSize = 0,
                        dw = 0,
                        dwType = 0,
                        dwBytesRead = 0;
                BOOL    fPresent = FALSE;
                int     ilen = 0;
                LPBYTE  pbFileData = NULL;
                LPSTR   pszToken = " ,\r\n\t",
                        pszData = NULL,
                        pTemp = NULL,
                        pszName = NULL,                        
                        pszTemp = NULL;
                LPWSTR  pwszTempName = NULL;
                        

                if( dwLen < 1 )
                {
                    DisplayMessage(g_hModule, 
                                   EMSG_WINS_INVALID_FILENAME, 
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    goto CommonReturn;
                }

                hFile = CreateFile(ppwcArguments[dwCurrentIndex+pdwTagNum[j]],
                                   GENERIC_READ | GENERIC_WRITE,
                                   0,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);

                if( hFile is INVALID_HANDLE_VALUE )
                {
                    Status = GetLastError();
                    goto ErrorReturn;
                }

                dwFileSize = GetFileSize(hFile, NULL);

                if( dwFileSize is 0 )
                {
                    DisplayMessage(g_hModule, 
                                   EMSG_WINS_EMPTY_FILE, 
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    CloseHandle(hFile);
                    hFile = NULL;
                    goto CommonReturn;
                }

                pbFileData = WinsAllocateMemory(dwFileSize+1);

                if( pbFileData is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    CloseHandle(hFile);
                    hFile = NULL;
                    goto ErrorReturn;
                }

                if( !ReadFile( hFile, pbFileData, dwFileSize, &dwBytesRead, NULL) )
                {
                    DisplayMessage(g_hModule, EMSG_WINS_FILEREAD_FAILED);
                    CloseHandle(hFile);
                    hFile = NULL;
                    goto CommonReturn;
                }
                
                CloseHandle(hFile);
                hFile = NULL;

                for( ilen=0; ilen<NumNBNames; ilen++ )
                {
                    if( NBNames[ilen] isnot NULL )
                    {
                        WinsFreeMemory(NBNames[ilen]);
                        NBNames[ilen] = NULL;
                    }
                }
                NumNBNames = 0;

                pszData = (LPSTR)pbFileData;
                
                pszName = strtok(pszData, pszToken);
                while( pszName isnot NULL )
                {
                    dw = strlen(pszName);
                    
                    if( dw < 1 or
                        dw > 18 )
                    {
                        pwszTempName = WinsOemToUnicode(pszName, NULL);
                        if( pwszTempName is NULL )
                        {
                            Status = ERROR_NOT_ENOUGH_MEMORY;
                            goto ErrorReturn;
                        }
                        DisplayMessage(g_hModule, EMSG_WINS_INVALID_NAME, pwszTempName);
                        WinsFreeMemory(pwszTempName);
                        pwszTempName = NULL;
                    }
                    else
                    {
                        WCHAR wcEnd[2] = {L'\0'};
                        CHAR  cEnd[2] = {L'\0'};

                        pTemp = strstr(pszName, "*");
                        if( pTemp is NULL )
                        {
                            pwszTempName = WinsOemToUnicode(pszName, NULL);
                            if( pwszTempName is NULL )
                            {
                                Status = ERROR_NOT_ENOUGH_MEMORY;
                                goto ErrorReturn;
                            }
                            DisplayMessage(g_hModule, EMSG_WINS_INVALID_NAME, pwszTempName);
                            WinsFreeMemory(pwszTempName);
                            pwszTempName = NULL;
                        }
                        else
                        {
                            CHAR    chEndChar = 0x00;
                            LPWSTR  pwszTempBuf = NULL;
                            dw = (DWORD)(pTemp - pszName + 1);
                            if( dw > 16 )
                            {
                                DisplayMessage(g_hModule,
                                               EMSG_SRVR_INVALID_NETBIOS_NAME);
                                goto ErrorReturn;
                            }
                            pszName[dw-1] = L'\0';
                            pwszTempBuf = WinsOemToUnicode(pTemp+1, NULL);

                            if( pwszTempBuf is NULL )
                            {
                                Status = ERROR_NOT_ENOUGH_MEMORY;
                                goto ErrorReturn;
                            }

                            chEndChar = StringToHexA(pwszTempBuf);
                            
                            WinsFreeMemory(pwszTempBuf);
                            pwszTempBuf = NULL;

                            if( dwType > 255 )
                            {
                                DisplayMessage(g_hModule, EMSG_WINS_VALUE_OUTOFRANGE);
                            }
                            else
                            {
                                LPSTR pcTemp = WinsAllocateMemory(NBT_NONCODED_NMSZ+1);
                                if( pcTemp is NULL )
                                {
                                    Status = ERROR_NOT_ENOUGH_MEMORY;
                                    if( pbFileData isnot NULL )
                                    {
                                        WinsFreeMemory(pbFileData );
                                        pbFileData = NULL;
                                    }
                                    goto ErrorReturn;                            
                                }
                                
                                strcpy(pcTemp, pszName);
                                strncat(pcTemp, 
                                        "               ", 
                                        (16-strlen(pszName)));
                           
                                pcTemp[15] = chEndChar;

                                for( ilen=0; ilen<NumNBNames; ilen++)
                                {
                                    if(_stricmp(NBNames[ilen], pcTemp) is 0 )
                                    {
                                        fPresent = TRUE;
                                        break;
                                    }
                                }
                                
                                if( fPresent is FALSE )
                                {
                                    LPSTR   pszOem = NULL;
                                    NBNames[NumNBNames] = WinsAllocateMemory(17);
                                    if( NBNames[NumNBNames] is NULL )
                                    {
                                        Status = ERROR_NOT_ENOUGH_MEMORY;
                                        goto ErrorReturn;
                                    }
                                    
                                    pszOem = WinsAnsiToOem(pcTemp);
                                    if( pszOem is NULL )
                                    {
                                        Status = ERROR_NOT_ENOUGH_MEMORY;
                                        goto ErrorReturn;
                                    }
                                    strncpy(NBNames[NumNBNames], pszOem, 16);
                                    
                                    WinsFreeMemory(pszOem);
                                    pszOem = NULL;

                                    NBNames[NumNBNames][15] = (CHAR)chEndChar;
                                    NumNBNames++;
                                }
                                if( pcTemp )
                                {
                                    WinsFreeMemory(pcTemp);
                                    pcTemp = NULL;
                                }
                            }
                        }
                    }
                    pszName = strtok(NULL, pszToken);
                }
                if( pbFileData )
                {
                    WinsFreeMemory(pbFileData);
                    pbFileData = NULL;
                }
                break;
            }
        case 2://ServerList
            {
                LPWSTR  pwszToken = L",\r\n\t ",
                        pwszName = NULL,
                        pwszTemp = NULL;
                int     ilen = 0;
                BOOL    fPresent = FALSE;
                DWORD   dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                

                if( dwLen < 2 )
                {
                    NumWinServers = 0;
                    break;
                }
                if( ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0] isnot L'{' or
                    ppwcArguments[dwCurrentIndex+pdwTagNum[j]][dwLen-1] isnot L'}' )
                {
                    NumWinServers = 0;
                    break;
                }

                pwszTemp = WinsAllocateMemory((dwLen)*sizeof(WCHAR));

                if(pwszTemp is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                
                if( fInclPartner is FALSE )
                {
                    memset(WinServers, 0x00, MAX_SERVERS*sizeof(WINSERVERS));

                    NumWinServers = 0;
                }

                wcscpy(pwszTemp, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+1);
                pwszTemp[dwLen-2] = L'\0';
                
                pwszName = wcstok(pwszTemp, pwszToken);
                
                while(pwszName isnot NULL )
                {             
                    fPresent = FALSE;
                    if( IsIpAddress(pwszName) is FALSE )
                    {
                        DisplayMessage(g_hModule, EMSG_WINS_INVALID_IPADDRESS, pwszName);
                    }
                    else
                    {
                        struct in_addr  Temp;
                        LPSTR           pszTempAddr = NULL;

                        pszTempAddr = WinsUnicodeToAnsi(pwszName, NULL);
                        if( pszTempAddr is NULL )
                        {
                            Status = ERROR_NOT_ENOUGH_MEMORY;
                            goto ErrorReturn;
                        }
                        Temp.s_addr = inet_addr(pszTempAddr);
                        
                        WinsFreeMemory(pszTempAddr);
                        pszTempAddr = NULL;

                        if( Temp.s_addr isnot INADDR_NONE )
                        {
                            for( ilen=0; ilen<NumWinServers; ilen++)
                            {
                                if( WinServers[ilen].Server.s_addr is Temp.s_addr )
                                {
                                    fPresent = TRUE;
                                    break;
                                }
                            }
                        
                            fIpEmpty = FALSE;

                            if( fPresent is FALSE )
                            {
                                WinServers[NumWinServers].Server.s_addr = Temp.s_addr;
                                NumWinServers++;
                            }                       
                        }
                    }
                    pwszName = wcstok(NULL, pwszToken);
                }
                
                break;
            }
        case 3://ServerFile
            {
                HANDLE hFile = NULL;
                DWORD   dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]),
                        dwFileSize = 0,
                        dwBytesRead = 0;
                BOOL    fPresent = FALSE;
                int     ilen = 0;
                LPBYTE  pbFileData = NULL;
                LPSTR   pszToken = " ,\r\n\t",
                        pszData = NULL,
                        pszName = NULL;
                LPWSTR  pwszToken = L" ,\r\n\t",
                        pwszName = NULL,
                        pwszData = NULL;
            
                if( dwLen < 1 )
                {
                    DisplayMessage(g_hModule, 
                                   EMSG_WINS_INVALID_FILENAME, 
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    goto CommonReturn;
                }

                hFile = CreateFile(ppwcArguments[dwCurrentIndex+pdwTagNum[j]],
                                   GENERIC_READ | GENERIC_WRITE,
                                   0,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);

                if( hFile is INVALID_HANDLE_VALUE )
                {
                    Status = GetLastError();
                    goto ErrorReturn;
                }

                dwFileSize = GetFileSize(hFile, NULL);

                if( dwFileSize is 0 )
                {
                    DisplayMessage(g_hModule, 
                                   EMSG_WINS_EMPTY_FILE, 
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    CloseHandle(hFile);
                    hFile = NULL;
                    goto CommonReturn;
                }

                pbFileData = WinsAllocateMemory(dwFileSize+1);

                if( pbFileData is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    CloseHandle(hFile);
                    hFile = NULL;
                    goto ErrorReturn;
                }

                if( !ReadFile( hFile, pbFileData, dwFileSize, &dwBytesRead, NULL) )
                {
                    CloseHandle(hFile);
                    hFile = NULL;
                    DisplayMessage(g_hModule, EMSG_WINS_FILEREAD_FAILED);
                    goto CommonReturn;
                }
                
                CloseHandle(hFile);
                hFile = NULL;
                
                if( fInclPartner is FALSE )
                {
                    memset(WinServers, 0x00, MAX_SERVERS*sizeof(WINSERVERS));

                    NumWinServers = 0;
                }

                pszData = (LPSTR)pbFileData;
                pwszData = WinsOemToUnicode(pszData, NULL);
                if( pwszData is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                pwszName = wcstok(pwszData, pwszToken);
                while( pwszName isnot NULL )
                {
                    fPresent = FALSE;
                    pszName = WinsUnicodeToOem(pwszName, NULL);
                    
                    if( pszName is NULL )
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }

                    if( IsIpAddress(pwszName) is FALSE )
                    {
                        DisplayMessage(g_hModule, EMSG_WINS_INVALID_IPADDRESS, pwszName);
                    }
                    else
                    {
                        struct in_addr  Temp;

                        Temp.s_addr = inet_addr(pszName);

                        if( Temp.s_addr isnot INADDR_NONE )
                        {
                            for( ilen=0; ilen<NumWinServers; ilen++)
                            {
                                if( WinServers[ilen].Server.s_addr is Temp.s_addr )
                                {
                                    fPresent = TRUE;
                                    break;
                                }
                            }
                 
                            fIpEmpty = FALSE;
                            
                            if( fPresent is FALSE )
                            {
                                WinServers[NumWinServers].Server.s_addr = Temp.s_addr;
                                NumWinServers++;
                            }
                        }
                    }
                    pwszName = wcstok(NULL, pwszToken);
                    if( pszName )
                    {
                        WinsFreeMemory(pszName);
                        pszName = NULL;
                    }
                }

                if( pbFileData )
                {
                    WinsFreeMemory(pbFileData);
                    pbFileData = NULL;
                }
                if( pwszData )
                {
                    WinsFreeMemory(pwszData);
                    pwszData = NULL;
                }

                break;
            }
        case 4://IncludePartners
            {
                HKEY    hServer = NULL,
                        hPull = NULL,
                        hPush = NULL;
                LPWSTR  pTemp = NULL;
                WCHAR   wcKey[MAX_IP_STRING_LEN+1] = {L'\0'};
                DWORD   dw = 0,
                        dwLen = MAX_IP_STRING_LEN+1,
                        dwKeys = 0;                
                if(wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) isnot 1 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                if( ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0] isnot L'Y' and
                    ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0] isnot L'y' )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                if( wcslen(g_ServerNetBiosName) < 2 )
                {
                    pTemp = NULL;
                }

                Status = RegConnectRegistry(pTemp,
                                            HKEY_LOCAL_MACHINE,
                                            &hServer );
                if( Status isnot NO_ERROR )
                {
                    Status = NO_ERROR;
                    break;
                }
                
                while(TRUE)
                {
                    Status = RegOpenKeyEx(hServer,
                                          PULLROOT,
                                          0,
                                          KEY_ALL_ACCESS,
                                          &hPull);

                    if( Status isnot NO_ERROR )
                    {
                        Status = NO_ERROR;
                        break;
                    }

                    Status = RegQueryInfoKey(hPull,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &dwKeys,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL);
                    
                    if( Status isnot NO_ERROR )
                    {
                        Status = NO_ERROR;
                        break;
                    }

                    if( dwKeys < 1 )
                        break;

                    for( dw=0; dw<dwKeys; dw++ )
                    {
                        DWORD i = 0;                             
                        LPSTR pszTempAddr = NULL;
                        BOOL  fPresent = FALSE;
                        struct in_addr  Temp;

                        dwLen = MAX_IP_STRING_LEN+1;

                        memset(wcKey, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));

                        Status = RegEnumKeyEx(hPull,
                                              dw,
                                              wcKey,
                                              &dwLen,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL);

                        if( Status isnot NO_ERROR )
                            continue;

                        pszTempAddr = WinsUnicodeToOem(wcKey, NULL);
                        if( pszTempAddr is NULL )
                        {
                            Status = ERROR_NOT_ENOUGH_MEMORY;
                            goto ErrorReturn;
                        }
                        Temp.s_addr = inet_addr(pszTempAddr);

                        WinsFreeMemory(pszTempAddr);
                        pszTempAddr = NULL;

                        if( Temp.s_addr isnot INADDR_NONE )
                        {
                            fPresent = FALSE;
                            if( MAX_SERVERS > NumWinServers )
                            {
                                for( i=0; i<(DWORD)NumWinServers; i++)
                                {
                                    if( WinServers[i].Server.s_addr is Temp.s_addr )
                                    {
                                        fPresent = TRUE;
                                        break;
                                    }
                                }
                            
                                if( fPresent is FALSE )
                                {
                                    WinServers[NumWinServers].Server.s_addr = Temp.s_addr;
                                    NumWinServers++;
                                }

                            }
                            else
                                break;
                        }

                    }

                }

                if( hPull )
                {
                    RegCloseKey(hPull);
                    hPull = NULL;
                }

                dw = dwKeys = 0;

                while(TRUE)
                {
                    Status = RegOpenKeyEx(hServer,
                                          PUSHROOT,
                                          0,
                                          KEY_ALL_ACCESS,
                                          &hPush);

                    if( Status isnot NO_ERROR )
                    {
                        Status = NO_ERROR;
                        break;
                    }

                    Status = RegQueryInfoKey(hPush,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &dwKeys,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL);
                    
                    if( Status isnot NO_ERROR )
                    {
                        Status = NO_ERROR;
                        break;
                    }

                    if( dwKeys < 1 )
                        break;

                    for( dw=0; dw<dwKeys; dw++ )
                    {
                        DWORD i = 0;
                        BOOL  fPresent = FALSE;
                        LPSTR pszTempAddr = NULL;
                        struct in_addr  Temp;

                        dwLen = MAX_IP_STRING_LEN+1;

                        memset(wcKey, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));

                        Status = RegEnumKeyEx(hPush,
                                              dw,
                                              wcKey,
                                              &dwLen,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL);

                        if( Status isnot NO_ERROR )
                            continue;

                        pszTempAddr = WinsUnicodeToOem(wcKey, NULL);
                        if( pszTempAddr is NULL )
                        {
                            Status = ERROR_NOT_ENOUGH_MEMORY;
                            goto ErrorReturn;
                        }

                        Temp.s_addr = inet_addr(pszTempAddr);
                        WinsFreeMemory(pszTempAddr);
                        pszTempAddr = NULL;

                        if( Temp.s_addr isnot INADDR_NONE )
                        {
                            if( MAX_SERVERS > NumWinServers )
                            {
                                for( i=0; i<(DWORD)NumWinServers; i++)
                                {
                                    if( WinServers[i].Server.s_addr is Temp.s_addr )
                                    {
                                        fPresent = TRUE;
                                        break;
                                    }
                                }
                            
                                if( fPresent is FALSE )
                                {
                                    WinServers[NumWinServers].Server.s_addr = Temp.s_addr;
                                    NumWinServers++;
                                }

                            }
                            else
                                break;
                        }

                    }

                }
                if( hPush )
                {
                    RegCloseKey(hPush);
                    hPush = NULL;
                }

                if( hServer )
                {
                    RegCloseKey(hServer);
                    hServer = NULL;
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    if( NumNBNames is 0 )
    {
        DisplayMessage(g_hModule, EMSG_WINS_NO_NAMES);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( NumWinServers is 0 )
    {
        DisplayMessage(g_hModule, EMSG_WINS_NO_SERVERS);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( fIpEmpty is TRUE )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_NO_SERVERS);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    else
    {
        CheckNameConsistency();
    }

    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);


CommonReturn:

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    if( pdwIpAddress )
    {
        WinsFreeMemory(pdwIpAddress);
        pdwIpAddress = NULL;
    }

    if( ppNames )
    {    
        WinsFreeMemory(ppNames);
        ppNames = NULL;
    }

    if( WinServers )
    {
        WinsFreeMemory(WinServers);
        WinServers = NULL;
    }

    if( NBNames )
    {
        WinsFreeMemory(NBNames);
        NBNames = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_CHECK_NAME, Status);
    goto CommonReturn;
}

DWORD
HandleSrvrCheckVersion(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Checks the version number consistencies for the records
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory, IP address of the server to start with.
        Optional, a File Name to store the output in proper format.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount = 0;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_SERVER, TRUE, FALSE},
                                {WINS_TOKEN_FILE, FALSE, FALSE},
                            };

    PDWORD      pdwTagNum = NULL,
                pdwTagType = NULL;
    
    BOOL        fFile = FALSE;
    FILE        *pFile = NULL;
    LPSTR       pStartIp = NULL;

    //Must provide the IP address of the server to start with
    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_CHECK_VERSION_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;

    }

    //Start processing the arguements based on the 
    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }
    
    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        //Ip Address of the server to start with
        case 0:
            {
                WCHAR   wcServerIpAdd[MAX_IP_STRING_LEN+1] = {L'\0'};
                                    
                if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) is FALSE )
                {
                    Status = ERROR_INVALID_IPADDRESS;
                    goto ErrorReturn;
                }

                wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);

                pStartIp = WinsUnicodeToOem(wcServerIpAdd, NULL);

                if( pStartIp is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                break;

            }
        //File to store the output data
        case 1:
            {
                WCHAR       wcFile[MAX_PATH] = {L'\0'};
            
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 or
                    wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > MAX_PATH )
                {
                    wcscpy(wcFile, L"wins.rec");
                }
                else
                {
                    wcscpy(wcFile, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                }

                pFile = _wfopen(wcFile, L"w+");

                if( pFile is NULL )
                {
                    pFile = _wfopen(L"wins.rec", L"w+");
                    fFile = TRUE;
                }
                else
                {
                    fFile = TRUE;
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }


    CheckVersionNumbers( pStartIp,
                         fFile,
                         pFile);

CommonReturn:
    
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    
    if( pFile )
    {
        fclose(pFile);
        pFile = NULL;
    }
    
    if( pStartIp)
    {
        WinsFreeMemory(pStartIp);
        pStartIp = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_CHECK_VERSION,
                        Status);
    goto CommonReturn;
}


DWORD
HandleSrvrDeleteName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Deletes an record entry for the WINS server database
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory, Record Name, Endchar
        Optional, Scope
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount = 0;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_NAME, TRUE, FALSE},
                                {WINS_TOKEN_ENDCHAR, TRUE, FALSE},
                                {WINS_TOKEN_SCOPE, FALSE, FALSE}
                            };
    PDWORD      pdwTagNum = NULL,
                pdwTagType = NULL;

    WCHAR       wszName[MAX_STRING_LEN] = {L'\0'};
    BOOL        fEndChar = FALSE;

    CHAR        ch16thChar = 0x00;
    BOOL        fScope = FALSE;
    WCHAR       wszScope[MAX_STRING_LEN] = {L'\0'};
    LPSTR       pszTempName = NULL;
    DWORD       dwTempNameLen = 0;
    
    DWORD       dwStrLen = 0;
    LPWSTR      pwszTemp = NULL;
    WINSINTF_RECORD_ACTION_T    RecAction = {0};
    PWINSINTF_RECORD_ACTION_T   pRecAction = NULL;

    memset(&RecAction, 0x00, sizeof(WINSINTF_RECORD_ACTION_T));
    RecAction.fStatic = FALSE;

    //Must provide at least the record name and endchar
    if( dwArgCount < dwCurrentIndex + 2 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_DELETE_NAME_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //Start processing the arguments based on ppwcArguments, dwArgCount and dwCurrentIndex
    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    i = dwTagCount;
    for( j=0; j<i; j++ )
    {
        switch(pdwTagType[j])
        {
        //Record Name
        case 0:
            {
                DWORD dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dwLen = ( 255 < dwLen ) ? 255 : dwLen;
                memcpy(wszName, 
                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 
                       dwLen*sizeof(WCHAR));
                wszName[dwLen] = L'\0';               
                break;
            }
        //Endchar
        case 1:
            {   
                DWORD dwLen = 0, k=0;
                fEndChar = TRUE;
                dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen > 2 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                        
                }
                
                for( k=0; k<dwLen; k++ )
                {
                    WCHAR  wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][k];
                    if( towlower(wc) >= L'a' and
                        towlower(wc) <= L'z' )
                    {
                        if( towlower(wc) > L'f' )
                        {
                            Status = ERROR_INVALID_PARAMETER;
                            goto ErrorReturn;
                        }
                    }
                }                

                ch16thChar = StringToHexA(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);

                break;
            }
        //Scope 
        case 2:
            {
                DWORD dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                fScope = TRUE;
                if( dwLen is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dwLen = ( 255 < dwLen ) ? 255 : dwLen;
                memcpy(wszScope,
                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 
                       dwLen*sizeof(WCHAR));
                wszScope[dwLen] = L'\0';               
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
    
     
    _wcsupr(wszName);
    _wcsupr(wszScope);

    pszTempName = WinsUnicodeToOem(wszName, NULL);

    if( pszTempName is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwStrLen = strlen(pszTempName);
    
    if( dwStrLen >= 16 )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_NETBIOS_NAME);
        Status = ERROR_INVALID_PARAMETER;
        WinsFreeMemory(pszTempName);
        pszTempName = NULL;
        goto ErrorReturn;
    }    
    
    RecAction.pName = WinsAllocateMemory(273);

    if( RecAction.pName is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    strncpy(RecAction.pName, pszTempName, dwStrLen);
    
    WinsFreeMemory(pszTempName);
    pszTempName = NULL;

    for( i=dwStrLen; i < 16; i++ )
    {
        RecAction.pName[i] = ' ';
    }

    if( fEndChar )
    {
        if( ch16thChar is 0x00 )
        {
            RecAction.pName[15] = 0x00;
        }
        else
        {           
            RecAction.pName[15] = ch16thChar;
        }

    }
    
    RecAction.pName[16] = '\0';
    
    dwStrLen = 16;

    if( fScope )
    {
        DWORD dwLen = 0;

        RecAction.pName[dwStrLen] = '.';
        pszTempName = WinsUnicodeToOem(wszScope, NULL);
        if( pszTempName is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        dwLen = strlen(pszTempName);
        dwLen = ( 255 - dwStrLen < dwLen ) ? 255 - dwStrLen : dwLen;

        strncpy(RecAction.pName + dwStrLen + 1, pszTempName, dwLen);
        WinsFreeMemory(pszTempName);
        pszTempName = NULL;
        RecAction.pName[dwLen + dwStrLen + 1] = '\0';
        if( fEndChar and 
            ch16thChar is 0x00 )
            dwStrLen = 16+dwLen+1;
        else
            dwStrLen = strlen(RecAction.pName);
    }
    else
    {

        RecAction.pName[dwStrLen] = '\0';
    }

    RecAction.NameLen = dwStrLen;

    RecAction.Cmd_e = WINSINTF_E_QUERY;

    RecAction.OwnerId = StringToIpAddress(g_ServerIpAddressUnicodeString);
   
    RecAction.NameLen = dwStrLen;
    pRecAction = &RecAction;

    Status = WinsRecordAction(g_hBind, &pRecAction);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    RecAction.Cmd_e      = WINSINTF_E_DELETE;
    
    RecAction.State_e      = WINSINTF_E_DELETED;   

    pRecAction = &RecAction;

    Status = WinsRecordAction(g_hBind, &pRecAction);
    
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( pszTempName )
    {
        WinsFreeMemory(pszTempName);
        pszTempName = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    
    if( RecAction.pName )
    {
        WinsFreeMemory(RecAction.pName);
        RecAction.pName = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_DELETE_NAME, Status);
    goto CommonReturn;

    return NO_ERROR;
}


DWORD
HandleSrvrDeletePartner(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Delete a partner from the WINS server
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Confirmation
        Optional : Server IP and Type.
        Note : If no ip is provided, it deletes all partners in the list.
               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;
    
    TAG_TYPE    pttTags[] = { 
                                {WINS_TOKEN_SERVER, FALSE, FALSE},
                                {WINS_TOKEN_TYPE, FALSE, FALSE},
                                {WINS_TOKEN_CONFIRM, TRUE, FALSE},
                            };
    WCHAR       wcServerIpAdd[MAX_IP_STRING_LEN + 1] = {L'\0'};
    DWORD       dwIpLen = (MAX_IP_STRING_LEN+1);
    BOOL        fPull = TRUE,
                fPush = TRUE,
                fConfirm = FALSE;

    HKEY        hServer = NULL,
                hPartner = NULL;

    LPWSTR      pTemp = NULL;

    //Must provide the confirmation in order for this to succeed.
    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_DELETE_PARTNER_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    //Start processing the arguments based on ppwcArguments, dwCurrentIndex and dwArgCount
    else
    {
        dwNumArgs = dwArgCount - dwCurrentIndex;

        pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
        pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

        if( pdwTagType is NULL or
            pdwTagNum is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

        Status = PreProcessCommand(ppwcArguments,
                                   dwArgCount,
                                   dwCurrentIndex,
                                   pttTags,
                                   &dwTagCount,
                                   pdwTagType,
                                   pdwTagNum);
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
        {
            if( pttTags[i].dwRequired is TRUE and
                pttTags[i].bPresent is FALSE 
              )
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }

        for( j=0; j<dwTagCount; j++ )
        {
            switch(pdwTagType[j])
            {
            //Server Ip
            case 0:
                {
                    struct  hostent * lpHostEnt = NULL;
                    CHAR    cAddr[16];
                    BYTE    pbAdd[4];
                    char    szAdd[4];
                    int     k = 0, l=0;
                    DWORD   dwLen, nLen = 0;
                    CHAR    *pTemp = NULL;
                    CHAR    *pNetBios = NULL;
                    
                    if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) is FALSE )
                    {
                        Status = ERROR_INVALID_IPADDRESS;
                        goto ErrorReturn;
                    }

                    wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    break;

                }
            //Partner Type
            case 1:
                {
                    DWORD dw = 0;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }                    

                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                    switch(dw)
                    {
                    case 0:
                        {
                            fPull = TRUE;
                            fPush = FALSE;
                            break;
                        }
                    case 1:
                        {
                            fPull = FALSE;
                            fPush = TRUE;
                            break;
                        }
                    case 2:
                        {
                            fPull = TRUE;
                            fPush = TRUE;
                            break;
                        }
                    default:
                        {
                            Status = ERROR_INVALID_PARAMETER;
                            break;
                        }
                    }
                    break;
                }
            //Confirmation
            case 2 :
                {
                    if( 0 is _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"Y", 1) )
                        fConfirm = TRUE;
                    else if ( 0 is _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"N", 1) )
                        fConfirm = FALSE;
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    break;

                }
            default:
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
            }
        }
    }

    if( fConfirm is FALSE )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_CONFIRMATION_DENIED);
        goto CommonReturn;
    }

    {
        if( wcslen(g_ServerNetBiosName) > 0 )
        {
            pTemp = g_ServerNetBiosName;
        }
        
        Status = RegConnectRegistry(pTemp,
                                    HKEY_LOCAL_MACHINE,
                                    &hServer);

        if( Status isnot ERROR_SUCCESS )
            goto ErrorReturn;

        //PullPartners
        if( fPull )
        {
            Status = RegOpenKeyEx(hServer,
                                  PULLROOT,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hPartner);
            if( Status isnot NO_ERROR )
            {
                if (Status == ERROR_FILE_NOT_FOUND)
                    Status = NO_ERROR;

                goto PUSH;
            }
            
            if( wcslen(wcServerIpAdd) < 3 )//not a valid Ip, delete all partners
            {
     
                while(TRUE)
                {
                    Status = RegEnumKeyEx(hPartner, 0, wcServerIpAdd, &dwIpLen, NULL, NULL, NULL, NULL);
                    if (Status != ERROR_SUCCESS)
                        break;
                    RegDeleteKey(hPartner, wcServerIpAdd);
                    dwIpLen = (MAX_IP_STRING_LEN + 1)*sizeof(WCHAR);
                    memset(wcServerIpAdd, L'\0', MAX_IP_STRING_LEN+1);
                }
            }
            else
            {
                RegDeleteKey(hPartner,
                             wcServerIpAdd);
            }

            if( hPartner )
            {
                RegCloseKey(hPartner);
                hPartner = NULL;
            }

            if( Status is ERROR_NO_MORE_ITEMS )
            {
                Status = NO_ERROR;
                goto PUSH;
            }
            
            if( Status is ERROR_FILE_NOT_FOUND )
            {
                DisplayMessage(g_hModule,
                               EMSG_INVALID_PARTNER_NAME);
                if( fPush )
                    goto PUSH;
                else
                    goto CommonReturn;
            }
            if( Status isnot NO_ERROR )
            {
                if( fPush )
                    goto PUSH;
                else
                    goto CommonReturn;
            }


        }
        //Push Partner
PUSH:   if( fPush )
        {
            Status = RegOpenKeyEx(hServer,
                                  PUSHROOT,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hPartner);

            if (Status is ERROR_FILE_NOT_FOUND)
            {
                DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
                goto CommonReturn;
            }

            if( Status isnot NO_ERROR )
                goto ErrorReturn;
    
            dwIpLen = (MAX_IP_STRING_LEN + 1);
            if( wcslen(wcServerIpAdd) < 3 )//not a valid Ip, delete all partners
            {
                while( TRUE )
                {
                    Status = RegEnumKeyEx(hPartner, 0, wcServerIpAdd, &dwIpLen, NULL, NULL, NULL, NULL);
                    if (Status != ERROR_SUCCESS)
                        break;
                    RegDeleteKey(hPartner, wcServerIpAdd);
                    dwIpLen = (MAX_IP_STRING_LEN + 1)*sizeof(WCHAR);
                }
            }
            else
            {
                RegDeleteKey(hPartner,
                             wcServerIpAdd);
            }

            if( Status is ERROR_NO_MORE_ITEMS )
            {
                Status = NO_ERROR;
            }

            if( Status is ERROR_FILE_NOT_FOUND )
            {
                DisplayMessage(g_hModule,
                               EMSG_INVALID_PARTNER_NAME);
                goto ErrorReturn;
            }

            if( Status isnot NO_ERROR )
                goto ErrorReturn;
            
            if( hPartner )
            {
                RegCloseKey(hPartner);
                hPartner = NULL;
            }
        }
    }    



    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    else
        goto ErrorReturn;

CommonReturn:


    if( hPartner )
    {
        RegCloseKey(hPartner);
        hPartner = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_DELETE_PARTNER, Status);
    goto CommonReturn;
}

DWORD
HandleSrvrDeleteRecords(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Delete or Tombstone records from a WINS server based on the version
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Minimum and Maximum version numbers( range of version ) to be 
                     deleted/tombstoned
        Optional : Operation - tombstone(default) or delete
               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount = 0;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_MINVER, TRUE, FALSE},
                                {WINS_TOKEN_MAXVER, TRUE, FALSE},
                                {WINS_TOKEN_OP, FALSE, FALSE},
                            };
    BOOL        fDelete = TRUE;
    WINSINTF_VERS_NO_T  MinVer, MaxVer;
    WINSINTF_ADD_T      WinsAdd;
    LPWSTR              pwszTemp = NULL;

    //Needs at least both Min Ver and Max ver
    if( dwArgCount < dwCurrentIndex + 2 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_DELETE_RECORDS_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //Start processing the arguments based on ppwcArguments, dwCurrentIndex and dwArgCount
    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    if( pdwTagType is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    if( pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }
        
    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    i = dwTagCount;

    for( j=0; j<i; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0://{high,low} format, Min version
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &MinVer);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;
            }
        case 1://{high,low} format, Max version
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &MaxVer);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;
            }
        case 2: //Operation 0 - delete 1 - Tombstone
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                if( dw is 0 )
                    fDelete = TRUE;
                else if( dw is 1 )
                    fDelete = FALSE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        
        }
    }

    WinsAdd.IPAdd = StringToIpAddress(g_ServerIpAddressUnicodeString);
    WinsAdd.Len = 4;
    WinsAdd.Type = 0;

    if( fDelete )
    {
        Status = WinsDelDbRecs(g_hBind, &WinsAdd, MinVer, MaxVer);
    }
    else
    {
        Status = WinsTombstoneDbRecs(g_hBind, &WinsAdd, MinVer, MaxVer);
    }
    if( Status isnot NO_ERROR )
        goto ErrorReturn;
CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_DELETE_RECORDS,
                        Status);
    goto CommonReturn;
}                  


DWORD
HandleSrvrDeleteWins(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Delete a partner from the WINS server
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Confirmation
        Optional : Server IP and Type.
        Note : If no ip is provided, it deletes all partners in the list.
               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD                   Status = NO_ERROR;
    DWORD                   i, j, dwNumArgs, dwTagCount;
    TAG_TYPE                pttTags[] = {
                                            {WINS_TOKEN_SERVERS, TRUE, FALSE},
                                            {WINS_TOKEN_OP, FALSE, FALSE},
                                        };
    DWORD                   dwIpCount = 0;
    LPDWORD                 pdwIp = NULL,
                            pdwTagType = NULL,
                            pdwTagNum = NULL;
                    
    BOOL                    fDelete = FALSE;

    WINSINTF_ADD_T          WinsAdd;
    handle_t                hBind;
    WINSINTF_BIND_DATA_T    BindData;
    
    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, 
                       HLP_SRVR_DELETE_WINS_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;

    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }


    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                LPWSTR  pszIps = NULL;
                DWORD   dwIpLen = 0;
                LPWSTR  pTemp = NULL;
                DWORD   dwIp = 0;
                
                dwIpCount = 0;

               
                dwIpLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
    
                if( dwIpLen < 2 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                pszIps = WinsAllocateMemory((dwIpLen+1)*sizeof(WCHAR));
                if( pszIps is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                wcscpy(pszIps, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                
                if( pszIps[0] isnot L'{' or 
                    pszIps[dwIpLen-1] isnot L'}')
                {
                    Status = ERROR_INVALID_PARAMETER;
                    if( pszIps )
                    {
                        WinsFreeMemory(pszIps);
                        pszIps = NULL;
                    }
                    goto ErrorReturn;
                }
                
                pTemp = pszIps+1;                               
                pszIps[dwIpLen-1] = L'\0';

                pTemp = wcstok(pTemp, L",");
                
                while(( pTemp isnot NULL ) && (dwIpCount < WINSINTF_MAX_MEM ) )
                {
                    PDWORD  pdwTemp = NULL;
                    dwIpCount++;
                    pdwTemp = WinsAllocateMemory(dwIpCount*sizeof(DWORD));
                    if( pdwTemp is NULL )
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        if( pszIps )
                        {
                            WinsFreeMemory(pszIps);
                            pszIps = NULL;
                        }
                        goto ErrorReturn;
                    }
                    if( pdwIp )
                    {
                        memcpy(pdwTemp, pdwIp, (dwIpCount-1)*sizeof(DWORD));
                        WinsFreeMemory(pdwIp);
                        pdwIp = NULL;
                    }
                    
                    dwIp = StringToIpAddress(pTemp);

                    if( dwIp is INADDR_NONE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        if( pszIps )
                        {
                            WinsFreeMemory(pszIps);
                            pszIps = NULL;
                        }
                        
                        if( pdwTemp )
                        {
                            WinsFreeMemory(pdwTemp);
                            pdwTemp = NULL;
                        }

                        goto ErrorReturn;
                    }
                    pdwTemp[dwIpCount-1] = dwIp;
                    pdwIp = pdwTemp;
                    pTemp = wcstok(NULL, L",");
                }
                if( pszIps )
                {
                    WinsFreeMemory(pszIps);
                    pszIps = NULL;
                }
                break;
            }
        case 1:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 10);
                if( dw is 0 )
                {
                    fDelete = FALSE;
                    break;
                }
                else if( dw is 1 )
                {
                    fDelete = TRUE;
                    break;
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            
        }
    }
    

    for( i=0; i<dwIpCount; i++ )
    {
        WinsAdd.Len = 4;
        WinsAdd.Type = 0;
        WinsAdd.IPAdd = pdwIp[i];

        if( fDelete is TRUE )
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_DELETING_RECORD,
                           IpAddressToString(pdwIp[i]));

            Status = WinsDeleteWins(g_hBind, 
                                    &WinsAdd);
        }
        else
        {
            WINSINTF_RESULTS_T  Results;
            WINSINTF_VERS_NO_T	MinVer;
	        WINSINTF_VERS_NO_T	MaxVer;
            
            MaxVer.HighPart = 0;
            MaxVer.LowPart = 0;
            MinVer.HighPart = 0;
            MinVer.LowPart = 0;

            DisplayMessage(g_hModule,
                           MSG_WINS_TOMBSTONE_RECORD,
                           IpAddressToString(pdwIp[i]));


            Status = WinsTombstoneDbRecs(g_hBind,
                                         &WinsAdd,
                                         MinVer,
                                         MaxVer);
        }
        if( Status isnot NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           EMSG_WINS_OPERATION_FAILED,
                           IpAddressToString(pdwIp[i]));

            DisplayErrorMessage(EMSG_SRVR_ERROR_MESSAGE,
                                Status);
                           
            continue;
        }


    }

    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_ERROR_SUCCESS);
    }

CommonReturn:

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    if( pdwIp )
    {
        WinsFreeMemory(pdwIp);
        pdwIp = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_DELETE_WINS,
                        Status);
    goto CommonReturn;
}


DWORD
HandleSrvrDeletePersona(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Delete one or all PNG servers from the list of PNG servers
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : A list of server IP Address separated by commas and 
                     enclosed by {}. If no server address is provided within {}
                     it will delete all PNG servers.              
Return Value:
        Returns the status of the operation.

--*/
{   
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwTagCount, dwNumArgs;
    HKEY        hServer = NULL,
                hPartner = NULL;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_SERVERS,TRUE, FALSE},
                            };

    LPBYTE      pbData = NULL,
                pbValue = NULL;
    DWORD       dwSize = 0,
                dwType = 0,
                dwCount = 0,
                dwTemp = 0;
    
    LPWSTR      pTemp = NULL,
                pwszPng = NULL;
    DWORD       dwTagType = 1,
                dwTagNum = 1,
                dwLenCount = 0,
                dwPngIp = 0;
    
    LPDWORD     pdwPngIp = NULL;
    BOOL        fAtleastone = FALSE;
    BOOL        fGrata;

    fGrata = (wcsstr(CMD_SRVR_DELETE_PNGSERVER, ppwcArguments[dwCurrentIndex-1]) == NULL);

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, fGrata ? HLP_SRVR_DELETE_PGSERVER_EX : HLP_SRVR_DELETE_PNGSERVER_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               &dwTagType,
                               &dwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    if( pttTags[0].bPresent is FALSE )
    {
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( wcslen(g_ServerNetBiosName) > 0 )
        pTemp = g_ServerNetBiosName;

    Status = RegConnectRegistry(pTemp,
                                HKEY_LOCAL_MACHINE,
                                &hServer);

    if( Status isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    Status = RegOpenKeyEx(hServer,
                          PARTNERROOT,
                          0,
                          KEY_ALL_ACCESS,
                          &hPartner);

    
    if( Status isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    if (!CheckValidPgOp(hPartner, fGrata))
    {
        DisplayMessage(g_hModule, fGrata ? EMSG_SRVR_PG_INVALIDOP : EMSG_SRVR_PNG_INVALIDOP);
        Status = ERROR_INVALID_PARAMETER;
        goto CommonReturn;
    }

    Status = RegQueryValueEx(hPartner,
                             fGrata ? PGSERVER : PNGSERVER,
                             NULL,
                             &dwType,
                             NULL,
                             &dwSize);

    if( Status isnot NO_ERROR && Status isnot ERROR_FILE_NOT_FOUND)
        goto ErrorReturn;

    if( dwSize < 7 )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_ERROR_SUCCESS);
        goto CommonReturn;
    }
    
    pbData = WinsAllocateMemory(dwSize);
    

    if( pbData is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    Status = RegQueryValueEx(hPartner,
                             fGrata ? PGSERVER : PNGSERVER,
                             NULL,
                             &dwType,
                             pbData,
                             &dwSize);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    pwszPng = (LPWSTR)pbData;

    for( i=0; i<(dwSize+2)/sizeof(WCHAR); i++ )
    {
        if( pwszPng[i] is L'\0' and
            pwszPng[i+1] isnot L'\0')
        {
            pwszPng[i] = L',';
            i++;
        }
    }

    dwPngIp = 0;
    dwCount = 0;
    pTemp = wcstok(pwszPng, L",");
    
    while((pTemp isnot NULL) && (dwLenCount+sizeof(WCHAR)*7<dwSize))
    {
        LPDWORD     pdwTemp = pdwPngIp;
        
        dwPngIp++;
        
        dwLenCount += wcslen(pTemp)*sizeof(WCHAR);
        pdwPngIp = WinsAllocateMemory(dwPngIp*sizeof(DWORD));

        if( pdwPngIp is NULL )
        {
            WinsFreeMemory(pdwTemp);
            pdwTemp = NULL;
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
        if( pdwTemp isnot NULL )
        {
            memcpy(pdwPngIp, pdwTemp, (dwPngIp-1)*sizeof(DWORD));
            WinsFreeMemory(pdwTemp);
            pdwTemp = NULL;
        }
        
        pdwPngIp[dwPngIp-1] = StringToIpAddress(pTemp);

        pTemp = wcstok(NULL, L","); 
        dwLenCount+=sizeof(WCHAR);
    }


    //Now parse the data
    {
        LPWSTR      pwszTemp = NULL;
        DWORD dwLen = wcslen(ppwcArguments[dwCurrentIndex]);
        
        if( ppwcArguments[dwCurrentIndex][0] isnot L'{' or
            ppwcArguments[dwCurrentIndex][dwLen-1] isnot L'}' )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        if( dwLen < 7 )
        {
            BYTE    rgbByte[] = {0x00, 0x00, 0x00, 0x00};
            
            Status = RegSetValueEx(hPartner,
                                   fGrata ? PGSERVER : PNGSERVER,
                                   0,
                                   REG_MULTI_SZ,
                                   rgbByte,
                                   sizeof(rgbByte));

            if( Status isnot NO_ERROR )
                goto ErrorReturn;

            fAtleastone = TRUE;

            DisplayMessage(g_hModule,
                           EMSG_WINS_ERROR_SUCCESS);
            goto CommonReturn;

        }

        pwszTemp = WinsAllocateMemory((dwLen-1)*sizeof(WCHAR));

        if( pwszTemp is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        wcsncpy(pwszTemp, ppwcArguments[dwCurrentIndex]+1, dwLen-1);
        pwszTemp[dwLen-2] = L'\0';
        
        pTemp = wcstok(pwszTemp, L",");
        
        dwCount = 0;

        while(pTemp isnot NULL )
        {
            DWORD   dw = StringToIpAddress(pTemp);
            BOOL fPresent = TRUE;
            if( dw is INADDR_NONE )
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_INVALID_IPADDRESS,
                               pTemp);
            }
            else
            {
                for( i=0; i<dwPngIp; i++ )
                {

                    if( dw is pdwPngIp[i] )
                    {
                        LPDWORD pdwTemp = pdwPngIp;
            
                        pdwPngIp = WinsAllocateMemory((dwPngIp-1)*sizeof(DWORD));

                        if( pdwPngIp is NULL )
                        {
                            WinsFreeMemory(pdwTemp);
                            pdwTemp = NULL;
                            WinsFreeMemory(pwszTemp);
                            pwszTemp = NULL;
                            Status = ERROR_NOT_ENOUGH_MEMORY;
                            goto ErrorReturn;
                        }
                        fAtleastone = TRUE;
                        memcpy(pdwPngIp, pdwTemp, i*sizeof(DWORD));
                        for( j=i+1; j<dwPngIp; j++ )
                        {
                            pdwPngIp[j-1] = pdwTemp[j];
                        }
                        dwPngIp--;                    
                        break;
                    }
                    else
                        continue;
                }
            }
            
            pTemp = wcstok(NULL, L",");
        }
        
        dwTemp += 0;

        pbValue = WinsAllocateMemory((dwPngIp*(MAX_IP_STRING_LEN+1)+1)*sizeof(WCHAR));
        if( pbValue is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
                    
        pTemp = (LPWSTR)pbValue;

        for( i=0; i<dwPngIp; i++ )
        {
            LPWSTR  pwIp = NULL;

            pwIp = IpAddressToString(pdwPngIp[i]);
            if( pwIp is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            wcscpy(pTemp+dwTemp, pwIp);
            dwTemp+=wcslen(pwIp);
            dwTemp++;
            WinsFreeMemory(pwIp);
            pwIp = NULL;
        }

        pTemp[dwTemp++] = L'\0';
        
    }
    
    Status = RegSetValueEx(hPartner,
                           fGrata ? PGSERVER : PNGSERVER,
                           0,
                           REG_MULTI_SZ,
                           pbValue,
                           dwTemp*sizeof(WCHAR));

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    if( fAtleastone is FALSE )
    {
        DisplayMessage(g_hModule,
                            fGrata ? EMSG_SRVR_ATLEAST_ONE_PG : EMSG_SRVR_ATLEAST_ONE_PNG);
    }
    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);

CommonReturn:

    if( pbData )
    {
        WinsFreeMemory(pbData);
        pbData = NULL;
    }

    if( pbValue )
    {
        WinsFreeMemory(pbValue);
        pbValue = NULL;
    }

    if( pdwPngIp )
    {
        WinsFreeMemory(pdwPngIp);
        pdwPngIp = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( hPartner )
    {
        RegCloseKey(hPartner);
        hPartner = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(fGrata ? EMSG_SRVR_DELETE_PGSERVER : EMSG_SRVR_DELETE_PNGSERVER,
                        Status);
    goto CommonReturn;
    
}


DWORD
HandleSrvrInitBackup(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Initiates a backup operation of WINS Server database.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Optional : Backup directory. If none is specified, it will assume the 
                   the default directory.             
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwNumTags = NULL, pdwTypeTags = NULL;
    LPSTR       pszBackupPath = NULL;
    LPWSTR      pwszTemp = NULL;
    BOOL        fIncremental = FALSE;
    LPBYTE      lpStr = NULL;
    TAG_TYPE    pttTags[] = { {WINS_TOKEN_DIR, FALSE, FALSE},
                              {WINS_TOKEN_TYPE, FALSE, FALSE},
                            };
    
       
    if( dwArgCount > dwCurrentIndex )
    {
        dwNumArgs = dwArgCount - dwCurrentIndex;

        pdwNumTags = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

        if( pdwNumTags is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        pdwTypeTags = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

        if( pdwTypeTags is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

        Status = PreProcessCommand(ppwcArguments,
                                   dwArgCount,
                                   dwCurrentIndex,
                                   pttTags,
                                   &dwTagCount,
                                   pdwTypeTags,
                                   pdwNumTags);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
        {
            if( pttTags[i].dwRequired is TRUE and
                pttTags[i].bPresent is FALSE 
              )
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }

        i = dwTagCount;

        for( j = 0; j < i ; j++ )
        {
            switch(pdwTypeTags[j])
            {
            case 0:
                {
                    pszBackupPath = WinsUnicodeToOem(ppwcArguments[dwCurrentIndex+pdwNumTags[j]], NULL);

                    if( pszBackupPath is NULL )
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }
                    break;
                }
            case 1:
                {
                    DWORD dwType = 0;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwNumTags[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }                    
                    dwType = STRTOUL(ppwcArguments[dwCurrentIndex+pdwNumTags[j]], NULL, 0);
                    if( dwType is 0 )
                        fIncremental = FALSE;
                    else if( dwType is 1 )
                        fIncremental = TRUE;
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }

                    break;
                }
            default:
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
            }
        }
    }
    if( pszBackupPath is NULL ) //Look for the previously set backup path from Registry
    {
        HKEY    hServer = NULL,
                hParameter = NULL;
        WCHAR   wcTempSrc[1024] = {L'\0'},
                wcTempDst[1024] = {L'\0'};
        LPSTR   pszTempPath = NULL;
        DWORD   dwType = REG_EXPAND_SZ,
                dwTempLen = 1024*sizeof(WCHAR);

        if( wcslen(g_ServerNetBiosName) > 0 )
            pwszTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pwszTemp,
                                    HKEY_LOCAL_MACHINE,
                                    &hServer);
        if( Status isnot NO_ERROR )
        {
            goto ErrorReturn;
        }

        Status = RegOpenKeyEx(hServer,
                              PARAMETER,
                              0,
                              KEY_ALL_ACCESS,
                              &hParameter);

        if( Status isnot NO_ERROR )
        {
            RegCloseKey(hServer);
            hServer = NULL;
            goto ErrorReturn;
        }

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_BACKUP_DIR_PATH_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)wcTempSrc,
                                 &dwTempLen);

        RegCloseKey(hParameter);
        hParameter = NULL;
        RegCloseKey(hServer);
        hServer = NULL;

        if( Status is ERROR_FILE_NOT_FOUND or
            wcslen(wcTempSrc) is 0 )
        {
            DisplayMessage(g_hModule,
                           EMSG_SRVR_NOBACKUP_PATH);
            Status = ERROR_INVALID_PARAMETER;
            goto CommonReturn;
        }
        if( Status isnot NO_ERROR )
        {
            goto ErrorReturn;
        }

        dwTempLen =  ExpandEnvironmentStrings(wcTempSrc,
                                              wcTempDst,
                                              1024);

        if( dwTempLen is 0 )
        {
            goto ErrorReturn;
        }

        pszTempPath = WinsUnicodeToOem(wcTempDst, NULL);
        
        if( pszTempPath is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        
        dwTempLen = MAX(dwTempLen, strlen(pszTempPath));

        pszBackupPath = WinsAllocateMemory(dwTempLen+1);

        if( pszBackupPath is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        strcpy(pszBackupPath, pszTempPath);

        WinsFreeMemory(pszTempPath);
        pszTempPath = NULL;
    }
    
    if( pszBackupPath[strlen(pszBackupPath) - 1] is '\\' )
    {
        pszBackupPath[strlen(pszBackupPath) - 1] = '\0';
    } 
    Status = WinsBackup(g_hBind,
                       (LPBYTE)pszBackupPath,
                       (short)fIncremental);
 

    if( Status isnot NO_ERROR )
        goto ErrorReturn;
                                
CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    
    if( pdwTypeTags )
    {
        WinsFreeMemory(pdwTypeTags);
        pdwTypeTags = NULL;
    }
    if( pdwNumTags )
    {
        WinsFreeMemory(pdwNumTags);
        pdwNumTags = NULL;
    }
    if( pszBackupPath )
    {
        WinsFreeMemory(pszBackupPath);
        pszBackupPath = NULL;
    }
   
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_INIT_BACKUP,
                        Status);
    goto CommonReturn;   
}



DWORD
HandleSrvrInitImport(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Initiates import of records from LMHOSTS file.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Lmhosts file name.             
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_FILE, TRUE, FALSE},
                            };
    
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;
    LPWSTR      pwszFileName = NULL;
    WCHAR       wcTemp[2042] = {L'\0'};    

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_INIT_IMPORT_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                DWORD dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                pwszFileName = WinsAllocateMemory((dwLen+1)*sizeof(WCHAR));
                if( pwszFileName is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                wcscpy(pwszFileName, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
	if( pwszFileName )
    {
        //
        // If this is a local connection, we copy the file to
        // temporary name (the source may be on a remote drive
        // which is not accessible to the WINS service.
        //
        // If this is not a local connection, attempt to copy
        // the file to a temp name on C$ of the WINS server
        //

    	do
        {
            if (IsLocalServer())
            {
                wcscpy(wcTemp ,_wtempnam(NULL, L"WINS"));
                //
                // First copy file to a temporary name (since the file
                // could be remote), and then import and delete this file
                //
                if (!CopyFile(pwszFileName, wcTemp, TRUE))
                {
                    Status = GetLastError();
                    break;
                }
                //
                // Now import the temporary file, and delete the file
                // afterwards.
                //
                Status = ImportStaticMappingsFile(wcTemp, TRUE);
                DeleteFile(wcTemp);
            }
            else
            {
                //
                // Try copying to the remote machine C: drive
                //
                wcscat(wcTemp, L"\\\\");
                wcscat(wcTemp, g_ServerNameUnicode);
                wcscat(wcTemp, L"\\");
                wcscat(wcTemp, L"C$");
                wcscat(wcTemp, L"\\");
                wcscat(wcTemp, L"WINS");
                j = wcslen(wcTemp);

                i=0;
                while (TRUE)
                {
                    WCHAR Buffer[10] = {L'\0'};
                    DWORD  dwErr = 0;
                    _itow(i, Buffer, 10);
		            wcscat(wcTemp,Buffer);

                    if (GetFileAttributes(wcTemp) == -1)
                    {
                        dwErr = GetLastError();
                        if (dwErr is ERROR_FILE_NOT_FOUND)
                        {
			            	break;
                        }
                    }
                    wcTemp[j] = L'\0';
                    i++;                        
                }
    
                //
                // First copy file to a temporary name (since the file
                // could be remote), and then import and delete this file
                //
                if (!CopyFile(pwszFileName, wcTemp, TRUE))
                {
                    Status = GetLastError();
                    break;
                }

                //
                // Now import the temporary file, and delete the file
                // afterwards.
                //
                Status = ImportStaticMappingsFile(wcTemp, TRUE);
                DeleteFile(wcTemp);
            }
        }while(FALSE);

        if (Status isnot NO_ERROR )
        {
            goto ErrorReturn;
        }

	}

CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( pwszFileName )
    {
        WinsFreeMemory(pwszFileName);
        pwszFileName = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;

ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_INIT_IMPORT,
                        Status);
    goto CommonReturn;
}

DWORD
HandleSrvrInitPull(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Initiates and send pull trigger to the specified pull partner.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Server Ip Address
               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    WINSINTF_ADD_T  WinsAdd;
    DWORD       i, j, dwNumArgs, dwTagCount = 0;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_SERVER, TRUE, FALSE},
                            };
    LPWSTR      pwszTemp = NULL;

    if( dwArgCount < dwCurrentIndex+1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_INIT_PULL_EX);
        Status = ERROR_INVALID_PARAMETER;                     
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if(pdwTagType is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    if(pdwTagType is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }


    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    i = dwTagCount;

    for( j=0; j<i; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                WinsAdd.Len = 4;
                WinsAdd.Type = 0;
                
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                if( IsIpAddress(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) )
                {
                    WinsAdd.IPAdd = StringToIpAddress(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    break;
                }
                else //Server UNC name
                {
                    struct  hostent * lpHostEnt = NULL;
                    CHAR    cAddr[16];
                    BYTE    pbAdd[4];
                    char    szAdd[4];
                    int     k = 0, l=0;
                    DWORD   nLen = 0;

                    if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 2 and
                        _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"\\\\", 2) is 0 )
                        k = 2;
                        
                    lpHostEnt = gethostbyname(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k, NULL));
                    if( lpHostEnt is NULL )
                    {
                        DisplayMessage(g_hModule,
                                       EMSG_WINS_INVALID_COMPUTER_NAME,
                                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k);
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;                                       
                    }

                    memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
                    for( l=0;l<4; l++)
                    {
                        _itoa((int)pbAdd[l], szAdd, 10);
                        memcpy(cAddr+nLen, szAdd, strlen(szAdd));
                        nLen += strlen(szAdd);
                        *(cAddr+nLen) = '.';
                        nLen++;
    
                    }
                    *(cAddr+nLen-1) = '\0';
                    WinsAdd.IPAdd = WinsDottedStringToIpAddress(cAddr);
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    for( j=0; j<sizeof(pttTags)/sizeof(TAG_TYPE); j++)
    {
        if( pttTags[j].dwRequired is TRUE &&
            pttTags[j].bPresent is FALSE )
        {
            DisplayMessage(g_hModule,
                           EMSG_WINS_REQUIRED_PARAMETER,
                           j);
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
                           
        }
    }

    Status = WinsTrigger(g_hBind, &WinsAdd, WINSINTF_E_PULL);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;


CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_INIT_PULL,
                        Status);
    goto CommonReturn;

}


DWORD
HandleSrvrInitPullrange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Initiates and pulls a range of database from a particular server.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Pulls a range of database from a particular server owned by
                     a particular server within the given version range.
        Note : If no ip is provided, it deletes all partners in the list.
               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD               Status = NO_ERROR;
    DWORD               i, j, dwTagCount, dwNumArgs;
    TAG_TYPE            pttTags[] = {
                                        {WINS_TOKEN_OWNER, TRUE, FALSE},
                                        {WINS_TOKEN_SERVER, TRUE, FALSE},
                                        {WINS_TOKEN_MAXVER, TRUE, FALSE},
                                        {WINS_TOKEN_MINVER, TRUE, FALSE},
                                    };

    LPDWORD             pdwTagType = NULL,
                        pdwTagNum = NULL;

    WINSINTF_VERS_NO_T  MinVer, MaxVer;
    WINSINTF_ADD_T      PullAdd, OwnerAdd ;

        
    
    if( dwArgCount < dwCurrentIndex + 4 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_INIT_PULLRANGE_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or 
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);


    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( j=0; j<sizeof(pttTags)/sizeof(TAG_TYPE); j++ )
    {
        if( pttTags[j].dwRequired is TRUE and
            pttTags[j].bPresent is FALSE )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                if( IsIpAddress(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                OwnerAdd.IPAdd = StringToIpAddress(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                OwnerAdd.Type = 0;
                OwnerAdd.Len = 4;
                break;
            }
        case 1:
            {
                if( IsIpAddress(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                PullAdd.IPAdd = StringToIpAddress(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                PullAdd.Type = 0;
                PullAdd.Len = 4;
                break;
            }
        case 2:
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &MaxVer);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;    
            }
        case 3:
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &MinVer);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }

    }

    Status = WinsPullRange(g_hBind, &PullAdd, &OwnerAdd, MinVer, MaxVer);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);

CommonReturn:

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_INIT_PULLRANGE,
                        Status);
    goto CommonReturn;
                        
}


DWORD
HandleSrvrInitPush(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Initiate and sends push trigger to a particular Push partner.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Push partner's IP Address
        Optional : If user wants to propagate the push trigger               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    WINSINTF_ADD_T  WinsAdd;
    DWORD       i, j, dwNumArgs, dwTagCount=0;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_SERVER, TRUE, FALSE},
                                {WINS_TOKEN_PROPAGATION, FALSE, FALSE},
                            };
    LPWSTR      pwszTemp = NULL;
    DWORD       dwChoice = WINSINTF_E_PUSH;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_INIT_PUSH_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if(pdwTagType is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    if(pdwTagType is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }


    i = dwTagCount;

    for( j=0; j<i; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                WinsAdd.Len = 4;
                WinsAdd.Type = 0;

                if( IsIpAddress(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) )
                {
                    WinsAdd.IPAdd = StringToIpAddress(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                }
                else //Server UNC name
                {
                    struct  hostent * lpHostEnt = NULL;
                    CHAR    cAddr[16];
                    BYTE    pbAdd[4];
                    char    szAdd[4];
                    int     k = 0, l=0;
                    DWORD   nLen = 0;

                    if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 2 and
                        _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"\\\\", 2) is 0 )
                        k = 2;
                    
                    lpHostEnt = gethostbyname(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k, NULL));
                    if( lpHostEnt is NULL )
                    {
                        DisplayMessage(g_hModule,
                                       EMSG_WINS_INVALID_COMPUTER_NAME,
                                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k);
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;                                       
                    }

                    memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
                    for( l=0;l<4; l++)
                    {
                        _itoa((int)pbAdd[l], szAdd, 10);
                        memcpy(cAddr+nLen, szAdd, strlen(szAdd));
                        nLen += strlen(szAdd);
                        *(cAddr+nLen) = '.';
                        nLen++;
    
                    }
                    *(cAddr+nLen-1) = '\0';
                    WinsAdd.IPAdd = WinsDottedStringToIpAddress(cAddr);
                }
                break;
            }
        case 1:
            {
                DWORD dwVal = 0;
                if( ( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE ) or
                    ( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 1 ) )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                
                if( ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0] is L'1' )
                    dwChoice = WINSINTF_E_PUSH_PROP;
                else if( ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0] is L'0' )
                    dwChoice = WINSINTF_E_PUSH;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                break;

            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    for( j=0; j<sizeof(pttTags)/sizeof(TAG_TYPE); j++)
    {
        if( pttTags[j].dwRequired is TRUE &&
            pttTags[j].bPresent is FALSE )
        {
            DisplayMessage(g_hModule,
                           EMSG_WINS_REQUIRED_PARAMETER,
                           j);
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
                           
        }
    }

    Status = WinsTrigger(g_hBind, &WinsAdd, dwChoice);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;


CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_INIT_PUSH,
                        Status);
    goto CommonReturn;

}


DWORD
HandleSrvrInitReplicate(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Initiates a database replication with the partners
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    
    HKEY        hServer = NULL,
                hPullRoot = NULL,
                hPushRoot = NULL;
    DWORD       dw = 0,
                dwKeyLen = MAX_IP_STRING_LEN+1,
                dwPullKeys = 0,                
                dwPushKeys = 0;

    WCHAR       wcIpAddress[MAX_IP_STRING_LEN+1] = {L'\0'};
    LPWSTR      pTemp = NULL;

    WINSINTF_ADD_T  WinsAdd;

    if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp,
                                HKEY_LOCAL_MACHINE,
                                &hServer);

    if( Status isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    Status = RegOpenKeyEx(hServer,
                          PULLROOT,
                          0,
                          KEY_ALL_ACCESS,
                          &hPullRoot);


    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegQueryInfoKey(hPullRoot,
                             NULL,
                             NULL,
                             NULL,
                             &dwPullKeys,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    
    Status = RegOpenKeyEx(hServer,
                          PUSHROOT,
                          0,
                          KEY_ALL_ACCESS,
                          &hPushRoot);


    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegQueryInfoKey(hPushRoot,
                             NULL,
                             NULL,
                             NULL,
                             &dwPushKeys,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule, MSG_WINS_TIME_WARNING);

    WinsAdd.Len = 4;
    WinsAdd.Type = 0;

    if( dwPullKeys is 0 )
    {
        DisplayMessage(g_hModule, EMSG_WINS_NO_PULLPARTNER);
    }

    if( dwPushKeys is 0 )
    {
        DisplayMessage(g_hModule, EMSG_WINS_NO_PUSHPARTNER);
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);

    for( dw=0; dw<dwPullKeys; dw++ )
    {
        dwKeyLen = MAX_IP_STRING_LEN+1;
        
        Status = RegEnumKeyEx(hPullRoot,
                              dw,
                              wcIpAddress,
                              &dwKeyLen,
                              NULL,
                              NULL,
                              NULL,
                              NULL);
        if( Status isnot NO_ERROR )
            continue;

        WinsAdd.IPAdd = StringToIpAddress(wcIpAddress);

        DisplayMessage(g_hModule, MSG_WINS_SEND_PULL, wcIpAddress);
        Status = WinsTrigger(g_hBind, &WinsAdd, WINSINTF_E_PULL);
        if( Status isnot NO_ERROR )
        {
            DisplayMessage(g_hModule, EMSG_WINS_PULL_FAILED);           
        }
        else
        {
            DisplayMessage(g_hModule, MSG_WINS_TRIGGER_DONE);
        }

    }

    WinsAdd.Len = 4;
    WinsAdd.Type = 0;

    for( dw=0; dw<dwPushKeys; dw++ )
    {
        dwKeyLen = MAX_IP_STRING_LEN+1;

        Status = RegEnumKeyEx(hPushRoot,
                              dw,
                              wcIpAddress,
                              &dwKeyLen,
                              NULL,
                              NULL,
                              NULL,
                              NULL);
        if( Status isnot NO_ERROR )
            continue;

        WinsAdd.IPAdd = StringToIpAddress(wcIpAddress);

        DisplayMessage(g_hModule, MSG_WINS_SEND_PUSH, wcIpAddress);
        Status = WinsTrigger(g_hBind, &WinsAdd, WINSINTF_E_PUSH_PROP);

        if( Status isnot NO_ERROR )
        {
            DisplayMessage(g_hModule, EMSG_WINS_PUSH_FAILED);
        }
        else
        {
            DisplayMessage(g_hModule, MSG_WINS_TRIGGER_DONE);
        }
    }
    
    
    if( Status isnot NO_ERROR )
        goto CommonReturn;

    DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
CommonReturn:
    
    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( hPullRoot )
    {
        RegCloseKey(hPullRoot);
        hPullRoot = NULL;
    }

    if( hPushRoot )
    {
        RegCloseKey(hPushRoot);
        hPushRoot = NULL;
    }

    return Status;

ErrorReturn:
    if( Status is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_NO_PARTNER);
    }
    else
    {
        DisplayErrorMessage(EMSG_SRVR_INIT_REPLICATE,
                            Status);
    }
    goto CommonReturn;

}

DWORD
HandleSrvrInitRestore(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Initiates and restore database 
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Directory to do restore from              
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR,
                Status1 = NO_ERROR,
                i, j, dwNumArgs, dwTagCount=0;
    PDWORD      pdwNumTags = NULL, pdwTypeTags = NULL;
    TAG_TYPE    pttTags[] = { {WINS_TOKEN_DIR, TRUE, FALSE},
                              {WINS_TOKEN_VERSION, FALSE, FALSE},
                            };
    CHAR        szRestorePath[MAX_PATH+1] = {'\0'};
    LPWSTR      pwszTemp = NULL;
    DWORD       dwService = NO_ERROR;
    DbVersion   eVersion = 3;
    BOOL        fBackupOnTerm = FALSE;

    handle_t                wbdhBind = g_hBind;
  	WINSINTF_BIND_DATA_T    wbdBindData = g_BindData;
    DWORD                   dwError = NO_ERROR;
    
    
    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_INIT_RESTORE_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( IsLocalServer() is FALSE )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_LOCAL_SERVER,
                       g_ServerIpAddressUnicodeString);
        return ERROR_INVALID_PARAMETER;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwNumTags = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwNumTags is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    pdwTypeTags = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTypeTags is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

        dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTypeTags,
                               pdwNumTags);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    i = dwTagCount;

    for( j = 0; j < i ; j++ )
    {
        switch(pdwTypeTags[j])
        {
        case 0:
            {
                DWORD   dw = 0;
                LPSTR   pszTempPath = NULL;
                pszTempPath = WinsUnicodeToOem(ppwcArguments[dwCurrentIndex+pdwNumTags[j]], NULL);

                if( pszTempPath is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                
                dw = strlen(pszTempPath);

                if( dw < 2 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    WinsFreeMemory( pszTempPath );
                    pszTempPath = NULL;
                    goto ErrorReturn;
                }

                strncpy(szRestorePath, 
                        pszTempPath,
                        ( dw > MAX_PATH - 1 ) ? MAX_PATH - 1 : dw );

                WinsFreeMemory(pszTempPath);
                pszTempPath = NULL;

                break;
            }
        case 1:
            {
                DWORD eVer = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwNumTags[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                eVer = STRTOUL(ppwcArguments[dwCurrentIndex+pdwNumTags[j]], NULL, 0);
                if( eVer > DbVersionMin && eVer < DbVersionMax )
                    eVersion = eVer;
                else
                {
                    Status = ERROR_INVALID_DB_VERSION;
                    goto ErrorReturn;
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
    
    //To restore the database, first stop WINS Service, Cleanup earlier dabase
    //do DB restore and then restart WINS

    
    {
       

        //Unbind WINS

        WinsUnbind(&g_BindData, g_hBind);
        g_hBind = NULL;
        
        //Reset Backup on Termination flag
        {
            HKEY hServer = NULL,
                 hParameter = NULL;

            LPWSTR  pTemp = NULL;
            
            DWORD   dwSize = sizeof(DWORD);
            DWORD   dwType = REG_DWORD;
            DWORD   dwData = 0;

            if( wcslen(g_ServerNetBiosName) > 0 )
                pTemp = g_ServerNetBiosName;
            
            Status = RegConnectRegistry(pTemp,
                                        HKEY_LOCAL_MACHINE,
                                        &hServer);
            if( Status isnot NO_ERROR )
                goto EXIT;

            Status = RegOpenKeyEx(hServer,
                                  PARAMETER,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hParameter);

            if( Status isnot NO_ERROR )
                goto EXIT;
            
            Status = RegQueryValueEx(hParameter,
                                     WINSCNF_DO_BACKUP_ON_TERM_NM,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwSize);

            if( Status is NO_ERROR )
            {
                if( dwData is 1 )
                {
                    DWORD dw = 0;
                    Status = RegSetValueEx(hParameter,
                                           WINSCNF_DO_BACKUP_ON_TERM_NM,
                                           0,
                                           REG_DWORD,
                                           (LPBYTE)&dw,
                                           sizeof(DWORD));
                    
                    if( Status is NO_ERROR )
                        fBackupOnTerm = TRUE;

                }
                else
                {
                    fBackupOnTerm = FALSE;
                }
            }

EXIT:
            if( Status isnot NO_ERROR )
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_RESTORE_IMPROPER);
            }

            if( hServer )
            {
                RegCloseKey(hServer);
                hServer = NULL;
            }

            if( hParameter )
            {
                RegCloseKey(hParameter);
                hParameter = NULL;
            }

            Status = NO_ERROR;
        }

        //Stop WINS Service
        Status = ControlWINSService(TRUE);

        if( Status isnot NO_ERROR )
        {
            if( Status isnot ERROR_SERVICE_NOT_ACTIVE )
            {
                g_BindData = wbdBindData;
                g_hBind = WinsBind(&g_BindData);
                goto ErrorReturn;
            }
            else
            {
                dwService = ERROR_SERVICE_NOT_ACTIVE;
                Status = NO_ERROR;
            }

        }

       //Now try restoring the database      
        Status1 = WinsRestore((LPBYTE)szRestorePath);

        if( Status1 isnot NO_ERROR )
        {
            DisplayErrorMessage(EMSG_SRVR_INIT_RESTORE,
                                Status1);
        }

        if( dwService isnot ERROR_SERVICE_NOT_ACTIVE )
            Status = ControlWINSService(FALSE);
    }

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    if( Status1 isnot NO_ERROR )
    {
        Status = Status1;
        goto ErrorReturn;
    }

    DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

CommonReturn:
    
    g_BindData = wbdBindData;
    g_hBind = WinsBind(&g_BindData);
     
    //Reset the DoBackUpOnTerm value
    if( fBackupOnTerm is TRUE )
    {
        HKEY    hServer = NULL,
                hParameter = NULL;
        LPWSTR  pTemp = NULL;
        DWORD   dwErr = NO_ERROR;
        if( wcslen(g_ServerNetBiosName) > 0 )
        {
            pTemp = g_ServerNetBiosName;
        }
        
        dwErr = RegConnectRegistry(pTemp,
                                   HKEY_LOCAL_MACHINE,
                                   &hServer);
        if( dwErr isnot NO_ERROR )
        {
            DisplayErrorMessage(EMSG_WINS_REGCONNECT_FAILED,
                                dwErr);
        }
        else
        {
            dwErr = RegOpenKeyEx(hServer,
                                 PARAMETER,
                                 0,
                                 KEY_ALL_ACCESS,
                                 &hParameter);
            if( dwErr isnot NO_ERROR )
            {
                RegCloseKey(hServer);
                hServer = NULL;
                DisplayErrorMessage(EMSG_WINS_REGOPEN_FAILED,
                                    dwErr);
            }
            else
            {
                DWORD dw = 1;
                dwErr = RegSetValueEx(hParameter,
                                      WINSCNF_DO_BACKUP_ON_TERM_NM,
                                      0,
                                      REG_DWORD,
                                      (LPBYTE)&dw,
                                      sizeof(DWORD));
                if( dwErr isnot NO_ERROR )
                {
                    DisplayErrorMessage(EMSG_WINS_REGSETVAL_FAILED,
                                        dwErr);
                }

                RegCloseKey(hParameter);
                hParameter = NULL;
                RegCloseKey(hServer);
                hServer = NULL;
            }
        }
        
    }
    if( pdwTypeTags )
    {
        WinsFreeMemory(pdwTypeTags);
        pdwTypeTags = NULL;
    }
    if( pdwNumTags )
    {
        WinsFreeMemory(pdwNumTags);
        pdwNumTags = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_INIT_RESTORE,
                        Status);
    goto CommonReturn;   
}


DWORD
HandleSrvrInitScavenge(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Initiates scavenging of database for the server
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD           Status = NO_ERROR;
    struct in_addr            InAddr;
    BOOL            fIpAddress = TRUE;
    DWORD           j = 0;

    WCHAR       wcName[256] = {L'\0'};
    DWORD       dwLen = 0;

    WINSINTF_ADD_T            WinsAdd;
    WINSINTF_RESULTS_T        Results;    
    WINSINTF_VERS_NO_T        MaxVer, MinVer;
    WINSINTF_RECS_T           Recs;
    PWINSINTF_RECORD_ACTION_T pRow =  NULL;

    Status = WinsDoScavenging( g_hBind );
    
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_ERROR_SUCCESS);
    }

    else
    {
        DisplayErrorMessage(EMSG_SRVR_INIT_SCAVENGE,
                            Status);
    }

    return Status;
}

DWORD
HandleSrvrInitSearch(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Search WINS database based on Name, 16th char, case and optionally stores the result to a file,
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Name to search for
        Optional : 16th char, case sensitive or not and if the result to be stored in a file, then the file
                   Name.               
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, k, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[]={
                              {WINS_TOKEN_NAME, TRUE, FALSE},
                              {WINS_TOKEN_ENDCHAR, FALSE, FALSE},
                              {WINS_TOKEN_CASE, FALSE, FALSE},
                              {WINS_TOKEN_FILE, FALSE, FALSE},
                          };
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;
    CHAR        chEndChar = (CHAR)0x00;
    BOOL        fEndChar = FALSE;
    WCHAR       wcName[256+1] = {L'\0'};
    WCHAR       wcFile[MAX_PATH] = {L'\0'};
    BOOL        fFile = FALSE;
    DWORD       dwLen = 0;
    BOOL        fIpAddress = TRUE;
    BOOL        fMatch = FALSE;
    BOOL        fCase = FALSE;
    BOOL        fNew = TRUE;
    struct in_addr            InAddr;
    LPSTR       pszName = NULL;


    WINSINTF_ADD_T            WinsAdd;
    WINSINTF_RESULTS_T        Results = {0};
    WINSINTF_RESULTS_NEW_T    ResultsN = {0};
    WINSINTF_VERS_NO_T        MaxVer, MinVer;
    WINSINTF_RECS_T           Recs;
    PWINSINTF_RECORD_ACTION_T pRow =  NULL;

    
    i = j = k = dwNumArgs = dwTagCount = 0;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_INIT_SEARCH_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    
    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);
    
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++)
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                DWORD dwLen = 0;
                
                dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                dwLen = ( 255 < dwLen ) ? 255 : dwLen;
                memcpy(wcName, 
                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 
                       dwLen*sizeof(WCHAR));
                wcName[dwLen] = L'\0';
                fIpAddress = FALSE;
                break;
            }
        case 1:
            {
                DWORD dwLen = 0, k=0;
                fEndChar = TRUE;
                dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen > 2 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                        
                }
                
                for( k=0; k<dwLen; k++ )
                {
                    WCHAR  wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][k];
                    if( towlower(wc) >= L'a' and
                        towlower(wc) <= L'z' )
                    {
                        if( towlower(wc) > L'f' )
                        {
                            Status = ERROR_INVALID_PARAMETER;
                            goto ErrorReturn;
                        }
                    
                    }
                }
                chEndChar = StringToHexA(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                break;
            }
        case 2:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 10);
                
                if( dw is 0 )
                {
                    fCase = FALSE;
                    break;
                }
                if( dw is 1 )
                {
                    fCase = TRUE;
                    break;
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                

            }
        case 3:
            {
                DWORD   dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen is 0 )
                {
                    wcscpy(wcFile, L"wins.rec");
                    fFile = TRUE;
                    break;
                }
                wcscpy(wcFile, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                fFile = TRUE;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
       
    pszName = WinsUnicodeToOem(wcName, NULL);

    if( pszName is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwLen = strlen(pszName);
    
    if( dwLen >= 16 )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_NETBIOS_NAME);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( fEndChar )
    {
        LPSTR pTemp = pszName;
        pszName = WinsAllocateMemory(17);
        if( pszName is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        memcpy(pszName, pTemp, 15);
        for( i=strlen(pszName); i<16; i++ )
        {
            pszName[i] = ' ';
        }
        pszName[15] = chEndChar;
        pszName[16] = '\0';
        WinsFreeMemory(pTemp);
        pTemp = NULL;
        dwLen = 16;
    }


    ResultsN.WinsStat.NoOfPnrs = 0;
    ResultsN.WinsStat.pRplPnrs = 0;
    ResultsN.NoOfWorkerThds = 1;
    ResultsN.pAddVersMaps = NULL;


    Status = WinsStatusNew(g_hBind, WINSINTF_E_CONFIG_ALL_MAPS, &ResultsN);
    
    if( Status is RPC_S_PROCNUM_OUT_OF_RANGE )
    {
        //Try old API
        Results.WinsStat.NoOfPnrs = 0;
        Results.WinsStat.pRplPnrs = 0;
        Status = WinsStatus(g_hBind, WINSINTF_E_CONFIG_ALL_MAPS, &Results);
        fNew = FALSE;
    }
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    g_dwSearchCount = 0;
    g_fHeader = FALSE;

    if( fNew is FALSE )
    {
        if( Results.NoOfOwners is 0 )
            goto CommonReturn;

        for( j=0; j<Results.NoOfOwners; j++)
        {
            WinsAdd.Len = 4;
            WinsAdd.Type = 0;
            WinsAdd.IPAdd = Results.AddVersMaps[j].Add.IPAdd;

            if( WinsAdd.IPAdd is 0 )
                continue;
            DisplayMessage(g_hModule,
                           MSG_WINS_SEARCHING_STATUS,
                           IpAddressToString(Results.AddVersMaps[j].Add.IPAdd));

            InAddr.s_addr = htonl(Results.AddVersMaps[j].Add.IPAdd);
            
            MaxVer = Results.AddVersMaps[j].VersNo;
            MinVer.HighPart = 0;
            MinVer.LowPart = 0;
            Status = GetDbRecs(MinVer,
                               MaxVer,
                               &WinsAdd,
                               inet_ntoa(InAddr),
                               fIpAddress ? FALSE : TRUE,
                               pszName, 
                               dwLen,
                               FALSE,
                               0,
                               FALSE,
                               fCase,
                               fFile,
                               fFile ? wcFile : NULL);
            if(Status isnot NO_ERROR )
            {
                if( Results.WinsStat.pRplPnrs)
                {
                    WinsFreeMem(Results.WinsStat.pRplPnrs);
                    Results.WinsStat.pRplPnrs = NULL;
                }
                goto ErrorReturn;
            }
        }
        if( Results.WinsStat.pRplPnrs)
        {
            WinsFreeMem(Results.WinsStat.pRplPnrs);
            Results.WinsStat.pRplPnrs = NULL;
        }
        if( Status isnot NO_ERROR )
            goto ErrorReturn;
    }
    else
    {
        if( ResultsN.NoOfOwners is 0 )
            goto CommonReturn;
        for( j=0; j<ResultsN.NoOfOwners; j++)
        {

            WinsAdd.Len = 4;
            WinsAdd.Type = 0;
            WinsAdd.IPAdd = ResultsN.pAddVersMaps[j].Add.IPAdd;

            if( WinsAdd.IPAdd is 0 )
                continue;

            DisplayMessage(g_hModule,
                           MSG_WINS_SEARCHING_STATUS,
                           IpAddressToString(ResultsN.pAddVersMaps[j].Add.IPAdd));

            InAddr.s_addr = htonl(ResultsN.pAddVersMaps[j].Add.IPAdd);
            MaxVer = ResultsN.pAddVersMaps[j].VersNo;
            MinVer.HighPart = 0;
            MinVer.LowPart = 0;
            Status = GetDbRecs(MinVer,
                               MaxVer,
                               &WinsAdd,
                               inet_ntoa(InAddr),
                               fIpAddress ? FALSE : TRUE,
                               pszName, 
                               dwLen,
                               FALSE,
                               0,
                               FALSE,
                               fCase,
                               fFile,
                               fFile ? wcFile : NULL);

            if(Status isnot NO_ERROR )
            {
                if( ResultsN.WinsStat.pRplPnrs)
                {
                    WinsFreeMem(ResultsN.WinsStat.pRplPnrs);
                    ResultsN.WinsStat.pRplPnrs = NULL;
                }
                goto ErrorReturn;
            }
        }
        if( ResultsN.WinsStat.pRplPnrs)
        {
            WinsFreeMem(ResultsN.WinsStat.pRplPnrs);
            ResultsN.WinsStat.pRplPnrs = NULL;
        }
        if( Status isnot NO_ERROR )
            goto ErrorReturn;
    }

    if( pszName )
    {
        WinsFreeMemory(pszName);
        pszName = NULL;
    }    

    DisplayMessage(g_hModule,
                   MSG_SRVR_SEARCH_COUNT,
                   g_dwSearchCount);

    if( fFile )
    {
        FILE * pFile = _wfopen(wcFile, L"a+");

        if( pFile isnot NULL )
        {
            DumpMessage(g_hModule,
                        pFile,
                        MSG_SRVR_SEARCH_COUNT,
                        g_dwSearchCount);

            fclose(pFile);
            pFile = NULL;
        }
    }

CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( pszName )
    {
        WinsFreeMemory(pszName);
        pszName = NULL;
    }
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    
    g_dwSearchCount = 0;
    g_fHeader = FALSE;

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_INIT_SEARCH,
                        Status);
    goto CommonReturn;   
}

DWORD
HandleSrvrResetCounter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Resets the version counter
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD Status = NO_ERROR;

    Status = WinsResetCounters( g_hBind );
    
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_ERROR_SUCCESS);
    }

    else
    {
        DisplayErrorMessage(EMSG_SRVR_INIT_BACKUP,
                            Status);
    }
    return Status;
}

DWORD
HandleSrvrSetAutopartnerconfig(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Sets automatic partner configuration parameters.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : State to set or disable
        Optional : Time Interval or TTL value
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;
    LPWSTR      pTemp = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                                {WINS_TOKEN_INTERVAL, FALSE, FALSE},
                                {WINS_TOKEN_TTL, FALSE, FALSE},
                            };
    DWORD       dwInterval = WINSCNF_DEF_MCAST_INTVL;
    DWORD       dwTTL = WINSCNF_DEF_MCAST_TTL;
    BOOL        fState = FALSE,
                fTTL   = FALSE,
                fInterval = FALSE;

    HKEY        hServer = NULL,
                hParameter = NULL;
                


    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_AUTOPARTNERCONFIG_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    {
        dwNumArgs = dwArgCount - dwCurrentIndex;

        pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
        pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

        if( pdwTagType is NULL or
            pdwTagNum is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

        Status = PreProcessCommand(ppwcArguments,
                                   dwArgCount,
                                   dwCurrentIndex,
                                   pttTags,
                                   &dwTagCount,
                                   pdwTagType,
                                   pdwTagNum);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
        {
            if( pttTags[i].dwRequired is TRUE and
                pttTags[i].bPresent is FALSE 
              )
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }

        for( j=0; j<dwTagCount; j++ )
        {
            switch(pdwTagType[j])
            {
            case 0:
                {
                    WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                    if( wc is L'1' )
                    {
                        fState = TRUE;                  
                    }
                    else if( wc is L'0' )
                    {
                        fState = FALSE;
                    }
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    break;
                }
            case 1:
                {
                    DWORD dw = 0;
                    fInterval = TRUE;
                    if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                        break;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);

                    if( dw >= ONEDAY )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    dwInterval = dw;
                    break;

                }
            case 2:
                {
                    DWORD dw = 0;
                    fTTL = TRUE;    
                    if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                        break;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                    if( dw > 32 )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    if( dw <= 0 )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    dwTTL = dw;
                    break;
                }
            default:
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
            }
        }
    }
    {
        if( wcslen(g_ServerNetBiosName) > 0 )
        {
            pTemp = g_ServerNetBiosName;
        }
        
        Status = RegConnectRegistry(pTemp,
                                    HKEY_LOCAL_MACHINE,
                                    &hServer);
        
        if( Status isnot NO_ERROR )
            goto ErrorReturn;
        
        Status = RegOpenKeyEx(hServer,
                              PARAMETER,
                              0,
                              KEY_ALL_ACCESS,
                              &hParameter);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
        
        Status = RegSetValueEx(hParameter,
                               WINSCNF_USE_SELF_FND_PNRS_NM,
                               0,
                               REG_DWORD,
                               (LPBYTE)&fState,
                               sizeof(BOOL));
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        if( fInterval )
        {
            Status = RegSetValueEx(hParameter,
                                   WINSCNF_MCAST_INTVL_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwInterval,
                                   sizeof(DWORD));

            if( Status isnot NO_ERROR )
                goto ErrorReturn;
        }

        if( fTTL )
        {
            Status = RegSetValueEx(hParameter,
                                   WINSCNF_MCAST_TTL_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwTTL,
                                   sizeof(DWORD));
            if( Status isnot NO_ERROR )
                goto ErrorReturn;
        }
                                      
    }
CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_AUTOPARTNERCONFIG,
                        Status);
    goto CommonReturn;   
   
}


DWORD
HandleSrvrSetBackuppath(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Sets the backup path for the WINS database
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Backup dir
        Optional : Enable backup at server shutdown.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_DIR, FALSE, FALSE},
                                {WINS_TOKEN_ATSHUTDOWN, FALSE, FALSE},
                            };

    LPWSTR      pwszDir = L"C:\\\\";
    BOOL        fDir = FALSE;
    BOOL        fAtShutDown = FALSE;
    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hParameter = NULL;
    

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_BACKUPPATH_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 0 )
                {
                    pwszDir = ppwcArguments[dwCurrentIndex+pdwTagNum[j]];
                }
                else
                {
                    pwszDir = L"";
                }

                fDir = TRUE;

                break;
            }
        case 1:
            {
                WCHAR   wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) isnot 1 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                
                if( wc is L'0' )
                    fAtShutDown = FALSE;
                else if( wc is L'1' )
                    fAtShutDown = TRUE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }

        }
    }

    if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegCreateKeyEx(hServer,
                            PARAMETER,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hParameter,
                            NULL);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    if( fDir )
    {
       
        Status = RegSetValueEx(hParameter,
                               WINSCNF_BACKUP_DIR_PATH_NM,
                               0,
                               REG_EXPAND_SZ,
                               (LPBYTE)pwszDir,
                               (wcslen(pwszDir)+1)*sizeof(WCHAR));

        if( Status isnot NO_ERROR )
        {
            goto ErrorReturn;
        }
    }
    
    Status = RegSetValueEx(hParameter,
                           WINSCNF_DO_BACKUP_ON_TERM_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&fAtShutDown,
                           sizeof(BOOL));
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    
CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_BACKUPPATH,
                        Status);
    goto CommonReturn;   


}


DWORD
HandleSrvrSetDefaultparam(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Sets the default values for all the configuration parameter. This command
        must be run at least once before running the dump command.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD           Status = NO_ERROR;
    HKEY            hServer = NULL,
                    hWins = NULL,
                    hParameter = NULL,
                    hDefault = NULL,
                    hDefaultPull = NULL,
                    hDefaultPush = NULL,
                    hPartner = NULL,
                    hCheck = NULL,
                    hPullPart = NULL,
                    hPushPart = NULL;
    DWORD           dwSize = 0,
                    dwType = 0,
                    dwData = 0;
    LPWSTR          pTemp = NULL;

    if( wcslen(g_ServerNetBiosName) > 2 )
        pTemp = g_ServerNetBiosName;

    Status = RegConnectRegistry(pTemp,
                                HKEY_LOCAL_MACHINE,
                                &hServer);

    if( Status isnot NO_ERROR )
    {
        goto RETURN;
    }


    //Open all required Registry key handles
    Status = RegCreateKeyEx(hServer,
                            PARAMETER,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hParameter,
                            NULL);

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegCreateKeyEx(hServer,
                            PARTNERROOT,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hPartner,
                            NULL);

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegCreateKeyEx(hServer,
                            PULLROOT,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hPullPart,
                            NULL);

    if( Status isnot NO_ERROR )
        goto RETURN;



    Status = RegCreateKeyEx(hServer,
                            PUSHROOT,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hPushPart,
                            NULL);

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegCreateKeyEx(hServer,
                            DEFAULTPULL,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hDefaultPull,
                            NULL);

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegCreateKeyEx(hServer,
                            DEFAULTPUSH,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hDefaultPush,
                            NULL);

    if( Status isnot NO_ERROR )
        goto RETURN;

    //Start setting the default values.

    Status = RegSetValueEx(hParameter,
                           WINSCNF_BACKUP_DIR_PATH_NM,
                           0,
                           REG_EXPAND_SZ,
                           (LPBYTE)L"",
                           (wcslen(L"")+1)*sizeof(WCHAR));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_DO_BACKUP_ON_TERM_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x7e900;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_REFRESH_INTVL_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));
    
    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x54600;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_TOMBSTONE_INTVL_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x7e900;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_TOMBSTONE_TMOUT_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x1fa400;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_VERIFY_INTVL_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));
    
    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 1;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_BURST_HANDLING_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x1f4;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_BURST_QUE_SIZE_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_LOG_DETAILED_EVTS_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 1;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_LOG_FLAG_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_LOG_FILE_PATH_NM,
                           0,
                           REG_EXPAND_SZ,
                           (LPBYTE)L"%windir%\\system32\\wins",
                           (wcslen(L"%windir%\\system32\\wins")+1)*sizeof(WCHAR));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_USE_SELF_FND_PNRS_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_MIGRATION_ON_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x1;
    Status = RegSetValueEx(hParameter,
                           WINSCNF_RPL_ONLY_W_CNF_PNRS_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;
    
    Status = RegSetValueEx(hParameter,
                           WINSCNF_DB_FILE_NM,
                           0,
                           REG_EXPAND_SZ,
                           (LPBYTE)L"%windir%\\system32\\wins\\wins.mdb",
                           (wcslen(L"%windir%\\system32\\wins\\wins.mdb")+1)*sizeof(WCHAR));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 2;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_MCAST_TTL_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x960;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_MCAST_INTVL_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_INIT_VERSNO_VAL_HW_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_INIT_VERSNO_VAL_LW_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x708;

    Status = RegSetValueEx(hDefaultPull,
                           WINSCNF_RPL_INTERVAL_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0;
    Status = RegSetValueEx(hDefaultPush,
                           WINSCNF_UPDATE_COUNT_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x3;

    Status = RegSetValueEx(hPullPart,
                           WINSCNF_RETRY_COUNT_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x1;

    Status = RegSetValueEx(hPullPart,
                           WINSCNF_INIT_TIME_RPL_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;
    
    dwData = 0x1;

    Status = RegSetValueEx(hPullPart,
                           WINSCNF_PRS_CONN_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x0;

    Status = RegSetValueEx(hPushPart,
                           WINSCNF_INIT_TIME_RPL_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;
    
    dwData = 0x1;

    Status = RegSetValueEx(hPushPart,
                           WINSCNF_PRS_CONN_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    dwData = 0x0;

    Status = RegSetValueEx(hPushPart,
                           WINSCNF_ADDCHG_TRIGGER_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto RETURN;

    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);
RETURN:                   

    if( Status isnot NO_ERROR )
        DisplayErrorMessage(EMSG_SRVR_SET_DEFAULTPARAM,
                            Status);
    if( hPushPart )
    {
        RegCloseKey(hPushPart);
        hPushPart = NULL;
    }

    if( hPullPart )
    {
        RegCloseKey(hPullPart);
        hPullPart = NULL;
    }

    if( hPartner )
    {
        RegCloseKey(hPartner);
        hPartner = NULL;
    }

    if( hCheck )
    {
        RegCloseKey(hCheck);
        hCheck = NULL;
    }

    if( hDefaultPull )
    {
        RegCloseKey(hDefaultPull);
        hDefaultPull = NULL;
    }

    if( hDefaultPush )
    {
        RegCloseKey(hDefaultPush);
        hDefaultPush = NULL;
    }

    if( hDefault )
    {
        RegCloseKey(hDefault);
        hDefault = NULL;
    }

    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( hWins )
    {
        RegCloseKey(hWins);
        hWins = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }    

    return Status;
}   



DWORD
HandleSrvrSetMigrateflag(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the migrate on/off flag
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Set or disable
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                            };

    BOOL        fMigrate = FALSE;
    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hParameter = NULL;
    

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_MIGRATEFLAG_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE or
                    wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                if( dw is 1 )
                    fMigrate = TRUE;
                else if( dw is 0 )
                    fMigrate = FALSE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    {
        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
        
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegCreateKeyEx(hServer,
                                PARAMETER,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hParameter,
                                NULL);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegSetValueEx(hParameter,
                               WINSCNF_MIGRATION_ON_NM,
                               0,
                               REG_DWORD,
                               (LPBYTE)&fMigrate,
                               sizeof(BOOL));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
    }


CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_MIGRATEFLAG,
                        Status);
    goto CommonReturn;   

}


DWORD
HandleSrvrSetNamerecord(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the name record parameters for the server.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Optional : Renew, extinction interval, extinction timeout and verification values.
        Note : All parameters are optional.                 
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_RENEW, FALSE, FALSE},
                                {WINS_TOKEN_EXTINCTION, FALSE, FALSE},
                                {WINS_TOKEN_EXTIMEOUT, FALSE, FALSE},
                                {WINS_TOKEN_VERIFICATION, FALSE, FALSE},
                            };

    DWORD       dwRenew = SIX_DAYS,
                dwExtinction = SIX_DAYS,
                dwExTimeOut = SIX_DAYS,
                dwVerify = WINSCNF_MIN_VERIFY_INTERVAL;

    BOOL        fRenew = FALSE,
                fExtinction = FALSE,
                fExTimeOut = FALSE,
                fVerify = FALSE;

    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hParameter = NULL;
    
    
    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
        return NO_ERROR;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                {
                    dwRenew = SIX_DAYS;
                }
                else
                {
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 10);
                    dwRenew = dw;
                }
                fRenew = TRUE;            
                break;
            }
        case 1:
            {   
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                {
                    dwExtinction = SIX_DAYS;
                }
                else
                {
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                    dwExtinction = dw;
                }
                fExtinction = TRUE;
                break;
            }
        case 2:
            {

                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                {
                    dwExTimeOut = SIX_DAYS;
                }
                else
                {
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                    dwExTimeOut = dw;
                }
                fExTimeOut = TRUE;
                break;
            }
        case 3:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                {
                    dwVerify = WINSCNF_MIN_VERIFY_INTERVAL;
                }
                else
                {
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                    dwVerify = dw;
                }
                fVerify = TRUE;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    {
        DWORD dwValue = 0,
              dwType = REG_DWORD,
              dwSize = sizeof(DWORD);
                
        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
        
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegCreateKeyEx(hServer,
                                PARAMETER,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hParameter,
                                NULL);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        //First retrieve the older values for all the parameters
        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_REFRESH_INTVL_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwValue,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            if( fRenew is FALSE )
            {
                dwRenew = dwValue;
            }
        }
            
        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_TOMBSTONE_INTVL_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwValue,
                                 &dwSize);
        if( Status is NO_ERROR )
        {
            if( fExtinction is FALSE )
                dwExtinction = dwValue;
        }

        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_TOMBSTONE_TMOUT_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwValue,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            if( fExTimeOut is FALSE )
                dwExTimeOut = dwValue;
        }

        dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hParameter,
                                 WINSCNF_VERIFY_INTVL_NM,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)&dwValue,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            if( fVerify is FALSE )
                dwVerify = dwValue;
        }

        //Check the validity and range of values
        {
            if( dwRenew < WINSCNF_MIN_REFRESH_INTERVAL )
            {
                DisplayMessage(g_hModule,
                               EMSG_SRVR_RENEW_INTERVAL);
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;                                           
            }
            if( dwRenew > ONE_YEAR )
            {
                dwRenew = ONE_YEAR;
            }

            if( dwExTimeOut < WINSCNF_MIN_TOMBSTONE_TIMEOUT )
            {
                DisplayMessage(g_hModule,
                               EMSG_SRVR_TOMBSTONE_TIMEOUT,
                               WINSCNF_MIN_TOMBSTONE_TIMEOUT);
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            if( dwExTimeOut > ONE_YEAR )
            {
                dwExTimeOut = ONE_YEAR;
            }

            if( dwExTimeOut < dwRenew )
            {
                DisplayMessage(g_hModule,
                               EMSG_SRVR_TOMBSTONE_TIMEOUT,
                               dwRenew);
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }

            if( dwExtinction < WINSCNF_MAKE_TOMB_INTVL_0_M(dwRenew) )
            {
                DisplayMessage(g_hModule,
                               EMSG_SRVR_TOMBSTONE_INTERVAL,
                               WINSCNF_MAKE_TOMB_INTVL_0_M(dwRenew) );
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }

            if( dwVerify < WINSCNF_MAKE_VERIFY_INTVL_M(dwExtinction) )
            {
                if( WINSCNF_MAKE_VERIFY_INTVL_M(dwExtinction) == TWENTY_FOUR_DAYS )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_SRVR_VERIFY_INTERVAL,
                                   TOMB_MULTIPLIER_FOR_VERIFY,
                                   WINSCNF_MAKE_VERIFY_INTVL_M(dwExtinction));
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

            }
        }


        Status = RegSetValueEx(hParameter,
                               WINSCNF_REFRESH_INTVL_NM,
                               0,
                               REG_DWORD,
                               (LPBYTE)&dwRenew,
                               sizeof(DWORD));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegSetValueEx(hParameter,
                               WINSCNF_TOMBSTONE_INTVL_NM,
                               0,
                               REG_DWORD,
                               (LPBYTE)&dwExtinction,
                               sizeof(DWORD));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegSetValueEx(hParameter,
                               WINSCNF_TOMBSTONE_TMOUT_NM,
                               0,
                               REG_DWORD,
                               (LPBYTE)&dwExTimeOut,
                               sizeof(DWORD));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegSetValueEx(hParameter,
                               WINSCNF_VERIFY_INTVL_NM,
                               0,
                               REG_DWORD,
                               (LPBYTE)&dwVerify,
                               sizeof(DWORD));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

    }

    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }
CommonReturn:


    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_NAMERECORD,
                        Status);
    goto CommonReturn;   
    
}

DWORD
HandleSrvrSetPeriodicdbchecking(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the periodic database checking parameters for the server
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : State
        Optional : Maximum record count, and other parameters.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                                {WINS_TOKEN_MAXRECORDCOUNT, FALSE, FALSE},
                                {WINS_TOKEN_CHECKAGAINST, FALSE, FALSE},
                                {WINS_TOKEN_CHECKEVERY, FALSE, FALSE},
                                {WINS_TOKEN_START, FALSE, FALSE},
                            };

    DWORD       dwMaxRec = WINSCNF_CC_DEF_RECS_AAT,
                dwEvery = WINSCNF_CC_DEF_INTERVAL,
                dwStart = WINSCNF_DEF_CC_SP_HR*60*60;

    BOOL        fPartner = WINSCNF_CC_DEF_USE_RPL_PNRS,
                fIsPartner = FALSE,
                fMax = FALSE,
                fEvery = FALSE,
                fStart = FALSE,
                fState = TRUE;


    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hCCRoot = NULL;
    

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_PERIODICDBCHECKING_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                
                if( dw is 0 )
                    fState = FALSE;
                else
                    fState = TRUE;
                break;
            }
        case 1:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                dwMaxRec = dw;
                fMax = TRUE;
                break;
            }
        case 2:
            {   
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                if( dw is 1 )
                    fPartner = TRUE;
                else
                    fPartner = FALSE;
                fIsPartner = TRUE;
                break;
            }
        case 3:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                dwEvery = dw*60*60;                   
                fEvery = TRUE;
                break;
            }
        case 4:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                dwStart = dw;
                fStart = TRUE;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    if( fState is FALSE )
    {
        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
       
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        RegDeleteKey(hServer, CCROOT);
    }
    else
    {
        if( fMax is TRUE or
            fEvery is TRUE or
            fIsPartner is TRUE or
            fStart is TRUE )
        {
            if( wcslen(g_ServerNetBiosName) > 0 )
                pTemp = g_ServerNetBiosName;

            Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
        
            if( Status isnot NO_ERROR )
                goto ErrorReturn;

            Status = RegCreateKeyEx(hServer,
                                    CCROOT,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hCCRoot,
                                    NULL);

            if( Status isnot NO_ERROR )
                goto ErrorReturn;


            if( fMax )
            {
                Status = RegSetValueEx(hCCRoot,
                                       WINSCNF_CC_MAX_RECS_AAT_NM,
                                       0,
                                       REG_DWORD,
                                       (LPBYTE)&dwMaxRec,
                                       sizeof(DWORD));

                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
            }

            if( fIsPartner )
            {
                Status = RegSetValueEx(hCCRoot,
                                       WINSCNF_CC_USE_RPL_PNRS_NM,
                                       0,
                                       REG_DWORD,
                                       (LPBYTE)&fPartner,
                                       sizeof(BOOL));

                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
            }
        
            if( fEvery )
            {
                Status = RegSetValueEx(hCCRoot,
                                       WINSCNF_CC_INTVL_NM,
                                       0,
                                       REG_DWORD,
                                       (LPBYTE)&dwEvery,
                                       sizeof(DWORD));

                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
            }

            if( fStart )
            {
                LPWSTR pwszTime = MakeTimeString(dwStart);
                if( pwszTime is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                Status = RegSetValueEx(hCCRoot,
                                       WINSCNF_SP_TIME_NM,
                                       0,
                                       REG_SZ,
                                       (LPBYTE)pwszTime,
                                       (wcslen(pwszTime)+1)*sizeof(WCHAR));

                WinsFreeMemory(pwszTime);
                pwszTime = NULL;
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
            }

        }
    }

CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hCCRoot )
    {
        RegCloseKey(hCCRoot);
        hCCRoot = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_PERIODICDBCHECKING,
                        Status);
    if( hServer )
    {
        if( hCCRoot )
        {
            RegCloseKey(hCCRoot);
            hCCRoot = NULL;
        }
        RegDeleteKey(hServer, CCROOT);
    }
    goto CommonReturn;   
}


DWORD
HandleSrvrSetPullpersistentconnection(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the pull partner configuration parameters
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Server IP and persistence state
        Optional : Start value and Time interval
        Note : All parameters are optional.                 
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                                {WINS_TOKEN_SERVER, TRUE, FALSE},
                                {WINS_TOKEN_START, FALSE, FALSE},
                                {WINS_TOKEN_INTERVAL, FALSE, FALSE},
                            };

    DWORD       dwStart = 0,
                dwInterval = 1800; 

    WCHAR       wcServerIpAdd[MAX_IP_STRING_LEN + 1] = {L'\0'};

    BOOL        fState = TRUE,
                fStart = FALSE,
                fInterval = FALSE;

    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hPullRoot = NULL,
                hPullServer = NULL;
    

    if( dwArgCount < dwCurrentIndex + 2 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_PULLPERSISTENTCONNECTION_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wc is L'0' )
                    fState = FALSE;
                else if ( wc is L'1' )
                    fState = TRUE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        case 1:
            {
                struct  hostent * lpHostEnt = NULL;
                CHAR    cAddr[16];
                BYTE    pbAdd[4];
                char    szAdd[4];
                int     k = 0, l=0;
                DWORD   dwLen, nLen = 0;

                if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) )
                {
                    DWORD dwIp = inet_addr(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL));
                    lpHostEnt = gethostbyaddr((char *)&dwIp, 4, AF_INET);
                    if(lpHostEnt isnot NULL )//Valid IP Address
                    {
                        wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                        break;
                    }
                    else
                    {
                        Status = ERROR_INVALID_IPADDRESS;
                        goto ErrorReturn;
                    }
                }

                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 2 and
                    _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"\\\\", 2) is 0 )
                    k = 2;

                lpHostEnt = gethostbyname(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k, NULL));
                if( lpHostEnt is NULL )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_WINS_INVALID_COMPUTER_NAME,
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k);
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;                                       
                }

                memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
                for( l=0; l<4; l++)
                {
                    _itoa((int)pbAdd[l], szAdd, 10);
                    memcpy(cAddr+nLen, szAdd, strlen(szAdd));
                    nLen += strlen(szAdd);
                    *(cAddr+nLen) = '.';
                    nLen++;

                }
                *(cAddr+nLen-1) = '\0';
                WinsAnsiToUnicode(cAddr, wcServerIpAdd);
                break;            }
        case 2:
            {   
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                dwStart = dw;
                fStart = TRUE;
                break;
            }
        case 3:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                dwInterval = dw;
                fInterval = TRUE;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    {
        DWORD   dwDisposition = 0;
        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegOpenKeyEx(hServer,
                              PULLROOT,
                              0,
                              KEY_ALL_ACCESS,
                              &hPullRoot);


        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegOpenKeyEx(hPullRoot,
                              wcServerIpAdd,
                              0,
                              KEY_ALL_ACCESS,
                              &hPullServer);

        if( Status is ERROR_FILE_NOT_FOUND )
        {
            DisplayMessage(g_hModule,
                           EMSG_SRVR_INVALID_PARTNER,
                           wcServerIpAdd);
            goto CommonReturn;
        }
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegSetValueEx(hPullServer,
                               PERSISTENCE,
                               0,
                               REG_DWORD,
                               (LPBYTE)&fState,
                               sizeof(BOOL));
        
        if( Status isnot NO_ERROR )
        {
            goto ErrorReturn;
        }
     
        if( fInterval )
        {
            Status = RegSetValueEx(hPullServer,
                                   WINSCNF_RPL_INTERVAL_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwInterval,
                                   sizeof(DWORD));

            if( Status isnot NO_ERROR )
            {
                goto ErrorReturn;
            }
        }
        if( fStart )
        {
            LPWSTR pwszTime = MakeTimeString(dwStart);
            if( pwszTime is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            Status = RegSetValueEx(hPullServer,
                                   WINSCNF_SP_TIME_NM,
                                   0,
                                   REG_SZ,
                                   (LPBYTE)pwszTime,
                                   (wcslen(pwszTime)+1)*sizeof(WCHAR));

            WinsFreeMemory(pwszTime);
            pwszTime = NULL;
            if( Status isnot NO_ERROR )
            {
                goto ErrorReturn;
            }
        }

    }
    
CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hPullServer )
    {
        RegCloseKey(hPullServer);
        hPullServer = NULL;
    }

    if( hPullRoot )
    {
        RegCloseKey(hPullRoot);
        hPullRoot = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_PULLPERSISTENTCONNECTION,
                        Status);
    goto CommonReturn;   
}

DWORD
HandleSrvrSetPushpersistentconnection(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the push partner configuration parameters
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Server IP and persistence state
        Optional : Update count
        Note : All parameters are optional.                 
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                                {WINS_TOKEN_SERVER, TRUE, FALSE},
                                {WINS_TOKEN_UPDATE,FALSE, FALSE},
                            };

    DWORD       dwUpdate = 0;

    WCHAR       wcServerIpAdd[MAX_IP_STRING_LEN + 1] = {L'\0'};

    BOOL        fState = TRUE,
                fUpdate = FALSE;

    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hPushRoot = NULL,
                hPushServer = NULL;
    

    if( dwArgCount < dwCurrentIndex + 2 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_PUSHPERSISTENTCONNECTION_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wc is L'0' )
                    fState = FALSE;
                else if ( wc is L'1' )
                    fState = TRUE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        case 1:
            {
                struct  hostent * lpHostEnt = NULL;
                CHAR    cAddr[16];
                BYTE    pbAdd[4];
                char    szAdd[4];
                int     k = 0, l=0;
                DWORD   dwLen, nLen = 0;

                if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) )
                {
                    DWORD dwIp = inet_addr(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL));
                    lpHostEnt = gethostbyaddr((char *)&dwIp, 4, AF_INET);
                    if(lpHostEnt isnot NULL )//Valid IP Address
                    {
                        wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                        break;
                    }
                    else
                    {
                        Status = ERROR_INVALID_IPADDRESS;
                        goto ErrorReturn;
                    }
                }

                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 2 and
                    _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"\\\\", 2) is 0 )
                    k = 2;

                lpHostEnt = gethostbyname(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k, NULL));
                if( lpHostEnt is NULL )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_WINS_INVALID_COMPUTER_NAME,
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k);
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;                                       
                }

                memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
                for( l=0;l<4; l++)
                {
                    _itoa((int)pbAdd[l], szAdd, 10);
                    memcpy(cAddr+nLen, szAdd, strlen(szAdd));
                    nLen += strlen(szAdd);
                    *(cAddr+nLen) = '.';
                    nLen++;

                }
                *(cAddr+nLen-1) = '\0';
                WinsAnsiToUnicode(cAddr, wcServerIpAdd);
                break;            
            }
        case 2:
            {   
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                dwUpdate = dw;
                fUpdate = TRUE;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    {
        DWORD   dwDisposition = 0;
        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegOpenKeyEx(hServer,
                              PUSHROOT,
                              0,
                              KEY_ALL_ACCESS,
                              &hPushRoot);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        
        Status = RegOpenKeyEx(hPushRoot,
                              wcServerIpAdd,
                              0,
                              KEY_ALL_ACCESS,
                              &hPushServer);

        if( Status is ERROR_FILE_NOT_FOUND )
        {
            DisplayMessage(g_hModule,
                           EMSG_SRVR_INVALID_PARTNER,
                           wcServerIpAdd);
            goto CommonReturn;
        }

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegSetValueEx(hPushServer,
                               PERSISTENCE,
                               0,
                               REG_DWORD,
                               (LPBYTE)&fState,
                               sizeof(BOOL));
        
        if( Status isnot NO_ERROR )
        {
            goto ErrorReturn;
        }
     
        if( fUpdate )
        {
            Status = RegSetValueEx(hPushServer,
                                   WINSCNF_UPDATE_COUNT_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwUpdate,
                                   sizeof(DWORD));

            if( Status isnot NO_ERROR )
            {
                goto ErrorReturn;
            }
        }
    }
    
CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hPushServer )
    {
        RegCloseKey(hPushServer);
        hPushServer = NULL;
    }

    if( hPushRoot )
    {
        RegCloseKey(hPushRoot);
        hPushRoot = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_PUSHPERSISTENTCONNECTION,
                        Status);
    goto CommonReturn;   
}


DWORD
HandleSrvrSetPullparam(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the default pull parameters
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : persistence state
        Optional : Startup value, Start time and Time interval and retry count
        Note : All parameters are optional.                 
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                                {WINS_TOKEN_STARTUP, FALSE, FALSE},
                                {WINS_TOKEN_START, FALSE, FALSE},
                                {WINS_TOKEN_INTERVAL, FALSE, FALSE},
                                {WINS_TOKEN_RETRY, FALSE, FALSE},
                            };

    DWORD       dwStart = 0,
                dwInterval = 1800,
                dwRetry = 3;

    BOOL        fStart = FALSE,
                fStartup = FALSE,
                fInterval = FALSE,
                fRetry = FALSE,
                fState = TRUE;


    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hDefault = NULL,
                hPullRoot = NULL;
    

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_PULLPARAM_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wc is L'0' )
                    fState = FALSE;
                else if ( wc is L'1' )
                    fState = TRUE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        case 1:
            {
                WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wc is L'1' )
                {
                    fStartup = TRUE;
                }
                else if ( wc is L'0' )
                {
                    fStartup = FALSE;
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        case 2:
            {   
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                dwStart = dw;
                fStart = TRUE;
                break;
            }
        case 3:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                
                

                if( dw > 0 && 
                    dw < 60 )   // 1 minute
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dwInterval = dw;
                fInterval = TRUE;
                break;
            }
        case 4:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                dwRetry = dw;
                fRetry = TRUE;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
    {
        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegCreateKeyEx(hServer,
                                PULLROOT,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hPullRoot,
                                NULL);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;


    
        Status = RegSetValueEx(hPullRoot,
                               PERSISTENCE,
                               0,
                               REG_DWORD,
                               (LPBYTE)&fState,
                               sizeof(BOOL));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
    

        Status = RegSetValueEx(hPullRoot,
                               WINSCNF_INIT_TIME_RPL_NM,
                               0,
                               REG_DWORD,
                               (LPBYTE)&fStartup,
                               sizeof(BOOL));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        if( fRetry )
        {
            Status = RegSetValueEx(hPullRoot,
                                   WINSCNF_RETRY_COUNT_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwRetry,
                                   sizeof(DWORD));
            if( Status isnot NO_ERROR )
                goto ErrorReturn;
        }

        if( fStart is TRUE or
            fInterval is TRUE )
        {
            Status = RegCreateKeyEx(hServer,
                                    DEFAULTPULL,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hDefault,
                                    NULL);

            if( Status isnot NO_ERROR )
                goto ErrorReturn;

            if( fStart )
            {
                LPWSTR pwszTime = MakeTimeString(dwStart);
                if( pwszTime is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                Status = RegSetValueEx(hDefault,
                                       WINSCNF_SP_TIME_NM,
                                       0,
                                       REG_SZ,
                                       (LPBYTE)pwszTime,
                                       (wcslen(pwszTime)+1)*sizeof(WCHAR));
                
                WinsFreeMemory(pwszTime);
                pwszTime = NULL;
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
            }

            if( fInterval )
            {
                Status = RegSetValueEx(hDefault,
                                       WINSCNF_RPL_INTERVAL_NM,
                                       0,
                                       REG_DWORD,
                                       (LPBYTE)&dwInterval,
                                       sizeof(DWORD));
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
            }
        } 
    }

CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hPullRoot )
    {
        RegCloseKey(hPullRoot);
        hPullRoot = NULL;
    }

    if( hDefault )
    {
        RegCloseKey(hDefault);
        hDefault = NULL;
    }
    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_PULLPARAM,
                        Status);
    goto CommonReturn;   
}

DWORD
HandleSrvrSetPushparam(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the default push parameters
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Server IP and persistence state
        Optional : Start value and Time interval
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                                {WINS_TOKEN_STARTUP, FALSE, FALSE},
                                {WINS_TOKEN_ADDRESSCHANGE, FALSE, FALSE},
                                {WINS_TOKEN_UPDATE, FALSE, FALSE},
                            };

    DWORD       dwUpdate = 3;

    BOOL        fStartup = FALSE,
                IsStartup = FALSE,
                fAddressChange = FALSE,
                IsAddChange = FALSE,
                fAdd = FALSE,
                IsAdd = FALSE,
                fUpdate = FALSE,
                IsUpdate = FALSE,
                fState = TRUE;


    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hDefault = NULL,
                hPushRoot = NULL;
    

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_PUSHPARAM_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wc is L'0' )
                    fState = FALSE;
                else if ( wc is L'1' )
                    fState = TRUE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        case 1:
            {
                WCHAR wc ;
                IsStartup = TRUE;
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                    break;
                wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wc is L'1' )
                {
                    fStartup = TRUE;
                }
                else if( wc is L'0' )
                    fStartup = 0;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        case 2:
            {   
                WCHAR wc ;
                IsAddChange = TRUE;
                fAdd = TRUE;
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) < 1 )
                    break;
                wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wc is L'1' )
                    fAddressChange = TRUE;
                else if( wc is L'0' )
                    fAddressChange = FALSE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
     
                break;
            }
        case 3:
            {
                DWORD dw = 0;
                IsUpdate = TRUE;
                fUpdate = TRUE;  
                if( wcslen( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) < 1 )
                    break;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                if( dw < 1000 )
                    dwUpdate = dw;
                else
                    dwUpdate = 999;

                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
    {
        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegCreateKeyEx(hServer,
                                PUSHROOT,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hPushRoot,
                                NULL);
                        

        if( Status isnot NO_ERROR )
            goto ErrorReturn;


    
        Status = RegSetValueEx(hPushRoot,
                               PERSISTENCE,
                               0,
                               REG_DWORD,
                               (LPBYTE)&fState,
                               sizeof(BOOL));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
    

        if( IsStartup )
        {
            Status = RegSetValueEx(hPushRoot,
                                   WINSCNF_INIT_TIME_RPL_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&fStartup,
                                   sizeof(BOOL));

            if( Status isnot NO_ERROR )
                goto ErrorReturn;
        }

        if( fAdd )
        {
            Status = RegSetValueEx(hPushRoot,
                                   WINSCNF_ADDCHG_TRIGGER_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&fAddressChange,
                                   sizeof(DWORD));
        
            if( Status isnot NO_ERROR )
                goto ErrorReturn;
        }

       
        if( fUpdate is TRUE )
        {
            Status = RegCreateKeyEx(hServer,
                                    DEFAULTPUSH,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hDefault,
                                    NULL);

            if( Status isnot NO_ERROR )
                goto ErrorReturn;

            Status = RegSetValueEx(hDefault,
                                   WINSCNF_UPDATE_COUNT_NM,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE)&dwUpdate,
                                   sizeof(DWORD));

            if( Status isnot NO_ERROR )
                goto ErrorReturn;
        }
    }

CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hPushRoot )
    {
        RegCloseKey(hPushRoot);
        hPushRoot = NULL;
    }

    if( hDefault )
    {
        RegCloseKey(hDefault);
        hDefault = NULL;
    }
    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_PUSHPARAM,
                        Status);
    goto CommonReturn;   
}


DWORD
HandleSrvrSetReplicateflag(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the replication flag
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Flag state
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                            };

    BOOL        fReplicate = FALSE;
    LPWSTR      pTemp = NULL;
    HKEY        hServer = NULL,
                hParameter = NULL;
    

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_REPLICATEFLAG_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                DWORD dw = 0;
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }                
                dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 0);
                if( dw is 1 )
                    fReplicate = TRUE;
                else if( dw is 0 )
                    fReplicate = FALSE;
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    {
        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
        
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        Status = RegCreateKeyEx(hServer,
                                PARAMETER,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hParameter,
                                NULL);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
    
        Status = RegSetValueEx(hParameter,
                               WINSCNF_RPL_ONLY_W_CNF_PNRS_NM,
                               0,
                               REG_DWORD,
                               (LPBYTE)&fReplicate,
                               sizeof(BOOL));

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
    }


CommonReturn:
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }

    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_REPLICATEFLAG,
                        Status);
    goto CommonReturn;   
}


DWORD
HandleSrvrSetLogparam(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the logging parameters
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Optional : Log database change and detail event log options
        Note : All parameters are optional.                 
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_DBCHANGE, FALSE, FALSE},
                                {WINS_TOKEN_EVENT, FALSE, FALSE},
                            };
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    BOOL        fDbChange = FALSE,
                IsDbChange = FALSE,
                fEvent = FALSE,
                IsEvent = FALSE;


    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_ERROR_SUCCESS);
        goto CommonReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];

                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is 0 )
                {
                    fDbChange = FALSE;
                    IsDbChange = TRUE;
                    break;
                }
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) isnot 1 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                if( wc is L'0' )
                {
                    fDbChange = FALSE;
                }
                else if( wc is L'1' )
                {
                     fDbChange = TRUE;
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                IsDbChange = TRUE;
                break;

            }
        case 1:
            {
                WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is 0 )
                {
                    fEvent = FALSE;
                    IsEvent = TRUE;
                    break;
                }

                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) isnot 1 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                if( wc is L'0' )
                {
                    fEvent = FALSE;
                }
                else if( wc is L'1' )
                {
                     fEvent = TRUE;
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

                IsEvent = TRUE;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    {
        HKEY    hServer = NULL,
                hParameter = NULL;
        LPWSTR  pTemp = NULL;
        DWORD   dwType = REG_DWORD,
                dwSize = sizeof(BOOL);

        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp,
                                    HKEY_LOCAL_MACHINE,
                                    &hServer);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
        
        Status = RegOpenKeyEx(hServer,
                              PARAMETER,
                              0,
                              KEY_ALL_ACCESS,
                              &hParameter);

        if( Status isnot NO_ERROR )
        {
            RegCloseKey(hServer);
            hServer = NULL;
            goto ErrorReturn;
        }
        
        if( IsDbChange )
        {
            Status = RegSetValueEx(hParameter,
                                   WINSCNF_LOG_FLAG_NM,
                                   0,
                                   dwType,
                                   (LPBYTE)&fDbChange,
                                   dwSize);

            if( Status isnot NO_ERROR )
            {
                RegCloseKey(hServer);
                hServer = NULL;
                RegCloseKey(hParameter);
                hParameter = NULL;
                goto ErrorReturn;                                    
            }
        }

        if( IsEvent )
        {
            Status = RegSetValueEx(hParameter,
                                   WINSCNF_LOG_DETAILED_EVTS_NM,
                                   0,
                                   dwType,
                                   (LPBYTE)&fEvent,
                                   dwSize);

            if( Status isnot NO_ERROR )
            {
                RegCloseKey(hServer);
                hServer = NULL;
                RegCloseKey(hParameter);
                hParameter = NULL;
                goto ErrorReturn;
            }
        }
        
        if( hServer )
        {
            RegCloseKey(hServer);
            hServer = NULL;
        }

        if( hParameter )
        {
            RegCloseKey(hParameter);
            hParameter = NULL;
        }

    }

    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);
CommonReturn:
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_LOGPARAM,
                        Status);
    goto CommonReturn;
}



DWORD
HandleSrvrSetBurstparam(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set the burst handling parameters
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : To enable or disable burst handling
        Optional : Burst handling value.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_STATE, TRUE, FALSE},
                                {WINS_TOKEN_VALUE, FALSE, FALSE},
                            };
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    BOOL        fState = FALSE,
                fValue = FALSE;

    DWORD       dwValue = 0;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_SET_BURSTPARAM_EX);

        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                WCHAR wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is 0 )
                {
                    fState = FALSE;
                    break;
                }
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) isnot 1 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                if( wc is L'0' )
                {
                    fState = FALSE;
                }
                else if( wc is L'1' )
                {
                     fState = TRUE;
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;

            }
        case 1:
            {                
                if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                
                dwValue = wcstoul(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 10);

                if( dwValue < 50 or
                    dwValue > 5000 )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_SRVR_BURST_PARAM_OUTOFRANGE);
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;

                }

                fValue = TRUE;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

    {
        HKEY    hServer = NULL,
                hParameter = NULL;
        LPWSTR  pTemp = NULL;
        DWORD   dwType = REG_DWORD,
                dwSize = sizeof(BOOL);

        if( wcslen(g_ServerNetBiosName) > 0 )
            pTemp = g_ServerNetBiosName;

        Status = RegConnectRegistry(pTemp,
                                    HKEY_LOCAL_MACHINE,
                                    &hServer);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;
        
        Status = RegOpenKeyEx(hServer,
                              PARAMETER,
                              0,
                              KEY_ALL_ACCESS,
                              &hParameter);

        if( Status isnot NO_ERROR )
        {
            RegCloseKey(hServer);
            hServer = NULL;
            goto ErrorReturn;
        }
        
         Status = RegSetValueEx(hParameter,
                               WINSCNF_BURST_HANDLING_NM,
                               0,
                               dwType,
                               (LPBYTE)&fState,
                               dwSize);

        if( Status isnot NO_ERROR )
        {
            RegCloseKey(hServer);
            hServer = NULL;
            RegCloseKey(hParameter);
            hParameter = NULL;
            goto ErrorReturn;                                    
        }

        if( fValue )
        {
            dwSize = sizeof(DWORD);
            Status = RegSetValueEx(hParameter,
                                   WINSCNF_BURST_QUE_SIZE_NM,
                                   0,
                                   dwType,
                                   (LPBYTE)&dwValue,
                                   dwSize);

            if( Status isnot NO_ERROR )
            {
                RegCloseKey(hServer);
                hServer = NULL;
                RegCloseKey(hParameter);
                hParameter = NULL;
                goto ErrorReturn;
            }
        }
        
        if( hServer )
        {
            RegCloseKey(hServer);
            hServer = NULL;
        }

        if( hParameter )
        {
            RegCloseKey(hParameter);
            hParameter = NULL;
        }

    }

    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);
CommonReturn:
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_BURSTPARAM,
                        Status);
    goto CommonReturn;
}


DWORD
HandleSrvrSetStartversion(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set start value of the version counter
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Version counter value in {high,low} format
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD               Status = 0;
    DWORD               i, j, dwTagCount, dwNumArgs;
    TAG_TYPE            pttTags[] = {
                                        {WINS_TOKEN_VERSION, TRUE, FALSE},
                                    };
    WINSINTF_VERS_NO_T  Version={0};
    
    LPWSTR              pServer = NULL;
    PDWORD              pdwTagNum = NULL,
                        pdwTagType = NULL;

    HKEY                hServer = NULL,
                        hParameter = NULL;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_SET_STARTVERSION_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount, 
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[0])
        {
        case 0:
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &Version);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                 break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            
            }
        }
    }   
    
    if( wcslen(g_ServerNetBiosName) > 0 )
        pServer = g_ServerNetBiosName;

    Status = RegConnectRegistry(pServer,
                                HKEY_LOCAL_MACHINE,
                                &hServer);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegOpenKeyEx(hServer,
                          PARAMETER,
                          0,
                          KEY_ALL_ACCESS,
                          &hParameter);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_INIT_VERSNO_VAL_HW_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&Version.HighPart,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegSetValueEx(hParameter,
                           WINSCNF_INIT_VERSNO_VAL_LW_NM,
                           0,
                           REG_DWORD,
                           (LPBYTE)&Version.LowPart,
                           sizeof(DWORD));

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);

CommonReturn:

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_STARTVERSION,
                        Status);
    goto CommonReturn;
}

DWORD
HandleSrvrSetPersMode(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Set Persona Grata/Non-Grata mode
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Grat|Non-Grata
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD     Status = 0;
    DWORD     dwTagCount;
    DWORD     dwPersMode;
    PDWORD    pdwTagNum = NULL;
    PDWORD    pdwTagType = NULL;
    TAG_TYPE  pttTags[] = {{WINS_TOKEN_MODE, TRUE, FALSE},};
    LPWSTR    lpwszMode;
    LPWSTR    pTemp;
    HKEY      hServer, hPartner;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_PGMODE_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    pdwTagType = WinsAllocateMemory((dwArgCount - dwCurrentIndex)*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory((dwArgCount - dwCurrentIndex)*sizeof(DWORD));

    if( pdwTagType is NULL || pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount, 
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    lpwszMode = ppwcArguments[dwCurrentIndex+pdwTagNum[0]];
    if (wcslen(lpwszMode) == 1 &&
        (lpwszMode[0] == L'0' || lpwszMode[0] == L'1'))
    {
        // set the value for 'persona grata mode'
        dwPersMode = lpwszMode[0] == L'0' ? PERSMODE_NON_GRATA : PERSMODE_GRATA;     
    }
    else
    {
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp,
                                HKEY_LOCAL_MACHINE,
                                &hServer);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegOpenKeyEx(hServer,
                          PARTNERROOT,
                          0,
                          KEY_ALL_ACCESS,
                          &hPartner);

    if (Status isnot NO_ERROR)
        goto ErrorReturn;

    Status = RegSetValueExA(
                hPartner,
                WINSCNF_PERSONA_MODE_NM,
                0,
                REG_DWORD,
                (LPVOID)&dwPersMode,
                sizeof(DWORD));

    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);

CommonReturn:
    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( hPartner )
    {
        RegCloseKey(hPartner);
        hPartner = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    return Status;

ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SET_PGMODE, Status);
    goto CommonReturn; 
}


DWORD
HandleSrvrShowDatabase(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays wins database based on (optionally)different filtering conditions
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Server ip whose database to be displayed
        Optional : Different conditions
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD                       Status = NO_ERROR;
    WINSINTF_ADD_T              WinsAdd = {0};
    TAG_TYPE                    pttTags[] = {   {WINS_TOKEN_SERVERS, TRUE, FALSE},
                                                {WINS_TOKEN_RECORDTYPE, FALSE, FALSE},
                                                {WINS_TOKEN_RECCOUNT, FALSE, FALSE},
                                                {WINS_TOKEN_START, FALSE, FALSE},
                                                {WINS_TOKEN_ENDCHAR, FALSE, FALSE},
                                                {WINS_TOKEN_FILE, FALSE, FALSE},
                                            };
    PDWORD                      pdwTagType = NULL,
                                pdwTagNum = NULL,
                                pdwIp = NULL;
    WCHAR                       wcFilter = L'\0';
    CHAR                        chFilter = 0x00;
    WCHAR                       wcServerIpAdd[MAX_IP_STRING_LEN+1]={L'\0'};
    WCHAR                       wcFile[MAX_PATH] = {L'\0'};
    DWORD                       i, j, dwNumArgs, dwTagCount;
    DWORD                       dwStart = WINSINTF_BEGINNING;
    DWORD                       NoOfRecsDesired = (DWORD)~0;
    DWORD                       TypeOfRec,
                                dwIpCount = 0,
                                dwRecCount = 0,
                                dwTotal = 0,
                                dw=0;
    WINSINTF_RECS_T             Recs = {0};
    PWINSINTF_RECORD_ACTION_T   pRow = NULL;
    BOOL                        fFilter = FALSE,
                                fFile = FALSE;
    BOOL                        fAll = FALSE,
                                fHeader = FALSE,
                                fError = FALSE,
                                fOnce = FALSE,
                                fNew = TRUE;
    WINSINTF_RESULTS_T          Results = {0};
    WINSINTF_RESULTS_NEW_T      ResultsN = {0};
    FILE                        *pFile = NULL;
    BOOL                        fOpenFile = FALSE;
    WCHAR                       wszFilter[3] = {L'\0'};
    LPWSTR                      pwszTemp = NULL;
    LPWSTR                      pwszTime = NULL;

    NoOfRecsDesired = (DWORD)~0;
    TypeOfRec = WINSINTF_BOTH;
    
    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_SHOW_DATABASE_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    {
        dwNumArgs = dwArgCount - dwCurrentIndex;
        pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
        pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
        if( pdwTagType is NULL or
            pdwTagNum is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);
        Status = PreProcessCommand(ppwcArguments,
                                   dwArgCount,
                                   dwCurrentIndex,
                                   pttTags,
                                   &dwTagCount,
                                   pdwTagType,
                                   pdwTagNum);
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
        {
            if( pttTags[i].dwRequired is TRUE and
                pttTags[i].bPresent is FALSE 
              )
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }

        for( j=0; j<dwTagCount; j++ )
        {
            switch(pdwTagType[j])
            {
            case 0:
                {
                    LPWSTR  pwcTemp = NULL,
                            pwcTag = L",\r\n",
                            pwcToken = NULL,
                            pwszIps = NULL;
                    DWORD   dwLen = 0;

                    dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);

                    if( ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0] isnot L'{' or
                        ppwcArguments[dwCurrentIndex+pdwTagNum[j]][dwLen-1] isnot L'}')
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    
                    pwcTemp = ppwcArguments[dwCurrentIndex+pdwTagNum[j]] + 1;
                    dwLen--;
                    ppwcArguments[dwCurrentIndex+pdwTagNum[j]][dwLen] = L'\0';
                    dwLen--;
                    
                    if( dwLen <= 0 )
                    {
                        fAll = TRUE;
                        break;
                    }
                    
                    if( dwLen < 7 )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }

                    pwszIps = WinsAllocateMemory(dwLen*sizeof(WCHAR));

                    if( pwszIps is NULL )
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }
                    
                    wcscpy(pwszIps, pwcTemp);
                    
                    pwcToken = wcstok(pwszIps, pwcTag);

                    dwIpCount = 0;

                    while( pwcToken isnot NULL )
                    {
                        PDWORD pdwTemp = NULL;

                        if( IsIpAddress( pwcToken ) is FALSE )
                        {
                            Status = ERROR_INVALID_PARAMETER;
                            WinsFreeMemory(pwszIps);
                            pwszIps = NULL;
                            goto ErrorReturn;
                        }

                        pdwTemp = pdwIp;
                        pdwIp = WinsAllocateMemory((dwIpCount+1)*sizeof(DWORD));
                        if( pdwIp is NULL )
                        {
                            Status = ERROR_NOT_ENOUGH_MEMORY;
                            WinsFreeMemory(pwszIps);
                            pwszIps = NULL;
                            if( pdwTemp )
                            {
                                WinsFreeMemory(pdwTemp);
                                pdwTemp = NULL;
                            }
                            goto ErrorReturn;
                        }

                        if( pdwTemp )
                        {
                            memcpy(pdwIp, pdwTemp, dwIpCount*sizeof(DWORD));
                            WinsFreeMemory(pdwTemp);
                            pdwTemp = NULL;
                        }

                        
                        pdwIp[dwIpCount] = StringToIpAddress(pwcToken);
                        dwIpCount++;
                        pwcToken = wcstok(NULL, pwcTag);

                    }
                    
                    if( pwszIps )
                    {
                        WinsFreeMemory(pwszIps);
                        pwszIps = NULL;
                    }

                    break;

                }
            case 1:
                {
                    DWORD dw = 0;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 10);
                    if( dw is 1 )
                        TypeOfRec = WINSINTF_STATIC;
                    else if( dw is 2 )
                        TypeOfRec = WINSINTF_DYNAMIC;
                    else if( dw is 0 )
                        TypeOfRec = WINSINTF_BOTH;
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    break;
                }
            case 2:
                {
                    DWORD dw = 0;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }                    
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 10);
                    NoOfRecsDesired = dw;
                    break;
                }
            case 3:
                {
                    DWORD dw = 0;
                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    dw = STRTOUL(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL, 10);
                    if( dw is 0 )
                    {
                        dwStart = WINSINTF_BEGINNING;
                    }
                    else if ( dw is 1 )
                    {
                        dwStart = WINSINTF_END;
                    }
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    break;
                }
            case 4:
                {
                    DWORD dwLen = 0, k=0;
                    dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    if( dwLen > 2 )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                        
                    }
                
                    for( k=0; k<dwLen; k++ )
                    {
                        WCHAR  wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][k];
                        if( isalpha(wc) is TRUE )
                        {
                            if( towlower(wc) < L'a' or
                                towlower(wc) > L'f' )
                            {
                                Status = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                        }
                    }
               
                    chFilter = StringToHexA(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    wcsncpy(wszFilter, ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 2);
                    fFilter = TRUE;
                    break;
                }
            case 5:
                {
                    DWORD   dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    if( dwLen is 0 or
                        dwLen > MAX_PATH )
                    {
                        wcscpy(wcFile, L"wins.rec");
                        fFile = TRUE;
                        break;
                    }
                    
                    wcscpy(wcFile, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                    fFile = TRUE;
                    break;
                }
            default:
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
            }
        }
    }
    
    if( fAll )
    {   
        ResultsN.WinsStat.NoOfPnrs = 0;
        ResultsN.WinsStat.pRplPnrs = 0;
        ResultsN.NoOfWorkerThds = 1;
        ResultsN.pAddVersMaps = NULL;


        Status = WinsStatusNew(g_hBind, WINSINTF_E_CONFIG_ALL_MAPS, &ResultsN);
    
        if( Status is RPC_S_PROCNUM_OUT_OF_RANGE )
        {
            //Try old API
            Results.WinsStat.NoOfPnrs = 0;
            Results.WinsStat.pRplPnrs = 0;
            Status = WinsStatus(g_hBind, WINSINTF_E_CONFIG_ALL_MAPS, &Results);
            fNew = FALSE;
        }
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        if( fNew )
        {
            dwIpCount = ResultsN.NoOfOwners;
        }
        else
        {
            dwIpCount = Results.NoOfOwners;
        }
    }

    if( fFile is TRUE )
    {
        pFile = _wfopen(wcFile, L"a+");
        if( pFile is NULL )
        {
            DisplayMessage(g_hModule,
                           EMSG_WINS_FILEOPEN_FAILED,
                           wcFile);
            fOpenFile = FALSE;
        }
        else
        {
            fOpenFile = TRUE;
        }
    }    
  
    for( dw=0; dw<dwIpCount; dw++ )
    {
        LPSTR   pszLastName = NULL;
        DWORD   dwLastNameLen = 0;
        DWORD   dwDesired = 0;
        BOOL    fDone = FALSE;

        if( fHeader is FALSE )
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_RECORD_DESC);


            DisplayMessage(g_hModule,
                           MSG_WINS_RECORD_TABLE);

            if( fOpenFile )
            {
                DumpMessage(g_hModule,
                            pFile,
                            FMSG_WINS_RECORDS_TABLE);
            }
            DisplayMessage(g_hModule,
                           WINS_FORMAT_LINE);


            fHeader = TRUE;
        }                             

        WinsAdd.Len = 4;
        WinsAdd.Type = 0;

        if( fAll )
        {
            if( fNew )
            {
                WinsAdd.IPAdd = ResultsN.pAddVersMaps[dw].Add.IPAdd;
            }
            else
            {
                WinsAdd.IPAdd = Results.AddVersMaps[dw].Add.IPAdd;
            }
        }
        else
        {
            WinsAdd.IPAdd = pdwIp[dw];
        }

        DisplayMessage(g_hModule,
                       MSG_SRVR_RETRIEVE_DATABASE,
                       IpAddressToString(WinsAdd.IPAdd));
        fOnce = FALSE;
        Status = NO_ERROR;
        dwTotal = 0;
        fDone = FALSE;

        while( Status is NO_ERROR and
               dwTotal < NoOfRecsDesired and
               fDone is FALSE )
        {
            dwDesired = ( NoOfRecsDesired - dwTotal > 500 ) ? 500 : (NoOfRecsDesired - dwTotal);
            if( Recs.pRow )
            {
                WinsFreeMem(Recs.pRow);
                Recs.pRow = NULL;
            }
            
            memset( &Recs, 0x00, sizeof(WINSINTF_RECS_T));

            Status = WinsGetDbRecsByName(g_hBind,
                                         &WinsAdd, 
                                         dwStart,
                                         fOnce ? pszLastName: NULL,
                                         dwLastNameLen,
                                         dwDesired, 
                                         TypeOfRec, 
                                         &Recs);
            if( Status isnot NO_ERROR )
            {
                if( fOnce is FALSE )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_SRVR_RETRIEVEDB_FAILED,
                                   IpAddressToString(WinsAdd.IPAdd));

                    DisplayErrorMessage(EMSG_SRVR_ERROR_MESSAGE,
                                        Status);
                    fError = TRUE;
                }
                else if (  Status isnot ERROR_REC_NON_EXISTENT )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_SRVR_RETRIEVEDB_FAILED,
                                   IpAddressToString(WinsAdd.IPAdd));

                    DisplayErrorMessage(EMSG_SRVR_ERROR_MESSAGE,
                                        Status);
                    fError = TRUE;
                }

                Status = NO_ERROR;


                break;
            }

            fOnce = TRUE;

            dwTotal += Recs.NoOfRecs;

            if( dwDesired > Recs.NoOfRecs )
            {
                fDone = TRUE;
            }
            pRow = Recs.pRow;

            if( Recs.NoOfRecs is 0 )
            {
                DisplayMessage(g_hModule,
                               MSG_WINS_NO_RECORDS);
            }
            else
            {
                WCHAR   Name[21] = {L'\0'};
                WCHAR   Type[2] = {L'\0'};
                WCHAR   State[2] = {L'\0'};
                WCHAR   Version[9] = {L'\0'};
                WCHAR   Group[2] = {L'\0'};
                WCHAR   IPAdd[MAX_IP_STRING_LEN+1] = {L'\0'};
                WCHAR   Buffer[16] = {L'\0'};
                DWORD   dwState = WINS_STATE_ACTIVE;
                DWORD   dwType = WINS_TYPE_STATIC;
                DWORD   dwGroup = WINS_GROUP_UNIQUE;
                DWORD   dwTempLen = 0;
                struct  tm* time = NULL;
                int     iType = 1;          
                for( j=0; j<Recs.NoOfRecs; j++ )
                {
            
                    LPWSTR  pwszGroup = NULL,
                            pwszStatic = NULL,
                            pwszType = NULL,
                            pwszState = NULL;
                    WCHAR   wszGroup[100] = {L'\0'},
                            wszType[100] = {L'\0'},
                            wszState[100] = {L'\0'};

                    CHAR    chEndChar = (CHAR)0x00;

                    DWORD   dwGrouplen = 0,
                            dwTypelen = 0,
                            dwStatelen = 0;
                    
                    memset( Name, 0x00, 21*sizeof(WCHAR));
                    if( j is Recs.NoOfRecs - 1 )
                    {
                        if( pszLastName )
                        {
                            WinsFreeMemory(pszLastName);
                            pszLastName = NULL;
                        }
                        pszLastName = WinsAllocateMemory(strlen(pRow->pName)+2);
                        if(pszLastName is NULL )
                        {
                            Status = ERROR_NOT_ENOUGH_MEMORY;
                            goto ErrorReturn;
                        }
                        memset(pszLastName, 0x00, strlen(pRow->pName)+2);

                        strcpy(pszLastName, pRow->pName);
                        
                        //1B records detected at the boundary, swap 1st and
                        //16th char
                        
                        if( pszLastName[15] == 0x1B )
                        {
                            CHAR ch = pszLastName[15];
                            pszLastName[15] = pszLastName[0];
                            pszLastName[0] = ch;
                        }

                        strcat(pszLastName, "\x01");
                        dwLastNameLen = pRow->NameLen+1;
                    }
                    
                    if( pRow->NameLen > 16 )
                        i = 15;
                    else
                        i = pRow->NameLen;
                    
                    chEndChar = pRow->pName[i];

                    pRow->pName[i] = (CHAR)0x20;
                    //pRow->pName[16] = '\0';

                    if( fFilter is TRUE )
                    {
                        if( chFilter isnot chEndChar )
                        {
                            pRow++;
                            continue;
                        }
                    }
                    
                    pwszTemp = WinsOemToUnicode(pRow->pName, NULL);
                    if( pwszTemp is NULL )
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }
                    
                    dwTempLen = wcslen(pwszTemp);
                    
                    dwTempLen = (dwTempLen>16) ? 16 : dwTempLen;

                    wcsncpy(Name, pwszTemp, dwTempLen);
            
                    WinsFreeMemory(pwszTemp);
                    pwszTemp = NULL;

                    for( i=dwTempLen; i<16; i++ )
                        Name[i] = L' ';
                    Name[15] = L'[';
                    i=0;


                    WinsHexToString(Name+16, (LPBYTE)&chEndChar, 1);
                    Name[18] = L'h';
                    Name[19] = L']';
                    Name[20] = L'\0';


                    if( pRow->fStatic )
                    {
                        wcscpy(Type, L"S");
                        pwszType = L"STATIC ";
                        dwType = WINS_TYPE_STATIC;
                    }
                    else
                    {
                        wcscpy(Type, L"D");
                        pwszType = L"DYNAMIC";
                        dwType = WINS_TYPE_DYNAMIC;

                    }

                    if( pRow->State_e is WINSINTF_E_ACTIVE )
                    {
                        wcscpy(State, L"A");
                        pwszState = L"ACTIVE   ";
                        dwState = WINS_STATE_ACTIVE;
                    }

                    else if( pRow->State_e is WINSINTF_E_RELEASED )
                    {
                        wcscpy(State, L"R");
                        pwszState = L"RELEASED ";
                        dwState = WINS_STATE_RELEASED;
                    }
                    else
                    {
                        wcscpy(State, L"T");
                        pwszState = L"TOMBSTONE";
                        dwState = WINS_STATE_TOMBSTONE;
                    }

            
                    if( pRow->TypOfRec_e is WINSINTF_E_UNIQUE )
                    {
                        wcscpy(Group,L"U");
                        pwszGroup = L"UNIQUE        ";
                        dwGroup = WINS_GROUP_UNIQUE;
                    }
                    else if( pRow->TypOfRec_e is WINSINTF_E_NORM_GROUP )
                    {
                        wcscpy(Group,L"N");
                        pwszGroup = L"GROUP         ";
                        dwGroup = WINS_GROUP_GROUP;
                    }
                    else if( pRow->TypOfRec_e is WINSINTF_E_SPEC_GROUP )
                    {
                        if( pRow->pName[15] is 0x1C )
                        {
                            wcscpy(Group, L"D");
                            pwszGroup = L"DOMAIN NAME   ";
                            dwGroup = WINS_GROUP_DOMAIN;
                        }
                        else
                        {
                            wcscpy(Group,L"I");
                            pwszGroup = L"INTERNET GROUP";
                            dwGroup = WINS_GROUP_INTERNET;
                        }
                    }
                    else
                    {
                        wcscpy(Group,L"M");
                        pwszGroup = L"MULTIHOMED    ";
                        dwGroup = WINS_GROUP_MULTIHOMED;
                    }
    
            
                    dwStatelen = LoadStringW(g_hModule,
                                            dwState,
                                            wszState,
                                            sizeof(wszState)/sizeof(WCHAR));

                    dwGrouplen = LoadStringW(g_hModule,
                                            dwGroup,
                                            wszGroup,
                                            sizeof(wszGroup)/sizeof(WCHAR));

                    dwTypelen = LoadStringW(g_hModule,
                                           dwType,
                                           wszType,
                                           sizeof(wszType)/sizeof(WCHAR));

                    memset(Version, L'\0', 9);
                    _itow((int)pRow->VersNo.LowPart, Buffer, 16);
                    wcsncpy(Version, Buffer, wcslen(Buffer)>8?8:wcslen(Buffer));

                    for( i=wcslen(Version); i<9; i++ )
                        Version[i] = L' ';
                           
                    Version[8] = L'\0';

                    pwszTime = GetDateTimeString(pRow->TimeStamp,
                                                 TRUE,
                                                 &iType);

                    if ( pRow->TypOfRec_e is WINSINTF_E_UNIQUE  or
                         pRow->TypOfRec_e is WINSINTF_E_NORM_GROUP )
                    {

                        wcscpy(IPAdd, IpAddressToString(pRow->Add.IPAdd));

                        for( i=wcslen(IPAdd); i<MAX_IP_STRING_LEN; i++ )
                            IPAdd[i] = L' ';
                
                        IPAdd[MAX_IP_STRING_LEN] = L'\0';
                
                        DisplayMessage(g_hModule,
                                       MSG_WINS_RECORD_ENTRY,
                                       Name,
                                       Type,
                                       State,
                                       Version,
                                       Group,
                                       IPAdd,
                                       iType ? wszInfinite : pwszTime);
                        if( fOpenFile )
                        {
                            DumpMessage(g_hModule,
                                        pFile,
                                        FMSG_WINS_RECORD_ENTRY,
                                        Name,
                                        ( dwTypelen > 0 ) ? wszType : pwszType,
                                        ( dwStatelen > 0 ) ? wszState : pwszState,
                                        Version,
                                        ( dwGrouplen > 0 ) ? wszGroup : pwszGroup,
                                        iType ? wszInfinite : pwszTime,
                                        IPAdd,
                                        IpAddressToString(WinsAdd.IPAdd));

                        }

         
            
                    }
                    else //spec. grp or multihomed
                    {
                        DWORD ind;
                        BOOL  fFirst = FALSE;
                        for ( ind=0;  ind < pRow->NoOfAdds ;  /*no third expr*/ )
                        {
                            struct in_addr InAddr1, InAddr2;
                            LPWSTR  pwszTempAddr = NULL;
                            InAddr1.s_addr = htonl( (pRow->pAdd + ind++)->IPAdd);
                            InAddr2.s_addr = htonl( (pRow->pAdd + ind++)->IPAdd);

                            pwszTempAddr = WinsOemToUnicode(inet_ntoa(InAddr2), NULL);

                            if( pwszTempAddr is NULL )
                            {
                                Status = ERROR_NOT_ENOUGH_MEMORY;
                                goto ErrorReturn;
                            }

                            wcscpy(IPAdd, pwszTempAddr);

                            WinsFreeMemory(pwszTempAddr);
                            pwszTempAddr = NULL;

                            for( i=wcslen(IPAdd); i<MAX_IP_STRING_LEN; i++ )
                                IPAdd[i] = L' ';

                            if( fFirst is FALSE )
                            {

                                fFirst = TRUE;
                                DisplayMessage(g_hModule,
                                               MSG_WINS_RECORD_ENTRY,
                                               Name,
                                               Type,
                                               State,
                                               Version,
                                               Group,
                                               IPAdd,
                                               iType ? wszInfinite : pwszTime); 
                                if( fOpenFile )
                                {
                                    pwszTempAddr = WinsOemToUnicode(inet_ntoa(InAddr1), NULL);
                                    if( pwszTempAddr is NULL )
                                    {
                                        Status = ERROR_NOT_ENOUGH_MEMORY;
                                        goto ErrorReturn;
                                    }
                                    DumpMessage(g_hModule,
                                                pFile,
                                                FMSG_WINS_RECORD_ENTRY,
                                                Name,
                                                ( dwTypelen > 0 ) ? wszType : pwszType,
                                                ( dwStatelen > 0 ) ? wszState : pwszState,
                                                Version,
                                                ( dwGrouplen > 0 ) ? wszGroup : pwszGroup,
                                                iType ? wszInfinite : pwszTime,
                                                IPAdd,
                                                pwszTempAddr);
                                    WinsFreeMemory(pwszTempAddr);
                                    pwszTempAddr = NULL;

                                }
 
                            }
                            else
                            {

                                pwszTempAddr = WinsOemToUnicode(inet_ntoa(InAddr2), NULL);
                                if( pwszTempAddr is NULL )
                                {
                                    Status = ERROR_NOT_ENOUGH_MEMORY;
                                    goto ErrorReturn;
                                }

                                DisplayMessage(g_hModule,
                                               MSG_WINS_RECORD_IPADDRESS,
                                               pwszTempAddr);

                                WinsFreeMemory(pwszTempAddr);
                                pwszTempAddr = NULL;

                                if( fOpenFile )
                                {
                                    pwszTempAddr = WinsOemToUnicode(inet_ntoa(InAddr1), NULL);
                                    if( pwszTempAddr is NULL )
                                    {
                                        Status = ERROR_NOT_ENOUGH_MEMORY;
                                        goto ErrorReturn;
                                    }
                                    DumpMessage(g_hModule,
                                                pFile,
                                                FMSG_WINS_RECORD_IPADDRESS,
                                                IPAdd,
                                                pwszTempAddr);

                                    WinsFreeMemory(pwszTempAddr);
                                    pwszTempAddr = NULL;
                                    DumpMessage(g_hModule,
                                                pFile,
                                                WINS_FORMAT_LINE);
                                }
                                DisplayMessage(g_hModule,
                                               WINS_FORMAT_LINE);

                            }
                        }
                    }

                    pRow++;
                    dwRecCount++;
                    if( pwszTime )
                    {
                        WinsFreeMemory(pwszTime);
                        pwszTime = NULL;
                    }
                }
      

            }
        }

        DisplayMessage(g_hModule,
                       MSG_WINS_RECORDS_RETRIEVED,
                       IpAddressToString(WinsAdd.IPAdd),
                       dwTotal);
    }

    

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    if( fFilter )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_FILTER_RECCOUNT,
                       wszFilter,
                       dwRecCount);
        if( fOpenFile )
        {
            DumpMessage(g_hModule,
                        pFile,
                        MSG_SRVR_FILTER_RECCOUNT,
                        wszFilter,
                        dwRecCount);
        }
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_TOTAL_RECCOUNT,
                       dwRecCount);

        if( fOpenFile )
        {
            DumpMessage(g_hModule,
                        pFile,
                        MSG_SRVR_TOTAL_RECCOUNT,
                        dwRecCount);
        }

    }

CommonReturn:
    if( Status is NO_ERROR and
        fError is FALSE )
    {
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    }
    else if( fError is TRUE )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_RETRIEVEDB_PARTIAL);
    }
    if( fOpenFile )
    {
        fclose(pFile);
        pFile = NULL;
    }
    if( Recs.pRow )
    {
        WinsFreeMem(Recs.pRow);
        Recs.pRow = NULL;
    }

    if( pwszTime )
    {
        WinsFreeMemory(pwszTime);
        pwszTime = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SHOW_DATABASE,
                        Status);
    goto CommonReturn;
}

DWORD
HandleSrvrShowDomain(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the domain master browser records
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/

{
    DWORD                     Status = NO_ERROR;
    DWORD                     i = 0, j=0;
    WINSINTF_BROWSER_NAMES_T  Names;
    PWINSINTF_BROWSER_INFO_T  pInfo = NULL;
    PWINSINTF_BROWSER_INFO_T  pInfoSv = NULL;
    WCHAR                     wcName[273] = {L'\0'},
                              wcCount[20] = {L'\0'}; 

    

    for(i=0; i<273; i++ )
        wcName[i] = L' ';

    for(i=0; i<20; i++ )
        wcCount[i] = L' ';

    wcCount[19] = L'\0';

    Names.EntriesRead = 0;
    Names.pInfo = NULL;
    Status = WinsGetBrowserNames(&g_BindData, &Names);
    if (Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_DOMAIN_COUNT,
                       Names.EntriesRead);
        
        DisplayMessage(g_hModule,
                       WINS_FORMAT_LINE);

        DisplayMessage(g_hModule,
                       MSG_WINS_DOMAIN_TABLE);

        pInfoSv = pInfo = Names.pInfo;
        for(i=0;  i < Names.EntriesRead; i++)
        {
            LPWSTR  pwcTemp = NULL;
            LPSTR   pcTemp = NULL;

            _itow((int)i, wcCount+3, 10);
            
            for( j=wcslen(wcCount); j<19; j++ )
                wcCount[j] = L' ';
            wcCount[19] = L'\0';

            pwcTemp = WinsOemToUnicode(pInfo->pName, NULL);
            if( pwcTemp is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }

            wcsncpy(wcName+3, pwcTemp, (15>wcslen(pwcTemp))? wcslen(pwcTemp) : 15);
                
            wcName[18] = L'[';

            if( strlen(pInfo->pName ) > 15 )
                pcTemp = pInfo->pName + 15;
            else
                pcTemp = pInfo->pName + strlen(pInfo->pName);

            WinsHexToString(wcName+19,
                            (LPBYTE)pcTemp,
                            1);
            wcName[21] = L'h';
            wcName[22] = L']';
            if( strlen(pInfo->pName)>16)
            {
                wcName[23] = L'.';
                wcscpy(wcName+24, pwcTemp+17);
                wcName[wcslen(wcName)] = L'\0';
            }
            else
                wcName[23] = L'\0';

            DisplayMessage(g_hModule,
                           MSG_WINS_DOMAIN_ENTRY,
                           wcCount,
                           wcName);
            if( pwcTemp )
            {
                WinsFreeMemory(pwcTemp);
                pwcTemp = NULL;
            }
             pInfo++;
        }
        WinsFreeMem(pInfoSv);
        pInfoSv = NULL;
        if( Status is NO_ERROR )
            DisplayMessage(g_hModule,
                           EMSG_WINS_ERROR_SUCCESS);
    }
    else
        goto ErrorReturn;

CommonReturn:
    if( pInfoSv )
    {
        WinsFreeMem(pInfoSv);
        pInfoSv = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SHOW_DOMAIN,
                        Status);
    goto CommonReturn;

}


DWORD
HandleSrvrShowInfo(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays server properties
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    HKEY        hServer = NULL,
                hParameter = NULL,
                hCCRoot = NULL;
    LPWSTR      pTemp = NULL;

    WCHAR       wcData[256] = {L'\0'};
    DWORD       dwType = REG_SZ,
                dwLen = 256*sizeof(WCHAR),
                dwData = 0,
                dwLow = 0;
    LPWSTR      pwszDayString = NULL,
                pwszTimeString = NULL;
    

    if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    Status = RegOpenKeyEx(hServer,
                          PARAMETER,
                          0,
                          KEY_READ,
                          &hParameter);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_WINS_DATABASE_BACKUPPARAM);

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_BACKUP_DIR_PATH_NM,
                             0,
                             &dwType,
                             (LPBYTE)wcData,
                             &dwLen);
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_DATABASE_BACKUPDIR,
                       wcData);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_DATABASE_BACKUPDIR,
                       wszUnknown);
                       
    }

    dwLen = sizeof(DWORD);
    dwType = REG_DWORD;

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_DO_BACKUP_ON_TERM_NM,
                             0,
                             &dwType,
                             (LPBYTE)&dwData,
                             &dwLen);

    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_DATABASE_BACKUPONTERM,
                       dwData ? wszEnable : wszDisable);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_DATABASE_BACKUPONTERM,
                       wszUnknown);
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_WINS_NAMERECORD_SETTINGS);


    {

        WINSINTF_RESULTS_T      Results = {0};
        WINSINTF_RESULTS_NEW_T  ResultsN = {0};
        BOOL                    fNew = TRUE;
        

		ResultsN.WinsStat.NoOfPnrs = 0;
		ResultsN.WinsStat.pRplPnrs = NULL;
		ResultsN.NoOfWorkerThds = 1;

        Status = WinsStatusNew(g_hBind,
                               WINSINTF_E_CONFIG,
                               &ResultsN);

        if( Status is RPC_S_PROCNUM_OUT_OF_RANGE )
        {
            //Try old API
            Results.WinsStat.NoOfPnrs = 0;
            Results.WinsStat.pRplPnrs = 0;
            Status = WinsStatus(g_hBind, WINSINTF_E_CONFIG, &Results);
            fNew = FALSE;
        }
        
        if( Status is NO_ERROR )
        {
            if( fNew )
            {
                LPWSTR  pwszDayString = NULL;

                pwszDayString = MakeDayTimeString(ResultsN.RefreshInterval);

                DisplayMessage(g_hModule,
                               MSG_WINS_NAMERECORD_REFRESHINTVL,
                               pwszDayString);
                WinsFreeMemory(pwszDayString);
                pwszDayString = NULL;

                pwszDayString = MakeDayTimeString(ResultsN.TombstoneInterval);
                DisplayMessage(g_hModule,
                               MSG_WINS_NAMERECORD_TOMBSTONEINTVL,
                               pwszDayString);
                WinsFreeMemory(pwszDayString);
                pwszDayString = NULL;

                pwszDayString = MakeDayTimeString(ResultsN.TombstoneTimeout);
                DisplayMessage(g_hModule,
                               MSG_WINS_NAMERECORD_TOMBSTONETMOUT,
                               pwszDayString);
                WinsFreeMemory(pwszDayString);
                pwszDayString = NULL;

                pwszDayString = MakeDayTimeString(ResultsN.VerifyInterval);
                DisplayMessage(g_hModule,
                               MSG_WINS_NAMERECORD_VERIFYINTVL,
                               pwszDayString);
                WinsFreeMemory(pwszDayString);
                pwszDayString = NULL;

                if( ResultsN.WinsStat.pRplPnrs)
                {
                    WinsFreeMem(ResultsN.WinsStat.pRplPnrs);
                    ResultsN.WinsStat.pRplPnrs = NULL;
                }
            }
            else
            {
                LPWSTR  pwszDayString = NULL;

                pwszDayString = MakeDayTimeString(Results.RefreshInterval);

                DisplayMessage(g_hModule,
                               MSG_WINS_NAMERECORD_REFRESHINTVL,
                               pwszDayString);
                WinsFreeMemory(pwszDayString);
                pwszDayString = NULL;

                pwszDayString = MakeDayTimeString(Results.TombstoneInterval);
                DisplayMessage(g_hModule,
                               MSG_WINS_NAMERECORD_TOMBSTONEINTVL,
                               pwszDayString);
                WinsFreeMemory(pwszDayString);
                pwszDayString = NULL;

                pwszDayString = MakeDayTimeString(Results.TombstoneTimeout);
                DisplayMessage(g_hModule,
                               MSG_WINS_NAMERECORD_TOMBSTONETMOUT,
                               pwszDayString);
                WinsFreeMemory(pwszDayString);
                pwszDayString = NULL;

                pwszDayString = MakeDayTimeString(Results.VerifyInterval);
                DisplayMessage(g_hModule,
                               MSG_WINS_NAMERECORD_VERIFYINTVL,
                               pwszDayString);
                WinsFreeMemory(pwszDayString);
                pwszDayString = NULL;

                if( Results.WinsStat.pRplPnrs)
                {
                    WinsFreeMem(Results.WinsStat.pRplPnrs);
                    Results.WinsStat.pRplPnrs = NULL;
                }
            }

        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_NAMERECORD_REFRESHINTVL,
                           wszUnknown);
            
            DisplayMessage(g_hModule,
                           MSG_WINS_NAMERECORD_TOMBSTONEINTVL,
                           wszUnknown);

            DisplayMessage(g_hModule,
                           MSG_WINS_NAMERECORD_TOMBSTONETMOUT,
                           wszUnknown);

            DisplayMessage(g_hModule,
                           MSG_WINS_NAMERECORD_VERIFYINTVL,
                           wszUnknown);

        }

                            
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_WINS_DBCC_PARAM);

    Status = RegOpenKeyEx(hParameter,
                          CC,
                          0,
                          KEY_READ,
                          &hCCRoot);

    if( Status isnot NO_ERROR )
    {
        DisplayMessage(g_hModule, 
                       MSG_WINS_DBCC_STATE,
                       wszDisable);
    }
    else
    {
        DisplayMessage(g_hModule, 
                       MSG_WINS_DBCC_STATE,
                       wszEnable);

        dwType = REG_DWORD;
        dwData = 0;
        dwLen = sizeof(DWORD);
        Status = RegQueryValueEx(hCCRoot,
                               WINSCNF_CC_MAX_RECS_AAT_NM,
                               0,
                               &dwType,
                               (LPBYTE)&dwData,
                               &dwLen);

        if( Status is NO_ERROR )
        {
            WCHAR Buffer[20] = {L'\0'};
            _itow(dwData, Buffer, 10);
            DisplayMessage(g_hModule,
                           MSG_WINS_DBCC_MAXCOUNT,
                           Buffer);
                           
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_DBCC_MAXCOUNT,
                           wszUnknown);
        }

        dwType = REG_DWORD;
        dwData = 0;
        dwLen = sizeof(DWORD);
        Status = RegQueryValueEx(hCCRoot,
                                 WINSCNF_CC_USE_RPL_PNRS_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwLen);
        
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_DBCC_CHECKAGAINST,
                           dwData ? wszRandom : wszOwner);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_DBCC_CHECKAGAINST,
                           wszUnknown);
        }

        dwType = REG_DWORD;
        dwData = 0;
        dwLen = sizeof(DWORD);

        Status = RegQueryValueEx(hCCRoot,
                                 WINSCNF_CC_INTVL_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwLen);
        if( Status is NO_ERROR )
        {
            WCHAR Buffer[5] = {L'\0'};
            _itow(dwData/(60*60), Buffer, 10);
            DisplayMessage(g_hModule,
                           MSG_WINS_DBCC_CHECKEVERY,
                           Buffer);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_DBCC_CHECKEVERY,
                           wszUnknown);
        }

        memset(wcData, 0x00, 256*sizeof(WCHAR));

        dwType = REG_SZ;
        dwLen = 256*sizeof(WCHAR);

        Status = RegQueryValueEx(hCCRoot,
                                 WINSCNF_SP_TIME_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)wcData,
                                 &dwLen);
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_DBCC_STARTAT,
                           wcData);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_DBCC_STARTAT,
                           wszUnknown);
        }
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_WINS_LOGGING_PARAM);


    dwType = REG_DWORD;
    dwData = 0;
    dwLen = sizeof(DWORD);

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_LOG_FLAG_NM,
                             0,
                             &dwType,
                             (LPBYTE)&dwData,
                             &dwLen);

    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_LOGGING_FLAG,
                       dwData ? wszEnable : wszDisable);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_LOGGING_FLAG,
                       wszUnknown);
    }

    dwType = REG_DWORD;
    dwData = 0;
    dwLen = sizeof(DWORD);

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_LOG_DETAILED_EVTS_NM,
                             0,
                             &dwType,
                             (LPBYTE)&dwData,
                             &dwLen);

    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_LOGGING_DETAILS,
                       dwData ? wszEnable : wszDisable);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_LOGGING_DETAILS,
                       wszUnknown);
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_WINS_BURSTHNDL_PARAM);

    dwType = REG_DWORD;
    dwData = 0;
    dwLen = sizeof(DWORD);

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_BURST_HANDLING_NM,
                             0,
                             &dwType,
                             (LPBYTE)&dwData,
                             &dwLen);

    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_BURSTHNDL_STATE,
                       dwData ? wszEnable : wszDisable);

        if( dwData > 0 )
        {
            dwType = REG_DWORD;
            dwData = 0;
            dwLen = sizeof(DWORD);

            Status = RegQueryValueEx(hParameter,
                            WINSCNF_BURST_QUE_SIZE_NM,
                            0,
                            &dwType,
                            (LPBYTE)&dwData,
                            &dwLen);

            if( Status is NO_ERROR )
            {
                WCHAR   Buffer[10] = {L'\0'};
                _itow(dwData, Buffer, 10);
                DisplayMessage(g_hModule,
                               MSG_WINS_BURSTHNDL_SIZE,
                               Buffer);
            }
            else
            {
                DisplayMessage(g_hModule,
                               MSG_WINS_BURSTHNDL_SIZE,
                               wszUnknown);
            }
                            
        }
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_BURSTHNDL_STATE,
                       wszUnknown);
    }

    DisplayMessage(g_hModule,
                   WINS_FORMAT_LINE);

    dwType = REG_DWORD;
    dwData = 0;
    dwLen = sizeof(DWORD);

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_INIT_VERSNO_VAL_HW_NM,
                             NULL,
                             &dwType,
                             (LPBYTE)&dwData,
                             &dwLen);
    dwLow = 0;

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_INIT_VERSNO_VAL_LW_NM,
                             NULL,
                             &dwType,
                             (LPBYTE)&dwLow,
                             &dwLen);

    
    if(Status is NO_ERROR )
    {
        wsprintf(wcData, L" %x , %x", dwData, dwLow);
        DisplayMessage(g_hModule,
                       MSG_SRVR_START_VERSION,
                       wcData);
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( hCCRoot )
    {
        RegCloseKey(hCCRoot);
        hCCRoot = NULL;
    }

    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    return Status;

ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SHOW_INFO,
                        Status);
    goto CommonReturn;

}


DWORD
HandleSrvrShowPartner(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the list of Partners optionally based on the partner type.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Optional : Partner type - Pull or Push or Both(default)
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount, dwCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_TYPE, FALSE, FALSE}
                            };

    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;
    DWORD       p = 0;
    typedef enum {all=0, pull, push, both}eType;

    eType       Type = all;

    BOOL        fPush = TRUE,
                fPull = TRUE;
    HKEY        hServer = NULL,
                hPullRoot = NULL,
                hPushRoot = NULL;
    WCHAR       wcServerIpAdd[MAX_IP_STRING_LEN] = {L'\0'};
    WCHAR       wcServer[256] = {L'\0'};
    DWORD       dwLen = 0;
    typedef struct _Server_List {
        WCHAR   wcServerIpAddress[MAX_IP_STRING_LEN + 1];
        WCHAR   wcServerName[1024];
        eType   etype;
    }Server_List, *PServer_List;
    
    PServer_List pServerList = NULL;
                
            
    LPWSTR      pwszServerList = NULL;

    LPWSTR      pTemp = NULL;
    
    dwCount = 0;

    if( dwArgCount >= dwCurrentIndex + 1  )
    {
        dwNumArgs = dwArgCount - dwCurrentIndex;

        pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
        pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
        if( pdwTagType is NULL or
            pdwTagNum is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

        Status = PreProcessCommand(ppwcArguments,
                                   dwArgCount,
                                   dwCurrentIndex,
                                   pttTags,
                                   &dwTagCount,
                                   pdwTagType,
                                   pdwTagNum);
        if( Status isnot NO_ERROR )
            goto ErrorReturn;

        for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
        {
            if( pttTags[i].dwRequired is TRUE and
                pttTags[i].bPresent is FALSE 
              )
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }

        for( j=0; j<dwTagCount; j++ )
        {
            switch(pdwTagType[j])
            {
            case 0:
                {
                    WCHAR wc = L'\0';

                    if( IsPureNumeric(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) is FALSE or
                        wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 1 )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    
                    wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];

                    if( wc is L'0' )
                    {
                        Type = all;
                    }
                    if( wc is L'1' )
                    {
                        Type = pull;
                        break;
                    }
                    else if( wc is L'2' )
                    {
                        Type = push;
                        break;
                    }
                    else if ( wc is L'3' )
                    {
                        Type = both;
                        break;
                    }
                    else
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    break;
                }
            default:
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
            }
        }
    }

    if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegOpenKeyEx(hServer,
                          PULLROOT,
                          0,
                          KEY_READ,
                          &hPullRoot);
    if( Status isnot ERROR_FILE_NOT_FOUND and 
        Status isnot NO_ERROR ) 
        goto ErrorReturn;

    Status = RegOpenKeyEx(hServer,
                          PUSHROOT,
                          0,
                          KEY_READ,
                          &hPushRoot);
    
    if( Status isnot ERROR_FILE_NOT_FOUND and 
        Status isnot NO_ERROR ) 
        goto ErrorReturn;
    
    if( hPullRoot is NULL and
        hPushRoot is NULL )
    {        
        goto ErrorReturn;
    }

    Status = NO_ERROR;

    {
        DWORD dwSubkey = 0;
        HKEY  hKey = NULL;

        if (hPullRoot != NULL)
        {
            Status = RegQueryInfoKey(hPullRoot,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &dwSubkey,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL);

            if (Status isnot NO_ERROR)
            {
                goto ErrorReturn;
            }
        }

        if( dwSubkey > 0 )
        {
            pServerList = WinsAllocateMemory(dwSubkey*sizeof(Server_List));
            if( pServerList is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }

            for( j=0; j<dwSubkey; j++ )
            {
                DWORD dwLen = (MAX_IP_STRING_LEN + 1)*sizeof(WCHAR);
                DWORD dwType = REG_SZ;
                Status = RegEnumKeyEx(hPullRoot,
                                      j,
                                      pServerList[j].wcServerIpAddress,
                                      &dwLen,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL);
                if( Status isnot NO_ERROR )
                {
                    if( Status is ERROR_FILE_NOT_FOUND )
                    {
                        continue;    
                    }
                    else
                    {
                        goto ErrorReturn;
                    }
                }
            
                Status = RegOpenKeyEx(hPullRoot,
                                      pServerList[j].wcServerIpAddress,
                                      0,
                                      KEY_READ,
                                      &hKey);
                if( Status isnot NO_ERROR )
                {
                    if( Status is ERROR_FILE_NOT_FOUND )
                    {
                        continue;    
                    }
                    else
                    {
                        goto ErrorReturn;
                    }
                }

                dwLen = 1024*sizeof(WCHAR);

                Status = RegQueryValueEx(hKey,
                                         L"NetBIOSName",
                                         0,
                                         &dwType,
                                         (LPBYTE)pServerList[j].wcServerName,
                                         &dwLen);
                if( Status isnot NO_ERROR )
                {
                    if( Status is ERROR_FILE_NOT_FOUND )
                    {
                        wcscpy(pServerList[j].wcServerName, wszUnknown);
                    }
                    else
                    {
                        goto ErrorReturn;
                    }
                }

                pServerList[j].etype = pull;
                RegCloseKey(hKey);
                hKey = NULL;
            }
        }

        i = dwSubkey;
        dwCount = i;
        Status = NO_ERROR;
        dwSubkey = 0;

        if (hPushRoot != NULL)
        {
            Status = RegQueryInfoKey(hPushRoot,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &dwSubkey,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL);

            if (Status isnot NO_ERROR)
            {
                goto ErrorReturn;
            }
        }

        if( dwSubkey > 0 )
        {
            PServer_List pTempList = NULL;

            if( pServerList )
                pTempList = pServerList;
            
            pServerList= WinsAllocateMemory((dwSubkey+i)*sizeof(Server_List));
            
            if( pServerList is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            
            memcpy(pServerList, pTempList, i*sizeof(Server_List));
            
            if( pTempList )
            {
                WinsFreeMemory(pTempList);
                pTempList = NULL;
            }

            p = 0;
            for( j=0; j<dwSubkey; j++ )
            {
                DWORD dwLen = (MAX_IP_STRING_LEN + 1)*sizeof(WCHAR);
                DWORD dwType = REG_SZ;
                WCHAR wcIpTemp[MAX_IP_STRING_LEN+1] = {L'\0'};
                DWORD k = 0;
                BOOL  fFind = FALSE;
                Status = RegEnumKeyEx(hPushRoot,
                                      j,
                                      wcIpTemp,
                                      &dwLen,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL);
                if( Status isnot NO_ERROR )
                {
                    if( Status is ERROR_FILE_NOT_FOUND )
                    {
                        Status = NO_ERROR;
                        continue;
                    }
                    else
                    {
                        goto ErrorReturn;
                    }
                }
            
                for( k=0; k<i; k++ )
                {
                    if( _wcsicmp(pServerList[k].wcServerIpAddress, wcIpTemp) is 0 )
                    {
                        pServerList[k].etype = all;
                        fFind = TRUE;
                        break;
                    }
                }

                if( fFind is FALSE )
                {
                    wcscpy(pServerList[i+p].wcServerIpAddress, wcIpTemp);
                    Status = RegOpenKeyEx(hPushRoot,
                                          pServerList[i+p].wcServerIpAddress,
                                          0,
                                          KEY_READ,
                                          &hKey);
                    if( Status isnot NO_ERROR )
                    {
                        if( Status is ERROR_FILE_NOT_FOUND )
                        {
                            Status = NO_ERROR;
                            continue;    
                        }
                        else
                        {
                            goto ErrorReturn;
                        }
                    }

                    dwLen = 1024*sizeof(WCHAR);
    
                    Status = RegQueryValueEx(hKey,
                                             L"NetBIOSName",
                                             0,
                                             &dwType,
                                             (LPBYTE)pServerList[i+p].wcServerName,
                                             &dwLen);
                    if( Status isnot NO_ERROR )
                    {
                     
                        if( Status is ERROR_FILE_NOT_FOUND )
                        {
                            wcscpy(pServerList[i+p].wcServerName, wszUnknown);
                            Status = NO_ERROR;
                        }
                        else
                        {
                            goto ErrorReturn;
                        }
                    }
                    pServerList[i+p].etype = push;
                    RegCloseKey(hKey);
                    hKey = NULL;
                    p++;
                    dwCount++;
                }
                else
                    continue;
            }
        }
                                   
    }

    if( dwCount <= 0 )
    {
        DisplayMessage(g_hModule, MSG_WINS_NO_PARTNER);
    }
    else
    {
        DisplayMessage(g_hModule, WINS_FORMAT_LINE);
        DisplayMessage(g_hModule,
                       MSG_WINS_PARTNER_COUNT,
                       dwCount);

        DisplayMessage(g_hModule, WINS_FORMAT_LINE);
        DisplayMessage(g_hModule, MSG_WINS_PARTNERLIST_TABLE);
        
        

        for( j=0; j<dwCount; j++)
        {
            WCHAR   wcServer[32] = {L'\0'};       
            WCHAR   wcIp[25] = {L'\0'};
            DWORD   dwServerLen = 0;
            DWORD   k = 0;
            for( k=0; k<31; k++ )
                wcServer[k] = L' ';
            wcServer[31] = L'\0';

            for( k=0; k<24; k++ )
                wcIp[k] = L' ';
            wcIp[24] = L'\0';
            
            dwServerLen = MIN( 24, wcslen(pServerList[j].wcServerName) );
            switch(Type)
            {
            case all:
            default:
                {
                    

                    memcpy(wcServer+3, pServerList[j].wcServerName, dwServerLen*sizeof(WCHAR) );
                    memcpy(wcIp+3, pServerList[j].wcServerIpAddress, wcslen(pServerList[j].wcServerIpAddress)*sizeof(WCHAR));
                    DisplayMessage(g_hModule,
                                   MSG_WINS_PARTNERLIST_ENTRY,
                                   wcServer,
                                   wcIp,
                                   pServerList[j].etype is all ? wszPushpull:
                                   (pServerList[j].etype is pull) ? wszPull : wszPush);
                    break;
                }
            case pull:
                {
                    if( pServerList[j].etype is pull or
                        pServerList[j].etype is all )
                    {
                        memcpy(wcServer+3, pServerList[j].wcServerName, dwServerLen*sizeof(WCHAR));
                        memcpy(wcIp+3, pServerList[j].wcServerIpAddress, wcslen(pServerList[j].wcServerIpAddress)*sizeof(WCHAR));

                        DisplayMessage(g_hModule,
                                       MSG_WINS_PARTNERLIST_ENTRY,
                                       wcServer,
                                       wcIp,
                                       pServerList[j].etype is all ? wszPushpull : wszPull);
                                   
                    }
                    break;
                }
            case push:
                {
                    if( pServerList[j].etype is push or
                        pServerList[j].etype is all )
                    {
                        memcpy(wcServer+3, pServerList[j].wcServerName, dwServerLen*sizeof(WCHAR));
                        memcpy(wcIp+3, pServerList[j].wcServerIpAddress, wcslen(pServerList[j].wcServerIpAddress)*sizeof(WCHAR));

                        DisplayMessage(g_hModule,
                                       MSG_WINS_PARTNERLIST_ENTRY,
                                       wcServer,
                                       wcIp,
                                       pServerList[j].etype is all ? wszPushpull : wszPush);
                    }
                    break;
                }
            case both:
                {
                    if( pServerList[j].etype is all )
                    {
                        memcpy(wcServer+3, pServerList[j].wcServerName, dwServerLen*sizeof(WCHAR));
                        memcpy(wcIp+3, pServerList[j].wcServerIpAddress, wcslen(pServerList[j].wcServerIpAddress)*sizeof(WCHAR));

                        DisplayMessage(g_hModule,
                                       MSG_WINS_PARTNERLIST_ENTRY,
                                       wcServer,
                                       wcIp,
                                       wszPushpull);

                    }
                }

            }
        }
    }
    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( hPullRoot )
    {
        RegCloseKey(hPullRoot);
        hPullRoot = NULL;
    }

    if( hPushRoot )
    {
        RegCloseKey(hPushRoot);
        hPushRoot = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }
    return Status;
ErrorReturn:

    if( Status is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_NO_PARTNER);
        Status = NO_ERROR;
    }
    else
    {
        DisplayErrorMessage(EMSG_SRVR_SHOW_PARTNER,
                            Status);
    }
    goto CommonReturn;
    

}

DWORD
HandleSrvrShowReccount(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the record count based on the version(optionally)
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Address of the server whose records to be counted
        Optional : Version range. Max and Min version both in the format {high,low}
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD               Status = NO_ERROR;
    DWORD               i, j, dwNumArgs, dwTagCount = 0;
    TAG_TYPE            pttTags[] = {
                                        {WINS_TOKEN_SERVER, TRUE, FALSE},
                                        {WINS_TOKEN_MAXVER, FALSE, FALSE},
                                        {WINS_TOKEN_MINVER, FALSE, FALSE},
                                    };
    WINSINTF_VERS_NO_T  MinVer={0}, MaxVer={0};
    WINSINTF_ADD_T      WinsAdd = {0};
    WINSINTF_RECS_T     Recs = {0};
    WCHAR               wcServerIpAdd[MAX_IP_STRING_LEN+1] = {L'\0'};
    LPWSTR              pwszTemp = NULL;
    LPDWORD             pdwTagType = NULL,
                        pdwTagNum = NULL;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_SHOW_RECCOUNT_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch( pdwTagType[j] )
        {
        case 0:
            {
                struct  hostent * lpHostEnt = NULL;
                CHAR    cAddr[16];
                BYTE    pbAdd[4];
                char    szAdd[4];
                int     k = 0, l=0;
                DWORD   dwLen, nLen = 0;
                CHAR    *pTemp = NULL;
                CHAR    *pNetBios = NULL;

                if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) )
                {
                    DWORD dwIp = inet_addr(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL));
                    lpHostEnt = gethostbyaddr((char *)&dwIp, 4, AF_INET);
                    if(lpHostEnt isnot NULL )//Valid IP Address
                    {
                        wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                        break;
                    }
                    else
                    {
                        Status = WSAGetLastError();
                        goto ErrorReturn;
                    }
                }

                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 2 and
                        _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"\\\\", 2) is 0 )
                        k = 2;

                lpHostEnt = gethostbyname(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k, NULL));
                if( lpHostEnt is NULL )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_WINS_INVALID_COMPUTER_NAME,
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k);
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;                                       
                }

                memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
                for( l=0;l<4; l++)
                {
                    _itoa((int)pbAdd[l], szAdd, 10);
                    memcpy(cAddr+nLen, szAdd, strlen(szAdd));
                    nLen += strlen(szAdd);
                    *(cAddr+nLen) = '.';
                    nLen++;

                }
                *(cAddr+nLen-1) = '\0';
                {
                    LPWSTR pstr = WinsAnsiToUnicode(cAddr, NULL);
                    if (pstr != NULL)
                    {
                        wcscpy(wcServerIpAdd, pstr);
                        WinsFreeMemory(pstr);
                    }
                    else
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }
                }
                break;
            }
        case 1:
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &MaxVer);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;
            }
        case 2:
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &MinVer);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
     
    WinsAdd.IPAdd = StringToIpAddress(wcServerIpAdd);
    WinsAdd.Len = 4;
    WinsAdd.Type = 0;

    Status = WinsGetDbRecs(g_hBind, 
                           &WinsAdd, 
                           MinVer, 
                           MaxVer, 
                           &Recs);


    if( Status isnot NO_ERROR )
        goto ErrorReturn;
    
    DisplayMessage(g_hModule,
                   MSG_WINS_RECORDS_COUNT_OWNER,
                   wcServerIpAdd,
                   Recs.TotalNoOfRecs);

    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);

CommonReturn:
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;        
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    if( Recs.pRow )
    {
        WinsFreeMem(Recs.pRow);
        Recs.pRow = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SHOW_RECCOUNT,
                        Status);
    goto CommonReturn;
}


DWORD
HandleSrvrShowRecbyversion(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays records based on Version range, filtered by 16th char
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Address of the server whose records to be displayed
        Optional : Version range. Max and Min version both in the format {high,low},
                   16th character, Name etc
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD               Status = NO_ERROR;
    DWORD               i, j, dwTagCount, dwNumArgs;
    TAG_TYPE            pttTags[] = {
                                        {WINS_TOKEN_SERVER, TRUE, FALSE},
                                        {WINS_TOKEN_MAXVER, FALSE, FALSE},
                                        {WINS_TOKEN_MINVER, FALSE, FALSE},
                                        {WINS_TOKEN_NAME, FALSE, FALSE},
                                        {WINS_TOKEN_ENDCHAR, FALSE, FALSE},
                                        {WINS_TOKEN_CASE, FALSE, FALSE},
                                    };
    WCHAR               wcName[17] = {L'\0'};
    LPWSTR              pwcScope = NULL;
    CHAR                ch16thChar = 0x00;
    DWORD               dwNameLen = 0;
    WINSINTF_VERS_NO_T  MinVer={0}, MaxVer={0};
    WINSINTF_ADD_T      WinsAdd = {0};
    WINSINTF_RECS_T     Recs = {0};
    WCHAR               wcServerIpAdd[MAX_IP_STRING_LEN+1] = {L'\0'};
    WCHAR               wcFile[MAX_PATH] = {L'\0'};
    LPWSTR              pwszTemp = NULL;
    BOOL                fEndChar = FALSE,
                        fCase = FALSE,
                        fFile = FALSE,
                        fName = FALSE;
    LPDWORD             pdwTagType = NULL,
                        pdwTagNum = NULL;
    LPSTR               pszTempAddr = NULL;
    LPSTR               lpName = NULL;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_SHOW_RECBYVERSION_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    for( j=0; j<dwTagCount; j++ )
    {
        switch( pdwTagType[j] )
        {
        case 0:
            {
                if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) )
                {
                    wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;
            }
        case 1:
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &MaxVer);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;
            }
        case 2:
            {
                Status = GetVersionData(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], &MinVer);
                if( Status isnot NO_ERROR )
                    goto ErrorReturn;
                break;
            }
        case 3:
            {
                wcsncpy(wcName, ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 15);
                fName = TRUE;
                break;
            }
        case 4:
            {
                DWORD dwLen = 0, k=0;
                fEndChar = TRUE;
                dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen > 2 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                        
                }
                
                for( k=0; k<dwLen; k++ )
                {
                    WCHAR  wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][k];
                    if( towlower(wc) >= L'a' and
                        towlower(wc) <= L'z' )
                    {
                        if( towlower(wc) > L'f' )
                        {
                            Status = ERROR_INVALID_PARAMETER;
                            goto ErrorReturn;
                        }                    
                    }
                }
                ch16thChar = StringToHexA(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                break;
            }
        case 5:
            {
                WCHAR wc = L'\0';
                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) isnot 1 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][0];
                if( wc is L'0' )
                {
                    fCase = FALSE;
                }
                else if( wc is L'1' )
                {
                    fCase = TRUE;
                }
                else
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                break;

            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
    
    for( j=0; j<sizeof(pttTags)/sizeof(TAG_TYPE); j++ )
    {
        if( pttTags[j].dwRequired is TRUE and
            pttTags[j].bPresent is FALSE )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }
    
    if( fName )
    {
     
        //Process the name option if present
        lpName = WinsUnicodeToOem(wcName, NULL);
        if( lpName is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        dwNameLen = strlen(lpName);

        if( dwNameLen >= 16 )
        {
            DisplayMessage(g_hModule,
                           EMSG_SRVR_INVALID_NETBIOS_NAME);
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        if( fEndChar)
        {
            LPSTR pTemp = lpName;
            lpName = WinsAllocateMemory(17);
            if( lpName is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            strcpy(lpName, pTemp);
            for( i=strlen(pTemp); i<16; i++ )
            {
                lpName[i] = ' ';
            }
            lpName[15] = ch16thChar;
            lpName[16] = '\0';

            WinsFreeMemory(pTemp);
            dwNameLen = 16;
        }
    }   



    WinsAdd.IPAdd = StringToIpAddress(wcServerIpAdd);
    WinsAdd.Len = 4;
    WinsAdd.Type = 0;

    pszTempAddr = WinsUnicodeToOem(wcServerIpAdd, NULL);

    if( pszTempAddr is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    Status = GetDbRecs(MinVer,
                       MaxVer,
                       &WinsAdd,
                       pszTempAddr,
                       fName,
                       lpName,
                       dwNameLen,
                       FALSE,
                       0,
                       FALSE,
                       fCase,
                       fFile,
                       fFile ? wcFile : NULL);

    WinsFreeMemory(pszTempAddr);
    pszTempAddr = NULL;

    if( lpName )
    {
        WinsFreeMemory(lpName);
        lpName = NULL;
    }
    if( Status isnot NO_ERROR )
        goto ErrorReturn;
    DisplayMessage(g_hModule,
                   EMSG_WINS_ERROR_SUCCESS);
CommonReturn:
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SHOW_RECBYVERSION,
                        Status);
    goto CommonReturn;
}


DWORD
HandleSrvrShowName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays detail information for a particular name records
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Name of the records
        Optional : 16th character and Scope
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount = 0;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_NAME, TRUE, FALSE},
                                {WINS_TOKEN_ENDCHAR, FALSE, FALSE},
                                {WINS_TOKEN_SCOPE, FALSE, FALSE}
                            };
    PDWORD      pdwTagNum = NULL,
                pdwTagType = NULL;

    WCHAR       wszName[MAX_STRING_LEN+4] = {L'\0'};
    BOOL        fEndChar = FALSE;
    CHAR        ch16thChar = 0x00;
    BOOL        fScope = FALSE;
    WCHAR       wszScope[MAX_STRING_LEN] = {L'\0'};
    
    DWORD       dwStrLen = 0;
    LPWSTR      pwszTemp = NULL;
    WINSINTF_RECORD_ACTION_T    RecAction = {0};
    PWINSINTF_RECORD_ACTION_T   pRecAction = NULL;
    LPWSTR      pwszGroup = NULL,
                pwszState = NULL,
                pwszType = NULL;
    CHAR        chEndChar = (CHAR)0x00;

    WCHAR       wszGroup[50] = {L'\0'},
                wszState[50] = {L'\0'},
                wszType[50] = {L'\0'};
    DWORD       dwTempLen = 0;

    struct  tm* time = NULL;
    DWORD       dwGroup = WINS_GROUP_UNIQUE;
    DWORD       dwState = WINS_STATE_ACTIVE;
    DWORD       dwType = WINS_TYPE_STATIC;
    DWORD       dwGrouplen = 0,
                dwStatelen = 0,
                dwTypelen = 0;
    LPSTR       pszTemp = NULL;
    LPWSTR      pwszTime = NULL;
    int         iType = 1;

    memset(&RecAction, 0x00, sizeof(WINSINTF_RECORD_ACTION_T));
    RecAction.fStatic = TRUE;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SHOW_NAME_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;

    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    i = dwTagCount;
    
    for( j=0; j<i; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                DWORD dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dwLen = ( 255 < dwLen ) ? 255 : dwLen;
                memcpy(wszName, 
                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 
                       dwLen*sizeof(WCHAR));
                wszName[dwLen] = L'\0';               
                break;
            }
        case 1:
            {
                DWORD dwLen = 0, k=0;
                fEndChar = TRUE;
                dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                if( dwLen > 2 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                        
                }
                
                for( k=0; k<dwLen; k++ )
                {
                    WCHAR  wc = ppwcArguments[dwCurrentIndex+pdwTagNum[j]][k];
                    if( towlower(wc) >= L'a' and
                        towlower(wc) <= L'z' )
                    {
                        if( towlower(wc) > L'f' )
                        {
                            Status = ERROR_INVALID_PARAMETER;
                            goto ErrorReturn;
                        }                    
                    }
                }
                ch16thChar = StringToHexA(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                break;
            }
        case 2:
            {
                DWORD dwLen = wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                fScope = TRUE;
                if( dwLen is 0 )
                {
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;
                }
                dwLen = ( 255 < dwLen ) ? 255 : dwLen;
                memcpy(wszScope,
                       ppwcArguments[dwCurrentIndex+pdwTagNum[j]], 
                       dwLen*sizeof(WCHAR));
                wszScope[dwLen] = L'\0';               
                break;
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }
           
    _wcsupr(wszName);
    _wcsupr(wszScope);
      
    wszName[16] = L'\0';

    pszTemp = WinsUnicodeToOem(wszName, NULL);

    if( pszTemp is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwStrLen = strlen(pszTemp);


    if( dwStrLen >= 16 )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_NETBIOS_NAME);
        Status = ERROR_INVALID_PARAMETER;
        WinsFreeMemory(pszTemp);
        pszTemp = NULL;
        goto ErrorReturn;
    }

    RecAction.pName = WinsAllocateMemory(273);

    if( RecAction.pName is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    strncpy(RecAction.pName, pszTemp, 16);
    
    WinsFreeMemory(pszTemp);
    pszTemp = NULL;

    for( i = dwStrLen; i<16; i++ )
    {
        RecAction.pName[i] = ' ';        
    }

    if( fEndChar )
    {
        RecAction.pName[15] = ch16thChar;
    }
    if( fEndChar and 
        ch16thChar is 0x00 )
        RecAction.pName[15] = 0x00;
    RecAction.pName[16] = '\0';

    dwStrLen = 16;

    if( fScope )
    {
        DWORD dwLen;

        RecAction.pName[dwStrLen] = '.';
        
        pszTemp = WinsUnicodeToOem(wszScope, NULL);
        
        if( pszTemp is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        dwLen = strlen(pszTemp);
        dwLen = ( 255 - dwStrLen < dwLen ) ? 255 - dwStrLen : dwLen;
        
        strncpy(RecAction.pName + dwStrLen + 1, pszTemp, dwLen);

        WinsFreeMemory(pszTemp);
        pszTemp = NULL;

        RecAction.pName[dwLen + dwStrLen + 1] = '\0';
        if( fEndChar and 
            ch16thChar is 0x00 )
            dwStrLen = 16+dwLen+1;
        else
            dwStrLen = strlen(RecAction.pName);
    }
    else
    {

        RecAction.pName[dwStrLen] = '\0';
    }


    RecAction.NameLen = dwStrLen;

    RecAction.Cmd_e = WINSINTF_E_QUERY;

    RecAction.OwnerId = StringToIpAddress(g_ServerIpAddressUnicodeString);
   
    RecAction.NameLen = dwStrLen;
    pRecAction = &RecAction;

    Status = WinsRecordAction(g_hBind, &pRecAction);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    RecAction.pName[RecAction.NameLen] = L'\0';

    memset(wszName, 0x00, MAX_STRING_LEN*sizeof(WCHAR));
    
    if( pRecAction->NameLen >= 16 )
    {
        chEndChar = pRecAction->pName[15];
        pRecAction->pName[15] = 0x00;
    }
    else
    {
        chEndChar = pRecAction->pName[pRecAction->NameLen];
        pRecAction->pName[pRecAction->NameLen] = 0x00;
    }
    
    pwszTemp = WinsOemToUnicode(pRecAction->pName, NULL);
    
    if( pwszTemp is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }
    
    wcscpy(wszName, pwszTemp);

    WinsFreeMemory(pwszTemp);
    pwszTemp = NULL;

    for( i=wcslen(wszName); i<16; i++ )
    {
        wszName[i] = L' ';
    }

    wszName[15] = L'[';
    WinsHexToString(wszName+16, (LPBYTE)&chEndChar, 1);
    wszName[18] = L'h';
    wszName[19] = L']';

    if( pRecAction->NameLen > 16 )
    {
        pwszTemp = WinsOemToUnicode(pRecAction->pName+16, NULL);
        
        if( pwszTemp is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        wcscpy(wszName + 20 , pwszTemp);
        WinsFreeMemory(pwszTemp);
        pwszTemp = NULL;
        wszName[wcslen(wszName)] = L'\0';
    }
    else
    {
        wszName[20] = L'\0';
    }
    
    if( pRecAction->pName[15] is 0x1C )
    {
        pwszGroup = L"DOMAIN NAME";
        dwGroup = WINS_GROUP_DOMAIN;
    }
    else if( pRecAction->TypOfRec_e is WINSINTF_E_UNIQUE )
    {
        pwszGroup = L"UNIQUE";
        dwGroup = WINS_GROUP_UNIQUE;
    }
    else if( pRecAction->TypOfRec_e is WINSINTF_E_NORM_GROUP )
    {
        pwszGroup = L"GROUP";
        dwGroup = WINS_GROUP_GROUP;
    }
    else if( pRecAction->TypOfRec_e is WINSINTF_E_SPEC_GROUP )
    {
        pwszGroup = L"INTERNET GROUP";
        dwGroup = WINS_GROUP_INTERNET;
    }
    else
    {
        pwszGroup = L"MULTIHOMED";
        dwGroup = WINS_GROUP_MULTIHOMED;
    }

    //Load the group string
    {
        dwGrouplen = LoadStringW(g_hModule,
                                dwGroup,
                                wszGroup,
                                sizeof(wszGroup)/sizeof(WCHAR));

        if( dwGrouplen is 0 )
            wcscpy(wszGroup, pwszGroup);
    }

    pwszTime = GetDateTimeString(pRecAction->TimeStamp,
                                 FALSE,
                                 &iType);
    
    if( pRecAction->State_e is WINSINTF_E_ACTIVE )
    {
        pwszState = L"ACTIVE";
        dwState = WINS_STATE_ACTIVE;
    }
    else if( pRecAction->State_e is WINSINTF_E_RELEASED )
    {
        dwState = WINS_STATE_RELEASED;
        pwszState = L"RELEASED";
    }
    else
    {
        dwState = WINS_STATE_TOMBSTONE;
        pwszState = L"TOMBSTONE";
    }

    //Load the State string
    {
        dwStatelen = LoadStringW(g_hModule,
                                dwState,
                                wszState,
                                sizeof(wszState)/sizeof(WCHAR));

        if( dwStatelen is 0 )
            wcscpy(wszState, pwszState);
    }



    if( pRecAction->fStatic )
    {
        dwType = WINS_TYPE_STATIC;
        pwszType = L"STATIC";
    }
    else
    {
        dwType = WINS_TYPE_DYNAMIC;
        pwszType = L"DYNAMIC";
    }

    //Load the State string
    {
        dwTypelen = LoadStringW(g_hModule,
                               dwType,
                               wszType,
                               sizeof(wszType)/sizeof(WCHAR));

        if( dwTypelen is 0 )
            wcscpy(wszType, pwszType);
    }
    
    DisplayMessage( g_hModule,
                    MSG_WINS_DISPLAY_NAME,
                    wszName,
                    pRecAction->NodeTyp,
                    wszState,
                    iType ? wszInfinite : pwszTime,
                    wszGroup,
                    pRecAction->VersNo.HighPart,
                    pRecAction->VersNo.LowPart,
                    wszType);
    
    if( pwszTime )
    {
        WinsFreeMemory(pwszTime);
        pwszTime = NULL;
    }

    if ( ( pRecAction->pName[15] isnot 0x1C and
           pRecAction->pName[15] isnot 0x1E ) and
         ( pRecAction->TypOfRec_e is WINSINTF_E_UNIQUE or
            pRecAction->TypOfRec_e is WINSINTF_E_NORM_GROUP )
       )
    {      
        DisplayMessage(g_hModule,
                       MSG_WINS_IPADDRESS_STRING,
                       IpAddressToString(pRecAction->Add.IPAdd));        
    }
    else
    {
       for (i=0; i<pRecAction->NoOfAdds; )
       {
           DisplayMessage(g_hModule,
                          MSG_WINS_OWNER_ADDRESS,
                          IpAddressToString((pRecAction->pAdd + i++)->IPAdd));
           DisplayMessage(g_hModule,
                          MSG_WINS_MEMBER_ADDRESS,
                          IpAddressToString((pRecAction->pAdd + i++)->IPAdd));
       }
    }


    //If UNIQUE, look for 0x00 and 0x03 records also
    if( ( pRecAction->TypOfRec_e is WINSINTF_E_UNIQUE or
          pRecAction->TypOfRec_e is WINSINTF_E_MULTIHOMED ) and
        fEndChar is FALSE )
    {
        
        DWORD dwNameLen = RecAction.NameLen;

        DisplayMessage(g_hModule,
                       WINS_FORMAT_LINE);

        RecAction.pName[15] = 0x00;
        RecAction.NameLen = 16;
        pRecAction = &RecAction;

        Status = WinsRecordAction(g_hBind, &pRecAction);

        if( Status is NO_ERROR )
        {
        
            RecAction.pName[RecAction.NameLen] = L'\0';

            memset(wszName, 0x00, MAX_STRING_LEN*sizeof(WCHAR));
            
            pwszTemp = WinsOemToUnicode(pRecAction->pName, NULL);
            if( pwszTemp is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            wcscpy(wszName, pwszTemp);
            
            WinsFreeMemory(pwszTemp);
            pwszTemp = NULL;

            for( i=wcslen(wszName); i<16; i++ )
            {
                wszName[i] = L' ';
            }

            for( i=wcslen(wszName)+3; j>=15; j-- )
                wszName[j-1] = wszName[j-4];
            
            wszName[15] = L'[';
            WinsHexToString(wszName+16, (LPBYTE)(pRecAction->pName+15), 1);
            wszName[18] = L'h';
            wszName[19] = L']';

            if( pRecAction->NameLen > 16 )
            {
                pwszTemp = WinsOemToUnicode(pRecAction->pName+16, NULL);
                if( pwszTemp is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }

                wcscpy(wszName + 20 , pwszTemp);
                WinsFreeMemory(pwszTemp);
                pwszTemp = NULL;
                wszName[wcslen(wszName)] = L'\0';
            }
            else
            {
                wszName[20] = L'\0';
            }

            iType = 1;
            pwszTime = GetDateTimeString(pRecAction->TimeStamp,
                                         FALSE,
                                         &iType);

            DisplayMessage( g_hModule,
                            MSG_WINS_DISPLAY_NAME,
                            wszName,
                            pRecAction->NodeTyp,
                            wszState,
                            iType ? wszInfinite : pwszTime,
                            wszGroup,
                            pRecAction->VersNo.HighPart,
                            pRecAction->VersNo.LowPart,
                            wszType);
            
            if( pwszTime )
            {
                WinsFreeMemory(pwszTime);
                pwszTime = NULL;
            }

            if( pRecAction->TypOfRec_e is WINSINTF_E_UNIQUE ) 
            {      
                DisplayMessage(g_hModule,
                               MSG_WINS_IPADDRESS_STRING,
                               IpAddressToString(pRecAction->Add.IPAdd));        
            }
        
            else
            {
               for (i=0; i<pRecAction->NoOfAdds; )
               {
                   DisplayMessage(g_hModule,
                                  MSG_WINS_OWNER_ADDRESS,
                                  IpAddressToString((pRecAction->pAdd + i++)->IPAdd));
                   DisplayMessage(g_hModule,
                                  MSG_WINS_MEMBER_ADDRESS,
                                  IpAddressToString((pRecAction->pAdd + i++)->IPAdd));
                }
            }                    
            
        }
        
        
        DisplayMessage(g_hModule,
                       WINS_FORMAT_LINE);

        //Now Look for 0x03 record
        if( fScope )
        {
            DWORD dwLen;
            dwStrLen = 16;
            RecAction.pName[dwStrLen] = '.';
            pszTemp = WinsUnicodeToOem(wszScope, NULL);
            if( pszTemp is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            dwLen = strlen(pszTemp);
            dwLen = ( 255 - dwStrLen < dwLen ) ? 255 - dwStrLen : dwLen;
            
            strncpy(RecAction.pName + dwStrLen + 1, pszTemp, dwLen);
            
            WinsFreeMemory(pszTemp);
            pszTemp = NULL;

            RecAction.pName[dwLen + dwStrLen + 1] = '\0';
            if( fEndChar and 
                ch16thChar is 0x00 )
                dwStrLen = 16+dwLen+1;
            else
                dwStrLen = strlen(RecAction.pName);
        }
        else
        {

            RecAction.pName[dwStrLen] = '\0';
        }


        RecAction.pName[15] = 0x03;
        RecAction.NameLen = dwNameLen;

        pRecAction = &RecAction;
               
        Status = WinsRecordAction(g_hBind, &pRecAction);

        if( Status is NO_ERROR )
        {       
            
            CHAR chEndChar = pRecAction->pName[15];

            RecAction.pName[RecAction.NameLen] = L'\0';

            memset(wszName, 0x00, MAX_STRING_LEN*sizeof(WCHAR));

            if( pRecAction->NameLen >= 16 )
            {
                chEndChar = pRecAction->pName[15];
                pRecAction->pName[15] = 0x00;
            }
            else
            {
                chEndChar = pRecAction->pName[pRecAction->NameLen];
                pRecAction->pName[pRecAction->NameLen] = 0x00;
            }
            
            pwszTemp = WinsOemToUnicode(pRecAction->pName, NULL);
            
            if( pwszTemp is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }
            
            
            wcscpy(wszName, pwszTemp);
            
            WinsFreeMemory(pwszTemp);
            pwszTemp = NULL;

            for( i = wcslen(wszName); i < 16; i++ )
            {
                wszName[i] = L' ';
            }

            for( i=wcslen(wszName)+3; j>=15; j-- )
                wszName[j-1] = wszName[j-4];

            wszName[15] = L'[';
            WinsHexToString(wszName+16, (LPBYTE)&chEndChar, 1);
            wszName[18] = L'h';
            wszName[19] = L']';

            if( pRecAction->NameLen > 16 )
            {
                pwszTemp = WinsOemToUnicode(pRecAction->pName+16, NULL);
                if( pwszTemp is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                wcscpy(wszName + 20 , pwszTemp);
                
                WinsFreeMemory(pwszTemp);
                pwszTemp = NULL;
                
                wszName[wcslen(wszName)] = L'\0';
            }
            else
            {
                wszName[20] = L'\0';
            }
    
            iType = 1;
            pwszTime = GetDateTimeString(pRecAction->TimeStamp,
                                         FALSE,
                                         &iType);

            DisplayMessage(g_hModule,
                           MSG_WINS_DISPLAY_NAME,
                           wszName,
                           pRecAction->NodeTyp,
                           wszState,
                           iType ? wszInfinite : pwszTime,
                           wszGroup,
                           pRecAction->VersNo.HighPart,
                           pRecAction->VersNo.LowPart,
                           wszType);
    
            if( pwszTime )
            {
                WinsFreeMemory(pwszTime);
                pwszTime = NULL;
            }

            if( pRecAction->TypOfRec_e is WINSINTF_E_UNIQUE ) 
            {      
                DisplayMessage(g_hModule,
                               MSG_WINS_IPADDRESS_STRING,
                               IpAddressToString(pRecAction->Add.IPAdd));        
            }
        
            else
            {
               for (i=0; i<pRecAction->NoOfAdds; )
               {
                   DisplayMessage(g_hModule,
                                  MSG_WINS_OWNER_ADDRESS,
                                  IpAddressToString((pRecAction->pAdd + i++)->IPAdd));
                   DisplayMessage(g_hModule,
                                  MSG_WINS_MEMBER_ADDRESS,
                                  IpAddressToString((pRecAction->pAdd + i++)->IPAdd));
                }
            }
        }
    }

CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    if( pszTemp )
    {
        WinsFreeMemory(pszTemp);
        pszTemp = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    if( RecAction.pName )
    {
        WinsFreeMemory(RecAction.pName);
        RecAction.pName = NULL;
    }
    return Status;
ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SHOW_NAME,
                        Status);
    goto CommonReturn;
}


DWORD
HandleSrvrShowServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the current WINS server
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/
{
    DisplayMessage(g_hModule,
                   MSG_WINS_SERVER_NAME,
                   g_ServerNameUnicode,
                   g_ServerIpAddressUnicodeString);
    return NO_ERROR;
                   
}


DWORD
HandleSrvrShowStatistics(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the Server statistics
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/
{

    DWORD                   Status = NO_ERROR;
    WINSINTF_RESULTS_T      Results = {0};
    WINSINTF_RESULTS_NEW_T  ResultsN = {0};
    WCHAR                   IpAddress[33] = {L'\0'};
    WCHAR                   RepCount[25] = {L'\0'};
    WCHAR                   Buffer[8] = {L'\0'};
    BOOL                    fNew = TRUE;
    DWORD                   i = 0,
                            k = 0;

    ResultsN.WinsStat.NoOfPnrs = 0;
    ResultsN.WinsStat.pRplPnrs = NULL;
    ResultsN.pAddVersMaps = NULL;

    Status = WinsStatusNew(g_hBind, WINSINTF_E_STAT, &ResultsN);
    
    if( Status is RPC_S_PROCNUM_OUT_OF_RANGE )
    {
        //Try old API
        Results.WinsStat.NoOfPnrs = 0;
        Results.WinsStat.pRplPnrs = 0;
        Status = WinsStatus(g_hBind, WINSINTF_E_CONFIG_ALL_MAPS, &Results);
        fNew = FALSE;
    }
    
    if( Status isnot NO_ERROR )
    {
        DisplayErrorMessage(EMSG_SRVR_SHOW_STATISTICS,
                            Status);
    }

    if( fNew )
    {
        DisplayMessage(g_hModule, 
                       MSG_WINS_TIMESTAMP,
                       TMSTN.WinsStartTime.wMonth,
                       TMSTN.WinsStartTime.wDay,
                       TMSTN.WinsStartTime.wYear,
                       TMSTN.WinsStartTime.wHour,
                       TMSTN.WinsStartTime.wMinute,
                       TMSTN.WinsStartTime.wSecond
                       );

        DisplayMessage(g_hModule,
                       MSG_WINS_LAST_INIT,
                       TIME_ARGSN(LastInitDbTime));

        DisplayMessage(g_hModule,
                       MSG_WINS_PLANNED_SCV,
                       TIME_ARGSN(LastPScvTime));
    
        DisplayMessage(g_hModule,
                       MSG_WINS_TRIGGERED_SCV,
                       TIME_ARGSN(LastATScvTime));

        DisplayMessage(g_hModule,
                       MSG_WINS_TOMBSTONE_SCV,
                       TIME_ARGSN(LastTombScvTime));

        DisplayMessage(g_hModule,
                       MSG_WINS_REPLICA_VERIFICATION,
                       TIME_ARGSN(LastVerifyScvTime));

        DisplayMessage(g_hModule,
                       MSG_WINS_PLANNED_REPLICATION,
                       TMSTN.LastPRplTime.wMonth,
                       TMSTN.LastPRplTime.wDay,
                       TMSTN.LastPRplTime.wYear,
                       TMSTN.LastPRplTime.wHour,
                       TMSTN.LastPRplTime.wMinute,
                       TMSTN.LastPRplTime.wSecond
                       );

        DisplayMessage(g_hModule,
                       MSG_WINS_TRIGGERED_REPLICATION,
                       TMSTN.LastATRplTime.wMonth,
                       TMSTN.LastATRplTime.wDay,
                       TMSTN.LastATRplTime.wYear,
                       TMSTN.LastATRplTime.wHour,
                       TMSTN.LastATRplTime.wMinute,
                       TMSTN.LastATRplTime.wSecond
                       );

        DisplayMessage(g_hModule,
                       MSG_WINS_RESET_COUNTER,
                       TIME_ARGSN(CounterResetTime));

        DisplayMessage(g_hModule, WINS_FORMAT_LINE);
        DisplayMessage(g_hModule,
                       MSG_WINS_COUNTER_INFORMATION,
                       ResultsN.WinsStat.Counters.NoOfUniqueReg,
                       ResultsN.WinsStat.Counters.NoOfGroupReg,
                       ResultsN.WinsStat.Counters.NoOfSuccQueries,
                       ResultsN.WinsStat.Counters.NoOfFailQueries,
                       ResultsN.WinsStat.Counters.NoOfUniqueRef,
                       ResultsN.WinsStat.Counters.NoOfGroupRef,
                       ResultsN.WinsStat.Counters.NoOfSuccRel,
                       ResultsN.WinsStat.Counters.NoOfFailRel,
                       ResultsN.WinsStat.Counters.NoOfUniqueCnf,
                       ResultsN.WinsStat.Counters.NoOfGroupCnf
                       );
    
        if (ResultsN.WinsStat.NoOfPnrs)
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PARTNER_TABLE);

            for (i =0; i < ResultsN.WinsStat.NoOfPnrs; i++)
            {
                LPTSTR pstr;

                for(k=0; k<32; k++)
                {
                    IpAddress[k] = L' ';
                }
                IpAddress[32] = L'\0';
                for(k=0; k<24; k++)
                    RepCount[k] = L' ';
                RepCount[24] = L'\0';
            
                pstr = IpAddressToString((ResultsN.WinsStat.pRplPnrs + i)->Add.IPAdd);
                if (pstr == NULL)
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                wcscpy(IpAddress+8, pstr);
                IpAddress[wcslen(IpAddress)] = L' ';
            
                _itow((ResultsN.WinsStat.pRplPnrs + i)->NoOfRpls, Buffer, 10);
                wcscpy(RepCount+8, Buffer);
                RepCount[wcslen(RepCount)] = L' ';

                DisplayMessage(g_hModule,
                               MSG_WINS_PARTNER_INFO,
                               IpAddress,
                               RepCount,
                               (ResultsN.WinsStat.pRplPnrs + i)->NoOfCommFails
                               );
            }
        }

        WinsFreeMem(ResultsN.pAddVersMaps);
        ResultsN.pAddVersMaps = NULL;
        WinsFreeMem(ResultsN.WinsStat.pRplPnrs);
        ResultsN.WinsStat.pRplPnrs = NULL;
    }
    else
    {
        DisplayMessage(g_hModule, 
                       MSG_WINS_TIMESTAMP,
                       TMST.WinsStartTime.wMonth,
                       TMST.WinsStartTime.wDay,
                       TMST.WinsStartTime.wYear,
                       TMST.WinsStartTime.wHour,
                       TMST.WinsStartTime.wMinute,
                       TMST.WinsStartTime.wSecond
                       );

        DisplayMessage(g_hModule,
                       MSG_WINS_LAST_INIT,
                       TIME_ARGS(LastInitDbTime));

        DisplayMessage(g_hModule,
                       MSG_WINS_PLANNED_SCV,
                       TIME_ARGS(LastPScvTime));
    
        DisplayMessage(g_hModule,
                       MSG_WINS_TRIGGERED_SCV,
                       TIME_ARGS(LastATScvTime));

        DisplayMessage(g_hModule,
                       MSG_WINS_TOMBSTONE_SCV,
                       TIME_ARGS(LastTombScvTime));

        DisplayMessage(g_hModule,
                       MSG_WINS_REPLICA_VERIFICATION,
                       TIME_ARGS(LastVerifyScvTime));

        DisplayMessage(g_hModule,
                       MSG_WINS_PLANNED_REPLICATION,
                       TMST.LastPRplTime.wMonth,
                       TMST.LastPRplTime.wDay,
                       TMST.LastPRplTime.wYear,
                       TMST.LastPRplTime.wHour,
                       TMST.LastPRplTime.wMinute,
                       TMST.LastPRplTime.wSecond
                       );

        DisplayMessage(g_hModule,
                       MSG_WINS_TRIGGERED_REPLICATION,
                       TMST.LastATRplTime.wMonth,
                       TMST.LastATRplTime.wDay,
                       TMST.LastATRplTime.wYear,
                       TMST.LastATRplTime.wHour,
                       TMST.LastATRplTime.wMinute,
                       TMST.LastATRplTime.wSecond
                       );

        DisplayMessage(g_hModule,
                       MSG_WINS_RESET_COUNTER,
                       TIME_ARGS(CounterResetTime));

        DisplayMessage(g_hModule, WINS_FORMAT_LINE);
        DisplayMessage(g_hModule,
                       MSG_WINS_COUNTER_INFORMATION,
                       Results.WinsStat.Counters.NoOfUniqueReg,
                       Results.WinsStat.Counters.NoOfGroupReg,
                       Results.WinsStat.Counters.NoOfSuccQueries,
                       Results.WinsStat.Counters.NoOfFailQueries,
                       Results.WinsStat.Counters.NoOfUniqueRef,
                       Results.WinsStat.Counters.NoOfGroupRef,
                       Results.WinsStat.Counters.NoOfSuccRel,
                       Results.WinsStat.Counters.NoOfFailRel,
                       Results.WinsStat.Counters.NoOfUniqueCnf,
                       Results.WinsStat.Counters.NoOfGroupCnf
                       );
    
        if (Results.WinsStat.NoOfPnrs)
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PARTNER_TABLE);

            for (i =0; i < Results.WinsStat.NoOfPnrs; i++)
            {

                for(k=0; k<32; k++)
                {
                    IpAddress[k] = L' ';
                }
                IpAddress[32] = L'\0';
                for(k=0; k<24; k++)
                    RepCount[k] = L' ';
                RepCount[24] = L'\0';
            
                wcscpy(IpAddress+8, IpAddressToString((Results.WinsStat.pRplPnrs + i)->Add.IPAdd));
                IpAddress[wcslen(IpAddress)] = L' ';
            
                _itow((Results.WinsStat.pRplPnrs + i)->NoOfRpls, Buffer, 10);
                wcscpy(RepCount+8, Buffer);
                RepCount[wcslen(RepCount)] = L' ';

                DisplayMessage(g_hModule,
                               MSG_WINS_PARTNER_INFO,
                               IpAddress,
                               RepCount,
                               (Results.WinsStat.pRplPnrs + i)->NoOfCommFails
                               );
            }
        }

        WinsFreeMem(Results.WinsStat.pRplPnrs);
        Results.WinsStat.pRplPnrs = NULL;

    }

    DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    return Status;
                   
}

DWORD
HandleSrvrShowVersion(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displas the current version counter value.
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD               Status = NO_ERROR;
    WINSINTF_RESULTS_T  Results;

    Results.AddVersMaps[0].Add.Len   = 4;
    Results.AddVersMaps[0].Add.Type  = 0;
    Results.AddVersMaps[0].Add.IPAdd = StringToIpAddress(g_ServerIpAddressUnicodeString);
    
    Results.WinsStat.NoOfPnrs = 0;
    Results.WinsStat.pRplPnrs = NULL;
    Status = WinsStatus(g_hBind, WINSINTF_E_ADDVERSMAP, &Results);
    
    if( Status isnot NO_ERROR )
    {
        DisplayErrorMessage(EMSG_SRVR_SHOW_VERSION,
                            Status);
        return Status;
    }
    

    DisplayMessage(g_hModule,
                   MSG_WINS_VERSION_INFO,
                   g_ServerIpAddressUnicodeString,
                   Results.AddVersMaps[0].VersNo.HighPart,
                   Results.AddVersMaps[0].VersNo.LowPart);

    return Status;
       
}

DWORD
HandleSrvrShowVersionmap(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the version mapping
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD                  Status = NO_ERROR;
    WINSINTF_RESULTS_T     Results = {0};
    WINSINTF_RESULTS_NEW_T ResultsN = {0};
    LPSTR                  pszIp = NULL;


    ResultsN.WinsStat.NoOfPnrs = 0;
    ResultsN.WinsStat.pRplPnrs = NULL;
    
    pszIp = WinsUnicodeToOem(g_ServerIpAddressUnicodeString, NULL);
    if( pszIp is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_OUT_OF_MEMORY);
        Status = ERROR_NOT_ENOUGH_MEMORY;
        return Status;
    }

    Status = GetStatus(TRUE, (LPVOID)&ResultsN, TRUE, TRUE, pszIp);
    
    if( Status is RPC_S_PROCNUM_OUT_OF_RANGE )
    {
        //Try old API
        Results.WinsStat.NoOfPnrs = 0;
        Results.WinsStat.pRplPnrs = 0;
        Status = GetStatus(TRUE, (LPVOID)&Results, FALSE, TRUE, pszIp);
    }

    WinsFreeMemory(pszIp);
    pszIp = NULL;
    
    if( ResultsN.pAddVersMaps )
    {
        WinsFreeMem(ResultsN.pAddVersMaps);
        ResultsN.pAddVersMaps = NULL;
    }

    if( Status isnot NO_ERROR )
    {
        DisplayErrorMessage(EMSG_SRVR_SHOW_VERSIONMAP,
                            Status);
        
        return Status;
    }
    DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);
    return Status;

}

DWORD
HandleSrvrShowPartnerproperties(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the default partner properties
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        NONE.
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    HKEY        hServer = NULL,
                hDefaultPull = NULL,
                hDefaultPush = NULL,
                hPullRoot = NULL,
                hPushRoot = NULL,
                hPartner = NULL,
                hParameter = NULL;
    LPWSTR      pTemp = NULL,
                pServerList = NULL;
    WCHAR       wcBuffer[255] = {L'\0'};

    DWORD       dwRplWCnfPnrs = 0,
                dwMigrate = 0,
                dwData = 0,
                i = 0,
                dwPersonaMode = 0,
                dwSelfFndPnrs = 0;

    DWORD       dwType = REG_DWORD;
    DWORD       dwSize = sizeof(DWORD);
    LPBYTE      pbData = NULL;



    if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    Status = RegOpenKeyEx(hServer,
                          PARAMETER,
                          0,
                          KEY_READ,
                          &hParameter);

    if( Status isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_RPL_ONLY_W_CNF_PNRS_NM,
                             0,
                             &dwType,
                             (LPBYTE)&dwRplWCnfPnrs,
                             &dwSize);
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_REPLICATE_STATE,
                       dwRplWCnfPnrs ? wszEnable : wszDisable);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_REPLICATE_STATE,
                       wszUnknown);
    }

    dwMigrate = 0;
    dwSize = sizeof(DWORD);

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_MIGRATION_ON_NM,
                             0,
                             &dwType,
                             (LPBYTE)&dwMigrate,
                             &dwSize);
    if( Status is NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_MIGRATE_STATE,
                       dwMigrate ? wszEnable : wszDisable);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_MIGRATE_STATE,
                       wszUnknown);
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_SRVR_AUTOCONFIGURE);

    Status = RegQueryValueEx(hParameter,
                             WINSCNF_USE_SELF_FND_PNRS_NM,
                             0,
                             &dwType,
                             (LPBYTE)&dwSelfFndPnrs,
                             &dwSize);
    if( Status isnot NO_ERROR )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_SELFFINDPNRS_STATE,
                       wszUnknown);
                       
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_SELFFINDPNRS_STATE,
                       dwSelfFndPnrs ? wszEnable : wszDisable);
        if( dwSelfFndPnrs > 0 )
        {
            dwData = 0;
            dwSize = sizeof(DWORD);
            Status = RegQueryValueEx(hParameter,
                                     WINSCNF_MCAST_INTVL_NM,
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwSize);
            if(Status is NO_ERROR )
            {
                LPWSTR  pwszTime = MakeTimeString(dwData);
                if( pwszTime is NULL )
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorReturn;
                }
                DisplayMessage(g_hModule,
                               MSG_SRVR_MCAST_INTERVAL,
                               pwszTime);
                WinsFreeMemory(pwszTime);
                pwszTime = NULL;

            }
            else
            {
                DisplayMessage(g_hModule,
                               MSG_SRVR_MCAST_INTERVAL,
                               wszUnknown);
            }

            dwData = 0;
            dwSize = sizeof(DWORD);
            Status = RegQueryValueEx(hParameter,
                                     WINSCNF_MCAST_TTL_NM,
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwData,
                                     &dwSize);
            if( Status is NO_ERROR )
            {
                WCHAR Buffer[10] = {L'\0'};
                _itow(dwData, Buffer, 10);
                DisplayMessage(g_hModule,
                               MSG_SRVR_MCAST_TTL,
                               Buffer);
            }
            else
            {
                DisplayMessage(g_hModule,
                               MSG_SRVR_MCAST_TTL,
                               wszUnknown);
            }

        }
    }

    //Display PNG Servers

    DisplayMessage(g_hModule,
                   WINS_FORMAT_LINE);

    Status = RegOpenKeyEx(hServer,
                          PARTNERROOT,
                          0,
                          KEY_READ,
                          &hPartner);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    dwSize = sizeof(DWORD);
    Status = RegQueryValueEx(hPartner,
                         TEXT(WINSCNF_PERSONA_MODE_NM),
                         0,
                         &dwType,
                         (LPVOID)&dwPersonaMode,
                         &dwSize);

    DisplayMessage(g_hModule,
                   dwPersonaMode == PERSMODE_NON_GRATA ?
                   MSG_WINS_PNGSERVER_TABLE : MSG_WINS_PGSERVER_TABLE);

    dwSize = 0;
    Status = RegQueryValueEx(hPartner,
                             dwPersonaMode == PERSMODE_NON_GRATA ? PNGSERVER : PGSERVER,
                             0,
                             &dwType,
                             NULL,
                             &dwSize);

    if( dwSize <= 2 )
    {
        DisplayMessage(g_hModule,
            dwPersonaMode == PERSMODE_NON_GRATA ? MSG_WINS_NO_PNGSERVER : MSG_WINS_NO_PGSERVER);
    }

    else
    {
        pbData = WinsAllocateMemory(dwSize);

        if( pbData is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
                         
        Status = RegQueryValueEx(hPartner,
                                 dwPersonaMode == PERSMODE_NON_GRATA ? PNGSERVER : PGSERVER,
                                 0,
                                 &dwType,
                                 pbData,
                                 &dwSize);

        if( Status isnot NO_ERROR )
            goto ErrorReturn;    



        pServerList = (LPWSTR)pbData;

        i = 0;
        while(TRUE)
        {
            if ( i+1 < dwSize/sizeof(WCHAR) )
            {
                if( pServerList[i] is L'\0' and 
                    pServerList[i+1] isnot L'\0' )
                {
                    pServerList[i] = L',';
                }
                i++;
            }
            else
                break;
            
        }

        pTemp = wcstok(pServerList, L",");

        while(pTemp isnot NULL )
        {
            DisplayMessage(g_hModule,
                           dwPersonaMode == PERSMODE_NON_GRATA ? MSG_WINS_PNGSERVER_ENTRY : MSG_WINS_PGSERVER_ENTRY,
                           pTemp);
            pTemp = wcstok(NULL, L",");
        }
    }

    Status = RegOpenKeyEx(hServer,
                          DEFAULTPULL,
                          0,
                          KEY_READ,
                          &hDefaultPull);
    
    if( Status is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       MSG_NO_DEFAULT_PULL);
    }
    else if( Status isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    Status = RegOpenKeyEx(hServer,
                          PULLROOT,
                          0,
                          KEY_READ,
                          &hPullRoot);

    if( Status is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       MSG_NO_DEFAULT_PULL);
    }
    else if( Status isnot NO_ERROR )
        goto ErrorReturn;


    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_SRVR_PULL_INFO);

    dwData = 0;
	dwSize = sizeof(DWORD);


    if( hPullRoot isnot NULL )
    {
        Status = RegQueryValueEx(hPullRoot,
                                 PERSISTENCE,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_PERSISTENCE_STATE,
                           dwData ? wszEnable : wszDisable);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_PERSISTENCE_STATE,
                           wszUnknown);
        }

        dwData = 0;
		dwSize = sizeof(DWORD);

        Status = RegQueryValueEx(hPullRoot,
                                 WINSCNF_INIT_TIME_RPL_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);
    
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_INITTIMEREPL_STATE,
                           dwData ? wszEnable : wszDisable);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_INITTIMEREPL_STATE,
                           wszUnknown);
        }
    }

    dwData = 0;
    dwSize = 255;

    if( hDefaultPull isnot NULL )
    {
        Status = RegQueryValueEx(hDefaultPull,
                                 WINSCNF_SP_TIME_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)wcBuffer,
                                 &dwSize);
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_STARTTIME,
                           wcBuffer);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_STARTTIME,
                           wszUnknown);
        }
    
        dwSize = sizeof(DWORD);
        dwData = 0;

        Status = RegQueryValueEx(hDefaultPull,
                                 WINSCNF_RPL_INTERVAL_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            LPWSTR  pwszDayString = MakeDayTimeString(dwData);
            DisplayMessage(g_hModule,
                           MSG_WINS_PULL_REPLINTERVAL,
                           MakeDayTimeString(dwData));
            WinsFreeMemory(pwszDayString);
            pwszDayString = NULL;
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PULL_REPLINTERVAL,
                           wszUnknown);
        }
    }

    dwData = 0;
	dwSize = sizeof(DWORD);

    if( hPullRoot isnot NULL )
    {
        Status = RegQueryValueEx(hPullRoot,
                                 WINSCNF_RETRY_COUNT_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);
    
        if( Status is NO_ERROR )
        {
            WCHAR   Buffer[20];
            _itow(dwData, Buffer, 10);

            DisplayMessage(g_hModule,
                           MSG_WINS_PULL_RETRYCOUNT,
                           Buffer);

        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PULL_RETRYCOUNT,
                           wszUnknown);
        }
    }

    Status = RegOpenKeyEx(hServer,
                          DEFAULTPUSH,
                          0,
                          KEY_READ,
                          &hDefaultPush);

    if( Status is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       MSG_NO_DEFAULT_PUSH);
    }
    else if( Status isnot NO_ERROR )
        goto ErrorReturn;

    Status = RegOpenKeyEx(hServer,
                          PUSHROOT,
                          0,
                          KEY_READ,
                          &hPushRoot);
    
    if( Status is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       MSG_NO_DEFAULT_PUSH);
    }
    else if( Status isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_SRVR_PUSH_INFO);

    dwData = 0;
    dwSize = sizeof(DWORD);
    
    if( hPushRoot isnot NULL )
    {
        Status = RegQueryValueEx(hPushRoot,
                                 PERSISTENCE,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_PERSISTENCE_STATE,
                           dwData ? wszEnable : wszDisable);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_PERSISTENCE_STATE,
                           wszUnknown);
        }

		dwData = 0;
		dwSize = sizeof(DWORD);
    
        Status = RegQueryValueEx(hPushRoot,
                                 WINSCNF_INIT_TIME_RPL_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_INITTIMEREPL_STATE,
                           dwData ? wszEnable : wszDisable);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_INITTIMEREPL_STATE,
                           wszUnknown);
        }

		dwData = 0;
		dwSize = sizeof(DWORD);
    
        
        Status = RegQueryValueEx(hPushRoot,
                                 WINSCNF_ADDCHG_TRIGGER_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);

        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_ONADDCHANGE,
                           dwData ? wszEnable : wszDisable);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_ONADDCHANGE,
                           wszUnknown);
        }
    }                     
    
    dwData = 0;
	dwSize = sizeof(DWORD);
    
    Status = NO_ERROR;

    if( hDefaultPush isnot NULL )
    {
        Status = RegQueryValueEx(hDefaultPush,
                                 WINSCNF_UPDATE_COUNT_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwSize);
        if( Status is NO_ERROR )
        {
            WCHAR Buffer[10] = {L'\0'};
        
            _itow(dwData, Buffer, 10);

            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_UPDATECOUNT,
                           Buffer);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_UPDATECOUNT,
                           wszUnknown);
        }
    }


CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( hPushRoot )
    {
        RegCloseKey(hPushRoot);
        hPushRoot = NULL;
    }

    if( hPullRoot )
    {
        RegCloseKey(hPullRoot);
        hPullRoot = NULL;
    }

    if( hDefaultPush )
    {
        RegCloseKey(hDefaultPush);
        hDefaultPush = NULL;
    }

    if( hDefaultPull )
    {
        RegCloseKey(hDefaultPull);
        hDefaultPull = NULL;
    }

    if( hParameter )
    {
        RegCloseKey(hParameter);
        hParameter = NULL;
    }

    if( hPartner )
    {
        RegCloseKey(hPartner);
        hPartner = NULL;
    }

    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    if( pbData )
    {
        WinsFreeMemory(pbData);
        pbData = NULL;
    }

    return Status;

ErrorReturn:
    if( Status is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_NO_PARTNER);
    }
    else
    {
        DisplayErrorMessage(EMSG_SRVR_SHOW_PARTNERPROPERTIES,
                            Status);
    }
    goto CommonReturn;


}

DWORD
HandleSrvrShowPullpartnerproperties(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the properties for a particular Pull partner
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Pull partner address
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_SERVER, TRUE, FALSE},
                            };
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    WCHAR       wcServerIpAdd[MAX_IP_STRING_LEN+1] = {L'\0'};
    HKEY        hPullRoot = NULL,
                hPullServer = NULL,
                hServer = NULL;
    BOOL        fPush = FALSE;

    LPWSTR      pTemp = NULL;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SHOW_PULLPARTNERPROPERTIES_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;
    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }


    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                struct  hostent * lpHostEnt = NULL;
                CHAR    cAddr[16];
                BYTE    pbAdd[4];
                char    szAdd[4];
                int     k = 0, l=0;
                DWORD   dwLen, nLen = 0;
                CHAR    *pTemp = NULL;
                CHAR    *pNetBios = NULL;

                if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) )
                {
                    DWORD dwIp = inet_addr(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL));
                    lpHostEnt = gethostbyaddr((char *)&dwIp, 4, AF_INET);
                    if(lpHostEnt isnot NULL )//Valid IP Address
                    {
                        wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                        break;
                    }
                    else
                    {
                        Status = ERROR_INVALID_IPADDRESS;
                        goto ErrorReturn;
                    }
                }

                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 2 and
                    _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"\\\\", 2) is 0 )
                    k = 2;

                lpHostEnt = gethostbyname(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k, NULL));
                if( lpHostEnt is NULL )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_WINS_INVALID_COMPUTER_NAME,
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k);
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;                                       
                }

                memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
                for( l=0;l<4; l++)
                {
                    _itoa((int)pbAdd[l], szAdd, 10);
                    memcpy(cAddr+nLen, szAdd, strlen(szAdd));
                    nLen += strlen(szAdd);
                    *(cAddr+nLen) = '.';
                    nLen++;

                }
                *(cAddr+nLen-1) = '\0';
                {
                    LPWSTR pstr = WinsAnsiToUnicode(cAddr, NULL);

                    if (pstr != NULL)
                    {
                        wcscpy(wcServerIpAdd, pstr);
                        WinsFreeMemory(pstr);
                    }
                    else
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }
                }
                break;               
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

        if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    Status = RegOpenKeyEx(hServer,
                          PULLROOT,
                          0,
                          KEY_READ,
                          &hPullRoot);

    if( Status isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);

    //Now check if the desired server is in the list of pull server.
    Status = RegOpenKeyEx(hPullRoot,
                          wcServerIpAdd,
                          0,
                          KEY_READ,
                          &hPullServer);

    if( Status isnot NO_ERROR )
    {
        DisplayMessage(g_hModule, 
                       EMSG_WINS_INVALID_PULLPARTNER,
                       wcServerIpAdd,
                       g_ServerIpAddressUnicodeString);
        goto CommonReturn;
    }

    //Check if it is also a push partner or not.
    {
        DWORD dwKeyLen = 0;
        HKEY hPushServer = NULL;
        dwKeyLen = wcslen(PUSHROOT)+ wcslen(L"\\") + wcslen(wcServerIpAdd);
        pTemp = WinsAllocateMemory((dwKeyLen+1)*sizeof(WCHAR));
        if(pTemp is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        memset(pTemp, 0x00, (dwKeyLen+1)*sizeof(WCHAR));
        wcscat(pTemp,PUSHROOT);
        wcscat(pTemp, L"\\");
        wcscat(pTemp, wcServerIpAdd);

        Status = RegOpenKeyEx(hServer,
                              pTemp,
                              0,
                              KEY_READ,
                              &hPushServer);
        if( Status isnot NO_ERROR )
        {
            fPush = FALSE;
        }
        else
        {
            fPush = TRUE;
        }
        WinsFreeMemory(pTemp);
        pTemp = NULL;
        if( hPushServer )
        {
            RegCloseKey(hPushServer);
            hPushServer = NULL;
        }
        
    }

    //Now look for required parameters to display
    {
        WCHAR   wcData[256] = {L'\0'};
        DWORD   dwData = 0;
        DWORD   dwDatalen = 256;
        DWORD   dwType = REG_SZ;

        Status = RegQueryValueEx(hPullServer,
                                 L"NetBIOSName",
                                 0,
                                 &dwType,
                                 (LPBYTE)wcData,
                                 &dwDatalen);
        if( Status isnot NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PULLPARTNER_INFO,
                           wcServerIpAdd,
                           wszUnknown,
                           (fPush is TRUE) ? wszPushpull : wszPull);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PULLPARTNER_INFO,
                           wcServerIpAdd,
                           wcData,
                           (fPush is TRUE) ? wszPushpull : wszPull);
        }

        dwDatalen = sizeof(DWORD);
        dwType = REG_DWORD;

        Status = RegQueryValueEx(hPullServer,
                                 PERSISTENCE,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwDatalen);
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_PERSISTENCE_STATE,
                           dwData ? wszEnable : wszDisable);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_PERSISTENCE_STATE,
                           wszUnknown);
        }

        dwType = REG_SZ;
        dwDatalen = 256;
        Status = RegQueryValueEx(hPullServer,
                                 WINSCNF_SP_TIME_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)wcData,
                                 &dwDatalen);
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_STARTTIME,
                           wcData);
        }
        else 
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PULL_STARTTIME,
                           L"00:00:00");
        }
    
        dwDatalen = sizeof(DWORD);
        dwType = REG_DWORD;

        Status = RegQueryValueEx(hPullServer,
                                 WINSCNF_RPL_INTERVAL_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwDatalen);

        if( Status is NO_ERROR )
        {
            LPWSTR  pwszDayString = MakeDayTimeString(dwData);
            DisplayMessage(g_hModule,
                           MSG_WINS_PULL_REPLINTERVAL,
                           pwszDayString);
            WinsFreeMemory(pwszDayString);
            pwszDayString = NULL;
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PULL_REPLINTERVAL,
                           L"00:00:00");
        }
                                
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);
CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }

    if( hPullServer )
    {
        RegCloseKey(hPullServer);
        hPullServer = NULL;
    }


    if( hPullRoot )
    {
        RegCloseKey(hPullRoot);
        hPullRoot = NULL;
    }


    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }

    return Status;

ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SHOW_PULLPARTNERPROPERTIES,
                        Status);
    goto CommonReturn;


}

DWORD
HandleSrvrShowPushpartnerproperties(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :
        Displays the properties for a particular Push partner
Arguments :
        All aguments are passes as array of wide char strings in ppwcArguments.
        Compulsory : Push partner address
Return Value:
        Returns the status of the operation.

--*/
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwNumArgs, dwTagCount;
    TAG_TYPE    pttTags[] = {
                                {WINS_TOKEN_SERVER, TRUE, FALSE},
                            };
    PDWORD      pdwTagType = NULL,
                pdwTagNum = NULL;

    WCHAR       wcServerIpAdd[MAX_IP_STRING_LEN+1] = {L'\0'};
    HKEY        hPushRoot = NULL,
                hPushServer = NULL,
                hServer = NULL;
    BOOL        fPull = FALSE;

    LPWSTR      pTemp = NULL;

    if( dwArgCount < dwCurrentIndex + 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SHOW_PUSHPARTNERPROPERTIES_EX);
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwNumArgs = dwArgCount - dwCurrentIndex;
    pdwTagType = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));
    pdwTagNum = WinsAllocateMemory(dwNumArgs*sizeof(DWORD));

    if( pdwTagType is NULL or
        pdwTagNum is NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorReturn;
    }

    dwTagCount = sizeof(pttTags)/sizeof(TAG_TYPE);

    Status = PreProcessCommand(ppwcArguments,
                               dwArgCount,
                               dwCurrentIndex,
                               pttTags,
                               &dwTagCount,
                               pdwTagType,
                               pdwTagNum);

    if( Status isnot NO_ERROR )
        goto ErrorReturn;

    for( i=0; i<sizeof(pttTags)/sizeof(TAG_TYPE); i++ )
    {
        if( pttTags[i].dwRequired is TRUE and
            pttTags[i].bPresent is FALSE 
          )
        {
            Status = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    for( j=0; j<dwTagCount; j++ )
    {
        switch(pdwTagType[j])
        {
        case 0:
            {
                struct  hostent * lpHostEnt = NULL;
                CHAR    cAddr[16];
                BYTE    pbAdd[4];
                char    szAdd[4];
                int     k = 0, l=0;
                DWORD   dwLen, nLen = 0;
                CHAR    *pTemp = NULL;
                CHAR    *pNetBios = NULL;

                if( IsIpAddress( ppwcArguments[dwCurrentIndex+pdwTagNum[j]] ) )
                {
                    DWORD dwIp = inet_addr(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], NULL));
                    lpHostEnt = gethostbyaddr((char *)&dwIp, 4, AF_INET);
                    if(lpHostEnt isnot NULL )//Valid IP Address
                    {
                        wcscpy(wcServerIpAdd, ppwcArguments[dwCurrentIndex+pdwTagNum[j]]);
                        break;
                    }
                    else
                    {
                        Status = ERROR_INVALID_IPADDRESS;
                        goto ErrorReturn;
                    }
                }

                if( wcslen(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]) > 2 and
                    _wcsnicmp(ppwcArguments[dwCurrentIndex+pdwTagNum[j]], L"\\\\", 2) is 0 )
                    k = 2;
                lpHostEnt = gethostbyname(WinsUnicodeToAnsi(ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k, NULL));
                if( lpHostEnt is NULL )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_WINS_INVALID_COMPUTER_NAME,
                                   ppwcArguments[dwCurrentIndex+pdwTagNum[j]]+k);
                    Status = ERROR_INVALID_PARAMETER;
                    goto ErrorReturn;                                       
                }

                memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
                for( l=0;l<4; l++)
                {
                    _itoa((int)pbAdd[l], szAdd, 10);
                    memcpy(cAddr+nLen, szAdd, strlen(szAdd));
                    nLen += strlen(szAdd);
                    *(cAddr+nLen) = '.';
                    nLen++;

                }
                *(cAddr+nLen-1) = '\0';
                {
                    LPWSTR pstr = WinsAnsiToUnicode(cAddr, NULL);

                    if (pstr != NULL)
                    {
                        wcscpy(wcServerIpAdd, pstr);
                        WinsFreeMemory(pstr);
                    }
                    else
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                        goto ErrorReturn;
                    }
                }
                break;               
            }
        default:
            {
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
    }

        if( wcslen(g_ServerNetBiosName) > 0 )
    {
        pTemp = g_ServerNetBiosName;
    }

    Status = RegConnectRegistry(pTemp, HKEY_LOCAL_MACHINE, &hServer);
    if( Status isnot NO_ERROR )
        goto ErrorReturn;


    Status = RegOpenKeyEx(hServer,
                          PUSHROOT,
                          0,
                          KEY_READ,
                          &hPushRoot);

    if( Status isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);

    //Now check if the desired server is in the list of push server.
    Status = RegOpenKeyEx(hPushRoot,
                          wcServerIpAdd,
                          0,
                          KEY_READ,
                          &hPushServer);

    if( Status isnot NO_ERROR )
    {
        DisplayMessage(g_hModule, 
                       EMSG_WINS_INVALID_PUSHPARTNER,
                       wcServerIpAdd,
                       g_ServerIpAddressUnicodeString);
        goto CommonReturn;
    }

    //Check if it is also a pull partner or not.
    {
        DWORD dwKeyLen = 0;
        HKEY hPullServer = NULL;
        dwKeyLen = wcslen(PULLROOT)+ wcslen(L"\\") + wcslen(wcServerIpAdd);
        pTemp = WinsAllocateMemory((dwKeyLen+1)*sizeof(WCHAR));
        if(pTemp is NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        memset(pTemp, 0x00, (dwKeyLen+1)*sizeof(WCHAR));
        wcscat(pTemp,PULLROOT);
        wcscat(pTemp, L"\\");
        wcscat(pTemp, wcServerIpAdd);

        Status = RegOpenKeyEx(hServer,
                              pTemp,
                              0,
                              KEY_READ,
                              &hPullServer);
        if( Status isnot NO_ERROR )
        {
            fPull = FALSE;
        }
        else
        {
            fPull = TRUE;
        }
        WinsFreeMemory(pTemp);
        pTemp = NULL;
        if( hPullServer )
        {
            RegCloseKey(hPullServer);
            hPullServer = NULL;
        }
        
    }

    //Now look for required parameters to display
    {
        WCHAR   wcData[256] = {L'\0'};
        DWORD   dwData = 0;
        DWORD   dwDatalen = 256;
        DWORD   dwType = REG_SZ;

        Status = RegQueryValueEx(hPushServer,
                                 L"NetBIOSName",
                                 0,
                                 &dwType,
                                 (LPBYTE)wcData,
                                 &dwDatalen);
        if( Status isnot NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PUSHPARTNER_INFO,
                           wcServerIpAdd,
                           wszUnknown,
                           (fPull is TRUE) ? wszPushpull : wszPush);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PUSHPARTNER_INFO,
                           wcServerIpAdd,
                           wcData,
                           (fPull is TRUE) ? wszPushpull : wszPush);
        }

        dwDatalen = sizeof(DWORD);
        dwType = REG_DWORD;

        Status = RegQueryValueEx(hPushServer,
                                 PERSISTENCE,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwDatalen);
        if( Status is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_PERSISTENCE_STATE,
                           dwData ? wszEnable : wszDisable);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_PERSISTENCE_STATE,
                           wszUnknown);
        }

  
        dwDatalen = sizeof(DWORD);
        dwType = REG_DWORD;

        Status = RegQueryValueEx(hPushServer,
                                 WINSCNF_UPDATE_COUNT_NM,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwData,
                                 &dwDatalen);

        if( Status is NO_ERROR )
        {
            WCHAR Buffer[10] = {L'\0'};
        
            _itow(dwData, Buffer, 10);

            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_UPDATECOUNT,
                           Buffer);
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_PUSH_UPDATECOUNT,
                           wszUnknown);
        }
                                
    }

    DisplayMessage(g_hModule, WINS_FORMAT_LINE);


CommonReturn:
    if( Status is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_WINS_ERROR_SUCCESS);

    if( hPushServer )
    {
        RegCloseKey(hPushServer);
        hPushServer = NULL;
    }


    if( hPushRoot )
    {
        RegCloseKey(hPushRoot);
        hPushRoot = NULL;
    }


    if( hServer )
    {
        RegCloseKey(hServer);
        hServer = NULL;
    }
    
    if( pdwTagType )
    {
        WinsFreeMemory(pdwTagType);
        pdwTagType = NULL;
    }
    
    if( pdwTagNum )
    {
        WinsFreeMemory(pdwTagNum);
        pdwTagNum = NULL;
    }

    return Status;

ErrorReturn:
    DisplayErrorMessage(EMSG_SRVR_SHOW_PUSHPARTNERPROPERTIES,
                        Status);
    goto CommonReturn;

}

DWORD
GetVersionData(
               LPWSTR               pwszVers,
               WINSINTF_VERS_NO_T   *Version
               )
{
    LPWSTR pTemp = NULL;
    LPWSTR pwcBuffer = NULL;
    DWORD  dwLen = 0;
    LPWSTR pwszToken=L",-.";
    
    if( ( pwszVers is NULL ) or 
        ( IsBadStringPtr(pwszVers, MAX_STRING_LEN) is TRUE ) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwLen = wcslen(pwszVers);

    if( dwLen<2 )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    pwcBuffer = WinsAllocateMemory((dwLen+1)*sizeof(WCHAR));

    if( pwcBuffer is NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(pwcBuffer, pwszVers);
    
    if( pwcBuffer[0] isnot L'{' or
        pwcBuffer[dwLen-1] isnot L'}' )
    {
        WinsFreeMemory(pwcBuffer);
        pwcBuffer = NULL;
        return ERROR_INVALID_PARAMETER;
    }
    
    pwcBuffer[dwLen-1] = L'\0';
    
    pTemp = wcstok(pwcBuffer+1, pwszToken);                
    
    if( pTemp is NULL )
    {
        WinsFreeMemory(pwcBuffer);
        pwcBuffer = NULL;
        return ERROR_INVALID_PARAMETER;
    }
    
    Version->HighPart = wcstoul(pTemp, NULL, 16);
    pTemp = wcstok(NULL, pwszToken);
    if( pTemp is NULL )
    {
        WinsFreeMemory(pwcBuffer);
        pwcBuffer = NULL;
        return ERROR_INVALID_PARAMETER;        
    }
    Version->LowPart = wcstoul(pTemp, NULL, 16);
    WinsFreeMemory(pwcBuffer);
    pwcBuffer = NULL;
    return NO_ERROR;
}


DWORD
PreProcessCommand(
      IN          LPWSTR            *ppwcArguments,
      IN          DWORD             dwArgCount,
      IN          DWORD             dwCurrentIndex,
      IN OUT      PTAG_TYPE         pttTags,
      IN OUT      PDWORD            pdwTagCount,
      OUT         PDWORD            pdwTagType,
      OUT         PDWORD            pdwTagNum
)
{
    DWORD       Status = NO_ERROR;
    DWORD       i, j, dwTag = 0;
    LPWSTR      pwszTemp = NULL;
    

    if( pdwTagType is NULL or
        pdwTagNum is NULL or
        pttTags is NULL or
        pdwTagCount is NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwTag = *pdwTagCount;
    i = 0;
    if( wcsstr(ppwcArguments[dwCurrentIndex], NETSH_ARG_DELIMITER) isnot NULL )
    {

        LPWSTR  pwszTag = NULL;
        while( IsBadStringPtr(ppwcArguments[dwCurrentIndex+i], MAX_STRING_LEN) is FALSE )
        {
            pwszTag = NULL;
            if( dwArgCount <= dwCurrentIndex + i )
                break;
            if( wcslen(ppwcArguments[dwCurrentIndex+i]) is 0 )
                break;

            pwszTemp = WinsAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+i])+1)*sizeof(WCHAR));

            if( pwszTemp is NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorReturn;
            }

            wcscpy(pwszTemp, ppwcArguments[dwCurrentIndex+i]);
            
            if( wcsstr(ppwcArguments[dwCurrentIndex+i], NETSH_ARG_DELIMITER ) is NULL )
            {
                DisplayMessage(g_hModule,
                               EMSG_SRVR_NOT_TAGGED,
                               i+1);
                i++;
                continue;
            }
            pwszTag = wcstok(pwszTemp, NETSH_ARG_DELIMITER);
            
            for( j=0; j<dwTag; j++ )
            {
                if( FALSE is MatchToken(pwszTag,
                                        pttTags[j].pwszTag) )
                {
                    continue;
                }
                else
                {
                    if( pttTags[j].bPresent is TRUE )
                    {
                        Status = ERROR_INVALID_PARAMETER;
                        WinsFreeMemory(pwszTemp);
                        pwszTemp = NULL;
                        goto ErrorReturn;
                    }
                    else
                    {
                        LPWSTR pwszVal = wcstok(NULL, NETSH_ARG_DELIMITER);
                        if( pwszVal is NULL )
                        {
                            wcscpy(ppwcArguments[dwCurrentIndex+i], L"");
                        }
                        else
                        {
                            wcscpy(ppwcArguments[dwCurrentIndex+i], pwszVal);
                        }
                        pttTags[j].bPresent = TRUE;
                        pdwTagType[i] = j;
                        pdwTagNum[i] = i;
                        break;
                    }
                }
            }
            if( pwszTemp )
            {
                WinsFreeMemory(pwszTemp);
                pwszTemp = NULL;
            }
            i++;
        }
    }
    else
    {
        while( IsBadStringPtr(ppwcArguments[dwCurrentIndex+i], MAX_STRING_LEN) is FALSE )
        {
            if( wcsstr(ppwcArguments[dwCurrentIndex+i], NETSH_ARG_DELIMITER) isnot NULL )
            {
                DisplayMessage(g_hModule,
                               EMSG_SRVR_NOT_UNTAGGED,
                               i+1);
                Status = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            if( dwArgCount <= dwCurrentIndex + i )
                break;
       //     if( wcslen(ppwcArguments[dwCurrentIndex+i]) is 0 )
       //         break;
            if( dwTag <= i )
            {                
                break;
            }
            pdwTagType[i] = i;
            pdwTagNum[i] = i;
            pttTags[i].bPresent = TRUE;
            i++;
        }
    }
    *pdwTagCount = i;
CommonReturn:
    if( pwszTemp )
    {
        WinsFreeMemory(pwszTemp);
        pwszTemp = NULL;
    }
    return Status;
ErrorReturn:
    goto CommonReturn;
}


DWORD
GetStatus(
        BOOL            fPrint,
        LPVOID          pResultsA,
        BOOL            fNew,
        BOOL            fShort,
        LPCSTR          pStartIp
        )
{
    DWORD                     Status, i;
    struct in_addr            InAddr;
    PWINSINTF_RESULTS_T       pResults = pResultsA;
    PWINSINTF_RESULTS_NEW_T   pResultsN = pResultsA;
    PWINSINTF_ADD_VERS_MAP_T  pAddVersMaps;
    DWORD                     NoOfOwners;
    WCHAR                     IpAddress[21] = {L'\0'};
    WCHAR                     OwnerId[15] = {L'\0'};
    WCHAR                     Buffer[5] = {L'\0'};
    LPWSTR                    pwszDay = NULL;
    handle_t                  BindHdl;
    WINSINTF_BIND_DATA_T      BindData = {0};
    

    BindData.fTcpIp = TRUE;
    BindData.pServerAdd = (LPBYTE)WinsOemToUnicode(pStartIp, NULL);

    if( BindData.pServerAdd is NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    DisplayMessage(g_hModule,
                   MSG_SRVR_MAPTABLE_HEADER,
                   BindData.pServerAdd);

    BindHdl = WinsBind(&BindData);

    if( BindHdl is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_BIND_FAILED,
                       BindData.pServerAdd);
        return NO_ERROR;
    }

    if (!fNew)
    {
      Status = WinsStatus(BindHdl, WINSINTF_E_CONFIG, pResultsA);
    }

    else
    {
      pResultsN->pAddVersMaps = NULL;
      Status = WinsStatusNew(BindHdl, WINSINTF_E_CONFIG, pResultsN);
    }
  
    if( Status isnot NO_ERROR )
    {
        WinsUnbind(&BindData, BindHdl);
        return Status;
    }

    if( fShort is TRUE )
    {
        DisplayMessage(g_hModule,
                       MSG_WINS_NAMERECORD_SETTINGS);
    
        if( fNew )
        {
            pwszDay = MakeDayTimeString(pResultsN->RefreshInterval);
        }
        else
        {
            pwszDay = MakeDayTimeString(pResults->RefreshInterval);
        }

        DisplayMessage(g_hModule,
                       MSG_WINS_NAMERECORD_REFRESHINTVL,
                       pwszDay);
    
        WinsFreeMemory(pwszDay);
        pwszDay = NULL;

        if( fNew )
        {
            pwszDay = MakeDayTimeString(pResultsN->TombstoneInterval);
        }
        else
        {
            pwszDay = MakeDayTimeString(pResults->TombstoneInterval);
        }

        DisplayMessage(g_hModule,
                       MSG_WINS_NAMERECORD_TOMBSTONEINTVL,
                       pwszDay);
    
        WinsFreeMemory(pwszDay);
        pwszDay = NULL;

        if( fNew )
        {
            pwszDay = MakeDayTimeString(pResultsN->TombstoneTimeout);
        }
        else
        {
            pwszDay = MakeDayTimeString(pResults->TombstoneTimeout);
        }

        DisplayMessage(g_hModule,
                       MSG_WINS_NAMERECORD_TOMBSTONETMOUT,
                       pwszDay);

        WinsFreeMemory(pwszDay);
        pwszDay = NULL;

        if( fNew )
        {
            pwszDay = MakeDayTimeString(pResultsN->VerifyInterval);
        }
        else
        {
            pwszDay = MakeDayTimeString(pResults->VerifyInterval);
        }
        DisplayMessage(g_hModule,
                       MSG_WINS_NAMERECORD_VERIFYINTVL,
                       pwszDay);

        WinsFreeMemory(pwszDay);
        pwszDay = NULL;

        DisplayMessage(g_hModule,WINS_FORMAT_LINE);

        if (!fNew)
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PRIORITY_CLASS, 
                           pResults->WinsPriorityClass == NORMAL_PRIORITY_CLASS ? wszNormal : wszHigh);
            DisplayMessage(g_hModule,
                           MSG_WINS_WORKER_THREAD,
                           pResults->NoOfWorkerThds);

            pAddVersMaps = pResults->AddVersMaps;
            NoOfOwners = pResults->NoOfOwners;
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_PRIORITY_CLASS, 
                           pResultsN->WinsPriorityClass == NORMAL_PRIORITY_CLASS ? wszNormal : wszHigh);
            DisplayMessage(g_hModule,
                           MSG_WINS_WORKER_THREAD,
                           pResultsN->NoOfWorkerThds);

            pAddVersMaps = pResultsN->pAddVersMaps;
            NoOfOwners = pResultsN->NoOfOwners;

        }

        DisplayMessage(g_hModule,WINS_FORMAT_LINE);

        if (NoOfOwners isnot 0)
        {
        
            DisplayMessage(g_hModule,
                           MSG_WINS_OWNER_TABLE);

            for ( i= 0; i < NoOfOwners; i++, pAddVersMaps++)
            {
                DWORD j=0;
                for(j=0; j<20; j++)
                {
                    IpAddress[j] = L' ';
                }
                IpAddress[20] = L'\0';
                for(j=0; j<14; j++)
                {
                    OwnerId[j] = L' ';
                }
                OwnerId[14] = L'\0';
    

                _itow(i, Buffer, 10);
                wcscpy(OwnerId+4, Buffer);
                for(j=wcslen(OwnerId); j<14; j++)
                    OwnerId[j] = L' ';
                OwnerId[14] = L'\0';

                wcscpy(IpAddress+2, IpAddressToString(pAddVersMaps->Add.IPAdd));
                for(j=wcslen(IpAddress); j<20; j++)
                    IpAddress[j] = L' ';
                IpAddress[20] = L'\0';

                if (fNew)
                {
                    if( pAddVersMaps->VersNo.HighPart is MAXLONG and
                        pAddVersMaps->VersNo.LowPart is MAXULONG )
                    {

                        DisplayMessage(g_hModule,
                                       MSG_WINS_OWNER_INFO_MAX,
                                       OwnerId,
                                       IpAddress,
                                       wszDeleted);
                    
                        continue;
                    }

                    if (fShort && pAddVersMaps->VersNo.QuadPart == 0)
                    {
                        continue;
                    }

                    DisplayMessage(g_hModule,
                                   MSG_WINS_OWNER_INFO,
                                   OwnerId,
                                   IpAddress,
                                   pAddVersMaps->VersNo.HighPart,
                                   pAddVersMaps->VersNo.LowPart);

                }

            }
        }
        else
        {
            DisplayMessage(g_hModule, MSG_WINS_NO_RECORDS);
        }
    }
    WinsUnbind(&BindData, BindHdl);

    if( BindData.pServerAdd )
    {
        WinsFreeMemory(BindData.pServerAdd);
        BindData.pServerAdd = NULL;
    }
    return(Status);
}


VOID
ChkAdd(
        PWINSINTF_RECORD_ACTION_T pRow,
        DWORD                     Add,
        BOOL                      fFile,
        FILE                      *pFile,
        DWORD                     OwnerIP,
        LPBOOL                    pfMatch
      )
{

    struct in_addr InAddr1, InAddr2;
    DWORD   dwIpAddress = 0;
    LPWSTR  pwszAdd1 = NULL;
    LPWSTR  pwszAdd2 = NULL;
    LPWSTR  pwszOwner = NULL;

    BOOL    fFirst = FALSE;

    if ( pRow->TypOfRec_e is WINSINTF_E_UNIQUE or
         pRow->TypOfRec_e is WINSINTF_E_NORM_GROUP )
    {
            pwszAdd2 = IpAddressToString(pRow->Add.IPAdd);
            pwszOwner = IpAddressToString(OwnerIP);
            
            if( pwszAdd2 is NULL or
                pwszOwner is NULL )
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_OUT_OF_MEMORY);

                if( pwszAdd2 )
                {
                    WinsFreeMemory(pwszAdd2);
                    pwszAdd2 = NULL;
                }

                if( pwszOwner )
                {
                    WinsFreeMemory(pwszOwner);
                    pwszOwner = NULL;
                }
                return;
            }

        if (*pfMatch)
        {
            if (Add isnot pRow->Add.IPAdd)
            {
                WinsFreeMemory(pwszAdd2);
                pwszAdd2 = NULL;
                WinsFreeMemory(pwszOwner );
                pwszOwner = NULL;                
                *pfMatch = FALSE;
                return;
            }
        }
        
        DisplayMessage(g_hModule, 
                       MSG_WINS_IPADDRESS_STRING,
                       pwszAdd2 );

        if( fFile )
        {
            DumpMessage(g_hModule,
                        pFile,
                        FMSG_WINS_IPADDRESS_STRING,
                        pwszAdd2,
                        pwszOwner);
        }

        WinsFreeMemory(pwszAdd2);
        pwszAdd2 = NULL;
        WinsFreeMemory(pwszOwner );
        pwszOwner = NULL;

        return;
    }
    else //spec. grp or multihomed
    {
        DWORD ind;
        if (!*pfMatch)
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_MEMBER_COUNT,
                           pRow->NoOfAdds/2);
        }

        for ( ind=0;  ind < pRow->NoOfAdds ;  /*no third expr*/ )
        {
            LPSTR psz1 = NULL;
 
            InAddr1.s_addr = htonl( (pRow->pAdd + ind++)->IPAdd);
            
            psz1 = inet_ntoa(InAddr1);
            
            if( psz1 is NULL )
            {
                continue;
            }

            pwszAdd1 = WinsOemToUnicode(psz1, NULL );

            if( pwszAdd1 is NULL )
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_OUT_OF_MEMORY);
                return;
            }


            if (!*pfMatch)
            {
                DisplayMessage(g_hModule,
                               MSG_WINS_OWNER_ADDRESS,
                               pwszAdd1);
            }

            InAddr2.s_addr = htonl((pRow->pAdd + ind++)->IPAdd);
            
            psz1 = inet_ntoa(InAddr2);
            
            if( psz1 is NULL )
            {
                if( pwszAdd1 )
                {
                    WinsFreeMemory(pwszAdd1);
                    pwszAdd1 = NULL;
                }
                continue;
            }

            pwszAdd2 = WinsOemToUnicode(psz1, NULL);

            if( pwszAdd2 is NULL )
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_OUT_OF_MEMORY);
                if( pwszAdd1 )
                {
                    WinsFreeMemory(pwszAdd1);
                    pwszAdd1 = NULL;
                }
                return;
            }

            if (!*pfMatch)
            {
                DisplayMessage(g_hModule,
                               MSG_WINS_IPADDRESS_STRING,
                               pwszAdd2 );
                if( fFile )
                {
                    if( fFirst is FALSE )
                    {
                        DumpMessage(g_hModule,
                                    pFile,
                                    FMSG_WINS_IPADDRESS_STRING,
                                    pwszAdd2, 
                                    pwszAdd1);
                        fFirst = TRUE;
                    }
                    else
                    {
                        DumpMessage(g_hModule,
                                    pFile,
                                    FMSG_WINS_IPADDRESS_LIST,
                                    pwszAdd2,
                                    pwszAdd1);
                    }
                }
            }
            if (*pfMatch)
            {
                if (Add isnot (pRow->pAdd + ind - 1)->IPAdd)
                {
                    *pfMatch = FALSE;

                    if( pwszAdd1 )
                    {
                        WinsFreeMemory(pwszAdd1);
                        pwszAdd1 = NULL;
                    }
                    if( pwszAdd2 )
                    {
                        WinsFreeMemory(pwszAdd2);
                        pwszAdd2 = NULL;
                    }                   
                    return;
                }
            }
        }

        //
        // If there were no members to compare with, then
        // let us set *pfMatch to FALSE.
        //
        if (ind == 0)
        {
            if (*pfMatch)
            {
                    *pfMatch = FALSE;
            }
        }
        if( pwszAdd1 )
        {
            WinsFreeMemory(pwszAdd1);
            pwszAdd1 = NULL;
        }

        if( pwszAdd2 )
        {
            WinsFreeMemory(pwszAdd2);
            pwszAdd2 = NULL;
        }

        return;
    }
}

DWORD
GetDbRecs(
   WINSINTF_VERS_NO_T LowVersNo,
   WINSINTF_VERS_NO_T HighVersNo,
   PWINSINTF_ADD_T    pWinsAdd,
   LPBYTE             pTgtAdd,
   BOOL               fSetFilter,
   LPBYTE             pFilterName,
   DWORD              Len,
   BOOL               fAddFilter,
   DWORD              AddFilter,
   BOOL               fCountRec,
   BOOL               fCase,
   BOOL               fFile,
   LPWSTR             pwszFile
  )
{

    WINSINTF_RECS_T    Recs;
    DWORD              Choice;
    DWORD              Status = WINSINTF_SUCCESS;
    DWORD              TotalCnt = 0;
    BOOL               fMatch;
    WINSINTF_VERS_NO_T sTmpVersNo;
    WCHAR              Name[20] = {L'\0'};
    DWORD              dwCount = 0;
    struct tm*         time = NULL;
    LPWSTR             pwszTime = NULL;
    int                iType = 1;
    FILE               *pFile = NULL;
    BOOL               fOpenFile = FALSE;
    BOOL               fHeader = FALSE;
    LPWSTR              pwszGroup = NULL,
                        pwszType = NULL,
                        pwszState = NULL;
    WCHAR               wszGroup[50] = {L'\0'},
                        wszState[50] = {L'\0'},
                        wszType[50] = {L'\0'};

    DWORD               dwGroup = WINS_GROUP_UNIQUE,
                        dwGrouplen = 0,
                        dwState = WINS_STATE_ACTIVE,
                        dwStatelen = 0,
                        dwType = WINS_TYPE_STATIC,
                        dwTypelen = 0;

   
   sTmpVersNo.LowPart = 1;
   sTmpVersNo.HighPart = 0;

   if( fFile )
   {
        pFile = _wfopen(pwszFile,
                        L"a+");
        if( pFile is NULL )
        {
            fOpenFile = FALSE;
            DisplayMessage(g_hModule,
                           EMSG_WINS_FILEOPEN_FAILED,
                           pwszFile);
        }
        else
        {
            fOpenFile = TRUE;
        }

   }
   while (TRUE)
   {
        LPWSTR  pwszTempTgt = NULL;

        Recs.pRow = NULL;
        Status = WinsGetDbRecs(g_hBind, pWinsAdd, LowVersNo, HighVersNo, &Recs);

        if (fCountRec)
        {
            DisplayMessage(g_hModule,
                           MSG_WINS_RECORDS_COUNT,
                           Recs.TotalNoOfRecs);

            break;
        }
        if (Status is WINSINTF_SUCCESS)
        {
            if (Recs.NoOfRecs > 0)
            {
                DWORD i, k;
                PWINSINTF_RECORD_ACTION_T pRow =  Recs.pRow;
                TotalCnt += Recs.NoOfRecs;


                if (!fSetFilter)
                {
                    DisplayMessage(g_hModule,
                                   MSG_WINS_RECORDS_RETRIEVED,
                                   IpAddressToString(pWinsAdd->IPAdd),
                                   Recs.NoOfRecs);
                    
                }

                

                for (i=0; i<Recs.NoOfRecs; i++)
                {

                    if (fAddFilter)
                    {
                        //
                        // The address filter was specfied
                        // If the address matches, then
                        // fMatch will be TRUE after the
                        // function returns.
                        //
                        fMatch = TRUE;
                        ChkAdd(
                                pRow,
                                AddFilter,
                                fOpenFile,
                                pFile,
                                pWinsAdd->IPAdd,
                                &fMatch
                              );
                    }
                    else
                    {
                        fMatch = FALSE;
                    }


                    //
                    // If the address matched or if no filter
                    // was specified or if there was a name
                    // filter and the names matched, print
                    // out the details
                    //
                    if( fCase )
                    {
                        if( fMatch or
                            fSetFilter is FALSE or
                            ( fAddFilter is FALSE and
                              IsBadStringPtrA(pRow->pName, 256) is FALSE and
                              strncmp(pRow->pName, pFilterName, (pRow->NameLen>Len)?Len:pRow->NameLen) is 0 )
                          )
                        {
                            WCHAR   Name[256] = {L'\0'};
                            CHAR    chEndChar = 0x00;
                            LPWSTR  pwszTemp = NULL;
                            DWORD   dwTempLen = 0;
                            
                            DisplayMessage(g_hModule,
                                           MSG_WINS_RECORD_LINE);
                            if( fOpenFile and
                                g_fHeader is FALSE )
                            {
                                DumpMessage(g_hModule,
                                            pFile,
                                            FMSG_WINS_RECORD_TABLE);
                                g_fHeader = TRUE;
                            }
                            
                            chEndChar = (CHAR)pRow->pName[15];
                            pRow->pName[15] = '\0';

                            pwszTemp = WinsOemToUnicode(pRow->pName, NULL);

                            if( pwszTemp is NULL )
                            {
                                DisplayMessage(g_hModule,
                                               EMSG_WINS_OUT_OF_MEMORY);
                                Status = WINSINTF_FAILURE;
                                break;
                            }
                            
                            dwTempLen = ( 16 > wcslen(pwszTemp) ) ? wcslen(pwszTemp) : 16;

                            wcsncpy(Name, pwszTemp, dwTempLen);
                            
                            WinsFreeMemory(pwszTemp);
                            pwszTemp = NULL;
                            
                            for( k=dwTempLen; k<15; k++ )
                            {
                                Name[k] = L' ';
                            }

                            Name[15] = L'[';
                            WinsHexToString(Name+16, (LPBYTE)&chEndChar, 1);
                            Name[18] = L'h';
                            Name[19] = L']';
                            Name[20] = L'\0';
                            
                            if( IsBadStringPtrA(pRow->pName+16, 240) is FALSE )
                            {
                                pwszTemp = WinsOemToUnicode(pRow->pName+16, NULL);
                                if( pwszTemp is NULL )
                                {
                                    DisplayMessage(g_hModule,
                                                   EMSG_WINS_OUT_OF_MEMORY);
                                    Status = WINSINTF_FAILURE;
                                    break;
                                }
                                dwTempLen = ( 240 > wcslen(pwszTemp) ) ? wcslen(pwszTemp) : 240;
                                wcsncpy(Name+20, pwszTemp, dwTempLen);
                                WinsFreeMemory(pwszTemp);
                                pwszTemp = NULL;

                            }
                            
                            Name[wcslen(Name)] = L'\0'; 

                            
                            if( chEndChar is 0x1C )
                            {
                                dwGroup = WINS_GROUP_DOMAIN;
                                pwszGroup = L"DOMAIN NAME   ";
                            }


                            else if( pRow->TypOfRec_e is WINSINTF_E_UNIQUE )
                            {
                                pwszGroup = L"UNIQUE        ";
                                dwGroup = WINS_GROUP_UNIQUE;
                            }
                            else if( pRow->TypOfRec_e is WINSINTF_E_NORM_GROUP )
                            {
                                pwszGroup = L"GROUP         ";
                                dwGroup = WINS_GROUP_GROUP;
                            }
                            else if( pRow->TypOfRec_e is WINSINTF_E_SPEC_GROUP )
                            {
                                pwszGroup = L"INTERNET GROUP";
                                dwGroup = WINS_GROUP_INTERNET;
                            }
                            else
                            {
                                pwszGroup = L"MULTIHOMED    ";
                                dwGroup = WINS_GROUP_MULTIHOMED;
                            }
                            

                           //Load the group string
                            {
                                dwGrouplen = LoadStringW(g_hModule,
                                                        dwGroup,
                                                        wszGroup,
                                                        sizeof(wszGroup)/sizeof(WCHAR));

                                if( dwGrouplen is 0 )
                                    wcscpy(wszGroup, pwszGroup);
                            }

                            if( pRow->State_e is WINSINTF_E_ACTIVE )
                            {
                                pwszState = L"ACTIVE";
                                dwState = WINS_STATE_ACTIVE;
                            }
                            else if( pRow->State_e is WINSINTF_E_RELEASED )
                            {
                                dwState = WINS_STATE_RELEASED;
                                pwszState = L"RELEASED";
                            }
                            else
                            {
                                dwState = WINS_STATE_TOMBSTONE;
                                pwszState = L"TOMBSTONE";
                            }

                            //Load the State string
                            {
                                dwStatelen = LoadStringW(g_hModule,
                                                        dwState,
                                                        wszState,
                                                        sizeof(wszState)/sizeof(WCHAR));

                                if( dwStatelen is 0 )
                                    wcscpy(wszState, pwszState);
                            }



                            if( pRow->fStatic )
                            {
                                dwType = WINS_TYPE_STATIC;
                                pwszType = L"STATIC";
                            }
                            else
                            {
                                dwType = WINS_TYPE_DYNAMIC;
                                pwszType = L"DYNAMIC";
                            }

                            //Load the State string
                            {
                                dwTypelen = LoadStringW(g_hModule,
                                                       dwType,
                                                       wszType,
                                                       sizeof(wszType)/sizeof(WCHAR));

                                if( dwTypelen is 0 )
                                    wcscpy(wszType, pwszType);
                            }

                            iType = 1;
                            pwszTime = GetDateTimeString(pRow->TimeStamp,
                                                         FALSE,
                                                         &iType);
                            DisplayMessage(g_hModule,
                                           MSG_WINS_RECORD_INFO,
                                           Name,
                                           wszType,
                                           wszState,
                                           pRow->VersNo.HighPart,
                                           pRow->VersNo.LowPart,
                                           pRow->NodeTyp,                                           
                                           wszGroup,
                                           iType ? wszInfinite : pwszTime);
                            
                            if( fOpenFile )
                            {
                                DumpMessage(g_hModule,
                                            pFile,
                                            FMSG_WINS_RECORDS_INFO,
                                            Name,
                                            wszType,
                                            wszState,
                                            pRow->VersNo.HighPart,
                                            pRow->VersNo.LowPart,
                                            pRow->NodeTyp,                                           
                                            wszGroup,
                                            iType ? wszInfinite : pwszTime);
                            }

                            if( pwszTime )
                            {
                                WinsFreeMemory(pwszTime);
                                pwszTime = NULL;
                            }
                            fMatch = FALSE;

                            ChkAdd(
                                    pRow,
                                    AddFilter,
                                    fOpenFile,
                                    pFile,
                                    pWinsAdd->IPAdd,
                                    &fMatch
                                  );

                            DisplayMessage(g_hModule,
                                           MSG_WINS_RECORD_LINE);
                            dwCount++;
                        }
                    }
                    else
                    {
                        if( fMatch or
                            fSetFilter is FALSE or
                            ( fAddFilter is FALSE and
                              IsBadStringPtrA(pRow->pName, 256) is FALSE and
                            _strnicmp(pRow->pName, pFilterName, (pRow->NameLen>Len)?Len:pRow->NameLen) is 0 )
                          )
                        {
                            WCHAR   Name[256] = {L'\0'};
                            CHAR    chEndChar = 0x00;
                            LPWSTR  pwszTemp = NULL;
                            DWORD   dwTempLen = 0;

                            DisplayMessage(g_hModule,
                                           MSG_WINS_RECORD_LINE);
                            if( fOpenFile and
                                g_fHeader is FALSE )
                            {
                                DumpMessage(g_hModule,
                                            pFile,
                                            FMSG_WINS_RECORD_TABLE);
                                g_fHeader = TRUE;
                            }
                            
                            chEndChar = (CHAR)pRow->pName[15];
                            pRow->pName[15] = '\0';

                            pwszTemp = WinsOemToUnicode(pRow->pName, NULL);

                            if( pwszTemp is NULL )
                            {
                                DisplayMessage(g_hModule,
                                               EMSG_WINS_OUT_OF_MEMORY);
                                Status = WINSINTF_FAILURE;
                                break;
                            }
                            
                            dwTempLen = ( 16 > wcslen(pwszTemp) ) ? wcslen(pwszTemp) : 16;

                            wcsncpy(Name, pwszTemp, dwTempLen);
                            
                            WinsFreeMemory(pwszTemp);
                            pwszTemp = NULL;
                            
                            for( k=dwTempLen; k<15; k++ )
                            {
                                Name[k] = L' ';
                            }

                            Name[15] = L'[';
                            WinsHexToString(Name+16, (LPBYTE)&chEndChar, 1);
                            Name[18] = L'h';
                            Name[19] = L']';
                            Name[20] = L'\0';
                            
                            if( IsBadStringPtrA(pRow->pName+16, 240) is FALSE )
                            {
                                pwszTemp = WinsOemToUnicode(pRow->pName+16, NULL);
                                if( pwszTemp is NULL )
                                {
                                    DisplayMessage(g_hModule,
                                                   EMSG_WINS_OUT_OF_MEMORY);
                                    Status = WINSINTF_FAILURE;
                                    break;
                                }
                                dwTempLen = ( 240 > wcslen(pwszTemp) ) ? wcslen(pwszTemp) : 240;
                                wcsncpy(Name+20, pwszTemp, dwTempLen);
                                WinsFreeMemory(pwszTemp);
                                pwszTemp = NULL;

                            }
                            
                            Name[wcslen(Name)] = L'\0';

                            if( chEndChar is 0x1C )
                            {
                                dwGroup = WINS_GROUP_DOMAIN;
                                pwszGroup = L"DOMAIN NAME   ";
                            }
                            else if( pRow->TypOfRec_e is WINSINTF_E_UNIQUE )
                            {
                                pwszGroup = L"UNIQUE        ";
                                dwGroup = WINS_GROUP_UNIQUE;
                            }
                            else if( pRow->TypOfRec_e is WINSINTF_E_NORM_GROUP )
                            {
                                pwszGroup = L"GROUP         ";
                                dwGroup = WINS_GROUP_GROUP;
                            }
                            else if( pRow->TypOfRec_e is WINSINTF_E_SPEC_GROUP )
                            {
                                pwszGroup = L"INTERNET GROUP";
                                dwGroup = WINS_GROUP_INTERNET;
                            }
                            else
                            {
                                pwszGroup = L"MULTIHOMED    ";
                                dwGroup = WINS_GROUP_MULTIHOMED;
                            }
                            

                           //Load the group string
                            {
                                dwGrouplen = LoadStringW(g_hModule,
                                                        dwGroup,
                                                        wszGroup,
                                                        sizeof(wszGroup)/sizeof(WCHAR));

                                if( dwGrouplen is 0 )
                                    wcscpy(wszGroup, pwszGroup);
                            }

                            if( pRow->State_e is WINSINTF_E_ACTIVE )
                            {
                                pwszState = L"ACTIVE";
                                dwState = WINS_STATE_ACTIVE;
                            }
                            else if( pRow->State_e is WINSINTF_E_RELEASED )
                            {
                                dwState = WINS_STATE_RELEASED;
                                pwszState = L"RELEASED";
                            }
                            else
                            {
                                dwState = WINS_STATE_TOMBSTONE;
                                pwszState = L"TOMBSTONE";
                            }

                            //Load the State string
                            {
                                dwStatelen = LoadStringW(g_hModule,
                                                        dwState,
                                                        wszState,
                                                        sizeof(wszState)/sizeof(WCHAR));

                                if( dwStatelen is 0 )
                                    wcscpy(wszState, pwszState);
                            }



                            if( pRow->fStatic )
                            {
                                dwType = WINS_TYPE_STATIC;
                                pwszType = L"STATIC";
                            }
                            else
                            {
                                dwType = WINS_TYPE_DYNAMIC;
                                pwszType = L"DYNAMIC";
                            }

                            //Load the State string
                            {
                                dwTypelen = LoadStringW(g_hModule,
                                                       dwType,
                                                       wszType,
                                                       sizeof(wszType)/sizeof(WCHAR));

                                if( dwTypelen is 0 )
                                    wcscpy(wszType, pwszType);
                            }
                            iType = 1;
                            pwszTime = GetDateTimeString(pRow->TimeStamp,
                                                         FALSE,
                                                         &iType);

                            DisplayMessage(g_hModule,
                                           MSG_WINS_RECORD_INFO,
                                           Name,
                                           wszType,
                                           wszState,
                                           pRow->VersNo.HighPart,
                                           pRow->VersNo.LowPart,
                                           pRow->NodeTyp,
                                           wszGroup,
                                           iType ? wszInfinite : pwszTime);

                            if( fOpenFile )
                            {
                                DumpMessage(g_hModule,
                                            pFile,
                                            FMSG_WINS_RECORDS_INFO,
                                            Name,
                                            wszType,
                                            wszState,
                                            pRow->VersNo.HighPart,
                                            pRow->VersNo.LowPart,
                                            pRow->NodeTyp,                                           
                                            wszGroup,
                                            iType ? wszInfinite : pwszTime);
                            }
                            if( pwszTime )
                            {
                                WinsFreeMemory(pwszTime);
                                pwszTime = NULL;
                            }
                            fMatch = FALSE;

                            ChkAdd(
                                    pRow,
                                    AddFilter,
                                    fOpenFile,
                                    pFile,
                                    pWinsAdd->IPAdd,
                                    &fMatch
                                  );

                            DisplayMessage(g_hModule,
                                           MSG_WINS_RECORD_LINE);
                            dwCount++;
                        }

                    }
                    pRow++;
                }// end of for (all recs)

                if (Status != WINSINTF_SUCCESS)
                    break;

                //
                // If a range was chosen and records
                // retrieved are == the limit of 100
                // and if the Max vers no retrieved
                // is less than that specified, ask
                // user if he wishes to continue
                //
                if (!fSetFilter)
                {
                    DisplayMessage(g_hModule,
                                   MSG_WINS_RECORDS_SEARCHED,
                                   Recs.NoOfRecs);                    
                }
                if ( Recs.NoOfRecs < Recs.TotalNoOfRecs and 
                     LiLtr((--pRow)->VersNo,HighVersNo) )
                {
                    LowVersNo.QuadPart = LiAdd(pRow->VersNo, sTmpVersNo);
                    continue;
                }

                DisplayMessage(g_hModule, 
                               MSG_WINS_SEARCHDB_COUNT, 
                               TotalCnt);

                
                break;
            }
            pwszTempTgt = WinsOemToUnicode(pTgtAdd, NULL);

            if( pwszTempTgt is NULL )
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_OUT_OF_MEMORY);
                Status = WINSINTF_FAILURE;
                break;
            }

            DisplayMessage(g_hModule,
                           MSG_WINS_NO_RECORD,
                           pwszTempTgt);
            WinsFreeMemory(pwszTempTgt);
            pwszTempTgt = NULL;

        }
        else
        {
            pwszTempTgt = WinsOemToUnicode(pTgtAdd, NULL);

            if( pwszTempTgt is NULL )
            {
                DisplayMessage(g_hModule,
                               EMSG_WINS_OUT_OF_MEMORY);
                
                break;
            }

            DisplayMessage(g_hModule,
                           MSG_WINS_NO_RECORD, 
                           pwszTempTgt);

            WinsFreeMemory(pwszTempTgt);
            pwszTempTgt = NULL;

        }
        break;

    } // while (TRUE)


    DisplayMessage(g_hModule,
                   MSG_SRVR_RECORD_MATCH,
                   dwCount);



    if( fOpenFile is TRUE )
    {
        fclose(pFile);
        pFile = NULL;
    }

    g_dwSearchCount += dwCount;

    if (Recs.pRow != NULL)
    {
        WinsFreeMem(Recs.pRow);
    }
    return(Status);
} // GetDbRecs

LPWSTR
GetDateTimeString(DWORD_PTR TimeStamp,
                  BOOL      fShort,
                  int      *piType
                  )
{

    DWORD       Status = NO_ERROR,
                dwTime = 0;
    int         iType = 1;

    LPWSTR      pwszTime = NULL;
    
    if( TimeStamp is INFINITE_EXPIRATION )
    {
        iType = 1;
    }
    else
    {
        Status = FormatDateTimeString(TimeStamp,
                                      fShort,
                                      NULL,
                                      &dwTime);

        if( Status is NO_ERROR )
        {
            pwszTime = WinsAllocateMemory((dwTime+1)*sizeof(WCHAR));

            if( pwszTime )
            {
                dwTime++;

                Status = FormatDateTimeString(TimeStamp,
                                              fShort,
                                              pwszTime,
                                              &dwTime);

            }
            if( Status is NO_ERROR )
            {
                iType = 0;
            }
        }
    }

    *piType = iType;
    return pwszTime;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\netsh\verify.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/

#include "precomp.h"



NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    );

void DisplayInfo(int uNames, u_long ulValidAddr);

LPWSTR ToWCS(LPCSTR szMBCSString)
{
	int     nResult = 0;
    LPWSTR  lpWideString = NULL;
	// determone the size first
	nResult = MultiByteToWideChar(
						CP_ACP,
						0,
						szMBCSString,
						-1,
						lpWideString,
						0);

    lpWideString = WinsAllocateMemory((nResult+1)*sizeof(WCHAR));

    if( lpWideString is NULL )
        return NULL;

	nResult = MultiByteToWideChar(
						CP_ACP,
						MB_COMPOSITE,
						szMBCSString,
						-1,
						lpWideString,
						(nResult+1)*sizeof(WCHAR));
    
    if( nResult is 0 )
    {
        WinsFreeMemory(lpWideString);
        lpWideString = NULL;
    }
    else
    {
        lpWideString[nResult + 1] = '\0';
    }
    return lpWideString;
}

//------------------------------------------------------------------------
NTSTATUS
GetIpAddress(
    IN HANDLE           fd,
    OUT PULONG          pIpAddress
    )

/*++

Routine Description:

    This function calls into netbt to get the ip address.

Arguments:

   fd - file handle to netbt
   pIpAddress - the ip address returned

Return Value:

   ntstatus

History:
    27-Dec-1995 CDermody    copied from nbtstat.c

--*/

{
    NTSTATUS    status;
    ULONG       BufferSize=100;
    PVOID       pBuffer;

    pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = DeviceIoCtrl(fd,
                         pBuffer,
                         BufferSize,
                         IOCTL_NETBT_GET_IP_ADDRS,
                         NULL,
                         0);

    if (NT_SUCCESS(status))
    {
        *pIpAddress = *(ULONG *)pBuffer;
    }
    else
    {
        *pIpAddress = 0;
    }

    LocalFree(pBuffer);

    return(status);
}

//------------------------------------------------------------------------
NTSTATUS
GetInterfaceList
(
    char pDeviceName[][MAX_NAME+1]
)
{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string, AnsiString;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    char                pNbtWinsDeviceName[MAX_NAME] = "\\Device\\NetBt_Wins_Export";

    PUCHAR  SubKeyParms = "system\\currentcontrolset\\services\\netbt\\parameters";
    PUCHAR  Scope = "ScopeId";
    CHAR    pScopeBuffer[BUFF_SIZE];
    HKEY    Key;
    LONG    Type;
    ULONG   size;

    NETBT_INTERFACE_INFO    *pInterfaceInfo;
    ULONG                   InterfaceInfoSize = 10 * sizeof(NETBT_ADAPTER_INDEX_MAP) + sizeof(ULONG);
    PVOID                   pInput = NULL;
    ULONG                   SizeInput = 0;

    LONG    i, index = 0;

    pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize);
    if (!pInterfaceInfo)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlInitString(&name_string, pNbtWinsDeviceName);
    RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uc_name_string,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = NtCreateFile (&StreamHandle,
                           SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0);

    RtlFreeUnicodeString(&uc_name_string);

    if (NT_SUCCESS (status))
    {
        do
        {
            status = DeviceIoCtrl(StreamHandle,
                                 pInterfaceInfo,
                                 InterfaceInfoSize,
                                 IOCTL_NETBT_GET_INTERFACE_INFO,
                                 pInput,
                                 SizeInput);

            if (status == STATUS_BUFFER_OVERFLOW)
            {
                LocalFree(pInterfaceInfo);

                InterfaceInfoSize *= 2;
                pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize);
                if (!pInterfaceInfo || (InterfaceInfoSize == 0xFFFF))
                {
                    NtClose(StreamHandle);
                    //NlsPerror(COMMON_UNABLE_TO_ALLOCATE_PACKET,0);
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }
            }
            else if (!NT_SUCCESS (status))
            {
                NtClose(StreamHandle);
                return(status);
            }

        } while (status == STATUS_BUFFER_OVERFLOW);
        NtClose (StreamHandle);

        for (i = 0; i<pInterfaceInfo->NumAdapters; i++)
        {
            RtlInitString(&name_string, NULL);
            RtlInitUnicodeString(&uc_name_string, pInterfaceInfo->Adapter[i].Name);
            if (NT_SUCCESS(RtlUnicodeStringToAnsiString(&name_string, &uc_name_string, TRUE)))
            {
                size = (name_string.Length > MAX_NAME) ? MAX_NAME : name_string.Length;

                strncpy(pDeviceName[index], name_string.Buffer, size);
                pDeviceName[index][size] = '\0';
                RtlFreeAnsiString (&name_string);

                index++;
            }
        }

        //
        // NULL out the next device string ptr
        //
        if (index < NBT_MAXIMUM_BINDINGS)
        {
            pDeviceName[index][0] = '\0';
        }

        //
        // Read the ScopeId key!
        //
        size = BUFF_SIZE;
        *pScope = '\0';     // By default
        status = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                     SubKeyParms,
                     0,
                     KEY_READ,
                     &Key);

        if (status == ERROR_SUCCESS)
        {
            // now read the Scope key
            status = RegQueryValueExA(Key, Scope, NULL, &Type, pScopeBuffer, &size);
            if (status == ERROR_SUCCESS)
            {
                strcpy(pScope,pScopeBuffer);
            }
            status = RegCloseKey(Key);
        }

        status = STATUS_SUCCESS;
    }

    return status;
}

//------------------------------------------------------------------------
NTSTATUS
OpenNbt(
    IN char path[][MAX_NAME+1],
    OUT PHANDLE pHandle,
    int max_paths
    )
{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    LONG                index=0;

    ASSERT ( max_paths <= NBT_MAXIMUM_BINDINGS );

    while ((path[index][0] != '\0') && (index < max_paths))
    {
        RtlInitString(&name_string, path[index]);
        RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &uc_name_string,
            OBJ_CASE_INSENSITIVE,
            (HANDLE) NULL,
            (PSECURITY_DESCRIPTOR) NULL
            );

        status =
        NtCreateFile(
            &StreamHandle,
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
            &ObjectAttributes,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_OPEN_IF,
            0,
            NULL,
            0);

        RtlFreeUnicodeString(&uc_name_string);

        if (NT_SUCCESS(status))
        {
            *pHandle = StreamHandle;
            return(status);
        }

        ++index;
    }

    return (status);
} // s_open

//------------------------------------------------------------------------
NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    )

/*++

Routine Description:

    This procedure performs an ioctl(I_STR) on a stream.

Arguments:

    fd        - NT file handle
    iocp      - pointer to a strioctl structure

Return Value:

    0 if successful, non-zero otherwise.

History:
    27-Dec-1995 CDermody    copied from nbtstat.c
--*/

{
    NTSTATUS                        status;
    int                             retval;
    ULONG                           QueryType;
    IO_STATUS_BLOCK                 iosb;


    status = NtDeviceIoControlFile(
                      fd,                      // Handle
                      NULL,                    // Event
                      NULL,                    // ApcRoutine
                      NULL,                    // ApcContext
                      &iosb,                   // IoStatusBlock
                      Ioctl,                   // IoControlCode
                      pInput,                  // InputBuffer
                      SizeInput,               // InputBufferSize
                      (PVOID) ReturnBuffer,    // OutputBuffer
                      BufferSize);             // OutputBufferSize


    if (status == STATUS_PENDING)
    {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
        if (NT_SUCCESS(status))
        {
            status = iosb.Status;
        }
    }

    return(status);
}

/****************************************************************************/
/*      CheckRemoteTable                                                    */
/*                                                                          */
/*  This routine does an adapter status query to get the remote name table  */
/*  then checks to see if a netbios name is contained in it.                */
/*                                                                          */
/*  Parameters:                                                             */
/*      RemoteName, the IP address (asci nn.nn.nn.nn format) of a server to */
/*                  query.                                                  */
/*      SearchName, a net bios name.                                        */
/*                                                                          */
/*  Return:                                                                 */
/*      WINSTEST_VERIFIED       The name exists in the remote name table    */
/*      WINSTEST_NOT_VERIFIED   The name does not exist in the remote table */
/*      WINSTEST_BAD_IP_ADDRESS inet_addr could not convert the ip address  */
/*                              character string.                           */
/*      WINSTEST_HOST_NOT_FOUND Could not reach ip address                  */
/*      WINSTEST_OUT_OF_MEMORY  Out of memory                               */
/*  History:                                                                */
/*      27-Dec-1995     CDermody    created following example of nbtstat.c  */
/****************************************************************************/

int
CheckRemoteTable(
    IN HANDLE   fd,
    IN PCHAR    RemoteName,
    IN PCHAR    SearchName
    )

{
    LONG                        Count;
    LONG                        i;
    PVOID                       pBuffer;
    ULONG                       BufferSize=600;
    NTSTATUS                    status;
    tADAPTERSTATUS              *pAdapterStatus;
    NAME_BUFFER                 *pNames;
    CHAR                        MacAddress[20];
    tIPANDNAMEINFO              *pIpAndNameInfo;
    ULONG                       SizeInput;
    ULONG                       IpAddress;
    USHORT                      BytesToCopy;


    pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
    if (!pBuffer)
    {
        return(WINSTEST_OUT_OF_MEMORY);
    }

    status = STATUS_BUFFER_OVERFLOW;
    pIpAndNameInfo = LocalAlloc(LMEM_FIXED,sizeof(tIPANDNAMEINFO));
    if (!pIpAndNameInfo)
    {
        LocalFree(pBuffer);
        return(WINSTEST_OUT_OF_MEMORY);
    }

    RtlZeroMemory((PVOID)pIpAndNameInfo,sizeof(tIPANDNAMEINFO));
    
    //
    // Convert the remote name which is really a dotted decimal ip address
    // into a ulong
    //
    IpAddress = inet_addr(RemoteName);
    
    //
    // Don't allow zero for the address since it sends a broadcast and
    // every one responds
    //
    if ((IpAddress == INADDR_NONE) || (IpAddress == 0))
    {
        LocalFree(pBuffer);
        LocalFree(pIpAndNameInfo);
    
        return(WINSTEST_BAD_IP_ADDRESS);
    }

    pIpAndNameInfo->IpAddress = ntohl(IpAddress);

    pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosName[0] = '*';


    pIpAndNameInfo->NetbiosAddress.TAAddressCount = 1;
    pIpAndNameInfo->NetbiosAddress.Address[0].AddressLength
        = sizeof(TDI_ADDRESS_NETBIOS);
    pIpAndNameInfo->NetbiosAddress.Address[0].AddressType
        = TDI_ADDRESS_TYPE_NETBIOS;
    pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosNameType
        = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    SizeInput = sizeof(tIPANDNAMEINFO);

    while (status == STATUS_BUFFER_OVERFLOW)
    {
        status = DeviceIoCtrl(fd,
                             pBuffer,
                             BufferSize,
                             IOCTL_NETBT_ADAPTER_STATUS,
                             pIpAndNameInfo,
                             SizeInput);

        if (status == STATUS_BUFFER_OVERFLOW)
        {
            LocalFree(pBuffer);

            BufferSize *=2;
            pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
            if (!pBuffer || (BufferSize == 0xFFFF))
            {
                LocalFree(pIpAndNameInfo);

                return(WINSTEST_OUT_OF_MEMORY);
            }
        }
    }

    pAdapterStatus = (tADAPTERSTATUS *)pBuffer;
    if ((pAdapterStatus->AdapterInfo.name_count == 0) ||
        (status != STATUS_SUCCESS))
    {
        LocalFree(pIpAndNameInfo);
        LocalFree(pBuffer);
        
        return(WINSTEST_HOST_NOT_FOUND);
    }

    pNames = pAdapterStatus->Names;
    Count = pAdapterStatus->AdapterInfo.name_count;

    status = 1;

    while (Count--)
    {
        if (0 == _strnicmp(SearchName, pNames->name, strlen(SearchName)))
        {
            LocalFree(pIpAndNameInfo);
            LocalFree(pBuffer);
            
            return WINSTEST_VERIFIED; // found
        }
        
        pNames++;
    }

    LocalFree(pIpAndNameInfo);
    LocalFree(pBuffer);

    return WINSTEST_NOT_VERIFIED;
}


/****************************************************************************/
/*      VerifyRemote                                                        */
/*                                                                          */
/*  This routine checks to see if a netbios name is contained in the remote */
/*  name table at a given IP address.                                       */
/*                                                                          */
/*  Parameters:                                                             */
/*      RemoteName, the IP address (asci nn.nn.nn.nn format) of a server to */
/*                  query.                                                  */
/*      NBName,     a net bios name.                                        */
/*                                                                          */
/*  Return:                                                                 */
/*      WINSTEST_VERIFIED       The name exists in the remote name table    */
/*      WINSTEST_NOT_VERIFIED   The name does not exist in the remote table */
/*      WINSTEST_BAD_IP_ADDRESS inet_addr could not convert the ip address  */
/*                              character string.                           */
/*      WINSTEST_OPEN_FAILED    Could not open NBT driver or could not read */
/*                              the NBT driver info from the registry.      */
/*      WINSTEST_HOST_NOT_FOUND Could not reach ip address                  */
/*      WINSTEST_OUT_OF_MEMORY  Out of memory                               */
/*  History:                                                                */
/*      27-Dec-1995     CDermody    created following example of nbtstat.c  */
/****************************************************************************/

int VerifyRemote(IN PCHAR RemoteName, IN PCHAR NBName)
{
    NTSTATUS    status;
    LONG        interval=-1;
    HANDLE      nbt = 0;
    int         nStatus;
    int         index;
    CHAR        pDeviceName[NBT_MAXIMUM_BINDINGS+1][MAX_NAME+1];
    
    status = GetInterfaceList(pDeviceName);
    if (!NT_SUCCESS(status))
    {
        return WINSTEST_OPEN_FAILED;
    }

    for (index = 0; index < NBT_MAXIMUM_BINDINGS && pDeviceName[index][0]; index++)
    {
        //
        //  Open the device of the appropriate streams module to start with.
        //
        status = OpenNbt(&pDeviceName[index], &nbt, NBT_MAXIMUM_BINDINGS-index);
        if (!NT_SUCCESS(status))
        {
            //
            // Try the next binding!
            //
            continue;
        }

        GetIpAddress(nbt, &NetbtIpAddress);

        if (RemoteName[0] == '\0')
            return WINSTEST_INVALID_ARG;
    
        status = (NTSTATUS)CheckRemoteTable(nbt,RemoteName,NBName);
        if (status == WINSTEST_VERIFIED)
            break;
    }

    return status;
}

/*************************************************************/
/*        NBEncode(name2,name)                               */
/*                                                           */
/* This routine code a netbios name from level1 to level2.   */
/* name2 has to be NBT_NAMESIZE bytes long, remember that.   */
/*************************************************************/

void
NBEncode(
    unsigned char *name2,
    unsigned char *name
    )
{
    int i;

    name2[0] = 0x20;        /* length of first block */

    for (i = 0; i < NBT_NONCODED_NMSZ - 1; i++)
    {
        name2[ 2*i+1 ] =  ((name[ i ] >> 4) & 0x0f) + 0x41;
        name2[ 2*i+2 ] =  (name[ i ]  & 0x0f) + 0x41;
    }

    name2[ NBT_NAMESIZE-1 ] = 0;    /* length of next block */
}

/*******************************************************************/
/*                                                                 */
/* Send a Name Query to a WINS Server                              */
/*                                                                 */
/* name is the name to query                                       */
/* winsaddr is the ip address of the wins server to query          */
/* TransID is the transaction ID to use for the query              */
/*                                                                 */
/*******************************************************************/

void
SendNameQuery(
    unsigned char *name,
    u_long winsaddr,
    u_short TransID
    )
{
    struct sockaddr_in destad;
    char    lpResults[MAX_SIZE] = {0};
    char    paddedname[NBT_NONCODED_NMSZ];
    USHORT usEndPoint = 5005;
    int     err = 0;

    struct
    {
        u_short TransactionID;
        u_short Flags;
        u_short QuestionCount;
        u_short AnswerCount;
        u_short NSCount;
        u_short AdditionalRec;
        u_char  QuestionName[NBT_NAMESIZE];
        u_short QuestionType;
        u_short QuestionClass;
    } NameQuery;

    memset(paddedname, 0x20, sizeof(paddedname));
    memcpy(paddedname, name, strlen(name));

    NBEncode(NameQuery.QuestionName, paddedname);

    NameQuery.TransactionID = htons(TransID);
    NameQuery.Flags = htons(0x0100);
    NameQuery.QuestionCount = htons(1);
    NameQuery.AnswerCount = 0;
    NameQuery.NSCount = 0;
    NameQuery.AdditionalRec = 0;
    NameQuery.QuestionType = htons(0x0020);
    NameQuery.QuestionClass = htons(1);

    destad.sin_family = AF_INET;
    destad.sin_port = htons(137);
    destad.sin_addr.s_addr = winsaddr;


    err = sendto(sd, (char *)&NameQuery, sizeof(NameQuery), 0,
                   (struct sockaddr *)&destad, sizeof(myad));
    
    if( err is SOCKET_ERROR )
    {
        DisplayErrorMessage(EMSG_WINS_SENDTO_FAILED, WSAGetLastError());
        return;
    }
}

/*******************************************************************/
/*                                                                 */
/* Wait for a Name Response which matches the Transaction ID       */
/*                                                                 */
/* recvaddr is the ip address returned by the wins server          */
/*                                                                 */
/*******************************************************************/

int
GetNameResponse(
    u_long * recvaddr,
	u_short  TransactionID
    )

{
    char lpResults[100] = {0};
    int i;
    int len;
    int rslt;
    u_long AnswerAddr;
    struct sockaddr_in addr;
    NameResponse * pNameResponse = NULL;
    BYTE Buf[NAME_RESPONSE_BUFFER_SIZE] = {0};

    i = 0;
    while (i < 15)
    {
        addrlen = sizeof(addr);
        if ((len=recvfrom(sd, (char *) Buf, sizeof(Buf), 0,
                     (struct sockaddr *)&addr, &addrlen)) < 0)
        {
            rslt = WSAGetLastError();
            if (rslt == WSAEWOULDBLOCK)
            {
                Sleep(100);
                i++;
                continue;
            }
            else
            {
                DisplayErrorMessage(EMSG_WINS_GETRESPONSE_FAILED,
                                    rslt);
                return WINSTEST_NO_RESPONSE;
            }
        }

        pNameResponse = (NameResponse *) Buf;

        if (TransactionID == htons(pNameResponse->TransactionID))
        {
            if (htons(pNameResponse->AnswerCount) == 0)
            {
                *recvaddr = 0;
                return(WINSTEST_NOT_FOUND);
            }
        
            AnswerAddr = (pNameResponse->AnswerAddr2 << 16) | pNameResponse->AnswerAddr1;
            *recvaddr = AnswerAddr;
            
            return(WINSTEST_FOUND);
        }
    }
    
    *recvaddr = 0;
    
    return(WINSTEST_NO_RESPONSE);
}

INT
InitNameCheckSocket()
{
	WCHAR lpResults[MAX_SIZE];
    BOOL  fBroadcast = TRUE;
    INT   err = 0;

    /*  Set up a socket to use for querys and responses   */

    WSAStartup( 0x0101, &WsaData ); // make sure winsock is happy - noop for now

    if ((sd = socket( AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)
    {
        DisplayErrorMessage(EMSG_WINS_NAMECHECK_FAILED,
                            WSAGetLastError());

		return WSAGetLastError(); 
    }

    myad.sin_family = AF_INET;
    myad.sin_addr.s_addr = htonl(INADDR_ANY);//htonl(INADDR_BROADCAST);//INADDR_ANY;
    myad.sin_port = htons(0);//htons(usEndPoint);

    if (bind( sd, (struct sockaddr *)&myad, sizeof(myad) ) < 0)
    {
        DisplayErrorMessage(EMSG_WINS_NAMECHECK_FAILED,
                            WSAGetLastError());
        
        closesocket( sd );
		return WSAGetLastError(); 
    }

    if (ioctlsocket(sd, FIONBIO, &NonBlocking) < 0)
    {
        DisplayErrorMessage(EMSG_WINS_NAMECHECK_FAILED,
                            WSAGetLastError());
		return WSAGetLastError(); 
    }

	return 0;
}

INT 
CloseNameCheckSocket()
{
	closesocket(sd);

	WSACleanup();

	return 0;
}



INT
CheckNameConsistency()
{
    int             status = 0;
    int             i, j;
    int             Pass;
    int             ServerInx, NameInx, Inx;
    struct in_addr  retaddr;
    struct in_addr  tempaddr;
    u_long          temp;
    WINSERVERS *    ServerTemp;
    int             retry;
	FILE *          nf;
    WCHAR           szBuffer[MAX_SIZE] = {L'\0'};
    WCHAR           szNum[10];
    WCHAR           lpResults[200] = {L'\0'};
    WCHAR           wcName[21] = {L'\0'};
    BOOL            fDone = FALSE;
    LPWSTR          pwszTempBuf = NULL;

    // initialize some things

    memset(VerifiedAddress, 0, sizeof(VerifiedAddress));

    status = InitNameCheckSocket();

    // if the query is sent to the local server, TranIDs less than 0x7fff are dropped by NetBT
    TranID = 0x8000;
        
    if( status )
        return status;

    for (i = 0; i < MAX_SERVERS; i++)
    {
        WinServers[i].LastResponse = -1;
        WinServers[i].fQueried = FALSE;
        WinServers[i].Valid = 0;
        WinServers[i].Failed = 0;
        WinServers[i].Retries = 0;
        WinServers[i].Completed = 0;
    }
 
    /*  We initially have no failed servers   */

    for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
    {
        ServerTemp = &WinServers[ServerInx];
		ServerTemp->Failed = 0;
    }

    for (NameInx = 0; NameInx < NumNBNames; NameInx++)
    {
        CHAR    cchEnd = 0x00;
        cchEnd = NBNames[NameInx][15];
        NBNames[NameInx][15] = 0x00;

        pwszTempBuf = WinsOemToUnicode(NBNames[NameInx], NULL);
        NBNames[NameInx][15] = cchEnd;

        if( pwszTempBuf is NULL )
        {
            DisplayMessage(g_hModule,
                           EMSG_WINS_OUT_OF_MEMORY);
            return FALSE;
        }
        wcsncpy(wcName, pwszTempBuf, 15);
        
        WinsFreeMemory(pwszTempBuf);
        pwszTempBuf = NULL;

        for( j=wcslen(wcName); j<16; j++ )
        {
            wcName[j] = L' ';
        }

        wcName[15] = L'[';
        WinsHexToString(wcName+16, (LPBYTE)&cchEnd, 1);
        wcName[18] = L'h';
        wcName[19] = L']';
        wcName[20] = L'\0';
        for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
        {
            ServerTemp = &WinServers[ServerInx];

            if (ServerTemp->Completed)
            {
                continue;
            }

            retry = 0;
            TranID++;

            fDone = FALSE;

            while( !fDone )
            {      
                pwszTempBuf = WinsOemToUnicode(inet_ntoa(ServerTemp->Server), NULL);
                if( pwszTempBuf is NULL )
                {
                    DisplayMessage(g_hModule,
                                   EMSG_WINS_OUT_OF_MEMORY);
                    return FALSE;
                }

                DisplayMessage(g_hModule,
                               MSG_WINS_SEND_NAMEQUERY,
                               pwszTempBuf,
                               wcName);

                WinsFreeMemory(pwszTempBuf);
                pwszTempBuf = NULL;

                SendNameQuery(NBNames[NameInx],
                              ServerTemp->Server.s_addr,
                              TranID);

                switch (GetNameResponse(&retaddr.s_addr, TranID))
                {
                case WINSTEST_FOUND:     // found
                    ServerTemp->RetAddr.s_addr = retaddr.s_addr;
                    ServerTemp->Valid = 1;
                    ServerTemp->LastResponse = NameInx;

                    if (retaddr.s_addr == VerifiedAddress[NameInx])
                    {
                        // this address has already been verified... don't
                        // do the checking again
                        DisplayMessage(g_hModule,
                                       MSG_WINS_DISPLAY_STRING,
                                       wszOK);
                        fDone = TRUE;
                        break;
                    }

                    status = VerifyRemote(inet_ntoa(ServerTemp->RetAddr),
                                          NBNames[NameInx]);


                    if (WINSTEST_VERIFIED == status)
                    {
                        DisplayMessage(g_hModule,
                                       MSG_WINS_DISPLAY_STRING,
                                       wszOK);
                        VerifiedAddress[NameInx] = retaddr.s_addr;
                    }
                    else
                    {
                        DisplayMessage(g_hModule,
                                       MSG_WINS_DISPLAY_STRING,
                                       wszNameVerify);//wszFailure);
                    }
                
                    fDone = TRUE;
                    break;

                case WINSTEST_NOT_FOUND:     // responded -- name not found
                    ServerTemp->RetAddr.s_addr = retaddr.s_addr;
                    ServerTemp->Valid = 0;
                    ServerTemp->LastResponse = NameInx;
                
                    DisplayMessage(g_hModule, EMSG_WINS_NAME_NOT_FOUND);
                    retry++;
                    if (retry > 2)
                    {
                        ServerTemp->Failed = 1;
                        fDone = TRUE;
                    }
                    break;

                case WINSTEST_NO_RESPONSE:     // no response
                    ServerTemp->RetAddr.s_addr = retaddr.s_addr;
                    ServerTemp->Valid = 0;
                    ServerTemp->Retries++;

					DisplayMessage(g_hModule, EMSG_WINS_NO_RESPONSE);

                    retry++;
                    if (retry > 2)
                    {
                        ServerTemp->Failed = 1;
                        fDone = TRUE;
                    }
                
                    break;
                default:
                    break;
                }   // switch GetNameResponse
            }   //while loop
        }   // for ServerInx

        //Find a server address for this name
        for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
        {

            ServerTemp = &WinServers[ServerInx];
            if (ServerTemp->Valid)
            {
                DisplayMessage(g_hModule,
                               MSG_WINS_RESULTS);
                DisplayInfo(NameInx, ServerTemp->RetAddr.s_addr);
                break;
            }
        }   // for ServerInx

    }   //Name for loop
        

    //Mark all successful servers as completed;
    for( ServerInx = 0; ServerInx < NumWinServers; ServerInx++ )
    {
        ServerTemp = &WinServers[ServerInx];
        if( !ServerTemp->Failed )
        {
            ServerTemp->Completed = 1;
        }
    }

    DisplayMessage(g_hModule,
                   MSG_WINS_FINAL_RESULTS);

    for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
    {
        ServerTemp = &WinServers[ServerInx];

        pwszTempBuf = WinsOemToUnicode(inet_ntoa(ServerTemp->Server), NULL);

        if( pwszTempBuf is NULL )
        {
            DisplayMessage(g_hModule,
                           EMSG_WINS_OUT_OF_MEMORY);
            return FALSE;
        }
        if ((-1) == ServerTemp->LastResponse)
        {
            DisplayMessage(g_hModule, 
                           EMSG_WINS_WINS_NEVERRESPONDED,
                           pwszTempBuf);
        }
        else if (0 == ServerTemp->Completed)
        {
            DisplayMessage(g_hModule, 
                           EMSG_WINS_WINS_INCOMPLETE,
                           pwszTempBuf);
        }
        WinsFreeMemory(pwszTempBuf);
        pwszTempBuf = NULL;
    }   // for ServerInx

    for (NameInx = 0; NameInx < NumNBNames; NameInx++)
    {
        CHAR cchEnd = NBNames[NameInx][15];
        NBNames[NameInx][15] = '\0';

        pwszTempBuf = WinsOemToUnicode(NBNames[NameInx], NULL);
        NBNames[NameInx][15] = cchEnd;        
        
        if( pwszTempBuf is NULL )
        {
            DisplayMessage(g_hModule,
                           EMSG_WINS_OUT_OF_MEMORY);
            return FALSE;
        }
        
        wcsncpy(wcName, pwszTempBuf, 15);
        
        WinsFreeMemory(pwszTempBuf);
        pwszTempBuf = NULL;

        for( j = wcslen(wcName); j < 16; j++ )
        {
            wcName[j] = L' ';
        }

        wcName[15] = L'[';
        WinsHexToString(wcName+16, (LPBYTE)&cchEnd, 1);
        wcName[18] = L'h';
        wcName[19] = L']';
        wcName[20] = L'\0';
        if (0 == VerifiedAddress[NameInx])
        {
            DisplayMessage(g_hModule, 
                           EMSG_WINS_ADDRESS_VERIFY_FAILED,
                           wcName);
        }
    }   // for NameInx

    DisplayMessage(g_hModule,
                   WINS_FORMAT_LINE);
    CloseNameCheckSocket();
    return 1;   // just to keep the compiler happy -- why do we have to?
}

void DisplayInfo(int uNames, u_long ulValidAddr)
{
    int             uServers;
    CHAR            cchEnd = 0x00;
    LPWSTR          pwszTemp = NULL;
    WINSERVERS *    pCurrentServer;
    struct in_addr  tempaddr;
    int             i, j;
    BOOL            fMismatchFound = FALSE;
    WCHAR           wcName[21] = {L'\0'};

    cchEnd = NBNames[uNames][15];
    NBNames[uNames][15] = 0x00;

    pwszTemp = WinsOemToUnicode(NBNames[uNames], NULL);
    NBNames[uNames][15] = cchEnd;

    if( pwszTemp is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_WINS_NOT_ENOUGH_MEMORY);
        return;
    }    
    
    wcsncpy(wcName, pwszTemp, 15);
    
    for( j=wcslen(wcName); j<16; j++ )
    {
        wcName[j] = L' ';
    }

    wcName[15] = L'[';
    WinsHexToString(wcName+16, (LPBYTE)&cchEnd, 1);
    wcName[18] = L'h';
    wcName[19] = L']';
    wcName[20] = L'\0';
    
    WinsFreeMemory(pwszTemp);
    pwszTemp = NULL;

	// now check and see which WINS servers didn't match
	for (uServers = 0; uServers < NumWinServers; uServers++)
    {
		pCurrentServer = &WinServers[uServers];

        if (pCurrentServer->Completed)
        {
            continue;
        }
        
        if ( (pCurrentServer->Valid) )
        {
            if ( (pCurrentServer->RetAddr.s_addr != ulValidAddr) || 
				 (VerifiedAddress[uNames] != 0 && 
				  VerifiedAddress[uNames] != ulValidAddr) )
            {

				// mismatch
                DisplayMessage(g_hModule,
                               EMSG_WINS_NAME_INCONSISTENCY,
                               wcName);

                if (VerifiedAddress[uNames] != 0)
                {
                    tempaddr.s_addr = VerifiedAddress[uNames];
                    
                    DisplayMessage(g_hModule,
                                   EMSG_WINS_VERIFIED_ADDRESS,
                                   IpAddressToString(ntohl(tempaddr.S_un.S_addr)));
                }
                
				// display the inconsistent name resolutions
                for (i = 0; i < NumWinServers; i++)
                {
                    if (WinServers[i].Valid &&
						VerifiedAddress[uNames] != WinServers[i].RetAddr.S_un.S_addr)
                    {
                        DisplayMessage(g_hModule,
                                       EMSG_WINS_NAMEQUERY_RESULT,
                                       IpAddressToString(ntohl(WinServers[i].Server.S_un.S_addr)),
                                       wcName,
                                       IpAddressToString(ntohl(WinServers[i].RetAddr.S_un.S_addr)));
                    }
                }
                fMismatchFound = TRUE;
                break;
            }
        }
    }   // end check for invalid addresses

    if (!fMismatchFound)
    {
        // display the correct info
        DisplayMessage(g_hModule,
                       EMSG_WINS_NAME_VERIFIED,
                       wcName,
                       IpAddressToString(ntohl(ulValidAddr)));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\perfctrs\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfmsg.h  

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

      Bob Watson (a-robw) 5 Oct 92

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  TEXT("WINSCTRS")

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging 
//             LOG_VERBOSE = Maximum Debugging 
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:   
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the 
// 
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could 
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\perfctrs\debug.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    debug.h

    This file contains a number of debug-dependent definitions for
    the WINS Service.


    FILE HISTORY:
        Pradeepb     07-Mar-1993 Created.

*/


#ifndef _DEBUG_H_
#define _DEBUG_H_


#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#if DBG

//
//  Debug output control flags.
//

#define WINSD_DEBUG_ENTRYPOINTS          0x00000001L     // DLL entrypoints
#define WINSD_DEBUG_OPEN                 0x00000002L     // OpenPerformanceData
#define WINSD_DEBUG_CLOSE                0x00000004L     // CollectPerformanceData
#define WINSD_DEBUG_COLLECT              0x00000008L     // ClosePerformanceData
// #define WINSD_DEBUG_                     0x00000010L
// #define WINSD_DEBUG_                     0x00000020L
// #define WINSD_DEBUG_                     0x00000040L
// #define WINSD_DEBUG_                     0x00000080L
// #define WINSD_DEBUG_                     0x00000100L
// #define WINSD_DEBUG_                     0x00000200L
// #define WINSD_DEBUG_                     0x00000400L
// #define WINSD_DEBUG_                     0x00000800L
// #define WINSD_DEBUG_                     0x00001000L
// #define WINSD_DEBUG_                     0x00002000L
// #define WINSD_DEBUG_                     0x00004000L
// #define WINSD_DEBUG_                     0x00008000L
// #define WINSD_DEBUG_                     0x00010000L
// #define WINSD_DEBUG_                     0x00020000L
// #define WINSD_DEBUG_                     0x00040000L
// #define WINSD_DEBUG_                     0x00080000L
// #define WINSD_DEBUG_                     0x00100000L
// #define WINSD_DEBUG_                     0x00200000L
// #define WINSD_DEBUG_                     0x00400000L
// #define WINSD_DEBUG_                     0x00800000L
// #define WINSD_DEBUG_                     0x01000000L
// #define WINSD_DEBUG_                     0x02000000L
// #define WINSD_DEBUG_                     0x04000000L
// #define WINSD_DEBUG_                     0x08000000L
// #define WINSD_DEBUG_                     0x10000000L
// #define WINSD_DEBUG_                     0x20000000L
#define WINSD_DEBUG_OUTPUT_TO_DEBUGGER   0x40000000L
// #define WINSD_DEBUG_                     0x80000000L

extern DWORD WinsdDebug;

#define IF_DEBUG(flag) if ( (WinsdDebug & WINSD_DEBUG_ ## flag) != 0 )


//
//  Debug output function.
//

VOID WinsdPrintf( CHAR * pszFormat,
                 ... );

#define WINSD_PRINT(args) WinsdPrintf args


//
//  Assert & require.
//

VOID WinsdAssert( VOID  * pAssertion,
                 VOID  * pFileName,
                 ULONG   nLineNumber );

#define WINSD_ASSERT(exp) if (!(exp)) WinsdAssert( #exp, __FILE__, __LINE__ )
#define WINSD_REQUIRE WINSD_ASSERT

#else   // !DBG

//
//  No debug output.
//

#define IF_DEBUG(flag) if (0)


//
//  Null debug output function.
//

#define WINSD_PRINT(args)


//
//  Null assert & require.
//

#define WINSD_ASSERT(exp)
#define WINSD_REQUIRE(exp) ((VOID)(exp))

#endif  // DBG


#endif  // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\netsh\winsmon.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

--*/
#ifndef _WINSMON_H_
#define _WINSMON_H_



DWORD
WINAPI
WinsCommit(
    IN  DWORD   dwAction
);

BOOL 
WINAPI
WinsDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
);

NS_CONTEXT_ENTRY_FN WinsMonitor;

DWORD
WINAPI
WinsUnInit(
    IN  DWORD   dwReserved
);

BOOL
SetServerInfo(
    IN  LPCWSTR  pwszServerInfo
);

BOOL
IsHelpToken(
    PWCHAR  pwszToken
);

#endif //_WINSMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\perfctrs\debug.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    debug.c

    This module contains debug support routines for the WINS Service.


    FILE HISTORY:
        pradeepb     20-July-1993 Created.

*/


#include "debug.h"
//#include "winsif.h"
//#include "winsintf.h"


#if DBG

//
//  Private constants.
//

#define MAX_PRINTF_OUTPUT       1024            // characters
#define WINSD_OUTPUT_LABEL       "WINS"


//
//  Private types.
//


//
//  Private globals.
//


//
//  Public functions.
//

/*******************************************************************

    NAME:       WinsdAssert

    SYNOPSIS:   Called if an assertion fails.  Displays the failed
                assertion, file name, and line number.  Gives the
                user the opportunity to ignore the assertion or
                break into the debugger.

    ENTRY:      pAssertion - The text of the failed expression.

                pFileName - The containing source file.

                nLineNumber - The guilty line number.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
VOID WinsdAssert( VOID  * pAssertion,
                 VOID  * pFileName,
                 ULONG   nLineNumber )
{
    RtlAssert( pAssertion, pFileName, nLineNumber, NULL );

}   // WinsdAssert

/*******************************************************************

    NAME:       WinsdPrintf

    SYNOPSIS:   Customized debug output routine.

    ENTRY:      Usual printf-style parameters.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
VOID WinsdPrintf( CHAR * pszFormat,
                 ... )
{
    CHAR    szOutput[MAX_PRINTF_OUTPUT];
    va_list ArgList;

    sprintf( szOutput,
             "%s (%lu): ",
             WINSD_OUTPUT_LABEL,
             GetCurrentThreadId() );

    va_start( ArgList, pszFormat );
    vsprintf( szOutput + strlen(szOutput), pszFormat, ArgList );
    va_end( ArgList );

    IF_DEBUG( OUTPUT_TO_DEBUGGER )
    {
        OutputDebugString( (LPCTSTR)szOutput );
    }

}   // WinsdPrintf


//
//  Private functions.
//

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\netsh\winsmon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\wins\winsmon.c

Abstract:

    WINS Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 12/10/98

--*/

#include "precomp.h"

HANDLE   g_hModule = NULL;
BOOL     g_bCommit = TRUE;
BOOL     g_hConnect = FALSE;
DWORD    g_dwNumTableEntries = 0;


//{bf563723-9065-11d2-be87-00c04fc3357a}
static const GUID g_MyGuid = 
{ 0xbf563723, 0x9065, 0x11d2, { 0xbe, 0x87, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

static const GUID g_NetshGuid = NETSH_ROOT_GUID;

//


ULONG   g_ulInitCount = 0;

WCHAR   wszUnknown[50] = {L'\0'};
WCHAR   wszEnable[50] = {L'\0'};
WCHAR   wszDisable[50] = {L'\0'};
WCHAR   wszRandom[150] = {L'\0'};
WCHAR   wszOwner[150] = {L'\0'};
WCHAR   wszInfinite[100] = {L'\0'};
WCHAR   wszPush[50] = {L'\0'};
WCHAR   wszPull[50] = {L'\0'};
WCHAR   wszPushpull[50] = {L'\0'};
WCHAR   wszHigh[50] = {L'\0'};
WCHAR   wszNormal[50] = {L'\0'};
WCHAR   wszDeleted[150] = {L'\0'};
WCHAR   wszOK[50] = {L'\0'};
WCHAR   wszFailure[50] = {L'\0'};
WCHAR   wszReadwrite[50] = {L'\0'};
WCHAR   wszRead[50] = {L'\0'};
WCHAR   wszNo[50] = {L'\0'};
WCHAR   wszNameVerify[100] = {L'\0'};


WINSMON_SUBCONTEXT_TABLE_ENTRY  g_WinsSubContextTable[] =
{
    {L"Server", HLP_WINS_CONTEXT_SERVER, HLP_WINS_CONTEXT_SERVER_EX, SrvrMonitor},
};


CMD_ENTRY g_WinsCmds[] = 
{
    CREATE_CMD_ENTRY(WINS_DUMP, HandleWinsDump),
    CREATE_CMD_ENTRY(WINS_HELP1, HandleWinsHelp),
    CREATE_CMD_ENTRY(WINS_HELP2, HandleWinsHelp),
    CREATE_CMD_ENTRY(WINS_HELP3, HandleWinsHelp),
    CREATE_CMD_ENTRY(WINS_HELP4, HandleWinsHelp),
};



ULONG g_ulNumTopCmds = sizeof(g_WinsCmds)/sizeof(CMD_ENTRY);
ULONG g_ulNumSubContext = sizeof(g_WinsSubContextTable)/sizeof(WINSMON_SUBCONTEXT_TABLE_ENTRY);

DWORD
WINAPI
WinsCommit(
    IN  DWORD   dwAction
)
{
    BOOL    bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. Dhcp current state is commit, then
            // nothing to be done.
            //

            if(g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    return NO_ERROR;
}

BOOL 
WINAPI
WinsDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
)
{
    WORD wVersion = MAKEWORD(1,1); //Winsock version 1.1 will do?
    WSADATA wsaData;
    HINSTANCE hAdmin = NULL;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            if(WSAStartup(wVersion,&wsaData) isnot NO_ERROR)
            {
                return FALSE;
            }

            //Load certain common string to be used extensively 
     
            {
                //Load the general "UNKNOWN" string
                DWORD dw = 0;
                dw = LoadString(g_hModule,
                                WINS_GENERAL_UNKNOWN,
                                wszUnknown,
                                ARRAY_SIZE(wszUnknown));

                if( dw is 0 )
                    wcscpy(wszUnknown, L"Not Set");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_ENABLE,
                                wszEnable,
                                ARRAY_SIZE(wszEnable));

                if( dw is 0 )
                    wcscpy(wszEnable, L"Enabled");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_DISABLE,
                                wszDisable,
                                ARRAY_SIZE(wszDisable));

                if( dw is 0 )
                    wcscpy(wszDisable, L"Disabled");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_RANDOM,
                                wszRandom,
                                ARRAY_SIZE(wszRandom));

                if( dw is 0 )
                    wcscpy(wszRandom, L"Randomly Selected Partner");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_OWNER,
                                wszOwner,
                                ARRAY_SIZE(wszOwner));

                if( dw is 0 )
                    wcscpy(wszOwner, L"Owner Server");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_INFINITE,
                                wszInfinite,
                                ARRAY_SIZE(wszInfinite));

                if( dw is 0 )
                    wcscpy(wszInfinite, L"Infinite                ");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_PULL,
                                wszPull,
                                ARRAY_SIZE(wszPull));

                if( dw is 0 )
                    wcscpy(wszPull, L"    Pull");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_PUSH,
                                wszPush,
                                ARRAY_SIZE(wszPush));

                if( dw is 0 )
                    wcscpy(wszPush, L"    Push");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_PUSHPULL,
                                wszPushpull,
                                ARRAY_SIZE(wszPushpull));

                if( dw is 0 )
                    wcscpy(wszPushpull, L"  Push/Pull");


                dw = LoadString(g_hModule,
                                WINS_GENERAL_NORMAL,
                                wszNormal,
                                ARRAY_SIZE(wszNormal));

                if( dw is 0 )
                    wcscpy(wszNormal, L"NORMAL");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_HIGH,
                                wszHigh,
                                ARRAY_SIZE(wszHigh));

                if( dw is 0 )
                    wcscpy(wszHigh, L"HIGH");


                dw = LoadString(g_hModule,
                                WINS_GENERAL_DELETED,
                                wszDeleted,
                                ARRAY_SIZE(wszDeleted));

                if( dw is 0 )
                    wcscpy(wszDeleted, L"Deleted. Slot will be reused later.");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_OK,
                                wszOK,
                                ARRAY_SIZE(wszOK));
                if( dw is 0 )
                    wcscpy(wszOK, L"OK");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_FAILURE,
                                wszFailure,
                                ARRAY_SIZE(wszFailure));
                if( dw is 0 )
                    wcscpy(wszFailure, L"FAILED");
                
                dw = LoadString(g_hModule,
                                WINS_GENERAL_NAMENOTVERIFIED,
                                wszNameVerify,
                                ARRAY_SIZE(wszNameVerify));

                if( dw is 0 )
                    wcscpy(wszNameVerify, L"Name can not be verified.");
                        


                dw = LoadString(g_hModule,
                                WINS_GENERAL_READWRITE,
                                wszReadwrite,
                                ARRAY_SIZE(wszReadwrite));
                if( dw is 0 )
                    wcscpy(wszReadwrite, L"Read and Write");

                dw = LoadString(g_hModule,
                                WINS_GENERAL_READ,
                                wszRead,
                                ARRAY_SIZE(wszRead));
                if( dw is 0 )
                    wcscpy(wszRead, L"Read Only");


                dw = LoadString(g_hModule,
                                WINS_GENERAL_NOREAD,
                                wszNo,
                                ARRAY_SIZE(wszNo));
                if( dw is 0 )
                    wcscpy(wszNo, L"No");

            }

            break;
        }
        case DLL_PROCESS_DETACH:
            {
                if( g_ServerNameAnsi )
                {
                    WinsFreeMemory(g_ServerNameAnsi);
                    g_ServerNameAnsi = NULL;
                }
                if( g_ServerNameUnicode )
                {
                    WinsFreeMemory(g_ServerNameUnicode);
                    g_ServerNameUnicode = NULL;
                }
                break;
            }
        default:
        {
            break;
        }
    }

    return TRUE;
}


DWORD
WINAPI
WinsStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;
    PNS_PRIV_CONTEXT_ATTRIBUTES  pNsPrivContextAttributes;

    pNsPrivContextAttributes = HeapAlloc(GetProcessHeap(), 0, sizeof(PNS_PRIV_CONTEXT_ATTRIBUTES));
    if (!pNsPrivContextAttributes)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    ZeroMemory(pNsPrivContextAttributes, sizeof(PNS_PRIV_CONTEXT_ATTRIBUTES));

    attMyAttributes.pwszContext = L"wins";
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = CMD_FLAG_ONLINE;
    attMyAttributes.pfnCommitFn = WinsCommit;
    attMyAttributes.pfnDumpFn   = WinsDump;

    pNsPrivContextAttributes->pfnEntryFn    = WinsMonitor;
    attMyAttributes.pReserved     = pNsPrivContextAttributes;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD WINAPI
InitHelperDll(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved )
{
    DWORD   dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;

    //
    // See if this is the first time we are being called
    //

    if(InterlockedIncrement(&g_ulInitCount) != 1)
    {
        return NO_ERROR;
    }


    g_bCommit = TRUE;

    // Register helpers
    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );

    attMyAttributes.guidHelper         = g_MyGuid;
    attMyAttributes.dwVersion          = WINS_HELPER_VERSION;
    attMyAttributes.pfnStart           = WinsStartHelper;
    attMyAttributes.pfnStop            = NULL;
 
    RegisterHelper( &g_NetshGuid, &attMyAttributes );

    return NO_ERROR;
}


DWORD
WINAPI
WinsMonitor(
    IN      LPCWSTR     pwszMachine,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      DWORD       dwFlags,
    IN      LPCVOID     pvData,
    OUT     LPWSTR      pwcNewContext
    )
{
    DWORD  dwError = NO_ERROR;
    DWORD  dwIndex, i, j;
    BOOL   bFound = FALSE;
    PFN_HANDLE_CMD    pfnHandler = NULL;
    DWORD  dwNumMatched;
    DWORD  dwCmdHelpToken = 0;
    DWORD  ThreadOptions = 0;    
    PNS_CONTEXT_ENTRY_FN     pfnHelperEntryPt;
    PNS_CONTEXT_DUMP_FN      pfnHelperDumpPt;

    //if dwArgCount is 1 then it must be a context switch fn. or looking for help

    if(dwArgCount is 1)
    {
        return ERROR_CONTEXT_SWITCH;
    }

    dwIndex = 1;

    //Is it a top level(non Group command)?
    for(i=0; i<g_ulNumTopCmds; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_WinsCmds[i].pwszCmdToken))
        {
            bFound = TRUE;
            dwIndex++;
            dwArgCount--;
            pfnHandler = g_WinsCmds[i].pfnCmdHandler;

            dwCmdHelpToken = g_WinsCmds[i].dwCmdHlpToken;

            break;
        }
    }


    if(bFound)
    {
        if(dwArgCount > dwIndex && IsHelpToken(ppwcArguments[dwIndex]))
        {
            DisplayMessage(g_hModule, dwCmdHelpToken);

            return NO_ERROR;
        }

        dwError = (*pfnHandler)(pwszMachine, ppwcArguments, dwIndex, dwArgCount,
                                dwFlags, pvData, &bFound);

        return dwError;
    }

    bFound = FALSE;

    //Is it meant for subcontext?
    for(i = 0; i<g_ulNumSubContext; i++)
    {
        if( MatchToken(ppwcArguments[dwIndex], g_WinsSubContextTable[i].pwszContext) )
        {
            bFound = TRUE;
            dwIndex++;
            dwArgCount--;
            pfnHelperEntryPt = g_WinsSubContextTable[i].pfnEntryFn;
            break;
        }
    }

    if( bFound )    //Subcontext
    {
        dwError = (pfnHelperEntryPt)(pwszMachine,
                                     ppwcArguments+1,
                                     dwArgCount,
                                     dwFlags,
                                     pvData,
                                     pwcNewContext);
        return dwError;
    }

    if (!bFound)
    {
        //
        // Command not found. 
       //
        return ERROR_CMD_NOT_FOUND;
    }   
    return dwError;
}



DWORD
WINAPI
WinsUnInit(
    IN  DWORD   dwReserved
    )
{
    if(InterlockedDecrement(&g_ulInitCount) isnot 0)
    {
        return NO_ERROR;
    }

    return NO_ERROR;
}

BOOL
IsHelpToken(
    PWCHAR  pwszToken
    )
{
    if(MatchToken(pwszToken, CMD_WINS_HELP1))
        return TRUE;

    if(MatchToken(pwszToken, CMD_WINS_HELP2))
        return TRUE;
    
    if(MatchToken(pwszToken, CMD_WINS_HELP3))
        return TRUE;

    if(MatchToken(pwszToken, CMD_WINS_HELP4))
        return TRUE;

    return FALSE;
}

PVOID
WinsAllocateMemory(
                   DWORD dwSize
                  )
{
    LPVOID pvOut = NULL;
    pvOut = malloc(dwSize);
    if( pvOut )
    {
        memset(pvOut, 0x00, dwSize);
    }
    return pvOut;
}

VOID
WinsFreeMemory(
               PVOID Memory
               )
{
    
    free( Memory );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\perfctrs\perfwins.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    perfwins.c

    This file implements the Extensible Performance Objects for
    the FTP Server service.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created, based on RussBl's sample code.

*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winperf.h>
#include <lm.h>

#include <string.h>
#include <stdlib.h>

#include "winsctrs.h"
#include "perfmsg.h"
#include "perfutil.h"
#include "winsintf.h"
#include "winsdata.h"
#include "debug.h"
#include "winsevnt.h"


//
//  Private globals.
//

DWORD   cOpens    = 0;                 // Active "opens" reference count.
BOOL    fInitOK   = FALSE;             // TRUE if DLL initialized OK.
BOOL    sfLogOpen;                     //indicates whether the log is
                                       //open or closed

BOOL    sfErrReported;                //to prevent the same error from being
                                      //logged continuously
#if DBG
DWORD   WinsdDebug = 0;                  // Debug behaviour flags.
#endif  // DBG

//
//  Public prototypes.
//

PM_OPEN_PROC    OpenWinsPerformanceData;
PM_COLLECT_PROC CollectWinsPerformanceData;
PM_CLOSE_PROC   CloseWinsPerformanceData;


//
//  Public functions.
//

/*******************************************************************

    NAME:       OpenWinsPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate
                performance counters with the registry.

    ENTRY:      lpDeviceNames - Poitner to object ID of each device
                    to be opened.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        Pradeepb     20-July-1993 Created.

********************************************************************/
DWORD OpenWinsPerformanceData( LPWSTR lpDeviceNames )
{
    DWORD err  = NO_ERROR;
    HKEY  hkey = NULL;
//    DWORD size;
//    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;

    IF_DEBUG( ENTRYPOINTS )
    {
        WINSD_PRINT(( "in OpenWinsPerformanceData\n" ));
    }

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). The registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem.
    //

    if( !fInitOK )
    {
        PERF_COUNTER_DEFINITION * pctr;
        DWORD                     i;
        if(AddSrcToReg() == ERROR_SUCCESS)
        {
          if (!MonOpenEventLog())
          {
             sfLogOpen = TRUE;
          }
        }

        //
        //  This is the *first* open.
        //

	    dwFirstCounter = WINSCTRS_FIRST_COUNTER;
	    dwFirstHelp    = WINSCTRS_FIRST_HELP;
	
            //
            //  Update the object & counter name & help indicies.
            //


            WinsDataDataDefinition.ObjectType.ObjectNameTitleIndex
                += dwFirstCounter;
            WinsDataDataDefinition.ObjectType.ObjectHelpTitleIndex
                += dwFirstHelp;

            pctr = &WinsDataDataDefinition.UniqueReg;

            for( i = 0 ; i < NUMBER_OF_WINSDATA_COUNTERS ; i++ )
            {
                pctr->CounterNameTitleIndex += dwFirstCounter;
                pctr->CounterHelpTitleIndex += dwFirstHelp;
                pctr++;
            }

            //
            //  Remember that we initialized OK.
            //

            fInitOK = TRUE;

        //
        //  Close the registry if we managed to actually open it.
        //

        if( hkey != NULL )
        {
            RegCloseKey( hkey );
            hkey = NULL;
        }

        IF_DEBUG( OPEN )
        {
            if( err != NO_ERROR )
            {
                WINSD_PRINT(( "Cannot read registry data, error %lu\n", err ));
            }
        }
    }

    //
    //  Bump open counter.
    //

    if( err == NO_ERROR )
    {
        cOpens++;
    }
    //
    // if sfLogOpen is FALSE, it means that all threads we closed the
    // event log in CloseWinsPerformanceData
    //
    if (!sfLogOpen)
    {
       MonOpenEventLog();
    }

    return err;

}   // OpenWinsPerformanceData

/*******************************************************************

    NAME:       CollectWinsPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate

    ENTRY:      lpValueName - The name of the value to retrieve.

                lppData - On entry contains a pointer to the buffer to
                    receive the completed PerfDataBlock & subordinate
                    structures.  On exit, points to the first bytes
                    *after* the data structures added by this routine.

                lpcbTotalBytes - On entry contains a pointer to the
                    size (in BYTEs) of the buffer referenced by lppData.
                    On exit, contains the number of BYTEs added by this
                    routine.

                lpNumObjectTypes - Receives the number of objects added
                    by this routine.

    RETURNS:    DWORD - Win32 status code.  MUST be either NO_ERROR
                    or ERROR_MORE_DATA.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CollectWinsPerformanceData( LPWSTR    lpValueName,
                                 LPVOID  * lppData,
                                 LPDWORD   lpcbTotalBytes,
                                 LPDWORD   lpNumObjectTypes )
{
    DWORD                    dwQueryType;
    ULONG                    cbRequired;
    DWORD                    *pdwCounter;
    WINSDATA_COUNTER_BLOCK   *pCounterBlock;
    WINSDATA_DATA_DEFINITION *pWinsDataDataDefinition;
    WINSINTF_RESULTS_NEW_T	      Results;
#if 0
    WINSINTF_RESULTS_T	      Results;
#endif
    WINSINTF_STAT_T          *pWinsStats = &Results.WinsStat;
    DWORD          	     Status;


    IF_DEBUG( ENTRYPOINTS )
    {
        WINSD_PRINT(( "in CollectWinsPerformanceData\n" ));
        WINSD_PRINT(( "    lpValueName      = %08lX (%ls)\n",
                     lpValueName,
                     lpValueName ));
        WINSD_PRINT(( "    lppData          = %08lX (%08lX)\n",
                     lppData,
                     *lppData ));
        WINSD_PRINT(( "    lpcbTotalBytes   = %08lX (%08lX)\n",
                     lpcbTotalBytes,
                     *lpcbTotalBytes ));
        WINSD_PRINT(( "    lpNumObjectTypes = %08lX (%08lX)\n",
                     lpNumObjectTypes,
                     *lpNumObjectTypes ));
    }

    //
    //  No need to even try if we failed to open...
    //

    if( !fInitOK )
    {
        IF_DEBUG( COLLECT )
        {
            WINSD_PRINT(( "Initialization failed, CollectWinsPerformanceData aborting\n" ));
        }

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        //
        //  According to the Performance Counter design, this
        //  is a successful exit.  Go figure.
        //

        return NO_ERROR;
    }

    //
    //  Determine the query type.
    //

    dwQueryType = GetQueryType( lpValueName );

    if( dwQueryType == QUERY_FOREIGN )
    {
        IF_DEBUG( COLLECT )
        {
            WINSD_PRINT(( "foreign queries not supported\n" ));
        }

        //
        //  We don't do foreign queries.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return NO_ERROR;
    }

    if( dwQueryType == QUERY_ITEMS )
    {
        //
        //  The registry is asking for a specific object.  Let's
        //  see if we're one of the chosen.
        //

        if( !IsNumberInUnicodeList(
                        WinsDataDataDefinition.ObjectType.ObjectNameTitleIndex,
                        lpValueName ) )
        {
            IF_DEBUG( COLLECT )
            {
                WINSD_PRINT(( "%ls not a supported object type\n", lpValueName ));
            }

            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            return NO_ERROR;
        }
    }

    //
    //  See if there's enough space.
    //

    pWinsDataDataDefinition = (WINSDATA_DATA_DEFINITION *)*lppData;

    cbRequired = sizeof(WINSDATA_DATA_DEFINITION) +
				WINSDATA_SIZE_OF_PERFORMANCE_DATA;

    if( *lpcbTotalBytes < cbRequired )
    {
        IF_DEBUG( COLLECT )
        {
            WINSD_PRINT(( "%lu bytes of buffer insufficient, %lu needed\n",
                          *lpcbTotalBytes,
                          cbRequired ));
        }

        //
        //  Nope.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return ERROR_MORE_DATA;
    }

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    memmove( pWinsDataDataDefinition,
             &WinsDataDataDefinition,
             sizeof(WINSDATA_DATA_DEFINITION) );

    //
    //  Try to retrieve the data.
    //

    Results.WinsStat.NoOfPnrs = 0;
    Results.WinsStat.pRplPnrs = NULL;
    Results.pAddVersMaps = NULL;

    {
        WINSINTF_BIND_DATA_T    BindData;
        handle_t                BindHdl;

        BindData.fTcpIp     =  FALSE;
        BindData.pPipeName  =  (LPBYTE)TEXT("\\pipe\\WinsPipe");
        BindData.pServerAdd =  (LPBYTE)TEXT("");

        BindHdl = WinsBind(&BindData);
        Status  = WinsStatusNew(BindHdl, WINSINTF_E_STAT, &Results);
        WinsUnbind(&BindData, BindHdl);
    }

    if( Status != WINSINTF_SUCCESS )
    {
        IF_DEBUG( COLLECT )
        {
            WINSD_PRINT(( "cannot retrieve statistics, error %lu\n",
                         Status ));

        }

        //
        // if we haven't logged the error yet, log it
        //
        if (!sfErrReported)
        {
          REPORT_ERROR(WINS_EVT_WINS_STATUS_ERR, LOG_USER);
          sfErrReported = TRUE;
        }

        //
        //  Error retrieving statistics.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return NO_ERROR;
    }

    //
    // Ahaa, we got the statistics, reset flag if set
    //
    if (sfErrReported)
    {
       sfErrReported = FALSE;
    }
    //
    //  Format the WINS Server data.
    //

    pCounterBlock = (WINSDATA_COUNTER_BLOCK *)( pWinsDataDataDefinition + 1 );

    pCounterBlock->PerfCounterBlock.ByteLength =
				WINSDATA_SIZE_OF_PERFORMANCE_DATA;

    //
    //  Get the pointer to the first (DWORD) counter.  This
    //  pointer *must* be quadword aligned.
    //

    pdwCounter = (DWORD *)( pCounterBlock + 1 );

    WINSD_ASSERT( ( (DWORD_PTR)pdwCounter & 3 ) == 0 );

    IF_DEBUG( COLLECT )
    {
        WINSD_PRINT(( "pWinsDataDataDefinition = %08lX\n", pWinsDataDataDefinition ));
        WINSD_PRINT(( "pCounterBlock       = %08lX\n", pCounterBlock ));
        WINSD_PRINT(( "ByteLength          = %08lX\n", pCounterBlock->PerfCounterBlock.ByteLength ));
        WINSD_PRINT(( "pliCounter          = %08lX\n", pdwCounter ));
    }

    //
    //  Move the DWORDs into the buffer.
    //
    IF_DEBUG( COLLECT )
    {
        WINSD_PRINT(( "pdwCounter          = %08lX\n", pdwCounter ));
    }

    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfUniqueReg;
    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfGroupReg;
    *pdwCounter++ = (DWORD)(pWinsStats->Counters.NoOfUniqueReg +
			pWinsStats->Counters.NoOfGroupReg);

    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfUniqueRef;
    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfGroupRef;
    *pdwCounter++ = (DWORD)(pWinsStats->Counters.NoOfUniqueRef +
				pWinsStats->Counters.NoOfGroupRef);
    *pdwCounter++ = (DWORD)(pWinsStats->Counters.NoOfSuccRel +
			     pWinsStats->Counters.NoOfFailRel);
    *pdwCounter++ = (DWORD)(pWinsStats->Counters.NoOfSuccQueries +
			    pWinsStats->Counters.NoOfFailQueries);
    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfUniqueCnf;
    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfGroupCnf;
    *pdwCounter++ = (DWORD)(pWinsStats->Counters.NoOfUniqueCnf +
				pWinsStats->Counters.NoOfGroupCnf);
    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfSuccRel;
    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfFailRel;
    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfSuccQueries;
    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfFailQueries;

    //
    //  Update arguments for return.
    //

    *lppData          = (PVOID)pdwCounter;
    *lpNumObjectTypes = 1;
    *lpcbTotalBytes   = (DWORD)((BYTE *)pdwCounter - (BYTE *)pWinsDataDataDefinition);

    IF_DEBUG( COLLECT )
    {
        WINSD_PRINT(( "pData               = %08lX\n", *lppData ));
        WINSD_PRINT(( "NumObjectTypes      = %08lX\n", *lpNumObjectTypes ));
        WINSD_PRINT(( "cbTotalBytes        = %08lX\n", *lpcbTotalBytes ));
    }

    //
    //  Free the API buffer.
    //
#if 0
    NetApiBufferFree( (LPBYTE)pWinsStats );
#endif

    //
    //  Free the buffers RPC allocates.
    //

    WinsFreeMem( Results.pAddVersMaps );
    WinsFreeMem( Results.WinsStat.pRplPnrs );

    //
    //  Success!  Honest!!
    //

    return NO_ERROR;

}   // CollectWinsPerformanceData

/*******************************************************************

    NAME:       CloseWinsPerformanceData

    SYNOPSIS:   Terminates the performance counters.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CloseWinsPerformanceData( VOID )
{
    IF_DEBUG( ENTRYPOINTS )
    {
        WINSD_PRINT(( "in CloseWinsPerformanceData\n" ));
    }

    //
    //  No real cleanup to do here.
    //

    cOpens--;


    if (!cOpens)
    {
      //
      // unbind from the nameserver. There could be synch. problems since
      // sfLogOpen is changed in both Open and Close functions. This at the
      // max. will affect logging. It being unclear at this point whether or
      // not Open gets called multiple times (from all looks of it, it is only
      // called once), this flag may even not be necessary.
      //
      MonCloseEventLog();
      sfLogOpen = FALSE;
    }
    return NO_ERROR;

}   // CloseWinsPerformanceData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\perfctrs\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfutil.h  

Abstract:

    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:

    Russ Blake  7/30/92

Revision History:


--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//    (assumes dword is 4 bytes long and pointer is a dword in size)
#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD) x & 0x00000003) ? ( ((DWORD) x & 0xFFFFFFFC) + 4 ) : ( (DWORD) x ) ))

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];      
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

//
// The definition of the only routine of perfutil.c, It builds part of a 
// performance data instance (PERF_INSTANCE_DEFINITION) as described in 
// winperf.h
//

HANDLE MonOpenEventLog ();
VOID MonCloseEventLog ();
LONG AddSrcToReg ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;


//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; \
    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
        REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,    \
            &dwHeapStatus, sizeof(dwHeapStatus));  \
    } else {  \
        REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
            &CallStatus, sizeof (DWORD)); \
    } \
}

#else

#define HEAP_PROBE()    ;

#endif

#endif  //_PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\perfctrs\perfutil.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
        common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

Created:

    Russ Blake  07/30/92

Revision History:

--*/
//
//  include files
//
#include "debug.h"
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "winsctrs.h"     // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "winsevnt.h"
//
// Global data definitions.
//

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string
HANDLE hEventLog;
DWORD dwLogUsers;

#define  WINSCTRS_LOG_KEY                \
  TEXT("System\\CurrentControlSet\\Services\\EventLog\\Application\\WinsCtrs")
HKEY  LogRoot;

#define  WINS_LOG_FILE_NAME TEXT("%SystemRoot%\\System32\\winsevnt.dll")
#define  WINS_MSGFILE_SKEY  TEXT("EventMessageFile")

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

TCHAR    WinsMsgFileSKey[]      = WINS_MSGFILE_SKEY;

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    Returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}


BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList



HANDLE
MonOpenEventLog (
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;
    TCHAR LogLevelValueName[] = TEXT("EventLogLevel");

    LONG lStatus;

    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;
   
    // if global value of the logging level not initialized or is disabled, 
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               WINSCTRS_LOG_KEY,
                               0,                         
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,           
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }
       
    if (hEventLog == NULL){
         hEventLog = RegisterEventSource (
            (LPTSTR)NULL,            // Use Local Machine
            APP_NAME);               // event log app name to find in registry

         if (hEventLog == NULL) {
            REPORT_ERROR (WINS_EVT_LOG_OPEN_ERR, LOG_USER);
         }
         
    }
    
    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller
      
Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog) {
        if (dwLogUsers)
            dwLogUsers--;
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            REPORT_INFORMATION (WINS_EVT_LOG_CLOSE, LOG_DEBUG);
            DeregisterEventSource (hEventLog);
            hEventLog = 0;
        }
    }
}


LONG
AddSrcToReg(
 VOID
 )

/*++

Routine Description:
        This function open (or creates) a log file for registering events
        
Arguments:
        None

Externals Used:
        None        

        
Return Value:


Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

   LONG            RetVal = ERROR_SUCCESS;

   DWORD    NewKeyInd;
   TCHAR    Buff[160];
   DWORD    dwData;

   RetVal =  RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,        //predefined key value 
                WINSCTRS_LOG_KEY,                //subkey for WINS        
                0,                        //must be zero (reserved)
                TEXT("Class"),                //class -- may change in future
                REG_OPTION_NON_VOLATILE, //non-volatile information
                KEY_ALL_ACCESS,                //we desire all access to the keyo
                NULL,                         //let key have default sec. attributes
                &LogRoot,                //handle to key
                &NewKeyInd                //is it a new key (out arg) -- not 
                                        //looked at 
                );


   if (RetVal != ERROR_SUCCESS)
   {
        return(RetVal);
   }
        

   /*
        Set the event id message file name
   */
   lstrcpy(Buff, WINS_LOG_FILE_NAME);
  
   /*
       Add the Event-ID message-file name to the subkey
   */
   RetVal = RegSetValueEx(
                        LogRoot,            //key handle
                        WinsMsgFileSKey,   //value name
                        0,                    //must be zero
                        REG_EXPAND_SZ,            //value type
                        (LPBYTE)Buff,
                        (lstrlen(Buff) + 1) * sizeof(TCHAR)   //length of value data
                         );

   if (RetVal != ERROR_SUCCESS)
   {
        return(RetVal);
   }

   /*
     Set the supported data types flags
   */
   dwData = EVENTLOG_ERROR_TYPE       | 
            EVENTLOG_WARNING_TYPE     | 
            EVENTLOG_INFORMATION_TYPE;
   
 
   RetVal = RegSetValueEx (
                        LogRoot,            //subkey handle
                        TEXT("TypesSupported"),  //value name
                        0,                    //must be zero
                        REG_DWORD,            //value type
                        (LPBYTE)&dwData,    //Address of value data
                        sizeof(DWORD)            //length of value data
                          );
 
   if (RetVal != ERROR_SUCCESS)
   {
        return(RetVal);
   }
                         
   /*
    * Done with the key.  Close it
   */
   RetVal = RegCloseKey(LogRoot);

   if (RetVal != ERROR_SUCCESS)
   {
        return(RetVal);
   }

   return(RetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\perfctrs\winsdata.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    winsdata.c

    Constant data structures for the FTP Server's counter objects &
    counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.

*/


#include "debug.h"
#include <windows.h>
#include <winperf.h>
#include "winsctrs.h"
#include "winsdata.h"


//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

WINSDATA_DATA_DEFINITION WinsDataDataDefinition =
{
    {   // WinsDataObjectType
        sizeof(WINSDATA_DATA_DEFINITION) + WINSDATA_SIZE_OF_PERFORMANCE_DATA,
        sizeof(WINSDATA_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        WINSCTRS_COUNTER_OBJECT,
        0,
        WINSCTRS_COUNTER_OBJECT,
        0,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_WINSDATA_COUNTERS,
        2,                              // Default = Bytes Total/sec
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // UniqueReg 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_UNIQUE_REGISTRATIONS,
        0,
        WINSCTRS_UNIQUE_REGISTRATIONS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_UNIQUE_REGISTRATIONS_OFFSET,
    },

    {   // GroupReg 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_GROUP_REGISTRATIONS,
        0,
        WINSCTRS_GROUP_REGISTRATIONS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_GROUP_REGISTRATIONS_OFFSET,
    },

    {   // TotalReg 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_TOTAL_REGISTRATIONS,
        0,
        WINSCTRS_TOTAL_REGISTRATIONS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_TOTAL_REGISTRATIONS_OFFSET,
    },

    {   // UniqueRef 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_UNIQUE_REFRESHES,
        0,
        WINSCTRS_UNIQUE_REFRESHES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_UNIQUE_REFRESHES_OFFSET,
    },

    {   // GroupRef 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_GROUP_REFRESHES,
        0,
        WINSCTRS_GROUP_REFRESHES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_GROUP_REFRESHES_OFFSET,
    },

    {   // TotalRef 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_TOTAL_REFRESHES,
        0,
        WINSCTRS_TOTAL_REFRESHES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_TOTAL_REFRESHES_OFFSET,
    },

    {   // Releases 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_RELEASES,
        0,
        WINSCTRS_RELEASES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_RELEASES_OFFSET,
    },

    {   // Queries 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_QUERIES,
        0,
        WINSCTRS_QUERIES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_QUERIES_OFFSET,
    },

    {   // UniqueCnf 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_UNIQUE_CONFLICTS,
        0,
        WINSCTRS_UNIQUE_CONFLICTS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_UNIQUE_CONFLICTS_OFFSET,
    },

    {   // GroupCnf 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_GROUP_CONFLICTS,
        0,
        WINSCTRS_GROUP_CONFLICTS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_GROUP_CONFLICTS_OFFSET,
    },

    {   // TotalCnf 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_TOTAL_CONFLICTS,
        0,
        WINSCTRS_TOTAL_CONFLICTS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_TOTAL_CONFLICTS_OFFSET
    },

    {   // Sucessful releases 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_SUCC_RELEASES,
        0,
        WINSCTRS_SUCC_RELEASES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_SUCC_RELEASES_OFFSET
    },

    {   // Failed releases 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_FAIL_RELEASES,
        0,
        WINSCTRS_FAIL_RELEASES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_FAIL_RELEASES_OFFSET
    },

    {   // Sucessful queries 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_SUCC_QUERIES,
        0,
        WINSCTRS_SUCC_QUERIES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_SUCC_QUERIES_OFFSET
    },

    {   // Failed queries 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_FAIL_QUERIES,
        0,
        WINSCTRS_FAIL_QUERIES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_FAIL_QUERIES_OFFSET
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\rpc\makefile.inc ===
$(O)\winscl.res: winscl.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\perfctrs\winsdata.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftpdata.h

    Extensible object definitions for the WINS Server's counter
    objects & counters.


    FILE HISTORY:
        Pradeepb     20-July-1993 Created.

*/


#ifndef _WINSDATA_H_
#define _WINSDATA_H_


//
//  This structure is used to ensure the first counter is properly
//  aligned.  Unfortunately, since PERF_COUNTER_BLOCK consists
//  of just a single DWORD, any LARGE_INTEGERs that immediately
//  follow will not be aligned properly.
//
// In our case, the counters that follow are of type DWORD, so we do not 
// need to pad.  The total number of bytes in the buffer returned to perflib 
// *has* to be a multiple of 8 otherwise perflib is going to log an 
// event in the application log indicating that the dll needs to be fixed.  
// Perflib requires buffer data returned to be 8 byte aligned because it
// concatenates the data from multiple dlls.  *Ideally, perflib should be 
// doing the padding before concatenating*. Since WINS
// has an odd number of counters (there are 15 counters) and
// PerfCounterBlock is DWORD, we should not pad the WINS_DATA_COUNTER_BLOCK.
// if we do, the length will become 732 and so it will not be a multiple of
// 8
//
//  This structure requires "natural" packing & alignment (probably
//  quad-word, especially on Alpha).  Ergo, keep it out of the
//  #pragma pack(4) scope below.
//
typedef struct _WINSDATA_COUNTER_BLOCK
{
    PERF_COUNTER_BLOCK  PerfCounterBlock;
//    DWORD       DummyEntryForAlignmentPurposesOnly;

} WINSDATA_COUNTER_BLOCK;


//
//  The routines that load these structures assume that all fields
//  are DWORD packed & aligned.
//

#pragma pack(4)


//
//  Offsets within a PERF_COUNTER_BLOCK.
//

#define WINSDATA_UNIQUE_REGISTRATIONS_OFFSET     sizeof(WINSDATA_COUNTER_BLOCK)

#define WINSDATA_GROUP_REGISTRATIONS_OFFSET    \
	(WINSDATA_UNIQUE_REGISTRATIONS_OFFSET + sizeof(DWORD))

#define WINSDATA_TOTAL_REGISTRATIONS_OFFSET    \
	(WINSDATA_GROUP_REGISTRATIONS_OFFSET +   sizeof(DWORD))

#define WINSDATA_UNIQUE_REFRESHES_OFFSET       \
	(WINSDATA_TOTAL_REGISTRATIONS_OFFSET + sizeof(DWORD))

#define WINSDATA_GROUP_REFRESHES_OFFSET        \
	(WINSDATA_UNIQUE_REFRESHES_OFFSET + sizeof(DWORD))

#define WINSDATA_TOTAL_REFRESHES_OFFSET        \
	(WINSDATA_GROUP_REFRESHES_OFFSET +   sizeof(DWORD))

#define WINSDATA_RELEASES_OFFSET     		\
	(WINSDATA_TOTAL_REFRESHES_OFFSET + sizeof(DWORD))

#define WINSDATA_QUERIES_OFFSET     		\
	(WINSDATA_RELEASES_OFFSET + sizeof(DWORD))

#define WINSDATA_UNIQUE_CONFLICTS_OFFSET       \
	(WINSDATA_QUERIES_OFFSET + sizeof(DWORD))

#define WINSDATA_GROUP_CONFLICTS_OFFSET        \
	(WINSDATA_UNIQUE_CONFLICTS_OFFSET + sizeof(DWORD))

#define WINSDATA_TOTAL_CONFLICTS_OFFSET        \
	(WINSDATA_GROUP_CONFLICTS_OFFSET +   sizeof(DWORD))

#define WINSDATA_SUCC_RELEASES_OFFSET     		\
	(WINSDATA_TOTAL_CONFLICTS_OFFSET + sizeof(DWORD))

#define WINSDATA_FAIL_RELEASES_OFFSET     		\
	(WINSDATA_SUCC_RELEASES_OFFSET + sizeof(DWORD))

#define WINSDATA_SUCC_QUERIES_OFFSET     		\
	(WINSDATA_FAIL_RELEASES_OFFSET + sizeof(DWORD))

#define WINSDATA_FAIL_QUERIES_OFFSET     		\
	(WINSDATA_SUCC_QUERIES_OFFSET + sizeof(DWORD))

#define WINSDATA_SIZE_OF_PERFORMANCE_DATA 	\
	(WINSDATA_FAIL_QUERIES_OFFSET +   sizeof(DWORD))

//
//  The counter structure returned.
//
//
// If the number of counters is odd, do not use DWORD alignment in
// WINSDATA_COUNTER_BLOCK, otherwise, use it.  See comment near the 
// definition of the above structure to get more info. 
//

typedef struct _WINSDATA_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            ObjectType;
    PERF_COUNTER_DEFINITION     UniqueReg;
    PERF_COUNTER_DEFINITION     GroupReg;
    PERF_COUNTER_DEFINITION     TotalReg;
    PERF_COUNTER_DEFINITION     UniqueRef;
    PERF_COUNTER_DEFINITION     GroupRef;
    PERF_COUNTER_DEFINITION     TotalRef;
    PERF_COUNTER_DEFINITION     Releases;
    PERF_COUNTER_DEFINITION     Queries;
    PERF_COUNTER_DEFINITION     UniqueCnf;
    PERF_COUNTER_DEFINITION     GroupCnf;
    PERF_COUNTER_DEFINITION     TotalCnf;
    PERF_COUNTER_DEFINITION     SuccReleases;
    PERF_COUNTER_DEFINITION     FailReleases;
    PERF_COUNTER_DEFINITION     SuccQueries;
    PERF_COUNTER_DEFINITION     FailQueries;
} WINSDATA_DATA_DEFINITION;


extern  WINSDATA_DATA_DEFINITION    WinsDataDataDefinition;


#define NUMBER_OF_WINSDATA_COUNTERS ((sizeof(WINSDATA_DATA_DEFINITION) -      \
                                  sizeof(PERF_OBJECT_TYPE)) /           \
                                  sizeof(PERF_COUNTER_DEFINITION))


#define WINSDATA_PERFORMANCE_KEY	\
	TEXT("System\\CurrentControlSet\\Services\\Wins\\Performance")
//
//  Restore default packing & alignment.
//

#pragma pack()


#endif  // _WINSDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\perfctrs\winsctrs.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    winsctrs.h

    Offset definitions for the WINS Server's counter objects & counters.

    These offsets *must* start at 0 and be multiples of 2.  In the
    WinsOpenPerformanceData procedure, they will be added to the
    WINS Server's "First Counter" and "First Help" values in order to
    determine the absolute location of the counter & object names
    and corresponding help text in the registry.

    This file is used by the WINSCTRS.DLL DLL code as well as the
    WINSCTRS.INI definition file.  WINSCTRS.INI is parsed by the
    LODCTR utility to load the object & counter names into the
    registry.


    FILE HISTORY:
        PradeepB     20-July-1993 Created.

*/


#ifndef _WINSCTRS_H_
#define _WINSCTRS_H_


//
// The range given by Hon-Wah Chan (2/22/94) is the following 
//
#define WINSCTRS_FIRST_COUNTER	920
#define WINSCTRS_FIRST_HELP	921
#define WINSCTRS_LAST_COUNTER	950
#define WINSCTRS_LAST_HELP	951



//
//  The WINS Server counter object.
//

#define WINSCTRS_COUNTER_OBJECT           0


//
//  The individual counters.
//

#define WINSCTRS_UNIQUE_REGISTRATIONS     2
#define WINSCTRS_GROUP_REGISTRATIONS      4
#define WINSCTRS_TOTAL_REGISTRATIONS      6
#define WINSCTRS_UNIQUE_REFRESHES         8
#define WINSCTRS_GROUP_REFRESHES         10
#define WINSCTRS_TOTAL_REFRESHES         12
#define WINSCTRS_RELEASES                14
#define WINSCTRS_QUERIES                 16
#define WINSCTRS_UNIQUE_CONFLICTS        18
#define WINSCTRS_GROUP_CONFLICTS         20
#define WINSCTRS_TOTAL_CONFLICTS         22
#define WINSCTRS_SUCC_RELEASES           24 
#define WINSCTRS_FAIL_RELEASES           26
#define WINSCTRS_SUCC_QUERIES            28 
#define WINSCTRS_FAIL_QUERIES            30 


#endif  // _WINSCTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\rpc\rpcbind.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dhcbind.c

Abstract:

    Routines which use RPC to bind and unbind the client to the
    WINS server service.

Author:

    Pradeep Bahl (pradeepb) April-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include "wins.h"
#include "winsif.h"

handle_t
WinsCommonBind(
    PWINSINTF_BIND_DATA_T pBindData
    )

/*++

Routine Description:

    This routine is called from the WINS server service client stubs when
    it is necessary create an RPC binding to the server end.

Arguments:

    ServerIpAddress - The IP address of the server to bind to.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    RPC_STATUS rpcStatus;
    LPTSTR binding;
    LPTSTR pProtSeq;
    LPTSTR pOptions = (TCHAR *)NULL;
    LPTSTR pServerAdd = (LPTSTR)pBindData->pServerAdd;
    handle_t bhandle;

    if (pBindData->fTcpIp)
    {
        if (lstrcmp((LPCTSTR)pBindData->pServerAdd, TEXT("127.0.0.1")) == 0)
        {
                pProtSeq   = TEXT("ncalrpc");
                pOptions   = TEXT("Security=Impersonation Dynamic False");
                pServerAdd = (TCHAR *)NULL;
        }
        else
        {
                pProtSeq   = TEXT("ncacn_ip_tcp");
                pServerAdd = (LPTSTR)pBindData->pServerAdd;
        }
        pBindData->pPipeName  = NULL;
    }
    else
    {
         pProtSeq = TEXT("ncacn_np");
    }

    //
    // Enter the critical section.  This will be freed  WINSIF_HANDLE_unbind().
    //
    //EnterCriticalSection(&WinsRpcCrtSec);
    rpcStatus = RpcStringBindingCompose(
                    0,
                    pProtSeq,
                    pServerAdd,
                    pBindData->fTcpIp ? TEXT("") : (LPWSTR)pBindData->pPipeName,
                    pOptions,
                    &binding);

    if ( rpcStatus != RPC_S_OK )
    {
        return( NULL );
    }

    rpcStatus = RpcBindingFromStringBinding( binding, &bhandle );
    RpcStringFree(&binding);

    if ( rpcStatus != RPC_S_OK )
    {
        return( NULL );
    }
#if SECURITY > 0
    rpcStatus = RpcBindingSetAuthInfo(
			bhandle,
			WINS_SERVER,
			RPC_C_AUTHN_LEVEL_CONNECT,
			RPC_C_AUTHN_WINNT,
			NULL,
			RPC_C_AUTHZ_NAME
				     );	
    if ( rpcStatus != RPC_S_OK )
    {
        return( NULL );
    }
#endif
    return bhandle;
}


handle_t
WinsABind(
    PWINSINTF_BIND_DATA_T pBindData
    )
{

	WCHAR  WcharString1[WINSINTF_MAX_NAME_SIZE];
	WCHAR  WcharString2[WINSINTF_MAX_NAME_SIZE];
	DWORD  NoOfChars;
	WINSINTF_BIND_DATA_T	BindData;
	if (pBindData->pServerAdd != NULL)
	{
	   NoOfChars = MultiByteToWideChar(CP_ACP, 0, pBindData->pServerAdd, -1,
				WcharString1, WINSINTF_MAX_NAME_SIZE); 	
	  if (NoOfChars > 0)
	  {
		BindData.pServerAdd = (LPSTR)WcharString1;
	  }
	}
	else
	{
		BindData.pServerAdd = (LPSTR)((TCHAR *)NULL);
	}
	if (!pBindData->fTcpIp)
	{
	   BindData.fTcpIp = 0;
	   NoOfChars = MultiByteToWideChar(CP_ACP, 0,
				pBindData->pPipeName, -1,
				WcharString2, WINSINTF_MAX_NAME_SIZE); 	
	   if (NoOfChars > 0)
	   {
		BindData.pPipeName = (LPSTR)WcharString2;
	   }
	}
	else
	{
		BindData.fTcpIp = 1;
	}
        return(WinsCommonBind(&BindData));

}
	
handle_t
WinsUBind(
    PWINSINTF_BIND_DATA_T pBindData
    )
{
        return(WinsCommonBind(pBindData));
}

VOID
WinsUnbind(
    PWINSINTF_BIND_DATA_T pBindData,
    handle_t BindHandle
    )
{

    (VOID)RpcBindingFree(&BindHandle);
	return;
}

handle_t
WINSIF_HANDLE_bind(
    WINSIF_HANDLE ServerHdl
    )

/*++

Routine Description:

    This routine is called from the WINS server service client stubs when
    it is necessary create an RPC binding to the server end.

Arguments:

    ServerIpAddress - The IP address of the server to bind to.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    return WinsCommonBind( ServerHdl );
}




void
WINSIF_HANDLE_unbind(
    WINSIF_HANDLE ServerHdl,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine is called from the DHCP server service client stubs
    when it is necessary to unbind from the server end.

Arguments:

    ServerIpAddress - This is the IP address of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    WinsUnbind( ServerHdl, BindHandle );
}

handle_t
WINSIF2_HANDLE_bind(
    WINSIF2_HANDLE ServerHdl
    )

/*++

Routine Description:

    This routine is called from the WINS server service client stubs when
    it is necessary create an RPC binding to the server end.

Arguments:

    ServerIpAddress - The IP address of the server to bind to.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    return ((handle_t)ServerHdl);
}




void
WINSIF2_HANDLE_unbind(
    WINSIF2_HANDLE ServerHdl,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine is called from the DHCP server service client stubs
    when it is necessary to unbind from the server end.

Arguments:

    ServerIpAddress - This is the IP address of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER( ServerHdl );
    UNREFERENCED_PARAMETER( BindHandle );
    return;
}



//void __RPC_FAR * __RPC_API
LPVOID
midl_user_allocate(size_t cBytes)
{
	LPVOID pMem;
	pMem = (LPVOID)LocalAlloc(LMEM_FIXED, cBytes);
	return(pMem);
}

//void __RPC_API
VOID
//midl_user_free(void __RPC_FAR *pMem)
midl_user_free(void  *pMem)
{
	if (pMem != NULL)
	{
		LocalFree((HLOCAL)pMem);
	}
	return;
}

LPVOID
WinsAllocMem(size_t cBytes)
{
	return(midl_user_allocate(cBytes));

}

VOID
WinsFreeMem(LPVOID pMem)
{
	midl_user_free(pMem);

}


DWORD
WinsGetBrowserNames_Old(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_BROWSER_NAMES_T	pNames
	)
{

    DWORD status;

    RpcTryExcept {

        status = R_WinsGetBrowserNames_Old(
            ServerHdl,
			pNames
                     );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsGetBrowserNames(
    WINSIF_HANDLE               ServerHdl,
    PWINSINTF_BROWSER_NAMES_T	pNames
	)
{

    DWORD status;

    RpcTryExcept {

        status = R_WinsGetBrowserNames(
            ServerHdl,
			pNames
                     );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\rpc\rpcstub.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    winsstub.c

Abstract:

    Client stubs of the WINS server service APIs.

Author:

    Pradeep Bahl (pradeepb) Apr-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include "windows.h"
#include "rpc.h"
#include "winsif.h"
#include "esent.h"
#include "winscnst.h"
//#include "winsintf.h"

//
// prototypes
//
DWORD
WinsRestoreC(
 LPBYTE pBackupPath,
 DbVersion Version
);


DWORD
WinsRecordAction(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_RECORD_ACTION_T *ppRecAction
	)	
{
    DWORD status;

    RpcTryExcept {

        status = R_WinsRecordAction(
            ServerHdl,
			ppRecAction
                     );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}


DWORD
WinsStatus(
    WINSIF2_HANDLE               ServerHdl,
	WINSINTF_CMD_E	    Cmd_e,
	PWINSINTF_RESULTS_T pResults
	)	
{
    DWORD status;

    RpcTryExcept {

        status = R_WinsStatus(
			//pWinsAddStr,
            ServerHdl,
			Cmd_e,
			pResults
                     );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsStatusNew(
    WINSIF2_HANDLE               ServerHdl,
	WINSINTF_CMD_E	    Cmd_e,
	PWINSINTF_RESULTS_NEW_T pResults
	)	
{
    DWORD status;

    RpcTryExcept {

        status = R_WinsStatusNew(
            ServerHdl,
			Cmd_e,
			pResults
                     );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsStatusWHdl(
    WINSIF_HANDLE               ServerHdl,
	WINSINTF_CMD_E	    Cmd_e,
	PWINSINTF_RESULTS_NEW_T pResults
	)	
{
    DWORD status;

    RpcTryExcept {

        status = R_WinsStatusWHdl(
            ServerHdl,
			Cmd_e,
			pResults
                     );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}


DWORD
WinsTrigger(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_ADD_T 	pWinsAdd,
	WINSINTF_TRIG_TYPE_E	TrigType_e
	)	
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsTrigger(
            ServerHdl,
			pWinsAdd,
			TrigType_e
                     );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}
DWORD
WinsDoStaticInit(
    WINSIF2_HANDLE               ServerHdl,
	LPWSTR pDataFilePath,
    DWORD  fDel
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsDoStaticInit(
            ServerHdl,
            pDataFilePath, fDel);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;

}

DWORD
WinsDoScavenging(
    WINSIF2_HANDLE               ServerHdl
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsDoScavenging(
                    ServerHdl
                 );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;

}
DWORD
WinsDoScavengingNew(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_SCV_REQ_T pScvReq
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsDoScavengingNew(
                    ServerHdl,
                    pScvReq);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;

}

DWORD
WinsGetDbRecs(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_ADD_T		pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo,
	PWINSINTF_RECS_T pRecs	
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsGetDbRecs(
                    ServerHdl,
                    pWinsAdd, MinVersNo, MaxVersNo, pRecs);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;

}
DWORD
WinsTerm(
    handle_t               ServerHdl,
	short	fAbruptTerm
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsTerm(
                    ServerHdl,
                    fAbruptTerm);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsBackup(
    WINSIF2_HANDLE               ServerHdl,
	LPBYTE		pBackupPath,
	short		fIncremental
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsBackup(
                    ServerHdl,
                    pBackupPath, fIncremental);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsDelDbRecs(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_ADD_T		pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsDelDbRecs(
                    ServerHdl,
                    pWinsAdd, MinVersNo, MaxVersNo);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsPullRange(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_ADD_T		pWinsAdd,
	PWINSINTF_ADD_T		pOwnAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsPullRange(
                    ServerHdl,
                    pWinsAdd, pOwnAdd, MinVersNo, MaxVersNo);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}
DWORD
WinsSetPriorityClass(
    WINSIF2_HANDLE               ServerHdl,
	WINSINTF_PRIORITY_CLASS_E	PrCls_e
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsSetPriorityClass(
                    ServerHdl,
                    PrCls_e);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}


DWORD
WinsResetCounters(
    WINSIF2_HANDLE               ServerHdl
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsResetCounters(
                    ServerHdl
                   );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsRestoreEx(
 LPBYTE pBackupPath,
 DbVersion  Version
)
{
   return(WinsRestoreC(pBackupPath, Version));
}

DWORD
WinsRestore(
 LPBYTE pBackupPath
)
{
   return(WinsRestoreC(pBackupPath, DbVersion5 ));
}

DWORD
ConvertUnicodeStringToAscii(
        LPWSTR pUnicodeString,
        LPBYTE pAsciiString,
        DWORD  MaxSz
        )
{
    DWORD RetVal;
    RetVal = WideCharToMultiByte(
                CP_ACP,
                0,
                pUnicodeString,
                -1,
                pAsciiString,
                MaxSz,
                NULL,
                NULL
                );
    if (0 == RetVal ) {
        return GetLastError();
    } else {
        return ERROR_SUCCESS;
    }
}

DWORD
WinsReadLogPath(
    PCHAR   *pLogPath
    )
{
    DWORD   Error;
    static  TCHAR    Buf[WINSINTF_MAX_NAME_SIZE];
    static  TCHAR    ExpandBuf[WINSINTF_MAX_NAME_SIZE];
    static  char     AsciiBuf[WINSINTF_MAX_NAME_SIZE];
    WCHAR   *pTempPath,*pExpandTempPath;
    HKEY    sParamKey;
    DWORD   ValTyp;
    DWORD   Sz;
#define WINS_PARAM_KEY  TEXT("System\\CurrentControlSet\\Services\\Wins\\Parameters")
#define DEFAULT_LOG_FILE_PATH TEXT("%SystemRoot%\\System32\\wins")

    Error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                WINS_PARAM_KEY,
                0 ,
                KEY_READ,
                &sParamKey
                );

    if (ERROR_SUCCESS != Error) {
        return Error;
    }

    pTempPath = Buf;
    Error = RegQueryValueEx(
                 sParamKey,
                 WINSCNF_LOG_FILE_PATH_NM,
                 NULL,                //reserved; must be NULL
                 &ValTyp,
                 (LPBYTE)pTempPath,
                 &Sz
                 );

    if (ERROR_SUCCESS != Error || pTempPath[0] == L'\0') {
        pTempPath = DEFAULT_LOG_FILE_PATH;
    }
    pExpandTempPath = ExpandBuf;
    Error = ExpandEnvironmentStrings(
                    pTempPath,
                    pExpandTempPath,
                    WINSINTF_MAX_NAME_SIZE);
    if (0 == Error || Error > WINSINTF_MAX_NAME_SIZE) {
        RegCloseKey(sParamKey);
        return GetLastError();
    }
    *pLogPath = AsciiBuf;
    Error = ConvertUnicodeStringToAscii(
                pExpandTempPath,
                *pLogPath,
                WINSINTF_MAX_NAME_SIZE
                );
    RegCloseKey(sParamKey);
    return Error;
}

DWORD
WinsRestoreC(
 LPBYTE pBackupPath,
 DbVersion Version
)

/*++

Routine Description:

	This is not an RPC function.  It is provided to do a restore of
	the database.
Arguments:
	pBackupPath - Path to the backup directory

Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/
{
	JET_ERR JetRetStat;
        HMODULE hExtension;
        FARPROC fRestoreFn;
        FARPROC fSetSystemParamFn;
        DWORD   RetStat = WINSINTF_SUCCESS;
        DWORD   ProcId = 0x9C;  //ordinal value of JetRestore
        LPCSTR  RestoreProcName;
        LPCSTR  SetSystemParamProcName;
        BYTE  BackupPath[WINSINTF_MAX_NAME_SIZE + sizeof(WINS_BACKUP_DIR_ASCII)];
        CHAR    *pLogFilePath;
        DWORD Error;
        BOOL  fDirCr;
        LPTSTR pDllName;

 //       static BOOL sLoaded = FALSE;

try {
//      if (!sLoaded)
      {

        switch ( Version ) {
        case DbVersion351:
            pDllName = TEXT("jet.dll");
            RestoreProcName = (LPCSTR)0x9C;
            SetSystemParamProcName=(LPCSTR)165;
            break;
        case DbVersion4:
            pDllName = TEXT("jet500.dll");
            RestoreProcName = "JetRestore";
            SetSystemParamProcName="JetSetSystemParameter";
            break;
        case DbVersion5:
            pDllName = TEXT("esent.dll");
            RestoreProcName = "JetRestore";
            SetSystemParamProcName="JetSetSystemParameter";
            break;
        default:
            return WINSINTF_FAILURE;
        }

        // load the extension agent dll and resolve the entry points...
        if ((hExtension = GetModuleHandle(pDllName)) == NULL)
        {
                if ((hExtension = LoadLibrary(pDllName)) == NULL)
                {
                        return(GetLastError());
                }
                else
	        {
	                if ((fRestoreFn = GetProcAddress(hExtension,RestoreProcName)) == (FARPROC)NULL)
                        {
                                RetStat = GetLastError();
                        }

                    if ((RetStat == ERROR_SUCCESS) && (Version != DbVersion351) )
                    {
	                  if ((fSetSystemParamFn = GetProcAddress(hExtension,
                              SetSystemParamProcName)) == (FARPROC)NULL)
                        {
                                RetStat = GetLastError();
                        }
                   }
                }
        }
    }
//    sLoaded = TRUE;
//FUTURES("Change to lstrcpy and lstrcat when Jet starts supporting unicode")
  if (RetStat == WINSINTF_SUCCESS)
  {
    strcpy(BackupPath, pBackupPath);
    strcat(BackupPath, WINS_BACKUP_DIR_ASCII);
    fDirCr = CreateDirectoryA(BackupPath, NULL);

    if (!fDirCr && ((Error = GetLastError()) == ERROR_ALREADY_EXISTS))
    {
       if (Version != DbVersion351)
       {
         JET_INSTANCE JetInstance=0;
#define BASENAME  "j50"
         //
         // first set the system parameter for basename
         //

         //
         // Basename to use for jet*.log and jet.chk
         //
         // We should also specify the logfile path by checking WINS registry
         // but it is not essential.

         //
         // When WINS comes up, if it gets an error indicating that there
         // was a bad log signature or log version, it will delete all log
         // files and restart again.
         //
         do {
             JetRetStat = (JET_ERR)(*fSetSystemParamFn)(
                                    &JetInstance,
                                    (JET_SESID)0,        //SesId - ignored
                                    JET_paramBaseName,
                                    0,
                                    BASENAME
                                       );
             if (JetRetStat != JET_errSuccess) break;
             JetRetStat = (JET_ERR)(*fSetSystemParamFn)(
                                    &JetInstance,
                                    (JET_SESID)0,        //SesId - ignored
                                    JET_paramLogFileSize,
                                    1024,
                                    NULL
                                       );

             JetRetStat = WinsReadLogPath( &pLogFilePath );
             if (JetRetStat != JET_errSuccess) break;

             JetRetStat = (JET_ERR)(*fSetSystemParamFn)(
                                    &JetInstance,
                                    (JET_SESID)0,        //SesId - ignored
                                    JET_paramLogFilePath,
                                    0,
                                    pLogFilePath
                                       );
         } while (FALSE);
         if (JetRetStat == JET_errSuccess) {
             JetRetStat = (JET_ERR)(*fRestoreFn)((const char *)BackupPath, NULL);
         }
       }
       else
       {
	      JetRetStat = (JET_ERR)(*fRestoreFn)((const char *)BackupPath, 0, NULL, (JET_PFNSTATUS)NULL);
       }
	   if (JetRetStat != JET_errSuccess)
	   {
		  RetStat = WINSINTF_FAILURE;
	   }
    }
    else
    {
        //
        // If CreateDirectoryA was successful, renove the directory
        //
        if (fDirCr)
        {
             RemoveDirectoryA(BackupPath);
             RetStat = WINSINTF_FAILURE;
        }
        else
        {
              RetStat = Error;
        }
    }
  }
}
except(EXCEPTION_EXECUTE_HANDLER) {
       RetStat = WINSINTF_FAILURE;
 }
    if (!FreeLibrary(hExtension))
    {
           RetStat = GetLastError();
    }
	return(RetStat);
}

DWORD
WinsWorkerThdUpd(
    WINSIF2_HANDLE               ServerHdl,
	DWORD NewNoOfNbtThds
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsWorkerThdUpd(
                    ServerHdl,
                    NewNoOfNbtThds);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsSyncUp(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_ADD_T		pWinsAdd,
	PWINSINTF_ADD_T		pOwnerAdd
	)
{
    DWORD status;
    WINSINTF_VERS_NO_T MinVersNo, MaxVersNo;

    //
    // Set both version numbers to zero
    //
    MinVersNo.LowPart = 0;
    MinVersNo.HighPart = 0;
    MaxVersNo = MinVersNo;
    RpcTryExcept {

        status = R_WinsPullRange(
                    ServerHdl,
                    pWinsAdd, pOwnerAdd, MinVersNo, MaxVersNo);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsGetNameAndAdd(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_ADD_T	pWinsAdd,
	LPBYTE		pUncName
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsGetNameAndAdd(
                    ServerHdl,
                    pWinsAdd, pUncName);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsDeleteWins(
    WINSIF2_HANDLE               ServerHdl,
    PWINSINTF_ADD_T pWinsAdd)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsDeleteWins(
                    ServerHdl,
                    pWinsAdd);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsSetFlags(
    WINSIF2_HANDLE               ServerHdl,
    DWORD fFlags)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsSetFlags(
                    ServerHdl,
                    fFlags);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}
DWORD
WinsGetDbRecsByName(
       WINSIF2_HANDLE               ServerHdl,
       PWINSINTF_ADD_T pWinsAdd,
       DWORD           Location,
       LPBYTE          pName,
       DWORD           NameLen,
       DWORD           NoOfRecsDesired,
       DWORD           fOnlyStatic,
       PWINSINTF_RECS_T pRecs
                   )
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsGetDbRecsByName(
                     ServerHdl,
                     pWinsAdd,
                      Location,
                      pName,
                      NameLen,
                      NoOfRecsDesired,
                      fOnlyStatic,
                      pRecs);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsTombstoneDbRecs(
    WINSIF2_HANDLE      ServerHdl,
    PWINSINTF_ADD_T     pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsTombstoneDbRecs(ServerHdl, pWinsAdd, MinVersNo, MaxVersNo);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsCheckAccess(
    WINSIF2_HANDLE      ServerHdl,
    DWORD               *Access
    	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsCheckAccess(ServerHdl, Access);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\assoc.h ===
#ifndef _COMMASSOC_
#define _COMMASSOC_

#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	assoc.c

Abstract:


	This is the header file to be included for calling assoc.c functions


Author:

	Pradeep Bahl	(PradeepB)	Dec-1992

Revision History:

--*/

/*
	includes
*/
#include <wins.h>
#include "winsock2.h"
#include "comm.h"

/*

 defines
*/

#define COMMASSOC_UDP_BUFFER_HEAP_SIZE	10000
#define COMMASSOC_UDP_DLG_HEAP_SIZE	    5000
#define COMMASSOC_DLG_DS_SZ		sizeof(COMMASSOC_DLG_CTX_T)
#define COMMASSOC_ASSOC_DS_SZ		sizeof(COMMASSOC_ASSOC_CTX_T)


/*
 *
 *  size of header put by RtlInsertElementGenericTable.
 */
FUTURES("Gary Kimura (2/13) said that he would provide a macro for the size")
FUTURES("Use that when it is available")

#define  COMMASSOC_TBL_HDR_SIZE   (sizeof(RTL_SPLAY_LINKS) + sizeof(LIST_ENTRY))

/*
  Size of memory block to allocate for sending any of association set up
  messages.  We use the largest of the sizes of the various assoc. set up
  messages so that we can reuse a buffer.  The buffer size is kept a multiple
  of 16.
*/

#define COMMASSOC_START_REQ_ASSOC_MSG_SIZE	(32 + sizeof(COMM_HEADER_T))
#define COMMASSOC_START_RSP_ASSOC_MSG_SIZE      (16 + sizeof(COMM_HEADER_T))
#define COMMASSOC_STOP_REQ_ASSOC_MSG_SIZE	(16 + sizeof(COMM_HEADER_T))

#define COMMASSOC_ASSOC_MSG_SIZE	COMMASSOC_START_REQ_ASSOC_MSG_SIZE

#if SUPPORT612WINS > 0
#define  COMMASSOC_POST_BETA1_ASSOC_MSG_SIZE  (COMMASSOC_ASSOC_MSG_SIZE + 1)
#endif

/*
 Initial memory sizes for heaps used for allocating assoc. and dlg ctx blocks
*/

#define COMMASSOC_ASSOC_BLKS_HEAP_SIZE		1000
#define COMMASSOC_DLG_BLKS_HEAP_SIZE		4000
#define COMMASSOC_TCP_MSG_HEAP_SIZE		    10000



//
// defines to access the next and prev assoc. in the list
//
#define NEXT_ASSOC_M(pAssocCtx)	((PCOMMASSOC_ASSOC_CTX_T)		\
					((pAssocCtx)->Top.Head.Flink))	
#define PREV_ASSOC_M(pAssocCtx)	((PCOMMASSOC_ASSOC_CTX_T)		\
					((pAssocCtx)->Top.Head.Blink))

//
// Macro to unlink an association from the table of responder associations
// Called by CommStopMonDlg in commapi.c and by CommAssocDeleteAssocInTbl
//
#define  COMMASSOC_UNLINK_RSP_ASSOC_M(pAssocCtx) 		{	\
	NEXT_ASSOC_M(PREV_ASSOC_M((pAssocCtx)))  = NEXT_ASSOC_M((pAssocCtx)); \
	PREV_ASSOC_M(NEXT_ASSOC_M((pAssocCtx)))  = PREV_ASSOC_M((pAssocCtx)); \
				}
/*
 Macros
*/
//
//  Sets up Communication data structures (assoc and dlg ctx blocks)
//
#define COMMASSOC_SETUP_COMM_DS_M(mpDlgCtx, mpAssocCtx, mType_e, mRole_e) \
	{								\
		(mpAssocCtx)->DlgHdl.SeqNo   = (mpDlgCtx)->Top.SeqNo;	\
		(mpAssocCtx)->DlgHdl.pEnt    = (mpDlgCtx);		\
		(mpAssocCtx)->State_e        = COMMASSOC_ASSOC_E_ACTIVE; \
		(mpAssocCtx)->Typ_e          = (mType_e);		\
									\
		(mpDlgCtx)->AssocHdl.SeqNo   = (mpAssocCtx)->Top.SeqNo;	\
		(mpDlgCtx)->AssocHdl.pEnt    = (mpAssocCtx);		\
		(mpDlgCtx)->Role_e           = (mRole_e);		\
		(mpDlgCtx)->Typ_e            = (mType_e);		\
	}

/*
 externs
*/

/*
 Handles to the heaps created for allocating assoc. ctx blocks and
 Dlg Ctx blocks
*/
extern HANDLE			CommAssocAssocHeapHdl;
extern HANDLE			CommAssocDlgHeapHdl;
extern HANDLE			CommAssocTcpMsgHeapHdl;

/*
  typedefs
*/

typedef		DWORD		IP_ADDRESS;
typedef 	IP_ADDRESS	HOST_ADDRESS;


	


typedef enum _COMMASSOC_ASSOC_STOP_RSN_E {
	COMMASSOC_E_USER_INITIATED = 0,
	COMMASSOC_E_AUTH_FAILURE,
	COMMASSOC_E_INCOMP_VERS,
	COMMASSOC_E_BUG_CHECK,
	COMMASSOC_E_MSG_ERR		//some error in message format
	} COMMASSOC_STP_RSN_E, *PCOMMASSOC_STP_RSN_E;

/*
   ASSOC_ROLE_E -- Enumerator for the different roles
*/

typedef enum _COMMASSOC_ASSOC_ROLE_E {
	COMMASSOC_ASSOC_E_INITIATOR = 0,
	COMMASSOC_ASSOC_E_RESPONDER
	} COMMASSOC_ASSOC_ROLE_E, *PCOMMASSOC_ASSOC_ROLE_E;

/*
   COMMASSOC_DLG_ROLE_E -- Enumerator for the different roles
*/

typedef enum _COMMASSOC_DLG_ROLE_E {
	COMMASSOC_DLG_E_IMPLICIT = 0,
	COMMASSOC_DLG_E_EXPLICIT
	} COMMASSOC_DLG_ROLE_E, *PCOMMASSOC_PDLG_ROLE_E;
	




/*
  ASSOC_MSG_TYP_E - different assoc. messages
*/

typedef enum _COMMASSOC_ASSOC_MSG_TYP_E{
	COMMASSOC_ASSOC_E_START_REQ = 0,
	COMMASSOC_ASSOC_E_STOP_REQ,
	COMMASSOC_ASSOC_E_START_RESP
	} COMMASSOC_MSG_TYP_E, *PCOMMASSOC_MSG_TYP_E;
	
/*
  DLG_STATE_E - states of a dialogue
*/

typedef enum _COMMASSOC_DLG_STATE_E {
	COMMASSOC_DLG_E_INACTIVE = 0,
	COMMASSOC_DLG_E_ACTIVE,
	COMMASSOC_DLG_E_DYING
	} COMMASSOC_DLG_STATE_E, *PCOMMASSOC_DLG_STATE_E;


/*

  DLG_HDL_T - Dialogue Context Block

 The ctx block must have COMM_TOP_T structure at the top (used by DeallocEnt in
 assoc.c)
*/

typedef struct _COMMASSOC_DLG_CTX_T {
	COMM_TOP_T	      Top;
	COMM_HDL_T 	      AssocHdl;        	//ptr to the Assoc ctx block
	COMMASSOC_DLG_STATE_E State_e;          // state of the dialogue
	COMM_TYP_E	      Typ_e;           // type of the dialogue
	COMMASSOC_DLG_ROLE_E  Role_e;           //Role - IMPLICIT/EXPLICIT
FUTURES("There is no need to store pMsg and MsgLen in dlg ctx block")
FUTURES("since now I am storing FirstWrdOfMsg in it. Make sure that this")
FUTURES("assertion is indeed true")
	MSG_T		      pMsg;             //ptr to datagram received on
					        //UDP port
	MSG_LEN_T	      MsgLen;           //msg Length of datagram
	DWORD		      FirstWrdOfMsg;	//first word of message received
	struct sockaddr_in    FromAdd;          //address of sender of datagram
CHECK("Is this needed")
	DWORD		      QuesNameSecLen;   //Length of question section
						//in name req
        DWORD		      RspLen;	        //length of the response packet
	SOCKET		      SockNo;		//sock. # of connection
					        //created when simulating an
						//nbt node (to send a name
						//reg request to a remote WINS)
						//see ClastAtReplUniqueR
	} COMMASSOC_DLG_CTX_T, *PCOMMASSOC_DLG_CTX_T;
	
	

/*
   ASSOC_STATE_E -- Enumerator for the different states of an Association
*/
typedef enum _COMMASSOC_ASSOC_STATE_E {
	COMMASSOC_ASSOC_E_NON_EXISTENT = 0,
	COMMASSOC_ASSOC_E_STARTING,
	COMMASSOC_ASSOC_E_ACTIVE,
	COMMASSOC_ASSOC_E_STOPPING,
	COMMASSOC_ASSOC_E_DISCONNECTED
	} COMMASSOC_ASSOC_STATE_E, *PCOMMASSOC_ASSOC_STATE_E;


typedef COMMASSOC_DLG_CTX_T	DLG_CTX_T;
typedef COMM_HDL_T	COMMASSOC_DLG_HDL_T;
typedef COMM_HDL_T	COMMASSOC_ASSOC_HDL_T;





/*
  ASSOC_CTX - Association Context Block

 The ctx block must have COMM_TOP_T structure at the top (used by DeallocEnt in
 assoc.c)

*/
typedef struct _COMMASSOC_ASSOC_CTX_T {
	COMM_TOP_T	            Top;
	COMM_HDL_T 	            DlgHdl;        //ptr to the Assoc ctx block
	SOCKET		            SockNo;	       /*handle to TCP/UDP socket*/
	ULONG		            uRemAssocCtx;  /*remote assoc ctx block*/
	DWORD		            MajVersNo;
	DWORD		            MinVersNo;
	COMMASSOC_ASSOC_STATE_E	State_e;	/* state	*/
	COMM_TYP_E	        Typ_e;    	/* type	*/
	COMMASSOC_ASSOC_ROLE_E	Role_e;         /*Role -- Initiator/responder*/
    COMM_ADD_TYP_E          AddTyp_e;
    union {
	struct sockaddr_in      RemoteAdd;	//Address of remote node
	struct sockaddr_in      RemoteAddIpx;	//Address of remote node
      };
    ULONG                   nTag; // 32bit tag to be used in replication protocol
	} COMMASSOC_ASSOC_CTX_T, *PCOMMASSOC_ASSOC_CTX_T;


/*
  ASSOC_TAG - Mapping between (64bit) pointers and 32bit values.
  This has to be used in order to locate the local COMMASSOC_ASSOC_CTX_T structure from the
  32bit value handed by the partner through the replication protocol.
*/

#define COMMASSOC_TAG_CHUNK     64

typedef struct _COMMASSOC_TAG_POOL_T {
    CRITICAL_SECTION crtSection;    // mutual exclusion guard
    LPVOID           *ppStorage;    // array of (64bit) pointer values
    ULONG            *pTagPool;     // array of 32bit tags
    ULONG            nIdxLimit;     // number of entries available in both arrays above
    ULONG           nMaxIdx;        // maximum number of free tags
} COMMASSOC_TAG_POOL_T, *PCOMMASSOC_TAG_POOL_T;

extern COMMASSOC_TAG_POOL_T sTagAssoc;  //32bit ULONG -> LPVOID mapping

/*
function prototypes
*/

extern
VOID
CommAssocSetUpAssoc(
	PCOMM_HDL_T	pDlgHdl,
	PCOMM_ADD_T	pAdd,
	COMM_TYP_E	CommTyp_e,
	PCOMMASSOC_ASSOC_CTX_T	*ppAssocCtx		
	);

extern
VOID
CommAssocFrmStartAssocReq(
	PCOMMASSOC_ASSOC_CTX_T	pAssocCtx,
	MSG_T			pMsg,	
	MSG_LEN_T		MsgLen
	);

extern
VOID
CommAssocUfmStartAssocReq(
	IN  MSG_T			pMsg,
	OUT PCOMM_TYP_E			pAssocTyp_e,
	OUT LPDWORD   			pMajorVer,
	OUT LPDWORD			pMinorVer,	
	OUT ULONG           *puRemAssocCtx
	);


extern
VOID
CommAssocFrmStartAssocRsp(
	PCOMMASSOC_ASSOC_CTX_T	pAssocCtx,
	MSG_T			pMsg,	
	MSG_LEN_T		MsgLen
	);

extern
VOID
CommAssocUfmStartAssocRsp(
	IN  MSG_T		pMsg,
	OUT LPDWORD   	pMajorVer,
	OUT LPDWORD		pMinorVer,	
	IN  ULONG	    *puRemAssocCtx
	);



extern
VOID
CommAssocFrmStopAssocReq(
	PCOMMASSOC_ASSOC_CTX_T   pAssocCtx,
	MSG_T			 pMsg,
	MSG_LEN_T		 MsgLen,
	COMMASSOC_STP_RSN_E	StopRsn_e
	);

extern
VOID
CommAssocUfmStopAssocReq(
	MSG_T			pMsg,
	PCOMMASSOC_STP_RSN_E	pStopRsn_e
	);


extern
VOID
CommAssocDeallocAssoc(
	LPVOID		   pAssocCtx	
	);

extern
VOID
CommAssocDeallocDlg(
	LPVOID		   pDlgCtx	
	);	

extern
LPVOID
CommAssocAllocAssoc(
		VOID
		  );

extern
LPVOID
CommAssocAllocDlg(
	VOID
	);

extern
VOID
CommAssocInit(
	VOID
	);



extern
PCOMMASSOC_DLG_CTX_T
CommAssocInsertUdpDlgInTbl(
	IN  PCOMMASSOC_DLG_CTX_T	pCtx,
	OUT LPBOOL			pfNewElem
	);
	
extern
VOID
CommAssocDeleteUdpDlgInTbl(
	IN  PCOMMASSOC_DLG_CTX_T	pDlgCtx
	);
	

extern
LPVOID
CommAssocCreateAssocInTbl(
	SOCKET SockNo
	);

extern
VOID
CommAssocDeleteAssocInTbl(
	PCOMMASSOC_ASSOC_CTX_T	pAssocCtx	
	);
extern
LPVOID
CommAssocLookupAssoc(
	SOCKET SockNo
	);

extern
VOID
CommAssocInsertAssocInTbl(
	PCOMMASSOC_ASSOC_CTX_T pAssocCtx
	);

extern
ULONG
CommAssocTagAlloc(
    PCOMMASSOC_TAG_POOL_T pTag,
    LPVOID pPtrValue
    );

extern
VOID
CommAssocTagFree(
    PCOMMASSOC_TAG_POOL_T pTag,
    ULONG nTag
    );

extern
LPVOID
CommAssocTagMap(
    PCOMMASSOC_TAG_POOL_T pTag,
    ULONG nTag
    );

#ifdef __cplusplus
}
#endif

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\com\commapi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:
        commapi.c

Abstract:
        This module contains the interface functions to interface with
        the comm. subsystem. These functions are used by the Replicator and
        the Name Space Manager.

Functions:


Portability:

        This module is portable

Author:

        Pradeep Bahl (PradeepB)          Dec-1992

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/


/*
 *       Includes
*/
#include <string.h>
#include <stdio.h>
#include "wins.h"
#include <winsock2.h>
#include "nms.h"
#include "winscnf.h"
#include "comm.h"
#include "assoc.h"
#include "nmsdb.h"
#include "winsmsc.h"
#include "winsevt.h"
#include "rpl.h"

/*
 *        Local Macro Declarations
 */


/*
 *        Local Typedef Declarations
 */



/*
 *        Global Variable Definitions
 */

COMM_HDL_T        QservDlgList;        //list of Q server dialogues.
HANDLE            CommUdpBuffHeapHdl;  //handle to heap used for allocating
                                       //buffers for storing datagrams
HANDLE            CommUdpDlgHeapHdl;   //handle to heap used for allocating
                                       //dlgs for udp buffers


HANDLE             sThdEvtArr[2];      //used by the Push thread in
                                       //ECommProcessDlg

SOCKET CommPnPNotificationSocket = INVALID_SOCKET; //to receive addr change notification
SOCKET CommTcpPortHandle = INVALID_SOCKET; //stores TCP port (socket) #
SOCKET CommUdpPortHandle = INVALID_SOCKET; //stores UDP port (socket) #
SOCKET CommNtfSockHandle = INVALID_SOCKET; //stores socket # of socket used
                                           //for listening for connection
                                           //notification messages from another
                                           //thread in the local WINS)
struct sockaddr_in  CommNtfSockAdd;        //stores address bound to
                                           //connection notification socket


#if SPX > 0
SOCKET CommSpxPortHandle = INVALID_SOCKET; //stores SPX port (socket) #
SOCKET CommIpxPortHandle = INVALID_SOCKET; //stores IPX port (socket) #
SOCKET CommIpxNtfSockHandle = INVALID_SOCKET; //stores socket # of socket used
                                           //for listening for connection
                                           //notification messages from another
                                           //thread in the local WINS)

struct sockaddr_ipx  CommIpxNtfSockAdd;        //stores address bound to
                                           //connection notification socket

#endif
COMM_HDL_T        CommExNbtDlgHdl;  /*explicit dialogue (used for
                                   *sending UDP requests to  nbt nodes */

//
// get rid of it when support for rpc function WinsGetNameAndAdd is
// removed.
//
#if USENETBT == 0
FUTURES("Remove this when support for WinsGetNameOrIpAdd is removed")
FUTURES("Check out ECommGetMyAdd")
BYTE                HostName[NMSDB_MAX_NAM_LEN];
#endif

/*
 *        Local Variable Definitions
 */






/*
  Externals
*/



/*
 *        Local Function Prototype Declarations
 */
VOID
InitOwnAddTbl(
        VOID
        );

//
// function definitions
//
DWORD
CommCreatePnPNotificationSocket(
    )
/*++

Routine Description:

Arguments:

    none.

Return Value:

    Registry Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;

    //
    // Create a socket
    //
    //--ft 06/01/2000: make multiple calls to CommCreatePnPNotificationSocket safe
    //CommCreatePnPNotificationSocket is called from both ECommInit and ECommGetMyAdd
    if (CommPnPNotificationSocket == INVALID_SOCKET)
    {
        CommPnPNotificationSocket = socket(
                                            PF_INET,
                                            SOCK_DGRAM,
                                            IPPROTO_UDP );

        if ( CommPnPNotificationSocket == INVALID_SOCKET ) {
            Error =  WSAGetLastError();
            DBGPRINT1( ERR,"could not create PnP notification socket, %ld.\n", Error );
        }
    }

    return Error;
}

VOID
CommInterfaceChangeNotification(
    DWORD   Error,
    DWORD   cbTransferred,
    LPWSAOVERLAPPED lpOverlapped,
    DWORD   dwFlags
)
/*++

Routine Description:

Arguments:

    none.

Return Value:

    Registry Error.

--*/

{
    DBGPRINT1(FLOW, "CommInterfaceChangeNotification with Error value = (%x)\n", Error);
    if ( Error == ERROR_SUCCESS ) {

        //
        // reregister intrface change notification before we process
        // the current list change. This is required to avoid misssing
        // any interface changes that occur while we are processing
        // the current list.
        ECommRegisterAddrChange();

        if (ECommGetMyAdd(&NmsLocalAdd) == WINS_SUCCESS)
        {

           WinsEvtLogDetEvt(
                 TRUE,
                 WINS_PNP_ADDR_CHANGED,
                 NULL,
                 __LINE__,
                 "dd",
                 pNmsDbOwnAddTbl->WinsAdd.Add.IPAdd,
                 NmsLocalAdd.Add.IPAdd);

           if (pNmsDbOwnAddTbl->WinsAdd.Add.IPAdd != NmsLocalAdd.Add.IPAdd)
           {

            //
            // Send the reconfig message to the Pull thread
            //
            // Note: The PULL thread will deallocate memory pointed
            // to be pWinsCnf when it gets done
            //
            ERplInsertQue(
                    WINS_E_WINSCNF,
                    QUE_E_CMD_ADDR_CHANGE,
                    NULL,                        //no dlg handle
                    NULL,                        //no msg
                    0,                        //msg len
                    NULL,                //client ctx
                    0
                        );
            }

        }


    } else {

        WINSEVT_LOG_M(Error, WINS_EVT_SFT_ERR);
    }

    DBGLEAVE("CommInterfaceChangeNotification\n");
}

VOID
ECommRegisterAddrChange()
{
    //--ft: bug 86768; 'overlap' shouldn't be allocated on the stack
    //since it is passed down to WSAIoctl on an overlapped socket.
    static WSAOVERLAPPED overlap;
    DWORD                Error;
    DWORD                byteRet;

    RtlZeroMemory( &overlap, sizeof(WSAOVERLAPPED));

    Error = WSAIoctl(
                CommPnPNotificationSocket,
                SIO_ADDRESS_LIST_CHANGE,
                NULL,
                0,
                NULL,
                0,
                &byteRet,
                &overlap,
                CommInterfaceChangeNotification
                );

    if ( Error != ERROR_SUCCESS && Error == SOCKET_ERROR) {

        Error = WSAGetLastError();
        if (Error == WSA_IO_PENDING) {
            Error = ERROR_SUCCESS;
        } else {
            DBGPRINT1( ERR,"SIO_INTERFACE_LIST_CHANGE ioctl failed, %ld.\n", Error );
        }
    }
    if (Error != ERROR_SUCCESS ) {

        WINSEVT_LOG_M(Error, WINS_EVT_SFT_ERR);

    }
    return ;

}

VOID
ECommInit(
        VOID
        )
/*++
Routine Description:
         This function is called by the main thread of the process at
        process invocation time.  It initializes the communication subsystem.
        This comprises of

          1)create the TCP and UDP ports
          2)create the TCP and UDP listener threads


        None
Externals Used:
        None

Called by:
        Init() in nms.c
Comments:
        None

Return Value:
        None

--*/

{

        //
        //  Initialize lists, Tables and Memory
        //
        CommInit();

        //
        // Initialize the owner address table with own address
        //
        InitOwnAddTbl();

        // Now register for address change notification
        CommCreatePnPNotificationSocket();
        ECommRegisterAddrChange();

        //
        //  Create the TCP and UDP ports
        //
        CommCreatePorts( );


DBGIF(fWinsCnfRplEnabled)
        //
        // Signal Rpl PULL Thd so that it can go on
        //
        WinsMscSignalHdl(
                        RplSyncWTcpThdEvtHdl
                        );

        //
        // Init the event array used by ECommProcessDlg (in Push thread)
        //
        sThdEvtArr[0] =   RplSyncWTcpThdEvtHdl;
        sThdEvtArr[1] =   NmsTermEvt;

        /*
        * Create the TCP listener thread to monitor the TCP port
        */
        CommCreateTcpThd();

        //
        // if Wins is not coming up in the initially paused state, create
        // the udp thread.
        //
#if INIT_TIME_PAUSE_TEST > 0
//        if (!fWinsCnfInitStatePaused)
        {
           /*
            *  Create the UDP listener thread to monitor the TCP port
            */
            CommCreateUdpThd();
        }
#else
            CommCreateUdpThd();
#endif

        return;
}


#if PRSCONN
__inline
ECommIsBlockValid
 (
        PCOMM_HDL_T        pDlgHdl
 )
{
    return(CommIsBlockValid(pDlgHdl));
}

__inline
BOOL
ECommIsDlgActive
      (
        PCOMM_HDL_T        pDlgHdl
     )
/*++

Routine Description:


Arguments:
        pDlgHdl   --  check if dlg is active

Externals Used:
        None

Called by:
        Replicator

Comments:
        None

Return Value:


--*/
{

#if 0
    //
    // Check if block is valid.  It won't be if the dlg was terminated earlier
    //
    if (!CommIsBlockValid(pDlgHdl))
    {
          return(FALSE);
    }
#endif

    //
    //
    // Check whether the dlg is still active (i.e. the association is still
    // valid.
    // CommIsDlgActive is an inline function.
    //
    return(CommIsDlgActive(pDlgHdl));

}
#endif

STATUS
ECommStartDlg(
        PCOMM_ADD_T         pAdd,  // Address
        COMM_TYP_E         CommTyp_e,
        PCOMM_HDL_T        pDlgHdl
        )

/*++

Routine Description:


Arguments:
        pAdd          -- Address of the WINS server with which to start a dlg
        CommTyp_e -- Type of dialogue (Pull, Push, Notifier, etc)
        pDlgHdl   -- Will contain handle to dlg on successful completion of
                     the function

Externals Used:
        None

Called by:
        Replicator

Comments:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  One of the STATUS codes (see wins.h)

--*/

{

        PCOMMASSOC_ASSOC_CTX_T  pAssocCtx;
        PCOMMASSOC_DLG_CTX_T    pDlgCtx;
        STATUS                  RetStat = WINS_SUCCESS;
#ifdef WINSDBG
        struct in_addr        InAddr;
        LPBYTE  pstrAdd;
#endif

        DBGENTER("ECommStartDlg\n");

        /*
          Allocate a  dlg ctx block
        */
        pDlgHdl->pEnt = CommAssocAllocDlg();
try {
        pDlgCtx         = pDlgHdl->pEnt;
        pDlgCtx->Role_e = COMMASSOC_DLG_E_EXPLICIT;
        pDlgCtx->Typ_e  = CommTyp_e;
        pDlgHdl->SeqNo  = pDlgCtx->Top.SeqNo; //no need actually. (explicit dlg)

        //
        // Set up an association if we are not simulating an NBT node
        //
        if (CommTyp_e != COMM_E_NBT)
        {
                /*
                 * set up an association
                */
                CommAssocSetUpAssoc(
                                pDlgHdl,
                                pAdd,
                                CommTyp_e,
                                &pAssocCtx
                                                   );
                pDlgCtx->State_e          = COMMASSOC_DLG_E_ACTIVE;

                //
                // No need to store sequence no. since there will never
                // be a danger of the assoc. block being reused by some
                // some other dialogue (this is an explicit dialogue)
                //
                pDlgCtx->AssocHdl.pEnt    = pAssocCtx;
                pDlgCtx->Typ_e            = CommTyp_e;
       }
       else  //simulate an NBT node
       {
         //
         // Create a connection to the remote WINS
         //
         CommConnect(
                pAdd,
#if SPX > 0
                pAdd->AddTyp_e == COMM_ADD_E_TCPUDPIP ? CommWinsTcpPortNo :
                          CommWinsSpxPortNo,
#else
                CommWinsTcpPortNo,
#endif
                &pDlgCtx->SockNo
                    );
       }

  }  // end of try { }
except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // Cleanup and reraise the exception
        //
        CommAssocDeallocDlg(pDlgHdl->pEnt);
        pDlgHdl->pEnt = NULL;                //let us cover all bases. See SndPushNtf                                        //in rplpull.c
        WINS_RERAISE_EXC_M();
        }

#ifdef WINSDBG
#if SPX == 0
        InAddr.s_addr = htonl(pAdd->Add.IPAdd);
        pstrAdd = inet_ntoa(InAddr);
#else
        if (pAdd->Add.AddTyp_e == COMM_E_ADD_TCPUDPIP)
        {
          InAddr.s_addr = htonl(pAdd->Add.IPAdd);
          pstrAdd = inet_ntoa(InAddr);
        }
        else
        {
           pstrAdd = pAdd->Add.nodenum;
        }
#endif

        DBGPRINT1(FLOW, "Leaving ECommStartDlg. Dlg started with Host at address -- (%s)\n", pstrAdd);

#endif
        DBGLEAVE("ECommStartDlg\n");
        return(RetStat);
}





VOID
ECommSndCmd(
        IN  PCOMM_HDL_T  pDlgHdl,
        IN  MSG_T        pMsg,
        IN  MSG_LEN_T    MsgLen,
        OUT PMSG_T       ppRspMsg,
        OUT PMSG_LEN_T   pRspMsgLen
        )

/*++

Routine Description:
        This function is used by the Replicator to send commands to Replicators         on remote WINSs.  It is also used by the Name Space Manager of a Q
        server to send name queriies to the Name Space Manager of an RQ server.


Arguments:
        pDlgHdl -- handle to dialogue to use for sending command
        pMsg        -- Msg (Cmd) to send
        MsgLen  -- Length of Message
        ppRspMsg -- Buffer containing response to command
        pRspLen         -- Length of response buffer


Externals Used:
        None

Called by:
        RplPull functions

Comments:
        None

Return Value:
        None
--*/
{

        PCOMMASSOC_ASSOC_CTX_T        pAssocCtx;
        PCOMMASSOC_DLG_CTX_T        pDlgCtx = pDlgHdl->pEnt;
        DWORD                        MsgTyp;
        DWORD                        Opc;
        ULONG                        uTmp;
        STATUS                         RetStat = WINS_SUCCESS;


        /*
          No need to lock the dialogue since:

                currently, only the thread (excluding the COMSYS threads) that
                creates a dialogue (explicit dialogue) sends messages on it.


                In the future, when multiple threads share the same
                dialogue, I will need to lock it or build an elaborate
                asynch notification mechanism (for responses)


          Also, there is no need to lock the associaation since only this
          thread would ever look at it
        */

        /*
         * Send the command
        */
        CommSend(
                pDlgCtx->Typ_e,
                &pDlgCtx->AssocHdl,
                pMsg,
                MsgLen
                );

        pAssocCtx = pDlgCtx->AssocHdl.pEnt;

        /*
          Wait for a response
        */
        RetStat = CommReadStream(
                        pAssocCtx->SockNo,
                        TRUE,                //do timed recv
                        ppRspMsg,
                        pRspMsgLen
                      );

        /*
          if bytes read are 0, there was a disconnect.  If RetStat is not
          success, maybe the recv. timed out or the most severe of
          all conditions, maybe the SOCKET_ERROR got returned by
          the first RecvData() call in CommReadStream. As far as the
          client is concerned, all of these conditions indicate
          COMM failure to it. Let us raise that exception.
        */
        if (( *pRspMsgLen == 0) || (RetStat != WINS_SUCCESS))
        {
                WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
        }
        COMM_GET_HEADER_M(*ppRspMsg, Opc, uTmp, MsgTyp);

        /*
          Let us check that this is not the stop assoc message
        */
        if (MsgTyp == COMM_STOP_REQ_ASSOC_MSG)
        {
            //
            // We do not disconnect the socket.  It will be disconnected as
            // a result of an end dialogue on this explicit association
            //
            //  CommDisc(pAssocCtx->SockNo);

            //
            // Free the buffer
            //
            ECommFreeBuff(*ppRspMsg);
            WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
        }
        /*
         *  Strip off the header before returning to the client
         * (Replicator)
        */
        *ppRspMsg   = *ppRspMsg   + COMM_HEADER_SIZE;
        *pRspMsgLen = *pRspMsgLen - COMM_HEADER_SIZE;

        return;
} // ECommSndCmd





STATUS
ECommSndRsp(
        PCOMM_HDL_T  pDlgHdl,
        MSG_T            pMsg,
        MSG_LEN_T   MsgLen
        )

/*++

Routine Description:

        This function is called by the Comm. clients to send messages to
        destinations identified by the dialogue.  No responses are expected to
        these messages.

        The function is used for sending responses.

Arguments:

        pDlgHdl - handle to dlg to use for sending response
        pMsg        - message (response) to send
        MsgLen  - length of message

Externals Used:
        None

Called by:
        NmsNmh functions, RplPush functions

Comments:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes  --

--*/
{

        BOOL                         fLocked = FALSE;
        STATUS                        RetStat = WINS_SUCCESS;
        PCOMMASSOC_DLG_CTX_T        pDlgCtx   = pDlgHdl->pEnt;

        DBGENTER("ECommSndRsp\n");
FUTURES("Since we do not want the overhead of an if test for responding")
FUTURES("to nbt requests, split up this function into one callable by")
FUTURES("replicator and the other one by NBT threads.  Do note that ")
FUTURES("this will take away some cleanliness of interfacing with COMM")

try {

        /*
          Check if the dialogue is for UDP communication.  If it is, there
          is no need for any synchronization.

          There is no need to lock the dialogue prior to checking it because

            if it is a UDP dialogue, it has to be the one that was allocated
            for this request (i.e. there is no possibility that we are now
            looking at another UDP dialogue).

        */
        if (pDlgCtx->Typ_e != COMM_E_UDP)
        {
                /*
                  * Lock the dialogue block so that it is not deleted from
                * under us. Actually, as things stand currently, an explicit
                * dialogue is never used by more than one thread. So, we don't
                * have to lock a dialogue if it is an explicit dialogue.  Let
                * us do it anyway since in the forseeable future, we could have
                * multiple threads using the same dialogue (Replicator threads -
                * Pull and Notifier). This is small insurance to save us
                * from later headaches.
                */

                fLocked = CommLockBlock(pDlgHdl);
                if (fLocked)
                {
                        CommSend(
                                pDlgCtx->Typ_e,
                                &pDlgCtx->AssocHdl,
                                pMsg,
                                MsgLen
                                );
                    }
                    else  //dialogue could not be locked
                {
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_LOCK_ERR);
                        DBGPRINT0(ERR, "ECommSndRsp: Could not lock the dialogue\n");
                        /*
                          *If Dialogue block could not be locked, it means
                         *that it was freed by the TCP listener thread (Check
                         *DelAssoc() in comm.c).  This would happen only
                         *if the connection terminated or if a stop assoc
                         *message was received on it.

                          *Return a COMM_FAIL error.  This will return in
                         *a search for a termination handler.  It is *ok*
                         * to take this overhead since this is a
                         * rare error case
                        */

                        return(WINS_COMM_FAIL);
                }

                if (CommUnlockBlock(pDlgHdl) == WINS_FAILURE)
                {
                        RetStat = WINS_FAILURE;
                }
                else  //successfully unlocked the dialogue
                {

                        fLocked = FALSE;
                }
        }
        else // it is dialogue for UDP communication with an NBT node
        {
                CommSendUdp(
                        0,
                        &(pDlgCtx->FromAdd),
                        pMsg,
                        MsgLen
                           );
                /*
                  We have sent the response.  We should now get rid of
                  the dialogue from the dialogue table.  This will
                  free the heap memory
                */
                CommAssocDeleteUdpDlgInTbl( pDlgCtx );
        }
    }

finally {

        if (fLocked)
        {
                  CommUnlockBlock(pDlgHdl);
        }
     }

     DBGLEAVE("ECommSndRsp\n");
     return(RetStat);

}

STATUS
ECommSendMsg(
        PCOMM_HDL_T          pDlgHdl,
        PCOMM_ADD_T        pAdd,
        MSG_T                  pMsg,
        MSG_LEN_T          MsgLen
        )

/*++

Routine Description:

        This function is used by the name challenge manager to send queries
        and release request to nbt nodes.

        It is also used by the replicator to send a Push notification to
        a WINS (pull pnr)

Arguments:
        pDlgHdl - handle to dlg to use for sending message
        pAdd        - Address of node to send message to
        pMsg    - Message to send
        MsgLen  - Length of message to send

Externals Used:
        None

Called by:
        NmsChl functions

Comments:

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   --

--*/

{

        PCOMMASSOC_DLG_CTX_T        pDlgCtx = pDlgHdl->pEnt;
         struct sockaddr_in         TgtAdd;

        //
        // if the dialogue is mapped to the UDP port, send a UDP packet
        //
        if (pDlgCtx->Typ_e == COMM_E_UDP)
        {
                //
                // Don't change from host to net order. CommSendUdp does
                // that
                //
                 TgtAdd.sin_addr.s_addr = pAdd->Add.IPAdd;
                 if(TgtAdd.sin_addr.s_addr == INADDR_NONE)
                 {
                        return(WINS_FAILURE);
                 }
                 TgtAdd.sin_family = PF_INET;
                 TgtAdd.sin_port   = htons(WINS_NBT_PORT);

                 //
                 // Send the message via netbt
                 //
                 CommSendUdp( 0,  &TgtAdd, pMsg, MsgLen );
        }
        else  // it is a dialogue mapped to a TCP connection
        {
                //
                // Send the message
                //
                CommSend(
                          pDlgCtx->Typ_e,
                          &pDlgCtx->AssocHdl,
                          pMsg,
                          MsgLen
                        );
        }
         return(WINS_SUCCESS);
}




STATUS
ECommEndDlg(
        PCOMM_HDL_T         pDlgHdl
        )

/*++

Routine Description:


        This function is used to end a dialogue.


        The processing depends upon the type of dialogue

        1)if the dlg is an implicit UDP dialogue. it is deleted from
        the dlg table and the memory is freed.

        2)if the dlg is an implicit dlg, a stop assoc.
          message is sent on the association

        3)if the dlg is an explicit dlg, a stop assoc. message is
          message is sent on the association and the association is
          terminated


Arguments:
        pDlgHdl - Handle to dlg to end

Externals Used:
        None

Called by:
        RplPull functions, HandleUpdNtf in rplpush.c (by the Push thread)

Comments:
        Currently, there is no need to lock an explicit dialogue since only
        one thread accesses it any time (currently).  In the future, if we
        have multiple threads accessing the same dialogue, we will do locking


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --

--*/

{
        BYTE                        Msg[COMMASSOC_ASSOC_MSG_SIZE];
        DWORD                        MsgLen = COMMASSOC_ASSOC_MSG_SIZE;
        PCOMMASSOC_ASSOC_CTX_T   pAssocCtx;
        PCOMMASSOC_DLG_CTX_T        pDlgCtx = pDlgHdl->pEnt;
        BOOL                        fLocked;

        DBGENTER("ECommEndDlg\n");
        //
        // If there is no dialogue to be ended, return WINS_INVALID_HDL
        // Note: There can be cases in failure recovery where ECommEndDlg
        // may be called to end a dialogue that was never got started or
        // got ended prematurely.  Though an error status is returned, the
        // caller, when doing failure recovery, may ignore the return status
        // of this function.  In case of fatal error conditions, an exception
        // will be raised which the caller can not ignore.
        //
        if (pDlgCtx == NULL)
        {
                DBGLEAVE("ECommEndDlg\n");
                return(WINS_INVALID_HDL);
        }

        //
        //  In case it is an implicit UDP dialogue, there is no danger
        //  of it being freed from under us, so there is no need to lock.
        //  In case it is an implicit TCP dialogue, it could get freed
        //  and even reallocated from under us, but reallocation will only
        //  be for TCP, so there is no danger since we do lock the dlg
        //  block if it is a TCP dlg block (if there has been a reallocation,
        //  the lock attempt  will fail.)
        //
        if (pDlgCtx->Role_e == COMMASSOC_DLG_E_IMPLICIT)
        {
             if (pDlgCtx->Typ_e == COMM_E_UDP)
             {
                   //
                   // Delete the dialogue from the table and free the
                   // heap memory
                   //
                   CommAssocDeleteUdpDlgInTbl( pDlgCtx );
             }
             else  // it is a TCP dialogue.
             {

                fLocked = CommLockBlock(pDlgHdl);

                //
                // If we could lock it, the dlg is ok.  If we could not
                // lock it, it means that the dlg was freed due to the
                // the assoc. going down. We have nothing more to do.
                //
                if (fLocked)
                {
                        pAssocCtx = pDlgCtx->AssocHdl.pEnt;

                        //
                        // The stop assoc. message will result in the
                        // the other WINS terminating the connection which
                        // result in all cleanup at our end
                        //
                            CommAssocFrmStopAssocReq(
                                pAssocCtx,
                                Msg,
                                MsgLen,
                                COMMASSOC_E_MSG_ERR
                                         );
                       try {

                        CommSendAssoc(
                                        pAssocCtx->SockNo,
                                        Msg,
                                        MsgLen
                                   );
                          }
                        except(EXCEPTION_EXECUTE_HANDLER) {
                            //
                            // No need to do any cleanup.  This is an
                            // implicit dlg.  The tcp listener thread will
                            // do the cleanup. Currently, it never calls
                            // ECommEndDlg for an implicit dlg so the client
                            // has got to be rpl
                            //
                            DBGPRINTEXC("CommEndDlg");
                         }

                         CommUnlockBlock(pDlgHdl);
                }
             }
        }
        else  // it is an explicit dialogue
        {
                if (pDlgCtx->Typ_e != COMM_E_NBT)
                {
                        CommEndAssoc(&pDlgCtx->AssocHdl);
                }

                /*
                   *  Dealloc the dialogue in order to put it in the free list
                */
                CommAssocDeallocDlg( pDlgCtx );
#if PRSCONN
FUTURES("Init the dlg hdl in the caller - good software engineering practice")
                //
                // The dlg is ended.  Let us init the dlg hdl to null so that
                // it is not used again.  Strictly speaking, we should do let
                // the caller do this.  For now, we will do it here
                //
                ECOMM_INIT_DLG_HDL_M(pDlgHdl);
#endif
        }

        DBGLEAVE("ECommEndDlg\n");
        return(WINS_SUCCESS);
}




#if 0
ECommSendtoAllQ(
        MSG_T           pMsg,
        MSG_LEN_T MsgLen
        )

/*++

Routine Description:
 This function is called to send a message to all Q servers.


Arguments:


Externals Used:
        None

Called by:

Comments:
        May use it in the future.  Needs work.

Return Value:

   Success status codes --
   Error status codes  --

--*/

{

        /*
          if there is no dialogue pertaining to a Q server, return failure
        */

        if (IsListEmpty(&QservDlgList))
        {
                return(WINS_FAILURE);
        }


        /*
                find all the dialogues pertaining to Q servers
        */

        while ((pQservDlg = GetNext(&QservDlgList)) != &QservDlgList)
        {
                CommSendAssoc(pQservDlg->pAssocCtx->SockNo, pMsg, MsgLen);
        }

        return(WINS_SUCCESS);
}

#endif

STATUS
ECommAlloc(
  OUT LPVOID                 *ppBuff,
  IN  DWORD                 BuffSize
        )

/*++

Routine Description:

        This function is called by by the replicator to allocate a buffer for
        sending to another WINS (over a TCP connection)


Arguments:
        ppBuff   - Buffer allocated by function
        BuffSize - Size of buffer to be allocated

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes  --

Error Handling:

Called by:

Side Effects:

Comments:

        Challenge manager should not call this function.  When it is coded,
        it will call AllocUdpBuff which will be made an external for this
        purpose (CommAllocUdpBuff)
--*/

{

        DWORD                Size =   COMM_HEADER_SIZE +
                                   sizeof(COMM_BUFF_HEADER_T) + sizeof(LONG);
        PCOMM_BUFF_HEADER_T pCommHdr;

        WinsMscAlloc( Size + BuffSize, ppBuff);
#if 0
        *ppBuff = CommAlloc(
                        NULL,         //no table
                        Size + BuffSize
                            );
#endif
        pCommHdr = (PCOMM_BUFF_HEADER_T)((LPBYTE)(*ppBuff) + sizeof(LONG));
        pCommHdr->Typ_e = COMM_E_TCP; //until we know better
        *ppBuff = (LPBYTE)(*ppBuff) + Size;

        return(WINS_SUCCESS);
}

#if 0

VOID
ECommDealloc(
  LPVOID pBuff
        )

/*++

Routine Description:
        This is a wrapper around CommDealloc. It conforms to the
        prototype required by RtlInitializeGenericTbl func.

Arguments:

        pBuf -- Buffer to deallocate

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        Not being used currently
--*/
{
        LPVOID pTmp = (LPBYTE)pBuff - COMM_HEADER_SIZE;

        WinsMscDealloc(pTmp);
#if 0
        CommDealloc(NULL, pTmp);
#endif
        return;
}
#endif

DWORD
ECommCompAdd(
        PCOMM_ADD_T        pFirstAdd,
        PCOMM_ADD_T        pSecAdd
        )

/*++

Routine Description:
        the function compares two host addresses

Arguments:

        pFirstAdd  - Address of a node
        pSecondAdd - Address of a node

Externals Used:
        None


Return Value:

        COMM_SAME_ADD
        COMM_DIFF_ADD

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
#if 0
        if ((pFirstAdd->AddTyp_e == COMM_ADD_E_TCPUDPIP) &&
            (pSecAdd->AddTyp_e == COMM_ADD_E_TCPUDPIP))
#endif
        {
          if (pFirstAdd->Add.IPAdd == pSecAdd->Add.IPAdd)
          {
                return(COMM_SAME_ADD);
          }
        }
        return(COMM_DIFF_ADD);
}

int
__cdecl
ECommCompareAdd(
        const void       *pKey1,
        const void       *pKey2
        )

/*++

Routine Description:
        the function compares two host addresses

Arguments:

        pFirstAdd  - Address of a node
        pSecondAdd - Address of a node

Externals Used:
        None


Return Value:


Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        const COMM_ADD_T *pFirstAdd = pKey1;
        const COMM_ADD_T *pSecAdd = pKey2;

        return (pFirstAdd->Add.IPAdd > pSecAdd->Add.IPAdd) ?
                    1 :
                    (pFirstAdd->Add.IPAdd < pSecAdd->Add.IPAdd) ?
                        -1:
                        0;
}

VOID
ECommFreeBuff(
        IN MSG_T    pMsg
        )

/*++

Routine Description:

        This function is called to free a buffer allocated earlier by
        COMSYS.  The function checks the buffer header to determine which
        deallocation function to call

        The usefulness of this function stems from the fact that a buffer
        can be made independent of the dialogue (or association) it came from
        in the sense that we don't need to pass information about such a
        dlg or assoc when freeing the buffer.  This saves us from locking
        and unlocking.

Arguments:

        pMsg -- Buffer to free

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:
        SndNamRegRsp, SndNamRelRsp, SndNamQueryRsp in nmsnmh.c

Comments:
        None
--*/

{

#if USENETBT > 0
        PCOMM_BUFF_HEADER_T  pHdr = (PCOMM_BUFF_HEADER_T)
                                      (pMsg - COMM_NETBT_REM_ADD_SIZE -
                                                sizeof(COMM_BUFF_HEADER_T));
#else
        PCOMM_BUFF_HEADER_T  pHdr = (PCOMM_BUFF_HEADER_T)
                                      (pMsg - sizeof(COMM_BUFF_HEADER_T));
#endif

        if (pHdr->Typ_e == COMM_E_UDP)
        {

                WinsMscHeapFree(
                                   CommUdpBuffHeapHdl,
                                   pHdr
                                  );
        }
        else
        {
                WinsMscHeapFree(CommAssocTcpMsgHeapHdl, (LPBYTE)pHdr - sizeof(LONG));
          //      WinsMscDealloc((LPBYTE)pHdr - sizeof(LONG));
        }
        return;
}


VOID
InitOwnAddTbl(
        VOID
        )

/*++

Routine Description:
        This function uses the local address of the WINS (i.e. the host
        address) to overwrite the NmsDbOwnAddTbl array entry
        pertaining to the local WINS if different

Arguments:
        None

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

        CommInit  (in the main thread)

Side Effects:

Comments:
        There is no need to synchronize over the NmsDbOwnAddTbl since
        the PULL thread will not touch it until it initiates the pull protocol
--*/

{
        COMM_IP_ADD_T        IPAddInDbTbl;

        //
        // if the address of the owner with  owner id = NMSDB_LOCAL_OWNER_ID
        // is different from mine (i.e. local WINS)
        // change it to mine.  I always own all entries tagged with
        // owner id of 0.  The fact that the address is different
        // means that the database was earlier used by a WINS at
        // a different address.
        //
        IPAddInDbTbl =  pNmsDbOwnAddTbl->WinsAdd.Add.IPAdd;
        if (
                IPAddInDbTbl != NmsLocalAdd.Add.IPAdd
           )
        {


               //
               // IPAddInDbTbl will be zero if there is no entry in the
               // local db having NMSDB_LOCAL_OWNER_ID as the owner field
               // value
               //
               NmsDbWriteOwnAddTbl (
                        IPAddInDbTbl == 0 ?
                                NMSDB_E_INSERT_REC : NMSDB_E_MODIFY_REC,
                        NMSDB_LOCAL_OWNER_ID,
                        &NmsLocalAdd,
                        NMSDB_E_WINS_ACTIVE,
                        &NmsDbStartVersNo,
                        &NmsDbUid
                                );

               pNmsDbOwnAddTbl->WinsAdd     =  NmsLocalAdd;
               pNmsDbOwnAddTbl->WinsState_e =  NMSDB_E_WINS_ACTIVE;
               pNmsDbOwnAddTbl->MemberPrec  =  WINSCNF_HIGH_PREC;
               pNmsDbOwnAddTbl->StartVersNo =  NmsDbStartVersNo;
               pNmsDbOwnAddTbl->Uid         =  NmsDbUid;

        }

        return;
}


BOOL
ECommProcessDlg(
        PCOMM_HDL_T        pDlgHdl,
        COMM_NTF_CMD_E     Cmd_e
        )

/*++

Routine Description:

        This function is called to either start or stop  monitoring a
        dialogue.  It  sends a message to the TCP listener thread  (a UDP
        datagram) on the notification socket.

Arguments:
        pDlgHdl - Dialogue handle
        Cmd_e   - Cmd (COMM_E_NTF_START_MON or COMM_E_NTF_STOP_MON)

Externals Used:
        RplSyncWTcpThdEvtHdl

Return Value:
        None

Error Handling:

Called by:
        SndUpdNtf in rplpull.c, HdlUpdNtf in rplpush.c

Side Effects:

Comments:
        The client should not expect to use the dailogue after calling
        this functions

        Only the Push thread calls this function

--*/

{
        COMM_NTF_MSG_T                NtfMsg;
        BOOL  fRetStat = TRUE;
        DWORD ArrInd;


        DBGENTER("ECommProcessDlg\n");

        //
        //Format the message to send in the UDP datagram
        //
        if (CommLockBlock(pDlgHdl))
        {
          PCOMMASSOC_DLG_CTX_T    pDlgCtx    = pDlgHdl->pEnt;
          PCOMMASSOC_ASSOC_CTX_T  pAssocCtx  = pDlgCtx->AssocHdl.pEnt;

          NtfMsg.SockNo    = pAssocCtx->SockNo;
          NtfMsg.Cmd_e     = Cmd_e;
          NtfMsg.AssocHdl  = pDlgCtx->AssocHdl;
          NtfMsg.DlgHdl    = *pDlgHdl;

CHECK("If TCP protocol is installed.  If not, use the Spx notification socket")

          CommUnlockBlock(pDlgHdl);

          CommSendUdp(
                        CommNtfSockHandle,
                        //CommUdpPortHandle,                   //sending port
                        &CommNtfSockAdd,                    //Address to send to
                        (LPBYTE)&NtfMsg,                //socket no to send
                        COMM_NTF_MSG_SZ
                   );

        DBGPRINT2(DET,
                "ECommProcessDlg: Sent %s monitoring message to TCP listener thread for socket no (%d)\n",
                Cmd_e == COMM_E_NTF_START_MON ? "start" : "stop",
                NtfMsg.SockNo
                 );

        //
        // if the command is to "stop monitoring the dlg" we have to wait
        // until the TCP listener thread has receive this message and
        // taken the socket out of its array of sockets
        //
        if (Cmd_e == COMM_E_NTF_STOP_MON)
        {
                //
                //Wait to be signaled by the TCP listener thread indicating that
                // it has removed the socket from the list of sockets that it
                // is monitoring. We also want to check the term. event since
                // the tcp thread may have terminated as a result of
                // a termination of WINS.
                //
                //WinsMscWaitInfinite(RplSyncWTcpThdEvtHdl);
                WinsMscWaitUntilSignaled(
                                   sThdEvtArr,
                                   sizeof(sThdEvtArr)/sizeof(HANDLE),
                                   &ArrInd,
                                   FALSE
                                        );

                if (ArrInd == 0)
                {
                   if (fCommDlgError)
                   {
                       DBGPRINT0(ERR, "ECommProcessDlg: The tcp listener thread indicated that the IMPLICIT assoc has been deallocated.  TIMING WINDOW\n");
                       fRetStat = FALSE;
                       fCommDlgError = FALSE;

                   }
                }
                else
                {
                     //
                     //Signaled for termination
                     //
                     WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
                }
        }
       }
       else
       {
             DBGPRINT1(ERR, "ECommProcessDlg: Could not lock the (%s) dlg block. Maybe the assocication and dialogue got deallocated\n", Cmd_e == COMM_E_NTF_STOP_MON ? "IMPLICIT" : "EXPLICIT");
              fRetStat = FALSE;
       }
        //
        // All done. Return
        //
        DBGLEAVE("ECommProcessDlg\n");
        return(fRetStat);
}

//--ft: 11/30/99
STATUS
CommRaiseMyDnsAdd(
        IN OUT LPSOCKET_ADDRESS_LIST   pAddrList
        )
//++
//Routine Description:
//
//        This function is called to find out the address returned by DNS when
//        the server address is queried through gethostbyname().
//
//Arguments:
//        pAddrList - the list of local interfaces as returned by WSAIoctl(SIO_ADDRESS_LIST_QUERY)
//--
{
    DWORD           Error = ERROR_SUCCESS;
    struct hostent  *pHostEnt;
    BYTE            HostName[NMSDB_MAX_NAM_LEN];
    CHAR            **pHostIter;

    // Get host's name
    if (gethostname(HostName, NMSDB_MAX_NAM_LEN) == SOCKET_ERROR)
    {
         return WSAGetLastError();
    }

    // Get host's HOSTENT structure
    pHostEnt = gethostbyname(HostName);

    if (pHostEnt == NULL)
    {
        return WSAGetLastError();
    }

    // For each address returned by DNS
    for (pHostIter = pHostEnt->h_addr_list; (*pHostIter) != NULL; pHostIter++)
    {
        INT i;

        // For each address in the interfaces list
        for (i = 0; i < pAddrList->iAddressCount; i++)
        {
            LPSOCKADDR_IN pSockIf = (LPSOCKADDR_IN)(pAddrList->Address[i].lpSockaddr);

            // it is assumed the address is IP (DWORD size)
            if (WINSMSC_COMPARE_MEMORY_M(
                    (*pHostIter),
                    &(pSockIf->sin_addr),
                    pHostEnt->h_length) == (UINT)pHostEnt->h_length)
            {
                // bring the DNS address in front of the interfaces list if needed
                // this is where the address to be used will be picked up from
                if (i != 0)
                {
                    LPSOCKADDR_IN pSockIfAtZero = (LPSOCKADDR_IN)(pAddrList->Address[0].lpSockaddr);
                    WINSMSC_COPY_MEMORY_M(
                        pSockIfAtZero,
                        pSockIf,
                        sizeof(SOCKADDR_IN)
                        );
                }
                // return success
                return Error;
            } // end_if success in matching dns address with if address
        } // end_for each interface address
    } // end_for each dns address

    // at this point is kind'a weird: either no DNS address could be found in the interfaces list
    // or the interfaces list is just empty (no interfaces?)
    // in either cases, this will be handled by the caller - the interfaces list is untouched
    return Error;
}

STATUS
ECommGetMyAdd(
        IN OUT PCOMM_ADD_T        pAdd
        )

/*++

Routine Description:

        This function is called to find out the name and address of the
        local machine and store it for later use.

Arguments:
        pAdd - pointer to buffer to contain the address

Externals Used:
        NmsLocalAdd

Return Value:
        None

Error Handling:

Called by:
        Init() in nms.c

Side Effects:

Comments:
        THIS MUST BE THE FIRST COMM FUNCTION TO BE CALLED IN WINS. This
        is so that WSAStartup is called prior to calling any winsock functions
--*/

{

        DWORD              Error;
        int                RetVal;
        DWORD              RetStat = WINS_SUCCESS;
        NTSTATUS           RetStatus;
        static BOOL        bWSAStarted = FALSE;
        WSADATA            wskData;
        DBGENTER("ECommGetMyAdd\n");
        /*
        * Let us call the WSAStartup function.  This function needs
        * to be called before any other wins socket function can be
        * called.
        */

        // added the bWSAStarted variable to avoid making several subsequent
        // calls to WSAStartup. Also it looks like there is no matching
        // WSACleanup call at this time.
        if (!bWSAStarted)
        {
            if (WSAStartup(0x101, &wskData) || (wskData.wVersion != 0x101))
            {
                   WinsEvtLogDetEvt(
                         FALSE,
                         WINS_PNP_FAILURE,
                         NULL,
                         __LINE__,
                         "d",
                         WINS_EXC_FATAL_ERR);

                   WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
            }

            bWSAStarted = TRUE;
        }

        //
        // If this is a cluster machine, always use cluster Ip resource address
        //
        if (WinsClusterIpAddress)
        {
            pAdd->Add.IPAdd = WinsClusterIpAddress;
        }
        else
        {
            DWORD                   dwAddrListSz = 0;   // size of the ioctl out buffer
            LPSOCKET_ADDRESS_LIST   pAddrList = NULL;   // pointer to the ioctl out buffer

            Error = CommCreatePnPNotificationSocket();

            if (Error == ERROR_SUCCESS)
            {
                // make one Ioctl call to get the required size of the output buffer
                // this should fail with SOCKET_ERROR and with LastError = WSAEFAULT
                Error = WSAIoctl(
                              CommPnPNotificationSocket,
                              SIO_ADDRESS_LIST_QUERY,
                              NULL,
                              0,
                              NULL,
                              0,
                              &dwAddrListSz,
                              NULL,
                              NULL
                              );
            }

            // if CommCreatePnPNotificationSocket failed, Error is supposed to be a WSAError
            // and not SOCKET_ERROR. This avoids calling WSAIoctl a second time and the error
            // will be captured in the next if()
            // we should get an error with the LastError = WSAEFAULT
            if (Error == SOCKET_ERROR && WSAGetLastError() == WSAEFAULT)
            {
                WinsMscAlloc(dwAddrListSz, &pAddrList);
                // make a second IoctlCall in order to get the list of addresses in
                // the newly allocated buffer. This is expected to succeed
                Error = WSAIoctl(
                              CommPnPNotificationSocket,
                              SIO_ADDRESS_LIST_QUERY,
                              NULL,
                              0,
                              pAddrList,
                              dwAddrListSz,
                              &dwAddrListSz,
                              NULL,
                              NULL
                              );                
            }

            // on success, go raise the first address known by DNS
            // this hack is needed in order to get the first adaptor from the binding list.
            // It seems like gethostbyname returns the adaptors in binding order while WSAIoctl does not.
            if (Error == 0)
            {
                // this is another hack: it looks like DNS is not refreshing the addresses instantly. For instance,
                // plugging out the cable for the first ip from the DNS list triggers CommInterfaceChangeNotification
                // but while in this function gethostbyname() still shows the address that went away as the first
                // one in the list. Add 1/2 sec delay here to let DNS update its addresses and after that attempt
                // to raise in the list returned by SIO_ADDRESS_LIST_QUERY the first address known by DNS.
                Sleep(500);
                Error = CommRaiseMyDnsAdd(pAddrList);
            }

            if (Error != 0)
            {
                Error = WSAGetLastError();

                WinsEvtLogDetEvt(
                     FALSE,
                     WINS_PNP_FAILURE,
                     NULL,
                     __LINE__,
                     "d",
                     Error);

                DBGPRINT1(ERR,
                 "ECommGetMyAdd:WSAIoctl(SIO_ADDRESS_LIST_QUERY) failed with error %d\n", Error);

                if (pAddrList != NULL)
                {
                    WinsMscDealloc(pAddrList);
                    pAddrList = NULL;
                }

                WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
            }

            if (pAddrList->iAddressCount > 0)
            {
                // why fooling around - pAdd->Add.IPAdd is a DWORD anyhow.
                pAdd->Add.IPAdd =
                    ((LPSOCKADDR_IN)(pAddrList->Address[0].lpSockaddr))->sin_addr.s_addr;
            }
            else
            {
                // just in case no addresses were passed up by the Ioctl, set the address
                // to 0. It will be seen as such a couple lines down.
                pAdd->Add.IPAdd = 0;
            }

            if (pAddrList != NULL)
            {
                WinsMscDealloc(pAddrList);
                pAddrList = NULL;
            }

            //
            //  Initialize the structure
            //
            pAdd->Add.IPAdd = ntohl(pAdd->Add.IPAdd);
        }

        //
        // This prints the address in reverse order, that's ok
        //
        DBGPRINT1(DET, "ECommGetMyAdd: Binding to Nbt interface %s\n",
                  inet_ntoa(*(struct in_addr *)&pAdd->Add.IPAdd));


        //
        // If we have a 0 address or a loopback address, it means that the
        // address went away.  Wait for one to come back.
        //
        if ((WinsCnf.State_e != WINSCNF_E_TERMINATING) &&
            ((pAdd->Add.IPAdd & 0xff000000) != (INADDR_LOOPBACK & 0xff000000)) && 
            (pAdd->Add.IPAdd != 0))
        {
           try
           {
               if (WinsCnfNbtHandle)
               {
                    NTSTATUS         status;
                    IO_STATUS_BLOCK  iosb;
                    tWINS_SET_INFO   setInfo;

                    // if there is already a Nbt handle, just rebind it
                    setInfo.IpAddress = pAdd->Add.IPAdd;

                    // this ioctl is just notifying NetBt on the address change.
                    // it should succeed with STATUS_SUCCESS - no reason for 'pending'
                    // hence no reason for passing down an Apc or an event handle.
                    status = NtDeviceIoControlFile(
                                      WinsCnfNbtHandle,             // Handle
                                      NULL,                         // Event
                                      NULL,                         // ApcRoutine
                                      NULL,                         // ApcContext
                                      &iosb,                        // IoStatusBlock
                                      IOCTL_NETBT_WINS_SET_INFO,    // IoControlCode
                                      &setInfo,                     // InputBuffer
                                      sizeof(tWINS_SET_INFO),       // Buffer Length
                                      NULL,                         // Output Buffer
                                      0                             // Output BufferSize
                             );

                    ASSERT(status == STATUS_SUCCESS);
               }
               else
               {
                   // open netbt handle with interface having this address
                   CommOpenNbt(pAdd->Add.IPAdd);
               }

               // We need to get all netbt interfaces' Ip addresses. They are sent
               // via multicast packet to other wins servers to support find self
               // partner feature.
               CommGetNetworkAdd();

               pAdd->AddTyp_e   = COMM_ADD_E_TCPUDPIP;
               pAdd->AddLen     = sizeof(COMM_IP_ADD_T);
           }
           except(EXCEPTION_EXECUTE_HANDLER)
           {
                WinsEvtLogDetEvt(
                     FALSE,
                     WINS_PNP_FAILURE,
                     NULL,
                     __LINE__,
                     "d",
                     GetExceptionCode());

                WINS_RERAISE_EXC_M();
           }
        }
        else
        {
           RetStat = WINS_FAILURE;
        }

        DBGLEAVE("ECommGetMyAdd\n");
        return(RetStat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\nmfilter.h ===
#ifndef _NMFILTER_H
#define _NMFILTER_H

// the node having this flag is a terminal node for some name
#define NMFILTER_FLAG_TERMINAL          0x00000001

// The filter is designed as a tree in which each node stands for one char from the NETBIOS name.
// The char (Key) associated with each node is contained in the parent's node, next to the reference
// (pointer) this the node. Given that we are filtering 1B names, the root of the tree stands for the
// 1B character (1B names are stored differently in the database: the 16th byte (1B) is swaped with
// the first char of the name.

typedef struct _NMFILTER_TREE   NMFILTER_TREE, *PNMFILTER_TREE;

struct _NMFILTER_TREE
{
    LIST_ENTRY   Link;          // list of NMFILTER_TREE structures linking all nodes having the 
                                // same parent node.
    CHAR         chKey;         // node key: each name in the filter is composed by the sequence of
                                // keys from the root to one of the leafs.
    UINT         nRef;          // number of references for this char in different filters having
                                // the same prefix. This ranks higher this node making the search faster
    BYTE         FollowMap[32]; // bitmask: one bit for each of the 256 possible byte values
                                // byte values (265/8=>32). The search engine will determine
                                // as fast as possible if a follower exists (and need to be
                                // searched in LstFollow) or not.
    DWORD        Flags;         // flags associated with this node.
    LIST_ENTRY   Follow;        // lisf of NMFILTER_TREE structures for all the followers (successors)
                                // of this node. These are chars that follow chKey in all filters.
};

extern CRITICAL_SECTION g_cs1BFilter;   // critical section protecting the filter tree
extern PNMFILTER_TREE   g_p1BFilter;    // filter to use for 1B names

// init the filter passed as parameter
PNMFILTER_TREE
InitNmFilter(PNMFILTER_TREE pFilter);

// clears the whole subtree from the node given as parameter, 
// the node itself being also deleted
PNMFILTER_TREE
DestroyNmFilter(PNMFILTER_TREE pNode);

// inserts a name in the filter
VOID
InsertNmInFilter(PNMFILTER_TREE pNode, LPSTR pName, UINT nLen);

// checks whether a name is present in the filter or not
BOOL
IsNmInFilter(PNMFILTER_TREE pNode, LPSTR pName, UINT nLen);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\rpc\winscl.c ===
//============================================================================
// Copyright(c) 1998, Microsoft Corporation
//
// File:    winscl.c
//
// Modification History:
//
//  1/14/1998   Ram Cherala (ramc)
//      Added this header and made the following changes to make winscl a more
//      intuitive and easy tool to use.
//      Expanded abbreviations like vers. to the full form words.
//      Made all string comparisions case insensitive.
//      Made the input choices more obvious - very specifically state what the
//      user should be entering as input to commands.
//      Printed version IDs in hexadecimal like the WINS snap-in does.
//
// Implementation of winscl command line utility
//============================================================================

#include <stdio.h>
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//#include <windef.h>
#include <winsock.h>
#include "windows.h"
//#include "jet.h"
//#include "winsif.h"
#include "winsintf.h"

//
// This includes wins.h which includes windbg.h
//
// winsdbg.h defines STATIC to nothing now
//
#include "winsthd.h"


#define FILEU   "winsu"
#define FILEO   "winso"

STATIC
VOID
GetNameInfo(
        PWINSINTF_RECORD_ACTION_T pRecAction,
        WINSINTF_ACT_E                  Cmd_e
         );
STATIC
VOID
GetFilterName(
        LPBYTE  pStr,
        LPDWORD pLen
         );

STATIC
DWORD
GetStatus(
        BOOL                          fPrint,
        LPVOID                       pResults,
        BOOL                         fNew,
        BOOL                         fShort
        );
VOID
ChkAdd(
        PWINSINTF_RECORD_ACTION_T pRow,
        FILE                          *pFile,
        DWORD                          Add,
        LPBOOL                          pfMatch
      );
STATIC
VOID
WantFile(
        FILE **ppFile
);

STATIC
DWORD
GetDbRecs(
   WINSINTF_VERS_NO_T LowVersNo,
   WINSINTF_VERS_NO_T HighVersNo,
   PWINSINTF_ADD_T     pWinsAdd,
   LPBYTE              pTgtAdd,
   BOOL                      fSetFilter,
   LPBYTE              pFilterName,
   DWORD              Len,
   BOOL                      fAddFilter,
   DWORD              AddFilter,
   FILE                      *pFile,
   BOOL                      fCountRec
  );

STATIC
DWORD
GetDbRecsByName(
  PWINSINTF_ADD_T pWinsAdd,
  DWORD           Location,
  LPBYTE          pName,
  DWORD           NameLen,
  DWORD           NoOfRecsDesired,
  DWORD           TypeOfRecs,
  BOOL            fFilter,
  DWORD           AddFilter
 ) ;

WINSINTF_VERS_NO_T        sTmpVersNo;


STATIC
DWORD
CreateFiles(
    PWINSINTF_RECS_T pRecs,
    PWINSINTF_ADD_T      pWinsAdd,
    FILE *pFileU,
    FILE  *pFileO
    );

STATIC
DWORD
InitFromFile(
        VOID
    );

VOID
Usage(
  VOID
 );

typedef enum _CMD_E *PCMD_E;

VOID
GetCmdCode(
  LPBYTE pCmd,
  PCMD_E pCmd_e
 );

typedef enum _CMD_E {
   REG_NAME = 0,
   QUERY_NAME,
   DEL_NAME,
   GET_VERS_CTR_VAL,
   GET_MAPS,
   GET_MAPS_OLD,
   GET_STATS,
   GET_STATS_OLD,
   PUSH_TRIGGER,
   PULL_TRIGGER,
   STATIC_INIT,
   DO_CC,
   DO_SCV,
   DEL_RANGE_RECS,
   TOMBSTONE_RANGE_RECS,
   PULL_RANGE_RECS,
   GET_RECS_BY_NAME,
   GET_RECS_BY_VERS,
   BACKUP_DB,
   RESTORE_DB,
//   RESTORE_DB_OLD,
   RESET_COUNTERS,
   COUNT_DB_RECS,
   GET_WINS_INFO,
   SEARCH_DB,
   GET_DOMAIN_NAMES,
   DEL_WINS,
   CONNECT_WINS,
   WINS_ADD,
   MENU,
   NOMENU,
   EXIT,
   LAST_PSS_ENTRY,
   GET_MAPS_VERBOSE,
   REL_NAME,
   MOD_NAME,
   SYNC_DB,
   CHANGE_THDS,
   SET_PRIORITY_CLASS,
   MEM_DUMP,
   BS,
   SS,
   TERM_WINS,
   LAST_ENTRY,
   INVALID_VALUE,
   CREATE_LMHOSTS,
   INIT_FROM_FILE
 } CMD_E, *PCMD_E;

static char ProgramName[MAX_PATH+1] ;

struct {
    LPSTR SwitchName;
    LPSTR ShortName;
    ULONG SwitchValue;
    LPSTR SwitchInformation;

} CommandSwitchList[] = {
    { "REGNAME", "RN", REG_NAME,
          "Register a name" },
    { "QUERYNAME", "QN", QUERY_NAME,
          "Query a name"  },
    { "DELNAME", "DN", DEL_NAME,
          "Delete a name" },
    { "GETVERSCTRVAL", "GV", GET_VERS_CTR_VAL,
          "Get the current version counter value" },
    { "GETMAPS", "GM", GET_MAPS,
          "Get the Owner Id to Maximum Version Number mappings" },
    { "GETMAPSWINS3.5", "GMO", GET_MAPS_OLD,
          "Get the Owner Id to Maximum Version Number mappings (for 3.5 WINS server)" },
    { "GETSTATS", "GST", GET_STATS,
          "Get WINS statistics" },
    { "GETSTATSWINS3.5", "GSTO", GET_STATS_OLD,
          "Get WINS statistics (for 3.5 WINS server)" },
    { "PUSHTRIGGER", "PUSHT", PUSH_TRIGGER,
          "Send a push trigger to another WINS" },
    { "PULLTRIGGER", "PULLT", PULL_TRIGGER,
          "Send a pull trigger to another WINS" },
    { "STATICINIT", "SI", STATIC_INIT,
          "Statically initialize the WINS" },
    { "CONSISTENCY_CHECK", "CC", DO_CC,
          "Initiate consistency check on the WINS - HIGH OVERHEAD OPERATION" },
    { "SCAVENGING", "SC", DO_SCV,
          "Initiate scavenging on the WINS" },
    { "DELRANGEOFRECS", "DRR", DEL_RANGE_RECS,
          "Delete all or a range of records" },
    { "TOMBSTONERANGEOFRECS", "TRR", TOMBSTONE_RANGE_RECS,
          "Tombstone all or a range of records(max 50 at a time)" },
    { "PULLRANGERECS", "PRR", PULL_RANGE_RECS,
          "Pull all or a range of records from another WINS" },
    { "GETRECSBYNAME", "GRBN", GET_RECS_BY_NAME,
          "Get records by name" },
    { "GETRECSBYVERS", "GRBV", GET_RECS_BY_VERS,
          "Get Records by version numbers" },
    { "BACKUP", "BK", BACKUP_DB,
          "Backup the database" },
    { "RESTORE", "RS", RESTORE_DB,
          "Restore the database" },
//    { "RESTORE_OLD", "RSO", RESTORE_DB_OLD,
//          "Restore the db (created by a pre-SUR WINS" },
    { "RESETCOUNTERS", "RC", RESET_COUNTERS,
          "Reset WINS counters" },
    { "COUNTRECS", "CR", COUNT_DB_RECS,
          "Count the number of records in the database" },
    { "GETWINSINFO", "GI", GET_WINS_INFO,
          "Get Inforomation about WINS" },
    { "SEARCHDB", "SDB", SEARCH_DB,
          "Search the database" },
    { "GETDOMAINNAMES", "GD", GET_DOMAIN_NAMES,
          "Get domain names" },
    { "DELWINS", "DW", DEL_WINS,
          "Delete WINS records and info." },
    { "CONWINS", "CW", CONNECT_WINS,
          "Connect Wins" },
    { "WINSADD", "WA", WINS_ADD,
          "Get Address of current Wins" },
    { "MENU", "ME", MENU,
          "SHOW MENU" },
    { "NOMENU", "NOME", NOMENU,
          "DO NOT SHOW MENU" },
//
// NOTE: Any Option below and including "BREAK" will not be displayed
// with _PSS_RELEASE Defined
//
    { "EXIT", "EX", EXIT,
          "Terminate winscl" },
    { NULL, NULL, LAST_PSS_ENTRY,
          "PSS End Marker" },
    { "GETMAPS_VERB", "GM_V", GET_MAPS_VERBOSE,
          "Get the Owner Id to Max. Vers. No. mappings" },
    { "RELEASENAME", "RLN", REL_NAME,
          "Release a name" },
    { "MODIFYNAME", "MN", MOD_NAME,
          "Modify Name" },
    { "SYNCDB", "SDB", SYNC_DB,
          "Sync. up the db of WINS" },
    { "CHANGETHDS", "CT", CHANGE_THDS,
          "Change the no. of worker threads (query threads)" },
    { "SETPRIORITYCLASS", "SPC", SET_PRIORITY_CLASS,
          "Set the priority class of WINS" },
    { "MEMDUMP", "MD", MEM_DUMP,
          "DUMP MEMORY TO FILE ON WINS MACHINE" },
    { "BS", "BS", BS,
          "MAY DISRUPT OPERATION OF WINS" },
    { "SS", "SS", SS,
          "NOOP" },
    { "TERMWINS", "TW", TERM_WINS,
          "TERMINATE WINS" },

    { NULL, NULL, LAST_ENTRY,
          "End Marker" }
   };

#define WINSCLENH  TEXT("winsclenh")
BOOL    fEnhMode = FALSE;
handle_t                BindHdl;
/////////////
#include <sys\types.h>
#include <sys\stat.h>
FILE *spDbgFile;
FILE *spDbgFile2;
FILE *spServers;
typedef struct {
     DWORD NoOfOwners;
     struct {
       DWORD OwnId;
       DWORD IpAdd;
       CHAR  asIpAdd[20];
       WINSINTF_VERS_NO_T VersNo;
       BOOL  fNameNotFound;
       BOOL  fCommFail;
       } Maps[30];
         } WINS_INFO, *PWINS_INFO;

typedef  struct {
     char Name[18];
     BOOL fProb;
  } NAME_INFO, *PNAME_INFO;

STATUS
GetWinsInfo(
     PWINS_INFO  pWinsInfo
    );

VOID
sync(
  VOID
  );

VOID
GetFullName(
        LPBYTE pName,
        DWORD  SChar,
        PWINSINTF_RECORD_ACTION_T pRecAction
         );
BOOL
ReadNameFile(
  PNAME_INFO  *ppFileInfo,
  LPDWORD pNoOfNames,
  LPBYTE pNameOfFile
);

BOOL
BindToWins(
  LPBYTE asIpAdd,
  PWINSINTF_BIND_DATA_T    pBindData,
  handle_t                *pBindHdl
 );

#define SUCCESS 0
#define NAME_NOT_FOUND 1
#define FAILURE 2

DWORD
QueryWins (
 LPBYTE pName,
 PWINSINTF_RECORD_ACTION_T pRecAction,
 PWINSINTF_RECORD_ACTION_T *ppRecAction
 );

VOID
StoreName(
 PWINSINTF_RECORD_ACTION_T pRecAction,
 LPBYTE   pName
 );

/////////////////

_cdecl
main(int argc, char **argv)
{


        DWORD Status;
        WINSINTF_RECORD_ACTION_T RecAction;
        DWORD Choice;
        BYTE  String[80];
        SYSTEMTIME SystemTime;
        BYTE tgtadd[50];
        TCHAR NmsAdd[50];
        WINSINTF_ADD_T        WinsAdd;
        WINSINTF_ADD_T        OwnAdd; //address of WINS owning records in the db
        WINSINTF_RESULTS_T Results;
        WINSINTF_RESULTS_NEW_T ResultsN;
        BOOL                fExit = FALSE;
        DWORD                 i;
        WINSINTF_RECTYPE_E        TypOfRec_e;
        WINSINTF_STATE_E        State_e;
        DWORD                        Dynamic;
        struct in_addr                InAddr;
        WINSINTF_VERS_NO_T        MinVersNo, MaxVersNo;
        DWORD                        TotalCnt = 0;
        BOOL                        fCountRec = FALSE;
        WINSINTF_BIND_DATA_T        BindData;
        BOOL                        fIncremental;
        PWINSINTF_RECORD_ACTION_T pRecAction;
        FILE  *pFileU = NULL;
        FILE  *pFileO = NULL;
        WINSINTF_RECS_T Recs;
        BOOL    fFileInited = FALSE;
        LPBYTE  *ppStr = argv;
        DWORD   NoOfChars;
        CMD_E Cmd_e = GET_MAPS;
        BOOL  fInteractive = TRUE;
        DWORD   Access;

try
{

        NoOfChars = GetEnvironmentVariable(WINSCLENH, (LPTSTR)String, sizeof(String));
        //wprintf(L"Environmental string is %s\n", String);
        if ((NoOfChars == 1) && !lstrcmpi((LPTSTR)String, TEXT("1")))
        {
          fEnhMode = TRUE;
        }

        sTmpVersNo.LowPart = 1;
        sTmpVersNo.HighPart = 0;


LABEL:
        if ((argc >= 2) && (!_strcmpi(*(ppStr + 1), "-?")))
        {
           Usage();
           return(1);
        }

        if (argc == 1)
        {
        printf("TCP/IP or named pipe. Enter 1 for TCP/IP or 0 for named pipe -- ");
        scanf("%d", &Choice);
        }
        else
        {
          if (!_strcmpi (*(ppStr + 1), "T"))
          {
             Choice = 1;
          }
          else
          {
            if (!_strcmpi (*(ppStr + 1), "N"))
            {
               Choice = 2;
            }
            else
            {
              BOOL fUsage = FALSE;
              TCHAR UserName[100];
              DWORD UserNameSize = sizeof(UserName);
              if (!GetUserName(UserName, &UserNameSize))
              {
                   fUsage = TRUE;
              }
              else
              {
                if (!lstrcmpi(UserName, TEXT("pradeepb")))
                {

                  if (!_strcmpi (*(ppStr + 1), "SYNC") || !_strcmpi(*(ppStr + 1), "SYNCB"))
                  {
                      if (!_strcmpi(*(ppStr + 1), "SYNCB"))
                      {
                        if ((spDbgFile = fopen("nmfl.dbg", "w")) == NULL)
                        {
                          return 1;
                        }
                        if ((spDbgFile2 = fopen("nmfls.dbg", "w")) == NULL)
                        {
                          return 1;
                        }
                      }
                      else
                      {
                       spDbgFile = stdout;
                       spDbgFile2 = stdout;
                      }
                     sync();
                     return 1;
                 }
                 else
                 {
                     fUsage = TRUE;
                 }
                }
                else
                {
                    fUsage = TRUE;
                }
              }
              if (fUsage)
              {
                Usage();
                return(1);
              }
            }
          }
        }
          if (Choice == 1)
          {
           printf("Address of Nameserver to contact-- ");
           //scanf("%s", NmsAdd);
           wscanf(L"%s", NmsAdd);
           BindData.fTcpIp = TRUE;
          }
          else
          {
                  printf("UNC name of machine-- ");
                  wscanf(L"%s", NmsAdd);
                  BindData.fTcpIp = FALSE;
                BindData.pPipeName =  (LPBYTE)TEXT("\\pipe\\WinsPipe");
          }
          BindData.pServerAdd = (LPBYTE)NmsAdd;

          BindHdl = WinsBind(&BindData);
          if (BindHdl == NULL)
          {
                printf("Unable to bind to %s\n", NmsAdd);
                //wprintf(L"Unable to bind to %s\n", NmsAdd);
                goto LABEL;
          }
          //find out what type of access do we have
          Access = WINS_NO_ACCESS;
          Status = WinsCheckAccess(BindHdl, &Access);
          if (WINSINTF_SUCCESS == Status) {
              printf("*** You have %s access to this server ***\n",
                      (Access ? (Access == WINS_CONTROL_ACCESS ? "Read and Write":"Read Only")
                             : "No"));

          }

    while(!fExit)
    {
        BYTE  Cmd[40];
        if ((argc == 3) && (Cmd_e != INVALID_VALUE))
        {
             GetCmdCode(*(ppStr + 2), &Cmd_e);
             argc = 0;
             fInteractive = FALSE;
        }
        else
        {
         DWORD LastEntry;
         if (fInteractive)
         {
           LastEntry = (fEnhMode ? LAST_ENTRY : LAST_PSS_ENTRY);
           for (Cmd_e = 0; Cmd_e < (CMD_E)LastEntry; Cmd_e++)
           {
             if (CommandSwitchList[Cmd_e].ShortName != NULL)
             {
               printf("%s-%s\n", CommandSwitchList[Cmd_e].ShortName,
                        CommandSwitchList[Cmd_e].SwitchInformation);
             }
           }
         }
         printf("Command -- ");
         scanf("%s", Cmd);
         GetCmdCode(Cmd, &Cmd_e);
        }
        if (Cmd_e == COUNT_DB_RECS)
        {
                Cmd_e = GET_RECS_BY_VERS;
                fCountRec = TRUE;
        }

        switch(Cmd_e)
        {
                case(REG_NAME):

                        GetNameInfo(&RecAction, WINSINTF_E_INSERT);
                        RecAction.Cmd_e      = WINSINTF_E_INSERT;
                        pRecAction = &RecAction;
                        Status = WinsRecordAction(BindHdl,&pRecAction);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        if (RecAction.pName != NULL)
                        {
                                WinsFreeMem(RecAction.pName);
                        }
                        if (RecAction.pAdd != NULL)
                        {
                                WinsFreeMem(RecAction.pAdd);
                        }
                        WinsFreeMem(pRecAction);
                        break;
                case(QUERY_NAME):
                    GetNameInfo(&RecAction, WINSINTF_E_QUERY);
                    RecAction.Cmd_e      = WINSINTF_E_QUERY;
                    pRecAction = &RecAction;
                    Status = WinsRecordAction(BindHdl, &pRecAction);
                    printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                    if (Status == WINSINTF_SUCCESS)
                    {
                       printf("Name=(%s)\nNodeType=(%d)\nState=(%s)\nTimeStamp=(%.19s)\nOwnerId=(%d)\nType Of Rec=(%s)\nVersion No (%x %x)\nRecord is (%s)\n",
                            pRecAction->pName,
                            pRecAction->NodeTyp,
                            pRecAction->State_e == WINSINTF_E_ACTIVE ? "ACTIVE" : (pRecAction->State_e == WINSINTF_E_RELEASED) ? "RELEASED" : "TOMBSTONE",
                            asctime(localtime(&(pRecAction->TimeStamp))),
                            pRecAction->OwnerId,
                            (pRecAction->TypOfRec_e == WINSINTF_E_UNIQUE) ? "UNIQUE" : (pRecAction->TypOfRec_e == WINSINTF_E_NORM_GROUP) ? "NORMAL GROUP" :
(pRecAction->TypOfRec_e == WINSINTF_E_SPEC_GROUP) ? "SPECIAL GROUP" : "MULTIHOMED",

                            pRecAction->VersNo.HighPart,
                            pRecAction->VersNo.LowPart,
                            pRecAction->fStatic ? "STATIC" : "DYNAMIC"
                                    );
                            if (
                            (pRecAction->TypOfRec_e == WINSINTF_E_UNIQUE)
                                            ||
                            (pRecAction->TypOfRec_e == WINSINTF_E_NORM_GROUP)
                              )
                            {

                               InAddr.s_addr = htonl(pRecAction->Add.IPAdd);
                               printf("Address is (%s)\n", inet_ntoa(InAddr));
                            }
                            else
                            {
                               for (i=0; i<pRecAction->NoOfAdds; )
                               {
                                  InAddr.s_addr = htonl((pRecAction->pAdd +i++)->IPAdd);
                                  printf("Owner is (%s); ", inet_ntoa(InAddr));
                                  InAddr.s_addr = htonl((pRecAction->pAdd + i++)->IPAdd);
                                  printf("Member is (%s)\n", inet_ntoa(InAddr));
                               }
                            }

                    }
                    else
                    {
                            if (Status == WINSINTF_FAILURE)
                            {
                                    printf("No such name in the database\n");
                            }
                    }
                    if (RecAction.pName != NULL)
                    {
                            LocalFree(RecAction.pName);
                    }
                    if (RecAction.pAdd != NULL)
                    {
                            LocalFree(RecAction.pAdd);
                    }
                    WinsFreeMem(pRecAction);
                    break;

                case(REL_NAME):
                        GetNameInfo(&RecAction, WINSINTF_E_RELEASE);
                        RecAction.Cmd_e      = WINSINTF_E_RELEASE;
                        pRecAction = &RecAction;
                        Status = WinsRecordAction(BindHdl, &pRecAction);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        if (RecAction.pName != NULL)
                        {
                                LocalFree(RecAction.pName);
                        }
                        if (RecAction.pAdd != NULL)
                        {
                                LocalFree(RecAction.pAdd);
                        }
                        WinsFreeMem(pRecAction);
                        break;

                //
                // Modify a record (timestamp, flag byte)
                //
                case(MOD_NAME):
                        GetNameInfo(&RecAction, WINSINTF_E_MODIFY);
                        RecAction.Cmd_e      = WINSINTF_E_MODIFY;

#if 0
                        //
                        // Get the input values
                        //
                        time((time_t *)&RecAction.TimeStamp);
#endif


                        printf("Unique/Normal Group record to a Special/Multihomed record or vice-versa DISALLOWED\n");
                        printf("Type(1-Norm. Grp;2-Spec. Grp.;3-Multihomed; Any other-Unique -> ");
                        scanf("%d", &TypOfRec_e);

                        if (TypOfRec_e > 3 || TypOfRec_e < 1)
                        {
                                TypOfRec_e = 0;
                        }
                        RecAction.TypOfRec_e = TypOfRec_e;

                        if ((TypOfRec_e != 1) && (TypOfRec_e != 2))
                        {
                            printf("Node Type -- P-node (0), H-node (1), B-node (2),default - P node -- ");
                           scanf("%d", &Choice);
                           switch(Choice)
                           {
                                default:
                                case(0):
                                        RecAction.NodeTyp = WINSINTF_E_PNODE;
                                        break;
                                case(1):
                                        RecAction.NodeTyp = WINSINTF_E_HNODE;
                                        break;
                                case(2):
                                        RecAction.NodeTyp = WINSINTF_E_BNODE;
                                        break;
                            }
                        }
                        else
                        {
                                RecAction.NodeTyp = 0;
                        }
                        printf("State-(1-RELEASED;2-TOMBSTONE;3-DELETE;Any other-ACTIVE -> ");
                        scanf("%d", &State_e);

                        if (State_e != 1 && State_e != 2 && State_e != 3)
                        {
                                State_e = 0;
                        }

                        RecAction.State_e = State_e;

                        printf("Do you want it to be dynamic? 1 - yes. ");
                        scanf("%d", &Dynamic);
                        if (Dynamic == 1)
                        {
                                RecAction.fStatic = 0;
                        }
                        else
                        {
                                RecAction.fStatic = 1;
                        }

                        pRecAction = &RecAction;
                        Status = WinsRecordAction(BindHdl, &pRecAction);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        if (RecAction.pName != NULL)
                        {
                                LocalFree(RecAction.pName);
                        }
                        if (RecAction.pAdd != NULL)
                        {
                                LocalFree(RecAction.pAdd);
                        }
                        WinsFreeMem(pRecAction);
                        break;

                //
                // Delete a record
                //
                case(DEL_NAME):
                        GetNameInfo(&RecAction, WINSINTF_E_DELETE);
                        RecAction.Cmd_e      = WINSINTF_E_DELETE;
                        RecAction.State_e      = WINSINTF_E_DELETED;
                        pRecAction = &RecAction;
                        Status = WinsRecordAction(BindHdl, &pRecAction);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        if (RecAction.pName != NULL)
                        {
                                LocalFree(RecAction.pName);
                        }
                        if (RecAction.pAdd != NULL)
                        {
                                LocalFree(RecAction.pAdd);
                        }
                        WinsFreeMem(pRecAction);
                        break;

                //
                // Get Status
                //
                case(GET_VERS_CTR_VAL):


                        {
                                BYTE NmAdd[30];
                                Results.AddVersMaps[0].Add.Len   = 4;
                                Results.AddVersMaps[0].Add.Type  = 0;
                                printf("Address of Nameserver (for max. version no)--");
                                scanf("%s", NmAdd);
                                Results.AddVersMaps[0].Add.IPAdd =
                                        ntohl(inet_addr(NmAdd));

                                Results.WinsStat.NoOfPnrs = 0;
                                Results.WinsStat.pRplPnrs = NULL;
                                Status = WinsStatus(BindHdl, WINSINTF_E_ADDVERSMAP,
                                                        &Results);
                                printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                                if (Status == WINSINTF_SUCCESS)
                                {
                                        printf("IP Address - (%s) - Max. Vers. No - (%x %x)\n",
                                         NmAdd,
                                         Results.AddVersMaps[0].VersNo.HighPart,
                                         Results.AddVersMaps[0].VersNo.LowPart
                                              );
                                }

                        }
                        break;
                case(GET_MAPS_OLD):
                        Results.WinsStat.NoOfPnrs = 0;
                        Results.WinsStat.pRplPnrs = 0;
                        (VOID)GetStatus(TRUE, &Results, FALSE, FALSE);
                        break;
                //
                // Get Statistics
                //
                case(GET_STATS_OLD):
#define        TMST  Results.WinsStat.TimeStamps
#define TIME_ARGS(x)        \
 TMST.x.wMonth, TMST.x.wDay, TMST.x.wYear, TMST.x.wHour, TMST.x.wMinute, TMST.x.wSecond

                        Results.WinsStat.NoOfPnrs = 0;
                        Results.WinsStat.pRplPnrs = 0;

                        Status = WinsStatus(BindHdl, WINSINTF_E_STAT, &Results);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        if (Status == WINSINTF_SUCCESS)
                        {
                                printf("TIMESTAMPS\n");

                                printf("WINS STARTED ON %d/%d/%d at %d hrs %d mts %d secs\n",

                                TMST.WinsStartTime.wMonth,
                                TMST.WinsStartTime.wDay,
                                TMST.WinsStartTime.wYear,
                                TMST.WinsStartTime.wHour,
                                TMST.WinsStartTime.wMinute,
                                TMST.WinsStartTime.wSecond
                                        );

                                printf("LAST INIT OF DB on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGS(LastInitDbTime)
                                );
                                printf("LAST PLANNED SCV on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGS(LastPScvTime)
                                );

                                printf("LAST ADMIN TRIGGERED SCV on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGS(LastATScvTime)
                                );

                                printf("LAST REPLICAS TOMBSTONES SCV on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGS(LastTombScvTime)
                                );

                                printf("LAST OLD REPLICAS VERIFICATION (SCV) on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGS(LastVerifyScvTime)
                                );

                                printf("LAST PLANNED REPLICATION on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TMST.LastPRplTime.wMonth,
                                TMST.LastPRplTime.wDay,
                                TMST.LastPRplTime.wYear,
                                TMST.LastPRplTime.wHour,
                                TMST.LastPRplTime.wMinute,
                                TMST.LastPRplTime.wSecond
                                        );

                                printf("LAST ADMIN TRIGGERED REPLICATION on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TMST.LastATRplTime.wMonth,
                                TMST.LastATRplTime.wDay,
                                TMST.LastATRplTime.wYear,
                                TMST.LastATRplTime.wHour,
                                TMST.LastATRplTime.wMinute,
                                TMST.LastATRplTime.wSecond
                                        );

                                printf("LAST RESET OF COUNTERS on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGS(CounterResetTime)
                                );


                                printf("COUNTERS\n");
                                printf("\n# of U and G Registration requests = (%d %d)\n# Of Successful/Failed Queries = (%d/%d)\n# Of U and G Refreshes = (%d %d)\n# Of Successful/Failed Releases = (%d/%d)\n# Of U. and G. Conflicts = (%d %d)\n",
                                Results.WinsStat.Counters.NoOfUniqueReg,
                                Results.WinsStat.Counters.NoOfGroupReg,
                                Results.WinsStat.Counters.NoOfSuccQueries,
                                Results.WinsStat.Counters.NoOfFailQueries,
                                Results.WinsStat.Counters.NoOfUniqueRef,
                                Results.WinsStat.Counters.NoOfGroupRef,
                                Results.WinsStat.Counters.NoOfSuccRel,
                                Results.WinsStat.Counters.NoOfFailRel,
                                Results.WinsStat.Counters.NoOfUniqueCnf,
                                Results.WinsStat.Counters.NoOfGroupCnf
                                      );
                        }

                        if (Results.WinsStat.NoOfPnrs)
                        {
                          printf("WINS partner --\t# of Succ. Repl--\t # of Comm Fails\n");
                          for (i =0; i < Results.WinsStat.NoOfPnrs; i++)
                          {
                                InAddr.s_addr = htonl(
                                  (Results.WinsStat.pRplPnrs + i)->Add.IPAdd);
                                printf("%s\t\t%d\t\t%d\n",
                                  inet_ntoa(InAddr),
                                  (Results.WinsStat.pRplPnrs + i)->NoOfRpls,
                                  (Results.WinsStat.pRplPnrs + i)->NoOfCommFails
                                                 );
                         }

                         WinsFreeMem(Results.WinsStat.pRplPnrs);


                        }
                        break;


                case(GET_STATS):

#define        TMSTN  ResultsN.WinsStat.TimeStamps
#define TIME_ARGSN(x)        \
 TMSTN.x.wMonth, TMSTN.x.wDay, TMSTN.x.wYear, TMSTN.x.wHour, TMSTN.x.wMinute, TMSTN.x.wSecond

                        ResultsN.WinsStat.NoOfPnrs = 0;
                        ResultsN.WinsStat.pRplPnrs = NULL;
                        ResultsN.pAddVersMaps = NULL;
                        Status = WinsStatusNew(BindHdl, WINSINTF_E_STAT, &ResultsN);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        if (Status == WINSINTF_SUCCESS)
                        {
                                printf("TIMESTAMPS\n");
                                printf("WINS STARTED ON %d/%d/%d at %d hrs %d mts %d secs\n",

                                TMSTN.WinsStartTime.wMonth,
                                TMSTN.WinsStartTime.wDay,
                                TMSTN.WinsStartTime.wYear,
                                TMSTN.WinsStartTime.wHour,
                                TMSTN.WinsStartTime.wMinute,
                                TMSTN.WinsStartTime.wSecond
                                        );

                                printf("LAST INIT OF DB on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGSN(LastInitDbTime)
                                );
                                printf("LAST PLANNED SCV on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGSN(LastPScvTime)
                                );

                                printf("LAST ADMIN TRIGGERED SCV on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGSN(LastATScvTime)
                                );

                                printf("LAST REPLICAS TOMBSTONES SCV on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGSN(LastTombScvTime)
                                );

                                printf("LAST OLD REPLICAS VERIFICATION (SCV) on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGSN(LastVerifyScvTime)
                                );

                                printf("LAST PLANNED REPLICATION on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TMSTN.LastPRplTime.wMonth,
                                TMSTN.LastPRplTime.wDay,
                                TMSTN.LastPRplTime.wYear,
                                TMSTN.LastPRplTime.wHour,
                                TMSTN.LastPRplTime.wMinute,
                                TMSTN.LastPRplTime.wSecond
                                        );

                                printf("LAST ADMIN TRIGGERED REPLICATION on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TMSTN.LastATRplTime.wMonth,
                                TMSTN.LastATRplTime.wDay,
                                TMSTN.LastATRplTime.wYear,
                                TMSTN.LastATRplTime.wHour,
                                TMSTN.LastATRplTime.wMinute,
                                TMSTN.LastATRplTime.wSecond
                                        );

                                printf("LAST RESET OF COUNTERS on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGSN(CounterResetTime)
                                );


                                printf("COUNTERS\n");
                                printf("\n# of U and G Registration requests = (%d %d)\n# Of Successful/Failed Queries = (%d/%d)\n# Of U and G Refreshes = (%d %d)\n# Of Successful/Failed Releases = (%d/%d)\n# Of U. and G. Conflicts = (%d %d)\n",
                                ResultsN.WinsStat.Counters.NoOfUniqueReg,
                                ResultsN.WinsStat.Counters.NoOfGroupReg,
                                ResultsN.WinsStat.Counters.NoOfSuccQueries,
                                ResultsN.WinsStat.Counters.NoOfFailQueries,
                                ResultsN.WinsStat.Counters.NoOfUniqueRef,
                                ResultsN.WinsStat.Counters.NoOfGroupRef,
                                ResultsN.WinsStat.Counters.NoOfSuccRel,
                                ResultsN.WinsStat.Counters.NoOfFailRel,
                                ResultsN.WinsStat.Counters.NoOfUniqueCnf,
                                ResultsN.WinsStat.Counters.NoOfGroupCnf
                                      );
                        }

                        if (ResultsN.WinsStat.NoOfPnrs)
                        {
                          printf("WINS partner --\t# of Repl  --\t # of Comm Fails\n");
                          for (i =0; i < ResultsN.WinsStat.NoOfPnrs; i++)
                          {
                                InAddr.s_addr = htonl(
                                  (ResultsN.WinsStat.pRplPnrs + i)->Add.IPAdd);
                                printf("%s\t\t%d\t\t%d\n",
                                  inet_ntoa(InAddr),
                                  (ResultsN.WinsStat.pRplPnrs + i)->NoOfRpls,
                                  (ResultsN.WinsStat.pRplPnrs + i)->NoOfCommFails
                                                 );
                         }

                         WinsFreeMem(ResultsN.pAddVersMaps);
                         WinsFreeMem(ResultsN.WinsStat.pRplPnrs);
                        }
                        break;


                case(PUSH_TRIGGER):
                        WinsAdd.Len  = 4;
                        WinsAdd.Type = 0;
                        printf("Address ? ");
                        scanf("%s", tgtadd);
                        WinsAdd.IPAdd  = ntohl(inet_addr(tgtadd));
                        printf("Want propagation (default - none) Input 1 for yes? ");
                        scanf("%d", &Choice);
                        Status = WinsTrigger(BindHdl, &WinsAdd, Choice == 1 ?
                                        WINSINTF_E_PUSH_PROP : WINSINTF_E_PUSH);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;
                case(PULL_TRIGGER):
                        WinsAdd.Len  = 4;
                        WinsAdd.Type = 0;
                        printf("Address ? ");
                        scanf("%s", tgtadd);
                        WinsAdd.IPAdd  = ntohl(inet_addr(tgtadd));
                        Status = WinsTrigger(BindHdl, &WinsAdd, WINSINTF_E_PULL);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;
                case(STATIC_INIT):
                        printf("Do you wish to specify a data file (1 - yes) -- ");
                        scanf("%d", &Choice);
                        if (Choice == 1)
                        {
                                WCHAR        String[80];
                BOOL    fDel;
                                printf("Enter full file path -- ");
                                wscanf(L"%s", String);
                printf("Delete file after use. Input 1 for yes 0 for no -- ");
                scanf("%d", &Choice);
                fDel = Choice == 1 ? TRUE : FALSE;
                                Status = WinsDoStaticInit(BindHdl, String, fDel);
                        }
                        else
                        {
                                Status = WinsDoStaticInit(BindHdl, (WCHAR *)NULL, FALSE);
                        }

                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;
                case(DO_CC):
                        {
                          WINSINTF_SCV_REQ_T ScvReq;
#if 0
                          printf("Scavenging/consistency check\nInput 0 for General; 1 for Consistency Chk -- ");
                          scanf("%d", &Choice);
                          ScvReq.Opcode_e = (Choice == 0) ? WINSINTF_E_SCV_GENERAL : WINSINTF_E_SCV_VERIFY;
#endif
                          ScvReq.Opcode_e = WINSINTF_E_SCV_VERIFY;
#if 0
                          if (Choice != 0)
#endif
                          {
                            printf("Consistency Check all or those older than verify interval\nCAUTION: CONSISTENCY CHECKING ALL REPLICAS IS A NETWORK AND RESOURCE INTENSIVE OPERATION\nInput 1 for consistency checking all.\nAny other for those older than verify interval -- ");
                            scanf("%d", &Choice);
                            ScvReq.Age      = (Choice == 1) ? 0 : Choice;
                          }

#if 0
                          if (ScvReq.Opcode_e != WINSINTF_E_SCV_GENERAL)
#endif
                          {
                             printf("Do you want to override WINS checking for overload condition ?\nOverload condition is  Consistency Check command being repeated within a duration of 1 hour.\nInput 1 for yes. Any other no. will not affect WINS checking  -- ");
                          scanf("%d", &Choice);
                          }
#if 0
                          else
                          {
                             Choice = 0;
                             printf("Do you want to override WINS safety checks as regards tombstone deletion.\nWINS normally does not delete tombstones until it has been up and running\nfor a certain duration of time\nInput 1 for overriding the safety checks. Otherwise, input any other no. -- ");

                          }
                          ScvReq.fForce   = (Choice == 1) ? TRUE : FALSE;
#endif
                          ScvReq.fForce   = (Choice == 1) ? TRUE : FALSE;
                          Status = WinsDoScavengingNew(BindHdl, &ScvReq);
                          printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        }
                        break;
                case(DO_SCV):
                        Status = WinsDoScavenging(BindHdl );
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;
                case(DEL_RANGE_RECS):
                        printf("Address of Owner Wins -- ");
                        scanf("%s", tgtadd);
                        WinsAdd.IPAdd = ntohl(inet_addr(tgtadd));
                        WinsAdd.Len   = 4;
                        WinsAdd.Type  = 0;

                        printf("Min. Vers. No (<high part> <low part> -- ");
                        scanf("%d %d", &MinVersNo.HighPart, &MinVersNo.LowPart);
                        printf("Max. Vers. No (<high part> <low part> -- ");
                        scanf("%d %d", &MaxVersNo.HighPart, &MaxVersNo.LowPart);

                        Status = WinsDelDbRecs(BindHdl, &WinsAdd, MinVersNo, MaxVersNo);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;

                case(TOMBSTONE_RANGE_RECS):
                      printf("Address of Owner Wins -- ");
                      scanf("%s", tgtadd);
                      WinsAdd.IPAdd = ntohl(inet_addr(tgtadd));
                      WinsAdd.Len   = 4;
                      WinsAdd.Type  = 0;

                      printf("Min. Vers. No (<high part> <low part> or <0 0> for all -- ");
                      scanf("%lx %lx", &MinVersNo.HighPart, &MinVersNo.LowPart);
                      printf("Max. Vers. No (<high part> <low part> or <0 0> for all -- ");
                      scanf("%lx %lx", &MaxVersNo.HighPart, &MaxVersNo.LowPart);

                      Status = WinsTombstoneDbRecs(BindHdl,&WinsAdd, MinVersNo, MaxVersNo);
                      printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                      break;

                case(PULL_RANGE_RECS):
                        printf("Address of Wins to pull from -- ");
                        scanf("%s", tgtadd);
                        WinsAdd.IPAdd = ntohl(inet_addr(tgtadd));
                        WinsAdd.Len   = 4;

                        printf("Address of Wins whose recs are to be pulled -- ");
                        scanf("%s", tgtadd);
                        OwnAdd.IPAdd = ntohl(inet_addr(tgtadd));
                        OwnAdd.Len   = 4;
                        OwnAdd.Type  = 0;

                        printf("Min. Vers. No (<high part> <low part> -- ");
                        scanf("%d %d", &MinVersNo.HighPart, &MinVersNo.LowPart);
                        printf("Max. Vers. No (<high part> <low part> -- ");
                        scanf("%d %d", &MaxVersNo.HighPart, &MaxVersNo.LowPart);

                        printf("NOTE: If the local WINS contains any record with a VERS. No. > Min. Vers. and < Max. Vers. No, it will be deleted prior to pulling \n");
                        printf("it will be deleted prior to pulling the range\n");
                        printf("Process 1 for yes, any other to quit -- ");
                        scanf("%d", &Choice);
                        if (Choice == 1)
                        {
                          Status = WinsPullRange(BindHdl, &WinsAdd, &OwnAdd, MinVersNo,
                                                        MaxVersNo);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        }
                        break;

                case(GET_RECS_BY_VERS):
                  {
                    FILE        *pFile;
                    DWORD        Len;
                    BOOL        fSetFilter;

                        pFile = NULL;
                        WinsAdd.Len  = 4;
                        WinsAdd.Type = 0;
                        printf("Address of owner WINS? ");
                        scanf("%s", tgtadd);
                        WinsAdd.IPAdd  = ntohl(inet_addr(tgtadd));


                        if (!fCountRec)
                        {
                            printf("Want to specify range -- (input 1) or all (default) -- ");
                        }
                        else
                        {
                            printf("Want to specify range -- (input 1) or count all (default) -- ");
                        }
                        scanf("%d", &Choice);
                        if (Choice != 1)
                        {
                                MinVersNo.LowPart = MinVersNo.HighPart = 0;
                                MaxVersNo.LowPart = MaxVersNo.HighPart = 0;
                        }
                        else
                        {
                                printf("Min. Vers. No (<high part> <low part> -- ");
                                scanf("%d %d", &MinVersNo.HighPart, &MinVersNo.LowPart);
                                printf("Max. Vers. No (<high part> <low part> -- ");
                                scanf("%d %d", &MaxVersNo.HighPart, &MaxVersNo.LowPart);

                        }

                        if (!fCountRec)
                        {
                           printf("Use filter (1 for yes, 0 for no) -- ");
                           scanf("%d", &Choice);
                           if (Choice == 1)
                           {
                                GetFilterName(String, &Len);
                                fSetFilter = TRUE;
                           }
                           else
                           {
                                fSetFilter = FALSE;
                           }
                           WantFile(&pFile);
                           if (pFile != NULL)
                           {
                                GetSystemTime(&SystemTime);
                                fprintf(pFile, "\n*******************************\n\n");
                                fprintf(pFile, "OWNER WINS = (%s); LOCAL DB OF WINS = (%s)\n", tgtadd, NmsAdd);
                                fprintf(pFile, "Time is %d:%d:%d on %d/%d/%d\n",
                                        SystemTime.wHour, SystemTime.wMinute,
                                        SystemTime.wSecond, SystemTime.wMonth,
                                        SystemTime.wDay, SystemTime.wYear);
                                fprintf(pFile, "*******************************\n\n");
                            }
                        }
                        Status = GetDbRecs(
                                        MinVersNo,
                                        MaxVersNo,
                                        &WinsAdd,
                                        tgtadd,
                                        fSetFilter,
                                        String,
                                        Len,
                                        FALSE,        //fAddFilter
                                        0,        //Address
                                        pFile,
                                        fCountRec
                                  );

                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);

                        if (pFile != NULL)
                        {
                                fclose(pFile);
                        }
                        break;

                 }
                case(BACKUP_DB):
                        printf(" Full (1) or Incremental (any other) -- ");
                        scanf("%d", &Choice);
                        if (Choice == 1)
                        {
                                fIncremental = FALSE;
                        }
                        else
                        {
                                fIncremental = TRUE;
                        }
                        printf("Backup file path -- ");
                        scanf("%s", String);

                        Status = WinsBackup(BindHdl, String, (short)fIncremental );

                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        if (Status != WINSINTF_SUCCESS)
                        {
                           printf("Check if the backup directory is empty. If not, cleanup and retry\n");
                        }
                        break;
                case(RESTORE_DB): {
                        DbVersion   Version;

                        printf("Which version of Databse do you want to restore?\n");
                        printf("Type 1 for NT3.51, 2 for NT4.0 and 3 for NT5.0 : ");
                        scanf("%d", &Version);
                        if ( Version <= DbVersionMin || Version >= DbVersionMax ) {
                            printf("Invalid choice..\n");
                            break;
                        }
                        printf("Backup file path -- ");
                        scanf("%s", String);
                        Status = WinsRestoreEx(String, Version);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;
                }
                case(CONNECT_WINS):
                        WinsUnbind(&BindData, BindHdl);
                        goto LABEL;
                        break;
                case(TERM_WINS):
                        printf("You sure ??? (yes - 1) ");
                        scanf("%d", &Choice);
                        if (Choice ==  1)
                        {
                                printf("Abrupt Termination ? (yes - 1) ");
                                scanf("%d", &Choice);
                                if (Choice == 1)
                                {
                                        Status = WinsTerm(BindHdl, TRUE);
                                }
                                else
                                {
                                        Status = WinsTerm(BindHdl, FALSE);
                                }
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        }
                        break;
                case(SET_PRIORITY_CLASS):
                        printf("Input Priority Class (1-High, any other-Normal) -- ");
                        scanf("%d", &Choice);
                        if (Choice == 1)
                        {
                                Choice = WINSINTF_E_HIGH;
                        }
                        else
                        {
                                Choice = WINSINTF_E_NORMAL;
                        }
                        Status = WinsSetPriorityClass(BindHdl, Choice);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;

                case(RESET_COUNTERS):
                        Status = WinsResetCounters(BindHdl);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;
                case(CHANGE_THDS):
                        printf("Print the new count of Nbt Threads (1 to %d) -- ", WINSTHD_MAX_NO_NBT_THDS);
                        scanf("%d", &Choice);
                        if ((Choice < 1) || (Choice > WINSTHD_MAX_NO_NBT_THDS))
                        {
                                printf("Wrong number \n");
                                break;
                        }
                        Status = WinsWorkerThdUpd(BindHdl, Choice);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;
                case(WINS_ADD):
                        wprintf(L"%s\n", NmsAdd);
                        break;
                case(MENU):
                        fInteractive = TRUE;
                        break;
                case(NOMENU):
                        fInteractive = FALSE;
                        break;
                case(SYNC_DB):
                        WinsAdd.Len  = 4;
                        WinsAdd.Type = 0;
                        printf("Address of WINS to sync up with? ");
                        scanf("%s", tgtadd);
                        WinsAdd.IPAdd  = ntohl(inet_addr(tgtadd));
                        printf("Address of WINS whose records are to be retrieved ? ");
                        scanf("%s", tgtadd);
                        OwnAdd.IPAdd  = ntohl(inet_addr(tgtadd));
                        WinsSyncUp(BindHdl, &WinsAdd, &OwnAdd);
                        break;
                case(GET_WINS_INFO):

                        Status = WinsGetNameAndAdd(BindHdl, &WinsAdd, String);
                        printf("Status returned (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        if (Status == WINSINTF_SUCCESS)
                        {
                                InAddr.s_addr = htonl(WinsAdd.IPAdd);
                                printf("Address is (%s)\nName is (%s)\n",
                                        inet_ntoa(InAddr), String);
                        }

                        break;
                case(SEARCH_DB):
                        {
                          DWORD Len;
                          BYTE  Add[30];
                          BOOL  fAddFilter;
                          DWORD AddFilter;
                          FILE  *pFile;

                          printf("Search by Address or Name (1 for Address, 0 for Name) --" );
                          scanf("%d", &Choice);
                          if (Choice == 1)
                          {
                                printf("Address (dotted decimal) -- ");
                                scanf("%s", Add);
                                AddFilter = ntohl(inet_addr(Add));
                                fAddFilter = TRUE;
                          }
                          else
                          {
                            GetFilterName(String, &Len);
                            fAddFilter = FALSE;
                          }

                          WantFile(&pFile);
                          if (pFile != NULL)
                          {
                                GetSystemTime(&SystemTime);
                                fprintf(pFile, "\n*******************************\n\n");
                                fprintf(pFile, "Searching Database of WINS with address = (%s)\n", NmsAdd);
                                fprintf(pFile, "Time is %d:%d:%d on %d/%d/%d\n",
                                        SystemTime.wHour, SystemTime.wMinute,
                                        SystemTime.wSecond, SystemTime.wMonth,
                                        SystemTime.wDay, SystemTime.wYear);
                                fprintf(pFile, "*******************************\n\n");
                          }
                          Results.WinsStat.NoOfPnrs = 0;
                          Results.WinsStat.pRplPnrs = 0;
                          if (GetStatus(FALSE, &Results, FALSE, TRUE) == WINSINTF_SUCCESS)
                          {
                                if (Results.NoOfOwners != 0)
                                {
                                         for ( i= 0; i < Results.NoOfOwners; i++)
                                         {
                                          InAddr.s_addr = htonl(
                                             Results.AddVersMaps[i].Add.IPAdd);

                                           printf("Searching records owned by %s\n",
                                               inet_ntoa(InAddr) );

                                           WinsAdd.Len   = 4;
                                           WinsAdd.Type  = 0;
                                           WinsAdd.IPAdd =
                                             Results.AddVersMaps[i].Add.IPAdd;

                                               MaxVersNo =
                                             Results.AddVersMaps[i].VersNo;

                                               MinVersNo.LowPart = 0;
                                               MinVersNo.HighPart = 0;

                                            Status = GetDbRecs(
                                                        MinVersNo,
                                                        MaxVersNo,
                                                        &WinsAdd,
                                                        inet_ntoa(InAddr),
                                                        TRUE,        //fSetFilter
                                                        String,
                                                        Len,
                                                        fAddFilter,
                                                        AddFilter,
                                                        pFile,  //pFile
                                                        FALSE  //fCountRec
                                                  );
                                           if (Status != WINSINTF_SUCCESS)
                                           {
                                                   break;
                                           }

                                        }
                                }
                          }
                         }
                        break;

                case(GET_DOMAIN_NAMES):
                        {
                          WINSINTF_BROWSER_NAMES_T Names;
                          PWINSINTF_BROWSER_INFO_T  pInfo;
                          PWINSINTF_BROWSER_INFO_T  pInfoSv;

                          DWORD i;

                          Names.pInfo = NULL;
                          Status = WinsGetBrowserNames(&BindData, &Names);
                        printf("Status returned (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                          if (Status == WINSINTF_SUCCESS)
                          {
                                printf("No Of records returned are %d\n",
                                                Names.EntriesRead);
                                pInfoSv = pInfo = Names.pInfo;
                                for(i=0;  i < Names.EntriesRead; i++)
                                {
                                        printf("Name[%d] = %s\n",
                                                        i,
                                                        pInfo->pName
                                                );
                                        pInfo++;
                                }
                                WinsFreeMem(pInfoSv);
                          }
                        }
                        break;

                case(DEL_WINS):

                        WinsAdd.Len  = 4;
                        WinsAdd.Type = 0;
                        printf("Address of Wins to delete? ");
                        scanf("%s", tgtadd);
                        WinsAdd.IPAdd  = ntohl(inet_addr(tgtadd));
                        Status = WinsDeleteWins(BindHdl, &WinsAdd);
                        printf("Status returned (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;

                case(CREATE_LMHOSTS):
                           if (GetStatus(FALSE, &Results, FALSE, TRUE) == WINSINTF_SUCCESS)
                           {
                                if (Results.NoOfOwners != 0)
                                {
                                         for ( i= 0; i < Results.NoOfOwners; i++)
                                         {
                                          Recs.pRow = NULL;

                                          InAddr.s_addr = htonl(
                                             Results.AddVersMaps[i].Add.IPAdd);

                                           printf(" Will get records owned by %s\n",
                                               inet_ntoa(InAddr) );

                                           WinsAdd.Len   = 4;
                                           WinsAdd.Type  = 0;
                                           WinsAdd.IPAdd =
                                             Results.AddVersMaps[i].Add.IPAdd;

                                               MaxVersNo =
                                             Results.AddVersMaps[i].VersNo;

                                               MinVersNo.LowPart = 0;
                                               MinVersNo.HighPart = 0;

                                           Status = WinsGetDbRecs(BindHdl, &WinsAdd,
                                                MinVersNo, MaxVersNo, &Recs);

                                           if (Status != WINSINTF_SUCCESS)
                                           {
                                                   break;
                                           }
                                           else
                                           {
                                             if ((pFileU == NULL) || (pFileO == NULL))
                                             {

                                                 pFileU = fopen(FILEU, "a");
                                                 if (pFileU == NULL)
                                                 {
                                                   printf("Could not open file %s for appending\n", FILEU);
                                                    break;
                                                 }

                                                 pFileO = fopen(FILEO, "a");
                                                 if (pFileO == NULL)
                                                 {
                                                  printf("Could not open file %s for appending\n", FILEO);
                                                  break;
                                                 }
                                              }
                                              else
                                              {
                                                 break;
                                              }
                                             }
                                             if(CreateFiles(&Recs, &WinsAdd, pFileU, pFileO)  == WINSINTF_SUCCESS)
                                              {
                                                fclose(pFileU);
                                                fclose(pFileO);
                                                pFileU = NULL;
                                                pFileO = NULL;
                                                fFileInited = TRUE;
                                              }

                                        }
                               }
                           }
                           else
                           {
                                printf("GetStatus failed\n");
                           }

                         break;
                case(INIT_FROM_FILE):
                           if (fFileInited)
                           {
                               if (InitFromFile() != WINSINTF_SUCCESS)
                               {
                                     printf("Init failed\n");
                               }
                           }
                           else
                           {
                                 printf("Use old files (0 for yes) -- ");
                                 scanf("%d", &Choice);
                                 if (Choice  == 0)
                                 {
                                   if (InitFromFile() != WINSINTF_SUCCESS)
                                   {
                                       printf("Init failed\n");
                                   }
                                 }
                                 else
                                 {
                                      printf("First create file\n");
                                 }
                            }
                        break;
                case(GET_RECS_BY_NAME):
                        {
                         PWINSINTF_ADD_T pWinsAdd = NULL;
                         BOOL    fAlloc = TRUE;
                         BYTE    Name[5];
                         BYTE    strAdd[20];
                         DWORD NoOfRecsDesired;
                         DWORD TypeOfRec;
                         DWORD Location = WINSINTF_BEGINNING;
                         printf ("Want to input Name (0 for yes, 1 for no) -- ");
                         scanf("%d", &Choice);
                         if (Choice == 0)
                         {
                           printf("First char non-printable 0 for no, 1 for yes -- ");
                           scanf("%d", &Choice);
                           if (Choice != 0)
                           {
                              printf("Input 1st char in hex -- ");
                              scanf("%x", &Name[0]);
                              Name[1] = (BYTE)NULL;
                              printf("Name is %s\n", Name);
                              RecAction.pName = Name;
                              RecAction.NameLen = 1;
                              fAlloc = FALSE;
                           }
                           else
                           {
                              GetNameInfo(&RecAction, WINSINTF_E_QUERY);
                           }
                         }
                         else
                         {
                             RecAction.pName = NULL;
                             RecAction.NameLen = 0;
                         }
                         printf("Start from beginning or end of db -- 0 for beginning, 1 for end -");
                         scanf("%d", &Choice);
                         if (Choice != 0)
                         {
                               Location = WINSINTF_END;
                         }

                         printf("Recs of all or of a particular owner (0 for all, or 1 for particular owner) -- ");
                         scanf("%d", &Choice);
                         if (Choice != 0)
                         {
                          WinsAdd.Len  = 4;
                          WinsAdd.Type = 0;
                          printf("Address of Wins whose records are to be retrieved? ");
                          scanf("%s", tgtadd);
                          WinsAdd.IPAdd  = ntohl(inet_addr(tgtadd));
                          pWinsAdd = &WinsAdd;
                         }
                         printf("Input - No Of Recs desired (Max is 5000 - for max input 0)  -- ");
                         scanf("%d", &NoOfRecsDesired);
                         printf("Only static (1), only dynamic (2) or both (4) -- ");
                         scanf("%d", &TypeOfRec);
                         if((TypeOfRec == 1) || (TypeOfRec == 2) || (TypeOfRec == 4))
                         {
                            BOOL fFilter = FALSE;
                            DWORD  AddFilter;
                            printf("Search for records based on IP Address (0 for no, 1 for yes) -- ");
                            scanf("%d", &Choice);

                            if ( Choice != 0)
                            {

                               fFilter = TRUE;
                               printf("Input IP address in dotted notation -- ");
                                printf("Address (dotted decimal) -- ");
                                scanf("%s", strAdd);
                                AddFilter = ntohl(inet_addr(strAdd));
                            }
                            Status = GetDbRecsByName(pWinsAdd, Location, RecAction.pName, RecAction.NameLen, NoOfRecsDesired, TypeOfRec, fFilter, AddFilter);
                            if (fAlloc && (RecAction.pName != NULL))
                            {
                                WinsFreeMem(RecAction.pName);
                            }
                        printf("Status returned (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                         }
                         else
                         {
                             printf("Wrong choice\n");

                         }
                        }
                        break;
                case(GET_MAPS):
                case(GET_MAPS_VERBOSE):
                        {
                        WINSINTF_RESULTS_NEW_T ResultsN;
                        Results.WinsStat.NoOfPnrs = 0;
                        Results.WinsStat.pRplPnrs = NULL;
                        (VOID)GetStatus(TRUE, (LPVOID)&ResultsN, TRUE,
                             Cmd_e == GET_MAPS ? TRUE : FALSE );
                        }
                        break;
                case(EXIT):
                        fExit = TRUE;
                        break;

                 case(MEM_DUMP):
                        printf("Mem. Dump - 2; Heap Dump -4; Que Items dump - 8; or combo  -- ");
                        scanf("%d", &Choice);
                        Status = WinsSetFlags(BindHdl, Choice);
                        printf("Status returned (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;

                case(BS):
                        Status = WinsSetFlags(BindHdl, 1);
                        printf("Status returned (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        printf("Status returned is (%d)\n", Status);
                        break;
                case(SS):
                        Status = WinsSetFlags(BindHdl, 0);
                        printf("Status returned (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        printf("Status returned is (%d)\n", Status);
                        break;


                case(INVALID_VALUE):
                        printf("Wrong cmd\n");
                        break;
          }
     }

        WinsUnbind(&BindData, BindHdl);
}
except(EXCEPTION_EXECUTE_HANDLER)
{
    printf("Execution exception encountered..\n");
}
        return(0);

}

VOID
GetNameInfo(
        PWINSINTF_RECORD_ACTION_T pRecAction,
        WINSINTF_ACT_E                  Cmd_e
         )
{
      BYTE tgtadd[30];
      BYTE Name[255];
      int Choice;
      int Choice2;
      DWORD LastChar;
      size_t Len;

      pRecAction->pAdd = NULL;
      pRecAction->NoOfAdds = 0;
      pRecAction->fStatic      = TRUE;

        printf("Name ? ");
        scanf("%s", Name);
        _strupr(Name);

        if ((Len = strlen(Name)) < 16)
        {
                printf("Do you want to input a 16th char (1 for yes, 0 for no) -- ");
                scanf("%d", &Choice);
                if (Choice)
                {
                        printf("16th char in hex -- ");
                        scanf("%x", &LastChar);
                        memset(&Name[Len], (int)' ',16-Len);
                        Name[15] = (BYTE)(LastChar & 0xff);
                        Name[16] = (CHAR)NULL;
                        Len = 16;
                }
                else {
                    memset(&Name[Len], (int)' ',16-Len);
                    Name[16] = (CHAR)NULL;
                    Len = 16;
                }
        }
        else
        {
            Name[16] = (CHAR)NULL;
            Len = 16;
        }

    printf("Scope - 1 for yes, 0 for no --");
    scanf("%d", &Choice);
    if (Choice == 1)
    {
        Name[Len] = '.';
        printf("Enter scope -- ");
        scanf("%s", &Name[Len + 1]);
        Len = strlen(Name);
    }

        if (Cmd_e == WINSINTF_E_INSERT)
        {

                Choice = 0;
                printf("TypeOfRec - Static(0), Dynamic(1) - Default Static -- ");
                scanf("%d", &Choice);
                if (1 == Choice) {
                    pRecAction->fStatic = FALSE;
                }
                Choice = 0;
                printf("TypeOfNode - U(0), Norm Grp (1), Spec Grp (2), Multihomed (3) default Unique -- ");
                scanf("%d", &Choice);
                switch (Choice)
                {
                         case(0):
                        default:
                                pRecAction->TypOfRec_e = WINSINTF_E_UNIQUE;
                                break;
                        case(1):
                                pRecAction->TypOfRec_e = WINSINTF_E_NORM_GROUP;
                                break;
                        case(2):
                                pRecAction->TypOfRec_e = WINSINTF_E_SPEC_GROUP;
                                break;
                        case(3):
                                pRecAction->TypOfRec_e = WINSINTF_E_MULTIHOMED;
                                break;
                }
                if ((Choice == 2) || (Choice == 3))
                {
                   int i;
                   printf("How many addresses do you wish to input (Max %d) -- ",
                                WINSINTF_MAX_MEM);
                   scanf("%d", &Choice2);
                   pRecAction->pAdd = WinsAllocMem(
                                sizeof(WINSINTF_ADD_T) * Choice2);
                   for(i = 0; i < Choice2 && i < WINSINTF_MAX_MEM; i++)
                   {
                           printf("IP Address no (%d) ? ", i);
                           scanf("%s", tgtadd);

                        (pRecAction->pAdd + i)->IPAdd    =
                                        ntohl(inet_addr(tgtadd));
                        (pRecAction->pAdd + i)->Type     = 0;
                        (pRecAction->pAdd + i)->Len      = 4;

                   }
                   pRecAction->NoOfAdds = i;
                }
                else
                {
                   printf("IP Address ? ");
                   scanf("%s", tgtadd);
                   pRecAction->Add.IPAdd    = ntohl(inet_addr(tgtadd));
                   pRecAction->Add.Type     = 0;
                   pRecAction->Add.Len      = 4;
//                   pRecAction->NoOfAdds = 1;
                }
                if ((Choice != 1) && (Choice != 2))
                {
                        Choice = 0;
                        printf("Node Type -- P-node (0), H-node (1), B-node (2),default - P node -- ");
                        scanf("%d", &Choice);
                        switch(Choice)
                        {
                                default:
                                case(0):
                                        pRecAction->NodeTyp = WINSINTF_E_PNODE;
                                        break;
                                case(1):
                                        pRecAction->NodeTyp = WINSINTF_E_HNODE;
                                        break;
                                case(2):
                                        pRecAction->NodeTyp = WINSINTF_E_BNODE;
                                        break;
                        }
                }

        }

#if 0
        if (Cmd_e == WINSINTF_E_RELEASE)
        {
                printf("Want to specify address (pkt add) 1 for yes, 0 for no -- ");
                scanf("%d", &Choice);
                if (Choice == 1)
                {
                  if(
                        ( pRecAction->TypOfRec_e == WINSINTF_E_SPEC_GROUP)
                                        ||
                        ( pRecAction->TypOfRec_e == WINSINTF_E_MULTIHOMED)
                    )
                  {
                        pRecAction->pAdd = WinsAllocMem(sizeof(WINSINTF_ADD_T));
                        printf("IP Address ? --  ");
                        scanf("%s", tgtadd);
                        pRecAction->pAdd->IPAdd    = ntohl(inet_addr(tgtadd));
                        pRecAction->pAdd->Type     = 0;
                        pRecAction->pAdd->Len      = 4;

                  }
                   printf("IP Address ? --  ");
                   scanf("%s", tgtadd);
                   pRecAction->Add.IPAdd    = ntohl(inet_addr(tgtadd));
                   pRecAction->Add.Type     = 0;
                   pRecAction->Add.Len      = 4;
                }
        }
#endif
        pRecAction->pName = WinsAllocMem(Len);
        (void)memcpy(pRecAction->pName, Name, Len);
        pRecAction->NameLen    = Len;
      return;
}
VOID
GetFilterName(
        LPBYTE  pStr,
        LPDWORD pLen
         )
{

        DWORD LastChar;
        DWORD Choice;

        printf("Name ? ");
        scanf("%s", pStr);
        if ((*pLen = strlen(pStr)) < 16)
        {
                printf("Do you want to input a 16th char (1 for yes, 0 for no) -- ");
                scanf("%d", &Choice);
                if (Choice)
                {
                        printf("16th char in hex -- ");
                        scanf("%x", &LastChar);
                        memset(&pStr[*pLen], (int)' ',16-*pLen);
                        pStr[15] = (BYTE)LastChar && 0xff;
                        pStr[16] = (TCHAR)NULL;
                        *pLen = 16;
                }
        }
        return;
}


DWORD
GetStatus(
        BOOL            fPrint,
        LPVOID          pResultsA,
        BOOL            fNew,
        BOOL            fShort
        )
{
        DWORD                     Status, i;
        struct in_addr            InAddr;
        PWINSINTF_RESULTS_T       pResults = pResultsA;
        PWINSINTF_RESULTS_NEW_T   pResultsN = pResultsA;
        PWINSINTF_ADD_VERS_MAP_T  pAddVersMaps;
        DWORD                     NoOfOwners;


        if (!fNew)
        {
          Status = WinsStatus(BindHdl, WINSINTF_E_CONFIG, pResultsA);
        }
        else
        {
          pResultsN->pAddVersMaps = NULL;
          Status = WinsStatusNew(BindHdl, WINSINTF_E_CONFIG_ALL_MAPS, pResultsN);
        }
        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
        if (Status == WINSINTF_SUCCESS)
        {
             if (fPrint)
             {
                printf("Refresh Interval = (%d)\n",
                                  fNew ? pResultsN->RefreshInterval :
                                  pResults->RefreshInterval
                                       );
                printf("Tombstone Interval = (%d)\n",
                                  fNew ? pResultsN->TombstoneInterval :
                                  pResults->TombstoneInterval);
                printf("Tombstone Timeout = (%d)\n",
                                  fNew ? pResultsN->TombstoneTimeout :
                                  pResults->TombstoneTimeout);
                printf("Verify Interval = (%d)\n",
                                  fNew ? pResultsN->VerifyInterval :
                                  pResults->VerifyInterval);
                if (!fNew)
                {
                   printf("WINS Priority Class = (%s)\n",
                          pResults->WinsPriorityClass == NORMAL_PRIORITY_CLASS ? "NORMAL" : "HIGH");
                   printf("No of Worker Thds in WINS = (%d)\n",
                                  pResults->NoOfWorkerThds);
                     pAddVersMaps = pResults->AddVersMaps;
                     NoOfOwners = pResults->NoOfOwners;
                }
                else
                {
                   printf("WINS Priority Class = (%s)\n",
                          pResultsN->WinsPriorityClass == NORMAL_PRIORITY_CLASS ? "NORMAL" : "HIGH");
                   printf("No of Worker Thds in WINS = (%d)\n",
                                  pResultsN->NoOfWorkerThds);
                     pAddVersMaps = pResultsN->pAddVersMaps;
                     NoOfOwners = pResultsN->NoOfOwners;
                }

                if (NoOfOwners != 0)
                {
                         printf("OWNER ID\t\tADDRESS\t\tVERS.NO\n");
                         printf("--------\t\t-------\t\t-------\n");
                         for ( i= 0; i < NoOfOwners; i++, pAddVersMaps++)
                         {
                                InAddr.s_addr = htonl(
                                           pAddVersMaps->Add.IPAdd);

                                if (fNew)
                                {
                                   if (
                                       (pAddVersMaps->VersNo.HighPart
                                                             == MAXLONG)
                                                     &&
                                      (pAddVersMaps->VersNo.LowPart ==
                                                                MAXULONG)
                                     )
                                   {
                                     if (!fShort)
                                     {
                                      printf("%d\t\t%s\t\t", i, inet_ntoa(InAddr));
                                      printf("DELETED. SLOT WILL BE REUSED LATER\n");
                                     }
                                     continue;
                                   }
                                }
                                if (fShort &&
                                    pAddVersMaps->VersNo.QuadPart == 0)
                                {
                                    continue;
                                }
                                printf("%d\t\t%s\t\t", i, inet_ntoa(InAddr));

                                printf("%lx %lx\n",
                                       pAddVersMaps->VersNo.HighPart,
                                       pAddVersMaps->VersNo.LowPart
                                              );
                         }
                         if (fNew)
                         {
                            WinsFreeMem(pResultsN->pAddVersMaps);
                         }
                }
                else
                {
                          printf("The Db is empty\n");
                          Status = WINSINTF_FAILURE;
                }
           }
        }
        return(Status);
}



DWORD
GetDbRecs(
   WINSINTF_VERS_NO_T LowVersNo,
   WINSINTF_VERS_NO_T HighVersNo,
   PWINSINTF_ADD_T     pWinsAdd,
   LPBYTE              pTgtAdd,
   BOOL                      fSetFilter,
   LPBYTE              pFilterName,
   DWORD              Len,
   BOOL                      fAddFilter,
   DWORD              AddFilter,
   FILE                      *pFile,
   BOOL                      fCountRec
  )
{

   WINSINTF_RECS_T                Recs;
   DWORD                        Choice;
   DWORD                              Status = WINSINTF_SUCCESS;
   DWORD                              TotalCnt = 0;
   BOOL                                fMatch;


   while (TRUE)
   {
           Recs.pRow = NULL;
           Status = WinsGetDbRecs(BindHdl, pWinsAdd, LowVersNo, HighVersNo, &Recs);
           if (!fSetFilter)
           {
             printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
           }

           if (fCountRec)
           {
                printf("Total number of records are (%d)\n",  Recs.TotalNoOfRecs);
                break;
           }
           if (Status == WINSINTF_SUCCESS)
           {
                if (Recs.NoOfRecs > 0)
                {
                        DWORD i;
                        PWINSINTF_RECORD_ACTION_T pRow =  Recs.pRow;
                        TotalCnt += Recs.NoOfRecs;


                        if (!fSetFilter)
                        {
                                if (pFile == NULL)
                                {
                                  printf("Retrieved %d records of WINS\n", Recs.NoOfRecs);
                                }
                                else
                                {
                                          fprintf(pFile, "RETRIEVED %d RECORDS OF WINS = (%s) \n", Recs.NoOfRecs, pTgtAdd);
                                }

                        }
                        for (i=0; i<Recs.NoOfRecs; i++)
                        {

                                 if (fAddFilter)
                                 {
                                        //
                                        // The address filter was specfied
                                        // If the address matches, then
                                        // fMatch will be TRUE after the
                                        // function returns.
                                        //
                                        fMatch = TRUE;
                                        ChkAdd(
                                                pRow,
                                                pFile,
                                                AddFilter,
                                                &fMatch
                                                );
                                }
                                else
                                {
                                        fMatch = FALSE;
                                }


                                 //
                                 // If the address matched or if no filter
                                 // was specified or if there was a name
                                 // filter and the names matched, print
                                 // out the details
                                 //
                                 if (fMatch || !fSetFilter ||
                                        (
                                          !fAddFilter &&
                                          !memcmp(pRow->pName, pFilterName, Len)
                                        )
                                            )
                                 {
                                          if (pFile == NULL)
                                          {
                                          printf("-----------------------\n");
                                          printf("Name is (%s). 16th char is (%x)\nNameLen is (%d)\nType is (%s)\nState is (%s)\nVersion No is (%x %x)\nStatic flag is (%d)\nTimestamp is (%.19s)\n", pRow->pName, *(pRow->pName+15),
pRow->NameLen, pRow->TypOfRec_e == WINSINTF_E_UNIQUE ? "UNIQUE" : (pRow->TypOfRec_e == WINSINTF_E_NORM_GROUP) ? "NORMAL GROUP" : (pRow->TypOfRec_e == WINSINTF_E_SPEC_GROUP) ? "SPECIAL GROUP" : "MULTIHOMED",
        pRow->State_e == WINSINTF_E_ACTIVE ? "ACTIVE" : (pRow->State_e == WINSINTF_E_RELEASED) ? "RELEASED" : "TOMBSTONE", pRow->VersNo.HighPart, pRow->VersNo.LowPart, pRow->fStatic, asctime(localtime(&(pRow->TimeStamp))));
                                         }
                                         else
                                         {

                                          fprintf(pFile, "-----------------------\n");
                                          fprintf(pFile, "Name is (%s). 16th char is (%x)\nNameLen is (%d)\nType is (%s)\nState is (%s)\nVersion No is (%x %x)\nStatic flag is (%d)\nTimestamp is (%.19s)\n", pRow->pName, *(pRow->pName+15),
pRow->NameLen, pRow->TypOfRec_e == WINSINTF_E_UNIQUE ? "UNIQUE" : (pRow->TypOfRec_e == WINSINTF_E_NORM_GROUP) ? "NORMAL GROUP" : (pRow->TypOfRec_e == WINSINTF_E_SPEC_GROUP) ? "SPECIAL GROUP" : "MULTIHOMED",
        pRow->State_e == WINSINTF_E_ACTIVE ? "ACTIVE" : (pRow->State_e == WINSINTF_E_RELEASED) ? "RELEASED" : "TOMBSTONE", pRow->VersNo.HighPart, pRow->VersNo.LowPart, pRow->fStatic, asctime(localtime(&(pRow->TimeStamp))));

                                         }
                                        fMatch = FALSE;

                                        ChkAdd(
                                                pRow,
                                                pFile,
                                                AddFilter,
                                                &fMatch
                                                );

                                          if (pFile == NULL)
                                          {
                                            printf("-----------------------\n");
                                          }
                                          else
                                          {
                                            fprintf(pFile, "-----------------------\n");
                                           }
                                    }
                                    pRow++;

                        } // end of for (all recs)

                        //
                        // If a range was chosen and records
                        // retrieved are == the limit of 100
                        // and if the Max vers no retrieved
                        // is less than that specified, ask
                        // user if he wishes to continue
                        //
                        if (!fSetFilter)
                        {
                                printf("Got %d records in this round\n",
                                                        Recs.NoOfRecs);
                        }
                        if (
                                (Recs.NoOfRecs < Recs.TotalNoOfRecs)
                                           &&
                                LiLtr((--pRow)->VersNo,
                                                HighVersNo )
                           )
                        {
                                if ((pFile == NULL) && (!fSetFilter))
                                {
                                          printf("There may be more. Get them ?? Input 1 for yes, 0 for no -- ");
                                          scanf("%d", &Choice);
                                }
                                else
                                {
                                                Choice = 1;
                                }
                                if (Choice == 1)
                                {
                                           LowVersNo.QuadPart = LiAdd(pRow->VersNo,sTmpVersNo);
                                           //Recs.NoOfRecs = 0;
                                           continue;
                                }

                        }

                        printf("Total No Of records %s = (%d)\n",
        fSetFilter ? "searched" : "retrieved", TotalCnt);
                        if (pFile != NULL)
                        {
                                fprintf(pFile, "TOTAL NO OF RECORDS %s = (%d) for WINS (%s)\n",
        fSetFilter ? "searched" : "retrieved",  TotalCnt, pTgtAdd);
                                fprintf(pFile, "++++++++++++++++++++++++++++++\n");

                        }
                }
                else
                {
                        printf("No records of WINS (%s) in the range requested are there in the local db\n", pTgtAdd);

                }
        }
                break;
    } // while (TRUE)

    if (Recs.pRow != NULL)
    {
        WinsFreeMem(Recs.pRow);
    }
    return(Status);
} // GetDbRecs


VOID
ChkAdd(
        PWINSINTF_RECORD_ACTION_T pRow,
        FILE                          *pFile,
        DWORD                          Add,
        LPBOOL                          pfMatch
      )
{

        struct in_addr InAddr;

        if (
            (pRow->TypOfRec_e == WINSINTF_E_UNIQUE)
                        ||
            (pRow->TypOfRec_e == WINSINTF_E_NORM_GROUP)
            )
        {
                InAddr.s_addr = htonl( pRow->Add.IPAdd);

                if (*pfMatch)
                {
                        if (Add == pRow->Add.IPAdd)
                        {
                                return;
                        }
                        else
                        {
                                  *pfMatch = FALSE;
                                return;
                        }
                }


                if (pFile == NULL)
                {
                          printf("IP Address is (%s)\n", inet_ntoa(InAddr) );
                }
                else
                {
                          fprintf(pFile, "IP Address is (%s)\n",
                                                        inet_ntoa(InAddr)
                                                        );
                }
          }
          else //spec. grp or multihomed
          {
                DWORD ind;
                if (!*pfMatch)
                {
                        if (pFile == NULL)
                        {
                          printf("No. Of Members (%d)\n\n", pRow->NoOfAdds/2);
                        }
                        else
                        {
                          fprintf(pFile, "No. Of Members (%d)\n\n", pRow->NoOfAdds/2);
                        }
                }

                for ( ind=0;  ind < pRow->NoOfAdds ;  /*no third expr*/ )
                {
                         InAddr.s_addr = htonl( (pRow->pAdd + ind++)->IPAdd);
                         if (!*pfMatch)
                         {
                            if (pFile == NULL)
                            {
                                printf("Owner is (%s); ", inet_ntoa(InAddr) );
                             }
                            else
                            {
                                    fprintf(pFile, "Owner is (%s); ",
                                                        inet_ntoa(InAddr) );
                            }
                         }
                         InAddr.s_addr = htonl(
                                                  (pRow->pAdd + ind++)->IPAdd);

                         if (!*pfMatch)
                         {
                                 if (pFile == NULL)
                                 {
                                  printf("Node is (%s)\n", inet_ntoa(InAddr) );
                                 }
                                 else
                                 {
                                  fprintf(pFile, "Node is (%s)\n",
                                                        inet_ntoa(InAddr)
                                                                );
                                   }
                         }
                         if (*pfMatch)
                         {
                                if (Add == (pRow->pAdd + ind - 1)->IPAdd)
                                {
                                        return;
                                }
                                else
                                {
                                          *pfMatch = FALSE;
                                        return;
                                }
                         }
                 }

                 //
                 // If there were no members to compare with, then
                 // let us set *pfMatch to FALSE.
                 //
                 if (ind == 0)
                 {
                        if (*pfMatch)
                        {
                                *pfMatch = FALSE;
                        }
                 }

          }
}


VOID
WantFile(
        FILE **ppFile
)
{
        DWORD Choice;
        printf("Put records in wins.rec file (1 for yes, 0 for no) -- ");
        scanf("%d", &Choice);
        if (Choice != 1)
        {
                *ppFile = NULL;
        }
        else
        {
                *ppFile = fopen("wins.rec", "a");
                if (*ppFile == NULL)
                {
                        printf("Could not open file wins.rec for appending\n");
                }
        }
        return;
}

DWORD
CreateFiles(
    PWINSINTF_RECS_T pRecs,
    PWINSINTF_ADD_T      pWinsAdd,
    FILE *pFileU,
    FILE  *pFileO
    )
{
        DWORD           no;
        PWINSINTF_RECORD_ACTION_T pRow;
        DWORD           i;
        struct in_addr InAddr;

        pRow = pRecs->pRow;
        InAddr.s_addr = htonl(pWinsAdd->IPAdd);
        fprintf(pFileU, "##UNIQUE records of WINS with address %s\n\n", inet_ntoa(InAddr));
        fprintf(pFileO, "##NON-UNIQUE records of WINS with address %s\n", inet_ntoa(InAddr));

        for(no = 0; no < pRecs->NoOfRecs; no++)
        {


            if (pRow->TypOfRec_e == WINSINTF_E_UNIQUE)
            {
                InAddr.s_addr = htonl(pRow->Add.IPAdd);

                fprintf(pFileU, "%s\t", inet_ntoa(InAddr));
                for (i=0; i<pRow->NameLen; i++)
                {
                  fprintf(pFileU, "%c", *(pRow->pName + i));
                }
                fprintf(pFileU, "\n");
            }
            else
            {
                fprintf(pFileO, "%d\t", pRow->NameLen);
                for (i=0; i<pRow->NameLen; i++)
                {
                    fprintf(pFileO, "%c", (BYTE)(*(pRow->pName + i)));
                }

                fprintf(pFileO, "\t%d", pRow->TypOfRec_e);
                if (pRow->TypOfRec_e == WINSINTF_E_NORM_GROUP)
                {
                    InAddr.s_addr = htonl(pRow->Add.IPAdd);
                    fprintf(pFileO, "\t%s", inet_ntoa(InAddr));

                }
                else
                {
                     fprintf(pFileO, "\t%d\t", pRow->NoOfAdds);
                     for (i=0; i<pRow->NoOfAdds; i)
                     {
                           InAddr.s_addr = htonl((pRow->pAdd +i++)->IPAdd);
                           fprintf(pFileO, "%s\t", inet_ntoa(InAddr));
                           InAddr.s_addr = htonl((pRow->pAdd + i++)->IPAdd);
                           fprintf(pFileO, "%s\t", inet_ntoa(InAddr));
                     }
                }
                fprintf(pFileO, "\n");
            }
            pRow++;
        }
       fprintf(pFileO, "\n\n\n");

       return(WINSINTF_SUCCESS);
}


DWORD
InitFromFile(
        VOID
    )
{
        FILE *pFileO;
        WINSINTF_RECORD_ACTION_T RecAction;
        DWORD NoOfRecs = 0;
        DWORD i;
        DWORD RetStat = WINSINTF_SUCCESS;
        BYTE  Add[20];

        pFileO = fopen(FILEO, "r");
        if (pFileO == NULL)
        {
                printf("Could not open file %s\n", FILEO);
                return(WINSINTF_FAILURE);
        }
        while(TRUE)
        {
          printf("Record no %d\n", ++NoOfRecs);

          if (fscanf(pFileO, "%d\t", &RecAction.NameLen) == EOF)
          {
                printf("ERROR reading NameLen\n");
                break;

          }
          RecAction.pName = WinsAllocMem(RecAction.NameLen);
          for(i=0;i<RecAction.NameLen;i++)
          {
            if (fscanf(pFileO, "%c", (RecAction.pName + i)) == EOF)
            {
                printf("ERROR reading Name. i is %d", i);
                break;
            }
          }
          if (fscanf(pFileO, "\t%d", &RecAction.TypOfRec_e) == EOF)
          {
                printf("ERROR reading TypeOfRec\n");
                break;
          }
          if (RecAction.TypOfRec_e == WINSINTF_E_NORM_GROUP)
          {
           fscanf(pFileO, "%s", Add);
                   RecAction.Add.IPAdd    = 0xFFFFFFFF;
                   RecAction.Add.Type     = 0;
                   RecAction.Add.Len      = 4;
                   RecAction.NoOfAdds = 0;
          }
          else
          {
            if (fscanf(pFileO, "\t%d\t", &RecAction.NoOfAdds) == EOF)
            {
                printf("ERROR reading NoOfAdds");
                break;
            }
            for (i=0; i<RecAction.NoOfAdds;i++)
            {
                   BYTE Add[20];
                   RecAction.pAdd = WinsAllocMem(
                                sizeof(WINSINTF_ADD_T) * RecAction.NoOfAdds);

                   for(i = 0; i < RecAction.NoOfAdds; i++)
                   {
                       if (fscanf(pFileO, "%s\t", Add) == EOF)
                       {
                         printf("ERROR reading Address");
                         break;
                       }
                       (RecAction.pAdd + i)->IPAdd = ntohl(inet_addr(Add));
                       (RecAction.pAdd + i)->Type     = 0;
                       (RecAction.pAdd + i)->Len      = 4;
                   }
            }
         }
         fscanf(pFileO, "\n");
        }  // end of while

        printf("Name = (%s), TypeOfRec (%s)\n", RecAction.pName, RecAction.TypOfRec_e == WINSINTF_E_NORM_GROUP ? "NORMAL GROUP" : (RecAction.TypOfRec_e ==
WINSINTF_E_SPEC_GROUP) ? "SPECIAL GROUP" : "MULTIHOMED");
        if (RecAction.TypOfRec_e == WINSINTF_E_NORM_GROUP)
        {
                printf("NORM GRP: Address is %x\n", RecAction.Add.IPAdd);
        }
        else
        {
                for (i=0; i < RecAction.NoOfAdds; i++)
                {
                        printf("%d -- Owner (%d) is (%p)\t", i,
                                        (RecAction.pAdd + i)->IPAdd);
                        printf("%d -- Address (%d) is (%p)\n", ++i,
                                        (RecAction.pAdd + i)->IPAdd);
                }

        }
        return(RetStat);
}

DWORD
GetDbRecsByName(
  PWINSINTF_ADD_T pWinsAdd,
  DWORD           Location,
  LPBYTE          pName,
  DWORD           NameLen,
  DWORD           NoOfRecsDesired,
  DWORD           TypeOfRecs,
  BOOL            fFilter,
  DWORD           AddFilter
 )
{
         DWORD Status;
         WINSINTF_RECS_T Recs;
         DWORD      TotalCnt = 0;

          Recs.pRow = NULL;
          Status = WinsGetDbRecsByName(BindHdl, pWinsAdd, Location, pName, NameLen,
                                   NoOfRecsDesired, TypeOfRecs, &Recs);
          printf("Total number of records are (%d)\n",  Recs.TotalNoOfRecs);
           if (Status == WINSINTF_SUCCESS)
           {
                if (Recs.NoOfRecs > 0)
                {
                        DWORD i;
                        PWINSINTF_RECORD_ACTION_T pRow =  Recs.pRow;
                        TotalCnt += Recs.NoOfRecs;


                        printf("Retrieved %d records\n", Recs.NoOfRecs);
                        for (i=0; i<Recs.NoOfRecs; i++)
                        {

                               printf("-----------------------\n");
                               printf("Name is (%s). 16th char is (%x)\nNameLen is (%d)\nType is (%s)\nState is (%s)\nVersion No is (%x %x)\nStatic flag is (%d)\nTimestamp is (%.19s)\n", pRow->pName, *(pRow->pName+15),
pRow->NameLen, pRow->TypOfRec_e == WINSINTF_E_UNIQUE ? "UNIQUE" : (pRow->TypOfRec_e == WINSINTF_E_NORM_GROUP) ? "NORMAL GROUP" : (pRow->TypOfRec_e == WINSINTF_E_SPEC_GROUP) ? "SPECIAL GROUP" : "MULTIHOMED",
        pRow->State_e == WINSINTF_E_ACTIVE ? "ACTIVE" : (pRow->State_e == WINSINTF_E_RELEASED) ? "RELEASED" : "TOMBSTONE", pRow->VersNo.HighPart, pRow->VersNo.LowPart, pRow->fStatic, asctime(localtime(&(pRow->TimeStamp))));

                                        ChkAdd(
                                                pRow,
                                                NULL,
                                                AddFilter,
                                                &fFilter
                                                );

                                printf("-----------------------\n");
                                pRow++;

                        } // end of for (all recs)

                }
                else
                {
                        printf("No records were retrieved\n");

                }
           }
           if (Recs.pRow != NULL)
           {
              WinsFreeMem(Recs.pRow);
           }
    return(Status);
}

VOID
Usage(
  VOID
 )
{
    CMD_E i;
    DWORD LastEntry = (fEnhMode ? LAST_ENTRY : LAST_PSS_ENTRY);
    printf("winscl {T or N} {CMD}\n");
    printf("where\nT -- TCP/IP\nN -- Named Pipe\n");
    printf("\n\nCMD is one of the following\n");

    for (i = 0; i < (CMD_E)LastEntry; i++)
    {
       if (CommandSwitchList[i].SwitchName != NULL)
       {
         printf("%s or %s\n", CommandSwitchList[i].SwitchName,
                        CommandSwitchList[i].ShortName);
       }
    }
    return;
}

VOID
GetCmdCode(
  LPBYTE pCmd,
  PCMD_E pCmd_e
 )
{
   CMD_E Cmd_e;
   *pCmd_e = INVALID_VALUE;

   for (Cmd_e = 0; Cmd_e < (fEnhMode ? LAST_ENTRY : LAST_PSS_ENTRY); Cmd_e++)
   {
     if (CommandSwitchList[Cmd_e].ShortName != NULL)
     {
     if (!_strcmpi(CommandSwitchList[Cmd_e].ShortName, pCmd)
                    ||
           !_strcmpi(CommandSwitchList[Cmd_e].SwitchName, pCmd)
        )
     {
           *pCmd_e = CommandSwitchList[Cmd_e].SwitchValue;
           return;

     }
    }
  }
  return;

}

#define PRADEEPB_PTM "157.55.80.183"
#define PRADEEPB_486 "157.55.80.182"

//#define RHINO1 PRADEEPB_PTM
//#define RHINO2 PRADEEPB_486
#define RHINO1 "157.55.80.151"
#define RHINO2  "157.55.80.152"
#define RED03NS  "157.54.16.159"

VOID
sync(VOID)
{
  handle_t                BindHdl;
  WINSINTF_BIND_DATA_T        BindData;
  PNAME_INFO  pNameInfo, pSrvInfo;
  WINS_INFO  WinsInfo;
  DWORD i, n, t, s;
  LPBYTE pWinsAdd = RHINO1;
  DWORD Status;
  PWINSINTF_RECORD_ACTION_T pSvRecAction = NULL;
  WINSINTF_RECORD_ACTION_T RecAction;
  PWINSINTF_RECORD_ACTION_T pRecAction;
  PWINSINTF_RECORD_ACTION_T pOutRecAction;
  BOOL fAtLeastOneFound;
  DWORD NoOfNames, NoOfSrvNames;


  if(!ReadNameFile( &pNameInfo, &NoOfNames, "nmfl.txt"))
  {
     return;
  }
  if(!ReadNameFile( &pSrvInfo, &NoOfSrvNames, "winss.txt"))
  {
     return;
  }
  WinsInfo.NoOfOwners = NoOfSrvNames;
  for (i = 0; i < NoOfSrvNames; i++)
  {
    strcpy(WinsInfo.Maps[i].asIpAdd, pSrvInfo->Name);
    WinsInfo.Maps[i].fCommFail = FALSE;
    WinsInfo.Maps[i].fNameNotFound = FALSE;
    fprintf(spDbgFile, "WINS server (%d) is  (%s)\n", i, WinsInfo.Maps[i].asIpAdd);
    pSrvInfo++;

  }

 i = 0;
#if 0
 do
 {
  if (!BindToWins(pWinsAdd, &BindData, &BindHdl))
  {
       fprintf(spDbgFile, "Unable to bind to %s\n", pWinsAdd);
       return;
  }
  fprintf(spDbgFile, "Connected to WINS = (%s)\n", pWinsAdd);
  //
  // Get WINS server info
  //
  WinsInfo.NoOfOwners = 0;

  i++;
  if (GetWinsInfo(&WinsInfo) != WINSINTF_SUCCESS)
  {
       fprintf(spDbgFile, "Comm. Failure with %s\n", pWinsAdd);
       if (i < 2)
       {
         pWinsAdd = RHINO2;
       }
  }
  else
  {
     i = 2;
  }
  WinsUnbind(&BindData, BindHdl);
  } while (i < 2);
#endif

  //
  // Loop over all names read in.  Query the name from all WINSs that
  // we have in our list of WINS owners that we got from RHINO1
  //
  for (i = 0; (pNameInfo->Name[0] != 0) && (i < NoOfNames); i++, pNameInfo++)
  {

   DWORD LChar;
   CHAR Name[50];
   BOOL  fStored;
   for (s=0; s<2;s++)
   {
     LChar = (s==0) ? 0x20 : 0x0;

     RecAction.Cmd_e      = WINSINTF_E_QUERY;

     strcpy(Name, pNameInfo->Name);
     GetFullName(Name, LChar, &RecAction);

     pRecAction = &RecAction;

     //
     // For a name, loop over all WINS owners
     //
     fStored = FALSE;
     fAtLeastOneFound = FALSE;
     for (n = 0; n < NoOfSrvNames; n++)
     {
             DWORD OwnIdOfName;

#if 0
             if (
                     !_strcmpi(WinsInfo.Maps[n].asIpAdd, RHINO1) ||
                     !_strcmpi(WinsInfo.Maps[n].asIpAdd, RHINO2) ||
                     !_strcmpi(WinsInfo.Maps[n].asIpAdd, RED03NS)
                )
#endif
            fprintf(spDbgFile, "BINDING TO WINS = (%s)\n", WinsInfo.Maps[n].asIpAdd);
             {

             //
             // Bind to the WINS
             //
             if (!BindToWins(WinsInfo.Maps[n].asIpAdd, &BindData, &BindHdl))
             {
                    fprintf(spDbgFile, "FAILED BINDING\n");
                    continue;  // go on to the next one
             }

             //
             // Query Wins for the name
             //
             pRecAction = &RecAction;
             if ((Status = QueryWins(Name, pRecAction, &pOutRecAction)) == NAME_NOT_FOUND)
             {
                  fprintf(spDbgFile2, "DID NOT FIND NAME = (%s[%x]) in Wins = (%s) db\n",
                           Name, Name[15], WinsInfo.Maps[n].asIpAdd);
                  WinsInfo.Maps[n].fNameNotFound = TRUE;
                  WinsInfo.Maps[n].fCommFail = FALSE;
             }
             else
             {
                if ( Status == SUCCESS)
                {
                  fprintf(spDbgFile, "FOUND name = (%s[%x]) in Wins = (%s) db\n",
                           Name, Name[15], WinsInfo.Maps[n].asIpAdd);
                 fAtLeastOneFound = TRUE;
                 if (!fStored)
                 {
                   fStored = TRUE;
                   pSvRecAction = pOutRecAction;
                 }
                 else
                 {
                     WinsFreeMem(pOutRecAction);
                 }
                  WinsInfo.Maps[n].fCommFail = FALSE;
                  WinsInfo.Maps[n].fNameNotFound = FALSE;
                }
                else
                {
                     WinsInfo.Maps[n].fCommFail = TRUE;
                }
             }
             WinsUnbind(&BindData, BindHdl);
             }
#if 0
             else
             {
                     WinsInfo.Maps[n].fCommFail = TRUE;
             }
#endif
       }

//#if 0
       for (t = 0; t < WinsInfo.NoOfOwners && fAtLeastOneFound; t++)
       {
                if (!WinsInfo.Maps[t].fCommFail && WinsInfo.Maps[t].fNameNotFound)
                {
                   if(BindToWins(WinsInfo.Maps[t].asIpAdd, &BindData, &BindHdl))
                   {
                     StoreName(pSvRecAction, RecAction.pName);
                     WinsUnbind(&BindData, BindHdl);
                   }
                }
                else
                {
                     continue;
                }
        }
//#endif
        if (RecAction.pName != NULL)
        {
                WinsFreeMem(RecAction.pName);
                RecAction.pName = NULL;
        }
        if (pSvRecAction)
        {
            WinsFreeMem(pSvRecAction);
            pSvRecAction = NULL;
        }
    }
  }

       fclose(spDbgFile);
       fclose(spDbgFile2);
       return;
}

VOID
StoreName(
 PWINSINTF_RECORD_ACTION_T pRecAction,
 LPBYTE pName
 )
{

      DWORD Status;
      DWORD i;

      (void)strncpy(pRecAction->pName, pName, 16);
      pRecAction->NameLen    = 16;
      pRecAction->Cmd_e      = WINSINTF_E_INSERT;
      if ((pRecAction->TypOfRec_e == WINSINTF_E_SPEC_GROUP) ||
          (pRecAction->TypOfRec_e == WINSINTF_E_MULTIHOMED))
      {
          for (i = 0; i < pRecAction->NoOfAdds; i++)
          {
            *(pRecAction->pAdd + i) = *(pRecAction->pAdd + i + 1);
            i++;
          }
          pRecAction->NoOfAdds = pRecAction->NoOfAdds/2;
      }

      fprintf(spDbgFile2, "StoreName:STORING name %s[%x]\n", pRecAction->pName, pRecAction->pName[15]);
      Status = WinsRecordAction(BindHdl, &pRecAction);
      fprintf(spDbgFile2, "StoreName:Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
       WinsFreeMem(pRecAction);
       return;
}


DWORD
QueryWins (
 LPBYTE pName,
 PWINSINTF_RECORD_ACTION_T pRecAction,
 PWINSINTF_RECORD_ACTION_T *ppRecAct
)
{
       DWORD RetStat;
       struct in_addr InAddr;
       DWORD i;
       DWORD Status;

       Status = WinsRecordAction(BindHdl, &pRecAction);
       fprintf(spDbgFile, "Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
       if (Status == WINSINTF_SUCCESS)
       {
            *ppRecAct = pRecAction;
                          fprintf(spDbgFile, "Name=(%s)\nNodeType=(%d)\nState=(%s)\nTimeStamp=(%.19s)\nOwnerId=(%d)\nType Of Rec=(%s)\nVersion No (%x %x)\nRecord is (%s)\n",
                                pRecAction->pName,
                                pRecAction->NodeTyp,
                                pRecAction->State_e == WINSINTF_E_ACTIVE ? "ACTIVE" : (pRecAction->State_e == WINSINTF_E_RELEASED) ? "RELEASED" : "TOMBSTONE",
                                asctime(localtime(&(pRecAction->TimeStamp))),
                                pRecAction->OwnerId,
                                (pRecAction->TypOfRec_e == WINSINTF_E_UNIQUE) ? "UNIQUE" : (pRecAction->TypOfRec_e == WINSINTF_E_NORM_GROUP) ? "NORMAL GROUP" :
(pRecAction->TypOfRec_e == WINSINTF_E_SPEC_GROUP) ? "SPECIAL GROUP" : "MULTIHOMED",

                                pRecAction->VersNo.HighPart,
                                pRecAction->VersNo.LowPart,
                                pRecAction->fStatic ? "STATIC" : "DYNAMIC"
                                        );
                                if (
                                (pRecAction->TypOfRec_e == WINSINTF_E_UNIQUE)
                                                ||
                                (pRecAction->TypOfRec_e == WINSINTF_E_NORM_GROUP)
                                  )
                                {

                                   InAddr.s_addr = htonl(pRecAction->Add.IPAdd);
                                   fprintf(spDbgFile, "Address is (%s)\n", inet_ntoa(InAddr));
                                }
                                else
                                {
                                   for (i=0; i<pRecAction->NoOfAdds; )
                                   {
                                      InAddr.s_addr = htonl((pRecAction->pAdd +i++)->IPAdd);
                                      fprintf(spDbgFile, "Owner is (%s); ", inet_ntoa(InAddr));
                                      InAddr.s_addr = htonl((pRecAction->pAdd + i++)->IPAdd);
                                      fprintf(spDbgFile, "Member is (%s)\n", inet_ntoa(InAddr));
                                   }
                                }


               RetStat = SUCCESS;
      }
      else
      {
              if (Status == ERROR_REC_NON_EXISTENT)
              {
                    fprintf(spDbgFile, "No such name in the db\n");
                    RetStat = NAME_NOT_FOUND;
              }
              else
              {
                    fprintf(spDbgFile, "Status is (%x)\n", Status);
                    RetStat = FAILURE;
              }
      }
      return RetStat;
}

handle_t
WinsABind(
    PWINSINTF_BIND_DATA_T pBindData
    );
BOOL
BindToWins(
  LPBYTE asIpAdd,
  PWINSINTF_BIND_DATA_T    pBindData,
  handle_t                *pBindHdl
 )
{

  pBindData->pServerAdd = asIpAdd;
  pBindData->fTcpIp = TRUE;

  *pBindHdl = WinsABind(pBindData);
  if (pBindHdl == NULL)
  {
          fprintf(spDbgFile, "Unable to bind to %s \n", asIpAdd);
          return (FALSE);
  }
  return(TRUE);
}

BOOL
ReadNameFile(
 PNAME_INFO *ppFileInfo,
 LPDWORD pNoOfNames,
 LPBYTE  pNameOfFile
)
{
  FILE *pFile;
  struct _stat  Stat;
  PNAME_INFO   pFileInfo;
  DWORD    SizeAlloc;
  *pNoOfNames = 0;
  if((pFile = fopen(pNameOfFile, "r")) == NULL)
  {
                  return FALSE;
  }

  if (_stat(pNameOfFile, &Stat) == -1)
  {
                  return FALSE;
  }
  SizeAlloc =  Stat.st_size + Stat.st_size/15 * sizeof(NAME_INFO);
  if (!(pFileInfo = malloc(SizeAlloc)))
  {
                  return FALSE;
  }
  else
  {
    fprintf(spDbgFile, "Allocated %d bytes\n", SizeAlloc);
  }
  *ppFileInfo = pFileInfo;

  memset(pFileInfo, 0, SizeAlloc);
  //
  // Read in names
  //
  while(fscanf(pFile, "%s\n", pFileInfo->Name) != EOF)
  {
             fprintf(spDbgFile, "Name is %s\n", pFileInfo->Name);
             (*pNoOfNames)++;
             pFileInfo++;
  }
  return(TRUE);
}

STATUS
GetWinsInfo(
     PWINS_INFO  pWinsInfo
)
{
      DWORD Status;
      WINSINTF_RESULTS_NEW_T Results;
      PWINSINTF_RESULTS_NEW_T pResultsN = &Results;
      DWORD  NoOfOwners;
      struct in_addr                InAddr;
      DWORD i, n;
      PWINSINTF_ADD_VERS_MAP_T  pAddVersMaps;

      Results.WinsStat.NoOfPnrs = 0;
      Results.WinsStat.pRplPnrs = NULL;

      Results.pAddVersMaps = NULL;
      Status = WinsStatusNew(BindHdl, WINSINTF_E_CONFIG_ALL_MAPS, pResultsN);
      if (Status == WINSINTF_SUCCESS)
      {
                pAddVersMaps = pResultsN->pAddVersMaps;

                if (pResultsN->NoOfOwners != 0)
                {
                         for (n=0, i= 0; i < pResultsN->NoOfOwners;  i++, pAddVersMaps++)
                         {
                                InAddr.s_addr = htonl(
                                           pAddVersMaps->Add.IPAdd);

                                if (
                                       (pAddVersMaps->VersNo.HighPart
                                                             == MAXLONG)
                                                     &&
                                      (pAddVersMaps->VersNo.LowPart ==
                                                                MAXULONG)
                                     )
                                {
                                     continue;
                                }
                                if (pAddVersMaps->VersNo.QuadPart == 0)
                                {
                                    continue;
                                }
                                fprintf(spDbgFile,"%d\t\t%s\t\t", i, inet_ntoa(InAddr));

                                fprintf(spDbgFile, "%lu %lu\n",
                                       pAddVersMaps->VersNo.HighPart,
                                       pAddVersMaps->VersNo.LowPart
                                              );

                                pWinsInfo->Maps[n].OwnId = i;
                                strcpy(pWinsInfo->Maps[n].asIpAdd,inet_ntoa(InAddr));
                                pWinsInfo->Maps[n].VersNo = pAddVersMaps->VersNo;
                                n++;
                         }
                         pWinsInfo->NoOfOwners = n; //pResultsN->NoOfOwners;
                         WinsFreeMem(pResultsN->pAddVersMaps);
                }
                else
                {
                          fprintf(spDbgFile, "The Db is empty\n");
                }
       }
       else
       {
                pWinsInfo->NoOfOwners = 0;
       }
       return Status;
}

VOID
GetFullName(
        LPBYTE pName,
        DWORD  SChar,
        PWINSINTF_RECORD_ACTION_T pRecAction
         )
{
      size_t Len;

      pRecAction->pAdd = NULL;
      pRecAction->NoOfAdds = 0;

        if ((Len = strlen(pName)) < 16)
        {
                  memset(pName + Len, (int)' ',16-Len);
                  *(pName + 15) = (BYTE)(SChar & 0xff);
                  *(pName + 16) = (CHAR)NULL;
                   Len = 16;
        }
        else
        {
            *(pName + Len) = (CHAR)NULL;
        }

        pRecAction->pName = WinsAllocMem(Len);
        (void)memcpy(pRecAction->pName, pName, Len);
        pRecAction->NameLen    = Len;
      return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\comm.h ===
#ifndef _COMM_
#define _COMM_


#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	comm.h

Abstract:
	header file for interfacing with comm.c

Functions:


Portability:

	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Jan-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/

#include "wins.h"
#include <winsock2.h>
#if SPX > 0
#include <wsipx.h>
#endif
#include <nb30.h>
#include <nbtioctl.h>

//Don't include winsque.h here since winsque.h includes comm.h
#if 0
#include "winsque.h"
#endif

/*
   simple defines (simple macros)
*/


#define COMM_DATAGRAM_SIZE		576 /*rfc 1002*/

#define COMM_NETBT_REM_ADD_SIZE		sizeof(tREM_ADDRESS)
/*

  The following two defines are for the TCP and UDP port numbers used
  by the WINS server.

  Normally the same port number is used for both TCP and UDP.


*/
FUTURES("Use a port registered with IANA - 1512.  IPPORT_NAMESERVER is used by")
FUTURES("BIND and NAMED -- Unix internet name servers")

#define 	WINS_TCP_PORT	IPPORT_NAMESERVER
#define 	WINS_UDP_PORT	IPPORT_NAMESERVER
#define 	WINS_NBT_PORT	137		//NBT nameserver port	
//#define 	WINS_NBT_PORT	5000		//for testing

//
// Hardcoded Server port for RPC calls.
//
// Note: This is not used since we let RPC pick a port.  Check out
// InitializeRpc() in nms.c  We will use this define olnly if AUTO_BIND is
// not defined
//
#define         WINS_SERVER_PORT 	5001


#define         COMM_DEFAULT_IP_PORT   IPPROTO_IP   //used to init CommPortNo
/*
 COMM_HEADER_SIZE -- size of the comm header on every message sent on a TCP
   		     connection.  This is used in RPL code
*/
#define 	COMM_HEADER_SIZE 	(sizeof(COMM_HEADER_T))

//
// Total header size of header used by COMSYS
//
#define 	COMM_N_TCP_HDR_SZ	sizeof(COMM_TCP_HDR_T)

/*
  Values returned by CommCompAdd function
*/
#define COMM_SAME_ADD		0x0     // addresses are same
#define COMM_DIFF_ADD		0x1	//addresses are different


#define COMM_START_REQ_ASSOC_MSG	0
#define COMM_START_RSP_ASSOC_MSG	1
#define COMM_STOP_REQ_ASSOC_MSG		2
#define COMM_RPL_MSG			3	


#define COMM_IP_ADD_SIZE		sizeof(COMM_IP_ADD_T)
//
// Size of the header on top of a buffer
//
#define COMM_BUFF_HEADER_SIZE		(sizeof(COMM_BUFF_HEADER_T))
/*
  macros
*/
//
// This macro gets the network address from an IP Address in binary form
// Used by AppendNetAdd in nmsnmh.c. It assumes a CLASS B network address
//
//
FUTURES("Use the subnet mask specified via registry")
#define  COMM_NET_ADDRESS_M(Add)	(Add >> 16)

#define COMM_SET_HEADER_M(pLong, Opc, uAssocCtx, MsgTyp)	 \
		{						 \
			LPBYTE _pTmpB = (LPBYTE)pLong++;	 \
			*(_pTmpB + 2)  = Opc << 3; 		 \
			*pLong++      = htonl(uAssocCtx); \
			*pLong++      = htonl(MsgTyp);		 \
		}


#define COMM_GET_HEADER_M(pMsg,  Opc, uAssocCtx, MsgTyp)  \
		{				         	\
			LPLONG	_pLong  = (LPLONG)pMsg;	\
			Opc             = ((*(pMsg + 2) & NMS_OPCODE_MASK) >> 3);\
			uAssocCtx       = ntohl(*++_pLong); \
			MsgTyp          = ntohl(*++_pLong); 	\
		}


//
// Is this my address
//
#define COMM_MY_IP_ADD_M(IpAddress)   ((IpAddress) == NmsLocalAdd.Add.IPAdd)

//
// Gets the address of the remote client
//
#define  COMM_GET_IPADD_M(pDlgHdl, pIPAdd)	{		  	  \
			PCOMMASSOC_DLG_CTX_T	_pEnt = (pDlgHdl)->pEnt;  \
			*(pIPAdd) = _pEnt->FromAdd.sin_addr.s_addr; 	  \
					}

#define  COMM_GET_FAMILY_M(pDlgHdl, Family)	{		  	  \
			PCOMMASSOC_DLG_CTX_T	_pEnt = (pDlgHdl)->pEnt;  \
			Family = _pEnt->FromAdd.sin_family; 	          \
					}

#define  COMM_IS_PNR_BETA1_WINS_M(pDlgHdl, fBeta1)	{(fBeta1) = FALSE;}
#if 0
#define  COMM_IS_PNR_BETA1_WINS_M(pDlgHdl, fBeta1)	{	  	  \
	PCOMMASSOC_DLG_CTX_T	_pEnt = (pDlgHdl)->pEnt;                  \
        PCOMMASSOC_ASSOC_CTX_T  _pAssocEnt = _pEnt->AssocHdl.pEnt;       \
        fBeta1 = (_pAssocEnt->MajVersNo == WINS_BETA1_MAJOR_VERS_NO) ? TRUE : \
          FALSE;                                                            \
					}
#endif
#if PRSCONN
#define  COMM_GET_WINS_VERS_NO_M(pDlgHdl, MajVers, MinVers)	{	  	  \
	PCOMMASSOC_DLG_CTX_T	_pEnt = (pDlgHdl)->pEnt;                  \
        PCOMMASSOC_ASSOC_CTX_T  _pAssocEnt = _pEnt->AssocHdl.pEnt;       \
        MajVers = _pAssocEnt->MajVersNo; \
        MinVers = _pAssocEnt->MinVersNo; \
					}

#define ECOMM_INIT_DLG_HDL_M(pDlgHdl)  {(pDlgHdl)->pEnt = NULL; (pDlgHdl)->SeqNo=0;}
#define ECOMM_IS_PNR_POSTNT4_WINS_M(pDlgHdl, fNT5) {  \
              DWORD _MajVers, _MinVers; \
              COMM_GET_WINS_VERS_NO_M((pDlgHdl), _MajVers, _MinVers); \
              fNT5 = (_MinVers >= WINS_MINOR_VERS_NT5) ? TRUE : FALSE; \
            }
#endif


//
// This macro checks if the name is local or not. Used in NmsNmhNamRegInd
// and NmsNmhNamRegGrp functions
//
#define  COMM_IS_IT_LOCAL_M(pDlgHdl)  \
        (((PCOMMASSOC_DLG_CTX_T)(pDlgHdl->pEnt))->FromAdd.sin_family == NBT_UNIX)

//
// On querying a name, if WINS finds it to be a local name, it sets the
// the family in the DlgHdl to NBT_UNIX so that NETBT can respond to the
// query
//

#if USENETBT > 0
#define  COMM_SET_LOCAL_M(pDlgHdl)  \
        (((PCOMMASSOC_DLG_CTX_T)(pDlgHdl->pEnt))->FromAdd.sin_family = NBT_UNIX)

#else
#define  COMM_SET_LOCAL_M(pDlgHdl)
#endif

//
// Initialize a COMM_ADD_T structure given an IP address
//
#define COMM_INIT_ADD_M(pWinsAdd, IPAddress)	{			\
			(pWinsAdd)->AddLen   = sizeof(PCOMM_IP_ADD_T); 	\
			(pWinsAdd)->AddTyp_e  = COMM_ADD_E_TCPUDPIP; 	\
			(pWinsAdd)->Add.IPAdd = (IPAddress);			\
						}	
//
// Initialize a COMM_ADD_T structure given a dlg handle.
//
#define COMM_INIT_ADD_FR_DLG_HDL_M(pWinsAdd, pDlgHdl)	{		\
			COMM_IP_ADD_T	IPAdd;				\
			COMM_GET_IPADD_M((pDlgHdl), &IPAdd);		\
			COMM_INIT_ADD_M((pWinsAdd), IPAdd);		\
						}	
//
// COMM_ADDRESS_SAME_M -- checks if the addresses are the same.  Expects
// pointers to COMM_ADD_T structues for its parameters
//

#define COMM_ADDRESS_SAME_M(pAdd1,pAdd2)     ((pAdd1)->Add.IPAdd == (pAdd2)->Add.IPAdd)
/*
 COMM_IS_TCP_MSG_M

 This macro is called by FrmNamQueryRsp to determine if the request
 message came over a TCP connection.

 FrmNamQueryRsp checks this in order to determine whether to allocate a
 buffer or use the request buffer for the response.
*/

#define COMM_IS_TCP_MSG_M(pDlgHdl) (((PCOMASSOC_DLG_CTX_T)pDlgHdl->pEnt)->Typ_e != COMM_E_UDP)

NONPORT("Port to different address families")
#define COMM_NETFORM_TO_ASCII_M(pAdd)	inet_ntoa(*(pAdd))

/*

 The macros below are used to host to network and network to host byte
 order coversion.  The macros are used by message formatting functions
 in the name space manager and replicator components of the WINS server
*/

#define COMM_HOST_TO_NET_L_M(HostLongVal_m, NetLongVal_m)	\
	{							\
		NetLongVal_m = htonl((HostLongVal_m));		\
	}

#define COMM_HOST_TO_NET_S_M(HostShortVal_m, NetShortVal_m)	\
	{							\
		NetShortVal_m = htons((HostShortVal_m));	\
	}
	
#define COMM_NET_TO_HOST_L_M(NetLongVal_m, HostLongVal_m)	\
	{							\
		HostLongVal_m = ntohl((NetLongVal_m));		\
	}

#define COMM_NET_TO_HOST_S_M(NetShortVal_m, HostShortVal_m)	\
	{							\
		HostShortVal_m = ntohs((NetShortVal_m));	\
	}

//
// Size of the message sent to the TCP listener thread by the PULL/PUSH
// thread
//
#define  COMM_NTF_MSG_SZ 	sizeof(COMM_NTF_MSG_T)

#if MCAST > 0
#define   COMM_MCAST_WINS_UP     0
#define   COMM_MCAST_WINS_DOWN   1
#define   COMM_MCAST_SIGN_START        0xABCD
#define   COMM_MCAST_SIGN_END          0xABCF
#define   COMM_MCAST_MSG_SZ 	 sizeof(COMM_MCAST_MSG_T)

#endif

//
// No of critical sections for assocs/dlgs that can be there at any one time.
// Want to save on non-paged pool
//
#define COMM_FREE_COMM_HDL_THRESHOLD     100
/*
 externs
*/
struct _COMM_HDL_T;	//forward reference

#if MCAST > 0
extern SOCKET CommMcastPortHandle;
#endif

extern HANDLE CommUdpBuffHeapHdl;
extern HANDLE CommUdpDlgHeapHdl;
extern SOCKET CommTcpPortHandle;
extern SOCKET CommUdpPortHandle;
extern SOCKET CommNtfSockHandle;
extern struct sockaddr_in CommNtfSockAdd;
extern struct _COMM_HDL_T CommExNbtDlgHdl;

extern DWORD  CommConnCount;   //total # of tcp connections from/to local WINS

extern DWORD CommWinsTcpPortNo;
extern DWORD WinsClusterIpAddress;
#if SPX > 0
extern DWORD CommWinsSpxPortNo
#endif

//
// Set to TRUE by the tcp listener thread when it discovers that the assoc.
// it was asked to stop monitoring is no longer in its list.
//
extern BOOL   fCommDlgError;

#ifdef WINSDBG
extern  DWORD CommNoOfDgrms;
extern  DWORD CommNoOfRepeatDgrms;
#endif

FUTURES("Remove this when WinsGetNameAndAdd is removed")

#if USENETBT == 0
extern BYTE	HostName[];
#endif

/*
 typedef  definitions
*/

#if USENETBT > 0
//
// The format of Adapter Status responses
//

typedef struct
{
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER    Names[32];
} tADAPTERSTATUS;
#endif
/*
 COMM_IP_ADD_T
	typedef for IP address
*/
typedef ULONG	COMM_IP_ADD_T, *PCOMM_IP_ADD_T;

/*
  COMM_TYP_E  - Enumerator for the different types of dlgs and associations
*/
typedef enum _COMM_TYP_E {
	COMM_E_RPL = 0,	  /* Used for pull replication*/
	COMM_E_NOT,  	  /* Used for notification	*/
	COMM_E_QUERY,	  /*used for querying an RQ server */
	COMM_E_UPD,	  /*used for sending name query responses and
			   * updates to a Q server	*/
	COMM_E_NBT,	  /*  set up by an NBT node*/
	COMM_E_UDP,	  /*set up for UDP communication	*/
	COMM_E_TCP	  /*until we know which TCP msg this is	*/
	} COMM_TYP_E, *PCOMM_TYP_E;

/*
 This is the comm header prefixed on every message sent by a WINS to another
 WINS (on a TCP connection)
*/
typedef struct _COMM_HEADER_T {
	LONG	Opcode;     //NBT or RPL connection opcode
    DWORD   uAssocCtx;  //tag to assoc context block sent by remote WINS 
                        //legacy (32bit) WINS send here pointer to memory.
                        //new (64bit) WINS send here 32bit tag value
	DWORD   MsgTyp;	    //Type of message  (START_ASSOC, STOP_ASSOC, etc)
	} COMM_HEADER_T, *PCOMM_HEADER_T;

/*
 This is the Tcp header prefixed on every message sent by a WINS to another
 WINS (on a TCP connection)
*/
typedef struct _COMM_TCP_HDR_T {
	LONG	      LenOfMsg;     //NBT or RPL connection opcode
        COMM_HEADER_T CommHdr;
	} COMM_TCP_HDR_T, *PCOMM_TCP_HDR_T;

/*
 * COMM_ADD_TYP_E -- enumerator for the different address families.
*/
typedef enum _COMM_ADD_TYP_E {
	COMM_ADD_E_TCPUDPIP = 0,
    COMM_ADD_E_SPXIPX
	} COMM_ADD_TYP_E, *PCOMM_ADD_TYP_E;


/*
 COMM_ADD_T --
	address of a node.  This is in TLV form.  Currently, the union has
	an entry just for IP address.  In the future, it will have
	entries for addresses pertaining to other address families.
	such as XNS, OSI, etc


	NOTE NOTE NOTE
		Put the enumerator at the end so that the alignment of
		the various fields in COMM_ADD_T is on their natural
		boundaries.

		This structure is written as is into the address field of
		the database record (in both the name - address table and the
		owner id - address table).  Therefore it is important
		that we have the alignment set right (in order to save
		on database storage) and also to read the stuff from the
		database record back into the correct fields of an in-memory
		COMM_ADD_T structure
*/
ALIGN("Alignment very important here")
FUTURES("Use a union of SOCKADDR_IP and SOCXADDR_IPX")
typedef struct _COMM_ADD_T {
	DWORD		 AddLen;
	union _Add{
	  DWORD  IPAdd;
	  //		
	  // we may add other fields later on
	  //
#if SPX > 0
      char  netnum[4];
      char  nodenum[6];
#endif

	      } Add;
	COMM_ADD_TYP_E  AddTyp_e;  /*this should be the last field for
				    *alignment puposes
				    */
	} COMM_ADD_T, *PCOMM_ADD_T;	

/*
COMM_HDL_T -- this is the handle to a comm sys. entity such as a dialogue
 or an association.  The handle to a dialogue is passed to COMSYS clients
 for future use by them
*/
typedef struct _COMM_HDL_T {
	DWORD	SeqNo;  //sequence no. of ctx block created for entity
	LPVOID  pEnt;   //pointer to ctx block
	} COMM_HDL_T, *PCOMM_HDL_T;

/*
 COMM_TOP_T  -- This is the structure which is at the top of the assoc and
  dlg ctx structures.   It must have LIST_ENTRY at its top.

*/
typedef struct _COMM_TOP_T {
	LIST_ENTRY	      Head; 	//for linking free blocks
	DWORD		      SeqNo;    //seq. no of block
    CRITICAL_SECTION  CrtSec;
    BOOLEAN           fCrtSecInited;
#if 0
	HANDLE		      MutexHdl; //mutex for locking block
#endif
	} COMM_TOP_T, *PCOMM_TOP_T;


/*
  COMM_BUFF_HEADER_T --

	This is the header for all buffers allocated for requests/responses.
	received over the wire

	Note: This buffer is added on top of COMM_HEADER_T buffer allocated
	for requests/responses sent by a WINS to another WINS	
	
*/
typedef struct _COMM_BUFF_HEADER_T {
	COMM_TYP_E  Typ_e;
	} COMM_BUFF_HEADER_T, *PCOMM_BUFF_HEADER_T;


//
// Command sent to the TCP listener thread by the PUSH thread or the PULL
// thread.   The PULL thread sends the START_MON command when it sends
// a Push trigger to another WINS. The PUSH thread sends the STOP_MON
// command when it receives a PUSH notification (trigger) from a remote WINS
//
typedef enum _COMM_NTF_CMD_E {
		COMM_E_NTF_START_MON = 0,   //sent by PULL thread
		COMM_E_NTF_STOP_MON	    //sent by PUSH thread
		} COMM_NTF_CMD_E, *PCOMM_NTF_CMD_E;

//
// structure of the message sent to the TCP listener thread
//
// There is no need to send the pointer to the Dlg ctx in the message since
// ChkNtfSock() in comm.c can get it from pAssocCtx.  We however send it
// anyway.
//
typedef struct _COMM_NTF_MSG_T {
		COMM_NTF_CMD_E  Cmd_e;
		SOCKET 		SockNo;	 //socket no to stop/start monitoring
		COMM_HDL_T  AssocHdl;
		COMM_HDL_T  DlgHdl;
		} COMM_NTF_MSG_T, *PCOMM_NTF_MSG_T;
		

#if MCAST > 0


typedef struct _COMM_MCAST_MSG_T {
		DWORD  Sign;                    //always 0xABCD
        DWORD  Code;
        BYTE   Body[1];
		} COMM_MCAST_MSG_T, *PCOMM_MCAST_MSG_T;
#endif

/*
	Externals
*/

extern RTL_GENERIC_TABLE	CommAssocTable;     //assoc table
extern RTL_GENERIC_TABLE	CommUdpNbtDlgTable; //tbl for nbt requests (UDP)
extern HANDLE			CommUdpBuffHeapHdl;

/*
 function declarations
*/

#if USENETBT > 0
extern
VOID
CommOpenNbt(
	DWORD FirstBindingIpAddress
    );

extern
STATUS
CommGetNetworkAdd(
	);

#endif

VOID
ECommRegisterAddrChange();

VOID
InitOwnAddTbl(
        VOID
        );

VOID
ECommInit(
	VOID
	);

extern
STATUS
ECommStartDlg(
	PCOMM_ADD_T 	pAdd,  // Address
	COMM_TYP_E 	CommTyp_e,
	PCOMM_HDL_T	pDlgHdl
	);
extern
VOID
ECommSndCmd(
	PCOMM_HDL_T	pDlgHdl,
	MSG_T		pMsg,
	MSG_LEN_T	MsgLen,
	PMSG_T		ppRspMsg,
	PMSG_LEN_T	pRspMsgLen	
	);
extern
STATUS
ECommSndRsp(
	PCOMM_HDL_T  pDlgHdl,
	MSG_T	    pMsg,
	MSG_LEN_T   MsgLen
	);
extern
STATUS
ECommSendMsg(
	PCOMM_HDL_T  	pDlgHdl,
	PCOMM_ADD_T	pAdd,
	MSG_T	  	pMsg,
	MSG_LEN_T  	MsgLen
	);

extern
STATUS
ECommEndDlg(
	PCOMM_HDL_T 	pDlgHdl
	);

extern
VOID
CommEndAssoc(
	PCOMM_HDL_T	pAssocHdl		
	);

extern
LPVOID
CommAlloc(
  PRTL_GENERIC_TABLE	pTable,
  DWORD                 BuffSize
	);

extern
STATUS
ECommAlloc(
  LPVOID *ppBuff,
  DWORD  BuffSize
	);
extern
VOID
ECommDealloc(
  LPVOID pBuff
	);


extern
VOID
CommCreatePorts(
        VOID
           );

extern
VOID
CommInit(
 	VOID
	);


extern
STATUS
CommReadStream(
	IN 	SOCKET  SockNo,
	IN      BOOL	fDoTimedRecv,
	OUT 	PMSG_T 	ppMsg,
	OUT	LPLONG	pBytesRead
	);


extern
VOID
CommCreateTcpThd(VOID);

extern
VOID
CommCreateUdpThd(VOID);




extern
DWORD
ECommCompAdd(PCOMM_ADD_T, PCOMM_ADD_T);

extern
int
__cdecl
ECommCompareAdd(const void *pKey1, const void *pKey2);

extern
STATUS
CommConnect(
    IN  PCOMM_ADD_T pHostAdd,
	IN  SOCKET Port,
	OUT SOCKET *pSockNo
	   );


#if 0
extern
VOID
CommDeallocUdpBuff(
   MSG_T  pMsg
	);
#endif

extern
STATUS
CommReadStream(
	IN 	SOCKET  SockNo,
	IN	BOOL	fDoTimedRecv,
	OUT 	PMSG_T 	ppMsg,
	OUT	LPLONG	pBytesRead
	);

extern
VOID
CommDealloc(
  IN PRTL_GENERIC_TABLE pTable,
  IN PVOID		pBuff
);

#if PRSCONN
extern
__inline
BOOL
CommIsDlgActive(
	PCOMM_HDL_T	pEntHdl
	);

extern
BOOL
CommIsBlockValid(
	PCOMM_HDL_T	pEntHdl
	);
#endif

extern
__inline
STATUS
CommUnlockBlock(
	PCOMM_HDL_T	pEntHdl
	);


extern
BOOL
CommLockBlock(
	PCOMM_HDL_T	pEntHdl
	);

extern
VOID
CommDisc(
	SOCKET SockNo,
    BOOL   fDecCnt
	);
extern
VOID
CommSendUdp (
  SOCKET 	SockNo,
  struct sockaddr_in	*pDest,
  MSG_T   	pMsg,
  MSG_LEN_T     MsgLen
  );

extern
STATUS
CommNbtTcpSnd(
	PCOMM_HDL_T   pAssocHdl,
	MSG_T	  pMsg,
	MSG_LEN_T	  MsgLen
	);

extern
VOID
CommSend(
	COMM_TYP_E	 CommTyp_e,
	PCOMM_HDL_T      pAssocHdl,
	MSG_T	         pMsg,
	MSG_LEN_T	 MsgLen
	);


extern
VOID
CommSendAssoc(
  SOCKET   SockNo,
  MSG_T    pMsg,
  MSG_LEN_T MsgLen
  );


#if PRSCONN
extern
__inline
BOOL
ECommIsDlgActive(
	PCOMM_HDL_T	pEntHdl
	);
extern
__inline
BOOL
ECommIsBlockValid(
	PCOMM_HDL_T	pEntHdl
	);
#endif

extern
VOID
ECommFreeBuff(
	MSG_T		pBuff
	);

extern
BOOL
//VOID
ECommProcessDlg(
	PCOMM_HDL_T	pDlgHdl,
	COMM_NTF_CMD_E  Cmd_e
	);

extern
RTL_GENERIC_COMPARE_RESULTS
CommCompareNbtReq(
 	PRTL_GENERIC_TABLE pTbl,
	PVOID pUdpDlg1,
	PVOID pUdpDlg2
	);

extern
STATUS
ECommGetMyAdd(
	IN OUT PCOMM_ADD_T	pAdd
	);

extern
VOID
CommDecConnCount(
 VOID
 );

#if MCAST > 0
extern
VOID
CommSendMcastMsg(
  DWORD Code
);

extern
VOID
CommLeaveMcastGrp(
  VOID
);

#endif
#ifdef __cplusplus
}
#endif

#endif //_COMM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\com\comm.c ===
/*++
Copyright (c) 1990  Microsoft Corporation

Module Name:

   Comm.c

Abstract:

        This module contains COMSYS's internal functions.  These functions
        are called by commapi functions.

Functions:
        CommCreatePorts
        CommInit
        MonTcp
        MonUdp
        HandleMsg
        CommReadStream
        ProcTcpMsg
        CommCreateTcpThd
        CommCreateUdpThd
        CreateThd
        CommConnect
        CommSend
        CommSendAssoc
        CommDisc
        CommSendUdp
        ParseMsg
        CommAlloc
        CommDealloc
        CompareNbtReq
        CommEndAssoc
        DelAssoc
        CommLockBlock
        CommUnlockBlock
        InitMem
        ChkNtfSock
        RecvData


Portability:
        This module is portable
Author:

   Pradeep  Bahl (pradeepb) 18-Nov-1992

Revision History:

--*/


/*
  Includes
*/
//
// The max. number of connections that can be there to/from WINS.
//
// NOTE NOTE NOTE
//
// We specify a RCVBUF size, based on this value, for the notification socket.
//
#define FD_SETSIZE        300

#include <sys/types.h>
#include <string.h>
#include <stdio.h>
#include "wins.h"

//
// pragma to disable duplicate definition message
//
#pragma warning (disable : 4005)
#include <winsock2.h>
#include <ws2tcpip.h>
#pragma warning (default : 4005)

#include <nb30.h>
#include <nbtioctl.h>
#include <tdi.h>
#include "nms.h"
#include "rpl.h"
#include "comm.h"
#include "assoc.h"
#include "winsthd.h"
#include "winsque.h"
#include "winsmsc.h"
#include "winsevt.h"
#include "winscnf.h"
#if MCAST > 0
#include "rnraddrs.h"
#endif


/*
 defines
*/

#define TCP_QUE_LEN        5    /*Max # of backlog connections that can be
                                 *existent at any time. NOTE: WinsSock
                                 *api can keep a max. of 5 connection req
                                 *in the queue.  So, even if we specified
                                 * a higher number, that wouldn't help.
                                 *For our purposes 5 is enough.
                                 */

#define SPX_QUE_LEN        5     /*Max # of backlog connections that can be*/

//
// These specify the timeout value for select call that is made when
// message/data is expected on a connection
//

//
// We keep the timeout 5 mts for now to give the WINS server we are
// communicating enough time to respond (in case it has been asked to send
// a huge number of records.
//
#define   SECS_TO_WAIT                        300 //5 mts
#define   MICRO_SECS_TO_WAIT                0

#define  TWENTY_MTS                         1200 //20 mts
#define  FIVE_MTS                         TWENTY_MTS/4  //5 mts

//
// The max. number of bytes we can expect in a message from another WINS over
// a tcp connection
//
#define MAX_BYTES_IN_MSG        (RPL_MAX_LIMIT_FOR_RPL * (sizeof(RPL_REC_ENTRY_T) + NMSDB_MAX_NAM_LEN + (RPL_MAX_GRP_MEMBERS * sizeof(COMM_ADD_T))) + 10000 /*pad*/)

#define MCAST_PKT_LEN_M(NoOfIpAdd)  (COMM_MCAST_MSG_SZ -1 + (COMM_IP_ADD_SIZE * (NoOfIpAdd)))
//
// This is the string used for getting the port pertaining to a nameserver
// from the etc\services file (via getserverbyname)
//
#define  NAMESERVER                "nameserver"

/*
 Globals
*/

RTL_GENERIC_TABLE CommUdpNbtDlgTable;  /*table for dialogue blocks created as
                                         *a result of nbt requests received
                                         *over the UDP port
                                         */

BOOL              fCommDlgError = FALSE;  //set to TRUE in ChkNtfSock() fn.
DWORD             CommWinsTcpPortNo = COMM_DEFAULT_IP_PORT;
DWORD             WinsClusterIpAddress = 0;
#if SPX > 0
#define           WINS_IPX_PORT           100
DWORD             CommWinsSpxPortNo;
#endif

/*
 Static variables
*/
#ifdef WINSDBG
#define SOCKET_TRACK_BUFFER_SIZE        20000

DWORD CommNoOfDgrms;        //for testing purposes only.  It counts the
                                //number of datagrams received
DWORD CommNoOfRepeatDgrms;

PUINT_PTR pTmpW;
BOOL   sfMemoryOverrun = FALSE;
LPLONG pEndPtr;
#endif

DWORD   CommConnCount = 0;  //no of tcp connection from/to this WINS
struct timeval  sTimeToWait = {SECS_TO_WAIT, MICRO_SECS_TO_WAIT};

STATIC HANDLE  sNetbtSndEvtHdl;
STATIC HANDLE  sNetbtRcvEvtHdl;
STATIC HANDLE  sNetbtGetAddrEvtHdl;

#if MCAST > 0
#define COMM_MCAST_ADDR  IP_S_MEMBERSHIP  //just pick one in the allowed range
struct sockaddr_in  McastAdd;

#endif

//
// Structures used to store information about partners discovered via
// Multicasting
//
typedef struct _ADD_T {
            DWORD NoOfAdds;
            COMM_IP_ADD_T IpAdd[1];
                  } ADD_T, *PADD_T;

typedef struct _MCAST_PNR_STATUS_T {
                    DWORD   NoOfPnrs;  //no of pnrs in pPnrStatus buffer
                    DWORD   NoOfPnrSlots; //no of pnr slots in pPnrStatus buffer
                    BYTE    Pnrs[1];
                } MCAST_PNR_STATUS_T, *PMCAST_PNR_STATUS_T;

typedef struct _PNR_STATUS_T {
                    COMM_IP_ADD_T  IPAdd;
                    DWORD          State;
                 } PNR_STATUS_T, *PPNR_STATUS_T;

#define MCAST_PNR_STATUS_SIZE_M(_NoOfPnrs) sizeof(MCAST_PNR_STATUS_T) +\
                                           ((_NoOfPnrs) * sizeof(PNR_STATUS_T))

PMCAST_PNR_STATUS_T  pPnrStatus;

//
// To store WINS Addresses
//
PADD_T pWinsAddresses=NULL;  //stores all the IP addresses returned by netbt

/* local function prototypes */
STATIC
DWORD
MonTcp(
        LPVOID
      );
STATIC
DWORD
MonUdp(
        LPVOID
      );
STATIC
VOID
HandleMsg(
        SOCKET         SockNo,
        LPLONG        pBytesRead,
        LPBOOL  pfSockCl
        );


STATIC
VOID
ProcTcpMsg(
        SOCKET   SockNo,
        MSG_T    pMsg,
        MSG_LEN_T MsgLen,
        LPBOOL   pfSockCl
        );

STATIC
VOID
CreateThd(
        DWORD              (*pStartFunc)(LPVOID),
        WINSTHD_TYP_E ThdTyp_e
        );




STATIC
VOID
ParseMsg(
        MSG_T                        pMsg,
        MSG_LEN_T                MsgLen,
        COMM_TYP_E                MsgType,
        struct sockaddr_in         *pFromAdd,
        PCOMMASSOC_ASSOC_CTX_T        pAssocCtx
        );


STATIC
VOID
DelAssoc(
        SOCKET                        SockNo,
        PCOMMASSOC_ASSOC_CTX_T pAssocCtx
        );


STATIC
VOID
InitMem(
        VOID
        );

STATIC
BOOL
ChkNtfSock(
        IN fd_set  *pActSocks,
        IN fd_set  *pRdSocks
        );

STATIC
STATUS
RecvData(
        SOCKET                SockNo,
        LPBYTE                pBuff,
        DWORD                BytesToRead,
        INT                Flags,
        DWORD                SecsToWait,
        LPDWORD                pBytesRead
           );

STATUS
CommTcp(
        IN  PCOMM_ADD_T pHostAdd,
        IN  SOCKET Port,
        OUT SOCKET *pSockNo
        );

#if SPX > 0
STATUS
CommSpx(
        IN  PCOMM_ADD_T pHostAdd,
        IN  SOCKET Port,
        OUT SOCKET *pSockNo
       );
#endif


STATIC
LPVOID
CommHeapAlloc(
  IN PRTL_GENERIC_TABLE pTable,
  IN CLONG                BuffSize
);

STATIC
VOID
CommHeapDealloc(
  IN PRTL_GENERIC_TABLE pTable,
  IN PVOID                pBuff
);

STATIC
NTSTATUS
DeviceIoCtrl(
    IN LPHANDLE         pEvtHdl,
    IN PVOID                pDataBuffer,
    IN DWORD                DataBufferSize,
    IN ULONG            Ioctl
    );

STATIC
VOID
SendNetbt (
  struct sockaddr_in        *pDest,
  MSG_T                   pMsg,
  MSG_LEN_T             MsgLen
 );

#if MCAST > 0
VOID
JoinMcastGrp(
 VOID
);

BOOL
CheckMcastSock(
   IN fd_set  *pActSocks,
   IN fd_set  *pRdSocks
 );

#endif

VOID
CreateTcpIpPorts(
 VOID
);

VOID
CreateSpxIpxPorts(
 VOID
);

BOOL
ChkMyAdd(
 COMM_IP_ADD_T IpAdd
 );


/*
  function definitions start here
*/

VOID
CommCreatePorts(
          VOID
           )

/*++

Routine Description:

 This function creates a TCP and UDP port for the WINS server
 It uses the standard WINS server port # to bind to both the TCP and the UDP
 sockets.

Arguments:

      Qlen           - Length of queue for incoming connects on the TCP port
      pTcpPortHandle - Ptr to SOCKET for the TCP port
      pUdpPortHandle - Ptr to SOCKET for the UDP port
      pNtfSockHandle - Ptr to SOCKET for receiving messages carrying socket
                       handles
      pNtfAdd        - Address bound to Notification socket

Externals Used:
        None

Called by:
        ECommInit

Comments:

        I might want to create a PassiveSock function that would create
        a TCP/UDP port based on its arguments.  This function would then
        be called from MOnTCP and MonUDP.
Return Value:
        None

--*/

{

    CreateTcpIpPorts();
#if SPX > 0
    CreateSpxIpxPorts();
#endif
}

VOID
CreateTcpIpPorts(
 VOID
)
{
    int      Error;
    DWORD    AddLen = sizeof(struct sockaddr_in);
    struct   servent *pServEnt;
    struct   sockaddr_in sin;
    int      SockBuffSize;


    WINSMSC_FILL_MEMORY_M(&sin, sizeof(sin), 0);
    WINSMSC_FILL_MEMORY_M(&CommNtfSockAdd, sizeof(sin), 0);

#if MCAST > 0
    /*
        Allocate a socket for UDP
    */

    if (  (CommUdpPortHandle = socket(
                        PF_INET,
                        SOCK_DGRAM,
                        IPPROTO_UDP
                                 )
          )  == INVALID_SOCKET
       )
    {
        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_UDP_SOCK);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }
    DBGPRINT1(MTCAST, "Udp socket # is (%d)\n", CommUdpPortHandle);
#endif

    sin.sin_family      = PF_INET;               //We are using the Internet
                                                 //family
    if (WinsClusterIpAddress) {
        sin.sin_addr.s_addr = htonl(WinsClusterIpAddress);            //Any network
    } else {
        sin.sin_addr.s_addr = 0; //any network
    }


    if (CommWinsTcpPortNo == COMM_DEFAULT_IP_PORT)
    {
     pServEnt = getservbyname( NAMESERVER,  NULL);
     if (!pServEnt)
     {
        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_UDP_SOCK);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
     }
     sin.sin_port         = pServEnt->s_port;
     CommWinsTcpPortNo    = ntohs(sin.sin_port);
    }
    else
    {
        sin.sin_port      = htons((USHORT)CommWinsTcpPortNo);
    }
    DBGPRINT1(DET, "UDP/TCP port used is (%d)\n", CommWinsTcpPortNo);

#if MCAST > 0

    //
    // Initialize global with mcast address of WINS. Used by SendMcastMsg
    //
    // Do this here as against later since sin gets changed later on
    //
    McastAdd.sin_family      = PF_INET;        //We are using the Internet
                                               //family
    McastAdd.sin_addr.s_addr = ntohl(inet_addr(COMM_MCAST_ADDR));
    McastAdd.sin_port        = sin.sin_port;

    /*
        Bind the  address to the socket
    */
    if ( bind(
          CommUdpPortHandle,
          (struct sockaddr *)&sin,
          sizeof(sin))  == SOCKET_ERROR
       )
    {

        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_WINSOCK_BIND_ERR);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }

#endif

    /*
    *        Allocate a socket for receiving TCP connections
    */
    if ( (CommTcpPortHandle = socket(
                PF_INET,
                SOCK_STREAM,
                IPPROTO_TCP
                                )
          )  == INVALID_SOCKET
       )
    {
        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_TCP_SOCK_FOR_LISTENING);
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }


    /*
     *        Bind the address to the socket
    */
#if 0
     sin.sin_port      = pServEnt->s_port;
     CommWinsTcpPortNo   = ntohs(pServEnt->s_port);
     DBGPRINT1(DET, "TCP port used is (%d)\n", CommWinsTcpPortNo);
#endif
     DBGPRINT1(DET, "TCP port used is (%d)\n", ntohs(sin.sin_port));


    if ( bind(
                CommTcpPortHandle,
                (struct sockaddr *)&sin,
                sizeof(sin)
             ) == SOCKET_ERROR
       )
    {
        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_WINSOCK_BIND_ERR);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
    }

    // Inform the TCP/IP driver of the queue length for connections
    if ( listen(CommTcpPortHandle, TCP_QUE_LEN) == SOCKET_ERROR)
    {
        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_WINSOCK_LISTEN_ERR);
        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
    }

    //
    // Create another socket for receiving socket #s of connections
    // to be added/removed from the list of sockets monitored by the
    // TCP listener thread.  An example of a connection added to the
    // above list is the one initiated by the PULL thread to push update
    // notifications to other WINSs (PULL partners of this thread).  An
    // example of a connection removed is the one on which a PUSH
    // notification (trigger) is received.
    //
    if (  (CommNtfSockHandle = socket(
                                PF_INET,
#if 0
                                SOCK_STREAM,
                                IPPROTO_TCP,
#endif
                                SOCK_DGRAM,
                                IPPROTO_UDP
                                 )
          )  == INVALID_SOCKET
       )
   {
        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_NTF_SOCK);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
   }

    sin.sin_port        = 0;  //Use any available port in the range 1024-5000
    /*
        Bind the  address to the socket
    */
    if ( bind(
          CommNtfSockHandle,
          (struct sockaddr *)&sin,
          sizeof(sin))  == SOCKET_ERROR
       )
    {
        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_WINSOCK_BIND_ERR);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }


    //
    // Let us get the address that we have bound the notification socket to
    //
    if (getsockname(
                        CommNtfSockHandle,
                        (struct sockaddr *)&CommNtfSockAdd,
                        &AddLen
                   ) == SOCKET_ERROR
       )
    {

        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_WINSOCK_GETSOCKNAME_ERR);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }

    //
    // Set the RCVBUF to FD_SETSIZE * 128.  128 is the # of bytes used up
    // per msg by Afd. We can have a max of FD_SETSIZE  connections initiated
    // to and from WINS. So, making the recv buf this size ensures that msgs
    // sent by push thread to the tcp thread will never get dropped.
    //
    // The above size comes out to be 38.4K for an FD_SETSIZE of 300. This
    // is > 8k which the default used by Afd.  Note:  Specifying this does
    // not use up memory.  It is just used to set a threshold.  pmon will
    // show a higher non-paged pool since the number it shows for the same
    // indicates the amount of memory charged to the process (not necessarily
    // allocated
    //
    SockBuffSize = FD_SETSIZE * 128;
    if (setsockopt(
                       CommNtfSockHandle,
                       SOL_SOCKET,
                       SO_RCVBUF,
                       (char *)&SockBuffSize,
                       sizeof(SockBuffSize)) == SOCKET_ERROR)
    {

          Error = WSAGetLastError();
          DBGPRINT1(ERR,  "CommCreatePorts: SetSockOpt failed", Error);
    }

    //
    // Initialize the address structure for this notification socket.
    // We can't use the address returned by getsockname() if the
    // machine we are running on is a multi-homed host.
    //
    // The IP address is in host byte order since we store all addresses in
    // host order.  CommNtfSockAdd will be passed to CommSendUdp which expects
    // the IP address in it to be in host byte order.
    //
    // Note: the Port should be in net byte order
    //

    //
    // The statement within #if 0 and #endif does not work.
    //
    CommNtfSockAdd.sin_addr.s_addr = NmsLocalAdd.Add.IPAdd;

#if 0
    CommNtfSockAdd.sin_addr.s_addr = ntohl(INADDR_LOOPBACK);
#endif

#if MCAST > 0

    JoinMcastGrp();
    CommSendMcastMsg(COMM_MCAST_WINS_UP);
#endif

    return;
}

#if SPX > 0
VOID
CreateSpxIpxPorts(
 VOID
)
{
    int      Error;
    DWORD    AddLen = sizeof(struct sockaddr_ipx);
    struct   servent *pServEnt;
    struct   sockaddr_ipx sipx;
    struct   hostent *pHostEnt;
    BYTE     HostName[80];

    WINSMSC_FILL_MEMORY_M(&sipx, sizeof(sipx), 0);
    WINSMSC_FILL_MEMORY_M(CommNtfAdd, sizeof(sipx), 0);



    /*
     *        Allocate a socket for receiving TCP connections
    */
    if ( (CommSpxPortHandle = socket(
                PF_IPX,
                SOCK_STREAM,
                NSPROTO_SPX
                                )
          )  == INVALID_SOCKET
       )
    {
        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_TCP_SOCK_FOR_LISTENING);
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }


    /*
     *        Bind the address to the socket
    */
    sipx.sa_family    = PF_IPX;
    sipx.sa_port      = ntohs(WINS_IPX_PORT);
CHECK("How do I specify that I want the connection from any interface")

    DBGPRINT1(DET, "SPX port used is (%d)\n", WINS_IPX_PORT);
    CommWinsSpxPortNo   = WINS_IPX_PORT;

    if ( bind(
                CommSpxPortHandle,
                (struct sockaddr *)&sipx,
                sizeof(sipx)
             ) == SOCKET_ERROR
       )
    {
        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_WINSOCK_BIND_ERR);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
    }

    // Inform the TCP/IP driver of the queue length for connections
    if ( listen(CommSpxPortHandle, SPX_QUE_LEN) == SOCKET_ERROR)
    {
        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_WINSOCK_LISTEN_ERR);
        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
    }

    //
    // Create another socket for receiving socket #s of connections
    // to be added/removed from the list of sockets monitored by the
    // TCP listener thread.  An example of a connection added to the
    // above list is the one initiated by the PULL thread to push update
    // notifications to other WINSs (PULL partners of this thread).  An
    // example of a connection removed is the one on which a PUSH
    // notification (trigger) is received.
    //
    if (  (CommIpxNtfSockHandle = socket(
                                PF_IPX,
                                SOCK_DGRAM,
                                NSPROTO_IPX
                                 )
          )  == INVALID_SOCKET
       )
   {
        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_NTF_SOCK);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
   }

    sipx.sa_port        = 0;  //Use any available port in the range 1024-5000
    /*
        Bind the  address to the socket
    */
    if ( bind(
          CommIpxNtfSockHandle,
          (struct sockaddr *)&sipx,
          sizeof(sipx))  == SOCKET_ERROR
       )
    {
        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_WINSOCK_BIND_ERR);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }


    //
    // Let us get the address that we have bound the notification socket to
    //
    if (getsockname(
                        CommIpxNtfSockHandle,
                        (struct sockaddr *)&CommIpxNtfSockAdd,
                        &AddLen
                   ) == SOCKET_ERROR
       )
    {

        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_WINSOCK_GETSOCKNAME_ERR);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }


    //
    // Initialize the address structure for this notification socket.
    // We can't use the address returned by getsockname() if the
    // machine we are running on is a multi-homed host.
    //
    // The IP address is in host byte order since we store all addresses in
    // host order.  *pNtfAdd will be passed to CommSendUdp which expects
    // the IP address in it to be in host byte order.
    //
    // Note: the Port should be in net byte order
    //
#if 0
    if (gethostname(HostName, sizeof(HostName) == SOCKET_ERROR)
    {
        Error = WSAGetLastError();
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }
    if (gethostbyname(HostName, sizeof(HostName) == NULL)
    {
        Error = WSAGetLastError();
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }
#endif

    //
    // The statement within #if 0 and #endif does not work.
    //
    CommIpxNtfSockAdd->sin_addr.s_addr = 0;

#if 0
    pNtfAdd->sin_addr.s_addr = ntohl(INADDR_LOOPBACK);
#endif

    return;
}
#endif


VOID
CommInit(
         VOID
        )

/*++

Routine Description:

        This function initializes all the lists, tables and memory
        used by COMSYS.

Arguments:
        None

Externals Used:
        CommAssocTable
        CommUdpNbtDlgTable
        CommExNbtDlgHdl
        CommUdpBuffHeapHdl


Return Value:
        None

Error Handling:

Called by:
        ECommInit

Side Effects:

Comments:
        None
--*/
{


        PCOMMASSOC_DLG_CTX_T        pDlgCtx = NULL;

        //
        // Do all memory initialization
        //
        InitMem();

        /*
         * Initialize the table that will store the dialogue context blocks
         * for nbt requests received over the UDP port.
        */
        WINSMSC_INIT_TBL_M(
                        &CommUdpNbtDlgTable,
                        CommCompareNbtReq,
                        CommHeapAlloc,
                        CommHeapDealloc,
                        NULL /* table context*/
                         );

        /*
         * Initialize the  critical sections and queue heads
         *
         * The initialization is done in a CommAssoc function instead of here
         * to avoid recursive includes
        */
        CommAssocInit();

        CommExNbtDlgHdl.pEnt = CommAssocAllocDlg();
        pDlgCtx              = CommExNbtDlgHdl.pEnt;

        /*
         * Initialize the explicit nbt dialogue handle
        */
        pDlgCtx->Typ_e          = COMM_E_UDP;
        pDlgCtx->AssocHdl.pEnt  = NULL;
        pDlgCtx->Role_e         = COMMASSOC_DLG_E_EXPLICIT;

#if USENETBT > 0
        //
        // Create two events (one for send and one for rcv to/from netbt)
        //
        WinsMscCreateEvt(NULL, FALSE, &sNetbtSndEvtHdl);
        WinsMscCreateEvt(NULL, FALSE, &sNetbtRcvEvtHdl);
        WinsMscCreateEvt(NULL, FALSE, &sNetbtGetAddrEvtHdl);
#endif

        return;
}  // CommInit()





DWORD
MonTcp(
        LPVOID pArg
      )

/*++

Routine Description:

        This function is the thread startup function for the TCP listener
        thread.  It monitors the TCP port and the connections that have
        been made and received by this process.

        If a connection is received, it is accepted.  If there is data on
        a TCP connection, a function is called to process it.

Arguments:

        pArg - Argument (Not used)

Externals Used:
        CommTCPPortHandle -- TCP port for the process
        CommAssocTable

Called by:
        ECommInit

Comments:
        None

Return Value:

   Sucess status codes --  WINS_SUCCESS
   Error status codes  --  WINS_FAILURE

--*/


{
        struct          sockaddr_in  fsin;      //address of connector
#if SPX > 0
        struct          sockaddr_ipx  fsipx;      //address of connector
#endif
        SOCKET          Port;
        LPVOID          pRemAdd;
        fd_set          RdSocks;         //The read socket set
        fd_set          ActSocks;        //the active socket set
        int             AddLen = sizeof(fsin);  //length of from address
        u_short         No;              //Counter for iterating over the sock
                                         //array
        BOOL            fSockCl = FALSE;         //Was the socket closed ?
        SOCKET          NewSock = INVALID_SOCKET;
        BOOL            fNewAssoc = FALSE;
        DWORD           BytesRead = 0;
        DWORD           Error;
           int          i = 0;                        //for testing purpose only
        SOCKET          SockNo;
        LONG            NoOfSockReady = 0;
        PCOMMASSOC_ASSOC_CTX_T pAssocCtx = NULL;
        STATUS          RetStat = WINS_SUCCESS;
        BOOL            fLimitReached = FALSE;
#ifdef WINSDBG
        PUINT_PTR pTmpSv;
        DWORD  Index = 0;
#endif


        EnterCriticalSection(&NmsTermCrtSec);
        NmsTotalTrmThdCnt++;
        LeaveCriticalSection(&NmsTermCrtSec);


        FD_ZERO(&ActSocks);             //init the Active socket array
        FD_ZERO(&RdSocks);              //init the Read socket array

        FD_SET(CommTcpPortHandle, &ActSocks); /*set the TCP listening socket
                                                handle in the  Active array */
        FD_SET(CommNtfSockHandle, &ActSocks); /*set the Notification socket
                                               *handle in the Active array */
#if MCAST > 0

        if (CommUdpPortHandle != INVALID_SOCKET)
        {
           //
           // We want to monitor multicast packets also
           //
           FD_SET(CommUdpPortHandle, &ActSocks);
           WinsMscAlloc(MCAST_PNR_STATUS_SIZE_M(RPL_MAX_OWNERS_INITIALLY),
                        (LPVOID *)&pPnrStatus
                       );
           pPnrStatus->NoOfPnrs     = 0;
           pPnrStatus->NoOfPnrSlots = RPL_MAX_OWNERS_INITIALLY;
        }
#endif
#if  SPX > 0

        FD_SET(CommSpxPortHandle, &ActSocks); /*set the TCP listening socket
                                                handle in the  Active array */
        FD_SET(CommIpxNtfSockHandle, &ActSocks); /*set the Notification socket
                                               *handle in the Active array */
#endif
#ifdef WINSDBG
        WinsMscAlloc(SOCKET_TRACK_BUFFER_SIZE, &pTmpSv);
        pTmpW = pTmpSv;
        pEndPtr = (LPLONG)((LPBYTE)pTmpSv + SOCKET_TRACK_BUFFER_SIZE);
#endif

LOOPTCP:
try {

        /*
          Loop forever
        */
        while(TRUE)
        {
          BOOL fConnTcp;
          BOOL fConnSpx;

          fConnTcp = FALSE;
          fConnSpx = FALSE;
          /*
              Copy the the active socket array into the
              read socket array.  This is done every time before calling
              select.  This is because select changes the contents of
              the read socket array.
          */
          WINSMSC_COPY_MEMORY_M(&RdSocks, &ActSocks, sizeof(fd_set));

          /*
            Do a blocking select on all sockets in the array (for connections
            and data)
          */
          DBGPRINT1(FLOW, "Rd array count is %d \n", RdSocks.fd_count);
#ifdef WINSDBG
        if (!sfMemoryOverrun)
        {
          if ((ULONG_PTR)(pTmpW + (10 + RdSocks.fd_count)) > (ULONG_PTR)pEndPtr)
          {
               WinsDbg |= 0x3;
               DBGPRINT0(ERR, "MonTcp: Stopping socket tracking to prevent Memory overrun\n")
               sfMemoryOverrun = TRUE;
          }
          else
          {
            *pTmpW++ = RdSocks.fd_count;
            *pTmpW++ = 0xFFFFFFFF;
            for(i = 0; i< (int)RdSocks.fd_count; i++)
            {
                *pTmpW++ = RdSocks.fd_array[i];
                DBGPRINT1(FLOW, "Sock no is (%d)\n", RdSocks.fd_array[i]);
            }
            *pTmpW++ = 0xFFFFFFFF;
          }
        }
#endif
       if (
                (
                        NoOfSockReady = select(
                                            FD_SETSIZE /*ignored arg*/,
                                            &RdSocks,
                                            (fd_set *)0,
                                            (fd_set *)0,
                                            (struct timeval *)0 //Infinite
                                                                //timeout
                                                  )
                ) == SOCKET_ERROR
             )
          {

                Error = WSAGetLastError();
#ifdef WINSDBG
                if (Error == WSAENOTSOCK)
                {
                        DWORD i;
                        PUINT_PTR pW;
                        WinsDbg |= 0x3;
                        DBGPRINT0(ERR, "MonTcp: Memory dump is\n\n");

                        for (i=0, pW = pTmpSv; pW < pTmpW; pW++,i++)
                        {
                          DBGPRINT1(ERR, "|%x|", *pW);
                          if (*pW == 0xEFFFFFFE)
                          {
                              DBGPRINT1(ERR, "Socket closed = (%x)\n",  *++pW);
                          }
                          if ((i == 16) || (*pW == 0xFFFFFFFF))
                          {
                            DBGPRINT0(ERR, "\n");
                          }

                        }
                        DBGPRINT0(ERR, "Memory Dump End\n");
                }
#endif

                //
                // If state is not terminating, we have an error.  If
                // it is terminating, then the reason we got an error
                // from select is because the main thread closed the
                // TCP socket. In the latter case, we pass WINS_SUCCESS
                // to WinsMscTermThd so that we don't end up signaling
                // the main thread prematurely.
                //
                if (
                          (WinsCnf.State_e == WINSCNF_E_RUNNING)
                                       ||
                          (WinsCnf.State_e == WINSCNF_E_PAUSED)
                   )
                {
                        ASSERT(Error != WSAENOTSOCK);
                        WINSEVT_LOG_D_M( Error, WINS_EVT_WINSOCK_SELECT_ERR );
                        RetStat = WINS_FAILURE;
                }
                else
                {
                  //
                  // State is terminating.  Error should
                  // be WSENOTSOCK
                  //
                  //ASSERT(Error == WSAENOTSOCK);
                }

                WinsThdPool.CommThds[0].fTaken = FALSE;
                WinsMscTermThd(RetStat, WINS_NO_DB_SESSION_EXISTS);
          }
          else
          {


             DBGPRINT1(FLOW, "Select returned with success. No of Sockets ready - (%d) \n", NoOfSockReady);
             /*
                if a connection has been received on the TCP port, accept it
                and change the active socket array
             */
             if (FD_ISSET(CommTcpPortHandle, &RdSocks))
             {
                    fConnTcp = TRUE;
                    Port = CommTcpPortHandle;
                    pRemAdd = &fsin;
             }
#if SPX > 0
             else
             {
                 if (FD_ISSET(CommSpxPortHandle, &RdSocks))
                 {
                    fConnSpx = TRUE;
                    Port = CommSpxPortHandle;
                    pRemAdd = &fsipx;
                 }

             }
#endif
             if (fConnTcp || fConnSpx)
             {
                DWORD  ConnCount;
                //
                // Note: FD_SET can fail silently if the fd_set array is
                // full. Therefore we should check this. Do it here instead
                // of after the accept to save on network traffic.
                //
                ConnCount = InterlockedExchange(&CommConnCount, CommConnCount);
                //if (ActSocks.fd_count >= FD_SETSIZE)

#ifdef WINSDBG
                if (ConnCount >= 200)
                {
                        DBGPRINT0(ERR,
                                "MonTcp: Connection limit of 200 reached. \n");
                }
#endif

#if 0
                if (ConnCount >= FD_SETSIZE)
                {
                        DBGPRINT1(ERR,
                                "MonTcp: Connection limit of %d reached. No accept being done\n",
                                                FD_SETSIZE);
                        WINSEVT_LOG_D_M(ConnCount,
                                        WINS_EVT_CONN_LIMIT_REACHED);
                        fLimitReached = TRUE;
                }
#endif

                DBGPRINT0(FLOW, "Going to do an accept now\n");
                if ( (NewSock = accept(
                                Port,
                                (struct sockaddr *)pRemAdd,
                                &AddLen
                                      )
                     ) == INVALID_SOCKET
                   )
                {
                    Error = WSAGetLastError();
                   if (WinsCnf.State_e !=  WINSCNF_E_TERMINATING)
                   {
                    WINSEVT_LOG_M(
                                Error,
                                WINS_EVT_WINSOCK_ACCEPT_ERR,
                                       );
                   }
                   WinsThdPool.CommThds[0].fTaken = FALSE;
                   WinsMscTermThd(
                      (((Error == WSAEINTR) || (Error == WSAENOTSOCK)) ?
                                WINS_SUCCESS : WINS_FAILURE),
                                WINS_NO_DB_SESSION_EXISTS);
                }

                DBGPRINT1(FLOW, "New Sock value is (%d)\n", NewSock);
                if (fLimitReached)
                {
FUTURES("Move this into CommDisc -- add a flag to it to indicate abrupt stop")
                      struct linger Linger;
                      Linger.l_onoff = 0;
                      if (setsockopt(
                               NewSock,
                               SOL_SOCKET,
                               SO_DONTLINGER,
                               (char *)&Linger,
                               sizeof(Linger)) == SOCKET_ERROR)
                      {

                        Error = WSAGetLastError();
                        DBGPRINT1(ERR,
                                "MonTcp: SetSockOpt failed", Error);
                      }
                      fLimitReached = FALSE;
                      CommDisc(NewSock, FALSE);  //close the socket
                      continue;
                }

                FD_SET(NewSock, &ActSocks);
                InterlockedIncrement(&CommConnCount);
#ifdef WINSDBG
                /*
                 * Let us see if the assoc. is there or not.  It shouldn't be
                 * but let us check anyway (robust programming).
                */
                pAssocCtx = CommAssocLookupAssoc( NewSock );

                if (!pAssocCtx)
                {
#endif
                        pAssocCtx = CommAssocCreateAssocInTbl(NewSock);

                        if (!pAssocCtx)
                        {
                           WINSEVT_LOG_D_M(
                                               WINS_OUT_OF_MEM,
                                               WINS_EVT_CANT_ALLOC_RSP_ASSOC,
                                              );
                           WinsMscTermThd(WINS_FAILURE, WINS_NO_DB_SESSION_EXISTS);
                        }

#ifdef WINSDBG
                }
                else
                {
                        DBGPRINT0(ERR, "MonTcp: Not a new assoc. Weird\n");

                        //
                        // log an error (Cleanup was not done properly)
                        //
                        return(WINS_FAILURE);

                }
#endif
                pAssocCtx->State_e     = COMMASSOC_ASSOC_E_NON_EXISTENT;
                pAssocCtx->Role_e      = COMMASSOC_ASSOC_E_RESPONDER;
                pAssocCtx->DlgHdl.pEnt = NULL;

                if (fConnTcp)
                {
                   pAssocCtx->RemoteAdd.sin_addr.s_addr =
                                        ntohl(fsin.sin_addr.s_addr);
                   pAssocCtx->AddTyp_e = COMM_ADD_E_TCPUDPIP;
                }
#if SPX > 0
                else
                {
                   RtlCopyMemory(
                         pAssocCtx->RemoteAddSpx.sa_netnum,
                         fsipx.netnum,
                         sizeof(fsipx.netnum);
                   RtlCopyMemory(
                         pAssocCtx->RemoteAddSpx.sa_nodenum,
                         fsipx.nodenum,
                         sizeof(fsipx.nodenum);
                   pAssocCtx->AddTyp_e = COMM_ADD_E_SPXIPX;
                }
#endif
             }
             else  /* one or more sockets has received data or a disconnect*/
             {

#if MCAST > 0

                if (CheckMcastSock(&ActSocks, &RdSocks) == TRUE)
                {
                     continue;
                }
#endif
                //
                // Check if the notification socket has data in it
                // If yes, continue.
                //
                if (ChkNtfSock(&ActSocks, &RdSocks))
                {
                        DBGPRINT0(FLOW,
                           "MonTcp: Notification socket had data in it\n");
                        continue;
                }

                /*
                 * Handle sockets that have been set.  These could have
                 * been set either because there is data on them or
                 * due to disconnects.
                */
                for(No = 0; No < RdSocks.fd_count; ++No)
                {

                  SockNo = RdSocks.fd_array[No];
                  if (FD_ISSET(SockNo, &RdSocks))
                  {
                        BytesRead = 0;
                        fSockCl   = FALSE;

                        DBGPRINT1(FLOW, "MonTcp: Socket (%d) was signaled. It has either data or a disconnect on it\n",
                                SockNo);

                        /*
                         * Socket has data on it or a disconnect.  Call
                         * HandleMsg to handle either case
                        */
                        (VOID)HandleMsg(SockNo, &BytesRead, &fSockCl);

                        /*
                         * if the socket was closed due to a stop message
                         * having been received, let us clean up the
                         * socket array
                        */
                        if (fSockCl)
                        {
                           DBGPRINT1(FLOW, "MonTcp: Sock (%d) was closed\n",
                                        SockNo);
                           FD_CLR(SockNo, &ActSocks);
                        }
                        else
                        {

                          /*
                           * if bytes read are 0, we have a disconnect
                           * All the processing for the disconnect should
                           * have been handled by HandleMsg.  We just need
                           * to close the socket and update the socket
                           * array appropriately.
                           */

                           if (BytesRead == 0)
                           {
                               DBGPRINT0(FLOW,
                                   "MonTcp: Received a disconnect\n");
                               //CommDisc(SockNo, TRUE);
                               FD_CLR(SockNo, &ActSocks);
                            }
                        }
                  }

              } //for (loop over all sockets)

             } //else (one or more sockets has received data or a disconnect
           } //else clause (if select () < 0)
        } // while (TRUE) loop end

  }  // end of try {}
except (EXCEPTION_EXECUTE_HANDLER)  {

        DBGPRINTEXC("MONTCP");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_TCP_LISTENER_EXC);

#if 0
        //
        // Don't use WinsMscTermThd here
        //
        ExitThread(WINS_FAILURE);
#endif
  }
        goto LOOPTCP;  //ugly but useful

        UNREFERENCED_PARAMETER(NoOfSockReady);

        // we should never hit this return
        ASSERT(0);
        return(WINS_FAILURE);
}

DWORD
MonUdp(
        LPVOID pArg
        )

/*++

Routine Description:
        This function is the thread startup function for the UDP listener
        thread.  It monitors the UDP port for UDP messages.

Arguments:
        pArg - Argument (not used)

Externals Used:
        CommUDPPortHandle -- UDP port for the process

Called by:
        ECommInit

Comments:
        None

Return Value:

   Success status codes --
   Error status codes  --

--*/

{


        register LPBYTE               pBuffer;
        struct sockaddr_in            FromAdd;
        int                           AddLen   = sizeof(FromAdd);
        register PCOMM_BUFF_HEADER_T  pBuffHdr = NULL;


        DWORD   DataBuffLen;
        tREM_ADDRESS *pRemAdd;
        NTSTATUS   NTStatus;

LOOP:
try {
        while(TRUE)
        {

          //
          // Allocate a buffer to get the datagram.  This buffer is prefixed
          // by the COMM_BUFF_HEADER_T and tREM_ADDRESS structure.
          //
          pBuffHdr = WinsMscHeapAlloc (
                            CommUdpBuffHeapHdl,
                            COMM_DATAGRAM_SIZE + sizeof(COMM_BUFF_HEADER_T)
                                + COMM_NETBT_REM_ADD_SIZE
                                        );
          DBGPRINT2(HEAP, "MonUdp: HeapHdl = (%p), pBuffHdr=(%p)\n",
                                        CommUdpBuffHeapHdl, pRemAdd);




          pBuffHdr->Typ_e = COMM_E_UDP;

          //
          // Adjust pointer to point to the Remote address header
          //
          pRemAdd = (tREM_ADDRESS *)
                        ((LPBYTE)pBuffHdr + sizeof(COMM_BUFF_HEADER_T));

          DataBuffLen =  COMM_DATAGRAM_SIZE + COMM_NETBT_REM_ADD_SIZE;
          //
          // Point to the data portion (passed to ParseMsg)
          //
          pBuffer         = (LPBYTE)pRemAdd + COMM_NETBT_REM_ADD_SIZE;

          //
          // read a datagram prefixed with the address of the sender from
          // nbt
          //
          NTStatus = DeviceIoCtrl(
                                    &sNetbtRcvEvtHdl,
                                    pRemAdd,
                                    DataBuffLen,
                                    IOCTL_NETBT_WINS_RCV
                                    );

         if (!NT_SUCCESS(NTStatus))
         {

                //
                // log the message only if WINS is not terminating
                //
                if (WinsCnf.State_e != WINSCNF_E_TERMINATING)

                {
                   //
                   // We do not log the message if the Netbt handle is NULL
                   // We can have a small window when the handle may be NULL
                   // This happens when we get an address/device change
                   // notification.  WINS closes the old handle and opens
                   // a new one after such an event if the machine has a
                   // a valid address that WINS can bind with. The address
                   // notification can occur due to ipconfig /release and
                   // /renew or due to psched being installed/removed.
                   //
                   if (WinsCnfNbtHandle != NULL)
                   {
                      WINSEVT_LOG_D_M(
                                NTStatus,
                                WINS_EVT_NETBT_RECV_ERR
                                   );
                   }
                   DBGPRINT1(ERR, "MonUdp:  Status = (%x)\n", NTStatus);
                   WinsMscHeapFree( CommUdpBuffHeapHdl, pBuffHdr);
                   Sleep(0);      //relinquish the processor
                   continue;
                }
                else
                {

                   DBGPRINT0(ERR, "MonUdp, Exiting Thread\n");


                   WinsThdPool.CommThds[1].fTaken = FALSE;
#if TEST_HEAP > 0
                   WinsMscHeapDestroy(CommUdpBuffHeapHdl);
                   DBGPRINT0(ERR, "MonUdp: Destroyed udp buff heap\n");
                   WinsMscHeapDestroy(CommUdpDlgHeapHdl);
                   DBGPRINT0(ERR, "MonUdp: Destroyed udp dlg buff heap\n");
#endif
                   return(WINS_FAILURE);
                }
           }
#ifdef WINSDBG
          ++CommNoOfDgrms;
          DBGPRINT1(FLOW, "UDP listener thread: Got  datagram (from NETBT) no = (%d)\n", CommNoOfDgrms);

//          DBGPRINT1(SPEC, "UDP listener thread: Got  datagram (from NETBT) no = (%d)\n", CommNoOfDgrms);
#endif



           //
           // NETBT returns the same code as is in winsock.h for the
           // internet family.  Also, port and IpAddress returned are
           // in network order
           //
           FromAdd.sin_family            = pRemAdd->Family;
           FromAdd.sin_port              = pRemAdd->Port;
           FromAdd.sin_addr.s_addr = ntohl(pRemAdd->IpAddress);

           // from now on the memory allocated for pBuffHdr is passed down the way so consider it handled there
           // There is basically no chance to hit an exception (unless everything is really messed up - like no mem)
           // in ParseMsg before having this buffer passed down to a different thread for processing.
           pBuffHdr = NULL;
          /*
           * process message
          */
            (void)ParseMsg(
                        pBuffer,
                        COMM_DATAGRAM_SIZE,
                        COMM_E_UDP,
                        &FromAdd,
                        NULL
                        );

        } //end of while(TRUE)

  } // end of try {..}
 except(EXCEPTION_EXECUTE_HANDLER) {

        DWORD ExcCode = GetExceptionCode();
        DBGPRINT1(EXC, "MonUdp: Got Exception (%X)\n", ExcCode);
        if (ExcCode == STATUS_NO_MEMORY)
        {
                //
                //If the exception is due to insufficient resources, it could
                // mean that WINS is not able to keep up with the fast arrivel
                // rate of the datagrams. In such a case drop the datagram.
                //
                WINSEVT_LOG_M( WINS_OUT_OF_HEAP, WINS_EVT_CANT_ALLOC_UDP_BUFF);
        }
        else
        {
                WINSEVT_LOG_M(ExcCode, WINS_EVT_UDP_LISTENER_EXC);
        }
PERF("Check how many cycles try consumes. If negligeble, move try inside the")
PERF("the while loop")
#if 0
        //Don't use WinsMscTermThd here
        ExitThread(WINS_FAILURE);
#endif
        } // end of exception

        if (pBuffHdr != NULL)
            WinsMscHeapFree(CommUdpBuffHeapHdl, pBuffHdr);

        goto LOOP;        //ugly but useful

        //
        // we should never hit this return
        //
        ASSERT(0);
        return(WINS_FAILURE);
}


VOID
HandleMsg(
        IN  SOCKET         SockNo,
        OUT LPLONG        pBytesRead,
        OUT LPBOOL          pfSockCl
        )

/*++

Routine Description:

        This function is called to read in a message or a disconnect from
        a socket and handle either appropriately.
        If there were no bytes received on the socket, tt
        does the cleanup

        The bytes read are handed to ProcTcpMsg function.

Arguments:

        SockNo     - Socket to read data from
        pBytesRead - # of bytes that were read
        fSockCl    - whether the socket is in closed condition

Externals Used:
        None

Called by:

        MonTcp

Comments:
        None

Return Value:
        None
--*/
{

        MSG_T    pMsg;
        STATUS   RetStat;

        /*
        *  Read in the message from the socket
        */
        // ---ft: 06/16/2000---
        // The second parameter to the call below has to be TRUE (timed receive).
        // If it is not so (it was FALSE before this moment) the following scenario
        // could happen.
        // An attacher creates a TCP socket and connects it to port 42 to any
        // WINS server and then sends 4 or less bytes on that socket. He leaves the
        // connection open (doesn't close the socket) and simply unplug his net cable.
        // Then he kills his app. Although his end of the connection terminates, WINS
        // will have no idea about that (since the cable is disconnected) and will
        // remain blocked in the call below (CommReadStrea->RecvData->recv) indefinitely
        //
        // Consequences:
        // - WINS will never be able again to listen on the TCP port 42: push/pull replication
        // is brought down along with the consistency checking.
        // - WINS will not be able to terminate gracefully (in case the administrator attempts
        // to shut down the service and restart it) because the MonTcp thread is in a hung state
        //
        // The same could happen in more usual cases (not necesarily on an intenional attack):
        // While sending Push notification (which happens quite often):
        // 1) the pusher is powered down (power outage)
        // 2) the pusher hits a PnP event like media disconnect or adapter disabled
        // 3) some router is down between the pusher and the receiving WINS.
        //
        // With this fix the best we can do for now is to have MonTcp thread recover in 20mts.
        // Even better would be to log an event.
        RetStat = CommReadStream(
                                  SockNo,
                                  TRUE,  //don't do timed recv
                                  &pMsg,
                                  pBytesRead
                                );

        //
        // if either RetStat is not WINS_SUCCESS or the number of bytes
        // read are 0, we need to delete the association and close the
        // socket.  Further, we need to set *pfSockCl to TRUE to indicate
        // to the caller (MonTcp) that it should get rid of the socket
        // from its array of sockets.
        //
        if ((RetStat != WINS_SUCCESS) || (*pBytesRead == 0))
        {
                /*
                 * No bytes received.  This means that it is a disconnect
                * Let us get rid of the context associated with  the socket
                */
                DelAssoc(
                           SockNo,
                           NULL /* we don't have the ptr to assoc block*/
                        );

                CommDisc(SockNo, TRUE);
                *pfSockCl = TRUE;
        }
        else   // means (RetStat == WINS_SUCCESS) and (*pBytesRead > 0)
        {
                ASSERT(*pBytesRead > 0);

                /*
                 *                process the message
                */
                ProcTcpMsg(
                           SockNo,
                           pMsg,
                           *pBytesRead,
                           pfSockCl
                          );
        }
        return;
}  // HandleMsg()


STATUS
CommReadStream(
        IN         SOCKET  SockNo,
        IN         BOOL        fDoTimedRecv,
        OUT         PMSG_T         ppMsg,
        OUT        LPLONG        pBytesRead
        )

/*++

Routine Description:

        This function reads from a TCP socket.  If there are no bytes
        there, it means a disconnect was received on that socket.

Arguments:
        SockNo     - Socket to read data from
        fDoTimedRecv - Whether timed receive should be done (set to TRUE only
                     if we are not sure whether data has arrived or not yet)
        ppMsg      - Buffer containing data that was read in
        pBytesRead - Size of buffer


Return Value:

    TBS

--*/

{
        u_long          MsgLen;
        LONG          BytesToRead;
        INT          Flags        = 0; /*flags for recv call (PEEK and/or OOB).
                                     * we want neither
                                    */
        WINS_MEM_T               WinsMem[2];
        PWINS_MEM_T              pWinsMem = WinsMem;
        STATUS                         RetStat;
        PCOMM_BUFF_HEADER_T  pBuffHdr;

        DBGENTER("CommReadStream\n");
        pWinsMem->pMem = NULL;

#ifdef WINSDBG
try {
#endif

        /*
         * All TCP messages are preceded by a length word (4 bytes) that
         * gives the length of the message that follows.   Read the length
         * bytes.
        */
        RetStat  = RecvData(
                                SockNo,
                                 (LPBYTE)&MsgLen,
                                  sizeof(u_long),
                                  Flags,
                                fDoTimedRecv ? TWENTY_MTS : fDoTimedRecv,
                                pBytesRead
                                );


        /*
         * Check if there was an error in reading.  We will have a RetStat
         * of WINS_SUCCESS even if 0 bytes (meaning a disconnect) were read
         * in
        */
        if (RetStat == WINS_SUCCESS)
        {
            if (*pBytesRead != 0)
            {
               COMM_NET_TO_HOST_L_M(MsgLen, MsgLen);

               //
               // Just making sure that the message length did not get
               // corrupted on the way. Also, this is a good guard against
               // a process that is trying to bring us down.
               //
               if (MsgLen <= MAX_BYTES_IN_MSG)
               {
                    /*
                     * Allocate memory for the buffer. Allocate extra space
                     * at the top to store the Header for the buffer.  This
                     * header is used to store information about the buffer.
                     * (See ECommFreeBuff also)
                    */
                    *ppMsg = WinsMscHeapAlloc(
                                CommAssocTcpMsgHeapHdl,
                                MsgLen +
#if USENETBT > 0
                                   COMM_NETBT_REM_ADD_SIZE +
#endif
                                  sizeof(COMM_BUFF_HEADER_T) + sizeof(LONG)
                            );
                    //
                    // if *ppMsg is NULL, it means that we received garabage
                    // in the first 4 bytes.  It should have been the length
                    // of the message.
                    //
                    if (*ppMsg == NULL)
                    {
                        //
                        // return with *pBytesRead = 0
                        //
                        *pBytesRead = 0;
                        return(WINS_FAILURE);
                    }

                    pWinsMem->pMem = *ppMsg;
                    (++pWinsMem)->pMem   = NULL;

                    /*
                     * Increment pointer past the buffer header and field
                     *  storing  the length of the message.
                    */
                    pBuffHdr =  (PCOMM_BUFF_HEADER_T)(*ppMsg + sizeof(LONG));
                    *ppMsg   = *ppMsg +
#if USENETBT > 0
                          COMM_NETBT_REM_ADD_SIZE +
#endif
                          sizeof(COMM_BUFF_HEADER_T) + sizeof(LONG);
#if 0
                    pBuffHdr =
                     (PCOMM_BUFF_HEADER_T)(*ppMsg - sizeof(COMM_BUFF_HEADER_T));
#endif

                    pBuffHdr->Typ_e = COMM_E_TCP;  //store type of buffer info
                    BytesToRead     = MsgLen;

                    /*
                      *  Read the whole message into the allocated buffer
                    */
                    RetStat = RecvData(
                                        SockNo,
                                        *ppMsg,
                                        BytesToRead,
                                        Flags,
                                        fDoTimedRecv ? FIVE_MTS : fDoTimedRecv,
                                        pBytesRead
                                    );
                    //
                    // If no bytes were read, deallocate memory
                    //
                    if ((*pBytesRead == 0) || (RetStat != WINS_SUCCESS))
                    {
                        ECommFreeBuff(*ppMsg);
                    }
              }
              else
              {
                  DBGPRINT1(ERR, "CommReadStream: Message size (%x) is TOO BIG\n", MsgLen);
                  WINSEVT_LOG_M(MsgLen, WINS_EVT_MSG_TOO_BIG);
                  *pBytesRead = 0;
              }
           }
        } // if (RetStat == WINS_SUCCESS)
#ifdef WINSDBG
        else
        {
                //
                // *pBytesRead = 0 is a valid condition.  It indicates a
                // disconnect from the remote WINS
                //
        }
#endif
#ifdef WINSDBG
  } // end of try { .. }
except (EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("CommReadStream");
                WINS_HDL_EXC_M(WinsMem);
                WINS_RERAISE_EXC_M();
        }
#endif
        DBGLEAVE("CommReadStream\n");
        return(RetStat);
} //CommReadStream()


VOID
ProcTcpMsg(
        IN  SOCKET   SockNo,
        IN  MSG_T    pMsg,
        IN  MSG_LEN_T MsgLen,
        OUT LPBOOL   pfSockCl
        )

/*++

Routine Description:

        This function processes a TCP message after it has been read in
Arguments:
        SockNo - Socket on which data was received
        pMsg   - Buffer containing data
        MsgLen - Size of buffer
        pfSockCl - Flag indicating whether the socket was closed

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        HandleMsg

Side Effects:

Comments:
        None
--*/

{
#if SUPPORT612WINS > 0
   BYTE                                        AssocMsg[COMMASSOC_POST_BETA1_ASSOC_MSG_SIZE];
#else
   BYTE                                        AssocMsg[COMMASSOC_ASSOC_MSG_SIZE];
#endif

   DWORD                          Opc;
   DWORD                          MsgTyp;
   DWORD                             MsgSz = sizeof(AssocMsg);
   PCOMMASSOC_ASSOC_CTX_T   pAssocCtx;
   PCOMMASSOC_DLG_CTX_T     pDlgCtx;
   BOOL                     fAssocAV = FALSE;

   DBGENTER("ProcTcpMsg\n");

//#ifdef WINSDBG
try {
//#endif

   /*
        Get the opcode and check whether it is an NBT message or a
        message from a WINSS.
   */
   if (NMSISNBT_M(pMsg))
   {
           /*
        * Get the assoc. ctx block associated with the socket
           */
           if ( (pAssocCtx = CommAssocLookupAssoc(SockNo) ) == NULL )
           {
                ECommFreeBuff(pMsg);
                WINSEVT_LOG_D_M(WINS_FAILURE, WINS_EVT_CANT_LOOKUP_ASSOC);
                WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
           }


        if (pAssocCtx->DlgHdl.pEnt == NULL)
        {
                pDlgCtx = CommAssocAllocDlg();

                //
                // The following will initialize the dlg and assoc ctx
                // blocks.  The association will be marked ACTIVE.
                //
                COMMASSOC_SETUP_COMM_DS_M(
                        pDlgCtx,
                        pAssocCtx,
                        COMM_E_NBT,
                        COMMASSOC_DLG_E_IMPLICIT
                                  );
        }

           /*
             * Parse the message
           */
           ParseMsg(
                  pMsg,
                  MsgLen,
                  pAssocCtx->Typ_e,
                  &pAssocCtx->RemoteAdd,
                  pAssocCtx
                );
   }
   else /*message from WINS */
   {
        ULONG uLocalAssocCtx;

        COMM_GET_HEADER_M(pMsg, Opc, uLocalAssocCtx, MsgTyp);

        DBGPRINT1(REPL,"ProcTcpMsg: Got Wins msg with tag %08x.\n", uLocalAssocCtx);

        pAssocCtx = (PCOMMASSOC_ASSOC_CTX_T)CommAssocTagMap(&sTagAssoc, uLocalAssocCtx);

        /*
          If the ptr to my assoc. ctx block is NULL, it means that
          this is the "start asssoc req" message from the remote WINS.

          We don't need to check MsgTyp but are doing it anyway for more
          robust error checking
        */
        if ((pAssocCtx == NULL) && (MsgTyp == COMM_START_REQ_ASSOC_MSG))
        {

            /*
             Get the assoc. ctx block associated with the socket
                */

                if ( (pAssocCtx = CommAssocLookupAssoc(SockNo)) == NULL )
                {
                        ECommFreeBuff(pMsg);
                        WINSEVT_LOG_D_M(WINS_FAILURE, WINS_EVT_CANT_LOOKUP_ASSOC);
                        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
                }

            /*
                       Unformat the assoc. message.  This function will return
                       with an error status if the message received is not
                 a start assoc. message.
            */
            CommAssocUfmStartAssocReq(
                        pMsg,
                        &pAssocCtx->Typ_e,
                        &pAssocCtx->MajVersNo,
                        &pAssocCtx->MinVersNo,
                        &pAssocCtx->uRemAssocCtx
                                     );

#if SUPPORT612WINS > 0
            if (MsgLen >= (COMMASSOC_POST_BETA1_ASSOC_MSG_SIZE - sizeof(LONG)))
            {
               pAssocCtx->MajVersNo = WINS_BETA2_MAJOR_VERS_NO;
            }
#endif
            //
            // Free the buffer read in.
            //
            ECommFreeBuff(pMsg);

            /*
                check if association set up params specified in the
                message are acceptable.
             */
            //
            // if the version numbers do not match, terminate the association
            // and log a message
            //
#if SUPPORT612WINS > 0
            if (pAssocCtx->MajVersNo != WINS_BETA2_MAJOR_VERS_NO)
            {
#endif
             if (pAssocCtx->MajVersNo != WINS_MAJOR_VERS)
             {

                DelAssoc(0, pAssocCtx);
                CommDisc(SockNo, TRUE);
                *pfSockCl = TRUE;
                //CommDecConnCount();
                WINSEVT_LOG_M(pAssocCtx->MajVersNo, WINS_EVT_VERS_MISMATCH);
                   DBGLEAVE("ProcTcpMsg\n");
                return;
             }
#if SUPPORT612WINS > 0
            }
#endif

FUTURES("When we support more sophisticated association set up protocol")
FUTURES("we will check the params.  A more sophisticated set up protocol")
FUTURES("is one where there is some negotiation going one. Backward")
FUTURES("compatibility is another item which would require it")

             /*
              *        Format a start assoc. response message.
              *
              *        The address passed to the formatting function is offset
              *        from the address of the buffer by a LONG so that
              *        CommSendAssoc can store the length of the message in it.
             */
             CommAssocFrmStartAssocRsp(
                                       pAssocCtx,
                                       AssocMsg + sizeof(LONG),
                                       MsgSz - sizeof(LONG)
                                      );


             CommSendAssoc(
                        pAssocCtx->SockNo,
                        AssocMsg + sizeof(LONG),
                        MsgSz - sizeof(LONG)
                        );


             //
             // Allocate the dlg and initialize the assoc and dlg ctx blocks.
             // The association is marked ACTIVE
             //
             pDlgCtx = CommAssocAllocDlg();
             COMMASSOC_SETUP_COMM_DS_M(
                        pDlgCtx,
                        pAssocCtx,
                        pAssocCtx->Typ_e,
                        COMMASSOC_DLG_E_IMPLICIT
                                  );

        }
        else /*the assoc has to be in the ACTIVE state        */
        {

           /*
            Let us check that this is not the stop assoc message
           */
           if (MsgTyp == COMM_STOP_REQ_ASSOC_MSG)
           {

                fAssocAV = TRUE;
                DelAssoc(0, pAssocCtx);
                fAssocAV = FALSE;
                ECommFreeBuff(pMsg);
                CommDisc(SockNo, TRUE);
                *pfSockCl = TRUE;
                //CommDecConnCount();
           }
           else
           {
PERF("Remove this test")
CHECK("Is there any need for this test")
              fAssocAV = TRUE;
              if (pAssocCtx->State_e == COMMASSOC_ASSOC_E_NON_EXISTENT)
              {
                fAssocAV = FALSE;
                ECommFreeBuff(pMsg);
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_BAD_STATE_ASSOC);
                DelAssoc(0, pAssocCtx);
                CommDisc(SockNo, TRUE);
                *pfSockCl = TRUE;
//                CommDecConnCount();
                WINS_RAISE_EXC_M(WINS_EXC_BAD_STATE_ASSOC);
              }
              else
              {
                fAssocAV = FALSE;
              }

                 /*
                   *  Parse the message header to determine what message it is.
                 */
                 ParseMsg(
                        pMsg,
                        MsgLen,
                        pAssocCtx->Typ_e,
                          &pAssocCtx->RemoteAdd,  //not used
                        pAssocCtx
                       );
          } //else (msg is not stop assoc msg)
       } //else (assoc is active)
    } // else (message is from a remote wins
//#ifdef WINSDBG
  } // end of try block
 except(EXCEPTION_EXECUTE_HANDLER) {
                DWORD ExcCode = GetExceptionCode();
FUTURES("Distinguish between different exceptions. Handle some. Reraise others")
                DBGPRINT1(EXC, "ProcTcpMsg: Got Exception (%x)\n", ExcCode);
                WINSEVT_LOG_D_M(ExcCode, WINS_EVT_SFT_ERR);
                if (ExcCode == WINS_EXC_COMM_FAIL)
                {
                     DelAssoc(0, pAssocCtx);
                     CommDisc(SockNo, TRUE);
                     *pfSockCl = TRUE;
//                     CommDecConnCount();
                }
                if (fAssocAV)
                {
                      ECommFreeBuff(pMsg);
                      // Without the following the assoc and the tcp connection
                      // will stay until either the tcp connection gets a valid
                      // message (one with the correct pAssocCtx) or it gets
                      // terminated
#if 0
                      DelAssoc(SockNo, NULL);
                      CommDisc(SockNo, TRUE);
                      *pfSockCl = TRUE;
    //                  CommDecConnCount();
#endif
                }

        //        WINS_RERAISE_EXC_M();
        }
//#endif


           DBGLEAVE("ProcTcpMsg\n");
        return;
} //ProcTcpMsg()

VOID
CommCreateTcpThd(
        VOID
        )

/*++

Routine Description:
        This function creates the TCP listener thread

Arguments:
        None


Externals Used:
        None

Called by:
        CommInit

Comments:

Return Value:
        None
--*/

{
        CreateThd(MonTcp, WINSTHD_E_TCP);
        return;
}

VOID
CommCreateUdpThd(VOID)

/*++

Routine Description:
        This function creates the UDP listener thread

Arguments:
        None


Externals Used:
        None

Called by:
        CommInit

Comments:

Return Value:
        None

--*/

{
        CreateThd(MonUdp, WINSTHD_E_UDP);
        return;
}


VOID
CreateThd(
        DWORD              (*pStartFunc)(LPVOID),
        WINSTHD_TYP_E ThdTyp_e
        )
/*++

Routine Description:

        This function creates a  COMSYS thread and initializes the
        context for it.

Arguments:
        pStartFunc -- address of startup function for the thread
        ThdTyp_e -- Type of thread (TCP listener or UDP listener)


Externals Used:
        WinsThdPool

Called by:
        CommCreateTCPThd, CommCreateUDPThd

Comments:
        None

Return Value:
        None
--*/

{

        HANDLE        ThdHandle;
        DWORD ThdId;
        INT        No;

        /*
          Create a thread with no sec attributes (i.e. it will take the
          security attributes of the process), and default stack size
        */

        ThdHandle = WinsMscCreateThd(
                                   pStartFunc,
                                 NULL,                 /*no arg*/
                                 &ThdId
                                );


FUTURES("Improve the following to remove knowledge of # of threads in commsys")
        /*
          Grab the first slot for comm threads (2 slots in total) if available.
          Else, use the second one.  Initialize the thread context block
        */
        No = (WinsThdPool.CommThds[0].fTaken == FALSE) ? 0 : 1;
        {

           WinsThdPool.CommThds[No].fTaken    = TRUE;
           WinsThdPool.CommThds[No].ThdId     = ThdId;
           WinsThdPool.CommThds[No].ThdHdl    = ThdHandle;
           WinsThdPool.CommThds[No].ThdTyp_e  = ThdTyp_e;
        }

        WinsThdPool.ThdCount++;

        return;
}



STATUS
CommConnect(
        IN  PCOMM_ADD_T pHostAdd,
        IN  SOCKET Port,
        OUT SOCKET *pSockNo
           )
/*++
Routine Description:
        This function creates a TCP connection to a destination host

Arguments:
        pHostAdd  --pointer to Host's address
        Port     -- Port number to connect to
        pSockNo  -- ptr to a Socket variable


Called by:

Externals Used:

Return Value:

    TBS

--*/

{

        //struct sockaddr_in        sin; //*Internet endpoint address
        DWORD  ConnCount;

        ConnCount = InterlockedExchange(&CommConnCount, CommConnCount);
#ifdef WINSDBG
        if (ConnCount >= 200)
        {
                        DBGPRINT0(ERR,
                                "MonTcp: Connection limit of 200 reached. \n");
        }
#endif
#if 0
        if (ConnCount >= FD_SETSIZE)
        {
             DBGPRINT2(EXC, "CommConnect: Socket Limit reached. Current no = (%d). Connection not being made to WINS. Address faimly of WINS is  (%s)\n",
            ConnCount,
            pHostAdd->AddTyp_e == COMM_ADD_E_TCPUDPIP ? "TCPIP" : "SPXIPX"
                      );
                WINSEVT_LOG_D_M(ConnCount, WINS_EVT_CONN_LIMIT_REACHED);
                WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
        }
#endif

#if SPX == 0
       if (CommTcp(pHostAdd, Port, pSockNo) != WINS_SUCCESS)
       {
                return(WINS_FAILURE);
       }
#else
       if (pHostAdd->AddTyp_e == COMM_ADD_E_TCPUDPIP)
       {
               if (CommTcp(pHostAdd, Port, pSockNo) != WINS_SUCCESS)
               {
                  return(WINS_FAILURE);
               }
       }
       else
       {
               if (CommSpx(pHostAdd, Port, pSockNo) != WINS_SUCCESS)
               {
                  return(WINS_FAILURE);
               }
       }
       //
#endif
       // Connection has been made.  Let us increment the connection count
       //
       InterlockedIncrement(&CommConnCount);
       return(WINS_SUCCESS);
}

STATUS
CommTcp(
        IN  PCOMM_ADD_T pHostAdd,
        IN  SOCKET Port,
        OUT SOCKET *pSockNo
       )
{

        struct sockaddr_in        destsin; //*Internet endpoint address
        struct sockaddr_in        srcsin;
//        DWORD  ConnCount;

        if (pHostAdd->Add.IPAdd == INADDR_NONE)
        {
           return(WINS_FAILURE);
        }





        //
        //  Create a TCP socket and connect it to the target host
        //
        if ((*pSockNo = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
        {
                WINSEVT_LOG_M(
                               WSAGetLastError(),
                               WINS_EVT_CANT_CREATE_TCP_SOCK_FOR_CONN
                             );
                return(WINS_FAILURE);

        }

        if (WinsClusterIpAddress) {
            WINSMSC_FILL_MEMORY_M(&srcsin, sizeof(srcsin), 0);
            srcsin.sin_addr.s_addr = htonl(WinsClusterIpAddress);
            srcsin.sin_family      = PF_INET;
            srcsin.sin_port        = 0;

            if ( bind(*pSockNo,(struct sockaddr *)&srcsin,sizeof(srcsin))  == SOCKET_ERROR)
            {

                WINSEVT_LOG_M(WSAGetLastError(), WINS_EVT_WINSOCK_BIND_ERR);  //log an event
                return(WINS_FAILURE);
            }

        }


FUTURES("May want to call setsockopt() on it to enable graceful close")
        WINSMSC_FILL_MEMORY_M(&destsin, sizeof(destsin), 0);
        destsin.sin_addr.s_addr = htonl(pHostAdd->Add.IPAdd);
        destsin.sin_family      = PF_INET;
        destsin.sin_port        = (u_short)htons((u_short)Port);

        if (
                connect(*pSockNo, (struct sockaddr *)&destsin, sizeof(destsin))
                                        == SOCKET_ERROR
           )
        {
                struct in_addr InAddr;
                InAddr.s_addr = destsin.sin_addr.s_addr;

                WinsEvtLogDetEvt(FALSE, WINS_EVT_WINSOCK_CONNECT_ERR,
                                NULL, __LINE__, "sd",
                                COMM_NETFORM_TO_ASCII_M(&InAddr),
                                WSAGetLastError());
                WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
        }

        return(WINS_SUCCESS);
}

#if SPX > 0
STATUS
CommSpx(
        IN  PCOMM_ADD_T pHostAdd,
        IN  SOCKET Port,
        OUT SOCKET *pSockNo
 )
{
        struct sockaddr_ipx        sipx; //*SPX/IPX endpoint address
        LPVOID pRemAdd;
        DWORD  SizeOfRemAdd;

        //
        //  Create an SPX socket and connect it to the target host
        //
        if ((*pSockNo = socket(PF_IPX, SOCK_STREAM, NSPROTO_SPX)) ==
                                       INVALID_SOCKET)
        {
              WINSEVT_LOG_M(WSAGetLastError(),
                          WINS_EVT_CANT_CREATE_TCP_SOCK_FOR_CONN);
              return(WINS_FAILURE);

        }
        WINSMSC_FILL_MEMORY_M(&sipx, sizeof(sipx), 0);
        sipx.sa_socket = htons(Port);
        sipx.sa_family      = PF_IPX;
        RtlCopyMemory(sipx.sa_netnum, pHostAdd->Add.netnum,
                                     sizeof(pHostAdd->Add.netnum);
        RtlCopyMemory(sipx.sa_nodenum, pHostAdd->Add.nodenum,
                                      sizeof(pHostAdd->Add.nodenum);


FUTURES("May want to call setsockopt() on it to enable graceful close")
        if (
                connect(*pSockNo, (struct sockaddr *)&sipx, sizeof(sipx))
                                        == SOCKET_ERROR
           )
        {
PERF("Pass address as binary data. Also log WSAGetLastError()")

                WinsEvtLogDetEvt(FALSE, WINS_EVT_WINSOCK_CONNECT_ERR,
                                NULL, __LINE__, "sd",
                                sipx.sa_nodenum,
                                WSAGetLastError());
                WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
        }

       return(WINS_SUCCESS);
}
#endif

VOID
CommSend(
        COMM_TYP_E         CommTyp_e,
        PCOMM_HDL_T      pAssocHdl,
        MSG_T                 pMsg,
        MSG_LEN_T        MsgLen
)
/*++

Routine Description:

        This function is called to send a TCP message to a WINS server or to
        an nbt client

Arguments:
        CommTyp_e - Type of communication
        pAssocHdl - Handle to association to send message on
        pMSg          - Message to send
        MsgLen          - Length of above message

Externals Used:
        None

Called by:
        Replicator code

Comments:
        This function should not be called for sending assoc messages.

Return Value:

        None
--*/
{


     PCOMM_HEADER_T  pCommHdr         = NULL;
     PCOMMASSOC_ASSOC_CTX_T pAssocCtx = pAssocHdl->pEnt;
     LPLONG             pLong;

    if (!CommLockBlock(pAssocHdl))
    {
        WINS_RAISE_EXC_M(WINS_EXC_LOCK_ASSOC_ERR);
    }

try {
         /*
         *  If it is not an NBT message (i.e. it is a WINS message), we
         *  need to set the header appropriately
         */
         if (CommTyp_e != COMM_E_NBT)
         {

             pCommHdr = (PCOMM_HEADER_T)(pMsg - COMM_HEADER_SIZE);
             pLong    = (LPLONG) pCommHdr;

                   COMM_SET_HEADER_M(
                        pLong,
                        WINS_IS_NOT_NBT,
                        pAssocCtx->uRemAssocCtx,
                        COMM_RPL_MSG
                       );

             pMsg   = (LPBYTE)pCommHdr;
             MsgLen = MsgLen + COMM_HEADER_SIZE;
          }

        /*
          send the message
        */
        CommSendAssoc(
                        pAssocCtx->SockNo,
                        pMsg,
                        MsgLen
                   );

   }
finally {

        CommUnlockBlock(pAssocHdl);
    }

    return;
}



VOID
CommSendAssoc(
          SOCKET    SockNo,
          MSG_T     pMsg,
          MSG_LEN_T MsgLen
  )
/*++

Routine Description:

        This function is called to interface with the TCP/IP code for
        sending a message on a TCP link
Arguments:

        SockNo - Socket to send message on
        pMsg   - Message to send
        MsgLen - Length of message to send
Externals Used:
        None

Called by:
          CommAssocSetUpAssoc
Comments:
        None

Return Value:

        None

--*/
{

        int    Flags     = 0;        //flags to indicate OOB or DONTROUTE
        INT    Error;
        int    BytesSent;
        LONG   Len       = MsgLen;
        LPLONG pLong =  (LPLONG)(pMsg - sizeof(LONG));
        int        NoOfBytesToSend;



        //initialize the last four bytes with the length of
        //the message

        COMM_HOST_TO_NET_L_M(Len, Len);
        *pLong  = Len;

        MsgLen  = MsgLen + 4;


       while(MsgLen > 0)
       {

        //
        // Since send(...) takes an int for the size of the message, let us
        // be conservative (since int could be different on different
        // machines) and not specify anything larger than MAXUSHORT.
        //
        // This strategy is also prudent since winsock may not work
        // properly for sizes > 64K
        //
        if ( MsgLen > MAXUSHORT)
        {
            NoOfBytesToSend = MAXUSHORT;
        }
        else
        {
            NoOfBytesToSend = MsgLen;
        }

        BytesSent = send(
                          SockNo,
                          (LPBYTE)pLong,
                          NoOfBytesToSend,
                          Flags
                         );

        if (BytesSent == SOCKET_ERROR)
        {
                Error = WSAGetLastError();

                if (
                    (Error == WSAENOTCONN)    ||
                    (Error == WSAECONNRESET)  ||
                    (Error == WSAECONNABORTED) ||
                    (Error == WSAEDISCON)

                   )
                {
                        DBGPRINT1(ERR, "CommSendAssoc: send returned SOCKET_ERROR due to connection abortion or reset. Error = (%d) \n", Error);

                        WINSEVT_LOG_D_M(
                                Error,
                                WINS_EVT_WINSOCK_SEND_MSG_ERR
                                    );
                        WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
                //        break;

                }
                else
                {

                        DBGPRINT1(ERR, "CommSendAssoc: send returned SOCKET_ERROR due to severe error = (%d) \n", Error);
                        //
                        // Some severe error.  Raise an exception.  We
                        // don't want the caller to ignore this.
                        //
                        WINSEVT_LOG_M(Error, WINS_EVT_WINSOCK_SEND_ERR);
                        WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
                }

        }
        else
        {
           if (BytesSent < NoOfBytesToSend)
           {

                DBGPRINT2(ERR, "CommSendAssoc: Bytes Sent (%d) are < Specified (%d)\n", BytesSent, NoOfBytesToSend);
                WINSEVT_LOG_D_M(BytesSent, WINS_EVT_WINSOCK_SEND_MSG_ERR);


                /*
                 * The connection could have gone down because of the
                 * other side aborting in the middle
                 *
                 * We should log an error but not raise an exception.
                */
                //WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
                WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
               // break;

           }
           else  //BytesSent == NoOfBytesToSend
           {
                //
                // Let us update the length left and the pointer into the
                // buffer to send.
                //
                MsgLen -= BytesSent;
                pLong  = (LPLONG)((LPBYTE)pLong + BytesSent);
           }

        }
    }
        return;
}  // CommSendAssoc()


VOID
CommDisc(
        SOCKET SockNo,
        BOOL   fDecCnt
        )

/*++

Routine Description:

        This function closes the connection (socket)

Arguments:
        SockNo - Socket that needs to be disconnected

Externals Used:

        None

Called by:
        MonTcp, HandleMsg, ProcTcpMsg, CommEndAssoc
Comments:
        None

Return Value:

        None
--*/
{

        DBGPRINT1(FLOW, "CommDisc: Closing socket = (%d)\n", SockNo);

        if (closesocket(SockNo) == SOCKET_ERROR)
        {
                WINSEVT_LOG_M(WSAGetLastError(),
                                WINS_EVT_WINSOCK_CLOSESOCKET_ERR);
                //WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
        }
#ifdef WINSDBG
         if (!sfMemoryOverrun)
         {
          if ((UINT_PTR)(pTmpW + 2) < (UINT_PTR)pEndPtr)
          {
              *pTmpW++ = 0xEFFFFFFE;
              *pTmpW++ = SockNo;
          }
          else
          {
               WinsDbg |= 0x3;
               DBGPRINT0(ERR, "CommDisc: Stopping socket close tracking to prevent Memory overrun\n")
               sfMemoryOverrun = TRUE;
          }
        }
#endif

        if (fDecCnt)
        {
            CommDecConnCount();
        }
        return;
}



VOID
CommSendUdp (
  SOCKET                 SockNo,
  struct sockaddr_in        *pDest,
  MSG_T                   pMsg,
  MSG_LEN_T             MsgLen
  )
/*++

Routine Description:


        This function is called to send a message to an NBT node using the
        datagram port

Arguments:

        SockNo - Socket to send message on (UDP port)
        pDest  - Address of node to send message to
        pMsg   - Message to send
        MsgLen - Length of message to send

Externals Used:
        None

Called by:

            NmsNmh functions
Comments:
        None

Return Value:

        None
--*/


{

        DWORD  BytesSent;
        DWORD  Error;
        int    Flags = 0;
        struct sockaddr_in  CopyOfDest;

#if USENETBT > 0
        //
        // When the address to send the datagram to is CommNtfSockAdd, we
        // use sockets, else we send it over NETBT.
        //
#if MCAST > 0
        if ((pDest != &CommNtfSockAdd) && (SockNo !=  CommUdpPortHandle))
#else
        if (pDest != &CommNtfSockAdd)
#endif
        {
                SendNetbt(pDest, pMsg, MsgLen);
                return;
        }
#endif
        //
        // use copy of the destination so that when we change the byte
        // order in it, we don't disturb the source.  This is important
        // because CommSendUdp can be called multiple times by HdlPushNtf
        // in the Push thread with pDest pointing to the address of the
        // UDP socket used by the TCP listener thread.  This address is
        // in host byte order and should not be changed
        //
        CopyOfDest = *pDest;

        CopyOfDest.sin_addr.s_addr          = htonl(pDest->sin_addr.s_addr);
        BytesSent = (DWORD)sendto(
                                SockNo,
                                pMsg,
                                MsgLen,
                                Flags,
                                (struct sockaddr *)&CopyOfDest,
                                sizeof(struct sockaddr)
                                 );

        if ((BytesSent != MsgLen) || (BytesSent == SOCKET_ERROR))
        {
                Error = WSAGetLastError();
#ifdef WINSDBG
                if (BytesSent == SOCKET_ERROR)
                {
                        DBGPRINT1(ERR, "CommSendUdp:SendTo returned socket error. Error = (%d)\n", Error);
                }
                else
                {
                        DBGPRINT0(ERR, "CommSendUdp:SendTo did not send all the bytes");

                }
#endif
                if (WinsCnf.State_e != WINSCNF_E_TERMINATING)
                {
                        WINSEVT_LOG_D_M(Error, WINS_EVT_WINSOCK_SENDTO_ERR);
                }

                //
                // Don't raise exception since sendto might have failed as
                // a result of wrong address in the RFC name request packet.
                //
                // For sending responses to name requests, there is no
                // possibility of WINS using a wrong address since the
                // address it uses is the one that it got from recvfrom
                // (stored In FromAdd field of the dlg ctx block.
                //
                // The possibility of a wrong address being there is
                // only there when a WACK/name query/name release is sent
                // by WINS.  In this case, it takes the address that is
                // stored in the database for the conflicting entry (this
                // address is ofcourse the one that was passed in the
                // RFC packet
                //
                // WSAEINVAL error is returned by GetLastError if the
                // address is invalid (winsock document doesn't list this --
                // inform Dave Treadwell about this).
                //

FUTURES("At name registration, should WINS make sure that the address in ")
FUTURES("the packet is the same as the address it got from recvfrom")
FUTURES("probably yes")

                //WINS_RAISE_EXC_M(WINS_EXC_FAILURE);

        }
        return;
}

#if USENETBT > 0
VOID
SendNetbt (
  struct sockaddr_in        *pDest,
  MSG_T                   pMsg,
  MSG_LEN_T             MsgLen
 )

/*++

Routine Description:
        This function is called to send a datagram through NETBT

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
       //
       // Point to the address structure prefix
       //
       tREM_ADDRESS *pRemAdd = (tREM_ADDRESS *)(pMsg -
                                        COMM_NETBT_REM_ADD_SIZE);

#ifdef JIM
        {
         BYTE        TransId = *pMsg;
         ASSERT(TransId == 0x80);
        }
#endif

       pRemAdd->Family               = pDest->sin_family;
       pRemAdd->Port               = pDest->sin_port;
       pRemAdd->IpAddress      = htonl(pDest->sin_addr.s_addr);
#ifdef JIM
ASSERT(MsgLen > 0x20);
#endif
       pRemAdd->LengthOfBuffer = MsgLen;
       DeviceIoCtrl(
                    &sNetbtSndEvtHdl,
                    pRemAdd,
                    MsgLen + COMM_NETBT_REM_ADD_SIZE,
                    IOCTL_NETBT_WINS_SEND
                    );
        return;
}
#endif
VOID
ParseMsg(
        MSG_T                        pMsg,
        MSG_LEN_T                MsgLen,
        COMM_TYP_E                MsgTyp_e,
        struct sockaddr_in         *pFromAdd,
        PCOMMASSOC_ASSOC_CTX_T        pAssocCtx
        )

/*++

Routine Description:

        This function is called to process a message received on the
        UDP port or a TCP connection.

Arguments:
        pMsg        - ptr to message received
        MsgLen  - length of message received
        MsgType - type of message
        pFromAdd - ptr to who it is from
        pAssocHdl - Assoc Handle if it came on an association

Externals Used:
        CommUdpNbtDlgTable

Called by:
        ProcTcpMsg, MonUdp

Comments:
        None

Return Value:

        None
--*/
{

        COMM_HDL_T                    DlgHdl;
        COMMASSOC_DLG_CTX_T        DlgCtx;
        register PCOMMASSOC_DLG_CTX_T        pDlgCtx;
        BOOL                       fNewElem = FALSE;


try {
        /*
        *  If the assoc handle is NULL, this is a UDP message
        */
        if (pAssocCtx == NULL)
        {

            /*
             * Check if this message is a response.  If it is, the explicit
             * dialogue is used
            */
            if (*(pMsg + 2) & NMS_RESPONSE_MASK)
            {
                ENmsHandleMsg(
                                &CommExNbtDlgHdl,
                                pMsg,
                                MsgLen
                             );
                return;
            }

            /*
             * Initialize the STATIC dlg ctx block with the fields that the
             * compare function will use to check if this is a duplicate
            */
            WINSMSC_COPY_MEMORY_M(
                                &DlgCtx.FromAdd,
                                pFromAdd,
                                sizeof(struct sockaddr_in)
                                 );

            //
            // Copy the first four bytes of the message into the FirstWrdOfMsg
            // field of the Dlg Ctx block.  The first 4 bytes contain the
            // transaction id and the opcode.  These values along with the
            // address of the sender are used by CompareNbtReq to determine
            // whether a request is a repeat request or a new one.
            //
            //  Note: The message buffer and the dlg ctx block are deleted
            //  in different functions, the message buffer getting deleted
            //  first.  We can not use  the pointer to the message
            //  buffer for the purposes of getting at the first word at
            //  comparison time since then we open ourselves to the possibility
            //  of two dialogues pointing to the same block for a finite
            //  window (true, when requests are coming rapidly)
            //

FUTURES("Directly assign the value instead of copying it")
            WINSMSC_COPY_MEMORY_M(
                          &DlgCtx.FirstWrdOfMsg,
                          pMsg,
                          sizeof(DWORD)
                        );


            /*
                create and insert a  dlg ctx block into the table of
                NBT type Implicit dialogues.  The key to searching for
                a duplicate inside the table comprises of the Transaction Id
                of the message, and the FromAdd of the nbt node that sent the
                datagram.
                (refer : CheckDlgDuplicate function).

            */
            pDlgCtx = CommAssocInsertUdpDlgInTbl(&DlgCtx, &fNewElem);

            if (pDlgCtx == NULL)
            {
                WINS_RAISE_EXC_M(WINS_EXC_OUT_OF_MEM);
            }

            /*
             *         If the dialogue for the particular command from the nbt node is
             *        already there, we will ignore this request, deallocate the
             *        UDP buffer and  return.
            */
            if (!fNewElem)
            {
                DBGPRINT0(FLOW, "Not a new element\n");
                ECommFreeBuff(pMsg);
#ifdef WINSDBG
                CommNoOfRepeatDgrms++;
#endif
                return;
            }

            /*
             * Initialize the dlg ctx block that got inserted
            */
            pDlgCtx->Role_e  = COMMASSOC_DLG_E_IMPLICIT;
            pDlgCtx->Typ_e   = COMM_E_UDP;

            DlgHdl.pEnt      = pDlgCtx;

            /*
             *        Call name space manager to handle the request
            */
            ENmsHandleMsg(&DlgHdl, pMsg, MsgLen);
        }
        else   // the request came over an association
        {

                pDlgCtx = pAssocCtx->DlgHdl.pEnt;

                //
                // required by the PULL thread (HandlePushNtf).
                // and the PUSH thread to print out the address of the WINS
                // that sent the push trigger or the Pull request
                //
                WINSMSC_COPY_MEMORY_M(
                                &pDlgCtx->FromAdd,
                                pFromAdd,
                                sizeof(struct sockaddr_in)
                                     );

                /*
                 * The request came over a TCP connection.  Examine the Dlg type
                 * and then call the appropriate component
                */
                if (pAssocCtx->Typ_e == COMM_E_NBT)
                {

                            /*
                             * It is an nbt request over a TCP connection.  Call
                              * the Name Space Manager
                            */
                            ENmsHandleMsg(
                                        &pAssocCtx->DlgHdl,
                                        pMsg,
                                        MsgLen
                                     );
                }
                else
                {
                            /*
                         * Call the replicator component
                         *
                         * Note: pMsg points to COMM_HEADER_T on top of the
                         *        data. We strip it off
                            */
DBGIF(fWinsCnfRplEnabled)
                            ERplInsertQue(
                                        WINS_E_COMSYS,
                                        QUE_E_CMD_REPLICATE_MSG,
                                        &pAssocCtx->DlgHdl,
                                        pMsg + COMM_HEADER_SIZE,
                                        MsgLen - COMM_HEADER_SIZE,
                                        NULL,   // no context
                    0       // no magic no.
                                     );
                   }
        }
   }
except(EXCEPTION_EXECUTE_HANDLER)        {

                DBGPRINTEXC("ParseMsg");
                /*
                * If this dialogue was allocated as a result of an Insert
                * get rid of it.
                */
                if (fNewElem)
                {
                        CommAssocDeleteUdpDlgInTbl( pDlgCtx );
                }
                WINS_RERAISE_EXC_M();
        }
        return;
}


LPVOID
CommAlloc(
  IN PRTL_GENERIC_TABLE pTable,
  IN CLONG                BuffSize
)

/*++

Routine Description:
        This function is called to allocate a buffer

Arguments:
        pTable   - Table where the buffer will be stored
        BuffSize - Size of buffer to allocate

Externals Used:
        None


Return Value:

   Success status codes -- ptr to buffer allocated
   Error status codes  --

Error Handling:

Called by:
        RtlInsertElementGeneric()

Side Effects:

Comments:
        This function exists just because the RtlTbl functions require
        this prototype for the user specified alloc function.
--*/

{
        LPVOID pTmp;

          UNREFERENCED_PARAMETER(pTable);

        WinsMscAlloc( (DWORD) BuffSize,  &pTmp );

        return(pTmp);

}


VOID
CommDealloc(
  IN PRTL_GENERIC_TABLE pTable,
  IN PVOID                pBuff
)

/*++

Routine Description:

  This function is called to deallocate memory allocated via CommAlloc.


Arguments:
        pTable - Table where buffer was stored
        pBuff  - Buffer to deallocate


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        The pTable argument is required since the address of this function
        is passed as an argument to RtlTbl functions
--*/

{


          UNREFERENCED_PARAMETER(pTable);
        WinsMscDealloc(
                        pBuff
                      );
        return;

}

#if 0
RTL_GENERIC_COMPARE_RESULTS
CompareAssoc(
        IN  PRTL_GENERIC_TABLE  pTable,
        IN  PVOID                pFirstAssoc,
        IN  PVOID                pSecondAssoc
        )

/*++

Routine Description:

        The function compares the first and the second assoc. structures
Arguments:
        pTable       - table where buffer (assoc. ctx block) is to be stored
        pFirstAssoc  - First assoc ctx block
        pSecondAssoc - Second assoc ctx block

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:
        RtlInsertElementGenericTable (called by MonTcp)

Side Effects:

Comments:
        The pTable argument is ignored.
        This function was once being used.  Due to change in code, it is
        no longer being used.  It is kept here for potential future use
--*/
{

  PCOMMASSOC_ASSOC_CTX_T         pFirst  = pFirstAssoc;
  PCOMMASSOC_ASSOC_CTX_T         pSecond = pSecondAssoc;

  if (pFirst->SockNo == pSecond->SockNo)
  {
        return(GenericEqual);
  }

  if (pFirst->SockNo > pSecond->SockNo)
  {
        return(GenericGreaterThan);
  }
  else
  {
        return(GenericLessThan);
  }

}

#endif

RTL_GENERIC_COMPARE_RESULTS
CommCompareNbtReq(
        IN  PRTL_GENERIC_TABLE  pTable,
        IN  PVOID                pFirstDlg,
        IN  PVOID                pSecondDlg
        )

/*++

Routine Description:

        This function compares two dialogue context blocks.  The fields
        used for comparison are:
                the address of the sender
                the first long word of the message (contains transaction id
                        and opcode)

Arguments:
        pTable     - Table where the Dialogue for the NBT request will be stored
        pFirstDlg  - Dlg. ctx. block
        pSecondDlg - Dlg. ctx. block

Externals Used:
        None


Return Value:

   Success status codes --  GenericLessThan or GenericGreaterThan
   Error status codes  -- GenericEqual

Error Handling:

Called by:
        RtlInsertElementGenericTable (called by ParseMsg)

Side Effects:

Comments:
        The pTable argument is ignored.
--*/
{

        PCOMMASSOC_DLG_CTX_T pFirst  = pFirstDlg;
        PCOMMASSOC_DLG_CTX_T pSecond = pSecondDlg;
        LONG                     Val     = 0;
        LONG           FirstMsgLong  = pFirst->FirstWrdOfMsg;
        LONG           SecondMsgLong = pSecond->FirstWrdOfMsg;

        //
        //  There seems to be no Rtl function with the functionality of memcmp
        //  RtlCompareMemory does not tell you which of the comparators is
        //  smaller/larger
        //
CHECK("Is there an Rtl function faster than memcmp in the nt arsenal\n");
        if (  (Val = (long)memcmp(
                        &pFirst->FromAdd,
                        &pSecond->FromAdd,
                        sizeof(struct sockaddr_in)
                                 )
              ) > 0
           )
        {
                return(GenericGreaterThan);
        }
        else
        {
           if (Val < 0)
           {
                return(GenericLessThan);
           }
        }

        /*
         if the addresses are the same, compare the first long word of
         the message
        */

        Val = FirstMsgLong -  SecondMsgLong;

        if (Val > 0)
        {
                return(GenericGreaterThan);
        }
        else
        {
           if (Val < 0)
           {
                return(GenericLessThan);
           }
        }

        return(GenericEqual);

}  // CommCompareNbtReq()

VOID
CommEndAssoc(
        IN  PCOMM_HDL_T        pAssocHdl
        )
/*++

Routine Description:

  This function is called to terminate an explicit association.  It sends a stop
  association response message to the WINS identified by the Address
  in the assoc ctx block. It then closes the socket and deallocates the
  association

Arguments:
        pAssocHdl - Handle to the Association to be terminated

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        ECommEndDlg (only for an explicit assoc)

Side Effects:

Comments:

--*/
{

    BYTE                            Msg[COMMASSOC_ASSOC_MSG_SIZE];
    DWORD                            MsgLen   = COMMASSOC_ASSOC_MSG_SIZE;
    PCOMMASSOC_ASSOC_CTX_T        pAssocCtx = pAssocHdl->pEnt;
    SOCKET                         SockNo;


    // no need to lock the association
    //
try {
    /*
        Format the Stop Assoc. Message

        The address passed to the formatting function is offset
        from the address of the buffer by a LONG so that CommSendAssoc
        can store the length of the message in it.
    */
    CommAssocFrmStopAssocReq(
                        pAssocCtx,
                        Msg + sizeof(LONG),
                        MsgLen - sizeof(LONG),
                        COMMASSOC_E_USER_INITIATED
                        );
    CommSendAssoc(
                pAssocCtx->SockNo,
                Msg + sizeof(LONG),
                MsgLen - sizeof(LONG)
                    );

    CommAssocTagFree(&sTagAssoc, pAssocCtx->nTag);
}
except(EXCEPTION_EXECUTE_HANDLER) {
       DBGPRINTEXC("CommEndAssoc");
 }
    //
    // The above call might have failed (It will fail if the connection
    // is down.  This can happen for instance in the case where GetReplicas()
    // in rplpull gets a comm. failure due to the connection going down).
    //
    SockNo = pAssocCtx->SockNo;

    CommAssocDeallocAssoc(pAssocCtx);
    CommDisc(SockNo, TRUE);
    //
    // decrement the conn. count
    //
    //CommDecConnCount();
    return;

}

VOID
DelAssoc(
        IN  SOCKET                     SockNo,
        IN  PCOMMASSOC_ASSOC_CTX_T  pAssocCtxPassed
        )

/*++

Routine Description:

        This function is called only by the TCP listener thread.  The
        socket no. therefore maps to a RESPONDER association. The function
        is called when the TCP listener thread gets an error or 0 bytes
        on doing a 'recv'.


Arguments:

        SockNo    -   Socket of association that has to be removed
        pAssocCtx - Assoc. ctx block to be removed


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        ProcTcpMsg, HandleMsg

Side Effects:

Comments:
        This function is called from HandleMsg() which is called
        only by the TCP listener thread.
--*/

{

    COMM_HDL_T                   DlgHdl;
    PCOMMASSOC_ASSOC_CTX_T pAssocCtx;

    DBGPRINT1(FLOW, "ENTER: DelAssoc. Sock No is (%d)\n", SockNo);
    if (pAssocCtxPassed == NULL)
    {

            /*
           Lookup the assoc. ctx block associated with the socket
            */

            pAssocCtx = CommAssocLookupAssoc(SockNo);

            /*
             * There is no reason why the assoc. ctx block should not
             * be there (a responder association is deleted only via this
        * function).
            */
            if(!pAssocCtx)
            {
                WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
            }
    }
    else
    {
        pAssocCtx = pAssocCtxPassed;
    }

    /*
     *        Only, if the association is not in the non-existent state,
     *  look for a dialogue handle
    */
    if (pAssocCtx->State_e != COMMASSOC_ASSOC_E_NON_EXISTENT)
    {
            /*
        *  get the dialogue handle
            */
            DlgHdl = pAssocCtx->DlgHdl;

            /*
         *        Lock the dialogue
         *
         *      We have to synchronize with thread calling CommSndRsp
            */
            CommLockBlock(&pAssocCtx->DlgHdl);

            /*
                Remove the assoc. from the table.  This will also put
                the assoc. in the free list.
            */
            CommAssocDeleteAssocInTbl(  pAssocCtx        );

            /*
                dealloc the dialogue (i.e. put it in the free list)

                Note: An implicit dialogue is deleted when the association(s)
                it is mapped to terminates.  If this dialogue was earlier
                 passed on to a client, the client will  find out that it
                has been deleted (via a communications failure exception)
                when it tries to use it (which may be never) -- see ECommSndRsp
            */
            CommAssocDeallocDlg( DlgHdl.pEnt );

            /*
                Unlock the dialogue so that other threads can use it
            */
            CommUnlockBlock(&DlgHdl);
   }
   else
   {
            /*
                Remove the assoc. from the table.  This will also put
                the assoc. in the free list
            */
            CommAssocDeleteAssocInTbl(pAssocCtx);

   }

   DBGLEAVE("DelAssoc\n");
   return;
}

#if PRSCONN
BOOL
CommIsBlockValid (
       IN   PCOMM_HDL_T       pEntHdl
      )
/*++

Routine Description:
        This function is called to check if the hdl is valid

Arguments:
        pEntHdl - Handle to entity to lock

Externals Used:
        None

Return Value:

   Success status codes -- TRUE
   Error status codes   --  FALSE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

  //
  // pEnt will be NULL for a persistent dlg that was never created during
  // the lifetime of this WINS instance or one that was ended.
  //
  if (pEntHdl->pEnt == NULL)
  {
      ASSERT(pEntHdl->SeqNo == 0);
      return (FALSE);
  }
  //
  // If we can lock the block, the dlg hdl is still valid. If not, it means
  // that the dlg was terminated earlier.
  //
  if (CommLockBlock(pEntHdl))
  {
     (VOID)CommUnlockBlock(pEntHdl);
     return(TRUE);
  }
  return(FALSE);
}
#endif

BOOL
CommLockBlock(
        IN  PCOMM_HDL_T        pEntHdl
        )

/*++

Routine Description:
        This function is called to lock the COMSYS entity identified by the
        handle.

Arguments:
        pEntHdl - Handle to entity to lock

Externals Used:
        None

Return Value:

   Success status codes -- TRUE
   Error status codes   --  FALSE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        PCOMM_TOP_T        pTop = pEntHdl->pEnt;

        //lock before checking

#if 0
        WinsMscWaitInfinite(pTop->MutexHdl);
#endif
        EnterCriticalSection(&pTop->CrtSec);
        if (pEntHdl->SeqNo == pTop->SeqNo)
        {
                return(TRUE);
        }
        else
        {
                CommUnlockBlock(pEntHdl);
                return(FALSE);
        }
}

__inline
STATUS
CommUnlockBlock(
        PCOMM_HDL_T        pEntHdl
        )

/*++

Routine Description:
        This function is called to unlock the COMSYS entity identified by the
        handle.

Arguments:
        pEntHdl - Handle to entity to unlock

Externals Used:
        None

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
FUTURES("Change to a macro")
#if 0
        BOOL RetVal = TRUE;
        BOOL RetStat = WINS_SUCCESS;
#endif
        PCOMM_TOP_T        pTop = pEntHdl->pEnt;

        LeaveCriticalSection(&pTop->CrtSec);
#if 0
        RetVal = ReleaseMutex(pTop->MutexHdl);

        if (RetVal == FALSE)
        {
                RetStat = WINS_FAILURE;
        }
#endif
        return(WINS_SUCCESS);

}

VOID
InitMem(
        VOID
        )

/*++

Routine Description:
        This function is called to do all memory initialization required
        by COMSYS.

Arguments:
        None

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        CommInit
Side Effects:

Comments:
        None
--*/
{


        /*
        * Create Memory heap for UDP buffers
        * We want mutual exclusion and generation of exceptions
        */
        DBGPRINT0(HEAP_CRDL,"InitMem: Udp. Buff heap\n");
        CommUdpBuffHeapHdl = WinsMscHeapCreate(
                                         HEAP_GENERATE_EXCEPTIONS,
                                        COMMASSOC_UDP_BUFFER_HEAP_SIZE
                                              );

    DBGPRINT0(HEAP_CRDL,"InitMem: Udp. Buff heap\n");
        CommUdpDlgHeapHdl = WinsMscHeapCreate(
                                         HEAP_GENERATE_EXCEPTIONS,
                                        COMMASSOC_UDP_DLG_HEAP_SIZE
                                              );

        /*
        * Create Memory heap for Assoc Ctx blocks.
        * We want mutual exclusion and generation of exceptions
        */
        DBGPRINT0(HEAP_CRDL,"InitMem: Assoc. blocks heap\n");
        CommAssocAssocHeapHdl = WinsMscHeapCreate(
                                         HEAP_GENERATE_EXCEPTIONS,
                                        COMMASSOC_ASSOC_BLKS_HEAP_SIZE
                                              );
        /*
        * Create Memory heap for dlg blocks
        * We want mutual exclusion and generation of exceptions
        */
        DBGPRINT0(HEAP_CRDL,"InitMem: Dlgs. blocks heap\n");
        CommAssocDlgHeapHdl = WinsMscHeapCreate(
                                         HEAP_GENERATE_EXCEPTIONS,
                                        COMMASSOC_DLG_BLKS_HEAP_SIZE
                            );
        /*
        * Create Memory heap for messages on tcp connections
        */
    DBGPRINT0(HEAP_CRDL,"InitMem: tcp connection message heap\n");
        CommAssocTcpMsgHeapHdl = WinsMscHeapCreate(
                                         HEAP_GENERATE_EXCEPTIONS,
                                        COMMASSOC_TCP_MSG_HEAP_SIZE
                                              );

        return;

}


BOOL
ChkNtfSock(
        IN fd_set  *pActSocks,
        IN fd_set  *pRdSocks
        )

/*++

Routine Description:
        This function is called to check if there is a notification message
        on the Notification socket.  If there is one, it reads the message.
        The message contains a socket # and a command to add or remove the
        socket to/from the list of sockets being monitored by the TCP
        listener thread.


Arguments:

        pActSocks - Array of active sockets
        pRdSocks  - Array of sockets  returned by select

Externals Used:
        CommNtfSockHandle

Return Value:
        TRUE  - Yes, there was a message.  The Active sockets array has been
                changed.
        FALSE - No.  There was no message

Error Handling:
        In case of an error, an exception is raised

Called by:
        MonTcp

Side Effects:

Comments:
        None
--*/

{
        DWORD  Error;
        int    RetVal;
        COMM_NTF_MSG_T        NtfMsg;
        PCOMMASSOC_DLG_CTX_T    pDlgCtx;
        PCOMMASSOC_ASSOC_CTX_T  pAssocCtx;
        SOCKET    Sock;
        BOOL      fNtfSockSet = TRUE;

        if (FD_ISSET(CommNtfSockHandle, pRdSocks))
        {
             Sock = CommNtfSockHandle;
        }
        else
        {
#if SPX > 0
           if (FD_ISSET(CommIpxNtfSockHandle, pRdSocks))
           {
             Sock = CommIpxNtfSockHandle;
           }
#endif
           fNtfSockSet = FALSE;
        }

        if (fNtfSockSet)
        {
                //do a recvfrom to read in the data.
                  RetVal = recvfrom(
                                Sock,
                                (char *)&NtfMsg,
                                COMM_NTF_MSG_SZ,
                                0,  //default flags (i.e. no peeking
                                    //or reading OOB message
                                NULL, //don't want address of sender
                                0     //length of above arg
                                    );

                  if (RetVal == SOCKET_ERROR)
                  {
                        Error = WSAGetLastError();
                        if (WinsCnf.State_e != WINSCNF_E_TERMINATING)
                        {
                          WINSEVT_LOG_M(
                                        Error,
                                        WINS_EVT_WINSOCK_RECVFROM_ERR
                                     );
                        }
                        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
                  }

               pDlgCtx   = NtfMsg.DlgHdl.pEnt;
               pAssocCtx = pDlgCtx->AssocHdl.pEnt;

                if (NtfMsg.Cmd_e == COMM_E_NTF_START_MON)
                {
                        DBGPRINT1(FLOW, "ChkNtfSock: Adding Socket (%d) to monitor list\n", NtfMsg.SockNo);

                        //
                        // We do this since FD_SETSIZE can fail silently
                        //
                        if (pActSocks->fd_count < FD_SETSIZE)
                        {
                                FD_SET(NtfMsg.SockNo, pActSocks);
                        }
                        else
                        {
                                DBGPRINT1(ERR,
                                 "ChkNtfSock: Connection limit of %d reached\n",
                                       FD_SETSIZE);
                                WINSEVT_LOG_M(WINS_FAILURE,
                                        WINS_EVT_CONN_LIMIT_REACHED);

                                //
                                //This will cleanup the dlg and assoc. ctx. blk
                                //
                                ECommEndDlg(&NtfMsg.DlgHdl);

                                return(TRUE);
                        }

                        //
                        // Add the association to the table of associations.
                        // Since this association will be monitored, we change
                        // the role of the association to RESPONDER.  Also,
                        // change the dialogue role to IMPLICIT. These are
                        // sleight of hand tactics. The client  who
                        // established the association  (Replicator)
                        // does not care whet we do with the comm data
                        // structures as long as we monitor the dialogue that
                        // it initiated with a remote WINS
                        //
                        pAssocCtx->Role_e  =  COMMASSOC_ASSOC_E_RESPONDER;
                        pDlgCtx->Role_e    =  COMMASSOC_DLG_E_IMPLICIT;
                        pDlgCtx->FromAdd   =  pAssocCtx->RemoteAdd;
                        CommAssocInsertAssocInTbl(pAssocCtx);
                }
                else  //COMM_NTF_STOP_MON
                {

                        DBGPRINT1(FLOW, "ChkNtfSock: Removing Socket (%d) from monitor list\n", NtfMsg.SockNo);
                        FD_CLR(NtfMsg.SockNo, pActSocks);

                        //
                        //Remove the association from the table of
                        //associations.  Since this association will not be
                        //monitored by the TCP thread, we change the role of
                        //the association to INITIATOR.  Also, change the
                        //dialogue role to EXPLICIT.  These are sleight of
                        //hand tactics.
                        //
                        if (CommLockBlock(&NtfMsg.DlgHdl))
                        {
                          pAssocCtx->Role_e  =  COMMASSOC_ASSOC_E_INITIATOR;
                          pDlgCtx->Role_e    =  COMMASSOC_DLG_E_EXPLICIT;
                          COMMASSOC_UNLINK_RSP_ASSOC_M(pAssocCtx);
                          pAssocCtx->RemoteAdd =  pDlgCtx->FromAdd;
                          CommUnlockBlock(&NtfMsg.DlgHdl);

                           //
                           // Let us signal the PUSH thread so that it can
                           // hand over the connection to the PULL thread (See
                           // HandleUpdNtf in rplpush.c)
                           //
                           WinsMscSignalHdl(RplSyncWTcpThdEvtHdl);
                        }
                        else
                        {
                          //
                          //The dlg could not be locked.  It means that before
                          //the tcp listener thread started processing this
                          //message, it had already processed a disconnect.
                          //
                          fCommDlgError = TRUE;
                          WinsMscSignalHdl(RplSyncWTcpThdEvtHdl);
                        }

                }
                return(TRUE);
        }
        return(FALSE);
} // ChkNtfSock()


STATUS
RecvData(
        IN  SOCKET                SockNo,
        IN  LPBYTE                pBuff,
        IN  DWORD                BytesToRead,
        IN  INT                        Flags,
        IN  DWORD                SecsToWait,
        OUT LPDWORD                pBytesRead
           )

/*++

Routine Description:
        This function is called to do a timed recv on a socket.

Arguments:
        SockNo        - Socket No.
        pBuff         - Buffer to read the data into
        BytesToRead   - The number of bytes to read
        Flags              - flag arguments for recv
        SecsToWait  -  No of secs to wait for the first read.
        pBytesRead    - No of Bytes that are read

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE or WINS_RECV_TIMED_OUT

Error Handling:

Called by:
        CommReadStream

Side Effects:

Comments:
        None
--*/

{
        fd_set RdSocks;
        int    NoOfSockReady;
        INT    BytesRead = 0;
        INT    BytesLeft = BytesToRead;
        DWORD  InChars;
        DWORD  Error;
        BOOL   fFirst = TRUE;
        STATUS RetStat;

        FD_ZERO(&RdSocks);
        FD_SET(SockNo, &RdSocks);

        /*
         *  Read the whole message into the allocated buffer
        */
        for (
                InChars = 0;
                BytesLeft > 0;
                InChars += BytesRead
            )
        {
          //
          // Check if we were told to do a timed receive.  This will
          // never happen in the TCP listener thread
          //
          if (SecsToWait)
          {
           //
           // Block on a timed select. The first time around we want to
           // wait the time specified by caller. The caller expects the other
           // side to send something within this much time.  For subsequent
           // reads we wait a pre-defined interval since the sender has already
           // accumulated all that it wants to send and has started sending it
           // obviating the need for us to wait long.
           //
           if (fFirst)
           {
              sTimeToWait.tv_sec = (long)SecsToWait;
              fFirst = FALSE;
           }
           else
           {
              sTimeToWait.tv_sec = SECS_TO_WAIT;
           }
           if (
                (
                        NoOfSockReady = select(
                                            FD_SETSIZE /*ignored arg*/,
                                            &RdSocks,
                                            (fd_set *)0,
                                            (fd_set *)0,
                                            &sTimeToWait
                                                  )
                ) == SOCKET_ERROR
             )
           {
                Error = WSAGetLastError();
                DBGPRINT1(ERR,
                "RecvData: Timed Select returned SOCKET ERROR. Error = (%d)\n",
                                Error);
//                CommDecConnCount();
                return(WINS_FAILURE);
          }
          else
          {
                DBGPRINT1(FLOW, "ReceiveData: Timed Select returned with success. No of Sockets ready - (%d) \n", NoOfSockReady);

               if (NoOfSockReady == 0)
               {
                        //
                        // Timing out of RecvData indicates some problem at
                        // the remote WINS (either it is very slow
                        // (overloaded) or the TCP listener thread is out of
                        // commission).
                        WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_WINSOCK_SELECT_TIMED_OUT
                                          );
                        DBGPRINT0(ERR, "ReceiveData: Select TIMED OUT\n");
                        *pBytesRead = 0;
                               *pBytesRead = BytesRead;
//                        CommDecConnCount();
                        return(WINS_RECV_TIMED_OUT);
             }
          }
       }


        //
        // Do a blocking recv
        //
        BytesRead = recv(
                                SockNo,
                                (char *)(pBuff + InChars),
                                BytesLeft,
                                Flags
                                );

        if (BytesRead == SOCKET_ERROR)
        {
                           Error = WSAGetLastError();

                           DBGPRINT1(ERR,
                        "RecvData: recv returned SOCKET_ERROR. Error = (%d)\n",
                                                Error);


                           /*
                         * If the connection was aborted or reset from the
                         *  other end, we close the socket and return an error
                           */
                           if (
                                (Error == WSAECONNABORTED)
                                        ||
                                (Error == WSAECONNRESET)
                                        ||
                                (Error == WSAEDISCON)
                            )
                           {
                                DBGPRINT0(ERR,
                                        "RecvData: Connection aborted\n");
                                WINSEVT_LOG_INFO_D_M(
                                        WINS_SUCCESS,
                                        WINS_EVT_CONN_ABORTED
                                                 );
                           }
                               *pBytesRead = BytesRead;
//                        CommDecConnCount();
                               return(WINS_FAILURE);
        }
        if (BytesRead == 0)
        {
                         /*recv returns 0 (normal graceful shutdown from
                        * either side)
                        * Note:
                         * recv returns 0 if the connection terminated with no
                        * loss of data from either end point of the connection
                        */

                        //
                        // If we were told to do a non timed receive,
                        // we must be executing in the TCP listener thread
                        //
                        // We don't return an error status here since
                        // a disconnect is a valid condition (the other
                        // WINS is terminating its connection normally)
                        //
                        if (SecsToWait == 0)
                        {
                                RetStat = WINS_SUCCESS;
                        }
                        else
                        {
                                //
                                // The fact that we were told to do a
                                // timed select means that we are in
                                // a thread of one of the clients of
                                // COMSYS.  We were expecting data but
                                // got a disconnect instead.  Let us
                                // return an error
                                //
                                RetStat = WINS_FAILURE;
                        }

                        //
                        // We are done. Break out of the loop
                        //
                               *pBytesRead = BytesRead;
//                        CommDecConnCount();
                               return(RetStat);
         }

         BytesLeft -=  BytesRead;

         //
         //We are here means that BytesRead > 0
         //

      } // end of for { ... }

      *pBytesRead = InChars;
      return(WINS_SUCCESS);
} // RecvData()

#if USENETBT > 0
VOID
CommOpenNbt(
        DWORD FirstBindingIpAddr
    )

/*++

Routine Description:

    This function opens the NetBt device for the interface specified by
    FirstBindingIpAddr.

Arguments:

    path        - path to the NETBT driver
    oflag       - currently ignored.  In the future, O_NONBLOCK will be
                    relevant.
    ignored     - not used

Return Value:

    An NT handle for the stream, or INVALID_HANDLE_VALUE if unsuccessful.

--*/

{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
//    STRING              name_string;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    PFILE_FULL_EA_INFORMATION   pEaBuffer;
    ULONG               EaBufferSize;

    //
    // Convert the path into UNICODE_STRING form
    //
#ifdef _PNP_POWER_
    RtlInitUnicodeString(&uc_name_string, L"\\Device\\NetBt_Wins_Export");
#else
#ifdef UNICODE
    RtlInitUnicodeString(&uc_name_string, pWinsCnfNbtPath);
#else
    RtlInitString(&name_string, pWinsCnfNbtPath);
    RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);
#endif
#endif // _PNP_POWER_
    InitializeObjectAttributes(
        &ObjectAttributes,
        &uc_name_string,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    EaBufferSize =  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                    strlen(WINS_INTERFACE_NAME) + 1 +
                    sizeof(FirstBindingIpAddr); // EA length


    WinsMscAlloc(EaBufferSize, &pEaBuffer);

    if (pEaBuffer == NULL)
    {
        WINS_RAISE_EXC_M(WINS_EXC_OUT_OF_MEM);
    }

    pEaBuffer->NextEntryOffset = 0;
    pEaBuffer->Flags = 0;
    pEaBuffer->EaNameLength = (UCHAR)strlen(WINS_INTERFACE_NAME);


    //
    // put "WinsInterface" into the name
    //
    RtlMoveMemory(
        pEaBuffer->EaName,
        WINS_INTERFACE_NAME,
        pEaBuffer->EaNameLength + 1);

    pEaBuffer->EaValueLength = sizeof(FirstBindingIpAddr);
    *(DWORD UNALIGNED *)(pEaBuffer->EaName + pEaBuffer->EaNameLength + 1) = FirstBindingIpAddr;

    status =
     NtCreateFile(
        &WinsCnfNbtHandle,
        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_IF,
        0,
        pEaBuffer,
        EaBufferSize
        );

#ifndef UNICODE
    RtlFreeUnicodeString(&uc_name_string);
#endif

    WinsMscDealloc(pEaBuffer);
    if(!NT_SUCCESS(status))
    {
        WinsEvtLogDetEvt(
             FALSE,
             WINS_PNP_FAILURE,
             NULL,
             __LINE__,
             "d",
             status);

        DBGPRINT1(EXC, "CommOpenNbt: Status from NtCreateFile is (%x)\n",
                     status);
        WINS_RAISE_EXC_M(WINS_EXC_NBT_ERR);
    }
    return;

} // CommOpenNbt

//------------------------------------------------------------------------
#if NEWNETBTIF == 0
//#include "nbtioctl.sav"

STATUS
CommGetNetworkAdd(
        IN OUT PCOMM_ADD_T        pAdd
    )

/*++

Routine Description:

    This procedure does an adapter status query to get the local name table.
    It either prints out the local name table or the remote (cache) table
    depending on whether WhichNames is NAMES or CACHE .

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    LONG                        i;
    PVOID                       pBuffer;
    ULONG                       BufferSize=sizeof(tADAPTERSTATUS);
    NTSTATUS                    Status;
    tADAPTERSTATUS              *pAdapterStatus;
    ULONG                       QueryType;
    PUCHAR                      pAddr;
    ULONG                       Ioctl;

    //
    // Get the local name table
    //
    Ioctl = IOCTL_TDI_QUERY_INFORMATION;

    Status = STATUS_BUFFER_OVERFLOW;

    while (Status == STATUS_BUFFER_OVERFLOW)
    {
        WinsMscAlloc(BufferSize, &pBuffer);
        Status = DeviceIoCtrl(
                              &sNetbtGetAddrEvtHdl,
                              pBuffer,
                              BufferSize,
                              Ioctl
                             );

        if (Status == STATUS_BUFFER_OVERFLOW)
        {
            WinsMscDealloc(pBuffer);

            BufferSize *=2;
            if (BufferSize == 0xFFFF)
            {
                WINSEVT_LOG_D_M(BufferSize, WINS_EVT_UNABLE_TO_ALLOCATE_PACKET);
                DBGPRINT1(ERR, "CommGetNetworkAdd: Unable to get address from NBT\n", BufferSize);
                return(WINS_FAILURE);
            }
        }
    }


    pAdapterStatus = (tADAPTERSTATUS *)pBuffer;
    if (pAdapterStatus->AdapterInfo.name_count == 0)
    {
        WINSEVT_LOG_D_M(WINS_FAILURE, WINS_EVT_ADAPTER_STATUS_ERR);
        DBGPRINT0(ERR, "CommGetNetworkAdd: No names in NBT cache\n");
        return(WINS_FAILURE);
    }


    //
    // print out the Ip Address of this node
    //
    pAddr = &pAdapterStatus->AdapterInfo.adapter_address[2];
    NMSMSGF_RETRIEVE_IPADD_M(pAddr, pAdd->Add.IPAdd);

    WinsMscDealloc(pBuffer);
    return(WINS_SUCCESS);
}
#else
STATUS
CommGetNetworkAdd(
    )

/*++

Routine Description:

    This routine gets all the Ip Addresses of Netbt interfaces.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    ULONG                       Buffer[NBT_MAXIMUM_BINDINGS + 1];
    ULONG                       BufferSize=sizeof(Buffer);
    NTSTATUS                    Status;
    ULONG                       Ioctl;
    PULONG                      pBuffer;
    PULONG                      pBufferSv;
    DWORD                       i, Count;
    BOOL                        fAlloc = FALSE;

    //
    // Get the local addresses
    //
    Ioctl = IOCTL_NETBT_GET_IP_ADDRS;


    //
    // NETBT does not support more than 64 adapters and not more than
    // one ip address per adapter.  So, there can be a max of 64 ip addresses
    // which means we don't require more than 65 * 4 = 280 bytes (256 for the
    // addresses  followed by a delimiter address of 0.
    //
    Status = DeviceIoCtrl(
                              &sNetbtGetAddrEvtHdl,
                              (LPBYTE)Buffer,
                              BufferSize,
                              Ioctl
                             );

    if (Status != STATUS_SUCCESS)
    {
        BufferSize *= 10;  //alocate a buffer that is 10 times bigger.
                           //surely, netbt can not be supporting so many
                           //addresses.  If it is, then the netbt developer
                           //goofed in that (s)he did not update
                           //NBT_MAXIMUM_BINDINGS in nbtioctl.h
        WinsMscAlloc(BufferSize, &pBuffer);

        DBGPRINT1(ERR, "CommGetNetworkAdd: Ioctl - GET_IP_ADDRS failed. Return code = (%x)\n", Status);
        Status = DeviceIoCtrl(
                              &sNetbtGetAddrEvtHdl,
                              (LPBYTE)pBuffer,
                              BufferSize,
                              Ioctl
                             );
        if (Status != STATUS_SUCCESS)
        {
            DBGPRINT1(ERR, "CommGetNetworkAdd: Ioctl - GET_IP_ADDRS failed AGAIN. Return code = (%x)\n", Status);
            WINSEVT_LOG_M(Status, WINS_EVT_UNABLE_TO_GET_ADDRESSES);
            WinsMscDealloc(pBuffer);  //dealloc the buffer
            return(WINS_FAILURE);
        }
        fAlloc = TRUE;

    }
    else
    {
        pBuffer = Buffer;
    }

    //
    // Count the number of addresses returned
    // The end of the address table contains -1 and any null addresses
    // contain 0
    //
    pBufferSv = pBuffer;
    for(Count=0; *pBuffer != -1; pBuffer++)
    {
        // Increment Count only if it is a valid address.
        if ( *pBuffer ) {
            Count++;
        }
    }

    if ( !Count ) {
        DBGPRINT0(ERR, "CommGetNetworkAdd: Netbt did not give any valid address\n");
        WINSEVT_LOG_M(Status, WINS_EVT_UNABLE_TO_GET_ADDRESSES);
        if (fAlloc)
        {
           WinsMscDealloc(pBufferSv);
        }

        return(WINS_FAILURE);
    }

    if (pWinsAddresses)
    {
         WinsMscDealloc(pWinsAddresses);
    }
    //
    // Allocate space for the addresses
    //
    WinsMscAlloc(sizeof(ADD_T) + ((Count - 1) * COMM_IP_ADD_SIZE), &pWinsAddresses);
    pWinsAddresses->NoOfAdds = Count;
    pBuffer = pBufferSv;
    // Copy all valid addresses
    for (i=0; i<Count; pBuffer++)
    {
        if ( *pBuffer ) {

            pWinsAddresses->IpAdd[i] = *pBuffer;
            i++;
        }
    }
    if (fAlloc)
    {
       WinsMscDealloc(pBufferSv);
    }

    return(WINS_SUCCESS);
}
#endif

//------------------------------------------------------------------------
NTSTATUS
DeviceIoCtrl(
    IN LPHANDLE         pEvtHdl,
    IN PVOID                pDataBuffer,
    IN DWORD                DataBufferSize,
    IN ULONG            Ioctl
    )

/*++

Routine Description:

    This procedure performs an ioctl(I_STR) on a stream.

Arguments:

    fd        - NT file handle
    iocp      - pointer to a strioctl structure

Return Value:

    0 if successful, -1 otherwise.

--*/

{
    NTSTATUS                        status;
    IO_STATUS_BLOCK                 iosb;
#if NEWNETBTIF == 0
    TDI_REQUEST_QUERY_INFORMATION   QueryInfo;
#endif
    PVOID                           pInput = NULL;
    ULONG                           SizeInput = 0;


#if NEWNETBTIF == 0
PERF("TDI_QUERY_INFORMATION is used only at WINS initialization")
    if (Ioctl == IOCTL_TDI_QUERY_INFORMATION)
    {
        pInput = &QueryInfo;
        QueryInfo.QueryType = TDI_QUERY_ADAPTER_STATUS; // node status
        SizeInput = sizeof(TDI_REQUEST_QUERY_INFORMATION);
    }
#endif

   while (TRUE)
   {
     status = NtDeviceIoControlFile(
                      WinsCnfNbtHandle,                      // Handle
                      *pEvtHdl,                    // Event
                      NULL,                    // ApcRoutine
                      NULL,                    // ApcContext
                      &iosb,                   // IoStatusBlock
                      Ioctl,                   // IoControlCode
                      pInput,                         // InputBuffer
                      SizeInput,               // Buffer Length
                      pDataBuffer,             // Output Buffer
                      DataBufferSize           // Output BufferSize
                        );


     if (status == STATUS_SUCCESS)
     {
        return(status);
     }
     else
     {
        //
        // If status is PENDING, do a wait on the event
        //
        if (status == STATUS_PENDING)
        {
            status = NtWaitForSingleObject(
                          *pEvtHdl,                   // Handle
                          TRUE,                       // Alertable
                          NULL);                      // Timeout

            if (status == STATUS_SUCCESS)
            {
                 return(status);
            }
        }
     }

     //
     // status returned by NtDeviceIoCtrl or NtWaitForSingleObject is
     // a failure code
     //
     DBGPRINT1(ERR, "DeviceIoCtrl, Status returned is (%x)\n", status);
     if (status != STATUS_CANCELLED)
     {
        //
        // If it is insufficient resources, we drop this datagram and
        // try again (only for recv)
        //
        if (Ioctl == IOCTL_NETBT_WINS_RCV)
        {
                if (status == STATUS_INSUFFICIENT_RESOURCES)
                {
                        continue;
                }
        }
        //
        // in case of a send, it can be invalid handle, invalid
        // parameter or insufficient resourcesi.  If it is INVALID_PARAMETER,
        // it means that we passed 0 in the Address field on top of the buffer.
        //
        // Drop this datagram and return to the caller
        //
        if (Ioctl == IOCTL_NETBT_WINS_SEND)
        {
                if (
                        (status == STATUS_INSUFFICIENT_RESOURCES)
                                        ||
                        (status == STATUS_INVALID_PARAMETER)
                   )
                {
                        return(STATUS_SUCCESS);
                }
                else
                {
                        DBGPRINT1(EXC, "NtDeviceIoCtrl returned error = (%x)\n",
                                        status);
                        WINSEVT_LOG_D_M(status, WINS_EVT_NETBT_SEND_ERR);


                         //
                         // If the machine's address has gone away due to some
                         // reason, WinsCnfNbtHandle will have been changed
                         // to NULL.  In this case, we will get
                         // STATUS_INVALID_HANDLE error.  We do not check for
                         // handle being NULL prior to making the Nbt call
                         // to avoid an if check which is of no value for
                         // 99% of the time.
                         //
                         // An error will be logged up above.  We should not see
                         // too many of these since the window where
                         // WinsCnfNbtHandle is NULL is very small unless WINS
                         // is terminating in which case this thread will
                         // just terminate as a result of the exception being
                         // raised below.
                         //
                         // The address can go away due to the following reasons
                         //
                         //  1) psched installation (unbind followed by bind)
                         //  2) Changing from dhcp/static or static/dhcp
                         //  3) ipconfig release/renew
                         //

                         //
                         // When the main thread has to terminate WINS, it
                         // closes WinsCnfNetbtHandle. A worker thread or a
                         // challenge thread might be busy dealing with its
                         // queue of work items (potentially long on a busy
                         // WINS) and may not see a termination
                         // signal from the main thread.  This exception will
                         // terminate it
                         //

                         //
                         // Raise an exception if the wins is terminating
                         //
                         if (WinsCnf.State_e == WINSCNF_E_TERMINATING)
                         {
                               WINS_RAISE_EXC_M(WINS_EXC_NBT_ERR);
                         }
                }
         }
        break;
      }
      break;
    } // end of while (TRUE)
    return(status);
}
#endif

LPVOID
CommHeapAlloc(
  IN PRTL_GENERIC_TABLE pTable,
  IN CLONG                BuffSize
)

/*++

Routine Description:
        This function is called to allocate a buffer

Arguments:
        pTable   - Table where the buffer will be stored
        BuffSize - Size of buffer to allocate

Externals Used:
        None


Return Value:

   Success status codes -- ptr to buffer allocated
   Error status codes  --

Error Handling:

Called by:
        RtlInsertElementGeneric()

Side Effects:

Comments:
        This function exists just because the RtlTbl functions require
        this prototype for the user specified alloc function.
--*/

{
        LPVOID pTmp;

          UNREFERENCED_PARAMETER(pTable);

        pTmp = WinsMscHeapAlloc( CommUdpDlgHeapHdl, (DWORD) BuffSize );

        return(pTmp);

}


VOID
CommHeapDealloc(
  IN PRTL_GENERIC_TABLE pTable,
  IN PVOID                pBuff
)

/*++

Routine Description:

  This function is called to deallocate memory allocated via CommAlloc.


Arguments:
        pTable - Table where buffer was stored
        pBuff  - Buffer to deallocate


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        The pTable argument is required since the address of this function
        is passed as an argument to RtlTbl functions
--*/

{


          UNREFERENCED_PARAMETER(pTable);
        WinsMscHeapFree(
                        CommUdpDlgHeapHdl,
                        pBuff
                      );
        return;

}

VOID
CommDecConnCount(
   VOID
 )

/*++

Routine Description:
  This function decrements the conn. count

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
         DWORD ConnCount;
         ConnCount = InterlockedExchange(&CommConnCount, CommConnCount);
         if (ConnCount != 0)
         {
               InterlockedDecrement(&CommConnCount);
         }
         else
         {
               DBGPRINT0(ERR, "CommDecConnCount: WEIRD: ConnCount should not have been zero\n");
         }
         return;
}

#if PRSCONN
__inline
BOOL
CommIsDlgActive (
  PCOMM_HDL_T   pDlgHdl
)
{

     fd_set RdSocks;
     int NoOfSockReady;
     BOOL  fRetStat = TRUE;
     DWORD  Error;

     PCOMMASSOC_DLG_CTX_T pDlgCtx = pDlgHdl->pEnt;
     PCOMM_HDL_T pAssocHdl = &pDlgCtx->AssocHdl;
     PCOMMASSOC_ASSOC_CTX_T pAssocCtx = pAssocHdl->pEnt;

     if (!CommLockBlock(pAssocHdl))
     {
        return(FALSE);
     }
try  {

     FD_ZERO(&RdSocks);
     FD_SET(pAssocCtx->SockNo, &RdSocks);
     sTimeToWait.tv_sec = 0;

//
// Pass socket and a win32 event with flag of FD_CLOSE to WSAEventSelect.
// if the socket is disconnected, the event will be set.  NOTE, only one
// event select can be active on the socket at any time - vadime 9/2/98
//
FUTURES("Use WSAEventSelect for marginally better performance")

     if (NoOfSockReady = select(
                                            FD_SETSIZE /*ignored arg*/,
                                            &RdSocks,
                                            (fd_set *)0,
                                            (fd_set *)0,
                                            &sTimeToWait
                                                  ) == SOCKET_ERROR)
    {
                Error = WSAGetLastError();
                DBGPRINT1(ERR,
                "RecvData: Timed Select returned SOCKET ERROR. Error = (%d)\n",
                                Error);
//                CommDecConnCount();
                return(FALSE);
    }
    else
    {
                DBGPRINT1(FLOW, "ReceiveData: Timed Select returned with success. No of Sockets ready - (%d) \n", NoOfSockReady);

             //
             // Either there is data or the socket is disconnected.  There
             // should never be any data.  We will just assume a disconnect
             // is there and return FALSE.  The client (RPL) will end the dlg.
             //
             if (NoOfSockReady == 1)
             {
                      fRetStat = FALSE;
             }
             ASSERT(NoOfSockReady == 0);
     }
 }
finally {
    CommUnlockBlock(pAssocHdl);
   }

   return(fRetStat);

}

#endif

#if MCAST > 0


VOID
JoinMcastGrp(
 VOID
)

/*++

Routine Description:
    This function is called by the comm. subsystem to make WINS join
    a multicast group

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:
       CommCreatePorts
Side Effects:

Comments:
	None
--*/

{
    int Loop = 0;  //to disable loopback of multicast messages on the
                     //same interface
    DWORD  Error;
    struct ip_mreq mreq;
    DBGENTER("JoinMcastGrp\n");
#if 0
    //
    // Open a socket for sending/receiving multicast packets.  We open
    // a seperate socket instead of using the one for udp datagrams since
    // we don't want to impact the client name packet processing with any
    // sort of overhead.  Also, having a seperate socket keeps things nice
    // and clean.
    //
    if (  (CommMcastPortHandle = socket(
                                PF_INET,
                                SOCK_DGRAM,
                                IPPROTO_UDP
                                 )
          )  == INVALID_SOCKET
       )
   {
        Error = WSAGetLastError();
        DBGPRINT1(MTCAST, "JoinMcastGrp: Can not create MCAST socket\n", Error);
//      WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_MCAST_SOCK);  //log an event
        return;
   }
#endif
   //
   // Set TTL
   //
   if (setsockopt(
                 CommUdpPortHandle,
                 IPPROTO_IP,
                 IP_MULTICAST_TTL,
                 (char *)&WinsCnf.McastTtl,
                 sizeof((int)WinsCnf.McastTtl)) == SOCKET_ERROR)
   {

        closesocket(CommUdpPortHandle);
        CommUdpPortHandle = INVALID_SOCKET;
        Error = WSAGetLastError();
        DBGPRINT1(MTCAST, "JoinMcastGrp: Can not set TTL option. Error = (%d)\n", Error);
//      WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_MCAST_SOCK);  //log an event
        return;
   }

#if 0
   //
   // Disable loopback of messages
   //
   if (setsockopt(CommUdpPortHandle, IPPROTO_IP, IP_MULTICAST_LOOP,
                      (char *)&Loop, sizeof(Loop)) == SOCKET_ERROR)
   {

        closesocket(CommUdpPortHandle);
        CommUdpPortHandle = INVALID_SOCKET;
        Error = WSAGetLastError();
        DBGPRINT1(MTCAST, "JoinMcastGrp: Can not set DISABLE LOOPBACK option. Error = (%d)\n",
                         Error);
//      WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_MCAST_SOCK);  //log an event
        return;
   }
#endif
   //
   // Join a multicast grp
   //
   mreq.imr_multiaddr.s_addr = htonl(McastAdd.sin_addr.s_addr);
   mreq.imr_interface.s_addr  = INADDR_ANY;    //use the default mcast i/f

   if (setsockopt(CommUdpPortHandle, IPPROTO_IP, IP_ADD_MEMBERSHIP,
                    (char *)&mreq, sizeof(mreq)) == SOCKET_ERROR)
   {

        Error = WSAGetLastError();
        closesocket(CommUdpPortHandle);
        CommUdpPortHandle = INVALID_SOCKET;
        DBGPRINT1(MTCAST, "JoinMcastGrp: Can not ADD SELF TO MCAST GRP. Error = (%d)\n", Error);
//      WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_MCAST_SOCK);  //log an event
        return;
   }

    DBGLEAVE("JoinMcastGrp\n");

    return;
}
VOID
CommLeaveMcastGrp(
 VOID
)

/*++

Routine Description:
    This function is called by the comm. subsystem to make WINS join
    a multicast group

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:
       CommCreatePorts
Side Effects:

Comments:
	None
--*/

{
    DWORD  Error;
    struct ip_mreq mreq;

   //
   // Leave a multicast grp
   //
   mreq.imr_multiaddr.s_addr = htonl(McastAdd.sin_addr.s_addr);
   mreq.imr_interface.s_addr  = INADDR_ANY;    //use the default mcast i/f

   if (setsockopt(CommUdpPortHandle, IPPROTO_IP, IP_DROP_MEMBERSHIP,
                    (char *)&mreq, sizeof(mreq)) == SOCKET_ERROR)
   {

        Error = WSAGetLastError();
        DBGPRINT1(MTCAST, "CommLeaveMcastGrp: Can not DROP MEMBERSHIP TO MCAST GRP. Error = (%d)\n", Error);
        return;
   }

    return;
}




BOOL
CheckMcastSock(
   IN fd_set  *pActSocks,
   IN fd_set  *pRdSocks
 )
{
        DWORD                   Error;
        int                     RetVal;
        BYTE                    Buff[COMM_DATAGRAM_SIZE];
        PCOMM_MCAST_MSG_T       pMcastMsg = (PCOMM_MCAST_MSG_T)Buff;
        struct sockaddr_in      RemWinsAdd;
        int                     RemWinsAddLen = sizeof(RemWinsAdd);

        LPBYTE                  pBody;
        COMM_IP_ADD_T           IPAdd;
        BOOL                    fFound;
        DWORD                   i, j;
        DWORD                   NoOfAddsInPkt;
        struct  in_addr         InAdd;
        LPBYTE                  pAdd;
        DWORD                   FirstDelEntryIndex;
        PPNR_STATUS_T           pPnrStatusTmp;

        DBGENTER("CheckMcastSock\n");
        if (FD_ISSET(CommUdpPortHandle, pRdSocks))
        {
                  //do a recvfrom to read in the data.
                  RetVal = recvfrom(
                                CommUdpPortHandle,
                                (char *)pMcastMsg,
                                COMM_DATAGRAM_SIZE,
                                //COMM_MCAST_MSG_SZ + COMM_IP_ADD_SIZE,
                                0,     //default flags (i.e. no peeking
                                       //or reading OOB message
                                (struct sockaddr *)&RemWinsAdd,
                                &RemWinsAddLen
                                    );

                  if (RetVal == SOCKET_ERROR)
                  {
                        Error = WSAGetLastError();
                        DBGPRINT1(MTCAST, "CheckMcastSock: recvfrom failed. Error = (%d)\n", Error);
                        if (WinsCnf.State_e != WINSCNF_E_TERMINATING)
                        {
                          WINSEVT_LOG_M(
                                        Error,
                                        WINS_EVT_WINSOCK_RECVFROM_ERR
                                     );
                        }
                        //WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
                  }

                 //
                 // If we were told not to use self found pnrs, return
                 //
                 if (!WinsCnf.fUseSelfFndPnrs)
                 {
                    DBGLEAVE("ChkMcastSock - 99\n");
                    return(TRUE);
                 }

                 //
                 // If the sign is not in the valid range, return
                 //
                 if ((pMcastMsg->Sign < COMM_MCAST_SIGN_START) || (pMcastMsg->Sign > COMM_MCAST_SIGN_END))
                 {
                      DBGPRINT1(MTCAST, "Signature in received message = %d\n", pMcastMsg->Sign);
                      DBGLEAVE("CheckMcastSock - 1\n");
                      return(TRUE);
                 }

                 //
                 // Compute the number of addresses in the packet.
                 //
                 NoOfAddsInPkt = (RetVal - (COMM_MCAST_MSG_SZ - 1))/COMM_IP_ADD_SIZE;
                 DBGPRINT2(MTCAST, "ChkMcastSock: RetVal = (%d);NoOfAddsInPkt = (%d)\n", RetVal, NoOfAddsInPkt);

                 FirstDelEntryIndex = pPnrStatus->NoOfPnrs;
                 pBody = pMcastMsg->Body;

                 IPAdd = *(PCOMM_IP_ADD_T)pBody;
                 pBody += COMM_IP_ADD_SIZE;

                 //
                 // Loop until either all ip addresses in packets are
                 // exhausted or we get an ip. address of 0.  If somebody
                 // sent a 0 address, then it is ok to ignore the rest.
                 //
                 for(
                            ;
                      (IPAdd != 0) && NoOfAddsInPkt;
                      IPAdd = *(PCOMM_IP_ADD_T)pBody, pBody += COMM_IP_ADD_SIZE,
                                             NoOfAddsInPkt--
                    )
                 {

                     DBGPRINT1(MTCAST, "CheckMcastSock: Processing WINS address = %lx\n", ntohl(IPAdd));
                     fFound = FALSE;
                     pPnrStatusTmp = (PPNR_STATUS_T)(pPnrStatus->Pnrs);
                     if (pMcastMsg->Code == COMM_MCAST_WINS_UP)
                     {
                         for (i=0; i < pPnrStatus->NoOfPnrs; i++, pPnrStatusTmp++)
                         {
                              if ((FirstDelEntryIndex == pPnrStatus->NoOfPnrs)
                                              &&
                                  (pPnrStatusTmp->State == COMM_MCAST_WINS_DOWN))
                              {
                                  FirstDelEntryIndex = i;
                              }

                              if (IPAdd == pPnrStatusTmp->IPAdd)
                              {
                                  if (pPnrStatusTmp->State == COMM_MCAST_WINS_DOWN)
                                  {
                                     pPnrStatusTmp->State = COMM_MCAST_WINS_UP;
                                     InAdd.s_addr      = IPAdd;
                                     pAdd              = inet_ntoa(InAdd);
                                     WinsCnfAddPnr(RPL_E_PULL, pAdd);
                                     WinsCnfAddPnr(RPL_E_PUSH, pAdd);
                                  }
                                  fFound = TRUE;
                                  break;
                              }
                         }
                         if (!fFound  && (i <= pPnrStatus->NoOfPnrs))
                         {
                             DWORD FirstFreeIndex;
                             PPNR_STATUS_T pPnr;
                             //
                             // since disable loopback is not working we
                             // have to check for message sent by self
                             //
FUTURES("Remove the if when winsock is enhanced to allow loopback to be")
FUTURES("disabled")
                             if (!ChkMyAdd(ntohl(IPAdd)))
                             {
                               InAdd.s_addr = IPAdd;
                               pAdd         = inet_ntoa(InAdd);

                               if (FirstDelEntryIndex < pPnrStatus->NoOfPnrs)
                               {
                                     FirstFreeIndex = FirstDelEntryIndex;
                               }
                               else
                               {
                                     FirstFreeIndex = pPnrStatus->NoOfPnrs++;
                                     if (pPnrStatus->NoOfPnrs == pPnrStatus->NoOfPnrSlots)
                                      {

                                        WINSMSC_REALLOC_M(MCAST_PNR_STATUS_SIZE_M(pPnrStatus->NoOfPnrSlots * 2), (LPVOID *)&pPnrStatus);
                                        pPnrStatus->NoOfPnrSlots *= 2;
                                        DBGPRINT1(DET, "CheckMcastSock: NO OF PNR SLOTS INCREASED TO (%d)\n", pPnrStatus->NoOfPnrSlots);

                                      }
                               }
                               pPnr = (PPNR_STATUS_T)(pPnrStatus->Pnrs);
                               (pPnr + FirstFreeIndex)->State = COMM_MCAST_WINS_UP;
                               (pPnr + FirstFreeIndex)->IPAdd = IPAdd;

                               WinsCnfAddPnr(RPL_E_PULL, pAdd);
                               WinsCnfAddPnr(RPL_E_PUSH, pAdd);

                               DBGPRINT1(MTCAST, "CheckMcastSock: ADDED WINS partner with address = %s\n", pAdd);
                             }
                         }
                   }
                   else  //has to be COMM_MCAST_WINS_DOWN
                   {
                         for (i=0; i < pPnrStatus->NoOfPnrs; i++, pPnrStatusTmp++)
                         {
                              if (IPAdd == pPnrStatusTmp->IPAdd)
                              {
                                  if (pPnrStatusTmp->State == COMM_MCAST_WINS_DOWN)
                                  {
                                    fFound = TRUE;
                                  }
                                  else
                                  {
                                      pPnrStatusTmp->State = COMM_MCAST_WINS_DOWN;
                                  }
                                  break;
                              }
                         }
                         if (!fFound)
                         {
                           InAdd.s_addr = IPAdd;
                           pAdd = inet_ntoa(InAdd);
                           DBGPRINT1(MTCAST, "CheckMcastSock: Will REMOVE WINS partner with address = %s IFF Untouched by admin\n", pAdd);
                           WinsCnfDelPnr(RPL_E_PULL, pAdd);
                           WinsCnfDelPnr(RPL_E_PUSH, pAdd);
                         }
                 }
               } // end of for loop
               DBGLEAVE("ChkMcastSock - 2\n");
               return(TRUE);
       }

       DBGLEAVE("ChkMcastSock - 3\n");
       return(FALSE);
}

BOOL
ChkMyAdd(
 COMM_IP_ADD_T IpAdd
 )
{
  DWORD i;
  PCOMM_IP_ADD_T pIpAdd = pWinsAddresses->IpAdd;
  for (i=0; i<pWinsAddresses->NoOfAdds; i++)
  {
      if (IpAdd == *pIpAdd++)
      {
          return(TRUE);
      }
  }
  return(FALSE);
}

VOID
CommSendMcastMsg(
      DWORD Code
 )
{

  PCOMM_MCAST_MSG_T  pMcastMsg;
  DWORD             McastMsgLen;
  LPBYTE            pBody;
  DWORD             i;
  COMM_IP_ADD_T     Add = 0;

  // --ft bug #103361: no need to send CommSendMcastMsg if there
  // is no nic card here
  if (pWinsAddresses == NULL)
      return;

  McastMsgLen = MCAST_PKT_LEN_M(pWinsAddresses->NoOfAdds + 1);

  WinsMscAlloc(McastMsgLen, &pMcastMsg);

  pMcastMsg->Code = Code;
  pMcastMsg->Sign = COMM_MCAST_SIGN_START;
  pBody = pMcastMsg->Body;

  //
  // Insert the count in net order.
  //
//  NMSMSGF_INSERT_ULONG_M(pBody, pWinsAddresses->NoOfAddresses);

  //
  // Insert the addresses in net order
  //
  for (i=0; i<pWinsAddresses->NoOfAdds; i++)
  {
    DBGPRINT1(MTCAST, "CommSendMcastMsg: Inserting Address = (%lx)\n",
                        pWinsAddresses->IpAdd[i]);
    NMSMSGF_INSERT_IPADD_M(pBody, pWinsAddresses->IpAdd[i]);
  }
  NMSMSGF_INSERT_IPADD_M(pBody, Add);


  DBGPRINT1(MTCAST, "CommSendMcastMsg: Sending MCAST msg of length = (%d)\n",
                                               McastMsgLen);
  CommSendUdp (CommUdpPortHandle, &McastAdd, (MSG_T)pMcastMsg, McastMsgLen);

  WinsMscDealloc(pMcastMsg);
  return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\com\assoc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	assoc.c

Abstract:
	THis module contains the functions that deal with associations and
	dialogues

Functions:
	CommAssocSetUpAssoc
	CommAssocFrmStartAssocReq
	CommAssocUfmStartAssocReq
	CommAssocFrmStopAssocReq
	CommAssocUfmStopAssocReq
	CommAssocFrmStartAssocRsp
	CommAssocUfmStartAssocRsp
	CommAssocAllocAssoc
	CommAssocAllocDlg
	AllocEnt
	DeallocEnt
	CommAssocDeallocAssoc	
	CommAssocDeallocDlg
	CommAssocInit
	CommAssocInsertUdpDlgInTbl
	CommAssocDeleteUdpDlgInTbl
	CommAssocCreateAssocInTbl
	CommAssocDeleteAssocInTbl
	CommAssocLookupAssoc
	CommAssocInsertAssocInTbl
	

Portability:

	This module is portable

Author:

	Pradeep Bahl (PradeepB)  	7-Dec-1992

Revision History:

	Modification date	Person		Description of modification
        -----------------	-------		----------------------------
--*/

/*
 *       Includes
*/
#include "wins.h"
#include "nms.h"
#include "comm.h"
#include "assoc.h"
#include "winsque.h"
#include "winsmsc.h"
#include "winsevt.h"

/*
 *	Local Macro Declarations
 */


/*
 *	Local Typedef Declarations
*/

#if PRSCONN
STATIC DWORD		sAssocSeqNo = 0;
#else
STATIC DWORD		sAssocSeqNo = 1;
#endif

STATIC QUE_HD_T		sAssocQueHd;
STATIC CRITICAL_SECTION sAssocListCrtSec;

#if PRSCONN
STATIC DWORD		sDlgSeqNo = 0;
#else
STATIC DWORD		sDlgSeqNo = 1;
#endif

STATIC QUE_HD_T		sDlgQueHd;
STATIC DWORD        sNoOfDlgCrtSec;     //no of crt. secs in dlgs
STATIC DWORD        sNoOfAssocCrtSec;   //no of crt. secs in assocs.
STATIC CRITICAL_SECTION sDlgListCrtSec;

STATIC LIST_ENTRY sUdpDlgHead;

COMMASSOC_TAG_POOL_T sTagAssoc;  //32bit ULONG -> LPVOID mapping

/*
 *	Global Variable Definitions
 */


/*
  Handles to the heaps to be used for assoc. and dlg. allocation
*/
HANDLE			CommAssocAssocHeapHdl;
HANDLE			CommAssocDlgHeapHdl;
HANDLE			CommAssocTcpMsgHeapHdl;

/*
  Size of the memory for one assoc.
*/
DWORD			CommAssocAssocSize = 0;

/*
  Size of
DWORD			CommAssocMaxAssoc  = 0;


/*
 *	Local Variable Definitions
 */

STATIC CRITICAL_SECTION       sUdpDlgTblCrtSec;

//
// This is the start of the Responder Assoc Table.  This table holds the list of
// active Responder associations.  Currently, the table is implemented
// as a linked list using the Rtl Linked list functions.
//
QUE_HD_T	     sRspAssocQueHd;

/*
 *	Local Function Prototype Declarations
*/

/* prototypes for functions local to this module go here */
STATIC
LPVOID
AllocEnt(
	HANDLE		   HeapHdl,
	PQUE_HD_T	   pQueHd,
	LPCRITICAL_SECTION pCrtSec,
	LPDWORD		   pSeqNoCntr,
	DWORD		   Size,
    LPDWORD        pCntCrtSec
	);

STATIC
VOID
DeallocEnt(
	HANDLE		   HeapHdl,
	PQUE_HD_T	   pQueHd,
	LPCRITICAL_SECTION pCrtSec,
	LPDWORD		   pSeqNoCntr,
	LPVOID		   pHdl,
    LPDWORD        pCntCrtSec
	);


//
// Function definitions start here
//

VOID
CommAssocSetUpAssoc(
	IN  PCOMM_HDL_T			pDlgHdl,
	IN  PCOMM_ADD_T			pAdd,
	IN  COMM_TYP_E			CommTyp_e,
	OUT PCOMMASSOC_ASSOC_CTX_T	*ppAssocCtx		
	)

/*++

Routine Description:

	This function sets up an association
Arguments:
	pDlghdl   - Handle to dlg under which an association has to be set up
	pAdd      - Address of node with which the association has to be set up
	CommTyp_e - TYpe of association
	ppAssocCtx - Association Context block allocated by the function


Externals Used:
	None

Called by:
	ECommStartDlg
Comments:
	None
	
Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   --

--*/

{

	SOCKET 		        SockNo = INVALID_SOCKET;
	PCOMMASSOC_ASSOC_CTX_T 	pAssocCtx = NULL; //v. imp to init this to NULL
	INT		 	BytesRead = -1;
	MSG_T		 	pTcpMsg;
	STATUS			RetStat;
	WINS_MEM_T	 	WinsMem[2];
	PWINS_MEM_T	 	pWinsMem = WinsMem;
#if SUPPORT612WINS > 0
	BYTE		 	AssocMsg[COMMASSOC_POST_BETA1_ASSOC_MSG_SIZE];
	DWORD		 	MsgLen = COMMASSOC_POST_BETA1_ASSOC_MSG_SIZE;
#else
	BYTE		 	AssocMsg[COMMASSOC_ASSOC_MSG_SIZE];
	DWORD		 	MsgLen = COMMASSOC_ASSOC_MSG_SIZE;
#endif
	PCOMMASSOC_DLG_CTX_T 	pDlgCtx = pDlgHdl->pEnt;
	pWinsMem->pMem = NULL;
	
try {

	/*
	*  Create a TCP connection to the WINS at the other node
	*/
	CommConnect(
         pAdd,
		CommWinsTcpPortNo,          // WINS_TCP_PORT,
		&SockNo
		   );

	/*
	*  Allocate the assoc context block
	*/
	pAssocCtx = CommAssocAllocAssoc();
	
	pAssocCtx->SockNo  	= SockNo;
	pAssocCtx->uRemAssocCtx = 0;
	pAssocCtx->State_e 	= COMMASSOC_ASSOC_E_NON_EXISTENT;
	pAssocCtx->Role_e  	= COMMASSOC_ASSOC_E_INITIATOR;
	pAssocCtx->Typ_e   	= CommTyp_e;
	pAssocCtx->DlgHdl  	= *pDlgHdl;
	pAssocCtx->RemoteAdd.sin_addr.s_addr  	= pAdd->Add.IPAdd;
    pAssocCtx->nTag     = CommAssocTagAlloc(&sTagAssoc,pAssocCtx);


	/*
		Format the start association message.

		The address passed to the formatting function is offset
		from the address of the buffer by a LONG so that CommSendAssoc
		can store the length of the message in it.
	*/
	CommAssocFrmStartAssocReq(
				pAssocCtx,
				AssocMsg + sizeof(LONG),
				MsgLen - sizeof(LONG)
				);


	pDlgCtx->AssocHdl.pEnt  = pAssocCtx;
	pDlgCtx->AssocHdl.SeqNo = pAssocCtx->Top.SeqNo;

	/*
	*  send the message on the TCP connection
	*/
	CommSendAssoc(
			pAssocCtx->SockNo,
			AssocMsg + sizeof(LONG),
			MsgLen - sizeof(LONG)
		   );

	/*
		Read in the response message
	*/
	RetStat =  CommReadStream(
			pAssocCtx->SockNo,
			TRUE,		// do timed wait
			&pTcpMsg,
			&BytesRead
		      		 );

	
	/*
	  If the return status is not WINS_SUCCESS or bytes read are 0, then
	  either it is a disconnect or the read timed out.  Raise an exception.
	  (We should have gotten either a start or a stop assoc.  message.
	*/
	if ((BytesRead != 0) && (RetStat == WINS_SUCCESS))
	{

		DWORD  Opc;
		DWORD  MsgTyp;
		ULONG  uNoNeed;

		pWinsMem->pMem = pTcpMsg - sizeof(LONG) - COMM_BUFF_HEADER_SIZE;
		(++pWinsMem)->pMem   = NULL;

		/*
		 * unformat the response
		*/
		COMM_GET_HEADER_M(pTcpMsg, Opc, uNoNeed, MsgTyp);
	

		/*
		* if MsgTyp indicates that it is a start assoc. response
		* message, change state of association to Active; return
		* success
		*/
		if (MsgTyp == COMM_START_RSP_ASSOC_MSG)
		{
			CommAssocUfmStartAssocRsp(
			    pTcpMsg,
                            &pAssocCtx->MajVersNo,
                            &pAssocCtx->MinVersNo,
			                &pAssocCtx->uRemAssocCtx
						 );

			pAssocCtx->State_e   = COMMASSOC_ASSOC_E_ACTIVE;
#if SUPPORT612WINS > 0
                        //
                        // If bytes read are less than what a post-beta1
                        // WINS sends us, it means that it must be a beta1 WINS.
                        //
                        if (BytesRead >= (COMMASSOC_POST_BETA1_ASSOC_MSG_SIZE - sizeof(LONG)))
                        {
#if 0
                            pAssocCtx->MajVersNo = WINS_BETA2_MAJOR_VERS_NO;
                            pAssocCtx->MinVersNo = 1; //not used currently
#endif
                        }
                        else
                        {
                            pAssocCtx->MajVersNo = WINS_BETA1_MAJOR_VERS_NO;
                            pAssocCtx->MinVersNo = 1; //not used currently

                        }
#endif
		}	

                //
                // Let us free the message that we received
                //
                ECommFreeBuff(pTcpMsg);

		/*
		 * if opcode indicates that it is a stop assoc. message, do
		 * cleanup; return failure
		*/
		if (MsgTyp == COMM_STOP_REQ_ASSOC_MSG)
		{
                  //
                  // Decrement conn. count
                  //
                  CommDecConnCount();
		  WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);	
	        }
	}
	else // Either Bytes Read are 0 or select timed out or some other error
	     // occurred
	{
		WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
	}
}
except (EXCEPTION_EXECUTE_HANDLER)  {

	DWORD	ExcCode = GetExceptionCode();
	DBGPRINTEXC("CommAssocSetUpAssoc");


	//
	// If the exception occurred after the socket was opened, close it
	//	
        if (SockNo != INVALID_SOCKET)
        {
		CommDisc(SockNo, TRUE);     // close the socket
	}

	//
	// if an assoc. ctx block was allocated, free it now
	//
	if (pAssocCtx != NULL)
	{
        CommAssocTagFree(&sTagAssoc, pAssocCtx->nTag);
		CommAssocDeallocAssoc(pAssocCtx);
	}
	
	//
	// reraise the exception
	//
	WINS_HDL_EXC_N_RERAISE_M(WinsMem);
   }  //end of except {..}

	*ppAssocCtx = pAssocCtx;
	return;
} //CommAssocSetUpAssoc()


VOID
CommAssocFrmStartAssocReq(
	IN  PCOMMASSOC_ASSOC_CTX_T	pAssocCtx,
	IN  MSG_T			pMsg,	
	IN  MSG_LEN_T		        MsgLen
	)


/*++

Routine Description:

	This function is called to format a start association message

Arguments:
	pAssocCtx - Association Context block
	pMsg     - Buffer containing the formatted start assoc. req. msg.
	MsgLen   - Size of the above buffer


Externals Used:
	None

Return Value:
	None

Error Handling:

Called by:
	CommAssocSetUpAssoc

Side Effects:

Comments:
	None
--*/
	
{

	ULONG		*pLong = NULL;

	/*

	 The start assoc. message  contains the following fields
	
		the assoc handle (ptr field)
		Version Number (major and minor) both are 16 bits
		Authentication Info (currently nothing)
		Association Type (an integer)

	*/
	pLong      	  =  (LPLONG)pMsg;

	COMM_SET_HEADER_M(
		pLong,
		WINS_IS_NOT_NBT,	//opcode
		0,	/*We don't have the remote guy's assoc. ptr yet*/
		COMM_START_REQ_ASSOC_MSG  //msg type
			      );

	*pLong++   = htonl(pAssocCtx->nTag);
	*pLong++   = htonl((WINS_MAJOR_VERS << 16 ) | WINS_MINOR_VERS);
	*pLong     = htonl(pAssocCtx->Typ_e);   //assoc type

	return;

}
	
	
        	

VOID
CommAssocUfmStartAssocReq(
	IN  MSG_T		        pMsg,
	OUT PCOMM_TYP_E        		pAssocTyp_e,
	OUT LPDWORD   		        pMajorVer,
	OUT LPDWORD		        pMinorVer,	
	OUT ULONG               *puRemAssocCtx
	)


/*++

Routine Description:

	This function parses the start association message that arrives on
	a TCP connection and returns with the relevant information

Arguments:
	pMsg	     -- Message to be unformatted
	pAssocTyp_e  -- Type of assoc  (i.e from who -- replicator, COMSYS, etc)
	pMajorVer    -- Major version no.
	pMinorVer    -- Minor version no.
	puRemAssocCtx -- ptr to assoc. ctx block of remote WINS


Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	ProcTcpMsg

Side Effects:

Comments:
	None
--*/

{



	/*
	  Increment pLong past the comm header
	*/
	LPLONG  pLong = (LPLONG)(pMsg + COMM_HEADER_SIZE);
	LONG    lTmp;

    *puRemAssocCtx = ntohl(*pLong++);
					//ptr to assoc. ctx at remote WINS
	/*
	 * Get the long that contains the major and minor version numbers
	*/
	lTmp = ntohl(*pLong++); 		

	*pMajorVer   = lTmp >> 16; 		//Major vers. no.
	*pMinorVer   = lTmp & 0x0ff;        	//Minor vers. no.

	*pAssocTyp_e = ntohl(*pLong);		/*Msg type (from who -- COMSYS,
						  Replicator
						*/
	return;

}	

VOID
CommAssocFrmStopAssocReq(
	IN  PCOMMASSOC_ASSOC_CTX_T   pAssocCtx,
	IN  MSG_T		     pMsg,
	IN  MSG_LEN_T		     MsgLen,
	IN  COMMASSOC_STP_RSN_E	     StopRsn_e
	)


/*++

Routine Description:
 This function formats a stop association message


Arguments:
	pAssocCtx -- Assoc. Ctx block.
	pMsg     -- Buffer containing the formatted stop assoc. req. msg.
	MsgLen   -- Length of above buffer
	StopRsn_e -- Reason why the association is being stopped

Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	CommAssocSetUpAssoc

Side Effects:

Comments:
	None
--*/
{



	unsigned long	*pLong = NULL;


	/*
	 The stop assoc. message  contains the following fields
	
		the reason for the stop/abort.

	*/


	pLong      =  (LPLONG)pMsg;

	
	COMM_SET_HEADER_M(
		pLong,
		WINS_IS_NOT_NBT,
		pAssocCtx->uRemAssocCtx,
		COMM_STOP_REQ_ASSOC_MSG
			      );
	
	*pLong   = htonl(StopRsn_e);

	return;
}

VOID
CommUfmStopAssocReq(
	IN  MSG_T			pMsg,
	OUT PCOMMASSOC_STP_RSN_E	pStopRsn_e
	)


/*++

Routine Description:
 This function formats a stop association message


Arguments:
	pMsg       - Message containing the stop assoc. req.
	pStopRsn_e - reason why the association was stopped


Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	ProcTcpMsg

Side Effects:

Comments:
	None
--*/
{
	
	/*
	  Increment pLong past the comm header
	*/
	LPLONG pLong = (LPLONG)(pMsg + COMM_HEADER_SIZE);
	
	*pStopRsn_e = ntohl(*pLong);
 	
	return;

}




VOID
CommAssocFrmStartAssocRsp(
	IN  PCOMMASSOC_ASSOC_CTX_T	pAssocCtx,
	IN  MSG_T			pMsg,	
	IN  MSG_LEN_T			MsgLen
	)


/*++

Routine Description:

	This function is called to format a start association response message

Arguments:
	pAssocCtx -- Assoc. ctx block
	pMsg     -- Buffer containing the formatted start assoc. rsp. msg.
	MsgLen   -- Length of above buffer

Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	ProcTcpMsg

Side Effects:

Comments:
	None
--*/
	
{
	LPLONG		pLong = NULL;


	/*

	 The start assoc. message  contains the following fields
	
		the assoc handle (ptr field)
		Authentication Info (currently nothing)

	*/


	pLong      =  (unsigned long *)pMsg;

	COMM_SET_HEADER_M(
		pLong,
		WINS_IS_NOT_NBT,
		pAssocCtx->uRemAssocCtx,
		COMM_START_RSP_ASSOC_MSG
			      );

    *pLong++   = htonl(pAssocCtx->nTag);
	*pLong   = htonl((WINS_MAJOR_VERS << 16 ) | WINS_MINOR_VERS);

	return;

}
	
	
        	


VOID
CommAssocUfmStartAssocRsp(
	IN  MSG_T		        pMsg,
	OUT LPDWORD   		        pMajorVer,
	OUT LPDWORD		        pMinorVer,	
	OUT ULONG               *puRemAssocCtx
	)


/*++

Routine Description:
 This function formats a stop association message


Arguments:
	pMsg          - Buffer containing the Start Assoc. rsp. message
	puRemAssocCtx - ptr to remote assoc. ctx block.

Externals Used:
	None

Return Value:
	None

Error Handling:

Called by:
	CommAssocSetUpAssoc

Side Effects:

Comments:
	None
--*/
{
	/*
	  Increment pLong past the comm header
	*/
	LPLONG pLong = (LPLONG)(pMsg + COMM_HEADER_SIZE);
        LONG   lTmp;
	
	*puRemAssocCtx = ntohl(*pLong++);
 	
	/*
	 * Get the long that contains the major and minor version numbers
	*/
	lTmp = ntohl(*pLong); 		

	*pMajorVer   = lTmp >> 16; 		//Major vers. no.
	*pMinorVer   = lTmp & 0xff;        	//Minor vers. no.

	return;

}



LPVOID
CommAssocAllocAssoc(
		VOID
)

/*++

Routine Description:
	This function allocates an association


Arguments:
	None

Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:
	ECommAssocAllocAssoc

Side Effects:

Comments:
	None
--*/

{

	return(
	   AllocEnt(
		CommAssocAssocHeapHdl,
		&sAssocQueHd,
		&sAssocListCrtSec,
		&sAssocSeqNo,
		COMMASSOC_ASSOC_DS_SZ,	
        &sNoOfAssocCrtSec	
	        )
	     );

}		

LPVOID
CommAssocAllocDlg( 	
	VOID
	)

/*++

Routine Description:
	This function allocates a dialogue context block

Arguments:
	None

Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	ECommStartDlg, ProcTcpMsg

Side Effects:

Comments:
	None
--*/

{

	return(
	  AllocEnt(
		CommAssocDlgHeapHdl,
		&sDlgQueHd,
		&sDlgListCrtSec,
		&sDlgSeqNo,
		COMMASSOC_DLG_DS_SZ,
        &sNoOfDlgCrtSec	
		    )
	     );

}		

LPVOID
AllocEnt(
	IN   HANDLE		  HeapHdl,
	IN   PQUE_HD_T	  	  pQueHd,
	IN   LPCRITICAL_SECTION   pCrtSec,
	IN   LPDWORD		  pSeqNoCntr,
	IN   DWORD		  Size,
    IN   LPDWORD      pCntOfCrtSec
	)

/*++

Routine Description:
	This function is used to allocate a ctx. block (association or dlg).

Arguments:
	HeapHdl   - Heap from where the alloc. muxt be done
	pQueHd	  - Head of free list queue
	pCrtSec   - Critical section protecting the above queue
	pSeqNoCtr - Counter value used to stamp the buffer if it is allocated
		    as versus when it is taken from the free list
	Size      - Size of buffer to allocate

Externals Used:
	None

	
Return Value:
	Ptr to the block allocated	

Error Handling:

Called by:
	CommAssocAllocAssoc, CommAssocAllocDlg	

Side Effects:

Comments:
--*/

{
	PCOMM_TOP_T	pTop;
//	DWORD		Error;
	PLIST_ENTRY	pHead = &pQueHd->Head;


	EnterCriticalSection(pCrtSec);
try {

	if (IsListEmpty(pHead))
	{	

		  pTop =   WinsMscHeapAlloc(
					   HeapHdl,
					   Size
					 );
#ifdef WINSDBG
          IF_DBG(HEAP_CNTRS)
          {
            EnterCriticalSection(&NmsHeapCrtSec);
            NmsHeapAllocForList++;
            LeaveCriticalSection(&NmsHeapCrtSec);
          }
#endif
        //
        // Init the critical section in the block we just allocated.
        //
        InitializeCriticalSection(&pTop->CrtSec);
        pTop->fCrtSecInited = TRUE;
        (*pCntOfCrtSec)++;
		pTop->SeqNo =  (*pSeqNoCntr)++;
	}
	else
	{
		pTop   = (PCOMM_TOP_T)RemoveTailList(pHead);

        //
        // Just took a free entry. Decrement count
        //
        if (!pTop->fCrtSecInited)
        {
           InitializeCriticalSection(&pTop->CrtSec);
           pTop->fCrtSecInited = TRUE;
           (*pCntOfCrtSec)++;
        }
	}

   }
finally	{
	LeaveCriticalSection(pCrtSec);
	}
	return(pTop);	
}


VOID
DeallocEnt(
	IN  HANDLE		   HeapHdl,
	IN  PQUE_HD_T	   	   pQueHd,
	IN  LPCRITICAL_SECTION     pCrtSec,
	IN  LPDWORD		   pSeqNoCntr,
	IN  LPVOID		   pEnt,
    IN  LPDWORD        pCntOfCrtSec
	)

/*++

Routine Description:
	The function deallocates a context block


Arguments:
	pQueHd	  - Head of free list queue
	pCrtSec   - Critical section protecting the above queue
	pSeqNoCtr - Counter value used to stamp the buffer before putting
		    it in the queue.
		    heap
	pEnt      - entity to be deallocated

Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	CommAssocDeallocDlg, CommAssocDeallocAssoc

Side Effects:

Comments:
	None
--*/

{
	PCOMM_TOP_T	pTop;
	PLIST_ENTRY	pHead = &pQueHd->Head;

	UNREFERENCED_PARAMETER(HeapHdl);
	pTop = pEnt;	
	EnterCriticalSection(pCrtSec);
try {
	(*pSeqNoCntr)++;
	pTop->SeqNo = *pSeqNoCntr;
	InsertTailList(pHead, &pTop->Head);
    //
    // Delete critical section if necessary to save on non-paged pool
    //
    if (*pCntOfCrtSec > COMM_FREE_COMM_HDL_THRESHOLD)
    {
       //
       //
       // We want to keep the non-paged pool within a limit.
       // Deallocate this block. This ensures that we will never
       // have more than COMM_FREE_COMM_HDL_THRESHOLD no of dlgs and
       // assocs in the free list.
       //
       DeleteCriticalSection(&pTop->CrtSec);
       (*pCntOfCrtSec)--;
       pTop->fCrtSecInited = FALSE;
    }
   } //end of try
finally {
	LeaveCriticalSection(pCrtSec);
	}
	return;	
}	

VOID
CommAssocDeallocAssoc(
	IN  LPVOID		   pAssocCtx	
	)

/*++

Routine Description:
	The function deallocates an association context block


Arguments:
	pAssocCtx - Buffer (assoc. ctx block) to deallocate


Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	CommAssocDeleteAssocInTbl, CommAssocSetUpAssoc, CommEndAssoc	

Side Effects:

Comments:
	None
--*/

{
	DeallocEnt(
		  CommAssocAssocHeapHdl,
		  &sAssocQueHd,
		  &sAssocListCrtSec,
		  &sAssocSeqNo,
		  pAssocCtx,
          &sNoOfAssocCrtSec
		  );
	return;
}	
	
VOID
CommAssocDeallocDlg(
	IN  LPVOID		   pDlgCtx	
	)

/*++

Routine Description:
	The function deallocates a dialogue context block


Arguments:
	pDlgCtx   - Buffer (dlg. ctx block) to deallocate


Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	RtlDeleteElementGenericTable

Side Effects:

Comments:
	None
--*/

{
	DeallocEnt(
		   CommAssocDlgHeapHdl,
		   &sDlgQueHd,
		   &sDlgListCrtSec,
		   &sDlgSeqNo,
		   pDlgCtx,
           &sNoOfDlgCrtSec
		  );
	return;
}	


VOID
CommAssocInit(
	VOID
	)

/*++

Routine Description:
	The function is called at init time to initialize the critical sections
	and queues for RESPONDER associations and dialogues pertaining to
	incoming request datagrams.


Arguments:

	None

Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	CommInit

Side Effects:

Comments:
	None
--*/

{

	//
	// Initialize the critical sections that guard the lists of
	// associations and non-udp dialogues
	//
	InitializeCriticalSection(&sAssocListCrtSec);
	InitializeCriticalSection(&sDlgListCrtSec);

	//	
	// Initialize the critical section for the UDP table
	//
	InitializeCriticalSection(&sUdpDlgTblCrtSec);

	
	//
	// Initialize the list heads for the lists of associations
	// and non-udp dialogues
	//
	InitializeListHead(&sAssocQueHd.Head);
	InitializeListHead(&sDlgQueHd.Head);

	//
	// Initialize the list head for the list of active responder
	// associations
	//
	InitializeListHead(&sRspAssocQueHd.Head);

	InitializeListHead(&sUdpDlgHead);

    // Initialize the tag variable
    InitializeCriticalSection(&sTagAssoc.crtSection);
    sTagAssoc.nIdxLimit = 0;
    sTagAssoc.nMaxIdx = 0;
    sTagAssoc.ppStorage = NULL;
    sTagAssoc.pTagPool = NULL;

	return;
}



PCOMMASSOC_DLG_CTX_T
CommAssocInsertUdpDlgInTbl(
	IN  PCOMMASSOC_DLG_CTX_T	pCtx,
	OUT LPBOOL			pfNewElem
	)
	
/*++

Routine Description:
	This function is called to insert a UDP dlg into the CommUdpNbtDlgTable.


Arguments:

	pDlgCtx	   - Dlg Ctx Block
	pfNewElem  - flag indicating whether it is a new element


Externals Used:
	None

	
Return Value:
	Ptr to the dlg ctx block

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/
{

	PCOMMASSOC_DLG_CTX_T	pDlgCtx;


	EnterCriticalSection(&sUdpDlgTblCrtSec);
try {
        pDlgCtx = WINSMSC_INSERT_IN_TBL_M(
					&CommUdpNbtDlgTable,
					pCtx,
					sizeof(COMMASSOC_DLG_CTX_T),
					(PBOOLEAN)pfNewElem
					  ); 	
	}
finally {
	LeaveCriticalSection(&sUdpDlgTblCrtSec);
 }
	return(pDlgCtx);	
}

VOID
CommAssocDeleteUdpDlgInTbl(
	IN  PCOMMASSOC_DLG_CTX_T	pDlgCtx
	)
	
/*++

Routine Description:
	This function is called to insert a UDP dlg into the CommUdpNbtDlgTable.


Arguments:
	pDlgCtx	   - Dlg Ctx Block

Externals Used:
	None
	
Return Value:

	Ptr to the dlg ctx block
Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/
{


	BOOLEAN   fRetVal;

	EnterCriticalSection(&sUdpDlgTblCrtSec);
try {
	DBGPRINT0(FLOW, "CommAssocDeleteUdpDlgInTbl:Deleting dlg from table\n");
        fRetVal = WINSMSC_DELETE_FRM_TBL_M(
					&CommUdpNbtDlgTable,
					pDlgCtx
				    ); 	

	if (fRetVal == (BOOLEAN)FALSE)
	{
		DBGPRINT0(ERR, "CommAssocDeleteUdpDlgInTbl:Could not delete dlg in table\n");
	}
  }
finally  {

	LeaveCriticalSection(&sUdpDlgTblCrtSec);
 }	

	return;	
}

				
		
LPVOID
CommAssocCreateAssocInTbl(
	SOCKET	SockNo
	)

/*++

Routine Description:
	This function is called to create an association ctx block for
	a tcp connection

Arguments:
	SockNo - Socket # of socket mapped to the TCP connection

Externals Used:
	sRspAssocQueHd	

	
Return Value:
	ptr to the associaton context block created for the TCP connection

Error Handling:

Called by:
	MonTcp (TCP listener thread)

Side Effects:

Comments:
	None
--*/

{
	PCOMMASSOC_ASSOC_CTX_T	pAssocCtx;

	//
	// Allocate/(grab from free list) an association
	//
	pAssocCtx 	  = CommAssocAllocAssoc();
	pAssocCtx->SockNo = SockNo;
    pAssocCtx->nTag   = CommAssocTagAlloc(&sTagAssoc,pAssocCtx);

	CommAssocInsertAssocInTbl(pAssocCtx);
	return(pAssocCtx);
}


VOID
CommAssocDeleteAssocInTbl(
	PCOMMASSOC_ASSOC_CTX_T	pAssocCtx
	)

/*++

Routine Description:
	This function is called to delete an association context block from
	the table of active responder associations.  The association ctx.
	block is deleted from the table and also deallocated (i.e. put
	in the free list)

Arguments:
	pAssocCtx - Association context block to delete from a table

Externals Used:
	sRspAssocQueHd	
	
Return Value:
	None

Error Handling:

Called by:
	DelAssoc

Side Effects:

Comments:
	None
--*/

{

	//
	// Unlink the association
	//
	COMMASSOC_UNLINK_RSP_ASSOC_M(pAssocCtx);

	//
	// Dealloc the assoc. so that it can be reused for some other
	// TCP connection
	//
    CommAssocTagFree(&sTagAssoc, pAssocCtx->nTag);
	CommAssocDeallocAssoc(pAssocCtx);
	return;
}

LPVOID
CommAssocLookupAssoc(
	SOCKET SockNo
	)

/*++

Routine Description:
	This function is called to lookup an association context block
	corresponding to a socket.

Arguments:
	SockNo - Socket # of socket whose association context block is
		 desired

Externals Used:
	sRspAssocQueHd
	
Return Value:

	ptr to assoc ctx block or NULL if there is no assoc. mapped to the
	socket

Error Handling:

Called by:
	DelAssoc

Side Effects:

Comments:
	None
--*/

{
	PCOMMASSOC_ASSOC_CTX_T	pTmp =
			(PCOMMASSOC_ASSOC_CTX_T)sRspAssocQueHd.Head.Flink;

	//
	// If list is empty, return NULL
	//
	if (IsListEmpty(&sRspAssocQueHd.Head))
	{
		return(NULL);
	}
	//
	// Search for the assoc. mapped to socket
	//
	for(
			;
		pTmp != (PCOMMASSOC_ASSOC_CTX_T)&sRspAssocQueHd ;
		pTmp = NEXT_ASSOC_M(pTmp)
	   )
	{
		if (pTmp->SockNo == SockNo)
		{
			return(pTmp);
		}
	}

	//
	// There is no assoc. mapped to socket SockNo.  Return NULL
	//
	return(NULL);
}


VOID
CommAssocInsertAssocInTbl(
	PCOMMASSOC_ASSOC_CTX_T pAssocCtx
	)

/*++

Routine Description:
	This function is called to insert an association at the head
	of the list of associations currently being monitored

Arguments:
	pAssocCtx - Assoc. Ctx. Block

Externals Used:
	None

	
Return Value:
	None
Error Handling:

Called by:
	CommAssocCreateAssocInTbl, ECommMonDlg
Side Effects:

Comments:
	Change to a macro
--*/

{

	//
	// Insert at the head of the list of active responder associations
	//
	// Insertion is done at the head of the list in order to optimize
	// the lookup of the association when the first message comes on
	// it from a remote WINS.  Since the first message follows on the
	// heels of the connection set up, the search for the association
	// which starts from the head is optimized.
	//
	InsertHeadList(&sRspAssocQueHd.Head, &pAssocCtx->Top.Head);
	return;
}

ULONG
CommAssocTagAlloc(
    PCOMMASSOC_TAG_POOL_T pTag,
    LPVOID pPtrValue
    )
/*++
Routine Description:
	This function is used to create a mapping between a generic pointer (32bit/64bit)
    and a 32bit tag.
Arguments:
    pPtrValue - generic pointer value
Externals Used:
    TBD
Return Value:
	None
--*/
{
    // a try..finally block is needed just in case the memory reallocation would raise. 
    // an exception. In this case, before leaving the try block and the function, the finally
    // block gets executed and leaves cleanly the tag critical section. If this happens
    // the exception will still be passed up the chain (since there is no except block present).
    try
    {
        ULONG newTag;

        DBGPRINT0(FLOW, "Entering CommAssocTagAlloc.\n");

        EnterCriticalSection(&(pTag->crtSection));

        // if nMaxIdx is 0 this means there is no entry available in the Tag pool
        if (pTag->nMaxIdx == 0)
        {
            UINT i;

            // tag pool needs to be enlarged. We might want to check if the buffers have not reached 
            // 2^32 entries (highly unlikely)
            ULONG nNewLimit = pTag->nIdxLimit + COMMASSOC_TAG_CHUNK;
            // realloc failures raise exceptions.
            if (pTag->nIdxLimit == 0)
            {
                pTag->ppStorage = (LPVOID*)WinsMscHeapAlloc(CommAssocAssocHeapHdl, nNewLimit*sizeof(LPVOID));
                pTag->pTagPool = (ULONG*)WinsMscHeapAlloc(CommAssocAssocHeapHdl, nNewLimit*sizeof(ULONG));
            }
            else
            {
                WinsMscHeapReAlloc(CommAssocAssocHeapHdl, nNewLimit*sizeof(LPVOID), (LPVOID)&(pTag->ppStorage));
                WinsMscHeapReAlloc(CommAssocAssocHeapHdl, nNewLimit*sizeof(ULONG), &(pTag->pTagPool));
            }

            // mark the newly allocated entries as being free for use
            pTag->nMaxIdx = COMMASSOC_TAG_CHUNK;
            for (i = 0; i < pTag->nMaxIdx; i++)
            {
                // tags should be in the range 1... hence the pre-increment op here.
                pTag->pTagPool[i] = ++pTag->nIdxLimit;
            }
        }
        // at this point pTag->nMaxIdx entries are free for use and pTag->nMaxIdx is guaranteed
        // to be greater than 0. The entries free for use have the indices in pTag->pTagPool[0..pTag->nMaxIdx-1]

       // get the newly allocated tag
        newTag = pTag->pTagPool[--pTag->nMaxIdx];
        // map the pointer to this tag into the pointer storage
        pTag->ppStorage[newTag-1] = pPtrValue;

#ifdef WINSDBG
        // robust programming
        pTag->pTagPool[pTag->nMaxIdx] = 0;
#endif
        DBGPRINT2(REPL, "TagAlloc: tag for %p is %08x.\n", pPtrValue, newTag);

        // return the newly allocated tag
        return newTag;
    }
    finally
    {
        LeaveCriticalSection(&(pTag->crtSection));
        DBGPRINT0(FLOW, "Leaving CommAssocTagAlloc.\n");
    }
}

VOID
CommAssocTagFree(
    PCOMMASSOC_TAG_POOL_T pTag,
    ULONG nTag
    )
/*++
Routine Description:
	This function is used to free a mapping between a generic pointer (32bit/64bit)
    and a 32bit tag.
Arguments:
    nTag - tag value to be freed.
Externals Used:
    TBD
Return Value:
	None
--*/
{
    DBGPRINT0(FLOW, "Entering CommAssocTagFree.\n");
    EnterCriticalSection(&(pTag->crtSection));

#ifdef WINSDBG
    // robust programming - just set the corresponding pointer from the storage to NULL
    pTag->ppStorage[nTag-1] = NULL;
#endif

    // just mark the nTag index as being free for use
    pTag->pTagPool[pTag->nMaxIdx++] = nTag;

    DBGPRINT1(REPL, "TagFree for tag %08x.\n", nTag);

    // 'Free' has to match with 'Alloc' so nMaxIdx can't exceed under no circumstances nIdxLimit
    ASSERT (pTag->nMaxIdx <= pTag->nIdxLimit);

    LeaveCriticalSection(&(pTag->crtSection));
    DBGPRINT0(FLOW, "Leaving CommAssocTagFree.\n");
}

LPVOID
CommAssocTagMap(
    PCOMMASSOC_TAG_POOL_T pTag,
    ULONG nTag
    )
/*++
Routine Description:
	This function is used to retrieve a generic pointer (32bit/64bit) that
    is uniquely identified through a 32bit tag.
Arguments:
    nTag - tag value that identifies the generic pointer.
Externals Used:
    TBD
Return Value:
	None
--*/
{
    DBGPRINT0(FLOW, "Entering CommAssocTagMap.\n");

    DBGPRINT2(REPL, "TagMap for tag %08x is %p.\n", 
           nTag, 
           nTag == 0 ? NULL : pTag->ppStorage[nTag-1]);

    // the indices that were given have to fall in the range 0..pTag->nIdxLimit
    ASSERT (nTag <= pTag->nIdxLimit);

    DBGPRINT0(FLOW, "Leaving CommAssocTagMap.\n");
    // return the (64bit) value from pStorage, associated with the nTag provided
    return nTag == 0 ? NULL : pTag->ppStorage[nTag-1];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\nms.h ===
#ifndef _NMS_
#define _NMS_
#ifdef __cplusplus
extern "C" {
#endif
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	nms.h

Abstract:

  This is the header file for the name space manager component of the
  Name Server.



Author:

	Pradeep Bahl	(PradeepB)	Dec-1992

Revision History:

--*/

/*
 includes
*/


#include "wins.h"
#include "comm.h"

/*
  defines
*/

#ifdef WINSDBG

FUTURES("Put all in a structure")
extern DWORD   NmsGenHeapAlloc;
extern DWORD   NmsDlgHeapAlloc;
extern DWORD   NmsUdpDlgHeapAlloc;
extern DWORD   NmsTcpMsgHeapAlloc;
extern DWORD   NmsUdpHeapAlloc;
extern DWORD   NmsQueHeapAlloc;
extern DWORD   NmsAssocHeapAlloc;
extern DWORD   NmsRpcHeapAlloc;
extern DWORD   NmsRplWrkItmHeapAlloc;
extern DWORD   NmsChlHeapAlloc;
extern DWORD   NmsTmmHeapAlloc;
extern DWORD   NmsCatchAllHeapAlloc;

extern DWORD   NmsHeapAllocForList;

extern DWORD   NmsGenHeapFree;
extern DWORD   NmsDlgHeapFree;
extern DWORD   NmsUdpDlgHeapFree;
extern DWORD   NmsTcpMsgHeapFree;
extern DWORD   NmsUdpHeapFree;
extern DWORD   NmsQueHeapFree;
extern DWORD   NmsAssocHeapFree;
extern DWORD   NmsRpcHeapFree;
extern DWORD   NmsRplWrkItmHeapFree;
extern DWORD   NmsChlHeapFree;
extern DWORD   NmsTmmHeapFree;
extern DWORD   NmsCatchAllHeapFree;

extern DWORD   NmsHeapCreate;
extern DWORD   NmsHeapDestroy;

//
// Count of updates (to version number) made by WINS.
//
extern DWORD   NmsRplUpd; 
extern DWORD   NmsRplGUpd; 
extern DWORD   NmsNmhUpd; 
extern DWORD   NmsNmhGUpd; 
extern DWORD   NmsNmhRelUpd; 
extern DWORD   NmsNmhRelGUpd; 
extern DWORD   NmsScvUpd; 
extern DWORD   NmsScvGUpd; 
extern DWORD   NmsChlUpd; 
extern DWORD   NmsChlGUpd; 
extern DWORD   NmsRpcUpd; 
extern DWORD   NmsRpcGUpd; 
extern DWORD   NmsOthUpd; 
extern DWORD   NmsOthGUpd; 


#if DBG
//
// No of reg/ref/rel requests dropped because of WINS hitting the threshold
// of max. requets on its queue.  Used by InsertOtherNbtWorkItem
//
extern volatile DWORD  NmsRegReqQDropped;
#endif

//
// NmsUpdCtrs[Client][TypeOfUpd][TypeOfRec][StateOfNewRec][VersNoInc]
//
extern DWORD NmsUpdCtrs[WINS_NO_OF_CLIENTS][2][4][3][2];
extern CRITICAL_SECTION NmsHeapCrtSec;
#endif

#define NMS_OPCODE_MASK	  0x78	     /*to weed out the 4 bits of the 3rd byte
				     * of the name packet	
				     */
#define NMS_RESPONSE_MASK 0x80	     /*to weed out the bit that indicates
				      * whether the datagram is a request or 
				      * a response
				      */
/*
  macros
*/

/*
 * NMSISNBT_M -- Is this an nbt request message
 *
 * Examines the third byte of the message to determine this
*/
#define NMSISNBT_M(pMsg) \
	(((*(pMsg + 2) & NMS_OPCODE_MASK) >> 3) != WINS_IS_NOT_NBT)  

/*
* NMSISRPL_M -- Is this a replicator message
*
* Examines the third byte of the message to determine this
*/
#define NMSISRPL_MSG_M(pMsg ) \
	(((*(pMsg + 2) & NMS_OPCODE_MASK) >> 3) == WINS_IS_NOT_NBT)  



/*
  GEN_INIT_BUFF_HEAP_SIZE -- This is the initial size of the heap 
			     for allocating queue items for the various
			     queues, TLS storage,  for reading in a file,etc.  
			     Keep it 1000 
*/
#define GEN_INIT_BUFF_HEAP_SIZE		1000


//
// RPC_INIT_BUFF_HEAP_SIZE -- This is the initial size of the heap for
//			      use by rpc
//
#define RPC_INIT_BUFF_HEAP_SIZE		1000


#define RPL_WRKITM_BUFF_HEAP_SIZE	1000    	//1000 bytes


//
// Initial heap size for timer work items
//
#define   TMM_INIT_HEAP_SIZE	1000

//
// The maximum number of concurrent RPC calls allowed
//
FUTURES("Move these defines to winsthd.h")
#define   NMS_MAX_RPC_CALLS	 15 
#define   NMS_MAX_BROWSER_RPC_CALLS   (NMS_MAX_RPC_CALLS - 4)

//
// Minimum number of RPC call threads
//
#define   NMS_MIN_RPC_CALL_THDS 2

//
// This is the amount of time the service controller is asked to wait
//
#define MSECS_WAIT_WHEN_DEL_WINS          120000   //from ReadOwnAddTbl

/* 
 structure definitions
*/

/*
 QUERY_RSP -- structure used to hold the information that needs to be sent
	      in a positive name query response message
*/

typedef struct
 	{
	DWORD	CountOfIPAdd;   //it is a DWORD for alignment
        DWORD   IPAdd[1];    	//one or more IP addresses start here.
	} QUERY_RSP;

#ifdef WINSDBG
typedef struct _PUSH_CTRS_T {
          DWORD NoUpdNtfAcc;
          DWORD NoUpdNtfRej;
          DWORD NoSndEntReq;
          DWORD NoAddVersReq;
          DWORD NoUpdNtfReq;
          DWORD NoUpdVersReq;
          DWORD NoInvReq;
         } PUSH_CTRS_T, *PPUSH_CTRS_T;

typedef struct _PULL_CTRS_T {
         DWORD  PH;
         } PULL_CTRS_T, *PPULL_CTRS_T; 
         
typedef struct _NMS_CTRS_T {
       PUSH_CTRS_T  RplPushCtrs;     
       PULL_CTRS_T  RplPullCtrs;     
       } NMS_CTRS_T, *PNMS_CTRS_T;
#endif
 
/*
 externs
*/
#ifdef WINSDBG
extern  NMS_CTRS_T  NmsCtrs;
#endif

extern HANDLE 		NmsMainTermEvt;
extern HANDLE 		NmsTermEvt;
extern CRITICAL_SECTION NmsTermCrtSec;
extern HANDLE		NmsCrDelNbtThdEvt;
extern DWORD		NmsNoOfNbtThds;
extern DWORD		NmsTotalTrmThdCnt;

extern BOOL         fNmsThdOutOfReck;


extern VERS_NO_T         NmsRangeSize;
extern VERS_NO_T         NmsHalfRangeSize;
extern VERS_NO_T         NmsVersNoToStartFromNextTime;
extern VERS_NO_T         NmsHighWaterMarkVersNo;

extern DWORD             NmsNoOfRpcCallsToDb;
//
// required for security checking.  The types are defined in ntseapi.h
//
extern GENERIC_MAPPING	   NmsInfoMapping;
extern PSECURITY_DESCRIPTOR pNmsSecurityDescriptor;


FUTURES("move to winsque.h")
extern HANDLE	  GenBuffHeapHdl;  //handle to heap for use for general 
				   //allocation
extern HANDLE	  NmsRpcHeapHdl;  //handle to heap for use for allocation 
				      //by rpc


extern COMM_ADD_T	NmsLocalAdd;  //WINS's Address
extern BOOL		fNmsAbruptTerm;
extern BOOL		fNmsMainSessionActive;

#ifdef TEST_DATA
extern HANDLE NmsFileHdl;
#endif
#ifdef DBGSVC
extern HANDLE NmsDbgFileHdl;
//extern FILE *pNmsDbgFile;
#endif

extern CRITICAL_SECTION WinsIntfNoOfUsersCrtSec;
/* 
 function definitions
*/

//
// Handler used for interfacing with the service controller
//
extern
VOID
NmsServiceControlHandler(
    IN DWORD Opcode
    );

extern
VOID
ENmsHandleMsg(
	PCOMM_HDL_T pDlgHdl, 
	MSG_T 	 	     pMsg,  
	MSG_LEN_T            MsgLen 
	); 

extern
VOID
ENmsWinsUpdateStatus(
    DWORD MSecsToWait
	); 

#ifdef WINSDBG
extern
VOID
NmsPrintCtrs(
 VOID
);
#endif

#ifndef WINS_INTERACTIVE
extern
VOID
NmsChkDbgFileSz(
    VOID
    );
#endif
#ifdef __cplusplus
}
#endif

#endif //_NMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\nmschl.h ===
#ifndef _NMSCHL_
#define _NMSCHL_

#ifdef __cplusplus
extern "C" {
#endif
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	Nmschl.h
	

Abstract:
	This is the header file for interfacing with the Name Challenge
	component of WINS

 



Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Feb-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "comm.h"
#include "nmsdb.h"
/*
  defines
*/

#define NMSCHL_INIT_BUFF_HEAP_SIZE	1000	//1000 bytes

/*
  macros
*/

//
//  The maximum number of challenges that can be initiated at any one time
//  500 is a very genrous number.  We might want to make it smaller.
//
//  used by QueRemoveChlReqWrkItm function in queue.c
//
#define NMSCHL_MAX_CHL_REQ_AT_ONE_TIME 	500 

/*
 externs
*/

extern HANDLE 		  NmsChlHeapHdl;   //Heap for name challenge work items

extern HANDLE		  NmsChlReqQueEvtHdl;
extern HANDLE		  NmsChlRspQueEvtHdl;
extern CRITICAL_SECTION   NmsChlReqCrtSec;
extern CRITICAL_SECTION   NmsChlRspCrtSec;

#ifdef WINSDBG
extern DWORD   NmsChlNoOfReqNbt;
extern DWORD   NmsChlNoOfReqRpl;
extern DWORD   NmsChlNoNoRsp;
extern DWORD   NmsChlNoInvRsp;
extern DWORD   NmsChlNoRspDropped;
extern DWORD   NmsChlNoReqDequeued;
extern DWORD   NmsChlNoRspDequeued;
extern DWORD   NmsChlNoReqAtHdOfList;
#endif

/* 
 typedef  definitions
*/
//
// NMSCHL_CMD_TYP_E -- Enumerator for indicating to the challenge manager
//		       what action it needs to take.
//
typedef enum _NMSCHL_CMD_TYP_E {
		NMSCHL_E_CHL = 0,	//challenge the node.  If the
					//challenge fails, send a negative
					//name reg. response to the registrant,
					//else send a positive response
		NMSCHL_E_CHL_N_REL,
		NMSCHL_E_CHL_N_REL_N_INF,
		NMSCHL_E_REL,		//ask the node to release the
					//name and then update db.  Used by 
                                        //the RPL PULL thread
		NMSCHL_E_REL_N_INF,	//ask the node to release the name. Tell					//remote WINS to update the version number
                NMSCHL_E_REL_ONLY      //ask node to release name, no update db

		}  NMSCHL_CMD_TYP_E, *PNMSCHL_CMD_TYP_E;

/* 
* function declarations
*/
STATUS
NmsChlInit(
	VOID
	);

extern
STATUS
NmsChlHdlNamReg(
	NMSCHL_CMD_TYP_E   CmdTyp_e,
	WINS_CLIENT_E	   Client_e, 
	PCOMM_HDL_T        pDlgHdl,
	MSG_T		   pMsg,
	MSG_LEN_T	   MsgLen,
	DWORD		   QuesNamSecLen,
	PNMSDB_ROW_INFO_T  pNodeToReg,
	PNMSDB_STAT_INFO_T pNodeInCnf,
//	PCOMM_ADD_T	   pAddOfNodeInCnf,
	PCOMM_ADD_T	   pAddOfRemWins
	);

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\nmsmsgf.h ===
#ifndef _NMSMSGF_
#define _NMSMSGF_

#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	nmsmsgf.h

	

Abstract:


	This is the header file to be used for calling nmsmsgf.c functions


Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Jan-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "comm.h"
#include "assoc.h"
#include "nmsdb.h"

/*
  defines
*/

//
// Max. length of name in an RFC packet
//
#define  NMSMSGF_RFC_MAX_NAM_LEN	NMSDB_MAX_NAM_LEN

/*
  macros
*/

//
// Inserts an IP address in an RFC pkt
//
#define NMSMSGF_INSERT_IPADD_M(pTmpB, IPAdd)				   \
			{						   \
				*(pTmpB)++ = (BYTE)((IPAdd) >> 24);	   \
				*(pTmpB)++ = (BYTE)(((IPAdd) >> 16) % 256);\
				*(pTmpB)++ = (BYTE)(((IPAdd) >> 8) % 256); \
				*(pTmpB)++ = (BYTE)((IPAdd) % 256);	   \
			}	

//
// Currently IP addresses are same length as ULONG. When that changes
// change this macro
//
FUTURES("Change when sizeof(COMM_IP_ADD_T) != sizeof(ULONG)")
#define NMSMSGF_INSERT_ULONG_M(pTmpB, x)    NMSMSGF_INSERT_IPADD_M(pTmpB, x)
//
// Retrieves an IP address from an RFC pkt
//
#define NMSMSGF_RETRIEVE_IPADD_M(pTmpB, IPAdd)				\
			{						\
				(IPAdd)  = *(pTmpB)++ << 24;		\
				(IPAdd) |= *(pTmpB)++ << 16;		\
				(IPAdd) |= *(pTmpB)++ << 8;		\
				(IPAdd) |= *(pTmpB)++;			\
			}	

//
// Currently IP addresses are same length as ULONG. When that changes
// change this macro
//
FUTURES("Change when sizeof(COMM_IP_ADD_T) != sizeof(ULONG)")
#define NMSMSGF_RETRIEVE_ULONG_M(pTmpB, x)    NMSMSGF_RETRIEVE_IPADD_M(pTmpB, x)

//
// Max number of multihomed addresses
//
#define NMSMSGF_MAX_NO_MULTIH_ADDS		NMSDB_MAX_MEMS_IN_GRP	

//
// Used for swapping bytes (to support the browser)
//
#define NMSMSGF_MODIFY_NAME_IF_REQD_M(pName)			\
		{						\
			if (*((pName) + 15) == 0x1B)		\
			{					\
				WINS_SWAP_BYTES_M((pName), (pName) + 15);\
			}						\
		}
		
/*
 externs
*/

/*
 typedef  definitions
*/
/*
 NMSMSGF_ERR_CODE_E - The various Rcode values returned in responses to
	the various name requests received.

	Note:  CFT_ERR is never returned in a negative name release response.
	ACT_ERR code in a negative name release response means that the
	WINS server will not allow a node to release the name owned by another
	node.o
*/

typedef enum _NMSMSGF_ERR_CODE_E {
	NMSMSGF_E_SUCCESS  = 0,    //Success
	NMSMSGF_E_FMT_ERR  = 1,   //Format error. Req. was invalidly formatted
	NMSMSGF_E_SRV_ERR  = 2,   //Server failure. Problem with WINS. Can not
				  //service name
CHECK("Check this one out.  Would WINS ever return this ?")
	NMSMSGF_E_NAM_ERR  = 3,   //Name does not exist in the directory
	NMSMSGF_E_IMP_ERR  = 4,   //Unsupported req. error. Allowable only for
				  //challenging NBNS when gets an Update type
				  //registration request
	NMSMSGF_E_RFS_ERR  = 5,   //Refused error. For policy reasons WINS
				  //will not register this namei from this host
	NMSMSGF_E_ACT_ERR  = 6,   //Active error. Name is owned by another node
	NMSMSGF_E_CFT_ERR  = 7    //Name in conflict error. A unique name is
				  //owned by more than one node
	} NMSMSGF_ERR_CODE_E, *PNMSMSGF_ERR_CODE_E;
/*
 NMSMSGF_NODE_TYP_E -- Node type of node that sent the name registration
		message
	Values assigned to the enumrators are those specified in RFC 1002

	Bnode value will be set by Proxy

	NOTE NOTE NOTE
	WINS will never get a registration from a B node since we decided
	that B node registrations will not be passed to WINS by the
	proxy.
*/

typedef enum _NMSMSGF_NODE_TYP_E {
	NMSMSGF_E_BNODE  = 0,    //RFC 1002 specified value
	NMSMSGF_E_PNODE  = 1,   // RFC 1002 specified value
	NMSMSGF_E_MODE   = 2    //RFC 1002 specified value
	} NMSMSGF_NODE_TYP_E, *PNMSMSGF_NODE_TYP_E;

//
// Information required to send a response to an NBT node
//
typedef struct _NMSMSGF_RSP_INFO_T {
	NMSMSGF_ERR_CODE_E 	Rcode_e;
	MSG_T			pMsg;
	MSG_LEN_T		MsgLen;
	PNMSDB_NODE_ADDS_T	pNodeAdds;
	DWORD			QuesNamSecLen;
	NMSMSGF_NODE_TYP_E	NodeTyp_e;
	BYTE			EntTyp;
        DWORD			RefreshInterval;
	} NMSMSGF_RSP_INFO_T, *PNMSMSGF_RSP_INFO_T;	
/*
 NMSMSGF_NAM_REQ_TYP_E
 	Type of name request that the WINS deals with
	Values assigned to the enumrators are those specified in RFC 1002

  	Used by NmsProcNbtReq and NmsNmhNamRegRsp.
*/

CHECK("RFC 1002 is inconsistent in its specification of the opcode for ")
CHECK("Name Refresh.  AT one place it specifies 8 and at another 9")
CHECK("8 seems more likely since it follows in sequeence to the value")
CHECK("for WACK")

typedef enum _NMSMSGF_NAM_REQ_TYP_E {
	NMSMSGF_E_NAM_QUERY = 0,
	NMSMSGF_E_NAM_REG   = 5,
	NMSMSGF_E_NAM_REL   = 6,
	NMSMSGF_E_NAM_WACK  = 7,
	NMSMSGF_E_NAM_REF   = 8, /*RFC 1002 specifies 8 and 9.Which one is
				 *correct (page 9 and page 15)?
				 */
	NMSMSGF_E_NAM_REF_UB  = 9, //Netbt in Daytona release will use 9 for
                               //compatibility with UB NBNS.  So, I
                               //need to support this too
	NMSMSGF_E_MULTIH_REG = 0xF, //not in RFC.  For supporting multi-homed
				    //hosts
	NMSMSGF_E_INV_REQ   = 10  // invalid name request
	} NMSMSGF_NAM_REQ_TYP_E, *PNMSMSGF_NAM_REQ_TYP_E;	

//
// Counted array of addresses.  The array size is big enough to hold the
// max. number of addresses that can be sent in a UDP packet.
//
//  We need to get all the addresses when a query response is received
// by WINS (to a challenge).  This is so that it can handle mh nodes
// with > 25 addresses.
//
// Since a UDP packet can not be > 512, assuming a name size of 16 (32 bytes
// encoded), the packet size apart from Ip address is around 60.  So the
// max. number of addresses there can be is (512-60 - 2)/4 = around 112.
//
//#define NMSMSGF_MAX_ADDRESSES_IN_UDP_PKT  100



//
// We will never take more than 25 addresses from a packet.  Netbt will also
// never send more than 25.  Even if it does, we will stop at the 26th address
// The count is being kept at 25 so as to avoid a buffer overflow problem
// in NmsMsgfUfmNamRsp.
//
// If the max name size is used - 255 and using 60 bytes for the other contents\// of the packet, we have (512-315 -2 = 195 bytes for the ip address). This  
// will accept 195/4 = around 48 addresses.  No chance for overflow when we
// use a limit of 25.
//
#define NMSMSGF_MAX_ADDRESSES_IN_UDP_PKT 25 
 





FUTURES("when we start supportng tcp connections. this array size may not")
FUTURES("be sufficient")
typedef struct _NMSMSGF_CNT_ADD_T {
	DWORD		NoOfAdds;
	COMM_ADD_T	Add[NMSMSGF_MAX_ADDRESSES_IN_UDP_PKT];	
	} NMSMSGF_CNT_ADD_T, *PNMSMSGF_CNT_ADD_T;
/*
 function definitions
*/

extern
STATUS
NmsMsgfProcNbtReq(
	PCOMM_HDL_T	pDlgHdl,
        MSG_T		pMsg,
	MSG_LEN_T	MsgLen
	);
extern
STATUS
NmsMsgfFrmNamRspMsg(
   PCOMM_HDL_T			pDlgHdl,
   NMSMSGF_NAM_REQ_TYP_E   	NamRspTyp_e,
   PNMSMSGF_RSP_INFO_T		pRspInfo
  	);



extern
VOID
NmsMsgfFrmNamQueryReq(
  IN  DWORD			TransId,
  IN  MSG_T	   		pMsg,
  OUT PMSG_LEN_T      	        pMsgLen,
  IN  LPBYTE			pNameToFormat,
  IN  DWORD			NameLen
	);

extern
VOID
NmsMsgfFrmNamRelReq(
  IN  DWORD			TransId,
  IN  MSG_T	   		pMsg,
  OUT PMSG_LEN_T      	        pMsgLen,
  IN  LPBYTE			pNameToFormat,
  IN  DWORD			NameLen,
  IN  NMSMSGF_NODE_TYP_E        NodeTyp_e,
  IN  PCOMM_ADD_T		pNodeAdd
	);

extern
STATUS
NmsMsgfFrmNamRegReq(
  IN  DWORD			TransId,
  IN  MSG_T	   		pMsg,
  OUT PMSG_LEN_T      	        pMsgLen,
  IN  LPBYTE			pNameToFormat,
  IN  DWORD			NameLen,
  IN  NMSMSGF_NODE_TYP_E        NodeTyp_e,
  IN  PCOMM_ADD_T		pNodeAdd
	);
extern
VOID
NmsMsgfFrmWACK(
  IN  LPBYTE			Buff,
  OUT LPDWORD			pBuffLen,
  IN  MSG_T	   		pMsg,
  IN  DWORD			QuesSecNamLen,
  IN  DWORD			TTL
	);




extern
STATUS
NmsMsgfUfmNamRsp(
	IN  LPBYTE		       pMsg,
	OUT PNMSMSGF_NAM_REQ_TYP_E     pOpcode_e,
	OUT LPDWORD		       pTransId,
	OUT LPBYTE		       pName,
	OUT LPDWORD 		       pNameLen,
	OUT PNMSMSGF_CNT_ADD_T	       pCntAdd,
	OUT PNMSMSGF_ERR_CODE_E	       pRcode_e,
    OUT PBOOL                      fGroup
	);

extern
VOID
NmsMsgfSndNamRsp(
  PCOMM_HDL_T pDlgHdl,
  LPBYTE      pMsg,
  DWORD       MsgLen,
  DWORD       BlockOfReq
 );

#ifdef __cplusplus
}
#endif
#endif //_NMSMSGF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\nmsnmh.h ===
#ifndef _NMSNMH_
#define _NMSNMH_

#ifdef __cplusplus
extern "C" {
#endif
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	nmsnmh.h
	

Abstract:





Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Jan-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "nmsdb.h"
#include "comm.h"
#include "nmsmsgf.h"
#include "nms.h"

/*
  defines
*/

extern BOOL  NmsNmhRegThdExists;

/*
  macros
*/


#define NMSNMH_VERS_NO_EQ_ZERO_M(VersNo) ((VersNo).QuadPart == 0)

#define NMSNMH_INC_VERS_NO_M(VersNoToInc, TgtVersNo)	{		\
			(TgtVersNo).QuadPart = LiAdd((VersNoToInc), NmsNmhIncNo);	\
					}
#define NMSNMH_DEC_VERS_NO_M(VersNoToDec, TgtVersNo)	{		\
			(TgtVersNo).QuadPart = LiSub((VersNoToDec), NmsNmhIncNo);	\
					}
				
#define NMSNMH_INC_VERS_COUNTER_M2(VersNoToInc, TgtVersNo) {  \
        if (LiGtr((VersNoToInc), NmsHighWaterMarkVersNo))         \
        {                                                       \
                DWORD ThdId;\
                HANDLE ThdHdl;\
              if(!WinsCnfRegUpdThdExists) { \
                WinsCnfRegUpdThdExists = TRUE; \
                ThdHdl = WinsMscCreateThd(WinsCnfWriteReg, NULL, &ThdId);    \
                CloseHandle(ThdHdl);                           \
                } \
        }                                                       \
        NMSNMH_INC_VERS_NO_M((VersNoToInc), (TgtVersNo));           \
    }

#define NMSNMH_INC_VERS_COUNTER_M(VersNoToInc, TgtVersNo)      \
                NMSNMH_INC_VERS_COUNTER_M2(VersNoToInc, TgtVersNo)

#ifdef WINSDBG
#if 0
#define NMSNMH_UPD_UPD_CTRS_M(pRowInfo)      {     \
      IF_DBG(UPD_CNTRS)                   \
      {                                   \
        PWINSTHD_TLS_T       _pTls;  \
        _pTls = TlsGetValue(WinsTlsIndex);     /*GET_TLS_M(_pTls); */\
        switch(_pTls->Client_e)    \
        {                         \
             case(WINS_E_RPLPULL): NMSDB_ENTRY_UNIQUE_M(pRowInfo->EntTyp) ? NmsRplUpd++ : NmsRplGUpd++; break; \
             case(WINS_E_NMSNMH):   NMSDB_ENTRY_UNIQUE_M(pRowInfo->EntTyp) ? NmsNmhUpd++ : NmsNmhGUpd++; break; \
             case(WINS_E_NMSCHL):   NMSDB_ENTRY_UNIQUE_M(pRowInfo->EntTyp) ? NmsChlUpd++ : NmsChlGUpd++; break;\
             case(WINS_E_NMSSCV):   NMSDB_ENTRY_UNIQUE_M(pRowInfo->EntTyp) ? NmsScvUpd++ : NmsScvGUpd++; break; \
             case(WINS_E_WINSRPC):  NMSDB_ENTRY_UNIQUE_M(pRowInfo->EntTyp) ? NmsRpcUpd++ : NmsRpcGUpd++; break; \
             default:               NMSDB_ENTRY_UNIQUE_M(pRowInfo->EntTyp) ? NmsOthUpd++ : NmsOthGUpd++; break; \
        } \
       } \
      }
#endif
#define NMSNMH_UPD_UPD_CTRS_M(fIndexUpd, fUpd, pRowInfo)      {     \
      IF_DBG(UPD_CNTRS)                   \
      {                                   \
        PWINSTHD_TLS_T       _pTls;  \
        _pTls = TlsGetValue(WinsTlsIndex);     /*GET_TLS_M(_pTls); */\
        NmsUpdCtrs[_pTls->Client_e][fUpd][pRowInfo->EntTyp][pRowInfo->EntryState_e][fIndexUpd]++; \
      } \
    }
#else
#define NMSNMH_UPD_UPD_CTRS_M(fIndexUpd, fUpd, pRowInfo)
#endif


				
					

/*
 externs
*/
/*
	NmsNmhMyMaxVersNo -- Stores highest version no. for
			   entries owned by the local WINS
			   in its local db
*/
extern	VERS_NO_T	NmsNmhMyMaxVersNo;
extern  VERS_NO_T	NmsNmhIncNo;

/*
	NmsNmhNamRegCrtSect -- Variable for the critical section entered
	when name registrations or refreshes need to be done
*/
extern CRITICAL_SECTION	NmsNmhNamRegCrtSec;


/*
 typedef  definitions
*/

/*
  NMSNMH_QUERY_RSP_T -- this contains the addresses found in a
	group entry. -- not being used currently
*/
typedef struct _NMSNMH_QUERY_RSP_T {
	BOOL	 fGrp;				 //is it rsp. for a group
	WORD	 NoOfAdd;   			 //no of addresses in the group
	COMM_ADD_T NodeAdd[NMSDB_MAX_MEMS_IN_GRP];  //addresses
	} NMSNMH_QUERY_RSP_T, *PNMSNMH_QUERY_RSP_T;

/*
 function prototypes
*/

extern
STATUS
NmsNmhNamRegInd(
	IN PCOMM_HDL_T		pDlgHdl,
	IN LPBYTE		pName,
	IN DWORD		NameLen,
	IN PCOMM_ADD_T		pNodeAdd,
	IN BYTE	        	NodeTyp, //change to take Flag byte
	IN MSG_T		pMsg,
	IN MSG_LEN_T		MsgLen,
	IN DWORD		QuesNamSecLen,
	IN BOOL			fRefresh,
	IN BOOL			fStatic,
	IN BOOL			fAdmin
	);

extern
STATUS
NmsNmhNamRegGrp(
	IN PCOMM_HDL_T		pDlgHdl,
	IN PBYTE		pName,
	IN DWORD		NameLen,
	IN PNMSMSGF_CNT_ADD_T	pCntAdd,
	IN BYTE			NodeTyp,
	IN MSG_T		pMsg,
	IN MSG_LEN_T		MsgLen,
	IN DWORD		QuesNamSecLen,
	IN DWORD		TypeOfRec,
	IN BOOL			fRefresh,
	IN BOOL			fStatic,
	IN BOOL			fAdmin
	);

extern
STATUS
NmsNmhNamRel(
	IN PCOMM_HDL_T		pDlgHdl,
	IN LPBYTE		pName,
	IN DWORD		NameLen,
	IN PCOMM_ADD_T		pNodeAdd,
	IN BOOL			fGrp,
	IN MSG_T		pMsg,
	IN MSG_LEN_T		MsgLen,
	IN DWORD		QuesNamSecLen,
	IN BOOL			fAdmin
	);

extern
STATUS
NmsNmhNamQuery(
	IN PCOMM_HDL_T		pDlgHdl,  //dlg handle
	IN LPBYTE		pName,	  //Name to release
	IN DWORD		NameLen, //length of name to release
	IN MSG_T		pMsg,	  //message received
	IN MSG_LEN_T		MsgLen,	  //length of message
	IN DWORD		QuesNamSecLen, //length of ques. name sec in msg
	IN BOOL			fAdmin,
        OUT PNMSDB_STAT_INFO_T  pStatInfo
	);


extern
VOID
NmsNmhSndNamRegRsp(
	PCOMM_HDL_T            pDlgHdl,
	PNMSMSGF_RSP_INFO_T    pRspInfo
	);



extern
STATUS
NmsNmhReplRegInd(
	IN LPBYTE		pName,
	IN DWORD		NameLen,
	IN PCOMM_ADD_T          pNodeAdd,
	IN DWORD	       	Flag, //change to take Flag byte
	IN DWORD			OwnerId,
	IN VERS_NO_T 		VersNo,
	IN PCOMM_ADD_T		pOwnerWinsAdd
	);

extern
STATUS
NmsNmhReplGrpMems(
	IN LPBYTE		pName,
	IN DWORD		NameLen,
	IN BYTE			EntTyp,
	IN PNMSDB_NODE_ADDS_T	pGrpMem,
	IN DWORD        	Flag, 		//change to take Flag byte
	IN DWORD		OwnerId,
	IN VERS_NO_T 		VersNo,
	IN PCOMM_ADD_T		pOwnerWinsAdd
	);
	

extern
VOID
NmsNmhUpdVersNo(
	IN LPBYTE		pName,
	IN DWORD		NameLen,
	//IN BYTE			NodeTyp,
	//IN BOOL			fBrowserName,
	//IN BOOL			fStatic,
	//IN PCOMM_ADD_T		pNodeAdd,
	OUT LPBYTE		pRcode,
        IN  PCOMM_ADD_T		pWinsAdd
	);
	
#ifdef __cplusplus
}
#endif
#endif //_NMSNMH_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\nmsdb.h ===
#ifndef _NMSDB_
#define _NMSDB_

#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

        nmsdb.h

Abstract:
        This header file is for interfacing with the database manager component
        of the name space manager. The database manager component is a front-end        to the database engine used for WINS server.

        The database engine used for the WINS server currently is JetBlue.


Functions:



Portability:

        This header file is portable.

Author:

        Pradeep Bahl        (PradeepB)        Jan-1993


Revision History:

        Modification Date        Person                Description of Modification
        ------------------        -------                ---------------------------

--*/

/*
  Includes
*/

#include "wins.h"
#include "comm.h"
#include "nmsscv.h"

#include "esent.h"

#include "winsthd.h"
#include "winsintf.h"

/*
  defines
*/

//
// The size of of an array required to hold the IP Address in ascii form.
//
// Used by NmsNmhNamRegInd, NmsNmhQueryRow, and NmsNmhReplRegInd
//
#define NMSDB_MAX_NET_ADD_ARR_SZ                10

#define        NMSDB_LOCAL_OWNER_ID         0  //local WINS always uses 0 for owner id.

//
// NOTE NOTE NOTE
//
//
#define NMSDB_MAX_OWNERS_INITIALLY        100 //max. number of owners in db
#define NMSDB_MAX_MEMS_IN_GRP        25 //max. # of members in group
/*
 Mask for retrieving different fields in the flag byte of a database entry
*/
#define NMSDB_BIT_ENT_TYP        0x03  //bit 0  and 1
#define NMSDB_BIT_STATE                0x0C  //bits 2 and 3
#define NMSDB_BIT_LOCAL                0x10  //bit 4
#define NMSDB_BIT_NODE_TYP        0x60  //bit 5 and 6
#define NMSDB_BIT_STATIC        0x80  // bit 7


/*
  Values to be stored in the flag byte for certain entry types

  NOTE: Don't change the values unless you change the WINSINTF_TYPE_E too.
  The values are same for the enum types in the above enumerator (kept same
  for performance reasons -- check out winsintf.c)
*/
#define NMSDB_UNIQUE_ENTRY        0
#define NMSDB_NORM_GRP_ENTRY        1
#define NMSDB_SPEC_GRP_ENTRY    2
#define NMSDB_MULTIHOMED_ENTRY  3

//
// is not stored in the db.  Used by winsprs functions only
//
#define NMSDB_USER_SPEC_GRP_ENTRY    4

/*
 The shift to the left to be given to values of various items to be stored
 in the flag byte
*/
#define NMSDB_SHIFT_ENT_TYP        0  //bit 0 and 1
#define NMSDB_SHIFT_STATE        2  //bit 2 and 3
#define NMSDB_SHIFT_LOCAL        4  //bit 4
#define NMSDB_SHIFT_NODE_TYP        5  //bit 5
#define NMSDB_SHIFT_STATIC        7  //bit 7


#define   NMSDB_ENTRY_IS_STATIC                        1
#define   NMSDB_ENTRY_IS_NOT_STATIC                0

/*
 NMSDB_MAX_NAM_LEN
  RFC 1002 states
        To simplify implementationss, the total length of label octets
        and label length octets that make up a domain name is restricted to
        255 or less.

        Note: the number is a multiple of 8 (fortunately)
*/
//
// If we are running some internal tests, we will be writing names that
// did not resolve on a query to a file.  We add a \n to the name.  Therefore
// the max size is being increased by 1 (so that when we get a name that
// is 255 bytes long, we do not go past the name array) -- see NmsNmhNamQuery
//
#ifdef TEST_DATA
#define NMSDB_MAX_NAM_LEN                257
#else
#define NMSDB_MAX_NAM_LEN                256 //maximum length of name-- RFC 1002
#endif

/*
  Error status codes returned by NmsDb functions
*/

FUTURES("Get rid of these. Use WINS status codes")

#define        NMSDB_SUCCESS        0x0
#define        NMSDB_CONFLICT   (NMSDB_SUCCESS + 0x1)  //conflict with an existing rec
/*
        limit of addresses in group reached
*/
#define        NMSDB_ADD_LMT_IN_GRP_REACHED   (NMSDB_SUCCESS + 0x2)
#define        NMSDB_NO_SUCH_ROW                  (NMSDB_SUCCESS + 0x3)


#define NMSDB_NAM_ADD_TBL_NM        "NamAddTbl"
#define NMSDB_OWN_ADD_TBL_NM        "OwnAddTbl"


/*
        names for the indices used on the Name to Address mapping table
*/
#define NMSDB_NAM_ADD_CLUST_INDEX_NAME        "NETBIOSNAME"
#define NMSDB_NAM_ADD_PRIM_INDEX_NAME        "OWNERVERSION"


//
// Name of index used on the Owner to Address mapping table
//
#define NMSDB_OWN_ADD_CLUST_INDEX_NAME        "OWNERID"


/*
*        no of pages to allocate initially for the Name to address mapping table
*/

//
// 250 pages means 1 MB of space.  This should be good enough
// If more are needed, the table will be extended by an extent amount
//
#define NMSDB_NAM_ADD_TBL_PGS        250
#define NMSDB_OWN_ADD_TBL_PGS        1

/*
 The density values specified when creating Name to address mapping table
  and the indices on the same
*/
#define NMSDB_NAM_ADD_TBL_DENSITY          80 //density when creating nam-ip tbl
#define NMSDB_NAM_ADD_CLUST_INDEX_DENSITY  80 //density when creating cl. index
#define NMSDB_NAM_ADD_PRIM_INDEX_DENSITY  80 //density when creating pr. index

/*
 The density values specified when creating Owner to address mapping table
  and the indices on the same
*/
#define NMSDB_OWN_ADD_TBL_DENSITY   80 //density when creating nam-ip tbl
#define NMSDB_OWN_ADD_CLUST_INDEX_DENSITY   80 //density when creating cl. index

/*
  macros
*/

//
// This macro gets the pointer to the Thread specific storage
//
FUTURES("Get rid of the return")
#define GET_TLS_M(pTls)        {                                              \
                                DWORD _Error;                           \
                                pTls  = TlsGetValue(WinsTlsIndex); \
                                if (pTls == NULL)                   \
                                {                                   \
                                        _Error = GetLastError();   \
                                        return(WINS_FAILURE);           \
                                }                                   \
                        }

//
// macros to get/set the various attributes of an entry from the flags byte
//
#define NMSDB_ENTRY_STATE_M(Flag)  (((Flag) & NMSDB_BIT_STATE) >> NMSDB_SHIFT_STATE)
#define NMSDB_ENTRY_TYPE_M(Flag)  (((Flag) & NMSDB_BIT_ENT_TYP) >> NMSDB_SHIFT_ENT_TYP)
#define NMSDB_NODE_TYPE_M(Flag)    (((Flag) & NMSDB_BIT_NODE_TYP) >> NMSDB_SHIFT_NODE_TYP)

//
// These macros evaluate to TRUE or FALSE
//
#define NMSDB_IS_ENTRY_LOCAL_M(Flag)  ((Flag) & NMSDB_BIT_LOCAL ? TRUE : FALSE)

#define NMSDB_SET_ENTRY_LOCAL_M(Flag)  (Flag) |= NMSDB_BIT_LOCAL
#define NMSDB_CLR_ENTRY_LOCAL_M(Flag)  (Flag) &= ~NMSDB_BIT_LOCAL

#define NMSDB_IS_ENTRY_STATIC_M(Flag)   ((Flag) & NMSDB_BIT_STATIC ? TRUE : FALSE)


#define NMSDB_CLR_ENTRY_TYPE_M(Flag)  (Flag) &= ~NMSDB_BIT_ENT_TYP
#define NMSDB_SET_ENTRY_TYPE_M(Flag, EntType)   {                        \
                                NMSDB_CLR_ENTRY_TYPE_M((Flag));                \
                                (Flag) |= ((EntType) << NMSDB_SHIFT_ENT_TYP);  \
                                        }

#define NMSDB_CLR_STATE_M(Flag)   (Flag) &= ~NMSDB_BIT_STATE
#define NMSDB_SET_STATE_M(Flag, state)   {                                \
                                NMSDB_CLR_STATE_M((Flag));                \
                                (Flag) |= ((state) << NMSDB_SHIFT_STATE);   \
                                        }

#define NMSDB_CLR_NODE_TYPE_M(Flag)  (Flag) &= ~NMSDB_BIT_NODE_TYP
#define NMSDB_SET_NODE_TYPE_M(Flag, NodeType)  {                        \
                        NMSDB_CLR_NODE_TYPE_M((Flag));                \
                        (Flag) |= ((NodeType) << NMSDB_SHIFT_NODE_TYP);   \
                                        }

#define NMSDB_CLR_STDYN_M(Flag)    (Flag) &= ~NMSDB_BIT_STATIC
#define NMSDB_SET_STDYN_M(Flag, StDynTyp)    {        \
                        NMSDB_CLR_STDYN_M(Flag);        \
                        (Flag) |= ((StDynTyp) << NMSDB_SHIFT_STATIC); \
                                             }

#define NMSDB_SET_STATIC_M(Flag)   (Flag) |= NMSDB_BIT_STATIC
#define NMSDB_SET_DYNAMIC_M(Flag)  (Flag) &= ~NMSDB_BIT_STATIC

#define NMSDB_ENTRY_ACT_M(Flag)         (NMSDB_ENTRY_STATE_M(Flag) == NMSDB_E_ACTIVE)
#define NMSDB_ENTRY_REL_M(Flag)         (NMSDB_ENTRY_STATE_M(Flag) == NMSDB_E_RELEASED)
#define NMSDB_ENTRY_TOMB_M(Flag) (NMSDB_ENTRY_STATE_M(Flag) == NMSDB_E_TOMBSTONE)
#define NMSDB_ENTRY_DEL_M(Flag) (NMSDB_ENTRY_STATE_M(Flag) == NMSDB_E_DELETED)



//
// Remember NameLen includes the EOS
//
FUTURES("Remove the following when support for spec. grp masks is put in")
#define  NMSDB_IS_IT_SPEC_GRP_NM_M(pName) (*((pName) + 15) == 0x1C)

//
// Used in NmsDbGetDataRecs()
//
#define  NMSDB_IS_IT_PDC_NM_M(pName) (*(pName) == 0x1B)


#define  NMSDB_IS_IT_DOMAIN_NM_M(pName) (*((pName) + 15) == 0x1C)
#define  NMSDB_IS_IT_BROWSER_NM_M(pName)  (*((pName) + 15) == 0x1D)


#define NMSDB_ENTRY_UNIQUE_M(EntTyp)   ((EntTyp) == NMSDB_UNIQUE_ENTRY)
#define NMSDB_ENTRY_NORM_GRP_M(EntTyp) ((EntTyp) == NMSDB_NORM_GRP_ENTRY)
#define NMSDB_ENTRY_SPEC_GRP_M(EntTyp) ((EntTyp) == NMSDB_SPEC_GRP_ENTRY)
#define NMSDB_ENTRY_MULTIHOMED_M(EntTyp) ((EntTyp) == NMSDB_MULTIHOMED_ENTRY)
#define NMSDB_ENTRY_GRP_M(EntTyp)      ((EntTyp) == NMSDB_NORM_GRP_ENTRY || \
                                         (EntTyp) == NMSDB_SPEC_GRP_ENTRY)

#define NMSDB_ENTRY_USER_SPEC_GRP_M(pName, EntTyp)  ((NMSDB_ENTRY_SPEC_GRP_M((EntTyp))) && !(NMSDB_IS_IT_SPEC_GRP_NM_M((pName))))

//
// Backup stuff
//
#if NEW_JET || DYNLOADJET
#define NMSDB_FULL_BACKUP          (JET_bitBackupAtomic)
#define NMSDB_INCREMENTAL_BACKUP   ((JET_bitBackupIncremental) | (JET_bitBackupAtomic))
typedef enum {
    DYN_LOAD_JET_200,
    DYN_LOAD_JET_500,
    DYN_LOAD_JET_600,
} DYN_LOAD_JET_VERSION ;

extern DYN_LOAD_JET_VERSION  DynLoadJetVersion;

//extern BOOL fDynLoadJet500;
//extern BOOL fDynLoadJet600;
#else
#define NMSDB_FULL_BACKUP          (JET_bitOverwriteExisting)
#define NMSDB_INCREMENTAL_BACKUP   (JET_bitBackupIncremental)
#endif


//
// Store the name in allocated memory if the name length is > 16.
//
// If the name is less than 17 bytes (can only happen if a small name is
// read in from a file -name within quotes is inserted in exactly the same
// form - or when an admin. inserts a smaller name via winscl), we allocate
// 17 bytes.  This is to protect against an access violation that may happen
// if the record that we have retrieved is a static - In GetGrpMem (called
// from StoreGrpMem), we access the 16th byte of the name field to see if it
// is 1C.
// We are not bothered that the 16th byte will always be 0 (allocated memory
// is initialized to 0) since we want the test in GetGrpMem to fail - see
// GetGrpMem
//
#define NMSDB_STORE_NAME_M(pTls, pRec, pLclName, NameLen)                \
        {                                                                \
                pRec->pName = WinsMscHeapAlloc(pTls->HeapHdl, NameLen < WINS_MAX_NS_NETBIOS_NAME_LEN ? WINS_MAX_NS_NETBIOS_NAME_LEN : NameLen);\
                WINSMSC_MOVE_MEMORY_M(pRec->pName, pLclName, NameLen); \
        }

#if 0
//
// Free all memory that may have been allocated for this record
//
#define NMSDB_FREE_REC_MEM_M(pRec)                        \
        {                                                \
                if (pRec->NameLen > WINS_MAX_NS_NETBIOS_NAME_LEN)        \
                {                                                        \
                        WinsMscHeapFree(RplRecHeapHdl, pRec->pName);        \
                }                                                        \
        }

#endif
/*
 externs
*/
struct _NMSDB_ADD_STATE_T;        //forward declaration

//
// Used during replication (response to get max vers # request)
//
extern VERS_NO_T    NmsDbStartVersNo;
extern WINS_UID_T   NmsDbUid;

//
// In memory table that stores the state of each WINS server we know about
// (as a PULL/PUSH pnr).  The index of the array is the owner id for that
//  WINS server (used to tag records in the name-address mapping table)
//
extern struct _NMSDB_ADD_STATE_T        *pNmsDbOwnAddTbl;
extern DWORD        NmsDbTotNoOfSlots;

//
// No of owners found in the Nam-Add mapping table
//
extern        DWORD                                NmsDbNoOfOwners;

//
// No of owners found in the Own-Add mapping table
//
extern        DWORD                                NmsDbNoOfPushPnrs;


//
// Stores the name of the database file
//
extern BYTE        NmsDbDatabaseFileName[WINS_MAX_FILENAME_SZ];

//
// critical section to protect the NmsDbOwnAddTbl (in-memory table)
//
extern CRITICAL_SECTION   NmsDbOwnAddTblCrtSec;

#ifdef WINSDBG
extern DWORD NmsDbDelDelDataRecs;
extern DWORD NmsDbDelQueryNUpdRecs;
#endif

/*
  enumerations
*/
/*
        NMSDB_TBL_ACTION_E

        Enumerates the actions that can be taken on a table
        Used by the Replicator when it calls NmsDbWriteOwnAddTbl at
        replication time

*/

typedef enum _NMSDB_TBL_ACTION_E {
        NMSDB_E_INSERT_REC = 0,         //Insert the record
        NMSDB_E_MODIFY_REC,                //modify the record
        NMSDB_E_DELETE_REC                //delete the record
        } NMSDB_TBL_ACTION_E, *PNMSDB_TBL_ACTION_E;






/*
        NMSDB_WINS_STATE_E

        states of a WINS server.

*/
typedef enum _NMSDB_WINS_STATE_E {

                NMSDB_E_WINS_ACTIVE = 0,      /*WINS is active */
                NMSDB_E_WINS_DOWN,  /*WINS is temporarily down (it may/may not        have entries in the name-add table*/
                NMSDB_E_WINS_DELETED,  //WINS is permanently down
                NMSDB_E_WINS_INCONSISTENT  //WINS is permanently down

                } NMSDB_WINS_STATE_E, *PNMSDB_WINS_STATE_E;


/*
 NMSDB_TBL_NAM_E - Enumerator for the different table names
*/
typedef enum _TBL_NAM_E {
        NMSDB_E_NAM_ADD_TBL_NM = 0,
        NMSDB_E_OWN_ADD_TBL_NM
        } NMSDB_TBL_NAM_E, *PNMSDB_TBL_NAM_E;


/*
 NMSDB_ADD_STATE_T
        Structure used to store the state of a WINS server
*/

typedef struct _NMSDB_ADD_STATE_T {
                COMM_ADD_T           WinsAdd;
                NMSDB_WINS_STATE_E   WinsState_e;
                DWORD                MemberPrec;
                VERS_NO_T            StartVersNo;
                WINS_UID_T           Uid;
                } NMSDB_ADD_STATE_T, *PNMSDB_ADD_STATE_T;


/*
 states of a database entry.
        There are three states
                ACTIVE,
                RELEASED,
                TOMBSTONE.

        These states are stored in two bits of the flags byte.  The values
        of these states should therefore be in the range 0-3 in the
        enumeration below.

        Enumeration is used to facilitate debugging since enumerated values
        are shown symbolically on many debuggers

        4th state of NMSDB_E_DELETED is not stored in the database.  It is
        used to mark an in-memory copy of the record as deleted for later
        removal from the db (see DoScavenging() in nmsscv.c)
*/
typedef enum _NMSDB_ENTRY_STATE_E {
        NMSDB_E_ACTIVE    = 0,
        NMSDB_E_RELEASED  = 1,
        NMSDB_E_TOMBSTONE = 2,
        NMSDB_E_DELETED   = 3
        } NMSDB_ENTRY_STATE_E, *PNMSDB_ENTRY_STATE_E;


/*
 typedef definitions
*/

/*
  NMSDB_TABLE_ID_T -- This is visible to DBM's clients making them
                      oblivious of the database engine's structure name
*/

typedef  JET_TABLEID        NMSDB_TABLE_ID_T, *PNMSDB_TABLE_ID_T;

/*
 NMSDB_GRP_MEM_ENTRY -- entry for a special group member in the database
*/
typedef struct _NMSDB_GRP_MEM_ENTRY_T {
                DWORD                  OwnerId;
                DWORD_PTR              TimeStamp;
                COMM_ADD_T         Add;
                } NMSDB_GRP_MEM_ENTRY_T, *PNMSDB_GRP_MEM_ENTRY_T;

/*
 Structure to store addres(es) of a conlficting record
*/
typedef struct _NMSDB_NODE_ADDS_T {
        DWORD                   NoOfMems;              /*no. of addresses*/
        NMSDB_GRP_MEM_ENTRY_T   Mem[NMSDB_MAX_MEMS_IN_GRP];   /*addresses */
        } NMSDB_NODE_ADDS_T, *PNMSDB_NODE_ADDS_T;


/*
 NMSDB_ROW_INFO_T -- Contains fields that go into a row of the Name -address
                   mapping table
*/
typedef struct _NMSDB_ROW_INFO_T {
        BYTE                 Name[NMSDB_MAX_NAM_LEN];    //name to reg or query
                                             