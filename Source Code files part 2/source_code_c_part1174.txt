 pTO->TypeOffset, Buf, 10 ) );
                pStream->Write( " (");
                pStream->Write( MIDL_ITOA( pTO->TypeOffset + Offset, Buf, 10 ) );
                pStream->Write( ") */");

                Offset += 2;
                }
                break;

            case FS_SHORT_TYPE_OFFSET :
                {
                // The absolute type offset.

                TypeOffsetDictElem  *   pTO;
                long                    ItsOffset; 
                    
                ItsOffset = *((unsigned short UNALIGNED *)(pBuffer + Offset));

                pTO = TypeOffsetDict.LookupOffset( Offset );

                if ( pTO->TypeOffset != ItsOffset )
                    {
                    pStream->Write( "Type offset out of range" );
                    pStream->NewLine();
                    RpcError(NULL, 0, FORMAT_STRING_LIMITS, "" );
                    fLimitErr = TRUE;
                    }
                
                if ( 0 == pTO->TypeOffset  ||  -1 == pTO->TypeOffset )
                    {
                    fprintf( stdout, "  MIDL_fixup: Invalid type offset at %d\n", Offset );
                    RpcError( NULL, 0, TYPE_OFFSET_IS_ZERO, "" );
                    }

                pStream->Write( "NdrFcShort( 0x" );
                pStream->Write( MIDL_ITOA( ItsOffset, Buf, 16 ) );
                pStream->Write( " ),\t/* Type Offset=");
                pStream->Write( MIDL_ITOA( pTO->TypeOffset, Buf, 10 ) );
                pStream->Write( " */");

                Offset += 2;
                }
                break;

            case FS_SHORT_STACK_OFFSET :
                {
                Out_ShortStackOffset( pStream, 
                                      OffsetDict.LookupOffset( Offset ), 
                                      EnvComment );
                Offset += 2;

                break;
                }
            case FS_SMALL_STACK_SIZE :
                {
                Out_SmallStackSize( pStream, 
                                    pBuffer[Offset], 
                                    EnvComment );
                Offset++;

                break;
                }

            case FS_LONG :
                pStream->Write( "NdrFcLong( 0x" );
                pStream->Write(
                    MIDL_LTOA( *((long UNALIGNED *)(pBuffer+Offset)), Buf, 16));
                pStream->Write( " ),\t/* ");
                pStream->Write(
                    MIDL_LTOA(*((long UNALIGNED *)(pBuffer+Offset)), Buf, 10));
                pStream->Write( " */");
        
                Offset += 4;
                break;

            case FS_PAD_MACRO :

                if ( pPadExprDesc )
                    {
                    MIDL_ASSERT( Offset == (long)pPadExprDesc->KeyOffset );

                    pPadDict->WriteCurrentPadDesc( pStream );
                    pPadExprDesc = pPadDict->GetNext();
                    }
                else
                    {
                    pStream->Write( "0x0,\t\t/* macro */" );
                    MIDL_ASSERT( 0  &&  "Pad macro missing" );
                    }

                Offset++;
                break;

            case FS_SIZE_MACRO :

                if ( pSizeDesc )
                    {
                    MIDL_ASSERT( Offset == (long)pSizeDesc->KeyOffset );

                    pSizeDict->WriteCurrentSizeDesc( pStream );
                    pSizeDesc = pSizeDict->GetNext();
                    }
                else
                    {
                    pStream->Write( "0x0, 0x0,\t\t//  macro" );
                    MIDL_ASSERT( 0  &&  "Size macro missing" );
                    }

                Offset += 2;
                break;

            case FS_UNKNOWN_STACK_SIZE :
                {
                char * LongBuf = Buf;
                long   NameLen = (long) strlen(
                                 UnknownStackSizeDict.LookupTypeName( (long) Offset ));
                if ( NameLen > 25 )
                    LongBuf = new char[ 75 + NameLen ];

                sprintf(
                    LongBuf,
                    "%s ( (sizeof(%s) + %s) & ~ (%s) ),",
                    "(unsigned char)",
                    UnknownStackSizeDict.LookupTypeName( (long) Offset ),
                    "sizeof(int) - 1",
                    "sizeof(int) - 1" );

                pStream->Write( LongBuf );
                }
                Offset++;
                break;
            }
        }

    pStream->NewLine( 2 );

    //
    // Spit out a terminating 0 so we don't ever fall off the end
    // of the world.
    //
    pStream->Write( "\t\t\t0x0" );

    pStream->IndentInc();
    pStream->IndentInc();
    pStream->IndentInc();

    pStream->IndentDec();
    pStream->NewLine();

    pStream->Write( '}' );
    pStream->IndentDec();
    pStream->NewLine();

    pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine();

    if ( LastOffset > _UI16_MAX )
        {
        pStream->Write( "Total Format String size is too big." );
        pStream->NewLine();
        fprintf(stdout, "Total Format String size = %d\n", LastOffset );
        RpcError(NULL, 0, FORMAT_STRING_LIMITS, "" );
        fLimitErr = TRUE;
        }

    if ( fLimitErr )
        exit( FORMAT_STRING_LIMITS );
}


long  
FORMAT_STRING::OptimizeFragment(
    CG_NDR  *       pNode )
/*++

Routine Description :
    
    Optimize a format string fragment away.

Arguments :
    
    pNode               - CG_NDR node, with format string start
                            and end offsets already set.

 --*/
{
    long      StartOffset = pNode->GetFormatStringOffset();
    long      EndOffset   = pNode->GetFormatStringEndOffset();

    FRMTREG_ENTRY       NewFragment( StartOffset, EndOffset );
    FRMTREG_ENTRY   *   pOldFragment;

    // perform format string optimization

#if defined(RKK_FRAG_OPT)
    {
            printf("Optimizing: start=%d, end=%d\n", StartOffset, EndOffset);

            printf("    off str=%d ", StartOffset );
            for (int off = StartOffset; off <= EndOffset; off++)
                printf("%02x ", pBuffer[ off ]);
            printf( "\n" );
            printf("    off typ=%d ", StartOffset );
            for ( off = StartOffset; off <= EndOffset; off++)
                printf("%02x ", pBufferType[ off ]);
            printf( "\n" );
    }
#endif

    if ( pCommand->IsSwitchDefined( SWITCH_NO_FMT_OPT ) )
        return StartOffset;

    // We attempt to optimize fragments even if they are apart by more than 32k.

    MIDL_ASSERT ( EndOffset <= (long)LastOffset );

    // add to dictionary

    // if match found, reset format string offset back to our start
    if ( GetReuseDict()->GetReUseEntry( pOldFragment, &NewFragment ) )
        {
        long  OldStartOffset = pOldFragment->GetStartOffset();

        // if we are not the end, we can't do anything about ourselves
        // similarly, if we match ourselves, don't do anything
        if ( ( GetCurrentOffset() == EndOffset ) &&
             ( OldStartOffset != StartOffset ) )
            {
            // move format string offset back
            SetCurrentOffset( StartOffset );
            pNode->SetFormatStringOffset( OldStartOffset );
            pNode->SetFormatStringEndOffset( pOldFragment->GetEndOffset() );
            return OldStartOffset;
            }

#if defined(RKK_FRAG_OPT)
        else if ( GetCurrentOffset() != EndOffset )
            {
            printf( "OptimizeFragment fragment not at the end End=%d, frag End=%d\n",
                    GetCurrentOffset(), EndOffset );
            }
#endif

        }   // duplicate found

    return StartOffset;

}


unsigned short  
FORMAT_STRING::RegisterFragment(
    CG_NDR  *       pNode )
/*++

Routine Description :
    
    Register, but do not remove, a format string fragment.

Arguments :
    
    pNode               - CG_NDR node, with format string start offset already set.
    EndOffset           - end offset of format string fragment

 --*/
{
    unsigned short      StartOffset     = (unsigned short)
                                                pNode->GetFormatStringOffset();
    unsigned short      EndOffset       = (unsigned short)
                                                pNode->GetFormatStringEndOffset();
    FRMTREG_ENTRY       NewFragment( StartOffset, EndOffset );
    FRMTREG_ENTRY   *   pOldFragment;

    // perform format string optimization
    if ( pCommand->IsSwitchDefined( SWITCH_NO_FMT_OPT ) )
        return StartOffset;

    MIDL_ASSERT( ( ((short) StartOffset) != -1 ) &&
            ( ((short) EndOffset) != -1 ) );
    MIDL_ASSERT ( EndOffset <= LastOffset );

    // add to dictionary, or return pointer to old entry
    GetReuseDict()->GetReUseEntry( pOldFragment, &NewFragment );

    return StartOffset;

}

char *
CommentDictionary::GetComments(
    long    Offset
    )
{
    CommentDictElem     Elem;
    CommentDictElem *   pHead;
    CommentDictElem *   pElem;
    Dict_Status         DictStatus;
    char *              Comments;
    long                Length;

    Elem.FormatStringOffset = Offset;

    DictStatus = Dict_Find( &Elem );

    if ( DictStatus != SUCCESS )
        return 0;

    pHead = (CommentDictElem *) Dict_Item();

    Length = 0;

    for ( pElem = pHead; pElem; pElem = pElem->Next )
        Length += (long) strlen( pElem->Comment );

    Comments = new char[Length+1];
    Comments[0] = 0;

    for ( pElem = pHead; pElem; pElem = pElem->Next )
        strcat( Comments, pElem->Comment );

    return Comments;
}

void
CommentDictionary::Insert(
    long    FormatStringOffset,
    char *  Comment
    )
{
    CommentDictElem     Elem;
    CommentDictElem *   pHead;
    CommentDictElem *   pElem;
    Dict_Status         DictStatus;

    Elem.FormatStringOffset = FormatStringOffset;

    DictStatus = Dict_Find( &Elem );

    if ( DictStatus == SUCCESS )
        pHead = (CommentDictElem *) Dict_Item();
    else
        pHead = 0;

    pElem = new CommentDictElem;

    pElem->Next = pHead;
    pElem->FormatStringOffset = FormatStringOffset;
    pElem->Comment = Comment;

    //
    // We delete any current entry and add a new entry so that comments
    // are always prepended to the list.
    //
    if ( pHead )
        Dict_Delete( (pUserType *) &pHead );

    Dict_Insert( pElem  );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\iid.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

 	iid.cxx

 Abstract:

	Generate a file containing UUIDs of [object] interfaces.

 Notes:


 History:


 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

CG_STATUS
CG_IID_FILE::GenCode(
	CCB		*	pCCB)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Generate the IID file.

 Arguments:

 	pCCB	- The code gen controller block.
	
 Return Value:

 	CG_OK	if all is well.
	
 Notes:

----------------------------------------------------------------------------*/
{
	ISTREAM				Stream( GetFileName(), 4 );
	ISTREAM	*			pStream = pCCB->SetStream( &Stream, this );
	CG_INTERFACE	*	pIntf;

	EmitFileHeadingBlock( pCCB, 
                          "the IIDs and CLSIDs",
                          "link this file in with the server and any clients" );


	// Write out the cplusplus guard.

	pStream->NewLine( 2 );
	pStream->Write( "#ifdef __cplusplus\nextern \"C\"{\n#endif " );
	pStream->NewLine( 2 );

	// Print out the declarations of the types and the procedures.

    const char * DefinitionBlock[] = 
    {
        "#include <rpc.h>"
       ,"#include <rpcndr.h>"
       ,""
       ,"#ifdef _MIDL_USE_GUIDDEF_"
       ,""
       ,"#ifndef INITGUID"
       ,"#define INITGUID"
       ,"#include <guiddef.h>"
       ,"#undef INITGUID"
       ,"#else"
       ,"#include <guiddef.h>"
       ,"#endif"
       ,""
       ,"#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \\"
       ,"        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)"
       ,""
       ,"#else // !_MIDL_USE_GUIDDEF_"
       ,""
       ,"#ifndef __IID_DEFINED__"
       ,"#define __IID_DEFINED__"
       ,""
       ,"typedef struct _IID"
       ,"{"
       ,"    unsigned long x;"
       ,"    unsigned short s1;"
       ,"    unsigned short s2;"
       ,"    unsigned char  c[8];"
       ,"} IID;"
       ,""
       ,"#endif // __IID_DEFINED__"
       ,""
       ,"#ifndef CLSID_DEFINED"
       ,"#define CLSID_DEFINED"
       ,"typedef IID CLSID;"
       ,"#endif // CLSID_DEFINED"            
       ,""
       ,"#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \\"
       ,"        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}"
       ,""
       ,"#endif !_MIDL_USE_GUIDDEF_"
       ,""
       ,NULL
    };
     
    pStream->WriteBlock(DefinitionBlock);
    
	pIntf	=	(CG_INTERFACE*) GetChild();

	while ( pIntf )
		{
        node_interface * pIntfNode = (node_interface *) pIntf->GetType();
        if (!pIntfNode->PrintedIID())
            {
		    switch ( pIntf->GetCGID() )
			    {
                case ID_CG_DISPINTERFACE:
                    {
                    CG_DISPINTERFACE * pDI = (CG_DISPINTERFACE *)pIntf;
                    node_dispinterface * pType = (node_dispinterface *) pDI->GetType();
                    node_guid * pGuid = (node_guid *) pType->GetAttribute( ATTR_GUID );
                    pStream->NewLine();
                    pStream->Write("MIDL_DEFINE_GUID(IID, DIID_");
                    pStream->Write(pDI->GetSymName());
                    pStream->Write(',');
                    Out_Guid(pCCB, pGuid->GetStrs(), GUIDFORMAT_RAW);
                    pStream->Write(");");
                    pStream->NewLine(2);
                    pIntfNode->SetPrintedIID();
	    
                    break;
                    }
                case ID_CG_COCLASS:
                    {
                    CG_COCLASS * pCoclass = (CG_COCLASS *)pIntf;
                    node_coclass * pType = (node_coclass *) pCoclass->GetType();
                    node_guid * pGuid = (node_guid *) pType->GetAttribute( ATTR_GUID );
                    pStream->NewLine();
                    pStream->Write("MIDL_DEFINE_GUID(CLSID, CLSID_");
                    pStream->Write(pCoclass->GetSymName());
                    pStream->Write(',');
                    Out_Guid(pCCB, pGuid->GetStrs(), GUIDFORMAT_RAW);
                    pStream->Write(");");
                    pStream->NewLine(2);
                    pIntfNode->SetPrintedIID();
	    
                    break;
                    }
			    case ID_CG_OBJECT_INTERFACE:
				    {
                    pStream->NewLine();
                    pStream->Write("MIDL_DEFINE_GUID(IID, IID_");
                    pStream->Write(pIntf->GetSymName());
                    pStream->Write(',');
                    Out_Guid(pCCB, pIntf->GetGuidStrs(), GUIDFORMAT_RAW);
                    pStream->Write(");");
                    pStream->NewLine(2);
                    pIntfNode->SetPrintedIID();

				    break;
				    }
                case ID_CG_LIBRARY:
                    {
                    CG_LIBRARY * pLib = (CG_LIBRARY *)pIntf;
                    node_library * pType = (node_library *) pLib->GetType();
                    node_guid * pGuid = (node_guid *) pType->GetAttribute( ATTR_GUID );
                    pStream->NewLine();
                    pStream->Write("MIDL_DEFINE_GUID(IID, LIBID_");
                    pStream->Write(pLib->GetSymName());
                    pStream->Write(',');
                    Out_Guid(pCCB, pGuid->GetStrs(), GUIDFORMAT_RAW);
                    pStream->Write(");");
                    pStream->NewLine(2);
	                CG_NDR * pChild	=	(CG_NDR*) pLib->GetChild();
                    pIntfNode->SetPrintedIID();

	                while ( pChild )
		                {
                        node_interface * pChildType = (node_interface *) pChild->GetType();
                        if (!pChildType->PrintedIID())
                            {
		                    switch ( pChild->GetCGID() )
			                    {
			                    case ID_CG_OBJECT_INTERFACE:
				                    {
                                    if (!pChildType->PrintedIID())
                                        {
                                        pStream->NewLine();
                                        pStream->Write("MIDL_DEFINE_GUID(IID, IID_");
				                        pStream->Write(pChild->GetSymName());
				                        pStream->Write(',');
				                        Out_Guid(pCCB, ((CG_INTERFACE*)pChild)->GetGuidStrs(), GUIDFORMAT_RAW );
            				            pStream->Write(");");
				                        pStream->NewLine(2);
                                        pChildType->SetPrintedIID();
                                        }
				                    break;
				                    }
                                case ID_CG_DISPINTERFACE:
                                    {
                                    CG_DISPINTERFACE * pDI = (CG_DISPINTERFACE *)pChild;
                                    node_dispinterface * pType = (node_dispinterface *) pDI->GetType();
                                    node_guid * pGuid = (node_guid *) pType->GetAttribute( ATTR_GUID );
                                    pStream->NewLine();
                                    pStream->Write("MIDL_DEFINE_GUID(IID, DIID_"); 
                                    pStream->Write(pDI->GetSymName());
                                    pStream->Write(',');
                                    Out_Guid(pCCB, pGuid->GetStrs(), GUIDFORMAT_RAW);
                                    pStream->Write(");");
                                    pStream->NewLine(2);
                                    pChildType->SetPrintedIID();
	                    
                                    break;
                                    }
                                case ID_CG_COCLASS:
                                    {
                                    CG_COCLASS * pCoclass = (CG_COCLASS *)pChild;
                                    node_coclass * pType = (node_coclass *) pCoclass->GetType();
                                    node_guid * pGuid = (node_guid *) pType->GetAttribute( ATTR_GUID );
                                    pStream->NewLine();
                                    pStream->Write("MIDL_DEFINE_GUID(CLSID, CLSID_");
                                    pStream->Write(pCoclass->GetSymName());
                                    pStream->Write(',');
                                    Out_Guid(pCCB, pGuid->GetStrs(), GUIDFORMAT_RAW);
                                    pStream->Write(");");
                                    pStream->NewLine(2);
                                    pChildType->SetPrintedIID();
	                    
                                    break;
                                    }
                                case ID_CG_INTERFACE:
			                    case ID_CG_INHERITED_OBJECT_INTERFACE:
			                    default:
				                    break;
			                    }
                            }
		                pChild = (CG_INTERFACE *) pChild->GetSibling();
        		        }
                    }
			    case ID_CG_INTERFACE:
			    case ID_CG_INHERITED_OBJECT_INTERFACE:
			    default:
				    break;
			    }
            } // if pIntfNode not printed

        pIntf = (CG_INTERFACE *) pIntf->GetSibling();
        } // while

	// print out the closing endifs.
    // the MIDL_DEFINE_GUID stuff.
    pStream->Write( "#undef MIDL_DEFINE_GUID" );
    pStream->NewLine();
	// the cplusplus stuff.
	pStream->NewLine();
	pStream->Write( "#ifdef __cplusplus\n}\n#endif\n" );
	pStream->NewLine();

	EmitFileClosingBlock( pCCB );

	pStream->Close();

	return CG_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\header.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

    header.cxx

 Abstract:
    
    Generates header file.

 Notes:


 History:


 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop
#include "buffer.hxx"

/****************************************************************************
 *  local definitions
 ***************************************************************************/


/****************************************************************************
 *  externs
 ***************************************************************************/
extern  CMD_ARG             *   pCommand;


CG_STATUS
CG_OBJECT_INTERFACE::GenHeader(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate interface header file.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes: The interface header file has the following structure:
        Forward declaration
        TypeDeclarations
        #if defined(__cplusplus) && !defined(CINTERFACE)
            CPlusPlusLanguageBinding
        #else 
            CLanguageBinding
        #endif

----------------------------------------------------------------------------*/
{
    node_interface *    pInterface = (node_interface *) GetType();
    ISTREAM *           pStream = pCCB->GetStream();
	char			*	pName	= pInterface->GetSymName();

    if (!pInterface->PrintedDef())
    {
        //Initialize the CCB for this interface.
        InitializeCCB(pCCB);

	    // put out the interface guards
	    pStream->Write("\n#ifndef __");
	    pStream->Write( pName );
	    pStream->Write( "_INTERFACE_DEFINED__\n" );

	    pStream->Write( "#define __");
	    pStream->Write( pName );
	    pStream->Write( "_INTERFACE_DEFINED__\n" );

        // Print out the declarations of the types
        pStream->NewLine();
        pInterface->PrintType( PRT_INTERFACE | PRT_OMIT_PROTOTYPE, pStream, 0);
        Out_IID(pCCB);
    
	    // print out the vtable/class definitions
        pStream->NewLine();
        pStream->Write("#if defined(__cplusplus) && !defined(CINTERFACE)");

        pStream->IndentInc();
        CPlusPlusLanguageBinding(pCCB);
        pStream->IndentDec();

        pStream->NewLine();
        pStream->Write("#else \t/* C style interface */");

        pStream->IndentInc();
        CLanguageBinding(pCCB);
        pStream->IndentDec();

	    // print out the C Macros
	    CLanguageMacros( pCCB );
        pStream->NewLine( 2 );

        pStream->Write("#endif \t/* C style interface */");
        pStream->NewLine( 2 );
    
	    // print out the prototypes for the proxy and stub routines

        ProxyPrototypes(pCCB);
        pStream->NewLine();

	    // put out the trailing interface guard
	    pStream->Write( "\n#endif \t/* __");
	    pStream->Write( pName );
	    pStream->Write( "_INTERFACE_DEFINED__ */\n" );

        pStream->NewLine();
        pInterface->SetPrintedDef();
    }
    return CG_OK;
}


CG_STATUS
CG_OBJECT_INTERFACE::CPlusPlusLanguageBinding(CCB *pCCB)
{
    ISTREAM *pStream = pCCB->GetStream();
    char *pName;

    pStream->NewLine();
    pName = GetType()->GetSymName();
    MIDL_ASSERT (pName != (char *)0);

    pStream->NewLine();

    // put out the declspec for the uuid
    if ( pCommand->GetMSCVer() >= 1100 )
        {
        pStream->Write("MIDL_INTERFACE(\"");
        pStream->Write(GuidStrs.str1);
        pStream->Write('-');
        pStream->Write(GuidStrs.str2);
        pStream->Write('-');
        pStream->Write(GuidStrs.str3);
        pStream->Write('-');
        pStream->Write(GuidStrs.str4);
        pStream->Write('-');
        pStream->Write(GuidStrs.str5);
        pStream->Write("\")");
        }
    else
        {
        pStream->Write(" struct ");
        }
    
    pStream->NewLine();
    pStream->Write(pName);

    CG_OBJECT_INTERFACE*    pBaseCG = (CG_OBJECT_INTERFACE*) GetBaseInterfaceCG();
    //Check if this interface was derived from a base interface.
    if(pBaseCG)
    {
        pStream->Write(" : public ");
        pStream->Write(pBaseCG->GetType()->GetSymName());
    }

    pStream->NewLine();
    pStream->Write('{');
    pStream->NewLine();
    pStream->Write("public:");
    pStream->IndentInc();

    // REVIEW: BEGIN/END_INTERFACE were only need for PowerMac.  Maybe we
    //         should stop emitting them?  -- MikeW 26-Jul-99

    if( ! pBaseCG )
        {
        pStream->NewLine();
        pStream->Write("BEGIN_INTERFACE");
        }

    PrintMemberFunctions( pStream, TRUE );

    if( ! pBaseCG )
        {
        pStream->NewLine();
        pStream->Write("END_INTERFACE");
        }

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();

    return CG_OK;
}

STATUS_T 
CG_OBJECT_INTERFACE::PrintMemberFunctions(
    ISTREAM       * pStream,
    BOOL			fAbstract) 
/*++

Routine Description:

    This routine prints C++ function prototypes for the interface member functions.
    We assume that all of the procedure nodes are pure virtual functions.

Arguments:

    pStream 	- Specifies the output stream.
	fAbstract	- Specifies whether the methods should be abstract ( = 0 ).

--*/
{
    CG_OBJECT_PROC  *   pProc = (CG_OBJECT_PROC *) GetChild();

    MIDL_ASSERT (GetType()->GetSymName() != (char *)0);

    while( pProc )
        {
        if ( !pProc->SupressHeader() )
            {
            node_skl* pN = pProc->GetType();

            //Assume this is a pure virtual function.
            // use the call_as form, if any
            pStream->NewLine();
            pStream->Write("virtual ");
            pN->PrintType( PRT_PROTOTYPE | PRT_CALL_AS | PRT_FORCE_CALL_CONV | PRT_CPP_PROTOTYPE, 
				           pStream, 
						   0 );
            if ( fAbstract) 
        	    pStream->Write(" = 0;");
		    else
			    pStream->Write(";");
            pStream->NewLine();
            }
 
        pProc = (CG_OBJECT_PROC *) pProc->GetSibling();
        }
    return STATUS_OK;
}


CG_STATUS
CG_OBJECT_PROC::PrintVtableEntry(
    CCB *       pCCB)
{
    ISTREAM *   pStream = pCCB->GetStream();
    node_id *   pTempID;
    char    *   pName   = GetType()->GetSymName();

    if (SupressHeader())
    {
        return CG_OK;
    }

    if ( GetCallAsName() )
        {
        pName = GetCallAsName();
        }

    pTempID = MakePtrIDNode( pName, GetType() );

    pStream->NewLine();
    pTempID->PrintType( PRT_PROC_PTR_PROTOTYPE | PRT_THIS_POINTER | PRT_CALL_AS | PRT_FORCE_CALL_CONV,
                        pStream,
                        NULL ,
                        pCCB->GetInterfaceCG()->GetType() );
                         
    return CG_OK;
}


CG_STATUS
CG_OBJECT_INTERFACE::CLanguageBinding(CCB *pCCB)
{
#ifndef DISABLE_C_OUTPUT
    ISTREAM *           pStream = pCCB->GetStream();
	char	*			pName	= pCCB->GetInterfaceName();

    pStream->NewLine( 2 );
    pStream->Write("typedef struct ");
    pStream->Write(pName);
    pStream->Write("Vtbl");
    pStream->NewLine();
    pStream->Write('{');

    
    pStream->IndentInc();
    pStream->NewLine();

    // REVIEW: BEGIN/END_INTERFACE were only need for PowerMac.  Maybe we
    //         should stop emitting them?  -- MikeW 26-Jul-99

    pStream->Write("BEGIN_INTERFACE");
    pStream->NewLine();

    // Now the regular entries.

    PrintVtableEntries( pCCB );

    // This is a match for the other macro.

    pStream->NewLine();
    pStream->Write("END_INTERFACE");

    pStream->IndentDec();
    pStream->NewLine();

    pStream->Write("} ");
    pStream->Write(pName);
    pStream->Write("Vtbl;");
    pStream->NewLine( 2 );
    pStream->Write("interface ");
    pStream->Write(pName);
    pStream->NewLine();
    pStream->Write('{');
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write("CONST_VTBL struct ");
    pStream->Write(pName);
    pStream->Write("Vtbl *lpVtbl;");
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine( 2 );
#endif
    return CG_OK;
}



CG_STATUS
CG_OBJECT_INTERFACE::ProxyPrototypes(CCB *pCCB)
/*++

Routine Description:

    This routine generates function prototypes for the interface proxy.
    For each procedure, we generate a proxy prototype and a 
    stub prototype.

Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.

--*/
{
    ISTREAM             *   pStream = pCCB->GetStream();
    CG_OBJECT_PROC      *   pProcCG = 0;
    char *                  pszName;
    CG_ITERATOR				I;

    pszName = GetType()->GetSymName();
    MIDL_ASSERT (pszName != (char *)0);

    GetMembers( I );
    while( ITERATOR_GETNEXT( I, pProcCG ) )
        {
        if (!pProcCG->SupressHeader())
            {
            //print proxy function prototype
            pStream->NewLine();
            pProcCG->Out_ProxyFunctionPrototype(pCCB, 
                                       PRT_TRAILING_SEMI );

            //print stub function prototype
            pStream->NewLine();
            pProcCG->Out_StubFunctionPrototype( pCCB );
            pStream->Write(';');
    
            pStream->NewLine();
            }
        }
    pStream->NewLine();

    return CG_OK;
}


CG_STATUS
CG_OBJECT_INTERFACE::PrintCMacros(CCB *pCCB)
/*++

Routine Description:

    This routine generates C macros for an interface

Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.

--*/
{
#ifndef DISABLE_C_OUTPUT
    ISTREAM             *   pStream = pCCB->GetStream();
    CG_OBJECT_PROC      *   pProcCG = 0;
    CG_ITERATOR        		I;

	// print inherited methods ( with our current ccb intf name )
	if ( GetBaseInterfaceCG() )                    
		((CG_OBJECT_INTERFACE *)GetBaseInterfaceCG())->PrintCMacros( pCCB );

    GetMembers( I );
    while( ITERATOR_GETNEXT( I, pProcCG ) )
        {
        //print proxy function prototype
        pStream->NewLine();
        pProcCG->GenCMacro(pCCB);

        }
    pStream->NewLine();
#endif    
    return CG_OK;
}


CG_STATUS
CG_OBJECT_INTERFACE::CLanguageMacros(CCB *pCCB)
{
#ifndef DISABLE_C_OUTPUT
    ISTREAM *           pStream = pCCB->GetStream();

    pStream->NewLine( 2 );
    pStream->Write("#ifdef COBJMACROS");
    pStream->NewLine();

    PrintCMacros( pCCB );

    pStream->NewLine();
    pStream->Write("#endif /* COBJMACROS */");
    pStream->NewLine();
#endif
    return CG_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\ilbase.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
    
    ilbase.cxx

 Abstract:

    Intermediate Language translator for base types

 Notes:


 Author:

    GregJen Dec-24-1993 Created.

 Notes:


 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

#include "ilxlat.hxx"
#include "ilreg.hxx"


/****************************************************************************
 *  local data
 ***************************************************************************/


/****************************************************************************
 *  externs
 ***************************************************************************/

extern CMD_ARG              *   pCommand;
extern BOOL                     IsTempName( char *);
extern REUSE_DICT           *   pReUseDict;

/****************************************************************************
 *  definitions
 ***************************************************************************/

//--------------------------------------------------------------------
//
// node_skl::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_skl::ILxlate( XLAT_CTXT* )
{
#ifdef trace_cg
    printf("..node_skl... kind is %d\n",NodeKind() );
#endif
    return 0;
};

//--------------------------------------------------------------------
//
// node_base_type::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_base_type::ILxlate( XLAT_CTXT * pContext )
{
    CG_NDR  *       pCG;
    XLAT_CTXT       MyContext(this, pContext);
#ifdef trace_cg
    printf("..node_base_type,\t%s\n", GetSymName());
#endif
    MyContext.BaseTypeSizes( this );

    // Note that these nodes are all preallocated so the modifiers
    // and this node can be ignored.

    // process any context_handle attributes from param nodes
    if ( pContext->ExtractAttribute( ATTR_CONTEXT ) )
        {
        MyContext.FixMemSizes( this );
        pCG = new CG_CONTEXT_HANDLE (
                                    this,
                                    0,
                                    MyContext
                                    );
        }

    switch ( NodeKind() )
        {
        case NODE_HANDLE_T:
            {
            pCG = new CG_PRIMITIVE_HANDLE( this, NULL, MyContext );
            break;
            }
        case NODE_INT3264:
            {
            if ( pCommand->Is64BitEnv() )
                pCG = new CG_INT3264( this, MyContext );
            else
                pCG = new CG_BASETYPE( this, MyContext );
            break;
            }
        case NODE_VOID:
            {
            // VOID should only occur as as a single VOID param;
            // return NULL here, then the PARAM returns NULL as well
            if (!pContext->AnyAncestorBits(IL_IN_LIBRARY) )
                return NULL;
            }
            // this looks like a conditional fall through.. 
        default:
            {

            if ( pContext->AnyAncestorBits( IL_CS_STAG | IL_CS_DRTAG | IL_CS_RTAG ) )
                {
                pCG = new CG_CS_TAG(
                                this,
                                MyContext,
                                pContext->AnyAncestorBits( IL_CS_STAG ),
                                pContext->AnyAncestorBits( IL_CS_DRTAG ),
                                pContext->AnyAncestorBits( IL_CS_RTAG ) );
                }
            else
                {
                pCG = new CG_BASETYPE( this, MyContext );
                node_range_attr* pRA = ( node_range_attr* ) pContext->ExtractAttribute( ATTR_RANGE );
                if ( pRA != 0 && pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
                    {
                    pCG->SetRangeAttribute( pRA );
                    }
                }
            break;
            }
        };
    
    pContext->ReturnSize( MyContext );

#ifdef trace_cg
    printf("..node_base_type return \n");
#endif
    return pCG; 
};


//--------------------------------------------------------------------
//
// node_label::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_label::ILxlate( XLAT_CTXT * pContext )
{
    pContext->ExtractAttribute(ATTR_IDLDESCATTR);
    pContext->ExtractAttribute(ATTR_VARDESCATTR);
    pContext->ExtractAttribute(ATTR_ID);
    pContext->ExtractAttribute(ATTR_HIDDEN);

#ifdef trace_cg
    printf("..node_label,\t%s\n", GetSymName());
#endif


return NULL;
};


//--------------------------------------------------------------------
//
// node_e_status_t::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_e_status_t::ILxlate( XLAT_CTXT * pContext )
{
    XLAT_CTXT           MyContext( this, pContext );
    CG_ERROR_STATUS_T * pCG;
    
#ifdef trace_cg
    printf("..node_e_status_t,\t%s\n", GetSymName());
#endif

    MyContext.BaseTypeSizes( this );
    
    // gaj - do we need to see which we used ??
    MyContext.ExtractAttribute( ATTR_COMMSTAT );
    MyContext.ExtractAttribute( ATTR_FAULTSTAT );

    pContext->ReturnSize( MyContext );

    pCG = new CG_ERROR_STATUS_T( this, MyContext );
    return pCG;
};


//--------------------------------------------------------------------
//
// node_wchar_t::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_wchar_t::ILxlate( XLAT_CTXT * pContext )
{
    CG_BASETYPE     *   pCG;
    XLAT_CTXT           MyContext( this, pContext );

#ifdef trace_cg
    printf("..node_wchar_t,\t%s\n", GetSymName());
#endif

    MyContext.BaseTypeSizes( this );

    pContext->ReturnSize( MyContext );

    pCG = new CG_BASETYPE( this, MyContext );
    return pCG;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\ilanaly.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1999-2000 Microsoft Corporation

 Module Name:

    ilanaly.cxx

 Abstract:

    Intermediate langangage analyzer/optimizer

 Notes:


 Author:

    mzoran Nov-11-1999 Created.

 Notes:

 This module takes an IL tree from IL translation and fixes the tree for correctness and
 optimizes the tree for performance.   Neither of these steps would be easy to do during 
 translation because of recursion and node reuse.  This module works around that problem by 
 first analyzing the nodes with the assumption that pointers do not propagate attributes, and
 then regenerating parts of the tree.
 
 Here are the steps.
 
 1. IL translation. Generic nodes are created, but variance, conformance, and complexity 
    are not determined yet.
 2. IL analysis.  Nodes are analyzed with recursion stopping at pointers.
 3. IL translation. Each node is converted exactly one. Variance, conformance, and 
    complexity are determined.  Simple structures are unrolled, and complex structures
    and regionalized.           
 ----------------------------------------------------------------------------*/
 
#include "becls.hxx"
#pragma hdrstop

extern  BOOL                            IsTempName( char *);

typedef  gplistmgr                      CG_UNROLLED_LIST;

typedef PTR_MAP<CG_CLASS,CG_CLASS> CG_ILCLASS_MAP;
typedef PTR_SET<CG_CLASS> CG_ILANALYSIS_SET;

void CG_ILANALYSIS_INFO::MergeAttributes( CG_ILANALYSIS_INFO *pMerge )
{
    if (pMerge->IsConformant())                SetIsConformant();
    if (pMerge->IsVarying())                   SetIsVarying();
    if (pMerge->IsForcedBogus())               SetIsForcedBogus();
    if (pMerge->IsFullBogus())                 SetIsFullBogus();
    if (pMerge->IsMultiDimensional())          SetIsMutiDimensional();
    if (pMerge->HasUnknownBuffer())            SetHasUnknownBuffer();
    if (pMerge->IsArrayofStrings())            SetIsArrayofStrings();
}

void ILUnroll( CG_CLASS *pClass, CG_UNROLLED_LIST *pList );


// 
//
//
//  Analysis STAGE 1
//
//  Analyze the IL nodes and mark them with attributes of interest.
//
//  Note:  Analysis only works if attributes do not propagate past pointers.  This
//         is necessary since pointers are used as a cutoff point during recursion.

enum _ILANALYSIS_ANCESTOR_FLAGS
{
  ILANALYSIS_IN_NOTHING               = 0,
  ILANALYSIS_IN_ARRAY                 = (1 << 0), // Directly under an array 
  ILANALYSIS_IN_ARRAY_CONFORMANCE     = (1 << 1), // Directly under a conformant array
  ILANALYSIS_IN_ARRAY_VARIANCE        = (1 << 2), // Directly under an array with variance
  ILANALYSIS_IN_EVERYTHING            = ((1 << 3) - 1)
};

typedef unsigned long ILANALYSIS_ANCESTOR_FLAGS; 

enum _ILANALYSIS_DESCENDANT_FLAGS
{
  ILANALYSIS_HAS_NOTHING              = 0,
  ILANALYSIS_HAS_ARRAY                = (1 << 0), // No struct/union/ptr between child array
  ILANALYSIS_HAS_ARRAY_CONFORMANCE    = (1 << 1), // No struct/union/ptr between child conf array
  ILANALYSIS_HAS_ARRAY_VARIANCE       = (1 << 2), // No struct/union/ptr between child var array
  ILANALYSIS_HAS_STRING               = (1 << 3), // No struct/union/ptr between child string
  ILANALYSIS_HAS_STRUCT_CONFORMANCE   = (1 << 4), // No ptr between child conf struct
  ILANALYSIS_HAS_STRUCT_VARIANCE      = (1 << 5), // No ptr between child var struct
  ILANALYSIS_HAS_FULL_BOGUS           = (1 << 6), // No ptr between fullbogus child
  ILANALYSIS_HAS_FORCED_BOGUS         = (1 << 7), // No ptr between forced bogus child
  ILANALYSIS_HAS_POINTER              = (1 << 8), // Child has pointer
  ILANALYSIS_HAS_UNKNOWN_BUFFER       = (1 << 9), // Buffer size is unknown
  ILANALYSIS_HAS_POINTER_ARRAY        = (1 << 10),// No ptr between array with pointers
  ILANALYSIS_HAS_EVERYTHING           = ((1 << 11) - 1)
};

typedef unsigned long ILANALYSIS_DESCENDANT_FLAGS;

typedef struct 
{
  ILANALYSIS_ANCESTOR_FLAGS ParentReceiveMask;  // Flags that should be received from parent.
  ILANALYSIS_ANCESTOR_FLAGS ChildPassMask;      // Flags that should be passed to child.
  ILANALYSIS_DESCENDANT_FLAGS ChildReceiveMask; // Flags that should be received from child.  
  ILANALYSIS_DESCENDANT_FLAGS ParentPassMask;   // Flags that should be passed to parent.

} ILANALYSIS_FLAGS_MASK;

const ILANALYSIS_FLAGS_MASK ILANALYSIS_PASS_EVERYTHING_FLAGS = 
    {
    ILANALYSIS_IN_EVERYTHING,
    ILANALYSIS_IN_EVERYTHING,
    ILANALYSIS_HAS_EVERYTHING,
    ILANALYSIS_HAS_EVERYTHING
    };

const ILANALYSIS_FLAGS_MASK ILANALYSIS_BLOCK_EVERYTHING_FLAGS =
    {
    ILANALYSIS_IN_NOTHING,
    ILANALYSIS_IN_NOTHING,
    ILANALYSIS_HAS_NOTHING,
    ILANALYSIS_HAS_NOTHING
    };

class CG_ILANALYSIS_VISITOR
{

protected:

   CG_ILANALYSIS_VISITOR *pParentCtxt;
   ILANALYSIS_ANCESTOR_FLAGS AncestorFlags;
   ILANALYSIS_DESCENDANT_FLAGS DescendantFlags;
   const ILANALYSIS_FLAGS_MASK *pFlagsMask;
   unsigned long Dimensions;

   CG_ILANALYSIS_SET *pRecursiveSet;

   void PropagateInfo( const ILANALYSIS_FLAGS_MASK *pFlags );
   void ContinueAnalysis( CG_CLASS *pClass );
   CG_ILANALYSIS_INFO* GetAnalysisInfo( CG_CLASS *pClass ) {return pClass->GetILAnalysisInfo(); }
   void PropagateInfoToParent( );

   BOOL AnyAncestorFlags(ILANALYSIS_ANCESTOR_FLAGS Flags) { return Flags & AncestorFlags; }
   BOOL AnyDescendantFlags(ILANALYSIS_DESCENDANT_FLAGS Flags) { return Flags & DescendantFlags; }
   void ClearAncestorFlags(ILANALYSIS_ANCESTOR_FLAGS Flags) 
       { AncestorFlags &= ~Flags;}
   void ClearDescendantFlags(ILANALYSIS_DESCENDANT_FLAGS Flags)
       { DescendantFlags &= ~Flags;}
   void AddAncestorFlags( ILANALYSIS_ANCESTOR_FLAGS NewAncestorFlags )
       { AncestorFlags |= NewAncestorFlags; }
   void AddDescendantFlags( ILANALYSIS_ANCESTOR_FLAGS NewDescendantFlags )
       { DescendantFlags |= NewDescendantFlags; }
   unsigned long GetDimensions( ) { return Dimensions; }
   void SetDimensions(unsigned long Dims ) { Dimensions = Dims;}


   ILANALYSIS_ANCESTOR_FLAGS GetFlagsForChild() 
       {
       return AncestorFlags & pFlagsMask->ChildPassMask;
       }
   void SetFlagsFromChild(  ILANALYSIS_DESCENDANT_FLAGS ChildFlags ) 
       {
       AddDescendantFlags( ChildFlags & 
                          pFlagsMask->ChildReceiveMask );
       }

public:


   void Visit( CG_BASETYPE *pClass );
   void Visit( CG_HANDLE *pClass );
   void Visit( CG_GENERIC_HANDLE *pClass );
   void Visit( CG_CONTEXT_HANDLE *pClass );
   void Visit( CG_IGNORED_POINTER *pClass );
   void Visit( CG_CS_TAG *pClass );
   void Visit( CG_CLASS *pClass );
   void Visit( CG_PROC *pClass );
   void Visit( CG_TYPEDEF *pClass );
   void Visit( CG_STRUCT *pClass );
   void Visit( CG_UNION *pClass );
   void Visit( CG_ARRAY *pClass );
   void Visit( CG_STRING_ARRAY *pClass );
   void Visit( CG_CONFORMANT_ARRAY *pClass );
   void Visit( CG_CONFORMANT_STRING_ARRAY *pClass );
   void Visit( CG_VARYING_ARRAY *pClass );
   void Visit( CG_CONFORMANT_VARYING_ARRAY *pClass );
   void Visit( CG_FIXED_ARRAY *pClass );
   void Visit( CG_POINTER *pClass );
   void Visit( CG_BYTE_COUNT_POINTER *pClass );
   void Visit( CG_LENGTH_POINTER *pClass );
   void Visit( CG_INTERFACE_POINTER *pClass );
   void Visit( CG_QUALIFIED_POINTER *pClass );
   void Visit( CG_STRING_POINTER *pClass );
   void Visit( CG_SIZE_POINTER *pClass );
   void Visit( CG_SIZE_STRING_POINTER *pClass ); 
   void Visit( CG_SIZE_LENGTH_POINTER *pClass );
   void Visit( CG_FIELD *pClass );
   void Visit( CG_CASE *pClass );

   static void StartAnalysis( CG_CLASS *pClass );
};

void CG_ILANALYSIS_VISITOR::StartAnalysis( CG_CLASS *pClass )
{
   CG_ILANALYSIS_SET RecursiveSet;

   CG_VISITOR_TEMPLATE<CG_ILANALYSIS_VISITOR> TemplateVisitor;
   CG_ILANALYSIS_VISITOR & Visitor = TemplateVisitor;

   Visitor.pParentCtxt = NULL;
   Visitor.pRecursiveSet = &RecursiveSet;
   Visitor.AncestorFlags = ILANALYSIS_IN_NOTHING;
   Visitor.DescendantFlags = ILANALYSIS_HAS_NOTHING;
   Visitor.pFlagsMask = NULL;

   if ( NULL != pClass)   
       {
       pClass->Visit( &TemplateVisitor );       
       }
}

void CG_ILANALYSIS_VISITOR::ContinueAnalysis( CG_CLASS *pClass )
{
   
   // Some classes have a NULL child in special cases.  In instead
   // of putting this check everywhere, just put it in this central 
   // location.
   if ( NULL != pClass )
       {
       CG_VISITOR_TEMPLATE<CG_ILANALYSIS_VISITOR> TemplateVisitor;
       CG_ILANALYSIS_VISITOR & Visitor = TemplateVisitor;
       
       Visitor.pParentCtxt = this;
       Visitor.pRecursiveSet = this->pRecursiveSet;
       Visitor.AncestorFlags = ILANALYSIS_IN_NOTHING;
       Visitor.DescendantFlags = ILANALYSIS_HAS_NOTHING;
       Visitor.pFlagsMask = NULL;
    
       pClass->Visit( &TemplateVisitor );
    
       Visitor.PropagateInfoToParent();
       }
}

void CG_ILANALYSIS_VISITOR::PropagateInfo( const ILANALYSIS_FLAGS_MASK *pFlags )
{
    pFlagsMask = pFlags;
	if (NULL != pParentCtxt)
        {
        Dimensions = 0;
        AddAncestorFlags( pParentCtxt->GetFlagsForChild() &
                          pFlagsMask->ParentReceiveMask );
        }
}

void CG_ILANALYSIS_VISITOR::PropagateInfoToParent() 
{
    if ( ( pFlagsMask != NULL ) && ( pParentCtxt != NULL ) )
        {
        pParentCtxt->Dimensions = Dimensions;
        pParentCtxt->SetFlagsFromChild( DescendantFlags &
                                pFlagsMask->ParentPassMask );        
        }
}


//
//
// Leaf Nodes
// 

//
// Basetype
// CG_BASETYE
// CG_INT3264
// CG_ENUM
// CG_HRESULT

void CG_ILANALYSIS_VISITOR::Visit( CG_BASETYPE *pClass )
{
    PropagateInfo( &ILANALYSIS_PASS_EVERYTHING_FLAGS );

    if (pClass->GetMemorySize() != pClass->GetWireSize())
        AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );

    if ( pClass->GetRangeAttribute() )
        AddDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS );
}
            
// CG_HANDLE
// CG_PRIMITIVE_HANDLE

void CG_ILANALYSIS_VISITOR::Visit( CG_HANDLE *pClass )
{
   PropagateInfo( &ILANALYSIS_PASS_EVERYTHING_FLAGS );

   if (pClass->GetMemorySize() != pClass->GetWireSize())
       AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_GENERIC_HANDLE *pClass )
{
   Visit( (CG_HANDLE*) pClass );
   AddDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_CONTEXT_HANDLE *pClass )
{
   Visit( (CG_HANDLE*) pClass );
   AddDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_IGNORED_POINTER *pClass )
{
   PropagateInfo( &ILANALYSIS_PASS_EVERYTHING_FLAGS );
   
   AddDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS );

   if (pClass->GetMemorySize() != pClass->GetWireSize())
       AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_CS_TAG *pClass )
{
   PropagateInfo( &ILANALYSIS_PASS_EVERYTHING_FLAGS );  
    
   if (pClass->GetMemorySize() != pClass->GetWireSize())
       AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );
}

//
// General Catchall cases.   No attributes are propagated.
// CG_CLASS
// CG_NDR
// CG_AUX
// CG_SOURCE
// CG_COCLASS
// CG_MODULE
// CG_SAFEARRAY
//
// Files
// CG_FILE
// CG_SSTUB_FILE
// CG_HDR_FILE
// CG_CSTUB_FILE
// CG_IID_FILE
// CG_NETMONSTUB_FILE
// CG_PROXY_FILE
// CG_TYPELIBRARY_FILE
//
// Interfaces
// CG_INTERFACE
// CG_OBJECT_INTERFACE
// CG_DISPINTERFACE
// CG_INHERITED_OBJECT_INTERFACE
// CG_INTERFACE_REFERENCE
// CG_IUNKNOWN_OBJECT_INTERFACE
// CG_ASYNC_HANDLE
// CG_ID
// 
// Parameters
// CG_PARAM
// CG_RETURN

void CG_ILANALYSIS_VISITOR::Visit( CG_CLASS *pClass )
{
   PropagateInfo( &ILANALYSIS_PASS_EVERYTHING_FLAGS );

   CG_ITERATOR Iterator;
   CG_CLASS *pChild = NULL;

   pClass->GetMembers( Iterator );

   while ( ITERATOR_GETNEXT( Iterator, pChild ) )
       ContinueAnalysis( pChild );

}

//
// Proc derived.  Attributes do not propagate past or apply to these nodes
//
//  CG_PROC
//  CG_CALLBACK_PROC
//  CG_ENCODE_PROC
//  CG_IUNKNOWN_OBJECT_PROC
//  CG_LOCAL_OBJECT_PROC
//  CG_OBJECT_PROC
//  CG_INHERITIED_OBJECT_PROC
//  CG_TYPE_ENCODE_PROC

void CG_ILANALYSIS_VISITOR::Visit( CG_PROC *pClass )
{
   PropagateInfo( &ILANALYSIS_BLOCK_EVERYTHING_FLAGS );

   CG_ITERATOR Iterator;
   CG_CLASS *pParam = NULL;

   pClass->GetMembers( Iterator );

   while ( ITERATOR_GETNEXT( Iterator, pParam ) )
       ContinueAnalysis( pParam );

   CG_CLASS *pReturnCG = pClass->GetReturnType();

   if ( pReturnCG )
       ContinueAnalysis( pReturnCG );

}

//
// typedef derived.  For now all of these force full complexity.
// 
// For now, all of these make the parent bogus.
// 
// CG_TYPEDEF
// CG_TYPE_ENCODE
// CG_PIPE
// CG_USER_MARSHAL
// CG_REPRESENT_AS
// CG_TRANSMIT_AS
// 
//

void CG_ILANALYSIS_VISITOR::Visit( CG_TYPEDEF *pClass )
{
       
   PropagateInfo( &ILANALYSIS_PASS_EVERYTHING_FLAGS );
   
   ContinueAnalysis( pClass->GetChild() );
   
   AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );
   AddDescendantFlags( ILANALYSIS_HAS_UNKNOWN_BUFFER );

}

//
// 
//
//   Root for structures and unions.
//   MAKE_ASSERT_ENTRY( CG_COMP )
//
//   Structures
//
//   All structures are handled from the base.
//
//   CG_STRUCT
//   CG_COMPLEX_STRUCT
//   CG_CONFORMAT_STRUCT
//   CG_CONFORMANT_VARYING_STRUCT
//   CG_ENCAPSULATED_STRUCT
//
// Policy for structures:
//
// 1.  A structure is full bogus if any of the following is true:
//     A. Any field of the structure is full bogus.
//     B. Any field has a unknown wire size or offset.
//     C. Any field has a wire size or offset that is different from the
//        memory size and offset.
//     D. The wire size of the structure is different from the memory size of the structure.
//     E. Any field is varying.
//
// 2.  A structure is forced bogus is any of the following is true.
//     A. Any field of the structure is forced bogus.
//
//  
//


void CG_ILANALYSIS_VISITOR::Visit( CG_STRUCT *pClass )
{

    static const ILANALYSIS_DESCENDANT_FLAGS STRUCT_TO_PARENT_MASK = 
        ILANALYSIS_HAS_STRUCT_CONFORMANCE |
        ILANALYSIS_HAS_STRUCT_VARIANCE |
        ILANALYSIS_HAS_STRING |
        ILANALYSIS_HAS_FULL_BOGUS |
        ILANALYSIS_HAS_POINTER |
        ILANALYSIS_HAS_POINTER_ARRAY |
        ILANALYSIS_HAS_FORCED_BOGUS |
        ILANALYSIS_HAS_UNKNOWN_BUFFER;

    static const ILANALYSIS_FLAGS_MASK StructAnalysisFlags =
    {   ILANALYSIS_IN_NOTHING,     // From parent 
        ILANALYSIS_IN_NOTHING,     // To child
        ILANALYSIS_HAS_EVERYTHING, // From child
        STRUCT_TO_PARENT_MASK      // To parent
    };

    PropagateInfo( &StructAnalysisFlags );

    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    CG_ITERATOR         Iterator;
    CG_FIELD            *pField;

    pClass->GetMembers( Iterator );

    while( ITERATOR_GETNEXT( Iterator, pField ) )
        {

        ContinueAnalysis( pField );

        // If an array is varying the structure needs to be marked as full bogus.
        if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE |
                                 ILANALYSIS_HAS_STRUCT_VARIANCE |
                                 ILANALYSIS_HAS_STRING ) )
            {
            pAnalysisInfo->SetIsFullBogus();
            }

        if ( ( pField->GetMemOffset() != pField->GetWireOffset() ) ||
             ( pField->GetMemorySize() != pField->GetWireSize() ) )
            {
            pAnalysisInfo->SetIsFullBogus();
            }

        }

    // Copy context attributes to structure node.

    if ( AnyDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS ) ||
         ( pClass->GetWireSize() != pClass->GetMemorySize() ) )
        pAnalysisInfo->SetIsFullBogus();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS ) )
        pAnalysisInfo->SetIsForcedBogus();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_STRUCT_CONFORMANCE | 
                             ILANALYSIS_HAS_ARRAY_CONFORMANCE ) )
        pAnalysisInfo->SetIsConformant();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_STRUCT_VARIANCE |
                             ILANALYSIS_HAS_ARRAY_VARIANCE ) )
        pAnalysisInfo->SetIsVarying();

    if ( pAnalysisInfo->IsConformant() || 
         pAnalysisInfo->IsVarying() ||
         AnyDescendantFlags( ILANALYSIS_HAS_UNKNOWN_BUFFER ) )
        {
        pAnalysisInfo->SetHasUnknownBuffer();
        }

    if ( pAnalysisInfo->IsVarying() )
        pAnalysisInfo->SetIsFullBogus();

    // Copy structure node attributes to context.

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_CONFORMANCE ) )
         AddDescendantFlags( ILANALYSIS_HAS_STRUCT_CONFORMANCE );
         
    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE ) )
         AddDescendantFlags( ILANALYSIS_HAS_STRUCT_VARIANCE );

    if ( pAnalysisInfo->IsFullBogus() )
         AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );
    if ( pAnalysisInfo->IsForcedBogus() )
         AddDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS );

}

//
// 
//
//   Unions
//
// For now, all unions have an unknown buffer size and cause the containing structure or
// array to be full bogus. This may change since a union where all the arms have the
// same size has a well defined wire size.  An example of this is a union of pointers.
//
//  
//
void CG_ILANALYSIS_VISITOR::Visit( CG_UNION *pClass )
{
    static const ILANALYSIS_DESCENDANT_FLAGS UNION_TO_PARENT_MASK = 
        ILANALYSIS_HAS_STRUCT_CONFORMANCE |
        ILANALYSIS_HAS_STRUCT_VARIANCE |
        ILANALYSIS_HAS_STRING |
        ILANALYSIS_HAS_FULL_BOGUS |
        ILANALYSIS_HAS_POINTER |
        ILANALYSIS_HAS_POINTER_ARRAY |
        ILANALYSIS_HAS_FORCED_BOGUS |
        ILANALYSIS_HAS_UNKNOWN_BUFFER;

    static const ILANALYSIS_FLAGS_MASK UnionAnalysisFlags =
    {   ILANALYSIS_IN_NOTHING,     // From parent 
        ILANALYSIS_IN_NOTHING,     // To child
        ILANALYSIS_HAS_EVERYTHING, // From child
        UNION_TO_PARENT_MASK      // To parent
    };

    PropagateInfo( &UnionAnalysisFlags );

    CG_ITERATOR         Iterator;
    CG_FIELD            *pArm;

    pClass->GetMembers( Iterator );

    while( ITERATOR_GETNEXT( Iterator, pArm ) )
       ContinueAnalysis( pArm );

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_CONFORMANCE ) )
         AddDescendantFlags( ILANALYSIS_HAS_STRUCT_CONFORMANCE );

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE ) )
         AddDescendantFlags( ILANALYSIS_HAS_STRUCT_VARIANCE );

    AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );
    AddDescendantFlags( ILANALYSIS_HAS_UNKNOWN_BUFFER );

}
//
//
//  Arrays
//
//  All arrays are handled from the base class.
//
//  CG_ARRAY
//  CG_STRING_ARRAY
//  CG_CONFORMANT_ARRAY
//  CG_CONFORMANT_STRING_ARRAY
//  CG_VARYING_ARRAY
//  CG_CONFORMANT_VARYING_ARRAY
//  CG_FIXED_ARRAY
//
// Policy for arrays:
//
// Conformance/Variance
// 1.  If any dimemsion of a multidimensional array is conformant, all dimensions are
//     conformant.
// 2.  If any dimension of a multidimensional array is varying, all dimensions are varying.
// 3.  An arrays a strings does not make the arrays varying.
// 4.  An array of conformant strings does make all dimensions of the array conformant.
//
// Full bogus:
//
// 5. An array is full bogus if any of the following are true:
//    A. The child of the array is full bogus.
//    B. The array is a string.
//
// Forced bogus:
// 6. An array is forced bogus if any of the following are true:
//    A. The array is multidimensional.
//    B. Any child of the array is an array with pointers.
//    C. The child of the array is forced bogus.
//
//

void CG_ILANALYSIS_VISITOR::Visit( CG_ARRAY *pClass )
    {

    static const ILANALYSIS_DESCENDANT_FLAGS ARRAY_TO_PARENT_MASK = 
          ILANALYSIS_HAS_ARRAY                  |
          ILANALYSIS_HAS_ARRAY_CONFORMANCE      | 
          ILANALYSIS_HAS_ARRAY_VARIANCE         |
          ILANALYSIS_HAS_STRING                 |
          ILANALYSIS_HAS_FULL_BOGUS             |
          ILANALYSIS_HAS_FORCED_BOGUS           |
          ILANALYSIS_HAS_POINTER                |
          ILANALYSIS_HAS_POINTER_ARRAY          |
          ILANALYSIS_HAS_UNKNOWN_BUFFER;

    static const ILANALYSIS_FLAGS_MASK ArrayAnalysisFlags =
    {   ILANALYSIS_IN_EVERYTHING,     // From parent 
        ILANALYSIS_IN_EVERYTHING,     // To child
        ILANALYSIS_HAS_EVERYTHING,    // From child
        ARRAY_TO_PARENT_MASK          // To parent
    };

    PropagateInfo( &ArrayAnalysisFlags );

    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    //
    // Copy flags from ancestor flags to node.
    //

    if ( AnyAncestorFlags( ILANALYSIS_IN_ARRAY ) )
        pAnalysisInfo->SetIsMutiDimensional();

    if ( AnyAncestorFlags( ILANALYSIS_IN_ARRAY_CONFORMANCE  ) )
        pAnalysisInfo->SetIsConformant();
    
    if ( AnyAncestorFlags( ILANALYSIS_IN_ARRAY_VARIANCE ) )
        pAnalysisInfo->SetIsVarying();

    //
    // Copy ancestor flags from node to context
    // 


    AddAncestorFlags( ILANALYSIS_IN_ARRAY );

    if ( pAnalysisInfo->IsConformant() )
        AddAncestorFlags( ILANALYSIS_IN_ARRAY_CONFORMANCE  );

    if ( pAnalysisInfo->IsVarying() )
        AddAncestorFlags( ILANALYSIS_IN_ARRAY_VARIANCE );

    ContinueAnalysis( pClass->GetChild() );
    
    //
    // copy descendant flags from context to node.
    //
    unsigned long Dimensions = GetDimensions();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY ) )
        {
        Dimensions++;
        pAnalysisInfo->SetIsMutiDimensional();
        }
    else 
        {
        Dimensions = 1;
        }

    SetDimensions( Dimensions );
    pAnalysisInfo->SetDimensions( (unsigned char) Dimensions );

    if ( Dimensions >= 256 )
        {
        RpcError( NULL, 0, ARRAY_DIMENSIONS_EXCEEDS_255, NULL );
        exit(ARRAY_DIMENSIONS_EXCEEDS_255); 
        }

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_CONFORMANCE ) )
        pAnalysisInfo->SetIsConformant();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE ) )
        pAnalysisInfo->SetIsVarying();
    
    if ( AnyDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS ) )
        pAnalysisInfo->SetIsFullBogus();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS ) ||
         AnyDescendantFlags( ILANALYSIS_HAS_POINTER_ARRAY ) ||
         pAnalysisInfo->IsMultiDimensional() )
        pAnalysisInfo->SetIsForcedBogus();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_UNKNOWN_BUFFER ) ||
         pAnalysisInfo->IsConformant() ||
         pAnalysisInfo->IsVarying() )
        pAnalysisInfo->SetHasUnknownBuffer();

    //
    // If the array has a first_is attribute that is not 0 then,
    // mark the array as forced bogus.
    //
    CG_VARY_ATTRIBUTE *pVaryAttribute = dynamic_cast<CG_VARY_ATTRIBUTE*>( pClass );
    if ( NULL != pVaryAttribute )
       {
       expr_node *pFirstIs = pVaryAttribute->GetFirstIsExpr();
       if ( NULL != pFirstIs )
           {
           if ( !pFirstIs->IsConstant() )
               pAnalysisInfo->SetIsForcedBogus();
           else if ( pFirstIs->GetValue() != 0 )
               pAnalysisInfo->SetIsForcedBogus();
           }
       }

    //
    // Copy descendant flags from node to context
    //

    AddDescendantFlags( ILANALYSIS_HAS_ARRAY );
    if ( AnyDescendantFlags( ILANALYSIS_HAS_POINTER ) )
        {
        AddDescendantFlags( ILANALYSIS_HAS_POINTER_ARRAY );
        }

    if ( pAnalysisInfo->IsForcedBogus() )
        AddDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS );

    if ( pAnalysisInfo->IsFullBogus() )
        AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );

    if ( pAnalysisInfo->IsConformant() )
        AddDescendantFlags( ILANALYSIS_HAS_ARRAY_CONFORMANCE );

    if ( pAnalysisInfo->IsVarying() )
        AddDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE );

    if ( pAnalysisInfo->HasUnknownBuffer() )
        AddDescendantFlags( ILANALYSIS_HAS_UNKNOWN_BUFFER );

    if ( pAnalysisInfo->IsArrayofStrings() )
        AddDescendantFlags( ILANALYSIS_HAS_STRING );
    
    }
            
void CG_ILANALYSIS_VISITOR::Visit( CG_STRING_ARRAY *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsVarying();
    pAnalysisInfo->SetIsArrayofStrings();
    pAnalysisInfo->SetHasUnknownBuffer();
    
    Visit( (CG_ARRAY*) pClass );

    // Do not propagate up variance from strings
    ClearDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE  );

}

void CG_ILANALYSIS_VISITOR::Visit( CG_CONFORMANT_ARRAY *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsConformant();
    pAnalysisInfo->SetHasUnknownBuffer();
    Visit( (CG_ARRAY *) pClass );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_CONFORMANT_STRING_ARRAY *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsConformant();
    pAnalysisInfo->SetIsArrayofStrings();    
    pAnalysisInfo->SetIsVarying();
    pAnalysisInfo->SetHasUnknownBuffer();

    Visit( (CG_ARRAY *) pClass );

    // Do not propagate up variance from strings
    ClearDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE  );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_VARYING_ARRAY *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsVarying();
    pAnalysisInfo->SetHasUnknownBuffer();
    Visit( (CG_ARRAY *) pClass );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_CONFORMANT_VARYING_ARRAY *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsConformant();
    pAnalysisInfo->SetIsVarying( );
    pAnalysisInfo->SetHasUnknownBuffer();
    Visit( (CG_ARRAY *) pClass );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_FIXED_ARRAY *pClass )
{
    // No attributes need to be added for fixed arrays.
    Visit( (CG_ARRAY *) pClass );
}
    
//
// 
//
//   Pointers
//
//   CRITICAL NOTE: This design of this analysis assumes that no attributes
//   may propagate past pointers.  If this changes, then the entire analysis
//   code will need to be redesigned.
//
//  CG_POINTER

void CG_ILANALYSIS_VISITOR::Visit( CG_POINTER *pClass )
{

    static const ILANALYSIS_FLAGS_MASK PointerAnalysisFlags =
    {   ILANALYSIS_IN_NOTHING,        // From parent 
        ILANALYSIS_IN_EVERYTHING,     // To child
        ILANALYSIS_HAS_EVERYTHING,    // From child
        ILANALYSIS_HAS_POINTER | ILANALYSIS_HAS_FULL_BOGUS,       // To parent
    };

    PropagateInfo( &PointerAnalysisFlags );

    // CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    // Check for recursion
    if ( pRecursiveSet->Lookup( pClass ) )
        {
        if ( pClass->GetMemorySize() != pClass->GetWireSize() )
            AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );

        AddDescendantFlags( ILANALYSIS_HAS_POINTER );        
        return;
        }

    pRecursiveSet->Insert( pClass );

    ContinueAnalysis( pClass->GetChild() );

    //
    //  Misc pointer attributes
    //

    ClearDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );
    
    if ( pClass->GetMemorySize() != pClass->GetWireSize() )
        AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );

    AddDescendantFlags( ILANALYSIS_HAS_POINTER );

}


//
// 
//
//   Qualified Pointers
//
//   CRITICAL NOTE: This design of this analysis assumes that no attributes
//   may propagate past pointers.  If this changes, then the entire analysis
//   code will need to be redesigned.
//
//  CG_QUALIFIED_POINTER
//  CG_BYTE_COUNT
//  CG_LENGTH_POINTER
//  CG_INTERFACE_POINTER
//  CG_STRING_POINTER
//  CG_SIZE_POINTER
//  CG_SIZE_STRING_POINTER
//  CG_SIZE_LENGTH_POINTER
//
// Note: A qualified pointer follows the same rules as an array.   The only difference
//       is that the attributes are not propagated up past the pointer.
//
// 
//

void CG_ILANALYSIS_VISITOR::Visit( CG_QUALIFIED_POINTER *pClass )
{
    static const ILANALYSIS_FLAGS_MASK PointerAnalysisFlags =
    {   ILANALYSIS_IN_NOTHING,        // From parent 
        ILANALYSIS_IN_EVERYTHING,     // To child
        ILANALYSIS_HAS_EVERYTHING,    // From child
        ILANALYSIS_HAS_POINTER | ILANALYSIS_HAS_FULL_BOGUS,       // To parent
    };

    PropagateInfo( &PointerAnalysisFlags );

    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    // Check for recursion
    if ( pRecursiveSet->Lookup( pClass ) )
        {
        if ( pClass->GetMemorySize() != pClass->GetWireSize() )
            AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );

        AddDescendantFlags( ILANALYSIS_HAS_POINTER );        
        return;
        }

    pRecursiveSet->Insert( pClass );

    //
    // Copy Ancestor flags from context to node
    //

    AddAncestorFlags( ILANALYSIS_IN_ARRAY );

    if ( pAnalysisInfo->IsConformant() )
        AddAncestorFlags( ILANALYSIS_IN_ARRAY_CONFORMANCE );

    if ( pAnalysisInfo->IsVarying() )
        AddAncestorFlags( ILANALYSIS_IN_ARRAY_VARIANCE );

    ContinueAnalysis( pClass->GetChild() );

    //
    // Copy descendant flags from context to node
    //

    unsigned long Dimensions = GetDimensions();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY ) )
        {
        Dimensions++;
        pAnalysisInfo->SetIsMutiDimensional();
        }
    else 
        {
        Dimensions = 1;
        }

    SetDimensions( Dimensions );
    pAnalysisInfo->SetDimensions( (unsigned char) Dimensions );

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_CONFORMANCE ) )
        pAnalysisInfo->SetIsConformant();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE ) )
        pAnalysisInfo->SetIsVarying();

    if ( pAnalysisInfo->IsConformant() ||
         pAnalysisInfo->IsVarying() )
        pAnalysisInfo->SetHasUnknownBuffer();

    if (AnyDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS ) )
        pAnalysisInfo->SetIsFullBogus();
    
    if ( AnyDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS ) ||
         AnyDescendantFlags( ILANALYSIS_HAS_POINTER_ARRAY ) ||
         pAnalysisInfo->IsMultiDimensional() )
        pAnalysisInfo->SetIsForcedBogus();

    //
    // If the sized pointer has a first_is attribute that is not 0 then,
    // mark the pointer as forced bogus.
    //
    CG_VARY_ATTRIBUTE *pVaryAttribute = dynamic_cast<CG_VARY_ATTRIBUTE*>( pClass );
    if ( NULL != pVaryAttribute )
       {
       expr_node *pFirstIs = pVaryAttribute->GetFirstIsExpr();
       if ( NULL != pFirstIs )
           {
           if ( !pFirstIs->IsConstant() )
               pAnalysisInfo->SetIsForcedBogus();
           else if ( pFirstIs->GetValue() != 0 )
               pAnalysisInfo->SetIsForcedBogus();
           }
       } 
    
    //
    //  Misc pointer attributes
    //

    ClearDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );
    
    if ( pClass->GetMemorySize() != pClass->GetWireSize() )
        AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );

    AddDescendantFlags( ILANALYSIS_HAS_POINTER );

}

void CG_ILANALYSIS_VISITOR::Visit( CG_BYTE_COUNT_POINTER *pClass )
{
    Visit( (CG_QUALIFIED_POINTER*)pClass );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_LENGTH_POINTER *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsVarying();
    pAnalysisInfo->SetHasUnknownBuffer();
    Visit( (CG_QUALIFIED_POINTER*)pClass );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_INTERFACE_POINTER *pClass )
{
    Visit( (CG_QUALIFIED_POINTER*) pClass );
}
 
void CG_ILANALYSIS_VISITOR::Visit( CG_STRING_POINTER *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsVarying();    
    pAnalysisInfo->SetIsArrayofStrings();    
    pAnalysisInfo->SetHasUnknownBuffer();

    Visit( (CG_QUALIFIED_POINTER*)pClass );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_SIZE_POINTER *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsConformant();
    pAnalysisInfo->SetHasUnknownBuffer();
    Visit( (CG_QUALIFIED_POINTER*)pClass );
}
 
void CG_ILANALYSIS_VISITOR::Visit( CG_SIZE_STRING_POINTER *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsVarying();
    pAnalysisInfo->SetIsConformant();
    pAnalysisInfo->SetIsArrayofStrings();    
    pAnalysisInfo->SetHasUnknownBuffer();
    
    Visit( (CG_QUALIFIED_POINTER*)pClass );
}
 
void CG_ILANALYSIS_VISITOR::Visit( CG_SIZE_LENGTH_POINTER *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsVarying();
    pAnalysisInfo->SetIsConformant();
    pAnalysisInfo->SetHasUnknownBuffer();
    Visit( (CG_QUALIFIED_POINTER*)pClass );
}

//
// 
//
//  Fields.
//
//  CG_FIELD
//  CG_UNION_FIELD
//
//  
//

void CG_ILANALYSIS_VISITOR::Visit( CG_FIELD *pClass )
{
    PropagateInfo( &ILANALYSIS_PASS_EVERYTHING_FLAGS );    
    
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    ContinueAnalysis( pClass->GetChild() );

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_CONFORMANCE |
                             ILANALYSIS_HAS_STRUCT_CONFORMANCE ) )
        pAnalysisInfo->SetIsConformant();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE  |
                             ILANALYSIS_HAS_STRUCT_VARIANCE ) )
        pAnalysisInfo->SetIsVarying();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS ) )
        pAnalysisInfo->SetIsForcedBogus();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS ) )
        pAnalysisInfo->SetIsFullBogus();

    if ( pAnalysisInfo->IsConformant() ||
         pAnalysisInfo->IsVarying() ||
         AnyDescendantFlags( ILANALYSIS_HAS_UNKNOWN_BUFFER ) )
        pAnalysisInfo->SetHasUnknownBuffer();

}

//
// 
//
//  Union cases.
//
//  CG_CASE
//  CG_UNION_FIELD
//
//


void CG_ILANALYSIS_VISITOR::Visit( CG_CASE *pClass )
{
    PropagateInfo( &ILANALYSIS_PASS_EVERYTHING_FLAGS );

    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    ContinueAnalysis( pClass->GetChild() );

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_CONFORMANCE |
                             ILANALYSIS_HAS_STRUCT_CONFORMANCE ) )
        pAnalysisInfo->SetIsConformant();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE |
                             ILANALYSIS_HAS_STRUCT_VARIANCE ) )
        pAnalysisInfo->SetIsVarying();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS ) )
        pAnalysisInfo->SetIsForcedBogus();
    if ( AnyDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS ) )
        pAnalysisInfo->SetIsFullBogus();
    if ( AnyDescendantFlags( ILANALYSIS_HAS_UNKNOWN_BUFFER ) )
        pAnalysisInfo->SetHasUnknownBuffer();
}

//
//
//
//
//   Transform STAGE 2
//
//   The tree is modified for correctness and optimized based on information
//   from the analysis pass.
//

class CG_TRANSFORM_VISITOR 
{
private:
  CG_CLASS *pReturn;
  CG_ILCLASS_MAP *pRecursiveMap;

  CG_CLASS *DoTransform( CG_CLASS *pClass );
  CG_CLASS *DoTransform( CG_ARRAY *pClass );
  CG_CLASS *DoTransform( CG_QUALIFIED_POINTER *pClass );
  CG_CLASS *DoTransform( CG_PROC  *pProc );
  CG_CLASS *DoTransform( CG_STRUCT *pClass );
  CG_CLASS *DoTransform( CG_ENCAPSULATED_STRUCT *pClass);

  CG_CLASS *ContinueTransform( CG_CLASS *pClass );
  
  void FlushRegionList( CG_COMPLEX_STRUCT *pClass, gplistmgr *pRegionList, 
                        gplistmgr *pMemberList, unsigned long Pad );
  void RegionalizeUnknownBufferSizeSection( CG_COMPLEX_STRUCT *pClass,
                                            gplistmgr & OldMemberList,
                                            gplistmgr & NewMemberList,
                                            gplistmgr & CurrentRegionList );
  void RegionalizeStruct( CG_COMPLEX_STRUCT *pClass );
  CG_ILANALYSIS_INFO* GetAnalysisInfo( CG_CLASS *pClass ) 
      {
      return pClass->GetILAnalysisInfo(); 
      }

protected:
  CG_TRANSFORM_VISITOR() {}

public:

  // Dispatcher functions. Member templates would be great for this.
  void Visit( CG_CLASS *pClass )               { pReturn = DoTransform( pClass );}
  void Visit( CG_ARRAY *pClass )               { pReturn = DoTransform( pClass );}
  void Visit( CG_QUALIFIED_POINTER *pClass )   { pReturn = DoTransform( pClass );}
  void Visit( CG_PROC *pClass )                { pReturn = DoTransform( pClass );}
  void Visit( CG_STRUCT *pClass )              { pReturn = DoTransform( pClass );}
  void Visit( CG_ENCAPSULATED_STRUCT *pClass ) { pReturn = DoTransform( pClass );}

  static CG_CLASS* StartTransform( CG_CLASS *pClass );
};


CG_CLASS* ILTransform( CG_CLASS *pClass )
{
   return CG_TRANSFORM_VISITOR::StartTransform( pClass );
}

CG_CLASS* CG_TRANSFORM_VISITOR::StartTransform( CG_CLASS *pClass )
{
   CG_VISITOR_TEMPLATE<CG_TRANSFORM_VISITOR> TemplateVisitor;
   CG_TRANSFORM_VISITOR & Visitor = TemplateVisitor;
   CG_ILCLASS_MAP ClassMap;
   
   Visitor.pRecursiveMap = &ClassMap;
   Visitor.pReturn = NULL;

   if (NULL != pClass )
       {
       pClass->Visit( &TemplateVisitor );
       }
   
   return Visitor.pReturn;
}


CG_CLASS *CG_TRANSFORM_VISITOR::ContinueTransform( CG_CLASS *pClass )
{

   // Some classes have a NULL child.  Deal with it here.
   if ( pClass == NULL )
       return NULL;

   CG_CLASS *pNewSelfCG;
   if ( pRecursiveMap->Lookup( pClass, &pNewSelfCG ) )
      return pNewSelfCG;

   CG_VISITOR_TEMPLATE<CG_TRANSFORM_VISITOR> TemplateVisitor;
   CG_TRANSFORM_VISITOR & Visitor = TemplateVisitor;   
   Visitor.pRecursiveMap = pRecursiveMap;

   pClass->Visit( &TemplateVisitor );

   return Visitor.pReturn;
}

//
// General Catchall cases.   Members are exchanged for new versions.
// CG_CLASS
// CG_NDR
// CG_AUX
// CG_SOURCE
// CG_COCLASS
// CG_MODULE
// CG_SAFEARRAY
//
// Files
// CG_FILE
// CG_SSTUB_FILE
// CG_HDR_FILE
// CG_CSTUB_FILE
// CG_IID_FILE
// CG_NETMONSTUB_FILE
// CG_PROXY_FILE
// CG_TYPELIBRARY_FILE
//
// Interfaces
// CG_INTERFACE
// CG_OBJECT_INTERFACE
// CG_DISPINTERFACE
// CG_INHERITED_OBJECT_INTERFACE
// CG_INTERFACE_REFERENCE
// CG_IUNKNOWN_OBJECT_INTERFACE
// CG_ASYNC_HANDLE
// CG_ID
// 
// Parameters
// CG_PARAM
// CG_RETURN
// 
// BaseTypes
// CG_BASETYPE
// CG_INT3264
// CG_ENUM
// CG_HRESULT
// CG_ERROR_STATUS_T
// 
// Handles
// CG_HANDLE
// CG_PRIMITIVE_HANDLE
// CG_GENERIC_HANDLE
// CG_CONTEXT_HANDLE
//
// CG_IGNORED_POINTER
// CG_CS_TAG
//
// Fields.  
// CG_FIELD
// CG_UNION_FIELD
// 
// Union cases. 
// CG_CASE
// CG_DEFAULT_CASE
// 
// CG_UNION
//
//  CG_TYPEDEF
//  CG_TYPE_ENCODE
//  CG_PIPE
//  CG_USER_MARSHAL
//  CG_REPRESENT_AS
//  CG_TRANSMIT_AS
//
//  Unqualified pointers.
//  
CG_CLASS* CG_TRANSFORM_VISITOR::DoTransform( CG_CLASS *pClass )
{

   ITERATOR Iterator;
   CG_CLASS *pChildCG = NULL;
   CG_CLASS *pNewChildCG = NULL;

   pRecursiveMap->Insert( pClass, pClass );

   gplistmgr NewList;

   pClass->GetMembers( Iterator );

   ITERATOR_INIT( Iterator );
   while ( ITERATOR_GETNEXT( Iterator, pChildCG ) )
       {                                      
       pNewChildCG = ContinueTransform( pChildCG );
       NewList.Insert( pNewChildCG );
       }
   
   ITERATOR_INIT( NewList );
   pClass->SetMembers( NewList );

   return pClass;

}

// 
// Array derived
//

CG_CLASS *CG_TRANSFORM_VISITOR::DoTransform( CG_ARRAY *pClass )
{
    
    CG_ARRAY *pNewArray = NULL;
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    node_skl *pType = pClass->GetType();
    
    FIELD_ATTR_INFO FieldAttr;
    FieldAttr.SetSizeIs( pClass->GetSizeIsExpr() );
    FieldAttr.SetMinIs( pClass->GetMinIsExpr() );

    node_cs_char *pCsUserType = pClass->GetCSUserType();    

    CG_VARY_ATTRIBUTE *pVaryingAttribute = dynamic_cast<CG_VARY_ATTRIBUTE*>( pClass );

    if ( NULL != pVaryingAttribute )
        {
        FieldAttr.SetLengthIs( pVaryingAttribute->GetLengthIsExpr() );
        FieldAttr.SetFirstIs( pVaryingAttribute->GetFirstIsExpr() );
        }
    else 
        {
        FieldAttr.SetLengthIs( pClass->GetSizeIsExpr() );
        FieldAttr.SetFirstIs( pClass->GetMinIsExpr() );
        }

    unsigned short Dimensions = pClass->GetDimensions();
    XLAT_SIZE_INFO NewSizeInfo(pClass->GetMemoryAlignment(),
                               pClass->GetWireAlignment(),
                               pClass->GetMemorySize(),
                               pClass->GetWireSize(),
                               0,
                               0,
                               0);

    // Class is a string
    if ( ( NULL != dynamic_cast<CG_STRING_ARRAY*>( pClass ) ) ||
         ( NULL != dynamic_cast<CG_CONFORMANT_STRING_ARRAY*>( pClass ) ) ) 
        {
        if ( pAnalysisInfo->IsConformant() )
            {
            pNewArray = new CG_CONFORMANT_STRING_ARRAY( pType,
                                                        &FieldAttr,
                                                        Dimensions,
                                                        NewSizeInfo );                
            }
        else
            {
            pNewArray = new CG_STRING_ARRAY( pType,
                                             &FieldAttr,
                                             Dimensions,
                                             NewSizeInfo );
            }
        }
    
    // Class is an array
    else 
        {
        // Some form of fixed array
        if ( !pAnalysisInfo->IsConformant() && !pAnalysisInfo->IsVarying() )
            {
            if ( pAnalysisInfo->IsFullBogus() )
                pNewArray = new CG_FULL_COMPLEX_FIXED_ARRAY( pType,
                                                           &FieldAttr,
                                                           Dimensions,
                                                           NewSizeInfo );
            else if ( pAnalysisInfo->IsForcedBogus() )
                pNewArray = new CG_FORCED_COMPLEX_FIXED_ARRAY( pType,
                                                             &FieldAttr,
                                                             Dimensions,
                                                             NewSizeInfo );
            else 
                pNewArray = new CG_FIXED_ARRAY( pType,
                                                &FieldAttr,
                                                Dimensions,
                                                NewSizeInfo );
            }
        // Some form of varying array
        else if ( !pAnalysisInfo->IsConformant() && pAnalysisInfo->IsVarying() )
            {
            if ( pAnalysisInfo->IsFullBogus() )
                pNewArray = new CG_FULL_COMPLEX_VARYING_ARRAY( pType,
                                                             &FieldAttr,
                                                             Dimensions,
                                                             NewSizeInfo );
            else if ( pAnalysisInfo->IsForcedBogus() )
                pNewArray = new CG_FORCED_COMPLEX_VARYING_ARRAY( pType,
                                                               &FieldAttr,
                                                               Dimensions,
                                                               NewSizeInfo );
            else 
                pNewArray = new CG_VARYING_ARRAY( pType,
                                                  &FieldAttr,
                                                  Dimensions,
                                                  NewSizeInfo );
            }
        // Some form of conformant array
        else if ( pAnalysisInfo->IsConformant() && !pAnalysisInfo->IsVarying() )
            {
            if ( pAnalysisInfo->IsFullBogus() )
                pNewArray = new CG_FULL_COMPLEX_CONFORMANT_ARRAY( pType,
                                                                  &FieldAttr,
                                                                  Dimensions,
                                                                  NewSizeInfo );
            else if ( pAnalysisInfo->IsForcedBogus() )
                pNewArray = new CG_FORCED_COMPLEX_CONFORMANT_ARRAY( pType,
                                                                  &FieldAttr,
                                                                  Dimensions,
                                                                  NewSizeInfo );
            else 
                pNewArray = new CG_CONFORMANT_ARRAY( pType,
                                                     &FieldAttr,
                                                     Dimensions,
                                                     NewSizeInfo );
            }
        // Some form of conformant varying array
        else if ( pAnalysisInfo->IsConformant() && pAnalysisInfo->IsVarying() )
            {
            if ( pAnalysisInfo->IsFullBogus() )
                pNewArray = new CG_FULL_COMPLEX_CONFORMANT_VARYING_ARRAY( pType,
                                                                        &FieldAttr,
                                                                        Dimensions, 
                                                                        NewSizeInfo );
            else if ( pAnalysisInfo->IsForcedBogus() )
                pNewArray = new CG_FORCED_COMPLEX_CONFORMANT_VARYING_ARRAY( pType,
                                                                          &FieldAttr,
                                                                          Dimensions,
                                                                          NewSizeInfo );
            else 
                pNewArray = new CG_CONFORMANT_VARYING_ARRAY( pType,
                                                             &FieldAttr,
                                                             Dimensions,
                                                             NewSizeInfo );            
            }
        }

    *GetAnalysisInfo( pNewArray ) = *pAnalysisInfo;

    pNewArray->SetCSUserType( pCsUserType );
    pNewArray->SetPtrType( pClass->GetPtrType() );
    pRecursiveMap->Insert( pClass, pNewArray );

    CG_CLASS *pChildClass = pClass->GetChild();
    CG_CLASS *pNewChildClass = ContinueTransform( pChildClass );

    pNewArray->SetChild( pNewChildClass );

    return pNewArray;

}

//
// Qualified pointers.
//
CG_CLASS *CG_TRANSFORM_VISITOR::DoTransform( CG_QUALIFIED_POINTER *pClass )
{
    
    CG_QUALIFIED_POINTER *pNewPointer = NULL;
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    node_skl *pType = pClass->GetType();
    PTRTYPE PointerType = pClass->GetPtrType();
    short AllocationDetails = pClass->GetAllocateDetails();
    node_cs_char *pCsUserType = pClass->GetCSUserType();

    FIELD_ATTR_INFO FieldAttr;
    
    CG_CONF_ATTRIBUTE *pConfAttribute = dynamic_cast<CG_CONF_ATTRIBUTE*>( pClass );
    CG_VARY_ATTRIBUTE *pVaryingAttribute = dynamic_cast<CG_VARY_ATTRIBUTE*>( pClass );

    //
    // If the pointer does not have a conformatn attribute or a varying attribute
    // then the pointer must be a string.

    MIDL_ASSERT( (NULL != pConfAttribute ) ||
            (NULL != pVaryingAttribute ) ||
            (NULL != dynamic_cast<CG_STRING_POINTER*>( pClass ) ) );

    //
    // 1. Conformant
    if ( ( NULL != pConfAttribute ) && ( NULL == pVaryingAttribute ) )
        {
        FieldAttr.SetSizeIs( pConfAttribute->GetSizeIsExpr() );
        FieldAttr.SetMinIs( pConfAttribute->GetMinIsExpr() );
        FieldAttr.SetLengthIs( pConfAttribute->GetSizeIsExpr() );
        FieldAttr.SetFirstIs( pConfAttribute->GetMinIsExpr() );
        }

    //
    // 2. Varying
    else if ( ( NULL == pConfAttribute ) && ( NULL != pVaryingAttribute ) )
        {
        FieldAttr.SetLengthIs( pVaryingAttribute->GetLengthIsExpr() );
        FieldAttr.SetFirstIs( pVaryingAttribute->GetFirstIsExpr() );
        FieldAttr.SetSizeIs( pVaryingAttribute->GetLengthIsExpr() );
        FieldAttr.SetMinIs( pVaryingAttribute->GetFirstIsExpr() );
        }

    //
    // 3. Conformant varying
    else if ( ( NULL != pConfAttribute ) && ( NULL != pVaryingAttribute ) )
        {
        FieldAttr.SetSizeIs( pConfAttribute->GetSizeIsExpr() );
        FieldAttr.SetMinIs( pConfAttribute->GetMinIsExpr() );
        FieldAttr.SetLengthIs( pVaryingAttribute->GetLengthIsExpr() );
        FieldAttr.SetFirstIs( pVaryingAttribute->GetFirstIsExpr() );
        }

    // Class is a string
    if ( ( NULL != dynamic_cast<CG_STRING_POINTER*>( pClass ) ) ||
         ( NULL != dynamic_cast<CG_SIZE_STRING_POINTER*>( pClass ) ) ) 
        {
        if ( pAnalysisInfo->IsConformant() )
            {
            pNewPointer = new CG_SIZE_STRING_POINTER( pType,
                                                      PointerType,
                                                      AllocationDetails,
                                                      &FieldAttr );                
            }
        else
            {
            pNewPointer = new CG_STRING_POINTER( pType,
                                               PointerType,
                                               AllocationDetails );
            }
        }

    // Class is really a pointer to an array
    else 
        {
        // Some form of varying array
        if ( !pAnalysisInfo->IsConformant() && pAnalysisInfo->IsVarying() )
            {
            if ( pAnalysisInfo->IsFullBogus() )
                pNewPointer = new CG_FULL_COMPLEX_LENGTH_POINTER( pType,
                                                              PointerType,
                                                              AllocationDetails,
                                                              &FieldAttr );
            else if ( pAnalysisInfo->IsForcedBogus() )
                pNewPointer = new CG_FORCED_COMPLEX_LENGTH_POINTER( pType,
                                                                PointerType,
                                                                AllocationDetails,
                                                                &FieldAttr );
            else 
                pNewPointer = new CG_LENGTH_POINTER( pType,
                                                   PointerType,
                                                   AllocationDetails,
                                                   &FieldAttr );
            }
        // Some form of conformant array
        else if ( pAnalysisInfo->IsConformant() && !pAnalysisInfo->IsVarying() )
            {
            if ( pAnalysisInfo->IsFullBogus() )
                pNewPointer = new CG_FULL_COMPLEX_SIZE_POINTER( pType,
                                                            PointerType,
                                                            AllocationDetails,
                                                            &FieldAttr );
            else if ( pAnalysisInfo->IsForcedBogus() )
                pNewPointer = new CG_FORCED_COMPLEX_SIZE_POINTER( pType,
                                                              PointerType,
                                                              AllocationDetails,
                                                              &FieldAttr );
            else 
                pNewPointer = new CG_SIZE_POINTER( pType,
                                                 PointerType,
                                                 AllocationDetails,
                                                 &FieldAttr );
            }
        // Some form of conformant varying array
        else if ( pAnalysisInfo->IsConformant() && pAnalysisInfo->IsVarying() )
            {
            if ( pAnalysisInfo->IsFullBogus() )
                pNewPointer = new CG_FULL_COMPLEX_SIZE_LENGTH_POINTER( pType,
                                                                   PointerType,
                                                                   AllocationDetails,
                                                                   &FieldAttr );
            else if ( pAnalysisInfo->IsForcedBogus() )
                pNewPointer = new CG_FORCED_COMPLEX_SIZE_LENGTH_POINTER( pType,
                                                                     PointerType,
                                                                     AllocationDetails,
                                                                     &FieldAttr );
            else 
                pNewPointer = new CG_SIZE_LENGTH_POINTER( pType,
                                                        PointerType,
                                                        AllocationDetails,
                                                        &FieldAttr );            
            }
        else 
            {
            MIDL_ASSERT( 0 );
            }
        }

    *GetAnalysisInfo( pNewPointer ) = *pAnalysisInfo;
    pNewPointer->SetCSUserType( pCsUserType );
    pNewPointer->SetPtrType( pClass->GetPtrType() );
    pRecursiveMap->Insert( pClass, pNewPointer );

    CG_CLASS *pChildClass = pClass->GetChild();
    CG_CLASS *pNewChildClass = ContinueTransform( pChildClass );

    pNewPointer->SetChild( pNewChildClass );

    return pNewPointer;

}

//
// Proc derived.  Clone parameters and return type.
//
//  CG_PROC
//  CG_CALLBACK_PROC
//  CG_ENCODE_PROC
//  CG_IUNKNOWN_OBJECT_PROC
//  CG_LOCAL_OBJECT_PROC
//  CG_OBJECT_PROC
//  CG_INHERITIED_OBJECT_PROC
//  CG_TYPE_ENCODE_PROC


CG_CLASS* CG_TRANSFORM_VISITOR::DoTransform( CG_PROC *pClass )
   { 

   ITERATOR Iterator;
   CG_CLASS *pChildCG = NULL;
   CG_CLASS *pNewChildCG = NULL;

   pRecursiveMap->Insert( pClass, pClass );

   gplistmgr NewList;

   pClass->GetMembers( Iterator );

   ITERATOR_INIT( Iterator );
   while ( ITERATOR_GETNEXT( Iterator, pChildCG ) )
       {                                      
       pNewChildCG = ContinueTransform( pChildCG );
       NewList.Insert( pNewChildCG );
       }
   
   ITERATOR_INIT( NewList );
   pClass->SetMembers( NewList );
   
   CG_CLASS *pReturnCG = pClass->GetReturnType();

   if ( pReturnCG )
       {
       CG_RETURN *pNewReturnCG = (CG_RETURN*)ContinueTransform( pReturnCG );
       pClass->SetReturnType( pNewReturnCG );
       }
   
   return pClass;
   }

const unsigned long MAX_SIMPLE_REGION_SIZE = 0xFFFF;
const unsigned long MIN_REGION_ELEMENTS = 3;

void CG_TRANSFORM_VISITOR::FlushRegionList( CG_COMPLEX_STRUCT *pClass,
                                            gplistmgr *pRegionList,
                                            gplistmgr *pMemberList,
                                            unsigned long Pad )
{

    // Check if the region has enough elements.  
    ITERATOR_INIT( *pRegionList );
    if ( ITERATOR_GETCOUNT( *pRegionList ) < MIN_REGION_ELEMENTS )
        {
        // transfer field elements unmodied since a region will not be created in this case

        ITERATOR_INIT( *pRegionList );
        CG_FIELD *pCurrentField;
        while ( ITERATOR_GETNEXT( *pRegionList, pCurrentField ) )
            {
            pMemberList->Insert( pCurrentField );
            }

        pRegionList->Discard();
        return;
        
        }
    
    CG_REGION *pRegion;
    CG_FIELD *pCurrentField = NULL;

    XLAT_SIZE_INFO RegionInfo;

    // 
    //  1. Adjust field offsets for region
    //  2. Determine region size.
    //  3. Determine if region has any pointers
    //  

    BOOL bRegionHasPointer = FALSE;
    CG_ILANALYSIS_INFO RegionAnalysisInfo;


    ITERATOR_GETNEXT( *pRegionList, pCurrentField );
    RegionInfo.GetMemOffset()       = pCurrentField->GetMemOffset();
    RegionInfo.GetWireOffset()      = pCurrentField->GetWireOffset(); 
    RegionInfo.GetWireAlign()       = pCurrentField->GetWireAlignment();
    RegionInfo.GetMemAlign()        = pCurrentField->GetMemoryAlignment();

    ITERATOR_INIT( *pRegionList );
    CG_FIELD *pLastField = NULL;
    while ( ITERATOR_GETNEXT( *pRegionList, pCurrentField ) )
        {

        // Adjust offsets
        pCurrentField->SetMemOffset( pCurrentField->GetMemOffset()  - RegionInfo.GetMemOffset() );
        pCurrentField->SetWireOffset( pCurrentField->GetWireOffset() - RegionInfo.GetWireOffset() );
        
        // Merge attributes from field
        bRegionHasPointer = bRegionHasPointer || pCurrentField->GetChild()->IsPointer();
        RegionAnalysisInfo.MergeAttributes( GetAnalysisInfo( pCurrentField ) );

        pLastField = pCurrentField;
        }

    // Compute the size of the new region
    RegionInfo.GetMemSize()      = pLastField->GetMemOffset() + pLastField->GetMemorySize() + Pad;
    RegionInfo.GetWireSize()     = pLastField->GetWireOffset() + pLastField->GetWireSize() + Pad;
    MIDL_ASSERT( RegionInfo.GetMemSize() == RegionInfo.GetWireSize() );

    if (bRegionHasPointer || 
        (RegionInfo.GetMemSize() > MAX_SIMPLE_REGION_SIZE) )
        {
        pRegion = new CG_COMPLEX_REGION(pClass, RegionInfo, bRegionHasPointer);
        }
    else 
        {
        pRegion = new CG_SIMPLE_REGION(pClass, RegionInfo);
        }
    *GetAnalysisInfo( pRegion ) = RegionAnalysisInfo;

    ITERATOR_INIT( *pRegionList );
    pRegion->SetMembers( *pRegionList );               
    
    CG_FIELD *pNewField = new CG_FIELD(pClass->GetType(), RegionInfo);
    pNewField->SetIsRegionField();               
    pNewField->SetChild( pRegion );

    pMemberList->Insert( pNewField );

    pRegionList->Discard();

}

void CG_TRANSFORM_VISITOR::RegionalizeUnknownBufferSizeSection( CG_COMPLEX_STRUCT *pClass,
                                                                gplistmgr & OldMemberList,
                                                                gplistmgr & NewMemberList,
                                                                gplistmgr & CurrentRegionList )
{
    CG_STRUCT *pCurrentRegionHint = NULL;
    CG_FIELD *pCurrentField = NULL;

    // Caller should have flushed the region list before caller

    while( ITERATOR_GETNEXT( OldMemberList, pCurrentField ) )
        {
        
        if ( pCurrentField->GetRegionHint() == NULL )
           {
           FlushRegionList( pClass, &CurrentRegionList, &NewMemberList, 0 );
           pCurrentRegionHint = NULL;
           NewMemberList.Insert( pCurrentField );
           }
 
        else 
           {

           if ( pCurrentField->GetRegionHint() != pCurrentRegionHint )
               {
               FlushRegionList( pClass, &CurrentRegionList, &NewMemberList, 0 );
               pCurrentRegionHint = pCurrentField->GetRegionHint();
               }

           MIDL_ASSERT( !pCurrentField->GetChild()->IsStruct() );

           CurrentRegionList.Insert( pCurrentField );
           
           }
        }
        
   // Caller should flush the region list after returning.           
         
}

void CG_TRANSFORM_VISITOR::RegionalizeStruct( CG_COMPLEX_STRUCT *pClass )
{
    gplistmgr OldMemberList;
    pClass->GetMembers( OldMemberList );
    ITERATOR_INIT( OldMemberList );
    
    gplistmgr CurrentRegionList, NewMemberList;

    BOOL bAreOffsetsKnown = TRUE;
    unsigned long BufferOffset = 0; // Last known good buffer offset.  Used for padding.
    unsigned long MemoryOffset = 0; // Last known good memory offset.

    CG_FIELD *pCurrentField;    
    while( ITERATOR_GETNEXT( OldMemberList, pCurrentField ) )
        {
        CG_ILANALYSIS_INFO *pFieldAnalysisInfo = GetAnalysisInfo( pCurrentField );

        // If this is a bogus field, then it cannot be placed in the region.
        // We also do not put conformant/varying arrays in the region.
        if ( ( pCurrentField->GetMemOffset() != pCurrentField->GetWireOffset() ) ||
             pFieldAnalysisInfo->IsFullBogus() ||
             pFieldAnalysisInfo->IsForcedBogus() ||
             pFieldAnalysisInfo->HasUnknownBuffer() )
            {

            //
            // Create a region out of the region candidate list. 
            //

            unsigned long Pad = 0;

#if 0
            // BUG BUG,  MIDL doesn't compute the wire offset for a varying array
            // correctly.  Reenable this once that code is fixed.

            if ( ( pCurrentField->GetMemOffset() == pCurrentField->GetWireOffset() )  &&
                 ( BufferOffset == MemoryOffset ) )
                {

                //    The padding between this field and previous field can be
                //    added to the region list.
                Pad = pCurrentField->GetMemOffset() - MemoryOffset; 
                }
#endif

            FlushRegionList( pClass, &CurrentRegionList, &NewMemberList, Pad );

            // Do not place field in a region.
            NewMemberList.Insert( pCurrentField );

            // Calculate new memory and buffer offsets.

            if ( pFieldAnalysisInfo->HasUnknownBuffer() )
                 {
                 bAreOffsetsKnown = FALSE;
                 }
            else
                 {
                 BufferOffset = pCurrentField->GetWireOffset();
                 MemoryOffset = pCurrentField->GetMemOffset();
                 }


            }

        else
            {

            MIDL_ASSERT( pCurrentField->GetMemOffset() == pCurrentField->GetWireOffset() );
            MIDL_ASSERT( pCurrentField->GetMemorySize() == pCurrentField->GetWireSize() );

            MIDL_ASSERT( !pCurrentField->GetChild()->IsStruct() );

            CurrentRegionList.Insert( pCurrentField );

            // Update buffer and memory offsets.  
            BufferOffset = pCurrentField->GetMemOffset() + pCurrentField->GetMemorySize();
            MemoryOffset = pCurrentField->GetWireOffset() + pCurrentField->GetWireSize();
            }

        if ( !bAreOffsetsKnown )
            {
            RegionalizeUnknownBufferSizeSection( pClass,
                                                 OldMemberList,
                                                 NewMemberList,
                                                 CurrentRegionList );
            break;
            }         

        }

    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    // BUG, BUG. For now just set the pad to 0.  This means that the tail of a structure 
    // will not be placed in the region.
    FlushRegionList( pClass, &CurrentRegionList, &NewMemberList, 0 );

    ITERATOR_INIT( NewMemberList );
    pClass->SetMembers( NewMemberList );


    if ( pAnalysisInfo->IsConformant() )
        {
        CG_CLASS * pConformantField = static_cast<CG_CLASS*>( NewMemberList.GetTail() );
        MIDL_ASSERT( NULL != pConformantField );
        pClass->SetConformantField( pConformantField );
        }

}

CG_CLASS* CG_TRANSFORM_VISITOR::DoTransform( CG_STRUCT *pClass )  
{
   
   // Create the structure node first to handle recursion correctly.
   CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
   CG_STRUCT *pNewStruct = NULL;
   BOOL bIsComplex = FALSE;


   XLAT_SIZE_INFO NewSizeInfo(pClass->GetMemoryAlignment(),
                              pClass->GetWireAlignment(),
                              pClass->GetMemorySize(),
                              pClass->GetWireSize(),
                              pClass->GetZp(),
                              0,
                              0);

   // Choose the currect structure type and return
   if ( pAnalysisInfo->IsForcedBogus() || pAnalysisInfo->IsFullBogus() )
       {
       
       bIsComplex = TRUE;
       if ( pAnalysisInfo->IsFullBogus() && pAnalysisInfo->IsConformant() )
           {
           pNewStruct = new CG_CONFORMANT_FULL_COMPLEX_STRUCT ( pClass->GetType(),
                                                                NewSizeInfo,
                                                                (unsigned short)pClass->HasPointer());
           }
       else if ( pAnalysisInfo->IsFullBogus() && !pAnalysisInfo->IsConformant() )
           {
           pNewStruct = new CG_FULL_COMPLEX_STRUCT ( pClass->GetType(),
                                                       NewSizeInfo,
                                                       (unsigned short)pClass->HasPointer());

           }

       else if ( pAnalysisInfo->IsForcedBogus() && pAnalysisInfo->IsConformant() )
           {
           pNewStruct = new CG_CONFORMANT_FORCED_COMPLEX_STRUCT ( pClass->GetType(),
                                                                NewSizeInfo,
                                                                (unsigned short)pClass->HasPointer());
           }
       else if ( pAnalysisInfo->IsForcedBogus() && !pAnalysisInfo->IsConformant() )
           {
           pNewStruct = new CG_FORCED_COMPLEX_STRUCT ( pClass->GetType(),
                                                       NewSizeInfo,
                                                       (unsigned short)pClass->HasPointer());

           }
       }
       
   else if (!pAnalysisInfo->IsVarying() && !pAnalysisInfo->IsConformant() )
       {
       pNewStruct = new CG_STRUCT( pClass->GetType(),
                                   NewSizeInfo,
                                   (unsigned short)pClass->HasPointer());       
       }
   else if (pAnalysisInfo->IsConformant() && pAnalysisInfo->IsVarying())
       {
       pNewStruct = new CG_CONFORMANT_VARYING_STRUCT( pClass->GetType(),
                                                      NewSizeInfo,
                                                      (unsigned short)pClass->HasPointer(),
                                                      NULL );       
       }
   else if (pAnalysisInfo->IsConformant() && !pAnalysisInfo->IsVarying())
       {
       pNewStruct = new CG_CONFORMANT_STRUCT( pClass->GetType(),
                                              NewSizeInfo,
                                              (unsigned short)pClass->HasPointer(),
                                              NULL );
       }
   else // !IsConformant && IsVariant( should be bogus )
       MIDL_ASSERT(0);

   *(GetAnalysisInfo( pNewStruct ) ) = *pAnalysisInfo;

   pRecursiveMap->Insert( pClass, pNewStruct );

   gplistmgr NewList;

   CG_ITERATOR Iterator;
   CG_CLASS *pChildCG = NULL;
   CG_CLASS *pNewChildCG = NULL;
   
   pClass->GetMembers( Iterator );

   ITERATOR_INIT( Iterator );
   while ( ITERATOR_GETNEXT( Iterator, pChildCG ) )
       {                                      
       pNewChildCG = ContinueTransform( pChildCG );
       NewList.Insert( pNewChildCG );
       }
   
   ITERATOR_INIT( NewList );
   pNewStruct->SetMembers( NewList );

   CG_UNROLLED_LIST UnrolledList;
   ILUnroll( pClass, &UnrolledList ); 

   ITERATOR_INIT( UnrolledList );

   // If the first field is a pad field, and the field has the same Alignments as this structure
   // delete the pad since it is redundant.
   CG_FIELD *pFirstField = (CG_FIELD*)UnrolledList.GetHead();
   CG_PAD *pPad = dynamic_cast<CG_PAD*>( pFirstField->GetChild() );

   if ( ( NULL != pPad) &&
        ( pFirstField->GetMemOffset() == 0 ) &&
        ( pFirstField->GetWireOffset() == 0 ) &&
        ( pPad->GetMemorySize() == 0 ) &&
        ( pPad->GetWireSize() == 0 ) &&
        ( pPad->GetMemoryAlignment() == pClass->GetMemoryAlignment() ) &&
        ( pPad->GetWireAlignment() == pClass->GetWireAlignment() ) )
       {
       UnrolledList.RemoveHead();
       }

   pNewStruct->SetMembers( UnrolledList );

   if ( pAnalysisInfo->IsConformant() )
       {
       CG_CLASS *pConformatField = static_cast<CG_CLASS*>( UnrolledList.GetTail() );
       dynamic_cast<CG_CONFORMANT_STRUCT*>( pNewStruct )->SetConformantField( pConformatField );
       }

   if (bIsComplex)
       {
       RegionalizeStruct( dynamic_cast<CG_COMPLEX_STRUCT*>( pNewStruct ) ); 
       }

   return pNewStruct;
}

// An encapsulated struct is really a union, so don't treat it like a struct.
CG_CLASS* CG_TRANSFORM_VISITOR::DoTransform( CG_ENCAPSULATED_STRUCT *pClass )
{
   return DoTransform( (CG_CLASS*) pClass );
}

// 
//
//   Unrolling code.
// 
//
//   Note, if recursion occures it must be through a struct or union.
//   Structures, fields, arrays, and pointers are cloned.  

class CG_UNROLL_VISITOR 
{
private:
  CG_UNROLLED_LIST *pParentList;
  BOOL bInPointerOrArray;

  CG_ILANALYSIS_INFO* GetAnalysisInfo( CG_CLASS *pClass ) {return pClass->GetILAnalysisInfo(); }

  void ContinueUnroll( CG_CLASS *pClass, CG_UNROLLED_LIST *pUnrolledList, 
                       BOOL bInPointerOrArray );
public:
  
  void Visit( CG_CLASS  *pClass );
  void Visit( CG_STRUCT *pClass );
  void Visit( CG_ENCAPSULATED_STRUCT *pClass );
  void Visit( CG_UNION *pClass );
  void Visit( CG_FIELD *pClass );
  void Visit( CG_POINTER *pClass );
  void Visit( CG_ARRAY *pClass );

  static void StartUnroll( CG_CLASS *pClass, CG_UNROLLED_LIST *pUnrolledList );
};

void ILUnroll( CG_CLASS *pClass, CG_UNROLLED_LIST *pList )
{
   CG_UNROLL_VISITOR::StartUnroll( pClass, pList );
}

void CG_UNROLL_VISITOR::ContinueUnroll( CG_CLASS *pClass, CG_UNROLLED_LIST *pParentList, 
                                        BOOL bInPointerOrArray )
{
    if ( NULL != pClass )
        {
        CG_VISITOR_TEMPLATE< CG_UNROLL_VISITOR > TemplateVisitor;
        CG_UNROLL_VISITOR & Visitor = TemplateVisitor;
        
        Visitor.pParentList         = pParentList;
        Visitor.bInPointerOrArray   = bInPointerOrArray;
    
        pClass->Visit( &TemplateVisitor );
        }
}

void CG_UNROLL_VISITOR::StartUnroll( CG_CLASS *pClass, CG_UNROLLED_LIST *pUnrolledList )
{
   CG_VISITOR_TEMPLATE< CG_UNROLL_VISITOR > TemplateVisitor;
   CG_UNROLL_VISITOR & Visitor = TemplateVisitor;
   
   Visitor.pParentList          = pUnrolledList;
   Visitor.bInPointerOrArray    = FALSE;

   if ( NULL != pClass )
       {
       pClass->Visit( &TemplateVisitor );
       }  

}

void CG_UNROLL_VISITOR::Visit( CG_CLASS *pClass )
{
    // Do not unroll random nodes in the tree.
    pParentList->Insert( pClass );
}

void CG_UNROLL_VISITOR::Visit( CG_STRUCT *pClass )
{ 
        
    if ( bInPointerOrArray )
        {
        pParentList->Insert( pClass );
        return;        
        }
    
    CG_UNROLLED_LIST UnrolledList;
    CG_ITERATOR Iterator;
    CG_FIELD *pField;    
    pClass->GetMembers( Iterator );
    
    // Get the first field of the structure, and if the first field has an aligment requirement
    // that is different from structure, add a pad field.

    ITERATOR_INIT( Iterator );
    BOOL HasField = (BOOL)ITERATOR_GETNEXT( Iterator, pField);
        
    if ( !HasField ||
         ( pField->GetWireAlignment() != pClass->GetWireAlignment() ) )
         {

         // Create a pad field for the start of the list
        
         XLAT_SIZE_INFO Info( pClass->GetMemoryAlignment(),
                              pClass->GetWireAlignment(),
                              0, // Memory size
                              0, // Wire size
                              pClass->GetZp(),
                              0, // MemOffset
                              0 // WireOffset
                              );
     
         CG_FIELD *pPadField = new CG_FIELD( pClass->GetType(), Info );
         CG_PAD *pPadItem = new CG_PAD( pClass->GetType(), Info );
         pPadField->SetChild( pPadItem );

         UnrolledList.Insert( pPadField );

         }



    ITERATOR_INIT( Iterator );
    while( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        ContinueUnroll( pField, &UnrolledList, bInPointerOrArray );
        }

    // If this was a simple struct, set the region hint
    // to make the region code more efficient. 
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    BOOL bIsSimpleStruct = !pAnalysisInfo->IsConformant() &&
                           !pAnalysisInfo->IsVarying() &&
                           !pAnalysisInfo->IsFullBogus() &&
                           !pAnalysisInfo->IsForcedBogus();

    if ( bIsSimpleStruct )
        {
        ITERATOR_INIT( UnrolledList );
        while( ITERATOR_GETNEXT( UnrolledList, pField ) ) 
            pField->SetRegionHint( pClass );
        
        ITERATOR_INIT( UnrolledList );        
        }

    pParentList->MergeToTail( &UnrolledList,
                              FALSE ); // Do not delete stack allocated list 
}

void CG_UNROLL_VISITOR::Visit( CG_ENCAPSULATED_STRUCT *pClass )
{
    // Do not unroll encapsulated unions.  
    
    pParentList->Insert( pClass );

}

void CG_UNROLL_VISITOR::Visit( CG_UNION *pClass )
{
    // Unions cannot have sized pointers or arrays, but the union needs to be cloned
    // since the switch expression may be correlated with a different variable.

    CG_UNION *pNewClass = (CG_UNION*)pClass->Clone();
    pParentList->Insert(pNewClass);
}

void CG_UNROLL_VISITOR::Visit( CG_FIELD *pClass )
{
    CG_UNROLLED_LIST UnrolledList;

    ContinueUnroll( pClass->GetChild(), &UnrolledList, bInPointerOrArray );
    
    // We had to have unrolled a structure to get here
        
    ITERATOR_INIT( UnrolledList );
    CG_CLASS *pChild;

    while( ITERATOR_GETNEXT( UnrolledList, pChild ) )
        {
        CG_FIELD *pField = dynamic_cast<CG_FIELD*>( pChild );
          if ( !pField )
            {
            // The child is not a field, so no offset calculation
            // needs to be done.  Just clone yourself and insert to into the list.

            CG_FIELD *pNewField = ( CG_FIELD *) pClass->Clone();
            *GetAnalysisInfo( pNewField ) = *GetAnalysisInfo( pClass );
            pNewField->SetChild( pChild );
            pParentList->Insert( pNewField );
            }
        
        else 
            {

            // We you arn't unrolling a region, append this field's 
            // name to the unrolled field.

            if ( !pClass->IsRegionField() )
                pField->AddPrintPrefix( pClass->GetSymName() );

            // The child is a field, so adjust the offset and append the print prefix.  

            pField->SetMemOffset( pClass->GetMemOffset() + pField->GetMemOffset() );      
            pField->SetWireOffset( pClass->GetWireOffset() + pField->GetWireOffset() );

            pParentList->Insert( pField );
            }
        }
}

void CG_UNROLL_VISITOR::Visit( CG_POINTER *pClass )
{

    CG_CLASS *pNewClass = pClass->Clone();
    *GetAnalysisInfo(pNewClass) = *GetAnalysisInfo(pClass);

    CG_UNROLLED_LIST UnrolledList;

    // We stop unrolling at this point, and switch to cloning.
    // That means that the items in the list are actual items instead 
    // of structure fields.  Since we're not unrolling anymore, we can
    // only have a single child.  Note that some pointers such as interface
    // pointers do not have a child.

    ContinueUnroll( pClass->GetChild(),  &UnrolledList, TRUE );

    MIDL_ASSERT( ( ITERATOR_GETCOUNT( UnrolledList ) == 1 ) ||
		    ( ITERATOR_GETCOUNT( UnrolledList ) == 0 ) );

    ITERATOR_INIT( UnrolledList );
    pNewClass->SetMembers( UnrolledList );

    // We are in deep trouble if our child is a field! 
    MIDL_ASSERT( dynamic_cast<CG_FIELD*>( pClass->GetChild() ) == NULL );

    pParentList->Insert( pNewClass );

}

void CG_UNROLL_VISITOR::Visit( CG_ARRAY *pClass )
{
    
    CG_CLASS *pNewClass = pClass->Clone();
    *GetAnalysisInfo(pNewClass) = *GetAnalysisInfo(pClass);

    CG_UNROLLED_LIST UnrolledList;
    
    // We stop unrolling at this point, and switch to cloning.
    // That means that the items in the list are actual items instead 
    // of structure fields.  Since we're not unrolling anymore, we can
    // only have a single child. 

    ContinueUnroll( pClass->GetChild(), &UnrolledList, TRUE );

    MIDL_ASSERT( ITERATOR_GETCOUNT( UnrolledList ) == 1 );

    ITERATOR_INIT( UnrolledList );
    pNewClass->SetMembers( UnrolledList );

    // We are in deep trouble if our child is a field! 
    MIDL_ASSERT( dynamic_cast<CG_FIELD*>( pClass->GetChild() ) == NULL );

    pParentList->Insert( pNewClass );
}

//
// Master control for this stage
//

CG_CLASS* ILSecondGenTransform( CG_CLASS *pClass )
{
    CG_ILANALYSIS_VISITOR::StartAnalysis( pClass );
    CG_CLASS *pResult = CG_TRANSFORM_VISITOR::StartTransform( pClass );

    return pResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\ilcore.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

    ilcore.cxx

 Abstract:

    Intermediate Language translator for core typegraph

 Notes:


 Author:

    GregJen Dec-24-1993     Created.

 Notes:


 ----------------------------------------------------------------------------*/

 /****************************************************************************
 *      include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

#include "ilxlat.hxx"
#include "ilreg.hxx"


/****************************************************************************
 *      local data
 ***************************************************************************/


/****************************************************************************
 *      externs
 ***************************************************************************/

extern CMD_ARG    * pCommand;
extern BOOL         IsTempName( char *);
extern REUSE_DICT * pReUseDict;

/****************************************************************************
 *      definitions
 ***************************************************************************/




// #define trace_cg

//--------------------------------------------------------------------
//
// node_href::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_href::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_href,\t%s\n", GetSymName());
#endif
    if ( !GetChild() )
        {
        named_node * pRef = Resolve();
        if ( !pRef )
            {
            SemError( this, *pContext, UNSATISFIED_HREF, GetSymName() );
            exit( UNSATISFIED_HREF );
            }
        }
    return GetChild()->ILxlate( pContext );
}

//--------------------------------------------------------------------
//
// node_forward::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_forward::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_forward,\t%s\n", GetSymName());
#endif
    // MIDL_ASSERT( GetChild() && "unsatisfied node_forward encountered" );

    node_skl* pChild = GetChild();
    // forward interface definitions return null
    if ( ( pContext->GetParent()->IsInterfaceOrObject() ) &&
            ( pChild->NodeKind() == NODE_INTERFACE_REFERENCE ) )
        return NULL;

    if ( pChild )
        {
        // pass it on to the child...
        return pChild->ILxlate( pContext );
        }
    else
        {
        // try again
        pChild = ResolveFDecl();
        if ( pChild )
            {
            // pass it on to the child...
            return pChild->ILxlate( pContext );
            }
        else
            {
            SemError( this, *pContext, UNSATISFIED_FORWARD, GetSymName() );
            exit( UNSATISFIED_FORWARD );
            }
        }

};

//--------------------------------------------------------------------
//
// node_id::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_id::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_id,\t%s\n", GetSymName());
#endif

    XLAT_CTXT   MyContext( this, pContext );
    CG_CLASS  * pCG;

    MyContext.ExtractAttribute(ATTR_ID);
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRING);
    MyContext.ExtractAttribute(ATTR_HIDDEN);

    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
    pCG = GetChild()->ILxlate( &MyContext );

    if (NODE_MODULE == pContext->GetParent()->NodeKind())
        {
        CG_ID * pID = new CG_ID (this, MyContext);
        pID->SetChild(pCG);
        pCG = pID;
        }

    pContext->ReturnSize( MyContext );

    return pCG;

};


//--------------------------------------------------------------------
//
// node_field::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_field::ILxlate( XLAT_CTXT * pContext )
{

    CG_NDR       *  pCG;
    CG_CLASS     *  pChildCG;
    XLAT_CTXT       MyContext( this, pContext );
    BOOL            fUnionField;
    CG_CASE      *  pFirstCase;
    CG_CASE      *  pCurCase;
    expr_node    *  pSwitchExpr = NULL;
    node_su_base *  pParent     = (node_su_base *)pContext->GetParent();
    BOOL            fConfFld    = FALSE;

    MyContext.ExtractAttribute(ATTR_ID);
    MyContext.ExtractAttribute(ATTR_IDLDESCATTR);
    MyContext.ExtractAttribute(ATTR_VARDESCATTR);
    MyContext.ExtractAttribute(ATTR_HELPSTRING);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HIDDEN);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    while (MyContext.ExtractAttribute(ATTR_MEMBER));

#ifdef trace_cg
    printf("..node_field,\t%s\n", GetSymName());
#endif

    if ( ( fUnionField = ( MyContext.FInSummary( ATTR_CASE ) ||
            MyContext.FInSummary( ATTR_DEFAULT ) ) ) != 0 )
        {
        CG_CASE   * pPrevCase = NULL;
        node_case * pCaseAttr;
        expr_list * pExprList;
        expr_node * pExpr;

        pCG = new CG_UNION_FIELD( this, MyContext );

        // for each case attribute, make a CG_CASE for each expr in the attr
        while ( ( pCaseAttr = (node_case *) MyContext.ExtractAttribute( ATTR_CASE ) ) != 0 )
            {
            pExprList = pCaseAttr->GetExprList();
            pExprList->Init();
            while ( pExprList->GetPeer( &pExpr ) == STATUS_OK )
                {
                pCurCase = new CG_CASE( this, pExpr );
                pCurCase->SetChild( pCG );
                if ( pPrevCase )
                    pPrevCase->SetSibling( pCurCase );
                else
                    pFirstCase = pCurCase;
                pPrevCase = pCurCase;
                }
            }

        // now process the default, if any
        if ( MyContext.ExtractAttribute( ATTR_DEFAULT ) )
            {
            pCurCase = new CG_DEFAULT_CASE( this );
            pCurCase->SetChild( pCG );
            if ( pPrevCase )
                pPrevCase->SetSibling( pCurCase );
            else
                pFirstCase = pCurCase;
            pPrevCase = pCurCase;
            }

        // mark the last case for this arm
        pCurCase->SetLastCase( TRUE );
        }

    // if we have a switch_is expr, fetch it..
    if ( MyContext.FInSummary( ATTR_SWITCH_IS ) )
        {
        node_switch_is * pAttr;
        if ( pCommand->IsNDR64Run() )
            {
            pAttr = (node_switch_is*)MyContext.GetAttribute( ATTR_SWITCH_IS );
            }
        else 
            {
            pAttr = (node_switch_is*)MyContext.ExtractAttribute( ATTR_SWITCH_IS );
            }
        pSwitchExpr = pAttr->GetExpr();
        }

    // process the child of the field
    pChildCG = GetChild()->ILxlate( &MyContext );

    // can't use attribute list after here...

    MyContext.AdjustForZP();            // fix up alignments for current ZP
    MyContext.GetOffset( *pContext );   // offset in parent struct/union

    node_skl * pBasic  = GetBasicType();

    // If this is NDR64, treat conformant fields the same
    // as nonconformant fields since conformant arrays
    // have an alignment even is they have 0 elements.
    if ( !pCommand->IsNDR64Run() &&
         pParent->HasConformance() &&
            IsLastField() &&
            ( pBasic->NodeKind() != NODE_STRUCT ) &&
            !fUnionField)               // if I'm a conf. field
        {
        fConfFld = TRUE;
        MyContext.AlignConfOffset();    // round mem, not wire up to alignment
        }
    else if ( pBasic->IsEncapsulatedStruct() ||
            ( pBasic->NodeKind() == NODE_UNION ) )
        {
        MyContext.AlignEmbeddedUnion();
        }
    else
        {
        MyContext.AlignOffset();    // round up to alignment
        }

    CG_FIELD *pField = NULL;

    if (fUnionField )
        {
        pCG->SetChild( pChildCG );
        pCG = pFirstCase;
        pField = (CG_FIELD *) pCG->GetChild();
        MIDL_ASSERT( ID_CG_UNION_FIELD == pField->GetCGID() );
        pContext->ReturnUnionSize( MyContext ); // return size and alignment
        }
    else
        {
        pField = new CG_FIELD( this, MyContext );
        pField->SetChild( pChildCG );
        pField->SetSwitchExpr( pSwitchExpr );
        pCG = pField;
        pContext->ReturnOffset( MyContext );    // return rounded-up offset

        // Treat conformant fields the same as non-conformant fields in Ndr64.
        // The wire-size and wire_offset should be 0 though.
        if ( !pCommand->IsNDR64Run() && fConfFld )
            pContext->ReturnConfSize( MyContext );  // don't munge wire size!
        else
            pContext->ReturnSize( MyContext );  // return size and alignment
        }

    if ( HasUnknownRepAs() )
        pField->SetHasEmbeddedUnknownRepAs();

    if ( fConfFld )
        {
        pCG->SetMemorySize( 0 );
        pCG->SetWireSize( 0 );
        }
    return pCG;
};

//--------------------------------------------------------------------
//
// node_bitfield::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_bitfield::ILxlate( XLAT_CTXT* pContext )
{
#ifdef trace_cg
    printf("..node_bitfield,\t%s\n", GetSymName());
#endif

    XLAT_CTXT       MyContext( this, pContext );

    SemError( this, MyContext, FAILED_TO_GENERATE_BIT_FIELD, GetSymName() );

    return NULL;
};

//--------------------------------------------------------------------
//
// node_enum::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_enum::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_enum,\t%s\n", GetSymName());
#endif

    XLAT_CTXT       MyContext( this, pContext );
    node_range_attr* pRange = (node_range_attr*) MyContext.ExtractAttribute(ATTR_RANGE);
    node_base_attr  *pV1enum = MyContext.ExtractAttribute( ATTR_V1_ENUM );

    pContext->ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.EnumTypeSizes (
                            this,
                            // All enums are 32bit on wire in new syntax.
                            pCommand->IsNDR64Run() || pV1enum
                            );
    
    CG_ENUM *   pCG = new CG_ENUM( this, MyContext );

    if ( pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
        {
        pCG->SetRangeAttribute( pRange );
        }

    pContext->ReturnSize( MyContext );
    
    return pCG;

};

//--------------------------------------------------------------------
//
// node_struct::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_struct::ILxlate( XLAT_CTXT * pContext )
{

    MEM_ITER        MemIter( this );
    node_field  *   pN;
    CG_STRUCT   *   pCG;
    CG_CLASS    *   pChildCG        = NULL;
    CG_CLASS    *   pPrevChildCG    = NULL;
    CG_CLASS    *   pFirstChildCG   = NULL;
    XLAT_CTXT       MyContext( this, pContext );
    REUSE_INFO  *   pSaved;
    BOOL fHasMovedFields = FALSE;   // has fields with diff mem/wire offsets
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute(ATTR_HIDDEN);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
#ifdef trace_cg
    printf("..node_struct,\t%s\n", GetSymName());
#endif

    MyContext.ExtractAttribute( ATTR_STRING );

    // raw rpc doesn't care about uuid's on structs, typelibs get a new context
    // during GetTypeInfo.
    MyContext.ExtractAttribute(ATTR_GUID);
  
    // process any context_handle attributes from param nodes
    if ( MyContext.ExtractAttribute( ATTR_CONTEXT ) )
        {
        CG_NDR * pChildCG;

        MyContext.ContextHandleSizes( this );
        pContext->ReturnSize( MyContext );
		pChildCG = new CG_CONTEXT_HANDLE (
                                    this,
                                    0,
                                    MyContext
                                    );
        return pChildCG;
        }
    
    // clear member attributes
    while (MyContext.ExtractAttribute(ATTR_MEMBER));

    // at this point, there should be no more attributes...

    MIDL_ASSERT( !MyContext.HasAttributes() );

    // store our own zp value for below

    MyContext.GetZeePee() = GetZeePee();

    // see if we were already generated
    if ( pReUseDict->GetReUseEntry( pSaved, this ) )
        {
        // reuse found...
        pSaved->FetchInfo( &MyContext, pChildCG );
        pContext->ReturnSize( MyContext );
        return pChildCG;
        }
        
    // manufature the CG node (to allow for recursion)
    switch (Complexity)
        {
        case FLD_PLAIN:
            {
            pCG = new CG_STRUCT( this,
                                 MyContext,
                                 HasAtLeastOnePointer()
                                 );
            break;
            }
        case FLD_CONF:
            {
            pCG = new CG_CONFORMANT_STRUCT( this,
                                            MyContext,
                                            HasAtLeastOnePointer(),
                                            NULL
                                            );
            break;
            }
        case FLD_CONF_VAR:
            {
            pCG = new CG_CONFORMANT_VARYING_STRUCT( this,
                                                    MyContext,
                                                    HasAtLeastOnePointer(),
                                                    NULL
                                                    );
            break;
            }
        case FLD_VAR:
        default:
            {
            pCG = new CG_COMPLEX_STRUCT( this,
                                         MyContext,
                                         HasAtLeastOnePointer(),
                                         NULL
                                         );
            break;
            }
        }

    // save our CG node so that recursive use can find it
    pSaved->SaveInfo( &MyContext, pCG);

    //
    // for each of the fields, call the core transformer.
    //

    while ( ( pN = (node_field *) MemIter.GetNext() ) != 0  )
        {
        pChildCG = pN->ILxlate( &MyContext );

        // adjust the size and current offset of the struct, special
        // case the conformant field ( last one )
        //
        // Except if this is the new transfer syntax.   In that case
        // the wire has a pad to the array even if the array has 0
        // elements.  This allows a case like this to be simple instead
        // of complex.
        //
        // struct MyStruct {
        //    char s;
        //    [size_is(s)] long s[];
        // };
        //

        if ( !pCommand->IsNDR64Run() &&
             ( fHasConformance &&
                   !pN->GetSibling() &&
                   ( pN->GetBasicType()->NodeKind() != NODE_STRUCT ) ) )
            {
            MyContext.AdjustConfSize();
            }
        else
            {
            MyContext.AdjustSize();
            }

        if ( !MyContext.SameOffsets() )
            fHasMovedFields = TRUE;

        // Add the field to the list of fields if it's available
        // pChildCG might be NULL if it's imported from .tlb and being 
        // processed earlier.
        if ( pChildCG )
            {
            if( pPrevChildCG )
                {
                pPrevChildCG->SetSibling( pChildCG );
                }
            else
                {
                pFirstChildCG = pChildCG;
                };

            pPrevChildCG = pChildCG;
            }
            else
                SemError( this, MyContext, FAILED_TO_GENERATE_FIELD, GetSymName() );

        // get the type of the field to determine kind of struct
        }

    // conformant structs don't get trailing padding
    if ( !fHasConformance )
        // The new transfer syntax pads the wire size for structures to the 
        // the new wire alignment.
        if ( pCommand->IsNDR64Run() )
            {
            MyContext.Ndr64AdjustTotalStructSize();
            }
        else 
            {
            MyContext.AdjustTotalSize();
            }

    pContext->ReturnSize( MyContext );

    pCG->SetChild( pFirstChildCG );

    // Sizes aren't determined until after the fields have been made, 
    // so we have to set them manually. For the same reason, i.e. because of
    // invalid recursive definitions, we check the memory size here.

    pCG->SetSizesAndAlignments( MyContext );

    if ( pCommand->IsNDR64Run() )
        {

        if ( pCG->GetMemorySize() >= SIZE_2GB )
            {
            SemError( this, MyContext, SIZE_EXCEEDS_2GB, NULL );
            exit( SIZE_EXCEEDS_2GB );
            }
        }
    else if ( pCG->GetMemorySize() > 65535 )
        {
        SemError( this, MyContext, STRUCT_SIZE_EXCEEDS_64K, NULL );
        exit( STRUCT_SIZE_EXCEEDS_64K );
        }

    // this picks up whatever is the last field...
    if ( fHasConformance )
        ((CG_CONFORMANT_STRUCT *) pCG)->SetConformantField( pChildCG );

    if ( fHasMovedFields )
        {
        pCG->SetHasMovedFields();
        }

    pSaved->SaveInfo( &MyContext, pCG);

    return pCG;
};

//--------------------------------------------------------------------
//
// node_en_struct::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_en_struct::ILxlate( XLAT_CTXT * pContext )
{
    MEM_ITER        MemIter( this );
    node_skl    *   pN;
    CG_STRUCT   *   pCG;
    CG_CLASS    *   pChildCG        = NULL;
    CG_CLASS    *   pPrevChildCG    = NULL;
    CG_CLASS    *   pFirstChildCG   = NULL;
    XLAT_CTXT       MyContext( this, pContext );
    REUSE_INFO  *   pSaved;

#ifdef trace_cg
    printf("..node_en_struct,\t%s\n", GetSymName());
#endif


    // store our own zp value for below

    MyContext.GetZeePee() = GetZeePee();
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
    // raw rpc doesn't care about uuid's on structs, typelibs get a new context
    // during GetTypeInfo.
    MyContext.ExtractAttribute(ATTR_GUID);

    // process any context_handle attributes from param nodes
    if ( MyContext.ExtractAttribute( ATTR_CONTEXT ) )
        {
        CG_HANDLE * pHdlCG;

        MyContext.ContextHandleSizes( this );
        pContext->ReturnSize( MyContext );
		pHdlCG = new CG_CONTEXT_HANDLE (
                                    this,
                                    0,
                                    MyContext
                                    );
        return pHdlCG;
        }

    // at this point, there should be no more attributes...

    MIDL_ASSERT( !MyContext.HasAttributes() );

    if ( pReUseDict->GetReUseEntry( pSaved, this ) )
        {
        // reuse found...
        pSaved->FetchInfo( &MyContext, pChildCG );
        pContext->ReturnSize( MyContext );
        return pChildCG;
        }

    // manufature the CG node (to allow for recursion)
    pCG = new CG_ENCAPSULATED_STRUCT( this,
                                      MyContext,
                                      HasAtLeastOnePointer()
                                      );

    // set that struct is encapsulated
    // pCG->SetIsEncapsulated();

    // save our CG node so that recursive use can find it
    pSaved->SaveInfo( &MyContext, pCG);

    //
    // for each of the fields, call the core transformer.
    //

    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        pChildCG = pN->ILxlate( &MyContext );
        MyContext.AdjustSize();

        if (pChildCG)
            {
            if( pPrevChildCG )
                {
                pPrevChildCG->SetSibling( pChildCG );
                }
            else
                {
                pFirstChildCG = pChildCG;
                };

            pPrevChildCG = pChildCG;
            }
        else
            SemError( this, MyContext, FAILED_TO_GENERATE_FIELD, GetSymName() );
        }

    MyContext.AdjustTotalSize();
    pContext->ReturnSize( MyContext );


    pCG->SetChild( pFirstChildCG );

    // set sizes manually, since they weren't known at constructor time.

    pCG->SetSizesAndAlignments( MyContext );

    if ( pCommand->IsNDR64Run() )
    {
        if ( pCG->GetMemorySize() >= SIZE_2GB )
            {
            SemError( this, MyContext, SIZE_EXCEEDS_2GB, NULL );
            exit( SIZE_EXCEEDS_2GB );
            }
    }
    else if ( pCG->GetMemorySize() > 65535 )
        {
        SemError( this, MyContext, STRUCT_SIZE_EXCEEDS_64K, NULL );
        exit( STRUCT_SIZE_EXCEEDS_64K );
        }

    pSaved->SaveInfo( &MyContext, pCG);

    return pCG;
};

//--------------------------------------------------------------------
//
// node_union::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_union::ILxlate( XLAT_CTXT * pContext )
{
    XLAT_CTXT               MyContext( this, pContext );
    MEM_ITER                MemIter( this );
    CG_CASE             *   pCurCaseCG;
    CG_CASE             *   pFirstCaseCG    = NULL;
    CG_CASE             *   pLastCaseCG     = NULL;
    CG_UNION            *   pUnionCG;
    node_field          *   pCurField;
    REUSE_INFO          *   pSaved;
    BOOL                    fMSUnion;
    BOOL                    fEncap          = IsEncapsulatedUnion();
    node_switch_type    *   pSwTypeAttr     = ( node_switch_type *)
                                                MyContext.ExtractAttribute( ATTR_SWITCH_TYPE );
    node_switch_is      *   pSwIsAttr       = NULL;
            
    node_skl            *   pReuseKey       = this;

    if ( pCommand->IsNDR64Run() )
        {
        pSwIsAttr = (node_switch_is *)MyContext.ExtractAttribute( ATTR_SWITCH_IS );

        if ( !fEncap )
            {
            pReuseKey = (node_skl*)pSwIsAttr;
            }
        }

    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
#ifdef trace_cg
    printf("..node_union,\t%s\n", GetSymName());
#endif
    // process any context_handle attributes from param nodes
    if ( MyContext.ExtractAttribute( ATTR_CONTEXT ) )
        {
        CG_NDR * pChildCG;

        MyContext.ContextHandleSizes( this );
        pContext->ReturnSize( MyContext );
		pChildCG = new CG_CONTEXT_HANDLE (
                                    this,
                                    0,
                                    MyContext
                                    );
        return pChildCG;
        }


    // decide if we are a MS union or a DCE union
    fMSUnion = (NULL != MyContext.ExtractAttribute( ATTR_MS_UNION ));

    fMSUnion = fMSUnion ||
               GetMyInterfaceNode()->FInSummary( ATTR_MS_UNION ) ||
               pCommand->IsSwitchDefined( SWITCH_MS_UNION );

    fMSUnion = fMSUnion && !fEncap;

    // store our own zp value for below

    MyContext.GetZeePee() = GetZeePee();

    if ( pReUseDict->GetReUseEntry( pSaved, pReuseKey ) )
        {
        CG_CLASS * pCG;

        // reuse found...
        pSaved->FetchInfo( &MyContext, pCG );
        pContext->ReturnSize( MyContext );
        return pCG;
        }

    pUnionCG = new CG_UNION( this,
                             MyContext,
                             HasAtLeastOnePointer()
                             );

    // save our CG node so that recursive use can find it
    pSaved->SaveInfo( &MyContext, pUnionCG);

    // process the union arms
    while ( ( pCurField = (node_field *) MemIter.GetNext() ) != 0 )
        {
        pCurCaseCG = (CG_CASE *) pCurField->ILxlate( &MyContext );
//      MyContext.AdjustSize();

        // add all the cases for the given field to the list

        if( pLastCaseCG )
            {
            pLastCaseCG->SetSibling( pCurCaseCG );
            }
        else
            {
            pFirstCaseCG = pCurCaseCG;
            };

        // advance pLastCaseCG to the end of the list
        pLastCaseCG = pCurCaseCG;
        MIDL_ASSERT( pLastCaseCG && "Null case list" );

        while ( pLastCaseCG->GetSibling() )
            pLastCaseCG = (CG_CASE *) pLastCaseCG->GetSibling();

        }

    // add a definition for the switch type to the CG node
    if ( pSwTypeAttr )
        {
        node_skl * pNode = pSwTypeAttr->GetType();
        // it gets its own context, so I doesn't mess up our sizing
        XLAT_CTXT SwTypeCtxt( &MyContext );

        CG_NDR * pSwCG = (CG_NDR *) pNode->ILxlate( &SwTypeCtxt );

        pUnionCG->SetSwitchType( pSwCG );
        }

    if ( pCommand->IsNDR64Run() && pSwIsAttr )
        {
        pUnionCG->SetNdr64SwitchIsExpr( pSwIsAttr->GetExpr() );
        }

    // add the case list to the union node and set all the union entries
    pUnionCG->SetChild( pFirstCaseCG );

    MyContext.AlignEmbeddedUnion();

    pUnionCG->SetSizesAndAlignments( MyContext );
    pUnionCG->SetUnionFlavor( unsigned short ( fMSUnion ? UNION_NONENCAP_MS : UNION_NONENCAP_DCE ) );

    if ( pCommand->IsNDR64Run() )
    {
        if ( pUnionCG->GetMemorySize() >= SIZE_2GB )
            {
            SemError( this, MyContext, SIZE_EXCEEDS_2GB, NULL );
            exit( SIZE_EXCEEDS_2GB );
            }
    }


    pSaved->SaveInfo( &MyContext, pUnionCG);

    if ( pCommand->IsNDR64Run() && !fEncap )
    {

        // If this is an nonencapsulated union, then we need to pass up the union alignment
        // instead of the arm alignment.  To do this, put the max of the arm alignment and
        // switchtype alignment is the context.

        // we don't care about union in tlb: they might not have switch

        CG_NDR * pSwCG = dynamic_cast<CG_NDR*>( pUnionCG->GetSwitchType() );

        if ( pSwCG != NULL )
            MyContext.GetWireAlign() = MyContext.GetWireAlign() > pSwCG->GetWireAlignment() ?
                                       MyContext.GetWireAlign() : pSwCG->GetWireAlignment();

    }
        

    pContext->ReturnSize( MyContext );

    return pUnionCG;
};

//--------------------------------------------------------------------
//
// node_en_union::ILxlate
//
// Notes:
//
//
// for an encapsulated union, we return the following tree:
//      CG_ENCAP_STRUCT ( with switch field )
//          |
//      CG_ENCAP_UNION
//          |
//      CG_CASE  -  CG_CASE  -  CG_CASE - CG_CASE
//          |           |           |
//      CG_UNION_FLD CG_UNION_FLD CG_UNION_FLD
//          |
//         etc.
//
//--------------------------------------------------------------------

CG_CLASS *
node_en_union::ILxlate( XLAT_CTXT * pContext )
{
    CG_UNION * pUnionCG;

#ifdef trace_cg
    printf("..node_en_union,\t%s\n", GetSymName());
#endif

    XLAT_CTXT               MyContext( this, pContext );

    // call non-encap union processor
    pUnionCG = (CG_UNION *) node_union::ILxlate( pContext );

    pUnionCG->SetUnionFlavor( UNION_ENCAP );
    
    if ( pCommand->IsNDR64Run() )
    {
        if ( pUnionCG->GetMemorySize() >= SIZE_2GB )
            {
            SemError( this, MyContext, SIZE_EXCEEDS_2GB, NULL );
            exit( SIZE_EXCEEDS_2GB );
            }
    }
    else if (pUnionCG->GetMemoryAlignment() > 16) 
        {
        SemError( this, MyContext, ENCAP_UNION_ARM_ALIGN_EXCEEDS_16, NULL );
        }

    return pUnionCG;
};

//--------------------------------------------------------------------
//
// node_def::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_def::ILxlate( XLAT_CTXT * pContext )
{
    CG_CLASS        *   pChildCG                = NULL;
    XLAT_CTXT           MyContext( this, pContext );
    node_transmit   *   pTransmitAttr   = (node_transmit *)
                                              MyContext.ExtractAttribute( ATTR_TRANSMIT );
    node_wire_marshal * pWireMarshalAttr= (node_wire_marshal *)
                                              MyContext.ExtractAttribute( ATTR_WIRE_MARSHAL );
    node_represent_as * pRepresentAttr  = (node_represent_as *)
                                              MyContext.ExtractAttribute( ATTR_REPRESENT_AS );
    node_user_marshal * pUserMarshalAttr= (node_user_marshal *)
                                              MyContext.ExtractAttribute( ATTR_USER_MARSHAL );
    node_cs_char      * pCSCharAttr     = (node_cs_char *)
                                              MyContext.ExtractAttribute( ATTR_CSCHAR );
    BOOL                fEncode         = (NULL !=
                                              MyContext.ExtractAttribute( ATTR_ENCODE ) );
    BOOL                fDecode         = (NULL !=
                                              MyContext.ExtractAttribute( ATTR_DECODE ) );

    node_guid *         pGUID           = (node_guid *)MyContext.ExtractAttribute(ATTR_GUID);
    node_version *      pVer            = (node_version *)MyContext.ExtractAttribute(ATTR_VERSION);
    node_constant_attr * pHC            = (node_constant_attr *)MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    node_text_attr *    pHelpStr        = (node_text_attr *)MyContext.ExtractAttribute(ATTR_HELPSTRING);
    XLAT_CTXT *         pIntfCtxt       = (XLAT_CTXT *) MyContext.GetInterfaceContext();
    BOOL                fIsHRESULT      = IsHResultOrSCode();
    REUSE_INFO * pSaved;

    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));

#ifdef trace_cg
    printf("..node_def,\t%s\n", GetSymName());
#endif

    fEncode |= pIntfCtxt->FInSummary( ATTR_ENCODE );
    fDecode |= pIntfCtxt->FInSummary( ATTR_DECODE );

    // only direct children of the interface get these bits
    if ( !pContext->GetParent()->IsInterfaceOrObject() )
        {
        fEncode = FALSE;
        fDecode = FALSE;
        }
    BOOL fInLibrary = MyContext.AnyAncestorBits(IL_IN_LIBRARY);
    BOOL fHidden = (NULL != MyContext.ExtractAttribute(ATTR_HIDDEN));
    BOOL fPublic = FALSE;
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);

    // check for public attribute
    node_type_attr * pTA;
    while ( ( pTA = (node_type_attr *)MyContext.ExtractAttribute(ATTR_TYPE) ) != 0 )
        {
        switch (pTA->GetAttr())
            {
            case TATTR_PUBLIC:
                fPublic = TRUE;
                break;
            default:
                // MIDL_ASSERT(!"Illegal attribute found on node_def during ILxlate");
                break;
            }
        }
    // clear member attributes
    while (MyContext.ExtractAttribute(ATTR_MEMBER));

    BOOL fNeedsCGTYPEDEF = fInLibrary &&
        (fPublic || NULL != pGUID || NULL != pVer || NULL != pHC || NULL != pHelpStr || fHidden)
        &&
        !(fEncode || fDecode || pRepresentAttr || pTransmitAttr ||
            pUserMarshalAttr || pWireMarshalAttr || pCSCharAttr);

    if (fNeedsCGTYPEDEF)
        {
        // see if we're already generated
            if (pReUseDict->GetReUseEntry(pSaved, this))
                {
                MyContext.ExtractAttribute( ATTR_V1_ENUM );

                // reuse found...
                pSaved->FetchInfo(&MyContext, pChildCG);
                pContext->ReturnSize(MyContext);
                return pChildCG;
                }
        }
  
    // process handle stuff
    if ( GetHandleKind() == HDL_CTXT )
        {
        MyContext.ExtractAttribute( ATTR_CONTEXT );
        }
    else if (GetHandleKind() == HDL_GEN)
        {
        MyContext.ExtractAttribute( ATTR_HANDLE );
        }    

    ////////////////////////////////////////////////////////////////////////
    // process the child, except for context handles and transmit_as types
    if ( ( GetHandleKind() != HDL_CTXT ) && !pTransmitAttr && !pWireMarshalAttr)
        {
        pChildCG = (CG_CLASS *) GetChild()->ILxlate( &MyContext );
        
        if (NULL != pChildCG && !IsTempName( GetSymName() ) )
            {
            switch ( pChildCG->GetCGID() )
                {
                // special case transmit_as to set the presented type
                case ID_CG_TRANSMIT_AS:
                        ((CG_TRANSMIT_AS *) pChildCG)->SetPresentedType( this );
                        break;
                case ID_CG_COCLASS:
                        break;
                // acf attributes are NOT transitive
                case ID_CG_REPRESENT_AS:
                case ID_CG_USER_MARSHAL:
                // odl attributes are also NOT transitive
                case ID_CG_TYPEDEF:
                        break;
                // idl attributes ARE transitive
                case ID_CG_CONTEXT_HDL:
                case ID_CG_GENERIC_HDL:
                default:
                    ((CG_NDR *)pChildCG)->SetType( this );
                }
            }

        // an HRESULT return type should be a CG_HRESULT
        if ( fIsHRESULT )
            {
            if ( !MyContext.FindAncestorContext( NODE_PARAM ) )
                {
                node_proc * pProc;
                WALK_CTXT * pProcCtxt =
                    MyContext.FindAncestorContext( NODE_PROC );

                if ( pProcCtxt )
                    {
                    pProc = (node_proc *)pProcCtxt->GetParent();
                    if ( pProc->FInSummary( ATTR_OBJECT ) ||
                            pProc->GetMyInterfaceNode()->FInSummary( ATTR_OBJECT ) )
                        {
                        pChildCG = new CG_HRESULT( this, MyContext );
                        }
                    }
                }
            }       // HRESULT tests
        }
    else if ( pTransmitAttr )
        {
        node_skl        *   pXmit;
        CG_TRANSMIT_AS  *   pTransCG;

        pXmit   = pTransmitAttr->GetTransmitAsType();

        // get rid of dangling attributes from the non-transmitted side
        // we've already picked up the attributes that go with our node
        MyContext.ClearAttributes();
        pChildCG = (CG_CLASS *) pXmit->ILxlate( &MyContext );

        MyContext.FixMemSizes( this );
        // if the child had generic handle, skip that...
        if ( pChildCG->GetCGID() == ID_CG_GENERIC_HDL )
            pChildCG = (CG_CLASS*) pChildCG->GetChild();

        pTransCG = new CG_TRANSMIT_AS( pXmit, this, MyContext );

        pTransCG->SetChild( pChildCG );
        pChildCG = pTransCG;
        }
   else if ( pWireMarshalAttr )
        {
        // Note that this is a node like for a transmit_as attribute,
        // but we map it into CG_USER_MARSHAL like for a user_marshal node.

        // "this" is the node for the presented type.

        node_skl * pXmit = pWireMarshalAttr->GetWireMarshalType();

        // get rid of dangling attributes from the non-transmitted side
        // we've already picked up the attributes that go with our node
        MyContext.ClearAttributes();
        pChildCG = (CG_CLASS *) pXmit->ILxlate( &MyContext );

        MyContext.FixMemSizes( this );

        // no support for user_marshal with Oi or Oi1.
        // Have to use Oi2 or Os.

        if ( (pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER)  &&
              ! (pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2)  
            )
             SemError( this, MyContext, REQUIRES_I2, "[wire_marshal]" );

        CG_USER_MARSHAL * pUserCG = new CG_USER_MARSHAL(
                                        pXmit,
                                        GetSymName(), // pres type name
                                        this,
                                        MyContext,
                                        TRUE          // from transmit_as
                                    );

        pUserCG->SetChild( pChildCG );
        pChildCG = pUserCG;
        }

    if ( GetHandleKind() != HDL_NONE )
        {
        CG_NDR * pCG;

        if ( GetHandleKind() == HDL_CTXT )
            {
            MyContext.ContextHandleSizes( this );
            // remaining attributes are not needed e.g. pointer attrs
		    pCG = new CG_CONTEXT_HANDLE (
                                        this,
                                        0,
                                        MyContext
                                        );
            MyContext.ClearAttributes();
            }
        else    // HDL_GEN
            {
            pCG = new CG_GENERIC_HANDLE( this, NULL, MyContext );
            }

        pCG->SetChild( pChildCG );
        pChildCG = pCG;
        }

    if ( pRepresentAttr )
        {
        node_skl * pRepT  = pRepresentAttr->GetRepresentationType();

        if (pRepT)
            {
            MyContext.FixMemSizes( pRepT );
            }

        CG_REPRESENT_AS *   pRepCG = new CG_REPRESENT_AS(
            this,
            pRepresentAttr->GetRepresentationName(),
            pRepT,
            MyContext
            );

        pRepCG->SetChild( pChildCG );
        pChildCG = pRepCG;
        }
    else if ( pUserMarshalAttr )
        {
        node_skl * pUserT  = pUserMarshalAttr->GetRepresentationType();

        if (pUserT)
            {
            MyContext.FixMemSizes( pUserT );
            }

        // no support for user_marshal with Oi or Oi1.
        // Have to use Oi2 or Os.

        if ( (pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER)  &&
              ! (pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2)  
            )
             SemError( this, MyContext, REQUIRES_I2, "[user_marshal]" );

        CG_USER_MARSHAL * pUserCG = new CG_USER_MARSHAL(
            this,
            pUserMarshalAttr->GetRepresentationName(),
            pUserT,
            MyContext,
            FALSE  // not from transmit_as
            );

        pUserCG->SetChild( pChildCG );
        pChildCG = pUserCG;
        }
    // wire marshal has to be under transmit as.

    if ( fEncode || fDecode )
        {
        CG_TYPE_ENCODE * pPickleCG;
        CG_PARAM       * pParamCG;
        CG_PROC        * pProcCG;

        pPickleCG = new CG_TYPE_ENCODE( this, fEncode, fDecode );
        pPickleCG->SetChild( pChildCG );

        pParamCG = new CG_PARAM( this,
            0,
            MyContext,
            NULL,
            0);
        pParamCG->SetChild( pPickleCG );

        pProcCG = new CG_TYPE_ENCODE_PROC( 0,
            this,
            NULL,
            NULL,
            0,
            0,
            0,
            0,
            0,
            NULL,
            unsigned short ( pCommand->Is64BitEnv() ? OPTIMIZE_ALL_I2_FLAGS :
                OPTIMIZE_INTERPRETER ),
            0,
            pCommand->IsSwitchDefined( SWITCH_ROBUST ) );
        pProcCG->SetChild( pParamCG );

        pChildCG = (CG_CLASS *)pProcCG;
        }

    if ( pCSCharAttr )
        {
        MyContext.FixMemSizes( pCSCharAttr->GetUserType() );
        }

    if (fNeedsCGTYPEDEF)
        {
        if (NULL == pChildCG)
            {
                // The only way we should be able to get here is if we had a typedef
                // that contained a forward reference to an interface, dispinterface, etc.
                // MKTYPLIB disallowed this but we're gonna go ahead and allow it.
                pChildCG = ((node_interface *)GetChild())->GetCG(TRUE);
            }
        CG_TYPEDEF * pTD = new CG_TYPEDEF(this, MyContext);
        pTD->SetChild(pChildCG);
        pChildCG = (CG_CLASS *) pTD;

        // remember this node so we don't generate two of these
        pSaved->SaveInfo(&MyContext, pChildCG);
        }
    pContext->ReturnSize( MyContext );

    return pChildCG;

};


//--------------------------------------------------------------------
//
// node_pointer::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_pointer::ILxlate( XLAT_CTXT * pContext )
{
    node_skl*           pType       = GetBasicType();
    CG_CLASS        *   pChildCG    = NULL;
    CG_NDR          *   pCG         = NULL;
    XLAT_CTXT           MyContext( this, pContext );
    PTRTYPE             PtrKind     = PTR_UNKNOWN;
    FIELD_ATTR_INFO     FAInfo;
    node_allocate   *   pAlloc;
    short               AllocDetails = 0;
    node_byte_count *   pCountAttr;
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
#ifdef trace_cg
    printf("..node_pointer,\t%s\n", GetSymName());
#endif

    ////////////////////////////////////////////////////////////////////////
    // process misc attributes

    if ( ( pAlloc = (node_allocate *) MyContext.ExtractAttribute( ATTR_ALLOCATE ) ) != 0 )
        {
        AllocDetails    = pAlloc->GetAllocateDetails();
        }

    ////////////////////////////////////////////////////////////////////////
    // process pointer attributes

    PtrKind = MyContext.GetPtrKind();

    // see if a param or return type context attr reached us...
    pCountAttr = (node_byte_count *)
        MyContext.ExtractAttribute( ATTR_BYTE_COUNT );

    ////////////////////////////////////////////////////////////////////////
    // process field attributes

    // see if we have any field attributes (are conformant or varying)
    FAInfo.SetControl( TRUE, pType->IsPtrOrArray() );
    MyContext.ExtractFieldAttributes( &FAInfo );
    FAInfo.Normalize();

    switch ( FAInfo.Kind )
        {
        case FA_NONE:
            {
            if ( ( pType->NodeKind() == NODE_INTERFACE_REFERENCE || pType->IsInterfaceOrObject() )
                    && MyContext.AnyAncestorBits(IL_IN_LIBRARY) )
                {
                //This is an interface pointer without an [iid_is] attribute but in a type library.
                // we don't care about the pointee
                MIDL_ASSERT ( FAInfo.pIIDIsExpr  == NULL );
                node_skl* pIf = ( pType->NodeKind() == NODE_INTERFACE_REFERENCE ) ? 
                    ( ( node_interface_reference* ) pType )->GetRealInterface() : pType ;

                pCG     = new CG_INTERFACE_POINTER( this,
                                                    (node_interface *)pIf );
                node_skl* pAlias = GetChild();

                if ( pType->NodeKind() != NODE_INTERFACE_REFERENCE && pAlias && pAlias->NodeKind() == NODE_DEF)
                    {
                    ( (CG_INTERFACE_POINTER* ) pCG )->SetTypeAlias( ( CG_TYPEDEF* ) pAlias->ILxlate( &MyContext ) );
                    }
                }
            else if ( pCountAttr )
                {
                pCG =   new CG_BYTE_COUNT_POINTER( this,
                                                   PtrKind,
                                                   pCountAttr->GetByteCountParam() );
                }
            else
                {
                pCG =   new CG_POINTER( this,
                                        PtrKind,
                                        AllocDetails );
                }
            break;
            }
        case FA_VARYING:
            {
            pCG = new CG_LENGTH_POINTER( this,
                                         PtrKind,
                                         AllocDetails,
                                         &FAInfo );
            break;
            }
        case FA_CONFORMANT:
            {
            pCG = new CG_SIZE_POINTER( this,
                                       PtrKind,
                                       AllocDetails,
                                       &FAInfo );
            break;
            }
        case FA_CONFORMANT_VARYING:
            {
            pCG = new CG_SIZE_LENGTH_POINTER( this,
                                              PtrKind,
                                              AllocDetails,
                                              &FAInfo );
            break;
            }
        case FA_STRING:
            {
            pCG = new CG_STRING_POINTER( this,
                                         PtrKind,
                                         AllocDetails );
            if (FAInfo.StringKind == STR_BSTRING)
                {
                ((CG_STRING_POINTER *) pCG)->SetBStr();
                }
            break;
            }
        case FA_CONFORMANT_STRING:
            {
            if (FAInfo.StringKind == STR_STRING)
                {
                pCG = new CG_SIZE_STRING_POINTER( this,
                                                  PtrKind,
                                                  AllocDetails,
                                                  &FAInfo );
                }
            break;
            }
        case FA_INTERFACE:
            {
            //This is an interface pointer with an [iid_is] attribute.
            // we don't care about the pointee
            node_skl* pIf = ( pType->NodeKind() == NODE_INTERFACE_REFERENCE ) ? 
                ( ( node_interface_reference* ) pType )->GetRealInterface() : pType ;
            pCG = new CG_IIDIS_INTERFACE_POINTER( this,
                                            pIf,
                                            FAInfo.pIIDIsExpr );
            break;
            }
        default:    // string + varying combinations
            {
            MIDL_ASSERT (!"Invalid pointer kind");
            break;
            }
        }


    // process any context_handle attributes from param nodes
    if ( MyContext.FInSummary( ATTR_CONTEXT ) )
        if ( pType->NodeKind() != NODE_POINTER )
            {
            MyContext.ExtractAttribute( ATTR_CONTEXT );
            MyContext.ContextHandleSizes( this );
            pContext->ReturnSize( MyContext );
		    pCG = new CG_CONTEXT_HANDLE (
                                        this,
                                        0,
                                        MyContext
                                        );
#ifdef trace_cg
            printf("..node_pointer return 1\n");
#endif
            return pCG;
            }

    // ignore pointers do not need to be rpc-able
    if ( MyContext.ExtractAttribute( ATTR_IGNORE ) )
        {
        MyContext.IgnoredPtrSizes();
        pContext->ReturnSize( MyContext );
        pCG = new CG_IGNORED_POINTER( this );

        return pCG;
        }


    ////////////////////////////////////////////////////////////////////////
    // process child
    node_skl*   pChild  = GetChild();

    if ( ( !pType->IsInterfaceOrObject() )  &&
         FAInfo.Kind != FA_INTERFACE        &&
         !pCG->IsInterfacePointer() )
        {
        pChildCG = GetChild()->ILxlate( &MyContext );
        }

    // if we are the pointer above an interface, we should get changed
    // into an interface pointer
    if ( ( ( pType->NodeKind() == NODE_INTERFACE_REFERENCE ) ||
            ( pType->IsInterfaceOrObject() ) )  &&
         !pCG->IsInterfacePointer() )
        {
        pCG = (CG_NDR *)pChildCG;
        pChildCG = NULL;
        }

    if ( pCG == 0 )
        {
        SemError( this, *pContext, UNDEFINED_SYMBOL, pChild->GetSymName() );
        exit( UNDEFINED_SYMBOL );
        }

    // do a three way merge of attributes to pass to parent.
    // Get a new context since the starting context was polleted with pointee attributes.

    XLAT_CTXT           NewPointerContext( this, pContext );
    NewPointerContext.BaseTypeSizes( this );

    pContext->ReturnSize( NewPointerContext);
    
    // update sizes with the size of the pointer
    pCG->SetSizesAndAlignments( NewPointerContext );

    pCG->SetChild( pChildCG );

    if ( HasCSType() )
    {
        node_def *pChild = (node_def *) GetChild();
        MIDL_ASSERT( NODE_DEF == pChild->NodeKind() );
        node_cs_char *p = (node_cs_char *) pChild->GetAttribute( ATTR_CSCHAR );
        MIDL_ASSERT( NULL != p );

        ( (CG_POINTER *) pCG )->SetCSUserType( p );

        CG_NDR *pUserTypeCG = (CG_NDR *) p->GetUserType()->ILxlate( &MyContext );
        p->SetElementSize( pUserTypeCG->GetMemorySize() );
    }

#ifdef trace_cg
    printf("..node_pointer return 2\n");
#endif
    return pCG;
}

//--------------------------------------------------------------------
//
// node_array::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_array::ILxlate( XLAT_CTXT * pContext )
{
    CG_CLASS        *   pChildCG;
    CG_ARRAY        *   pCG;
    unsigned short      Dimensions;
    PTRTYPE             PtrKind     = PTR_UNKNOWN;
    XLAT_CTXT           MyContext( this, pContext );
    FIELD_ATTR_INFO     FAInfo;
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
#ifdef trace_cg
    printf("..node_array,\t%s\n", GetSymName());
#endif

    // process any context_handle attributes from param nodes
    if ( MyContext.ExtractAttribute( ATTR_CONTEXT ) )
        {
        CG_NDR  * pCG;

        MyContext.ContextHandleSizes( this );
        pContext->ReturnSize( MyContext );
		pCG = new CG_CONTEXT_HANDLE (
                                    this,
                                    0,
                                    MyContext
                                    );
        return pCG;
        }

    ////////////////////////////////////////////////////////////////////////
    // process pointer attributes

    PtrKind = MyContext.GetPtrKind();
    MIDL_ASSERT( PtrKind != PTR_UNKNOWN );

    // see if we have any field attributes (are conformant or varying)
    FAInfo.SetControl( FALSE, GetChild()->IsPtrOrArray() );
    MyContext.ExtractFieldAttributes( &FAInfo );
    FAInfo.Normalize( pLowerBound, pUpperBound );

    // The 64bit transfer syntax has it's own mechanism
    // for propagating conformant/variance among array dimensions.
    if ( !pCommand->IsNDR64Run() )
        {
        // if we are multi-dimensional, absorb parent information
        if ( MyContext.AnyAncestorBits( IL_IN_MULTIDIM_CONF ) )
            FAInfo.Kind |= FA_CONFORMANT;
        // don't propogate varying down into a string
        if ( MyContext.AnyAncestorBits( IL_IN_MULTIDIM_VAR ) &&
                ( ( FAInfo.Kind & FA_STRING ) == 0 ))
            FAInfo.Kind |= FA_VARYING;
        }

    // if our child is also an array, tell it about us
    if ( GetBasicType()->NodeKind() == NODE_ARRAY )
        {
        if ( FAInfo.Kind & FA_CONFORMANT )
            MyContext.SetAncestorBits( IL_IN_MULTIDIM_CONF );
        if ( FAInfo.Kind & FA_VARYING )
            MyContext.SetAncestorBits( IL_IN_MULTIDIM_VAR );
        }
    else
        {
        MyContext.ClearAncestorBits( IL_IN_MULTIDIM_CONF | IL_IN_MULTIDIM_VAR );
        }

    // process the child
    pChildCG = GetChild()->ILxlate( &MyContext );

    MyContext.ArraySize( this, &FAInfo );

    // fetch # of dimensions from child;
    if ( pChildCG->IsArray() )
        {
        Dimensions = unsigned short ( ( (CG_ARRAY *) pChildCG )->GetDimensions() + 1 );
        // force all inner dimensions to be REF
        ( (CG_ARRAY *) pChildCG )->SetPtrType( PTR_REF );
        }
    else
        {
        Dimensions = 1;
        }

    // force embedded arrays to be REF
    if ( PtrKind != PTR_REF )
        {
        WALK_CTXT * pUpperCtxt = MyContext.GetParentContext();
        while ( pUpperCtxt )
            {
            NODE_T Kind = pUpperCtxt->GetParent()->NodeKind();
            if ( Kind == NODE_PARAM )
                break;
            else if ( Kind == NODE_DEF )
                {
                node_def * pNode = (node_def *) pUpperCtxt->GetParent();
                if ( pNode->FInSummary( ATTR_TRANSMIT ) ||
                        pNode->FInSummary( ATTR_REPRESENT_AS ) )
                    {
                    PtrKind = PTR_REF;
                    break;
                    }
                // else go up another level
                }
            else
                {
                PtrKind = PTR_REF;
                break;
                }
            pUpperCtxt = pUpperCtxt->GetParentContext();
            }
        }

    switch ( FAInfo.Kind )
        {
        case FA_NONE:
            {
            pCG = new CG_FIXED_ARRAY( this,
                                      &FAInfo,
                                      Dimensions,
                                      MyContext );
            break;
            }
        case FA_VARYING:
            {
            pCG =   new CG_VARYING_ARRAY( this,
                                          &FAInfo,
                                          Dimensions,
                                          MyContext );

            break;
            }
        case FA_CONFORMANT:
            {
            pCG = new CG_CONFORMANT_ARRAY( this,
                                           &FAInfo,
                                           Dimensions,
                                           MyContext );

            break;
            }
        case FA_CONFORMANT_VARYING:
            {
            pCG = new CG_CONFORMANT_VARYING_ARRAY( this,
                                                   &FAInfo,
                                                   Dimensions,
                                                   MyContext );

            break;
            }
        case FA_STRING:
            {
            pCG = new CG_STRING_ARRAY( this,
                                       &FAInfo,
                                       Dimensions,
                                       MyContext );

            break;
            }
        case FA_CONFORMANT_STRING:
            {
            pCG = new CG_CONFORMANT_STRING_ARRAY( this,
                                                  &FAInfo,
                                                  Dimensions,
                                                  MyContext );

            break;
            }
        default:    // string + varying combinations
            {
            MIDL_ASSERT (!"invalid conf/var combination");
            break;
            }
        }

    pContext->ReturnSize( MyContext );
    pCG->SetPtrType( PtrKind );

    if ( HasCSType() )
    {
        node_def *pChild = (node_def *) GetChild();
        MIDL_ASSERT( NODE_DEF == pChild->NodeKind() );
        node_cs_char *p = (node_cs_char *) pChild->GetAttribute( ATTR_CSCHAR );
        MIDL_ASSERT( NULL != p );

        ( (CG_ARRAY *) pCG )->SetCSUserType( p );

        CG_NDR *pUserTypeCG = (CG_NDR *) p->GetUserType()->ILxlate( &MyContext );
        p->SetElementSize( pUserTypeCG->GetMemorySize() );
    }

    pCG->SetChild( pChildCG );

    if ( pCommand->IsNDR64Run() )
    {
        if ( pCG->GetMemorySize() >= SIZE_2GB )
            {
            SemError( this, MyContext, SIZE_EXCEEDS_2GB, NULL );
            exit( SIZE_EXCEEDS_2GB );
            }
    }

    return pCG;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\ilctxt.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
    
    ilctxt.cxx

 Abstract:

    Intermediate Language translator context management routines

 Notes:


 Author:

    GregJen Jun-11-1993 Created.

 Notes:


 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

#include "nodeskl.hxx"
#include "ilxlat.hxx"
#include "cmdana.hxx"
#include "optprop.hxx"
#include "ilreg.hxx"
#include "ndrcls.hxx"


/****************************************************************************
 *  externs
 ***************************************************************************/

extern CMD_ARG  * pCommand;

/****************************************************************************
 *  definitions
 ***************************************************************************/




// #define trace_cg
//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::XLAT_SIZE_INFO
//
// Notes:
//      
//
//
//--------------------------------------------------------------------
XLAT_SIZE_INFO::XLAT_SIZE_INFO(
    CG_NDR * pCG )
    {
    ZeePee      = pCommand->GetZeePee();
    MemAlign    = pCG->GetMemoryAlignment();
    WireAlign   = pCG->GetWireAlignment();
    MemSize     = pCG->GetMemorySize();
    WireSize    = pCG->GetWireSize();
    MemOffset   = 0;
    WireOffset  = 0;
    MustAlign   = false;
    }

//--------------------------------------------------------------------
//
// ::RoundToAlignment
//
// Helper round-up routine
//
// Notes:
//      
//
//
//--------------------------------------------------------------------

inline unsigned long
RoundToAlignment( unsigned long & Offset, unsigned short Alignment )
{
    unsigned long   AlignFactor = Alignment - 1;

    return (Offset = (Offset + AlignFactor) & ~AlignFactor );
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::BaseTypeSizes
//
// Notes:
//      
// Merges attributes for a base type with the given context.
//
//--------------------------------------------------------------------


void
XLAT_SIZE_INFO::BaseTypeSizes( node_skl * pNode )
{
    unsigned short MS, WS;

    switch( pNode->NodeKind() )
        {
        case NODE_DOUBLE:
        case NODE_HYPER:
        case NODE_INT64:
        case NODE_LONGLONG:
            {
            MS=8; WS=8;
            break;
            };
        case NODE_INT128:
        case NODE_FLOAT80: //BUG, BUG double check this once VC supports
        case NODE_FLOAT128:
            {
            MS=16; WS = 16;
            break;
            }
        case NODE_POINTER:
        case NODE_HANDLE_T:
            {
            MS = (unsigned short) SIZEOF_MEM_PTR();
            WS = (unsigned short) SIZEOF_WIRE_PTR();
            break;
            };
        case NODE_INT3264:
            {
            MS = (unsigned short) SIZEOF_MEM_INT3264();
            WS = (unsigned short) SIZEOF_WIRE_INT3264();
            break;
            };
        case NODE_FLOAT:
        case NODE_LONG:
        case NODE_INT32:
        case NODE_INT:
        case NODE_E_STATUS_T:
            {
            MS=4; WS=4;
            break;
            };
        case NODE_SHORT:
        case NODE_WCHAR_T:
            {
            MS=2; WS=2;
            break;
            };
        case NODE_SMALL:
        case NODE_CHAR:
        case NODE_BOOLEAN:
        case NODE_BYTE:
            {
            MS=1; WS=1;
            break;
            };
        default:
            {
            MS=0; WS=0;
            break;
            }
        }

    GetMemSize()        = MS;
    GetMemAlign()       = __max(MS,GetMemAlign());

    GetWireSize()       = WS;
    GetWireAlign()      = __max(WS,GetWireAlign());

};

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::EnumTypeSizes
//
// Notes:
//      
// Merges in the sizes for an enum.
//
//--------------------------------------------------------------------


void
XLAT_SIZE_INFO::EnumTypeSizes( node_skl*, BOOL Enum32 )
/*
    Called when xlating node_enum: Enum32 means [enum_v1] used.
*/
{
    unsigned short MS, WS;

    // note - this needs to check environment
    WS  = unsigned short( ( Enum32 ) ? 4 : 2 );
    MS  = 4;

    GetMemSize()        = MS;
    GetMemAlign()       = __max(MS, GetMemAlign());

    GetWireSize()       = WS;
    GetWireAlign()      = __max(WS, GetWireAlign());

};

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::ContextHandleSizes
//
// Notes:
//      
//
//
//--------------------------------------------------------------------


void
XLAT_SIZE_INFO::ContextHandleSizes( node_skl * pNode )
{
    FixMemSizes( pNode );

    GetWireSize()       = 20;
    GetWireAlign()      = 4;

};

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::ArraySize
//
// Notes:
//      
//
//
//--------------------------------------------------------------------


void
XLAT_SIZE_INFO::ArraySize( node_skl*, FIELD_ATTR_INFO * pFA )
{
    // if conformant, set sizes to 0 and return

    if ( pFA->Kind & FA_CONFORMANT )
        {
        MemSize     =
        WireSize    = 0;
        return;
        }

    // round up element size to alignment boundary
    // Element is already rounded up.
    // RoundToAlignment( MemSize, MemAlign );
    // RoundToAlignment( WireSize, WireAlign );
    
    // compute number of elements and multiply...

    unsigned long       ElementCount;

    ElementCount = (ulong) pFA->pSizeIsExpr->GetValue();

    MemSize     *= ElementCount;
    WireSize    *= ElementCount;


}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::GetOffset
//
// Notes:
//  For use only by field nodes !!
//  
//  Fetch the offsets from another size info block
//
//--------------------------------------------------------------------


void                
XLAT_SIZE_INFO::GetOffset( XLAT_SIZE_INFO & pInfo )
{
    MemOffset   = pInfo.MemOffset;
    WireOffset  = pInfo.WireOffset;
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::AlignOffset
//
// Notes:
//  For use only by field and struct/union nodes!!
//  
//  Round the offsets up to the corresponding alignments.
//
//--------------------------------------------------------------------

void
XLAT_SIZE_INFO::AlignOffset()
{
    RoundToAlignment( MemOffset, MemAlign );
    RoundToAlignment( WireOffset, WireAlign );
}


//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::AlignEmbeddedUnion
//
// Notes:
//  For use only by field and struct/union nodes!!
//  
//  Round the offsets up to the corresponding alignments.
//  don't round up the wire offset
//
//--------------------------------------------------------------------

void
XLAT_SIZE_INFO::AlignEmbeddedUnion()
{
    RoundToAlignment( MemOffset, MemAlign );
    RoundToAlignment( MemSize,   MemAlign );
    // RoundToAlignment( WireOffset, WireAlign );
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::AlignConfOffset
//
// Notes:
//  For use only by field and struct/union nodes!!
//  
//  Round the offsets up to the corresponding alignments.
//
//  the Mem offset passed down from the parent
//      of the conformant field is aligned
//  the Wire offset passed down from the parent is advanced by
//      the wire size and then aligned
//
//--------------------------------------------------------------------

void
XLAT_SIZE_INFO::AlignConfOffset()
{
    RoundToAlignment( MemOffset, MemAlign );
    //WireSize  += WireOffset;
    WireOffset  +=  WireSize;
    RoundToAlignment( WireOffset, WireAlign );
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::AdjustForZP
//
// Notes:
//  For use only by field and struct/union nodes!!
//  
//  Round the offsets up to the corresponding alignments.
//
//--------------------------------------------------------------------

void
XLAT_SIZE_INFO::AdjustForZP()
{
    if ( ( MemAlign > ZeePee ) && !MustAlign ) MemAlign = ZeePee;
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::AdjustSize
//
// Notes:
//  For use only by field and struct nodes!!
//  
//  Add current offsets to current sizes
//  pad MemSize out to ZeePee
//
//--------------------------------------------------------------------

void
XLAT_SIZE_INFO::AdjustSize()
{
    MemSize     += MemOffset;
    MemOffset   = MemSize;

    WireSize    += WireOffset;
    WireOffset  = WireSize;
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::AdjustConfSize
//
// Notes:
//  For use only by field and struct nodes!!
//  
//  Add current offsets to current sizes
//  pad MemSize out to ZeePee
//
//--------------------------------------------------------------------

void
XLAT_SIZE_INFO::AdjustConfSize()
{
    MemSize     += MemOffset;
    MemOffset   = MemSize;

    // don't count padding before the conformance (in case it has size 0)
    /*****
    WireSize    += WireOffset;
    WireOffset  = WireSize;
     ******/
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::AdjustTotalSize
//
// Notes:
//  For use only by field and struct/union nodes!!
//  
//  Add current offsets to current sizes
//  pad MemSize out to ZeePee
//
//--------------------------------------------------------------------

void
XLAT_SIZE_INFO::AdjustTotalSize()
{
    RoundToAlignment( MemSize, MemAlign );
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::Ndr64AdjustTotalStructSize
//
// Notes:
//  For use only by field and struct nodes!!
//  
//  Add current offsets to current sizes
//  pad MemSize and BuffSize out to ZeePee
//
//--------------------------------------------------------------------

void
XLAT_SIZE_INFO::Ndr64AdjustTotalStructSize()
{
    RoundToAlignment( WireSize, WireAlign );
    RoundToAlignment( MemSize, MemAlign );
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::FixMemSizes
//
// Notes:
//      
// This routine fixes up mem sizes when they are different from what
// the IL translate of children generated
//
//--------------------------------------------------------------------


void
XLAT_SIZE_INFO::FixMemSizes( node_skl * pNode )
{
    FRONT_MEMORY_INFO MemInfo = pNode->GetMemoryInfo();
    MemSize = MemInfo.Size;
    MemAlign = MemInfo.Align;
    MustAlign = MemInfo.IsMustAlign;
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::IgnoredPointerSizes
//
// Notes:
//      
// This routine fixes up sizes for an ignored pointer
//
//--------------------------------------------------------------------


void
XLAT_SIZE_INFO::IgnoredPtrSizes()
{
    MemSize  =                  SIZEOF_MEM_PTR();
    MemAlign = (unsigned short) SIZEOF_MEM_PTR();
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::ReturnSize
//
// Notes:
//
//  Copy the size information up into the parent.
//
//--------------------------------------------------------------------



void
XLAT_SIZE_INFO::ReturnSize( XLAT_SIZE_INFO & pCtxt )
{
    if ( pCtxt.MemAlign > MemAlign ) 
        MemAlign = pCtxt.MemAlign;
    MemSize = pCtxt.MemSize;

    if ( pCtxt.WireAlign > WireAlign ) 
        WireAlign = pCtxt.WireAlign;
    WireSize = pCtxt.WireSize;

    MustAlign = MustAlign || pCtxt.MustAlign;

    // note: ZeePee is NOT propogated up, only down
    // note: offsets are propogated up specially
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::ReturnConfSize
//
// Notes:
//
//  Copy the size information up into the parent.
//  Don't overwrite the wire size the parent already has
//
//--------------------------------------------------------------------



void
XLAT_SIZE_INFO::ReturnConfSize( XLAT_SIZE_INFO & pCtxt )
{
    if ( pCtxt.MemAlign > MemAlign ) 
        MemAlign = pCtxt.MemAlign;
    MemSize = pCtxt.MemSize;

    if ( pCtxt.WireAlign > WireAlign ) 
        WireAlign = pCtxt.WireAlign;
    // WireSize     = pCtxt.WireSize;

    MustAlign = MustAlign || pCtxt.MustAlign;

    // note: ZeePee is NOT propogated up, only down
    // note: offsets are propogated up specially
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::ReturnUnionSize
//
// Notes:
//
//  Copy the size information up into the parent.
//
//--------------------------------------------------------------------



void
XLAT_SIZE_INFO::ReturnUnionSize( XLAT_SIZE_INFO & pCtxt )
{
    if ( pCtxt.MemAlign > MemAlign )    MemAlign = pCtxt.MemAlign;
    if ( pCtxt.MemSize > MemSize )      MemSize  = pCtxt.MemSize;

    if ( pCtxt.WireAlign > WireAlign )  WireAlign = pCtxt.WireAlign;
    if ( pCtxt.WireSize > WireSize )    WireSize  = pCtxt.WireSize;

    MustAlign = MustAlign || pCtxt.MustAlign;
    
    // note: ZeePee is NOT propogated up, only down
    // note: offsets are propogated up specially
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\ilreg.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	ilreg.cxx

 Abstract:

	This file implements the type registry for structure/union reuse.

 Notes:

 History:

	Oct-25-1993		GregJen		Created.
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

#include "ilreg.hxx"

/***********************************************************************
 * global data
 **********************************************************************/

// #define trace_reuse

REUSE_DICT				*	pReUseDict;

REUSE_DICT::REUSE_DICT()
		: Dictionary()
	{
	}

SSIZE_T
REUSE_DICT::Compare( pUserType pL, pUserType pR )
	{
	SSIZE_T	l1	= (SSIZE_T) ((REUSE_INFO *)pL)->pType;
	SSIZE_T l2  = (SSIZE_T) ((REUSE_INFO *)pR)->pType;

	return l1 - l2;
	}


REUSE_INFO *
REUSE_DICT::IsRegistered(
	REUSE_INFO	*	pInfo )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Search for a type with the reuse registry.

 Arguments:

 	pInfo	- A pointer to the type being registered.
	
 Return Value:

 	The node that gets registered.
	
 Notes:

----------------------------------------------------------------------------*/
{
#ifdef trace_reuse
printf(". . .Reuse: finding %08x\n", pInfo->pType );
fflush(stdout);
#endif
	Dict_Status	Status	= Dict_Find( pInfo );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:
			return (REUSE_INFO *)0;
		default:
			return (REUSE_INFO *)Dict_Curr_Item();
		}
}

REUSE_INFO *
REUSE_DICT::Register(
	REUSE_INFO	*	pInfo )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Register a type with the dictionary.

 Arguments:
	
 	pType	- A pointer to the type node.

 Return Value:

 	The final inserted type.
	
 Notes:

----------------------------------------------------------------------------*/
{
#ifdef trace_reuse
printf(". . .Reuse: inserting %08x\n", pInfo->pType );
fflush(stdout);
#endif
		Dict_Insert( (pUserType) pInfo );
		return pInfo;
}

BOOL				
REUSE_DICT::GetReUseEntry( 
	REUSE_INFO * & pRI, 
	node_skl * pNode )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Register a type with the dictionary.

 Arguments:
	
 	pRI		- A pointer to the returned REUSE_INFO block
 	pNode	- A pointer to the type node.

 Return Value:

 	True if the entry was already in the table,
 	False if the entry is new.
	
 Notes:

----------------------------------------------------------------------------*/
{
	REUSE_INFO		TempEntry(pNode);
	REUSE_INFO	*	pRealEntry;

#ifdef trace_reuse
printf(". . .Reuse: searching for %08x\n", pNode );
fflush(stdout);
#endif
	if ( (pRealEntry = IsRegistered( &TempEntry ) ) == 0 )
		{
		pRealEntry = new REUSE_INFO( pNode );
		Register( pRealEntry );
		pRI = pRealEntry;
#ifdef trace_reuse
printf(". . .Reuse: new node %08x\n", pRI );
fflush(stdout);
#endif
		return FALSE;
		}

	pRI	= pRealEntry;
#ifdef trace_reuse
printf(". . .Reuse: found %08x\n", pRI );
fflush(stdout);
#endif
	return TRUE;

}

void
REUSE_DICT::MakeIterator(
	ITERATOR&	ListIter )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Get a list of structs and unions into the specified iterator.

 Arguments:
	
	ListIter	- A reference to the iterator class where the list is
				  accumulated.

 Return Value:
	
	A count of the number of resources.

 Notes:

----------------------------------------------------------------------------*/
{
	REUSE_INFO	*	pR;
	Dict_Status		Status;
	
	//
	// Get to the top of the dictionary.
	//

	Status = Dict_Next( (pUserType) 0 );

	//
	// Iterate till the entire dictionary is done.
	//

	while( SUCCESS == Status )
		{
		pR	= (REUSE_INFO *)Dict_Curr_Item();
		ITERATOR_INSERT( ListIter, pR->pSavedCG );
		Status = Dict_Next( pR );
		}

	return;
}

/****************************************************************************
 	utility functions.
 ****************************************************************************/
SSIZE_T
CompareReUseKey( void * p1, void *p2 )
	{
#ifdef trace_reuse
printf(". . .Reuse: comparing %08x to %08x (in)\n", p1, p2 );
fflush(stdout);
#endif
	SSIZE_T	l1	= (SSIZE_T)
					((REUSE_INFO *)p1)->pType;
	SSIZE_T	l2	= (SSIZE_T)
					((REUSE_INFO *)p2)->pType;

#ifdef trace_reuse
printf(". . .Reuse: comparing %08x to %08x\n", l1, l2 );
fflush(stdout);
#endif

	if( l1 < l2 ) return -1;
	else if( l1 > l2 ) return 1;
	return 0;
	}
void
PrintReUseKey( void* ) { }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\misccls.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    misccls.hxx

 Abstract:

    Code generation methods for miscellaneous cg classes.

 Notes:


 History:

    Sep-01-1993     VibhasC     Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop
#include "malloc.h"


/****************************************************************************
 *  local definitions
 ***************************************************************************/

/****************************************************************************
 *  local data
 ***************************************************************************/
GUID_STRS   TransferSyntaxGuidStrs( TRANSFER_SYNTAX_GUID_STR_1,
                                    TRANSFER_SYNTAX_GUID_STR_2,
                                    TRANSFER_SYNTAX_GUID_STR_3,
                                    TRANSFER_SYNTAX_GUID_STR_4,
                                    TRANSFER_SYNTAX_GUID_STR_5);

GUID_STRS   NDR64TransferSyntaxGuidStrs( NDR64_TRANSFER_SYNTAX_GUID_STR_1,
                                         NDR64_TRANSFER_SYNTAX_GUID_STR_2,
                                         NDR64_TRANSFER_SYNTAX_GUID_STR_3,
                                         NDR64_TRANSFER_SYNTAX_GUID_STR_4,
                                         NDR64_TRANSFER_SYNTAX_GUID_STR_5);

GUID_STRS   FakeNDR64TransferSyntaxGuidStrs( 
                 FAKE_NDR64_TRANSFER_SYNTAX_GUID_STR_1,
                 FAKE_NDR64_TRANSFER_SYNTAX_GUID_STR_2,
                 FAKE_NDR64_TRANSFER_SYNTAX_GUID_STR_3,
                 FAKE_NDR64_TRANSFER_SYNTAX_GUID_STR_4,
                 FAKE_NDR64_TRANSFER_SYNTAX_GUID_STR_5);
                                         

/****************************************************************************
 *  externs
 ***************************************************************************/
extern CMD_ARG * pCommand;

extern BOOL                     IsTempName( char * );

/****************************************************************************/

CG_INTERFACE::CG_INTERFACE(
    node_interface * pI,
    GUID_STRS       GStrs,
    BOOL            fCallbacks,
    BOOL            fMopInfo,
    CG_HANDLE   *   pIH,
    CG_INTERFACE*   pBaseIF
    ) :CG_NDR(pI, XLAT_SIZE_INFO() ),
    fTypeInfoInitialized( FALSE )

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    The constructor for the code generation file node.

 Arguments:

    pI          - A pointer to the interface node in type graph.
    GStrs       - guid strings
    fCallbacks  - Does the interface have any callbacks ?
    fMopInfo    - Does the interface have any mops ?
    pIH         - A pointer to the CG nodes for any implicit handle
    
 Return Value:
    
 Notes:

----------------------------------------------------------------------------*/
{
    pCGBase = pBaseIF;
    _pCTI = NULL;
    char        *       pName   = GetType()->GetSymName();

    GuidStrs            = GStrs;
    GuidStrs.SetValue();
    fMopsPresent        = fMopInfo;
    fCallbacksPresent   = fCallbacks;
    pImpHdlCG           = (CG_HANDLE *) pIH;
    CreateDispatchTables();
    fAllRpcSS           = FALSE;
    fUsesRpcSS          = FALSE;
    pIntfName           = pName;
    fHasPipes           = FALSE;
    fVisited            = FALSE;

    fLocal            = GetType()->FInSummary( ATTR_LOCAL );
    fHasMSConfStructAttr = FALSE;
    //
    // For now.
    //

    ProtSeqEPCount      = 0;

    pStubDescName = new char[ strlen(STUB_DESC_STRUCT_VAR_NAME) +
                              strlen(pName) + 1 ];

    strcpy( pStubDescName, pName );
    strcat( pStubDescName, STUB_DESC_STRUCT_VAR_NAME );

    pSyntaxInfoName = new char [strlen(MIDL_SYNTAX_INFO_VAR_NAME) +
                                strlen(pName) + 1];

    strcpy( pSyntaxInfoName, pName );
    strcat( pSyntaxInfoName, MIDL_SYNTAX_INFO_VAR_NAME );

    pProxyInfoName = new char [strlen(MIDL_PROXY_INFO_VAR_NAME) + 
                               strlen(pName) + 1];

    strcpy( pProxyInfoName, pName );
    strcat( pProxyInfoName, MIDL_PROXY_INFO_VAR_NAME );
}


CG_STATUS
CG_INTERFACE::GenClientInfo(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code for the file node.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    unsigned short      M,m;            // for MAJOR and minor versions :-)
    CG_ITERATOR         I;
    CG_PROC         *   pCG;
    CG_HANDLE       *   pCGHandle   = GetImplicitHandle();
    node_skl        *   pID;
    char                Buffer[_MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT+1];
    short               CallbackCount;
    ISTREAM         *   pStream = pCCB->GetStream();
    int                 ProtSeqEPCount = 0;
    ITERATOR        *   pProtSeqIterator;
    char            *   pCStubPrefix;

    //Initialize the CCB for this interface.
    InitializeCCB(pCCB);

    pCCB->SetImplicitHandleIDNode( 0 );

    if( !GetMembers( I ) )
        {
        return CG_OK;
        }

    //
    // Emit the external variables needed.
    //
    if ( HasInterpretedCallbackProc() )
        Out_InterpreterServerInfoExtern( pCCB );

    if ( pCommand->NeedsNDR64Run() )
        Out_ProxyInfoExtern( pCCB );

    pStream->NewLine();

    if( pCGHandle )
        {
        pID = pCGHandle->GetHandleIDOrParam();
        pID->PrintType( PRT_ID_DECLARATION, pStream, 0 );
        }


    //
    // Emit the protseq endpoint structure if necessary. It is not
    // necessary if the endpoint attribute was not specified in which 
    // case the ep count is 0.
    //

    if ( ( pProtSeqIterator = GetProtSeqEps() ) != 0 )
        {
        ProtSeqEPCount = ITERATOR_GETCOUNT( *pProtSeqIterator );
        Out_EP_Info( pCCB, pProtSeqIterator );
        }

    //
    // Emit the interface information structure.
    //

    pCCB->GetVersion( &M,&m );

    CallbackCount = ((node_interface *)GetType())->GetCallBackProcCount();

    if( CallbackCount )
        {
        sprintf( Buffer, 
                "extern %s %s%s%s%_DispatchTable;",
                RPC_DISPATCH_TABLE_TYPE_NAME,
                pCCB->GetInterfaceName(),
                pCommand->IsNDR64Run()?"_NDR64_":"",
                pCCB->GenMangledName() );

        pStream->NewLine( 2 );
        pStream->Write( Buffer );

        /// NOTE:: This buffer is printed in the Out_IfInfo call !!!!
        sprintf( Buffer,
                 "&%s%s%s_DispatchTable",
                 pCCB->GetInterfaceName(),
                 pCommand->IsNDR64Run()?"_NDR64_":"",
                 pCCB->GenMangledName() );
        
        }
    
    //
    // Must set this before outputing the interface info.
    //
    pCCB->SetCodeGenSide( CGSIDE_CLIENT );

    Out_IFInfo( pCCB,                           // controller block.
                RPC_C_INT_INFO_TYPE_NAME,       // interface info type name.
                RPC_C_INT_INFO_STRUCT_NAME,     // variable name.
                SIZEOF_RPC_CLIENT_INTERFACE,    // string speicifying size.

                GuidStrs,                       // Guid specified in idl
                M,                              // user specified major version
                m,                              // user specified minor version
//              TransferSyntaxGuidStrs,         // ndr identifying guid.
//              NDR_UUID_MAJOR_VERSION,         // ndr's version
//              NDR_UUID_MINOR_VERSION,

                CallbackCount ? Buffer : 0,     // call back dispatch table name
                ProtSeqEPCount,                 // if this is 0, then the next
                                                // 2 fields are ignored by 
                                                // the call.
                PROTSEQ_EP_TYPE_NAME,           // RPC_PROTSEQ_ENDPOINT
                PROTSEQ_EP_VAR_NAME,            // ___RpcProtSeqEndpoint
                pCCB->IsNoDefaultEpv(),
                0,                              // client side
                HasPipes()
              );


    if ( (pCStubPrefix = pCommand->GetUserPrefix( PREFIX_CLIENT_STUB ) ) == 0 )
        {
        pCStubPrefix = "";
        }

    pStream->NewLine();
    sprintf( Buffer,
            "RPC_IF_HANDLE %s%s%s_%s = (RPC_IF_HANDLE)& %s" RPC_C_INT_INFO_STRUCT_NAME";",
            pCStubPrefix,
            pCCB->GetInterfaceName(),
            pCCB->GenMangledName(),
            ((pCCB->IsOldNames()) ? "ClientIfHandle" : "c_ifspec"),
            pCCB->GetInterfaceName()
           );
    pStream->Write( Buffer );

    //
    // Emit the stub descriptor extern declaration.
    //
    Out_StubDescriptorExtern( pCCB );

    //
    // Check for use of [enable_allocate]
    // Use in ms_ext when explicit, in osf always, to cover some weird cases.
    //

    if ( GetUsesRpcSS() || pCCB->InOSFMode() )
        pCCB->SetMallocAndFreeStructExternEmitted();

    // Emit the auto handle extern

    pStream->NewLine();
    sprintf( Buffer,
             "static %s %s%s;",
             AUTO_BH_TYPE_NAME,
             pCCB->GetInterfaceName(),
             AUTO_BH_VAR_NAME
           );

    pStream->Write( Buffer );

    pStream->NewLine();

    //
    // Send the message to the children to emit code.
    //

    //
    // for all procedure in this interface, generate code.
    //

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pCG->GenClientStub( pCCB );
        }

    return CG_OK;
}



void
CG_INTERFACE::Out_ProcOffsetTable( CCB *pCCB, BOOL IsForCallback )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output a table of offsets to procedure information in the format 
    string/structure.
    
 Arguments:
    
    pCCB            - a pointer to the code generation control block.
    IsForCallback   - Is this is a table of callback offsets?

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *pStream = pCCB->GetStream();

    if ( pCommand->IsNDR64Run() )
        pStream->WriteOnNewLine( "static const FormatInfoRef " );
    else
        pStream->WriteOnNewLine( "static const unsigned short " );

    if ( IsForCallback )
        pStream->Write( MIDL_CALLBACK_VAR_NAME );
    
    pStream->Write( GetSymName() );
    
    if ( pCommand->IsNDR64Run() )
        pStream->Write( "_Ndr64ProcTable[] =" );
    else
        pStream->Write( "_FormatStringOffsetTable[] =" );

    pStream->IndentInc();
    pStream->WriteOnNewLine( '{' );
    pStream->NewLine();

    OutputProcOffsets( pCCB, TRUE, IsForCallback );

    pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine( 2 );

    // If we need a table of callbacks also, recursively call ourselves

        if ( !IsForCallback && HasInterpretedCallbackProc() )
            Out_ProcOffsetTable( pCCB, TRUE );
}



CG_STATUS
CG_INTERFACE::OutputClientStub(
    CCB *   pCCB )
{
    CG_ITERATOR I;

    if( !GetMembers( I ) )
        {
        return CG_OK;
        }

    //Initialize the CCB for this interface.
    InitializeCCB(pCCB);

    // Output a table containing the offsets of each proc description for this
    // interface in the format info string/struct.  Output another table for 
    // callbacks if needed.

    Out_ProcOffsetTable( pCCB );

    //
    // Emit the stub descriptor and all that is specific to the interface,
    // Generate externs to tables that may be common to several interfaces.
    //

    Out_StubDescriptor( GetImplicitHandle(), pCCB );

    if ( pCommand->NeedsNDR64Run() )
        Out_ProxyInfo( pCCB, FALSE );

    //
    // Generate the dispatch table.
    //

    short CallbackCount = ( (node_interface *) GetType() )
                                            ->GetCallBackProcCount();
    if( CallbackCount )
        {
        ITERATOR    ProcList;

        GetCallbackProcedureList( ProcList, DTF_NONE );
        Out_DispatchTableStuff( pCCB,   
                                ProcList,
                                CallbackCount
                              );
        }

    if ( HasInterpretedCallbackProc() )
        {
        GenSyntaxInfo( pCCB, TRUE );
        Out_InterpreterServerInfo( pCCB, CGSIDE_CLIENT );
        }

    return CG_OK;
}



CG_STATUS
CG_INTERFACE::GenServerInfo(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code for the interface node.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    unsigned short      M,m;            // for MAJOR and minor versions :-)
    CG_PROC *           pCG;
    CG_ITERATOR         I;
    char                Buffer[ _MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1 ];
    ISTREAM *           pStream = pCCB->GetStream();
    ITERATOR    *       pProtSeqIterator;
    node_interface *    pInterface = (node_interface *)GetType();
    char            *   pSStubPrefix;

    InitializeCCB(pCCB);

    if( !GetMembers( I ) )
        {
        return CG_OK;
        }


    //
    // Emit the external variables needed.
    //
    if ( HasInterpretedProc() )
        Out_InterpreterServerInfoExtern( pCCB );

    //
    // Emit the protseq endpoint structure if necessary. It is not
    // necessary if the endpoint attribute was not specified in which 
    // case the ep count is 0.
    //

    if ( ( pProtSeqIterator = GetProtSeqEps() ) != 0 )
        {
        ProtSeqEPCount = ITERATOR_GETCOUNT( *pProtSeqIterator );
        Out_EP_Info( pCCB, pProtSeqIterator );
        }

    //
    // Emit the interface information structure.
    //

    pCCB->GetVersion( &M,&m );

    //
    // Emit the extern decl for the server's dispatch table, which goes
    // in the server interface structure which follows.
    //
    sprintf( Buffer, 
             "extern %s %s%s%s_DispatchTable;",
             RPC_DISPATCH_TABLE_TYPE_NAME,
             pCCB->GetInterfaceName(),
             pCommand->IsNDR64Run()?"_NDR64_":"",
             pCCB->GenMangledName() );

    pStream->NewLine( 2 );
    pStream->Write( Buffer );

    //
    // Emit the extern decl for the server side manager epv table, which goes
    // in the server interface structure which follows.
    //

    if( pCCB->IsMEpV()  &&
       !pCCB->IsNoDefaultEpv() &&
       (pInterface->GetProcCount() != 0) )
        {
        sprintf( Buffer, 
                "extern %s%s_%s DEFAULT_EPV;",
                pCCB->GetInterfaceName(),
                pCCB->GenMangledName(), 
                pCCB->IsOldNames() ? "SERVER_EPV" : "epv_t" );

        pStream->NewLine( 2 );
        pStream->Write( Buffer );
        }

    // Prepare address string for the address of the dispatch table in the
    // interface information structure.

    sprintf( Buffer,
             "&%s%s%s_DispatchTable",
             pCCB->GetInterfaceName(),
             pCommand->IsNDR64Run()?"_NDR64_":"",
             pCCB->GenMangledName()
           );

    //
    // Must set this before outputing the interface info.
    //
    pCCB->SetCodeGenSide( CGSIDE_SERVER );

    Out_IFInfo( pCCB,                           // controller block.
                RPC_S_INT_INFO_TYPE_NAME,       // interface info type name.
                RPC_S_INT_INFO_STRUCT_NAME,     // variable name.
                SIZEOF_RPC_SERVER_INTERFACE,    // string speicifying size.
                GuidStrs,                       // Guid specified in idl
                M,                              // user specified major version
                m,                              // user specified minor version
//              TransferSyntaxGuidStrs,         // ndr identifying guid.
//              NDR_UUID_MAJOR_VERSION,         // ndr's version
//              NDR_UUID_MINOR_VERSION,

                Buffer,
                ProtSeqEPCount,                 // if this is 0, then the next
                                                // 2 fields are ignored by 
                                                // the call.
                PROTSEQ_EP_TYPE_NAME,           // RPC_PROTSEQ_ENDPOINT
                PROTSEQ_EP_VAR_NAME,            // ___RpcProtSeqEndpoint
                pCCB->IsNoDefaultEpv(),
                1,
                HasPipes()
              );

    if ( (pSStubPrefix = pCommand->GetUserPrefix( PREFIX_SERVER_MGR ) ) == 0 )
        {
        pSStubPrefix = "";
        }

    pStream->NewLine();
    sprintf( Buffer,
            "RPC_IF_HANDLE %s%s%s_%s = (RPC_IF_HANDLE)& %s"
                            RPC_S_INT_INFO_STRUCT_NAME";",
            pSStubPrefix,
            pCCB->GetInterfaceName(),
            pCCB->GenMangledName(),
            ((pCCB->IsOldNames()) ? "ServerIfHandle" : "s_ifspec"),
            pCCB->GetInterfaceName()
           );
    pStream->Write( Buffer );

    //
    // Emit the stub descriptor extern declaration.
    //
    Out_StubDescriptorExtern( pCCB );

    //
    // Check for use of [enable_allocate]
    //

    if ( GetUsesRpcSS() && !pCCB->InOSFMode() )
        pCCB->SetMallocAndFreeStructExternEmitted();

    // has callback and Needsndr64: we need to generate proxy info for callback's
    // client stub. 
    if ( HasInterpretedCallbackProc() )
        Out_ProxyInfoExtern( pCCB );        

    //
    // Send the message to the children to emit code.
    //

    //
    // For all procedures in this interface, generate code.
    //

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pCG->GenServerStub( pCCB );
        }

    return CG_OK;
}



CG_STATUS
CG_INTERFACE::OutputServerStub(
    CCB *   pCCB )
{
    CG_ITERATOR I;

    if( !GetMembers( I ) )
        {
        return CG_OK;
        }

    short               NormalProcCount;
    ITERATOR            NormalProcList;

    InitializeCCB( pCCB );

    // For procs that return complex types (structures, floating point, etc)
    // we need to have a thunk that takes a pointer to where to store this
    // type.

    OutputComplexReturnThunks( pCCB );

    // Output a table containing the offsets of each proc description for this
    // interface in the format info string/struct.  Output another table for 
    // callbacks if needed.

    Out_ProcOffsetTable( pCCB );

    //
    // Emit the stub descriptor.
    //

    if ( HasInterpretedProc() ) 
        pCCB->SetOptimOption( unsigned short( pCCB->GetOptimOption() | OPTIMIZE_INTERPRETER ) );


    Out_StubDescriptor( GetImplicitHandle(), pCCB );

    //
    // Generate the dispatch table.
    //

    NormalProcCount = GetNormalProcedureList( NormalProcList,
                                              DTF_NONE  
                                            );
    if( NormalProcCount )
        Out_DispatchTableStuff( pCCB,   
                                NormalProcList,
                                NormalProcCount
                              );

    // Generate the manager epv if the -use epv switch has been specified.

    if( pCCB->IsMEpV() && !pCCB->IsNoDefaultEpv() )
        {
        ITERATOR    ProcList;
        short       Count;

        Count = GetNormalProcedureList( ProcList,
                                        DTF_NONE
                                      );

        if( Count )
            {
            Out_ManagerEpv( pCCB, pCCB->GetInterfaceName(), ProcList, Count );
            }
        }

    if ( pCommand->NeedsNDR64Run() )
        {
        GenSyntaxInfo( pCCB, FALSE );
        if ( pCCB->GetInterfaceCG()->HasInterpretedCallbackProc() )
            Out_ProxyInfo( pCCB, TRUE );
        }

    if ( HasInterpretedProc() )
        Out_InterpreterServerInfo( pCCB, CGSIDE_SERVER );
 
    return CG_OK;
}



void 
CG_INTERFACE::OutputComplexReturnThunks(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    For procs that return complex types (structures, floating point, etc
    we need to have a thunk that takes a pointer to where to store this
    type.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Notes:
    
    The thunk looks like:

        void Proc_ComplexThunk(..., ReturnType *_RetVal)
        {
            *_RetVal = Proc(...);
        }

 REVIEW: 

    Integrate this with NeedsServerThunk stuff

----------------------------------------------------------------------------*/
{
    if ( CGSIDE_SERVER != pCCB->GetCodeGenSide() )
        return;

    if ( !pCommand->IsFinalProtocolRun() )
        return;

    ISTREAM    *pStream = pCCB->GetStream();
    ITERATOR    procs;
    CG_PROC    *procCG;

    GetMembers( procs );

    while ( ITERATOR_GETNEXT( procs, procCG ) )
        {
        if ( ! procCG->HasComplexReturnType() || procCG->HasAsyncHandle() )
            continue;


        ITERATOR        params;
        short           nParams;
        expr_proc_call *pCall = new expr_proc_call( procCG->GetSymName() );
        expr_node      *pExpr;
        CG_PARAM       *param;

        procCG->GetMembers( params );
        nParams = ITERATOR_GETCOUNT( params );

        for ( int i = 0; i < nParams - 1; i++ )
            {
            ITERATOR_GETNEXT( params, param );
            pCall->SetParam( new expr_variable( param->GetResource()->GetResourceName() ) );
            }

        node_proc  *proc = new node_proc( (node_proc *) procCG->GetType() );
        node_param *pParam;
        node_skl   *pVoid;
        node_skl   *pOldChild;

        char *pProcName = (char *) alloca(
                                        strlen( proc->GetSymName() ) 
                                        + sizeof( "_ComplexThunk" ) );

        strcpy( pProcName, proc->GetSymName() );
        strcat( pProcName, "_ComplexThunk" );
        proc->SetSymName( pProcName );
        
        // REVIEW: A lot of this is cruft, clean it up!

        GetBaseTypeNode( &pVoid, SIGN_UNDEF, SIZE_UNDEF, TYPE_VOID, ATTR_NONE );
        pParam = new node_param;
        pParam->SetSymName( RETURN_VALUE_VAR_NAME );
        pParam->SetChild( new node_pointer( proc->GetChild() ) );
        pParam->GetChild()->GetModifiers().SetModifier( ATTR_TAGREF );
        pOldChild = proc->GetChild();
        proc->SetChild( pVoid );
//        proc->SetHasComplexReturnType( FALSE );
        proc->RemoveAttribute( ATTR_PTR_KIND );
        proc->AddLastMember( pParam );

        pExpr = new expr_assign(new expr_variable( "*" RETURN_VALUE_VAR_NAME ), pCall );

        pStream->NewLine( 2 );
        proc->PrintType( PRT_DECL, pStream );
        pStream->WriteOnNewLine( "{" );
        pStream->IndentInc();
        pStream->NewLine();
        pExpr->PrintCall( pStream, 0, 0 );
        pStream->IndentDec();
        pStream->WriteOnNewLine( "}" );

        proc->RemoveLastMember();
        proc->SetChild( pOldChild );
        }
}
    


CG_STATUS
CG_INTERFACE::GenHeader(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate interface header file.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error other wise.

 Notes:
    

----------------------------------------------------------------------------*/
{
    node_interface *    pInterface = (node_interface *) GetType();
    ITERATOR            I;
    ITERATOR            J;
    char                Buffer[ _MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1 ];
    CG_HANDLE *         pCGHandle   = GetImplicitHandle();
    node_skl *          pID;
    ISTREAM *           pStream = pCCB->GetStream();
    unsigned short      M, m;
    char            *   pCStubPrefix;
    char            *   pSStubPrefix;
    char            *   pName   = pInterface->GetSymName();
    BOOL                fAnonymous  = IsTempName( pName );

    //Initialize the CCB for this interface.
    InitializeCCB(pCCB);

    // put out the interface guards
    if ( !fAnonymous )
        {
        pStream->Write("\n#ifndef __");
        pStream->Write( pName );
        pStream->Write( "_INTERFACE_DEFINED__\n" );

        pStream->Write( "#define __");
        pStream->Write( pName );
        pStream->Write( "_INTERFACE_DEFINED__\n" );
        }

    // Print out the declarations of the types and the procedures.
    // If the user defined a prefix for the cstub or sstub,
    // then emit prototypes with the prefix in them.

    pStream->NewLine();
    pInterface->PrintType( 
            PRT_INTERFACE | PRT_BOTH_PREFIX | PRT_OMIT_CS_TAG_PARAMS, 
            pStream, 
            0 );

    if( pCGHandle )
        {
        pID = pCGHandle->GetHandleIDOrParam();
        pStream->NewLine();
        pStream->Write( "extern " );
        pID->PrintType( PRT_ID_DECLARATION, pStream, 0 );
        }

    // Emit the declarations for user supplied routines.


    // Print out the dispatch table.

    pStream->NewLine();
    GetNormalProcedureList( I, DTF_NONE );

    if( pCCB->IsMEpV() )
        {
        if( ITERATOR_GETCOUNT(I) )
            Out_DispatchTableTypedef(
                                    pCCB,
                                    pCCB->GetInterfaceName(),
                                    I,
                                    0
                                    );
        }

    GetCallbackProcedureList( J, DTF_NONE );

    if( ITERATOR_GETCOUNT(J ) )
        Out_DispatchTableTypedef(
                                pCCB,
                                pCCB->GetInterfaceName(),
                                J,
                                1
                                );
    pCCB->GetVersion( &M, &m );

    if ( (pCStubPrefix = pCommand->GetUserPrefix( PREFIX_CLIENT_STUB ) ) == 0 )
        {
        pCStubPrefix = 0;
        }
    if ( (pSStubPrefix = pCommand->GetUserPrefix( PREFIX_SERVER_MGR ) )  == 0 )
        {
        pSStubPrefix = 0;
        }

    // Generate the extern for the client if handle.

    pStream->NewLine();
    sprintf( Buffer, "extern RPC_IF_HANDLE %s%s%s_%s;", 
             (pCStubPrefix == 0) ? "" : pCStubPrefix,
             pCCB->GetInterfaceName(),
             pCCB->GenMangledName(),
             (pCCB->IsOldNames()) ? "ClientIfHandle" : "c_ifspec" );
    pStream->Write( Buffer );

    // If a prefix is defined for cstub, generate another extern for the
    // non - prefixed client if handle. Remember, in the header file we need
    // both the externs, since the header file generated out of the -prefix
    // cstub invocation contains prototypes for both prefixed and non-prefix
    // stuff.

    if( pCStubPrefix )
        {
        pStream->NewLine();
        sprintf( Buffer, "extern RPC_IF_HANDLE %s%s%s_%s;", 
                 "",
                 pCCB->GetInterfaceName(),
                 pCCB->GenMangledName(),
                 (pCCB->IsOldNames()) ? "ClientIfHandle" : "c_ifspec" );
        pStream->Write( Buffer );
        }

    pStream->NewLine();
    sprintf( Buffer, "extern RPC_IF_HANDLE %s%s%s_%s;", 
             (pSStubPrefix == 0) ? "" : pSStubPrefix,
             pCCB->GetInterfaceName(),
             pCCB->GenMangledName(),
             (pCCB->IsOldNames()) ? "ServerIfHandle" : "s_ifspec" );
    pStream->Write( Buffer );
    pStream->NewLine();

    // put out the trailing interface guard
    if ( !fAnonymous )
        {
        pStream->Write( "#endif /* __");
        pStream->Write( pName );
        pStream->Write( "_INTERFACE_DEFINED__ */\n" );
        }
    return CG_OK;
}



ITERATOR *
CG_INTERFACE::GetProtSeqEps()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get the protocol sequences pairs iterator.

 Arguments:

    Iterator reference.
    
 Return Value:
    
    FALSE if there are no endpoints

 Notes:

    The iterator is invalid if there are no endpoints.

----------------------------------------------------------------------------*/
{
    node_interface  *       pIntf   = (node_interface *) GetType();
    node_endpoint   *       pEps    = (node_endpoint *)
                                        pIntf->GetAttribute( ATTR_ENDPOINT );

    return ( pEps ) ? &(pEps->GetEndPointPairs()) : NULL;

}


void
CG_INTERFACE::CreateDispatchTables()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Set up the stub dispatch tables.

 Arguments:

    None.
    
 Return Value:
    
    None.

 Notes:

----------------------------------------------------------------------------*/
{

    pNormalDispatchTable    = new DISPATCH_TABLE();
    pCallbackDispatchTable  = new DISPATCH_TABLE();

    ppDispatchTableSaved = ppDispatchTable = &pNormalDispatchTable;

}

BOOL
CG_INTERFACE::HasInterpretedProc()
{
    CG_ITERATOR    Iterator;
    CG_PROC *   pProc;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        if ( pProc->GetOptimizationFlags() & OPTIMIZE_INTERPRETER ) 
            return TRUE;

    return FALSE;
}

BOOL
CG_INTERFACE::HasOnlyInterpretedProcs()
{
    CG_ITERATOR     Iterator;
    CG_PROC *       pProc;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        if ( (pProc->GetOptimizationFlags() & OPTIMIZE_INTERPRETER ) == 0 ) 
            return FALSE;

    return TRUE;
}

BOOL
CG_OBJECT_INTERFACE::HasOnlyInterpretedMethods()
{
    CG_ITERATOR             Iterator;
    CG_PROC *               pProc;
    CG_OBJECT_INTERFACE*    pBaseCG = (CG_OBJECT_INTERFACE*) GetBaseInterfaceCG();
    if ( pBaseCG && !pBaseCG->HasOnlyInterpretedMethods() )
        return FALSE;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        if ( (pProc->GetOptimizationFlags() & OPTIMIZE_INTERPRETER ) == 0 ) 
            return FALSE;

    return TRUE;
}

BOOL
CG_INTERFACE::HasItsOwnOi2()
{
    CG_ITERATOR     Iterator;
    CG_PROC *       pProc;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        if ( (pProc->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2)  ) 
            return TRUE;

    return FALSE;
}

void
CG_INTERFACE::EvaluateVersionControl()
{
    if ( HasItsOwnOi2() )
        {
        GetNdrVersionControl().SetHasOi2();
        }
}

BOOL
CG_OBJECT_INTERFACE::HasItsOwnStublessProxies()
{
    CG_ITERATOR     Iterator;
    CG_PROC *       pProc;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        if (pProc->GetOptimizationFlags() & OPTIMIZE_STUBLESS_CLIENT ) 
            return TRUE;

    return FALSE;
}

void
CG_OBJECT_INTERFACE::EvaluateVersionControl()
{
    CG_OBJECT_INTERFACE*    pBaseCG = (CG_OBJECT_INTERFACE*) GetBaseInterfaceCG();
    if ( pBaseCG )
        {
        pBaseCG->EvaluateVersionControl();
        }

    if ( HasItsOwnStublessProxies()  ||
         pBaseCG  &&  pBaseCG->HasStublessProxies() )
        {
        GetNdrVersionControl().SetHasStublessProxies();
        }

    if ( HasItsOwnOi2()  ||
         pBaseCG  &&  pBaseCG->HasOi2() )
        {
        GetNdrVersionControl().SetHasOi2();
        }
}


BOOL
CG_INTERFACE::HasInterpretedCallbackProc()
{
    CG_ITERATOR    Iterator;
    CG_PROC *   pProc;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        if ( pProc->GetCGID() == ID_CG_CALLBACK_PROC &&
             pProc->GetOptimizationFlags() & OPTIMIZE_INTERPRETER ) 
            return TRUE;

    return FALSE;
}

BOOL
CG_INTERFACE::HasClientInterpretedCommOrFaultProc( CCB * pCCB )
{
    CG_ITERATOR Iterator;
    CG_PROC *   pProc;
    CGSIDE      Side;

    Side = pCCB->GetCodeGenSide();

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        if ( (pProc->GetOptimizationFlags() & OPTIMIZE_INTERPRETER) &&
             pProc->HasStatuses() && 
             ( ((pProc->GetCGID() == ID_CG_PROC) && (Side == CGSIDE_CLIENT)) ||
               ((pProc->GetCGID() == ID_CG_CALLBACK_PROC) && (Side == CGSIDE_SERVER)) ) ) 
            return TRUE;

    return FALSE;
}

CG_STATUS
CG_INTERFACE::InitializeCCB( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Initialize the CCB for this interface.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    unsigned short      Major,minor;    
    node_interface *pInterface = (node_interface *) GetType();

    pInterface->GetVersionDetails(&Major, &minor);
    pCCB->SetVersion(Major, minor);
    pCCB->SetInterfaceName(pInterface->GetSymName());
    pCCB->SetInterfaceCG(this);

    return CG_OK;
}


void
CG_INTERFACE::OutputProcOffsets( CCB * pCCB, BOOL fLast, BOOL IsForCallback )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output a list of offsets (from the beginning of the proc format info)
    to each proc in the interface

 Arguments:
    
    pCCB            - a pointer to the code generation control block.
    fLast           -
    IsForCallback   -

 Notes:

    For Ndr32 the list is a table of shorts that offset from the beginning
    of the proc format string.

    For Ndr64 it is a table of longs that is the offset from the format info 
    structure.

----------------------------------------------------------------------------*/
{
    CG_PROC *   pProc;
    CG_ITERATOR    Iterator;
    ISTREAM *   pStream     = pCCB->GetStream();
    CGSIDE      Side;
    long        Offset;

    // IUnknown doesn't get entries in the proc offsets table
    if ( IsIUnknown() )
        {
        if ( fLast )
            {
            pStream->Write( '0' );
            pStream->NewLine();
            }
        return;
        }

    Side = pCCB->GetCodeGenSide();

    if ( IsObject() )
        {
        CG_OBJECT_INTERFACE * pObjInterface;

        pObjInterface = (CG_OBJECT_INTERFACE *) this;

        if ( pObjInterface->GetBaseInterfaceCG() )
            {
            pObjInterface->GetBaseInterfaceCG()->OutputProcOffsets( pCCB, FALSE, IsForCallback );
            }
        } 

    GetMembers( Iterator );

    BOOL fNoOffsetsEmitted = TRUE;

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        {
        if ( (Side == CGSIDE_CLIENT) &&
            ( IsForCallback ? ( pProc->GetCGID() != ID_CG_CALLBACK_PROC ) :
             (pProc->GetCGID() == ID_CG_CALLBACK_PROC) ) )
            continue;

        if ( (Side == CGSIDE_SERVER) &&
             ( ( IsForCallback ? ( pProc->GetCGID() != ID_CG_CALLBACK_PROC ) :
               ( pProc->GetCGID() == ID_CG_CALLBACK_PROC )  )
               || (pProc->GetCGID() == ID_CG_TYPE_ENCODE_PROC ) ) )
            continue;

        CG_PROC *pTargetProc = pProc;

        if ( fLocal )
            pTargetProc = pProc->GetCallAsCG();

        // type encode procs are not real procs

        if ( dynamic_cast<CG_TYPE_ENCODE_PROC *>(pTargetProc) )
            continue;

        fNoOffsetsEmitted = FALSE;

        // REVIEW: If Offset is -1 (dce) or 0 (ndr64) then we haven't generated
        //         format info for the proc.  This can only happen in certain
        //         conditions ([nocode], methods in parent interface).  There
        //         should be an assert.

        if ( pCommand->IsNDR64Run() )
            {
            Offset = 0;
            if ( pTargetProc )
                Offset = (long) (size_t) pCCB->GetNdr64Format()->GetRoot()
                                        ->LookupFragmentID( pTargetProc );

            if ( 0 == Offset )
                pStream->Write( "(FormatInfoRef) -1" );
            else
                pStream->WriteNumber( "&__midl_frag%d", Offset );
            }
        else
            {
            Offset = -1;
            if ( pTargetProc )
                Offset = pTargetProc->GetFormatStringOffset();

            if ( -1 == Offset )
                pStream->Write( "(unsigned short) -1" );
            else
                pStream->WriteNumber( "%d", Offset );
            }

        if ( pProc->GetSibling() || !fLast )
            pStream->Write( ',' );

        pStream->NewLine();
        }

    if ( fNoOffsetsEmitted && fLast )
        {
        pStream->Write( '0' );
        pStream->NewLine();
        }
}

void
CG_INTERFACE::OutputThunkTableEntries( CCB * pCCB, BOOL fLast )
{
    CG_PROC *   pProc;
    CG_ITERATOR Iterator;
    ISTREAM *   pStream     = pCCB->GetStream();
    CGSIDE      Side        = pCCB->GetCodeGenSide();
    char    *   pIntfName   = GetType()->GetSymName();

    // IUnknown doesn't get entries in the thunk table
    if ( IsIUnknown() )
        {
        if ( fLast )
            {
            pStream->Write( '0' );
            pStream->NewLine();
            }
        return;
        }

    if ( IsObject() )
        {
        CG_OBJECT_INTERFACE * pObjInterface;

        pObjInterface = (CG_OBJECT_INTERFACE *) this;

        if ( pObjInterface->GetBaseInterfaceCG() )
            {
            pObjInterface->GetBaseInterfaceCG()->OutputThunkTableEntries( pCCB, FALSE );
            }
        } 

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        {
        if ( (Side == CGSIDE_CLIENT) && 
             (pProc->GetCGID() != ID_CG_CALLBACK_PROC) )
            continue;

        if ( (Side == CGSIDE_SERVER) && 
             (pProc->GetCGID() == ID_CG_CALLBACK_PROC) )
            continue;

        if ( pProc->NeedsServerThunk( pCCB, Side ) && !pProc->IsDelegated() )
            {
            pStream->Write( pIntfName );
            pStream->Write( '_' );
            pStream->Write( pProc->GetType()->GetSymName() );

            // if( IsObject() )
                pStream->Write( "_Thunk" );
            }
        else
            pStream->Write( '0' );

        if ( pProc->GetSibling() || !fLast )
            pStream->Write( ',' );

        pStream->NewLine();
        }
}

void
CG_INTERFACE::OutputInterfaceIdComment( CCB * pCCB )
{
    char            TmpBuf[40];
    unsigned short  Major, Minor;
    ISTREAM *   pStream = pCCB->GetStream();
    char *      pIfKind = IsObject() ? "Object"
                                     : HasPicklingStuffOnly() ? "Pickling"
                                                              : "Standard";
    pStream->NewLine(2);
    sprintf( TmpBuf, "/* %s interface: ", pIfKind );
    pStream->Write( TmpBuf );
    pStream->Write( GetInterfaceName() );

    ((node_interface *) GetType())->GetVersionDetails( &Major, &Minor );
    sprintf( TmpBuf, ", ver. %d.%d,\n   GUID=", Major, Minor );
    pStream->Write( TmpBuf );

    Out_Guid( pCCB, GetGuidStrs() );
    pStream->Write( " */" );
    pStream->NewLine();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\ndr64.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1999-2000 Microsoft Corporation

 Module Name:
    
    ndr64.cxx

 Abstract:

    Routines for the ndr64 transfer syntax.

 Notes:


 History:

 ----------------------------------------------------------------------------*/


#include "becls.hxx"

char * _SimpleTypeName[] = {
    "",
    "NDR64_FORMAT_UINT8",
    "NDR64_FORMAT_UINT16",
    "NDR64_FORMAT_UINT32",
    "NDR64_FORMAT_UINT64"
};

// define the name table for the NDR64 format characters
#define NDR64_BEGIN_TABLE \
const char *pNDR64FormatCharNames[] = {

#define NDR64_TABLE_END \
};

#define NDR64_ZERO_ENTRY \
"FC64_ZERO"

#define NDR64_TABLE_ENTRY( number, tokenname, marshal, embeddedmarshall, unmarshall, embeddedunmarshal, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
, #tokenname

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, simpletypebuffersize, simpletypememorysize ) \
, #tokenname

#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) \
, #tokenname

#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number ) \
, NULL

#include "tokntbl.h"

extern const pNDR64FormatCharNamesSize = (sizeof(pNDR64FormatCharNames) / sizeof(*pNDR64FormatCharNames));

C_ASSERT( (sizeof(pNDR64FormatCharNames) / sizeof(*pNDR64FormatCharNames)) == 256 );
#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_END
#undef NDR64_ZERO_ENTRY
#undef NDR64_TABLE_ENTRY
#undef NDR64_SIMPLE_TYPE_TABLE_ENTRY
#undef NDR64_UNUSED_TABLE_ENTRY
#undef NDR64_UNUSED_TABLE_ENTRY_NOSYM


FormatFragment * GenExprFormatString(CCB *pCCB,
                         expr_node *pSizeExpr,
                         CompositeFormatFragment *FragmentList,
                         BOOL    *  IsEarly,
                         ulong *    pExprLength );


//+--------------------------------------------------------------------------
//
//  Method:     FormatFragment::OutputDescription
//
//  Synopsis:   Output a description of this fragment
//
//  Notes:      The output is in the form of a C style comment.
//              The decription is the name of the type that this fragment
//              represents.  If this fragment represents more than on type
//              because of optimization then all the types will be output.
//              
//---------------------------------------------------------------------------

void FormatFragment::OutputDescription( ISTREAM *stream )
{
    FormatFragment *frag = this;
    bool            first = true;

    stream->WriteOnNewLine( "/* " );

    do
    {
        if ( !first )
            stream->Write(", ");

        CG_CLASS   *pClass = frag->GetCGNode();
        const char *pName = NULL;

        while ( NULL != pClass && pClass->IsPointer() )
            {
            stream->Write( "*" );
            pClass = pClass->GetChild();
            }
        if ( NULL != pClass && NULL != pClass->GetType() )
            {
            pName = pClass->GetName();
            if ( pName != NULL && pName[0] == '\0' )
                pName = NULL;
            }
        if ( NULL == pName )
            pName = frag->GetTypeName();

        stream->Write( pName );

        frag = frag->pNextOptimized;
        first = false;
    }
    while ( NULL != frag );

    stream->Write( " */" );
}



//+--------------------------------------------------------------------------
//
//  Method:     CompositeFormatFragment::IsEqualTo
//
//  Synopsis:   Compare two composite fragments
//
//  Notes:      This method compares two composite fragments. Two composite
//              fragments are equal if and only if the elements of the composite
//              are equal.
//              
//---------------------------------------------------------------------------

bool CompositeFormatFragment::IsEqualTo( FormatFragment *candidate )
{
    CompositeFormatFragment *pOther = (CompositeFormatFragment *)candidate;

    FormatFragment *pCurrent        = pHead;
    FormatFragment *pCurrentOther   = pOther->pHead;

    while ( (pCurrent != NULL) &&
            (pCurrentOther != NULL) )
        {

        const type_info &frag_type      = typeid( *pCurrent );
        const type_info &other_type     = typeid( *pCurrentOther );

        if ( frag_type != other_type )
            return false;

        if ( !pCurrent->IsEqualTo( pCurrentOther ) )
            return false;

        pCurrent        = pCurrent->Next;
        pCurrentOther   = pCurrentOther->Next;

        }

    // Both lists must have the same length.
    bool bResult = ( NULL == pCurrent ) && ( NULL == pCurrentOther );

    return bResult;
}



//+--------------------------------------------------------------------------
//
//  Class:      CompositeFormatFragment::LookupFragment
//
//  Synopsis:   Find the fragment corresponding to a class
//
//  Parameters: [pClass]        -- The class
//
//  Returns:    NULL if the class has no fragment yet
//
//---------------------------------------------------------------------------

FormatFragment * CompositeFormatFragment::LookupFragment( CG_CLASS *pClass )
{
    FormatFragment *frag;
  
    // Generic handles are a special case.  They don't actually have any
    // representation in the format info.

    if ( ID_CG_GENERIC_HDL == pClass->GetCGID() )
        pClass = pClass->GetChild();

    for ( frag = pHead; NULL != frag; frag = frag->Next )
        if ( frag->pClass == pClass )
            return frag;

    return NULL;
}



//+--------------------------------------------------------------------------
//
//  Class:      CompositeFormatFragment::AddFragment
//
//  Synopsis:   Add a fragment to the list if it isn't already present
//
//  Parameters: [frag]          -- The fragment
//    
//  Returns:    The id of the fragment
//              
//  Notes:      Another way to think of this method is that it provides a
//              mapping between CG_CLASS pointers and FormatInfoRef's.
//
//---------------------------------------------------------------------------

FormatInfoRef CompositeFormatFragment::AddFragment( FormatFragment *frag )
{
    frag->Next   = NULL;
    frag->RefID  = NextRefID;
    frag->Prev   = pTail;
    frag->Parent = this;

    if ( NULL == pTail )
        pHead = frag;
    else
        pTail->Next = frag;

    pTail = frag;
    NextRefID = (FormatInfoRef) ((size_t) NextRefID + 1);

    return frag->RefID;
}



//+--------------------------------------------------------------------------
//
//  Class:      CompositeFormatFragment::OutputFragmentType
//
//  Synopsis:   Output a type declaration for this composite
//
//  Notes:      It looks like:
//
//              struct <name>
//              {
//                  <frag1 type>,
//                  <frag2 type>
//                  ...
//              }
//
//---------------------------------------------------------------------------

void CompositeFormatFragment::OutputFragmentType( CCB *pCCB )
{

    ISTREAM *stream = pCCB->GetStream();

    stream->WriteOnNewLine("struct ");
    stream->Write( GetTypeName() );
    stream->WriteOnNewLine("{");
    stream->IndentInc();

    FormatFragment *pCurrent = pHead;

    for ( pCurrent = pHead; NULL != pCurrent; pCurrent = pCurrent->Next )
        {
        if ( pCurrent->WasOptimizedOut() )
        {
            // Only top-level stuff should be optimized
            MIDL_ASSERT( NULL == GetParent() );
            continue;
        }

        pCurrent->OutputFragmentType( pCCB );
        stream->WriteFormat(" frag%d;", (size_t) pCurrent->GetRefID());
        }

    stream->IndentDec();
    stream->WriteOnNewLine("}");

}



//+--------------------------------------------------------------------------
//
//  Class:      CompositeFormatFragment::OutputFragmentData
//
//  Synopsis:   Output the initializer data for this composite
//
//  Notes:      It looks like:
//
//              {
//                  <frag1 data>,
//                  <frag2 type>
//                  ...
//              }
//
//---------------------------------------------------------------------------

void CompositeFormatFragment::OutputFragmentData( CCB *pCCB )
{
    
    ISTREAM *stream = pCCB->GetStream();

    OutputStructDataStart( pCCB );

    FormatFragment *pCurrent;
    bool FirstFragment = true;

    for ( pCurrent = pHead; NULL != pCurrent; pCurrent = pCurrent->Next )
        {
        if ( pCurrent->WasOptimizedOut() )
        {
            // Only top-level stuff should be optimized
            MIDL_ASSERT( NULL == GetParent() );
            continue;
        }

        if ( !FirstFragment )
            stream->Write(",");

        FirstFragment = false;

        pCurrent->OutputFragmentData( pCCB );

    }

    OutputStructDataEnd( pCCB );
}

//+--------------------------------------------------------------------------
//
//  Class:      CompositeFormatFragment::OptimizeFragment
//
//  Synopsis:   Try to optimize out a fragment in the format string by
//              checking to see if it is the same as some other fragment.
//
//  Parameters: [frag]     -- The fragment to optimize
//
//  Returns:    The final ID of the fragment
//              
//  Notes:      Optimization can be suppressed by the user by specifiying
//              -no_format_opt
//  
//---------------------------------------------------------------------------

FormatInfoRef CompositeFormatFragment::OptimizeFragment( FormatFragment *frag )
{
    if ( pCommand->IsSwitchDefined( SWITCH_NO_FMT_OPT ) )
        return frag->RefID;

    // Only stuff in the root composite can be optimized

    if ( ! dynamic_cast<RootFormatFragment *>(frag->GetParent()) )
        return frag->RefID;

    FormatFragment *candidate;

    for ( candidate = pHead; 
          NULL != candidate && candidate != frag; 
          candidate = candidate->Next )
        {
        const type_info &frag_type      = typeid( *frag );
        const type_info &candidate_type = typeid( *candidate );

        if ( frag_type != candidate_type )
            continue;

        if ( candidate->IsEqualTo( frag ) )
            {
            frag->RefID = candidate->RefID;
            
            while ( NULL != candidate->pNextOptimized )
                candidate = candidate->pNextOptimized;

            candidate->pNextOptimized = frag;
            frag->pPrevOptimized = candidate;

            break;
            }
        }

    return frag->RefID;
}
        
//+--------------------------------------------------------------------------
//
//  Method:     RootFormatFragement::Output
//
//  Synopsis:   Output a the whole ndr64 format structure
//
//---------------------------------------------------------------------------

void RootFormatFragment::Output( CCB *pCCB )
{
    ISTREAM *stream = pCCB->GetStream();

    stream->NewLine();

    // REVIEW: Is this the right place to output these?

    stream->WriteOnNewLine("#include \"ndr64types.h\"");
    stream->WriteOnNewLine("#include \"pshpack8.h\"");
    stream->NewLine();

    FormatFragment *pCurrent;

    for ( pCurrent = pTail; NULL != pCurrent; pCurrent = pCurrent->Prev )
        {
        if ( pCurrent->WasOptimizedOut() )
            continue;

        stream->NewLine();
        stream->WriteOnNewLine("typedef ");
        pCurrent->OutputFragmentType( pCCB );
        stream->NewLine();
        stream->WriteFormat("__midl_frag%d_t;", pCurrent->GetRefID() );
        stream->NewLine();
        stream->WriteFormat(
                    "extern const __midl_frag%d_t __midl_frag%d;", 
                    pCurrent->GetRefID(), 
                    pCurrent->GetRefID() );            
        }

    for ( pCurrent = pTail; NULL != pCurrent; pCurrent = pCurrent->Prev )
        {
        if ( pCurrent->WasOptimizedOut() )
            continue;

        stream->NewLine( 2 );
        stream->WriteFormat(
                    "static const __midl_frag%d_t __midl_frag%d =", 
                    pCurrent->GetRefID(), 
                    pCurrent->GetRefID() );            
        pCurrent->OutputFragmentData( pCCB );
        stream->Write(";");
        }

    stream->NewLine( 2 );
    stream->WriteOnNewLine("#include \"poppack.h\"");
    stream->NewLine( 2 );
}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::CreateInstance  (static)
//
//  Synopsis:   Class factory for GenNdr64Format
//
//---------------------------------------------------------------------------

GenNdr64Format * GenNdr64Format::CreateInstance( CCB *pCCB )
{
    MIDL_ASSERT( pCommand->IsNDR64Run() );

    CG_VISITOR_TEMPLATE<GenNdr64Format> *pVisitor = new CG_VISITOR_TEMPLATE<GenNdr64Format>;

	GenNdr64Format *generator = pVisitor;

    generator->pCCB     = pCCB;
    generator->pRoot    = new RootFormatFragment;
    generator->pCurrent = generator->pRoot;
    generator->pVisitor = pVisitor;

    // add a dummy entry at the beginning of format string to prevent
    // an emptry structure being generated when there is only [local] 
    // interface in an .idl file.
    MIDL_NDR_FORMAT_UINT32  * pDummy = new MIDL_NDR_FORMAT_UINT32;
    pDummy->Data = 0;
    
    generator->pRoot->AddFragment( pDummy ); 
    
    return generator;
}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::ContinueGeneration
//
//  Synopsis:   Do generation for a sub-tree. This is typically called
//              by a parent node to generate it's children so that it can
//              get offsets to the child format string indices, etc.
//
//  Parameters: pClass              -- The subtree to generate from
//              pCompositeFragment  -- The composite to generate into
//
//---------------------------------------------------------------------------


FormatInfoRef GenNdr64Format::ContinueGeneration( 
    CG_CLASS *pClass,
    CompositeFormatFragment *pComposite )
{
    CompositeFormatFragment *pOldCurrent = pCurrent;

    // Some CG classes don't have children.  Those classes should not be
    // calling ContinueGeneration on thier non-existant children.

    MIDL_ASSERT( NULL != pClass );

    // Do this here to save from every visit function from doing it.
    FormatFragment* pFrag = pComposite->LookupFragment( pClass );
    if ( NULL != pFrag )
        return pFrag->GetRefID();

    if ( NULL != pComposite )
        pCurrent    = pComposite;        

    pClass->Visit( pVisitor );

    FormatInfoRef NewFragmentID = pCurrent->LookupFragmentID( pClass );

    pCurrent    =   pOldCurrent;

    return NewFragmentID;
}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Generate
//
//  Synopsis:   External routine called to generate the string for a type.
//
//  Parameters: pClass              -- Type to generate string for.
//
//---------------------------------------------------------------------------

FormatInfoRef GenNdr64Format::Generate( CG_CLASS *pClass ) 
     {
     return ContinueGeneration( pClass, GetRoot() );
     }

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Output
//
//  Synopsis:   External routine called to output the string.
//
//  Parameters: None
//
//---------------------------------------------------------------------------
    
void GenNdr64Format::Output( )
     {
     GetRoot()->Output( pCCB );
     }


//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::ContinueGenerationInRoot
//
//  Synopsis:   Same as ContinueGeneration except switches to root.
//
//  Parameters: pClass              -- The subtree to generate from
//
//---------------------------------------------------------------------------


inline FormatInfoRef GenNdr64Format::ContinueGenerationInRoot( CG_CLASS *pClass )
{
    return ContinueGeneration( pClass, GetRoot() );
}


//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_CLASS )
//
//  Synopsis:   Default visitor that handles things that don't need any
//              handling.
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_CLASS *pClass )
{
    // Should only be called for these classes or drived ones
/*
    assert(
        NULL != dynamic_cast<CG_AUX *>(pClass) 
          );
*/

    CG_ITERATOR Iterator;
    CG_CLASS    *pChild;

    pClass->GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pChild ) )
        ContinueGenerationInRoot( pChild );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_BASETYPE )
//
//  Synopsis:   Generate info for base types and ranges
//
//  Notes:      FC64_BYTE, FC64_CHAR, FC64_WCHAR, FC64_SMALL, FC64_USMALL,
//              FC64_SHORT, FC64_USHORT, FC64_LONG, FC64_ULONG, FC64_HYPER, FC64_UHYPER,
//              FC64_INT3264, FC64_UINT3264, FC64_FLOAT, FC64_DOUBLE, 
//              FC64_ERROR_STATUS_T
//
//              (also, pending support elsewhere)
//
//              FC64_INT128, FC64_UINT128, FC64_FLOAT128, FC64_FLOAT80
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_BASETYPE *pClass )
{
    if ( pClass->GetRangeAttribute() )
        {
        GenRangeFormat( pClass );
        return;
        }

    MIDL_NDR64_FORMAT_CHAR *frag = new MIDL_NDR64_FORMAT_CHAR( pClass );

    GetCurrent()->AddFragment( frag );
    GetRoot()->OptimizeFragment( frag );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenRangeFormat
//
//  Synopsis:   Ranges are a special case of base types so we can't
//              distinguish between them polymorphically.  The base type
//              visitor method calls this if we have a range.
//
//---------------------------------------------------------------------------

void GenNdr64Format::GenRangeFormat( CG_BASETYPE *pRangeCG )
{
    MIDL_NDR64_RANGE_FORMAT    *format;
    node_range_attr            *range;

    format = new MIDL_NDR64_RANGE_FORMAT( pRangeCG );

    range = pRangeCG->GetRangeAttribute();
    MIDL_ASSERT( NULL != range );

    format->FormatCode   = FC64_RANGE;
    format->RangeType    = (NDR64_FORMAT_CHAR)pRangeCG->GetNDR64FormatChar();
    format->Reserved     = 0;
    format->MinValue     = range->GetMinExpr()->GetValue();
    format->MaxValue     = range->GetMaxExpr()->GetValue();

    GetCurrent()->AddFragment( format );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_ENCAPSULATED_STRUCT )
//
//  Synopsis:   Despite the name, this is for generating info for 
//              encapsulated unions
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_ENCAPSULATED_STRUCT *pEncapUnion )
{

    // A union is represented in the format info by a composite containing
    // the union header follow by fragments representing the arm selector

    CompositeFormatFragment *composite = new CompositeFormatFragment( pEncapUnion );

    GetCurrent()->AddFragment( composite );

    MIDL_NDR64_ENCAPSULATED_UNION *format;

    format = new MIDL_NDR64_ENCAPSULATED_UNION( pEncapUnion );

    composite->AddFragment( format );

    CG_FIELD    *pSwitchField = (CG_FIELD *) pEncapUnion->GetChild();
    CG_BASETYPE *pSwitch      = (CG_BASETYPE *) pSwitchField->GetChild();
    CG_FIELD    *pUnionField  = (CG_FIELD *) pSwitchField->GetSibling();
    CG_UNION    *pUnion       = (CG_UNION *) pUnionField->GetChild();

    MIDL_ASSERT( NULL != dynamic_cast<CG_BASETYPE *>(pSwitch) );
    MIDL_ASSERT( NULL != pUnion && NULL != dynamic_cast<CG_UNION *>(pUnion) );

    format->FormatCode      = FC64_ENCAPSULATED_UNION;         
    format->Alignment       = ConvertAlignment( pEncapUnion->GetWireAlignment() );
    format->Flags           = 0;
    format->SwitchType      = (NDR64_FORMAT_CHAR)pSwitch->GetNDR64SignedFormatChar();
    format->MemoryOffset    = pUnionField->GetMemOffset() 
                                        - pSwitchField->GetMemOffset();
    format->MemorySize      = pEncapUnion->GetMemorySize();
    format->Reserved        = 0;

    GenerateUnionArmSelector( pUnion, composite );    
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenerateUnionArmSelector
//
//  Synopsis:   Generate info about union arms
//
//---------------------------------------------------------------------------

void GenNdr64Format::GenerateUnionArmSelector( 
        CG_UNION                *pUnion, 
        CompositeFormatFragment *FragmentList )
{
    MIDL_NDR64_UNION_ARM_SELECTOR *header;

    header = new MIDL_NDR64_UNION_ARM_SELECTOR;

    header->Reserved1            = 0;
    header->Alignment            = ConvertAlignment( pUnion->GetWireAlignment() );
    header->Reserved2            = 0;
    header->Arms                 = (NDR64_UINT32) pUnion->GetNumberOfArms();

    FragmentList->AddFragment( header );

    // Generate the non-default arms

    CG_ITERATOR  Iterator;
    CG_CASE     *pCase;
    CG_CASE     *pDefaultCase = NULL;
    NDR64_UINT16 ArmCount = 0;

    pUnion->GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pCase ) )
        {   
        // The default case is always put at the end

        if ( ID_CG_DEFAULT_CASE == pCase->GetCGID() )
            {
            pDefaultCase = pCase;
            continue;
            }

        MIDL_NDR64_UNION_ARM *arm = new MIDL_NDR64_UNION_ARM;

        MIDL_ASSERT( NULL != pCase->GetExpr() );

        arm->CaseValue = pCase->GetExpr()->GetValue();

        // it's legal to have a case with no type

        if ( NULL == pCase->GetChild() || NULL == pCase->GetChild()->GetChild() )
            arm->Type = 0;
        else
            arm->Type = ContinueGenerationInRoot( 
                                pCase->GetChild()->GetChild() );

        arm->Reserved = 0;
        FragmentList->AddFragment( arm );
        ++ArmCount;
        }

    MIDL_ASSERT( ArmCount == header->Arms );

    // Generate the default

    PNDR64_FORMAT    Type;

    if ( NULL == pDefaultCase )
        Type = (PNDR64_FORMAT) -1;
    else
        {
        CG_CLASS *pType = pDefaultCase->GetChild();

        if ( NULL != pType )
            pType = pType->GetChild();

        if ( NULL == pType )
            Type = 0;
        else
            Type = ContinueGenerationInRoot( pType );
        }

    FragmentList->AddFragment( new MIDL_NDR64_DEFAULT_CASE( Type ) );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_INTERFACE )
//
//  Synopsis:   Generate info for interfaces
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_INTERFACE *pInterface )
{
    CG_ITERATOR     I;
    CCB            *pCCB = GetCCB();
    CG_PROC        *pProc;

    pInterface->InitializeCCB( pCCB );

    pCCB->SetImplicitHandleIDNode( 0 );

	if( pInterface->GetMembers( I ) )
        while ( ITERATOR_GETNEXT( I, pProc ) )
            ContinueGenerationInRoot( pProc );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_PARAM )
//
//  Synopsis:   Generate info for parameters
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_PARAM *pParam )
{

    if ( GetCurrent()->HasClassFragment( pParam ) )
        return;

    NDR64_PARAM_FLAGS   Attributes;
    CG_NDR             *pChild;
    CG_NDR             *pOldPlaceholder;

    pChild = (CG_NDR *) pParam->GetChild();

    if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
        pChild = (CG_NDR *) pChild->GetChild();

    // Ignore the following type of arguments that don't go on wire:
    //  - async handles
    //  - primitive handles
    //  
    if ( pChild->GetCGID() == ID_CG_PRIMITIVE_HDL  || ( (CG_PARAM*) pParam)->IsAsyncHandleParam() )
        return;

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( pParam );

    // Get the parameter attributes.  The 32-bit PARAM_ATTRIBUTES structure
    // is essentially the same as the NDR64_PARAM_FLAGS structure except
    // the 64-bit structure has a single bit (UseCache) for the old 
    // ServerAllocSize field

    PARAM_ATTRIBUTES *pattr = (PARAM_ATTRIBUTES *) &Attributes;
    pChild->GetNdrParamAttributes( pCCB, pattr );
    Attributes.UseCache = (NDR64_UINT16) ((pattr->ServerAllocSize) ? 1 : 0);
    Attributes.Reserved = 0;

    // For reasons not understood, GenNdrParamAttributes marks basetypes as
    // not by value even if they are (unless they are ranges).  Fix the 
    // insanity.

    if ( pChild->IsSimpleType() )
        Attributes.IsByValue = 1;

    pCCB->SetLastPlaceholderClass( pOldPlaceholder );

    // Get the fragment of the pointee.

    FormatFragment *pChildFragment;

    pChildFragment = GetCurrent()->GetParent()->LookupFragment( pChild );
    MIDL_ASSERT( NULL != pChildFragment );

    // Fill in the parameter information

    MIDL_NDR64_PARAM_FORMAT    *format;

    format = new MIDL_NDR64_PARAM_FORMAT( pParam );

    format->Attributes      = Attributes;
    format->Reserved        = 0;
    
    pParam->GetStackOffsets( pCCB, &format->StackOffset );

    // REVIEW:  The reason why we have to test base types seperately is
    //          because of the inconsistent way things are stored.  Consider
    //          a string pointer.  It's format info is a simple ref to an
    //          string array - this can be intrepreted as a pointer to a block
    //          of memory.  However, it's CG representation is just a pointer.
    //          The missing level of dereference causes the problem.  In
    //          constrast a pointer to a single long is represented as a ref
    //          pointer to a long both in CG and in the format info.

    if ( Attributes.IsBasetype
         && ( Attributes.IsByValue || Attributes.IsSimpleRef ) )
        {
        if ( Attributes.IsSimpleRef )
            pChild = (CG_NDR *) pChild->GetChild();

        format->Type = GetRoot()->LookupFragment( pChild )->GetRefID();
        }
    else
        {
        FormatFragment *pChildFragment = GetCurrent()->GetParent()->LookupFragment( pChild );
        MIDL_ASSERT( NULL != pChildFragment );

        // Is the parameter is a simple ref, we need to bypass the pointer
        // in the format string.
        if ( Attributes.IsSimpleRef )
            {
            MIDL_NDR64_POINTER_FORMAT* pPointerFrag =
                 dynamic_cast<MIDL_NDR64_POINTER_FORMAT*>(pChildFragment);
            format->Type = pPointerFrag->Pointee;
            }
        else 
            {
            format->Type = pChildFragment->GetRefID();
            }
        }        

    GetCurrent()->AddFragment( format );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_PROC )
//
//  Synopsis:   Generate info for interfaces
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_PROC *pProc )
{

    if ( GetCurrent()->HasClassFragment( pProc ) )
        return;

    CG_NDR *                pOldCGNodeContext;
    CG_ITERATOR             Iterator;
    CG_PARAM *              pParam;
    short                   ParamNum;
    long                    ServerBufferSize;
    long                    ClientBufferSize;
    long                    BufSize;
    BOOL                    fServerMustSize;
    BOOL                    fClientMustSize;

    // Make sure [call_as] targets are processed

    CG_PROC *pCallAs = pProc->GetCallAsCG();
    if (pCallAs)
        ContinueGenerationInRoot( pCallAs );

    CompositeFormatFragment *composite = new CompositeFormatFragment( pProc );

    composite->SetParent( GetCurrent() );
    GetCurrent()->AddFragment(composite);

    MIDL_NDR64_PROC_FORMAT *format = new MIDL_NDR64_PROC_FORMAT( pProc );

    composite->AddFragment( format );

    pCCB->SetInObjectInterface( pProc->IsObject() );

    pOldCGNodeContext = pCCB->SetCGNodeContext( pProc );

    //
    // If this procedure uses an explicit handle then set the
    // NdrBindDescriptionOffset to 0 so that it will not try to output it's
    // description when given the GenNdrParamOffLine method in the loop below.
    // It's description must be part of the procedure description.
    //
    if ( pProc->GetHandleUsage() == HU_EXPLICIT )
        {
        CG_HANDLE * pHandle = pProc->GetHandleClassPtr();

        pHandle->SetNdrBindDescriptionOffset( 0 );

        if ( pHandle->GetCGID() == ID_CG_CONTEXT_HDL )
            {
            // The context handle directs the call.
            ((CG_CONTEXT_HANDLE *)pHandle)->SetCannotBeNull();
            }
        }

    if ( !pProc->IsObject() && !pCCB->IsInCallback() )
        {
        if ( HU_IMPLICIT == pProc->GetHandleUsage() )
            {
            if ( pProc->IsGenericHandle() )
                pCCB->RegisterGenericHandleType(
                            pProc->GetHandleClassPtr()->GetHandleType() );
            }
        }

    pProc->GetMembers( Iterator );

    ParamNum = 0;

    ServerBufferSize = 0;
    ClientBufferSize = 0;

    fServerMustSize = FALSE;
    fClientMustSize = FALSE;

    pCCB->SetInterpreterOutSize( 0 );

    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;

        pChild = (CG_NDR *) pParam->GetChild();

        // Ignore the following type of arguments that don't go on wire:
        //  - async handles
        //  - primitive handles
        //  
        if ( pChild->GetCGID() == ID_CG_PRIMITIVE_HDL  || ( (CG_PARAM*) pParam)->IsAsyncHandleParam() )
            continue;

        pParam->SetParamNumber( ParamNum++ );

        pCCB->SetCurrentParam( (CG_PARAM *) pParam );
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pParam );

        ContinueGenerationInRoot( pChild );
                               
        // A procedure's buffer size does not depend on pipe arguments
        if (pChild->IsPipeOrPipeReference())
            {
                if (pChild->GetChild()->HasAFixedBufferSize())
                    pParam->SetInterpreterMustSize(FALSE);
                else
                    // There must be a union in there somewhere 
                    pParam->SetInterpreterMustSize(TRUE);
            }
        else
            {            
            BufSize = pChild->FixedBufferSize( pCCB );

            if ( BufSize != -1 )
                {
                //
                // If either the client's or server's fixed buffer size gets too
                // big then we force the parameter to be sized.
                //
                if ( (pParam->IsParamIn() &&
                    ((ClientBufferSize + BufSize) >= 65356)) ||
                    (pParam->IsParamOut() &&
                    ((ServerBufferSize + BufSize) >= 65356)) )
                    {
                    fClientMustSize = TRUE;
                    fServerMustSize = TRUE;
                    }
                else
                    {
                    pParam->SetInterpreterMustSize( FALSE );
    
                    if ( pParam->IsParamIn() )
                        ClientBufferSize += BufSize;
                    if ( pParam->IsParamOut() )
                        ServerBufferSize += BufSize;
                    }
                }
            else
                {
                if ( pParam->IsParamIn() )
                    fClientMustSize = TRUE;
                if ( pParam->IsParamOut() )
                    fServerMustSize = TRUE;
                }
            }

        pCCB->SetCurrentParam( 0 );
        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    //
    // Generate the format string for the return type if needed.
    //
    if ( pProc->GetReturnType() )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;

        pProc->GetReturnType()->SetParamNumber( ParamNum++ );
        
        pChild = (CG_NDR *) pProc->GetReturnType()->GetChild();

        pCCB->SetCurrentParam( pProc->GetReturnType() );
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pProc->GetReturnType() );

        ContinueGenerationInRoot( pChild );

        BufSize = pChild->FixedBufferSize( pCCB );

        if ( BufSize != -1 )
            {
            if ( (ServerBufferSize + BufSize) >= 65536 )
                {
                fServerMustSize = TRUE;
                }
            else
                {
                ServerBufferSize += BufSize;
                pProc->GetReturnType()->SetInterpreterMustSize( FALSE );
                }
            }
        else
            fServerMustSize = TRUE;

        pCCB->SetCurrentParam( 0 );
        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    pCCB->SetCurrentParam( 0 );

//
// REVIEW: This routine really needs to be broken up a bit
//

    // Figure out the handle type

    if ( pProc->IsObject() )
        format->Flags.HandleType = NDR64_FC_AUTO_HANDLE;
    else if ( pCCB->IsInCallback() )
        format->Flags.HandleType = NDR64_FC_CALLBACK_HANDLE;
    else if ( HU_IMPLICIT != pProc->GetHandleUsage() )
        format->Flags.HandleType = NDR64_FC_EXPLICIT_HANDLE;
    else if ( pProc->IsAutoHandle() )
        format->Flags.HandleType = NDR64_FC_AUTO_HANDLE;
    else if ( pProc->IsPrimitiveHandle() )
        format->Flags.HandleType = NDR64_FC_BIND_PRIMITIVE;
    else if ( pProc->IsGenericHandle() )
        format->Flags.HandleType = NDR64_FC_BIND_GENERIC;

    // Set the proc flags

    format->Flags.ProcType = 0;     // REVIEW: ??
    format->Flags.IsInterpreted = 1;            // REVIEW: ??
    format->Flags.IsObject = pProc->IsObject();
    format->Flags.IsAsync = pProc->HasAsyncUUID();  // REVIEW: HasAsyncHandle?
    format->Flags.IsEncode = pProc->HasEncode();
    format->Flags.IsDecode = pProc->HasDecode();
    format->Flags.UsesFullPtrPackage = pProc->HasFullPtr(); 
    format->Flags.UsesRpcSmPackage = pProc->MustInvokeRpcSSAllocate();
    format->Flags.HandlesExceptions = pProc->HasStatuses(); // REVIEW: ??
    format->Flags.UsesPipes = pProc->HasPipes();
    format->Flags.ServerMustSize = fServerMustSize;
    format->Flags.ClientMustSize = fClientMustSize;
    format->Flags.HasReturn = ( NULL != pProc->GetReturnType() );
    format->Flags.HasComplexReturn = pProc->HasComplexReturnType();
    format->Flags.ServerHasCorrelation = pProc->HasServerCorr();
    format->Flags.ClientHasCorrelation = pProc->HasClientCorr();
    format->Flags.HasNotify = pProc->HasNotify() || pProc->HasNotifyFlag();
    format->Flags.HasOtherExtensions = 0;   // Reset in GenExtendedProcInfo
    format->Flags.Reserved = 0;

    // Figure out the stack size.  Note that stack size in the 
    // NDR64_PROC_FORMAT structure is meaningless outside of ndr since it is
    // different for every processor

    format->ia64StackSize = pProc->GetTotalStackSize( pCCB );

    // Constant buffer sizes

    format->ConstantClientBufferSize = ClientBufferSize;
    format->ConstantServerBufferSize = ServerBufferSize;


    // RpcFlags
    //
    // REVIEW: Async is not an operation type!

    unsigned int opbits = pProc->GetOperationBits();

    format->RpcFlags.Idempotent       = (NDR64_UINT16) (opbits & OPERATION_IDEMPOTENT ? 1 : 0);
    format->RpcFlags.Broadcast        = (NDR64_UINT16) (opbits & OPERATION_BROADCAST  ? 1 : 0);
    format->RpcFlags.Maybe            = (NDR64_UINT16) (opbits & OPERATION_MAYBE      ? 1 : 0);
    format->RpcFlags.Message          = (NDR64_UINT16) (opbits & OPERATION_MESSAGE    ? 1 : 0);
    format->RpcFlags.InputSynchronous = (NDR64_UINT16) (opbits & OPERATION_INPUT_SYNC ? 1 : 0);
    format->RpcFlags.Asynchronous     = 0; // !!
    format->RpcFlags.Reserved1        = 0;
    format->RpcFlags.Reserved2        = 0;
    format->RpcFlags.Reserved3        = 0;

    // Miscellaneous

    format->FloatDoubleMask = pProc->GetFloatArgMask( pCCB );
    format->NumberOfParams  = ParamNum;
    format->ExtensionSize   = 0;         // Reset in GenExtendedProcInfo

    // Generate the extended proc info if any

    if ( format->Flags.HasNotify || pProc->GetHandleUsage() == HU_EXPLICIT )
        GenExtendedProcInfo( composite );

    // Now generate the parameter descriptors

    ITERATOR_INIT( Iterator );
    
    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        ContinueGeneration( pParam, composite );

    if ( pProc->HasReturn() )
        ContinueGeneration( pProc->GetReturnType(), composite );

    // REVIEW: Are procs optimized?  If so be careful because the stack size
    //         field is set to 0 for all procs 
    // composite->OptimizeFragment( format );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenExtendedProcInfo
//
//  Synopsis:   Generate info concerning explicit binding handles and
//              [notify] procs.
//
//  Parameters: [composite]     -- The composite to add the info to
//
//---------------------------------------------------------------------------

void GenNdr64Format::GenExtendedProcInfo( CompositeFormatFragment *composite )
{
    // The proc info should be the first thing in the composite 
    MIDL_NDR64_PROC_FORMAT                 *procFormat;
    CG_PROC                                *procCG;
    MIDL_NDR64_BIND_AND_NOTIFY_EXTENSION   *extension;

    extension = new MIDL_NDR64_BIND_AND_NOTIFY_EXTENSION;

    composite->AddFragment( extension );
    
    procFormat = dynamic_cast<MIDL_NDR64_PROC_FORMAT *>(composite->GetFirstFragment());
    MIDL_ASSERT( NULL != procFormat );

    procCG = (CG_PROC *) procFormat->GetCGNode();

    procFormat->Flags.HasOtherExtensions = 1;     // REVIEW: ??

    //
    // explicit handles
    //

    if ( procCG->GetHandleUsage() == HU_EXPLICIT )
        {
            CG_HANDLE *pHandle = procCG->GetHandleClassPtr();
            CG_PARAM  *pParam  = procCG->GetHandleUsagePtr();
            CG_NDR    *pOldPlaceholder;

            pOldPlaceholder = pCCB->SetLastPlaceholderClass( pParam );

            pHandle->GetNdrHandleInfo( pCCB, &extension->Binding );            
            pParam->GetStackOffsets( pCCB, &extension->StackOffsets );

            pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }
    else
        {
        // No explicit handle, zero out the handle info.
        memset( &extension->Binding, 0, sizeof( extension->Binding ) );
        memset( &extension->StackOffsets, 0, sizeof( extension->StackOffsets ) );
        }

    //
    // [notify] 
    //

    if ( procFormat->Flags.HasNotify )
        extension->NotifyIndex = procCG->GetNotifyTableOffset( pCCB );
    else
        extension->NotifyIndex = 0;

    // Update the extension size field.

    procFormat->ExtensionSize = sizeof(NDR64_BIND_AND_NOTIFY_EXTENSION);
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_POINTER )
//
//  Synopsis:   Generate info for simple pointer and add fragment to
//              current composite fragment.
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_POINTER *pPointer )
{
    MIDL_NDR64_POINTER_FORMAT   *format;

    format = new MIDL_NDR64_POINTER_FORMAT( pPointer );

    // Get the type of the pointer (ref, etc) and any flags

    pPointer->GetTypeAndFlags( pCCB, format );

    CG_CLASS *pointee = pPointer->GetChild();

    if ( format->Flags & FC_SIMPLE_POINTER )
        {

        // generic handles are represented as thier underlying type and
        // otherwise pretty much ignored for our purposes.

        if ( ID_CG_GENERIC_HDL == pointee->GetCGID() )
            pointee = pointee->GetChild();

        MIDL_ASSERT( NULL != dynamic_cast<CG_BASETYPE *> ( pointee ) );
    
        }
    
    GetCurrent()->AddFragment( format );

    format->Reserved = 0;
    
    format->Pointee  = ContinueGenerationInRoot( pointee );

    GetRoot()->OptimizeFragment( format );
}


MIDL_NDR64_POINTER_FORMAT* GenNdr64Format::GenQualifiedPtrHdr( CG_QUALIFIED_POINTER *pPointer )
{
    MIDL_NDR64_POINTER_FORMAT* pHeader = new MIDL_NDR64_POINTER_FORMAT( pPointer );    
    pPointer->GetTypeAndFlags( pCCB, pHeader );

    // Always use complex pointer struct
    pHeader->Flags &= ~FC_SIMPLE_POINTER;
    pHeader->Reserved = 0;
    pHeader->Pointee = INVALID_FRAGMENT_ID;

    return pHeader;
}

MIDL_NDR64_POINTER_FORMAT* GenNdr64Format::GenQualifiedArrayPtr( CG_ARRAY *pArray )
{
    // Ref arrays do not need the pointer header.
    if ( pArray->GetPtrType() == PTR_REF )
        return NULL;

    MIDL_NDR64_POINTER_FORMAT* pFragment = new MIDL_NDR64_POINTER_FORMAT( pArray );
    switch ( pArray->GetPtrType() )
        {
        case PTR_UNKNOWN:
        case PTR_REF:
            MIDL_ASSERT(0);
            break;

        case PTR_UNIQUE:
            pFragment->FormatCode = FC64_UP;
            break;

        case PTR_FULL:
            pFragment->FormatCode = FC64_FP;
            break;
        
        default:
            MIDL_ASSERT(0);
            break;        
        }

    pFragment->Flags    = 0;
    pFragment->Reserved = 0;

    return pFragment;
}

void GenNdr64Format::Visit( CG_STRING_POINTER *pPointer )
{
    // REVIEW: This is essentially two routines distinguished by an if.
    //         Seperate them.

    MIDL_NDR64_POINTER_FORMAT* pPointerHdr = GenQualifiedPtrHdr( pPointer );
    GetCurrent()->AddFragment( pPointerHdr );
    
    FormatFragment *pStringFrag = NULL;

    if ( dynamic_cast<CG_SIZE_STRING_POINTER *>(pPointer) )
        {
        CG_CONF_ATTRIBUTE *pConfAttribute = dynamic_cast<CG_CONF_ATTRIBUTE*>( pPointer );
        FormatFragment *pFrag = GenerateCorrelationDescriptor( pConfAttribute->GetSizeIsExpr() );            
        MIDL_NDR64_SIZED_CONFORMANT_STRING_FORMAT *pSizedConfFormat =
            new MIDL_NDR64_SIZED_CONFORMANT_STRING_FORMAT( pPointer );
        pStringFrag = pSizedConfFormat;
        
        InitStringHeader( pPointer, &pSizedConfFormat->Header, true, true);
        pSizedConfFormat->SizeDescription = (PNDR64_FORMAT)pFrag->GetRefID();
        }
    else
        {
        MIDL_NDR64_CONFORMANT_STRING_FORMAT *pConfFormat =
            new MIDL_NDR64_CONFORMANT_STRING_FORMAT( pPointer );
        pStringFrag = pConfFormat;
        
        InitStringHeader( pPointer, &pConfFormat->Header, true, false);
        }
    GetRoot()->AddFragment( pStringFrag );
    GetRoot()->OptimizeFragment( pStringFrag );

    pPointerHdr->Pointee = pStringFrag->GetRefID();

    GetRoot()->OptimizeFragment( pPointerHdr );
}

void GenNdr64Format::GenerateNonStringQualifiedPtr( CG_QUALIFIED_POINTER *pPointer )
{
    MIDL_NDR64_POINTER_FORMAT *pPointerFrag = GenQualifiedPtrHdr( pPointer );
    GetCurrent()->AddFragment( pPointerFrag );

    FormatFragment *pArrayFrag = GenerateNonStringQualifiedArrayLayout( pPointer, GetRoot() );
    pPointerFrag->Pointee = pArrayFrag->GetRefID();
    
}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenInterfacePointer
//
//  Synopsis:   Generate info for interface pointers
//
//---------------------------------------------------------------------------

void GenNdr64Format::GenInterfacePointer( CG_POINTER *pPointer, BOOL IsConstantIID )
{
    MIDL_NDR64_POINTER_FORMAT   *format;

    format = new MIDL_NDR64_POINTER_FORMAT( pPointer );

    // Generate the pointer node

    pPointer->GetTypeAndFlags( pCCB, format );

    format->FormatCode = FC64_IP;     // GetTypeAndFlags doesn't emit FC64_IP
    format->Reserved = 0;

    GetCurrent()->AddFragment( format );

    // generate the interface type node

    if ( IsConstantIID )
        {

        CG_INTERFACE_POINTER *pInterface =
            dynamic_cast<CG_INTERFACE_POINTER*>( pPointer );

        MIDL_NDR64_CONSTANT_IID_FORMAT *iid;

        iid = new MIDL_NDR64_CONSTANT_IID_FORMAT;

        iid->FormatCode = FC64_IP;         
        iid->Flags.ConstantIID = 1;
        iid->Flags.Reserved = 0;
        iid->Reserved = 0;

        node_guid * pGuid = (node_guid *) pInterface
                                                ->GetTheInterface()
                                                ->GetAttribute( ATTR_GUID );

        pGuid->GetGuid( iid->Guid );

        format->Pointee = GetRoot()->AddFragment( iid );

        }
    else 
        {
        CG_IIDIS_INTERFACE_POINTER *piidInterface = 
            dynamic_cast<CG_IIDIS_INTERFACE_POINTER*>( pPointer );
        
        FormatFragment *pIIDExpr = GenerateCorrelationDescriptor( piidInterface->GetIIDExpr() );
        MIDL_NDR64_IID_FORMAT *iid = new MIDL_NDR64_IID_FORMAT;

        iid->FormatCode             = FC64_IP;
        iid->Flags.ConstantIID      = 0;
        iid->Flags.Reserved         = 0;
        iid->Reserved               = 0;
        iid->IIDDescriptor          = pIIDExpr->GetRefID();

        format->Pointee = GetRoot()->AddFragment( iid );
        }

}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_UNION )
//
//  Synopsis:   Generate info for unions
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_UNION *pUnion )
{

    // A union is represented in the format info by a composite containing
    // the union header follow by fragments representing the arm selector

    CompositeFormatFragment *composite = new CompositeFormatFragment( pUnion );

    GetCurrent()->AddFragment( composite );

    MIDL_NDR64_NON_ENCAPSULATED_UNION *format;

    format = new MIDL_NDR64_NON_ENCAPSULATED_UNION( pUnion );

    composite->AddFragment( format );

    MIDL_ASSERT( dynamic_cast<CG_BASETYPE *> (pUnion->GetSwitchType()) );

    NDR64_FORMAT_CHAR SwitchType = (NDR64_FORMAT_CHAR)
                                   ( (CG_BASETYPE *) pUnion->GetSwitchType() )
                                            ->GetNDR64SignedFormatChar();
    
    // The alignment of a union is the max of the type alignment and the arm alignment.
    unsigned short UnionArmAlignment = pUnion->GetWireAlignment();
    unsigned short SwitchTypeAlignment =  
        ( (CG_BASETYPE*) pUnion->GetSwitchType() )->GetWireAlignment() ;
    unsigned short UnionAlignment = UnionArmAlignment > SwitchTypeAlignment ? 
                                    UnionArmAlignment : SwitchTypeAlignment;

    format->FormatCode      = FC64_NON_ENCAPSULATED_UNION;
    format->Alignment       = ConvertAlignment( UnionAlignment ); 
    format->Flags           = 0;
    format->SwitchType      = SwitchType;
    format->MemorySize      = pUnion->GetMemorySize();
    format->Reserved        = 0;

    expr_node  *pSwitchExpr = pUnion->GetNdr64SwitchIsExpr();
    
    FormatFragment* pSwitchFormat = GenerateCorrelationDescriptor( pSwitchExpr );
    format->Switch = (PNDR64_FORMAT)pSwitchFormat->GetRefID();

    GenerateUnionArmSelector( pUnion, composite );    

    GetRoot()->OptimizeFragment( composite );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_CONTEXT_HANDLE )
//
//  Synopsis:   Generate info for context handles
//
//  Notes:      This is an an abreviated version of the same information in
//              the proc descriptor.
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_CONTEXT_HANDLE *pHandle )
{
    CG_PARAM * pBindParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();
    CG_PROC  * pProc      = (CG_PROC *) pCCB->GetCGNodeContext();

    MIDL_NDR64_CONTEXT_HANDLE_FORMAT  *format;
    
    format = new MIDL_NDR64_CONTEXT_HANDLE_FORMAT( pHandle );

    format->FormatCode = FC64_BIND_CONTEXT;

    //
    // Register the rundown routine always, even if the context handle is
    // not used as the binding paramter.
    //
    if ( pHandle->GetHandleType()->NodeKind() == NODE_DEF )
        {
        pCCB->RegisterContextHandleType( pHandle->GetHandleType() );
        }

    // Flags

    unsigned char uFlags = pHandle->MakeExplicitHandleFlag( pBindParam );

    format->ContextFlags.CannotBeNull = pHandle->GetCannotBeNull() 
                                        || pBindParam->IsParamIn() 
                                        && !pBindParam->IsParamOut();

    format->ContextFlags.Serialize    = (NDR64_UINT8) ( pHandle->HasSerialize() ? 1 : 0 );
    format->ContextFlags.NoSerialize  = (NDR64_UINT8) ( pHandle->HasNoSerialize() ? 1 : 0 );
    format->ContextFlags.Strict       = (NDR64_UINT8) ( pHandle->HasStrict() ? 1 : 0 );
    format->ContextFlags.IsReturn     = (NDR64_UINT8) ( ( uFlags & HANDLE_PARAM_IS_RETURN ) ? 1 : 0 );
    format->ContextFlags.IsOut        = (NDR64_UINT8) ( ( uFlags & HANDLE_PARAM_IS_OUT ) ? 1 : 0 );
    format->ContextFlags.IsIn         = (NDR64_UINT8) ( ( uFlags & HANDLE_PARAM_IS_IN ) ? 1 : 0 );
    format->ContextFlags.IsViaPointer = (NDR64_UINT8) ( ( uFlags & HANDLE_PARAM_IS_VIA_PTR ) ? 1 : 0 );

    // Routine index.
    // IndexMgr keeps indexes 1..n, we use indexes 0..n-1

    format->RundownRoutineIndex = (NDR64_UINT8) 
                    ( pCCB->LookupRundownRoutine( pHandle->GetRundownRtnName() ) - 1);

    // Ordinal

    format->Ordinal = (NDR64_UINT8) pProc->GetContextHandleCount();
    pProc->SetContextHandleCount( (short) (format->Ordinal + 1) );

    GetCurrent()->AddFragment( format );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_GENERIC_HANDLE )
//
//  Synopsis:   Generate info for generic handles
//
//  Notes:      Actually generic handles are represented by thier underlying
//              type, not by any special "generic handle" type.  Therefore
//              there's nothing to generate.  We do need a place to
//              register the handle though.
//
//  Review:     Since we're not generating perhaps registering is better
//              placed in some other phase?  
//
//---------------------------------------------------------------------------
    
void GenNdr64Format::Visit( CG_GENERIC_HANDLE *pHandle )
{
    ContinueGenerationInRoot( pHandle->GetChild() );

    MIDL_ASSERT( pCCB->GetCGNodeContext()->IsProc() );

    CG_HANDLE *pBindingHandle = ((CG_PROC *)pCCB->GetCGNodeContext())
                                    ->GetHandleClassPtr();

    if ( pBindingHandle == pHandle )
        pCCB->RegisterGenericHandleType( pHandle->GetHandleType() );
}



//---------------------------------------------------------------------------
//
//  Pointer Layout Functions
//
//---------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenSimplePtrLayout( CG_STRUCT, bool, ulong *)
//
//  Synopsis:   Generate a pointer layout for a block copyable structure.
//
//---------------------------------------------------------------------------

FormatFragment * GenNdr64Format::GenSimplePtrLayout( CG_STRUCT *pStruct,
                                                     bool bGenHeaderFooter,
                                                     ulong *pPtrInstances )
{
    CompositeFormatFragment *pCompositeFormatFragment = NULL;
    CCB *pCCB = GetCCB();
    ulong NumberPointerInstances = 0;

    CG_FIELD *pOldRegionField = NULL;
    CG_NDR *pOldContext       = NULL;

    if ( dynamic_cast<CG_REGION*>( pStruct ) )
        pOldRegionField = pCCB->StartRegion();
    else
        pOldContext = pCCB->SetCGNodeContext( pStruct );

    CG_ITERATOR Iterator;
    pStruct->GetMembers( Iterator );

    CG_FIELD *pField;
    ITERATOR_INIT( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {

        CG_NDR * pOldPlaceHolder = pCCB->SetLastPlaceholderClass( pField );

        CG_CLASS *pMember = (CG_NDR *) pField->GetChild();

        MIDL_ASSERT( !pMember->IsStruct() ); // Structure should have been unrolled.

        if ( pMember->IsPointer() )
            {
            
            if ( NULL == pCompositeFormatFragment )
                pCompositeFormatFragment = new CompositeFormatFragment();

            if ( bGenHeaderFooter )
                pCompositeFormatFragment->AddFragment( 
                    new MIDL_NDR64_NO_REPEAT_FORMAT() );

            pCompositeFormatFragment->AddFragment(
                    new MIDL_NDR64_POINTER_INSTANCE_HEADER_FORMAT( pField->GetMemOffset() ) );

            ContinueGeneration( pMember, pCompositeFormatFragment );

            NumberPointerInstances++;
            }

        // For now, arrays do not have pointers.

        else if ( pMember->IsArray() )
            {
            FormatFragment *pPointerFragment = GenSimplePtrLayout( dynamic_cast<CG_ARRAY*>( pMember ),
                                                                   false,
                                                                   pField->GetMemOffset() );
                                                                      
            if ( NULL != pPointerFragment )
                {

                if ( NULL == pCompositeFormatFragment )
                    pCompositeFormatFragment = new CompositeFormatFragment();

                pCompositeFormatFragment->AddFragment( pPointerFragment );

                }
            }

        pCCB->SetLastPlaceholderClass( pOldPlaceHolder );
        }

    if ( ( NULL != pCompositeFormatFragment ) && 
         bGenHeaderFooter )
        {
        FormatFragment *pFormatFragment = new MIDL_NDR64_FORMAT_CHAR( FC64_END );
        pCompositeFormatFragment->AddFragment( pFormatFragment );
        }

    if ( NULL != pPtrInstances )
        {
        *pPtrInstances = NumberPointerInstances;
        }

    if ( dynamic_cast<CG_REGION*>( pStruct ) )
        pCCB->EndRegion( pOldRegionField );
    else
        pCCB->SetCGNodeContext( pOldContext );

    return pCompositeFormatFragment;
}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenSimplePtrLayout( CG_ARRAY, bool, ulong *)
//
//  Synopsis:   Generate a pointer layout for a block copyable structure.
//
//---------------------------------------------------------------------------
FormatFragment * GenNdr64Format::GenSimplePtrLayout( CG_NDR *pArray,
                                                     bool bGenHeaderFooter,
                                                     ulong MemoryOffset )
{

    CompositeFormatFragment *pArrayLayout = NULL;
    CG_CLASS *pChild             = pArray->GetChild();
    FormatFragment* pChildLayout = NULL;
    unsigned long NumberPointers = 0;

    // Multidimensional arrays should be bogus
    MIDL_ASSERT( !pChild->IsArray() );
    
    if ( pChild->IsPointer() )
        {

        CompositeFormatFragment *pCompositeFormatFragment = 
            new CompositeFormatFragment();
        
        pCompositeFormatFragment->AddFragment(
                new MIDL_NDR64_POINTER_INSTANCE_HEADER_FORMAT( 0 ) );

        ContinueGeneration( pChild, pCompositeFormatFragment );

        pChildLayout = pCompositeFormatFragment;
        NumberPointers = 1;
        }

    else if ( pChild->IsStruct() )
        {
        pChildLayout = GenSimplePtrLayout( dynamic_cast< CG_STRUCT *>( pChild ),
                                           false,
                                           &NumberPointers );
        }

    if ( pChildLayout )
        {

        pArrayLayout = new CompositeFormatFragment();
        FormatFragment *pHeader;

        if ( dynamic_cast<CG_FIXED_ARRAY*>( pArray ) )
            {
            
            CG_FIXED_ARRAY *pFixedArray = (CG_FIXED_ARRAY*)( pArray );
            pHeader = new MIDL_NDR64_FIXED_REPEAT_FORMAT( dynamic_cast<CG_NDR*>( pChild )->GetMemorySize(),
                                                          MemoryOffset,
                                                          NumberPointers,
                                                          pFixedArray->GetNumOfElements(),
                                                          dynamic_cast<CG_NDR*>( pChild )->IsStruct() );
            }

        else 
            {
            
            pHeader = new MIDL_NDR64_REPEAT_FORMAT( dynamic_cast<CG_NDR*>( pChild )->GetMemorySize(),
                                                    MemoryOffset,
                                                    NumberPointers,
                                                    dynamic_cast< CG_NDR* >( pChild )->IsStruct() );
            }

        pArrayLayout->AddFragment( pHeader );
        pArrayLayout->AddFragment( pChildLayout );

        if ( bGenHeaderFooter )
            {
            pArrayLayout->AddFragment( new MIDL_NDR64_FORMAT_CHAR( FC64_END ) );
            }

        }

    return pArrayLayout;

}

//--------------------------------------------------------------------------
//  
//   Structure layout
//
//
//--------------------------------------------------------------------------



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenCmplxPtrLayout( CG_COMPLEX_STRUCT )
//
//  Synopsis:   Generate a pointer layout for a complex structure.
//
//---------------------------------------------------------------------------


FormatFragment * GenNdr64Format::GenCmplxPtrLayout( CG_COMPLEX_STRUCT *pStruct )
{
    CompositeFormatFragment *pCompositeFormatFragment = NULL;
    CCB *pCCB = GetCCB();

    CG_ITERATOR Iterator;
    pStruct->GetMembers( Iterator );

    CG_FIELD *pField;
    ITERATOR_INIT( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {

        CG_NDR * pOldPlaceHolder = pCCB->SetLastPlaceholderClass( pField );

        CG_CLASS *pMember = (CG_NDR *) pField->GetChild();

        if ( pMember->IsPointer() )
            {
            
            if (NULL == pCompositeFormatFragment)
                pCompositeFormatFragment = new CompositeFormatFragment();
            
            ContinueGeneration( pMember, pCompositeFormatFragment );
            
            }

        pCCB->SetLastPlaceholderClass( pOldPlaceHolder );
        }

    return pCompositeFormatFragment;

}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenerateSimpleStructure( CG_STRUCT, bool )
//
//  Synopsis:   Generate the format string for a simple structure.
//
//---------------------------------------------------------------------------

void GenNdr64Format::GenerateSimpleStructure( CG_STRUCT *pStruct,
                                              bool IsConformant )
{
    // Add the fragment right away so recursive structure definitions 
    // are caught

    CompositeFormatFragment *pMainFragment 
                                    = new CompositeFormatFragment( pStruct );
    GetCurrent()->AddFragment( pMainFragment );

    CG_FIELD *pOldRegionField = NULL;
    CG_NDR   *pOldContext     = NULL;

    if ( dynamic_cast<CG_REGION*>( pStruct ) )
        pOldRegionField = pCCB->StartRegion();
    else
        pOldContext = pCCB->SetCGNodeContext( pStruct );

    FormatFragment* pMemberLayout  = NULL;
    FormatFragment* pPointerLayout = GenSimplePtrLayout( pStruct );
    
    if ( pCommand->NeedsNDR64DebugInfo() )
        pMemberLayout = GenerateStructureMemberLayout( pStruct, true );

    if ( IsConformant )
        {
        CG_CONFORMANT_STRUCT *pConfStruct = dynamic_cast<CG_CONFORMANT_STRUCT*>( pStruct );
        CG_FIELD *pConfField = dynamic_cast<CG_FIELD*>( pConfStruct->GetConformantField() );
        MIDL_ASSERT( NULL != pConfField );
        CG_ARRAY *pConfArray = dynamic_cast<CG_ARRAY*>( pConfField->GetChild() );
        MIDL_ASSERT( NULL != pConfArray );
        
        CG_NDR * pOldPlaceholder = GetCCB()->SetLastPlaceholderClass( pConfField );
        
        FormatFragment *pHeader = 
            new MIDL_NDR64_CONF_STRUCTURE_HEADER_FORMAT( pConfStruct, 
                                                         NULL != pPointerLayout, 
                                                         NULL != pMemberLayout,
                                                         ContinueGenerationInRoot( pConfArray ) );
        
        pMainFragment->AddFragment( pHeader );

        GetCCB()->SetLastPlaceholderClass( pOldPlaceholder );

        }

    else
        {

        FormatFragment *pHeader = 
            new MIDL_NDR64_STRUCTURE_HEADER_FORMAT( pStruct, 
                                                    NULL != pPointerLayout, 
                                                    NULL != pMemberLayout );

        pMainFragment->AddFragment( pHeader );

        }

    if ( NULL != pPointerLayout )   pMainFragment->AddFragment( pPointerLayout );
    if ( NULL != pMemberLayout )    pMainFragment->AddFragment( pMemberLayout );

    if ( dynamic_cast<CG_REGION*>( pStruct ) )
        pCCB->EndRegion( pOldRegionField );
    else
        pCCB->SetCGNodeContext( pOldContext );

    GetRoot()->OptimizeFragment( pMainFragment );

}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenerateComplexStruct( CG_STRUCT, bool )
//
//  Synopsis:   Generate the format string for a complex structure.
//
//---------------------------------------------------------------------------

void GenNdr64Format::GenerateComplexStruct( CG_COMPLEX_STRUCT *pStruct,
                                            bool IsConformant )
{
    
    if ( GetCurrent()->HasClassFragment( pStruct ) )
        return;

    // This must be done first to handle recurion.
    CompositeFormatFragment *pMainFragment = 
        new CompositeFormatFragment( pStruct );
    GetCurrent()->AddFragment( pMainFragment );

    CG_NDR *pOldContext = pCCB->SetCGNodeContext( pStruct );

    FormatInfoRef ArrayID = INVALID_FRAGMENT_ID;
    CG_ARRAY *pConfArray = NULL;

    if ( IsConformant )
        {
        CG_FIELD *pConfField = dynamic_cast<CG_FIELD*>( pStruct->GetConformantField() );
        MIDL_ASSERT( NULL != pConfField );
        pConfArray = dynamic_cast<CG_ARRAY*>( pConfField->GetChild() );
        MIDL_ASSERT( NULL != pConfArray );
        
        CG_NDR * pOldPlaceholder = GetCCB()->SetLastPlaceholderClass( pConfField );
        ArrayID = ContinueGenerationInRoot( pConfArray );
        GetCCB()->SetLastPlaceholderClass( pOldPlaceholder );

        }

    FormatInfoRef PointerID = INVALID_FRAGMENT_ID;
    FormatFragment *pPointerLayout = GenCmplxPtrLayout( pStruct );
    if ( NULL != pPointerLayout )
        {
        // Pointer Layout for complex struct goes in the root fragment.
        PointerID = GetRoot()->AddFragment( pPointerLayout );
        }
    
    FormatFragment* pMemberLayout  = GenerateStructureMemberLayout( pStruct, false );

    // The only difference between the member layout with debugging
    // and without debugging is that simple region become complex regions
    // with member layouts. 
    FormatInfoRef DebugPointerID    = INVALID_FRAGMENT_ID;
    FormatInfoRef DebugMemberLayoutID = INVALID_FRAGMENT_ID;
    if ( pCommand->NeedsNDR64DebugInfo() )
        {

        DebugPointerID = PointerID;
        FormatFragment *pDebugMemberLayout = GenerateStructureMemberLayout( pStruct, true );

        DebugMemberLayoutID = GetRoot()->AddFragment( pDebugMemberLayout );
        }

    
    FormatFragment* pHeader;

    if ( IsConformant )
        {
		MIDL_ASSERT( NULL != pConfArray );
        pHeader = new MIDL_NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT( pStruct,
                                                                     pConfArray,
                                                                     ArrayID,
                                                                     DebugMemberLayoutID, 
                                                                     DebugPointerID,
                                                                     PointerID );
        }
    else 
        {
        pHeader = new MIDL_NDR64_BOGUS_STRUCTURE_HEADER_FORMAT( pStruct, 
                                                                DebugMemberLayoutID,
                                                                DebugPointerID,
                                                                PointerID );
        }
    
    pMainFragment->AddFragment( pHeader );
    pMainFragment->AddFragment( pMemberLayout );

    pCCB->SetCGNodeContext( pOldContext );
}

//+--------------------------------------------------------------------------
//
//  Class:      StructureMemberGenerator
//
//  Synopsis:   This object is responsible for generating the member layout 
//              of a structure.
//
//---------------------------------------------------------------------------

class StructureMemberGenerator 
{
private:
    GenNdr64Format *pMainGenerator;
    CompositeFormatFragment *pCompositeFormatFragment;
    CG_VISITOR *pVisitor;
    bool bIsDebug;

    void StartGeneration( CG_STRUCT *pStruct ); 
    void GenerateMember( CG_CLASS *pClass ) 
       {
       pClass->Visit( pVisitor );
       }
    
public:

    static FormatFragment*  Generate( GenNdr64Format *pMainGenerator,
                                      CG_STRUCT *pStruct,
                                      bool bIsDebug )
       {
       CG_VISITOR_TEMPLATE<StructureMemberGenerator> TemplateVisitor;
       StructureMemberGenerator & Visitor = TemplateVisitor;

       Visitor.pMainGenerator              = pMainGenerator;
       Visitor.pCompositeFormatFragment    = new CompositeFormatFragment();
       Visitor.pVisitor                    = &TemplateVisitor;
       Visitor.bIsDebug                    = bIsDebug;

       Visitor.StartGeneration( pStruct );

       return Visitor.pCompositeFormatFragment;
       }
    
    // Items that get a unique member layout item.
    void Visit( CG_POINTER *pPointer) 
       {
       pPointer;
       FormatFragment *pFormatFragment = new MIDL_NDR64_SIMPLE_MEMBER_FORMAT( FC64_POINTER );
       pCompositeFormatFragment->AddFragment( pFormatFragment );
       }

    void Visit( CG_IGNORED_POINTER *pPointer )
       {
       pPointer;
       FormatFragment *pFormatFragment = new MIDL_NDR64_SIMPLE_MEMBER_FORMAT( FC64_IGNORE );
       pCompositeFormatFragment->AddFragment( pFormatFragment );
       }

    void Visit( CG_BASETYPE *pBaseType )
       {
       if ( pBaseType->GetRangeAttribute() != NULL )
           {
           // Send to generic catch all case(Embedded complex)
           Visit( (CG_CLASS*) pBaseType );
           return;
           }
       NDR64_FORMAT_CHAR FormatCode = (NDR64_FORMAT_CHAR)pBaseType->GetNDR64FormatChar();
       FormatFragment *pFormatFragment = new MIDL_NDR64_SIMPLE_MEMBER_FORMAT( FormatCode );
       pCompositeFormatFragment->AddFragment( pFormatFragment );
       }

    void Visit( CG_SIMPLE_REGION *pSimpleRegion )
       {

       // If this member layout is for debugging, send this 
       // to the CG_CLASS visit function to create an
       // embedded complex.
       if ( bIsDebug )
           {
           Visit( (CG_CLASS*)pSimpleRegion );
           return;
           }

       FormatFragment *pFormatFragment = 
           new MIDL_NDR64_SIMPLE_REGION_FORMAT( pSimpleRegion );
       pCompositeFormatFragment->AddFragment( pFormatFragment );
       }
    
    void Visit( CG_PAD *pPad )
       {
       FormatFragment *pFormatFragment 
           = new MIDL_NDR64_BUFFER_ALIGN_FORMAT( pPad );
       pCompositeFormatFragment->AddFragment( pFormatFragment );
       }

    // Do nothing for conformant arrays.  They must be at the end.
    void Visit( CG_CONFORMANT_ARRAY *pConfArray )               { pConfArray; }
    void Visit( CG_CONFORMANT_VARYING_ARRAY *pConfVaryArray )   { pConfVaryArray; }
    void Visit( CG_CONFORMANT_STRING_ARRAY *pConfStringArray )  { pConfStringArray; }

    // Catch all case. Generates embedded complex
    void Visit( CG_CLASS *pClass )
       {
       FormatInfoRef ID = pMainGenerator->ContinueGenerationInRoot( pClass );
       FormatFragment *pFormatFragment = new MIDL_NDR64_EMBEDDED_COMPLEX_FORMAT( ID );
       pCompositeFormatFragment->AddFragment( pFormatFragment );
       }
};

void StructureMemberGenerator::StartGeneration( CG_STRUCT *pStruct )
{
    CCB *pCCB = pMainGenerator->GetCCB();
    CG_NDR * pOldPlaceholder = pCCB->GetLastPlaceholderClass();

    CG_ITERATOR         Iterator;
    pStruct->GetMembers( Iterator );

    CG_FIELD * pField;
    unsigned long BufferOffset = 0;

    ITERATOR_INIT( Iterator );
    while( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        
        //FormatFragment *FormatFragment = NULL;
        unsigned long MemPad = pField->GetMemOffset() - BufferOffset;

        if ( MemPad != 0 )
            {

            MIDL_NDR64_MEMPAD_FORMAT *pMemPadFormat = 
                new MIDL_NDR64_MEMPAD_FORMAT( MemPad );
            pCompositeFormatFragment->AddFragment( pMemPadFormat );
            }

        BufferOffset += MemPad;

        pCCB->SetLastPlaceholderClass( pField );
        
        CG_NDR *pMember = (CG_NDR *) pField->GetChild();
        
        // Embedded unknown represent as is not allowed.
        MIDL_ASSERT( ! pField->HasEmbeddedUnknownRepAs() ); 

        GenerateMember( pMember );
        
        BufferOffset += pField->GetMemorySize();

        }

    // Account for padding at the end of the structure.

    MIDL_ASSERT( pStruct->GetMemorySize() >= BufferOffset );

    unsigned long EndingPad = pStruct->GetMemorySize() - BufferOffset;

    
    if ( EndingPad )
        {
        MIDL_NDR64_MEMPAD_FORMAT *pMemPadFormat = 
            new MIDL_NDR64_MEMPAD_FORMAT( EndingPad );
        pCompositeFormatFragment->AddFragment( pMemPadFormat );
        }

    FormatFragment* pEndFormatFragment = new MIDL_NDR64_SIMPLE_MEMBER_FORMAT( FC64_END );
    pCompositeFormatFragment->AddFragment( pEndFormatFragment );

    pCCB->SetLastPlaceholderClass( pOldPlaceholder );

}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenerateStructureMemberLayout( CG_STRUCT, bool )
//
//  Synopsis:   Wrapper for the member layout generator
//
//---------------------------------------------------------------------------
FormatFragment *GenNdr64Format::GenerateStructureMemberLayout( CG_STRUCT *pStruct, bool bIsDebug )
{
    return StructureMemberGenerator::Generate( this, pStruct, bIsDebug );
}



//---------------------------------------------------------------------------
//
//
//  Arrays
//
//
//
//---------------------------------------------------------------------------

FormatFragment *GenNdr64Format::GenerateArrayElementInfo( CG_CLASS *pChild )
{
    CG_NDR *pNdr = dynamic_cast<CG_NDR*>( pChild );
    MIDL_ASSERT( NULL != pNdr );
    
    MIDL_NDR64_ARRAY_ELEMENT_INFO *pElementInfo =
        new MIDL_NDR64_ARRAY_ELEMENT_INFO();

    pElementInfo->ElementMemSize = pNdr->GetMemorySize();
    pElementInfo->Element        = (PNDR64_FORMAT)ContinueGenerationInRoot( pNdr );

    return pElementInfo;
}

void GenNdr64Format::Visit( CG_FIXED_ARRAY *pArray )
{
    CompositeFormatFragment *pMainFragment = new CompositeFormatFragment( pArray );
    GetCurrent()->AddFragment( pMainFragment );

    FormatFragment *pMemberInfo    = NULL;
    FormatFragment *pPointerLayout = GenSimplePtrLayout( pArray );
    
    if ( pCommand->NeedsNDR64DebugInfo() )
        pMemberInfo    = GenerateArrayElementInfo( pArray->GetChild() );

    MIDL_NDR64_FIX_ARRAY_HEADER_FORMAT *pArrayFormat = 
        new MIDL_NDR64_FIX_ARRAY_HEADER_FORMAT( pArray );

    memset( (NDR64_FIX_ARRAY_HEADER_FORMAT*)pArrayFormat,
            0,
            sizeof(NDR64_FIX_ARRAY_HEADER_FORMAT*));

    pArrayFormat->FormatCode              = (NDR64_FORMAT_CHAR) FC64_FIX_ARRAY; 
    pArrayFormat->Alignment               = ConvertAlignment( pArray->GetWireAlignment() );

    pArrayFormat->Flags.HasPointerInfo    = (NULL != pPointerLayout);
    pArrayFormat->Flags.HasElementInfo    = (NULL != pMemberInfo );;

    pArrayFormat->Reserved                = 0;
    pArrayFormat->TotalSize               = pArray->GetMemorySize();

    pMainFragment->AddFragment( pArrayFormat );
    
    if ( pPointerLayout )
       pMainFragment->AddFragment( pPointerLayout );

    if ( pMemberInfo )
       pMainFragment->AddFragment( pMemberInfo );
}

void GenNdr64Format::GenerateFixBogusArrayCommon( CG_FIXED_ARRAY *pArray, bool IsFullBogus )
{
    CompositeFormatFragment *pMainFragment = new CompositeFormatFragment( pArray );
    GetCurrent()->AddFragment( pMainFragment );
        
    CG_ILANALYSIS_INFO *pAnalysisInfo = pArray->GetILAnalysisInfo();


    MIDL_NDR64_BOGUS_ARRAY_HEADER_FORMAT *pHeaderFragment = 
        new MIDL_NDR64_BOGUS_ARRAY_HEADER_FORMAT( pArray );

    memset( (NDR64_BOGUS_ARRAY_HEADER_FORMAT*)pHeaderFragment,
            0,
            sizeof(NDR64_BOGUS_ARRAY_HEADER_FORMAT));

    pHeaderFragment->FormatCode                 = (NDR64_FORMAT_CHAR) 
                                                  ( IsFullBogus ? FC64_FIX_BOGUS_ARRAY  :
                                                                  FC64_FIX_FORCED_BOGUS_ARRAY ); 

    pHeaderFragment->Alignment                  = ConvertAlignment( ((CG_NDR*)pArray->GetChild())
                                                                    ->GetWireAlignment() );
    pHeaderFragment->Flags.HasPointerInfo       = false;
    pHeaderFragment->Flags.HasElementInfo       = true;
    pHeaderFragment->Flags.IsArrayofStrings     = pAnalysisInfo->IsArrayofStrings();
    pHeaderFragment->Flags.IsMultiDimensional   = pAnalysisInfo->IsMultiDimensional();

    pHeaderFragment->NumberDims                 = pAnalysisInfo->GetDimensions();
    pHeaderFragment->NumberElements             = pArray->GetNumOfElements();
    pHeaderFragment->Element                    = (PNDR64_FORMAT)
                                                  ContinueGenerationInRoot( pArray->GetChild() );

    pMainFragment->AddFragment( pHeaderFragment );

}

FormatFragment * 
GenNdr64Format::GenerateNonStringQualifiedArrayLayout( CG_NDR *pNdr,
                                                       CompositeFormatFragment *pComp )
{
    CompositeFormatFragment *pMainFragment = new CompositeFormatFragment( pNdr );
    pComp->AddFragment( pMainFragment );
    
    FormatFragment *pHeaderFragment;
    FormatFragment *pPointerLayout = NULL;    
    FormatFragment *pMemberInfo = NULL;

    CG_ILANALYSIS_INFO *pAnalysisInfo = pNdr->GetILAnalysisInfo();
    
    FormatInfoRef SizeIsDescriptor      = INVALID_FRAGMENT_ID;
    FormatInfoRef OffsetOfDescriptor    = INVALID_FRAGMENT_ID;
    FormatInfoRef LengthIsDescriptor    = INVALID_FRAGMENT_ID;

    if ( pAnalysisInfo->IsConformant() )
        {
        CG_CONF_ATTRIBUTE *pConfAttribute = dynamic_cast<CG_CONF_ATTRIBUTE*>( pNdr );
        expr_node *pSizeIs     = pConfAttribute->GetSizeIsExpr();
        if ( pSizeIs != NULL )
            {
            FormatFragment *pSizeIsFrag = GenerateCorrelationDescriptor( pSizeIs );
            SizeIsDescriptor = pSizeIsFrag->GetRefID();
            }

        }
    if ( pAnalysisInfo->IsVarying() )
        {
        CG_VARY_ATTRIBUTE *pVaryAttribute = dynamic_cast<CG_VARY_ATTRIBUTE*>( pNdr );
        expr_node *pLengthIs   = pVaryAttribute->GetLengthIsExpr();
        if ( pLengthIs != NULL )
            {
            FormatFragment *pLengthIsFrag = GenerateCorrelationDescriptor( pLengthIs );
            LengthIsDescriptor = pLengthIsFrag->GetRefID();
            }

        expr_node *pFirstIs    = pVaryAttribute->GetFirstIsExpr();
        if ( pFirstIs != NULL )
            {
            FormatFragment *pOffsetOfFrag = GenerateCorrelationDescriptor( pFirstIs );
            OffsetOfDescriptor = pOffsetOfFrag->GetRefID();
            }
        }



    if ( pAnalysisInfo->IsFullBogus() || pAnalysisInfo->IsForcedBogus() )
        {
        // treat like a bogus array
        
        MIDL_NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT *pArrayHeader = 
              new MIDL_NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT( pNdr );
        NDR64_BOGUS_ARRAY_HEADER_FORMAT *pFixedArrayHeader = &pArrayHeader->FixedArrayFormat;
        pHeaderFragment = pArrayHeader;

        bool bIsFullBogus = pAnalysisInfo->IsFullBogus();

        NDR64_UINT32 NumberElements = 0;
        CG_CONF_ATTRIBUTE *pConfAttribute = dynamic_cast<CG_CONF_ATTRIBUTE *>( pNdr );
        
        if ( !pAnalysisInfo->IsConformant() && 
             pConfAttribute &&
             pConfAttribute->GetSizeIsExpr() &&
             pConfAttribute->GetSizeIsExpr()->IsConstant() )
            {
            NumberElements = (NDR64_UINT32)pConfAttribute->GetSizeIsExpr()->GetValue();
            }

        CG_NDR *pChildNdr = dynamic_cast<CG_NDR*>( pNdr->GetChild() );
        memset( (NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT*)pArrayHeader,
                0,
                sizeof(NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT));

        pFixedArrayHeader->FormatCode              = (NDR64_FORMAT_CHAR) 
                                                     ( bIsFullBogus ? FC64_BOGUS_ARRAY :
                                                                      FC64_FORCED_BOGUS_ARRAY );        
        pFixedArrayHeader->Alignment               = ConvertAlignment( pChildNdr->GetWireAlignment() );

        pFixedArrayHeader->Flags.HasPointerInfo        = false;
        pFixedArrayHeader->Flags.HasElementInfo        = true;
        pFixedArrayHeader->Flags.IsArrayofStrings      = pAnalysisInfo->IsArrayofStrings();
        pFixedArrayHeader->Flags.IsMultiDimensional    = pAnalysisInfo->IsMultiDimensional();

        pFixedArrayHeader->NumberDims                  = pAnalysisInfo->GetDimensions();

        pFixedArrayHeader->NumberElements              = NumberElements;
                
        pFixedArrayHeader->Element                     = (PNDR64_FORMAT)
                                                         ContinueGenerationInRoot( pChildNdr );
        
        pArrayHeader->ConfDescription                  = (PNDR64_FORMAT)SizeIsDescriptor;
        pArrayHeader->VarDescription                   = (PNDR64_FORMAT)LengthIsDescriptor;
        pArrayHeader->OffsetDescription                = (PNDR64_FORMAT)OffsetOfDescriptor;
        
        }
    else 
        {

        pPointerLayout = GenSimplePtrLayout( pNdr );
        
        if ( pCommand->NeedsNDR64DebugInfo() )
            pMemberInfo    = GenerateArrayElementInfo( pNdr->GetChild() );

        if ( !pAnalysisInfo->IsConformant() && 
              pAnalysisInfo->IsVarying() )
            {
            
            MIDL_NDR64_VAR_ARRAY_HEADER_FORMAT *pArrayHeader = 
              new MIDL_NDR64_VAR_ARRAY_HEADER_FORMAT( pNdr );
            pHeaderFragment = pArrayHeader;

            CG_NDR *pChildNdr = dynamic_cast<CG_NDR*>(pNdr->GetChild());

            memset( (NDR64_VAR_ARRAY_HEADER_FORMAT*)pArrayHeader,
                    0,
                    sizeof(NDR64_VAR_ARRAY_HEADER_FORMAT));
            
            pArrayHeader->FormatCode              = (NDR64_FORMAT_CHAR) FC64_VAR_ARRAY; 
            pArrayHeader->Alignment               = ConvertAlignment( pChildNdr->GetWireAlignment() );
            
            pArrayHeader->Flags.HasPointerInfo    = ( NULL != pPointerLayout );
            pArrayHeader->Flags.HasElementInfo    = ( NULL != pMemberInfo );

            pArrayHeader->Reserved                = 0;
            pArrayHeader->TotalSize               = pNdr->GetMemorySize();
            pArrayHeader->ElementSize             = pChildNdr->GetMemorySize();

            pArrayHeader->VarDescriptor           = (PNDR64_FORMAT)LengthIsDescriptor;

            pMemberInfo = GenerateArrayElementInfo( pNdr->GetChild() );
            }
        else if (  pAnalysisInfo->IsConformant() && 
                  !pAnalysisInfo->IsVarying() )
            {
            
            MIDL_NDR64_CONF_ARRAY_HEADER_FORMAT *pArrayHeader = 
              new MIDL_NDR64_CONF_ARRAY_HEADER_FORMAT( pNdr );
            pHeaderFragment = pArrayHeader;

            CG_NDR *pChildNdr = dynamic_cast<CG_NDR*>(pNdr->GetChild());

            memset( (NDR64_CONF_ARRAY_HEADER_FORMAT*)pArrayHeader,
                    0,
                    sizeof(NDR64_CONF_ARRAY_HEADER_FORMAT));

            pArrayHeader->FormatCode              = (NDR64_FORMAT_CHAR) FC64_CONF_ARRAY; 
            pArrayHeader->Alignment               = ConvertAlignment( pChildNdr->GetWireAlignment() );
            
            pArrayHeader->Flags.HasPointerInfo    = (NULL != pPointerLayout);
            pArrayHeader->Flags.HasElementInfo    = (NULL != pMemberInfo);

            pArrayHeader->Reserved                = 0;
            pArrayHeader->ElementSize             = pChildNdr->GetMemorySize();

            pArrayHeader->ConfDescriptor          = (PNDR64_FORMAT)SizeIsDescriptor;
            
            pMemberInfo = GenerateArrayElementInfo( pNdr->GetChild() );

            }
        else if ( pAnalysisInfo->IsConformant() && 
                  pAnalysisInfo->IsVarying() )
            {
            
            MIDL_NDR64_CONF_VAR_ARRAY_HEADER_FORMAT *pArrayHeader = 
              new MIDL_NDR64_CONF_VAR_ARRAY_HEADER_FORMAT( pNdr );
            pHeaderFragment = pArrayHeader;

            CG_NDR *pChildNdr = dynamic_cast<CG_NDR*>(pNdr->GetChild());

            memset( (NDR64_CONF_VAR_ARRAY_HEADER_FORMAT*)pArrayHeader,
                    0,
                    sizeof(NDR64_CONF_VAR_ARRAY_HEADER_FORMAT));

            pArrayHeader->FormatCode              = (NDR64_FORMAT_CHAR) FC64_CONFVAR_ARRAY; 
            pArrayHeader->Alignment               = ConvertAlignment( pChildNdr->GetWireAlignment() );
            
            pArrayHeader->Flags.HasPointerInfo    = (NULL != pPointerLayout);
            pArrayHeader->Flags.HasElementInfo    = (NULL != pMemberInfo);

            pArrayHeader->Reserved                = 0;
            pArrayHeader->ElementSize             = pChildNdr->GetMemorySize();

            pArrayHeader->ConfDescriptor          = (PNDR64_FORMAT)SizeIsDescriptor;
            pArrayHeader->VarDescriptor           = (PNDR64_FORMAT)LengthIsDescriptor;
            

            }
        else 
            {
            // !pAnalysisInfo->IsConformant && !pAnalysisInfo->IsVarying
            MIDL_ASSERT(0);
            pHeaderFragment = NULL;
            }
        }

    pMainFragment->AddFragment( pHeaderFragment );
    if ( pPointerLayout )
        pMainFragment->AddFragment( pPointerLayout );    
    if ( pMemberInfo )
        pMainFragment->AddFragment( pMemberInfo );

    return pMainFragment;  
}

void GenNdr64Format::GenerateNonStringQualifiedArray( CG_ARRAY *pArray )
{
    CompositeFormatFragment *pContainer;
    MIDL_NDR64_POINTER_FORMAT* pPointerHdr = GenQualifiedArrayPtr( pArray );    
    if ( pPointerHdr != NULL)
        {
        GetCurrent()->AddFragment( pPointerHdr );
        pContainer = GetRoot();
        }
    else 
        pContainer = GetCurrent();

    FormatFragment *pArrayFragment = 
        GenerateNonStringQualifiedArrayLayout( pArray, pContainer );

    if ( NULL != pPointerHdr )
        {
        pPointerHdr->Pointee = pArrayFragment->GetRefID();
        }

}

void GenNdr64Format::InitStringHeader( CG_NDR *pString,
                                       NDR64_STRING_HEADER_FORMAT *pHeader,
                                       bool bIsConformant,
                                       bool bIsSized )
{
    NDR64_FORMAT_CHAR FormatCode;
    CG_BASETYPE *pBT = dynamic_cast<CG_BASETYPE*>( pString->GetChild() );

    if ( NULL != pBT )
        {             
        
        switch( pBT->GetType()->GetBasicType()->NodeKind() )
            {
            case NODE_BYTE:
            case NODE_CHAR:
                FormatCode = (NDR64_FORMAT_CHAR)
                             ( bIsConformant ? FC64_CONF_CHAR_STRING : FC64_CHAR_STRING );
                break;
            case NODE_WCHAR_T:
                FormatCode = (NDR64_FORMAT_CHAR)
                             ( bIsConformant ? FC64_CONF_WCHAR_STRING : FC64_WCHAR_STRING );
                break;
            default:
                FormatCode = (NDR64_FORMAT_CHAR)
                             ( bIsConformant ? FC64_CONF_STRUCT_STRING : FC64_STRUCT_STRING );
                break;
            }

        }
    else
        FormatCode = (NDR64_FORMAT_CHAR)
                     ( bIsConformant ? FC64_CONF_STRUCT_STRING : FC64_STRUCT_STRING );

    CG_NDR *pChildNdr           = dynamic_cast<CG_NDR*>( pString->GetChild() );
    MIDL_ASSERT( pChildNdr->GetMemorySize() <= 0xFFFF );
    NDR64_UINT16 ElementSize    = (NDR64_UINT16)pChildNdr->GetMemorySize();

    MIDL_ASSERT( (FC64_CHAR_STRING == FormatCode) ? (1 == ElementSize) : 1 );
    MIDL_ASSERT( (FC64_WCHAR_STRING == FormatCode) ? (2 == ElementSize) : 1 );

    memset( pHeader, 0, sizeof(NDR64_STRING_HEADER_FORMAT)); 

    pHeader->FormatCode    = FormatCode;
    pHeader->Flags.IsSized = bIsSized;
    pHeader->ElementSize   = ElementSize;

}



void GenNdr64Format::GenerateStringArray( CG_ARRAY *pArray,
                                          bool bIsSized )
{
    MIDL_NDR64_POINTER_FORMAT* pPointerHdr = GenQualifiedArrayPtr( pArray );    
    if ( pPointerHdr != NULL)
        GetCurrent()->AddFragment( pPointerHdr );

    FormatFragment *pStringFrag = NULL;

    if ( bIsSized )
        {
        CG_CONF_ATTRIBUTE *pConfAttribute = dynamic_cast<CG_CONF_ATTRIBUTE*>( pArray );
        expr_node *pSizeIs = pConfAttribute->GetSizeIsExpr();

        if ( NULL != pSizeIs )
            {
            FormatFragment *pFrag = GenerateCorrelationDescriptor( pConfAttribute->GetSizeIsExpr() );
    
            MIDL_NDR64_SIZED_CONFORMANT_STRING_FORMAT *pSizedConfFormat =
                new MIDL_NDR64_SIZED_CONFORMANT_STRING_FORMAT( pArray );
            pStringFrag = pSizedConfFormat;
            
            InitStringHeader( pArray, &pSizedConfFormat->Header, true, true);
            pSizedConfFormat->SizeDescription = (PNDR64_FORMAT)pFrag->GetRefID();
            }
        else 
            {
            MIDL_NDR64_CONFORMANT_STRING_FORMAT *pConfFormat =
                new MIDL_NDR64_CONFORMANT_STRING_FORMAT( pArray );
            pStringFrag = pConfFormat;
            
            InitStringHeader( pArray, &pConfFormat->Header, true, false);
            }
        }
    else
        {
        MIDL_NDR64_NON_CONFORMANT_STRING_FORMAT *pNonConfFormat =
            new MIDL_NDR64_NON_CONFORMANT_STRING_FORMAT( pArray );
        pStringFrag = pNonConfFormat;

        InitStringHeader( pArray, &pNonConfFormat->Header, false, false);
        pNonConfFormat->TotalSize = pArray->GetMemorySize();
        }

    if ( NULL != pPointerHdr )
        {
        GetRoot()->AddFragment( pStringFrag );
        pPointerHdr->Pointee = pStringFrag->GetRefID();
        }
    else
        {
        GetCurrent()->AddFragment( pStringFrag );
        }
}

class ExpressionGenerator
{
public:
    static  CompositeFormatFragment * 
        Generate( CCB *         pCCB,
                  expr_node *   pSizeExpr
                );

private:
    static void 
        GenExprPadIfNecessary( 
                 CompositeFormatFragment * FragmentList,
                 ulong *    pExprLength,
                 ulong      Align );

    static FormatFragment * 
        GenExprConstant(
                 NDR64_FORMAT_CHARACTER fc,
                 EXPR_VALUE lValue,
                 CompositeFormatFragment * FragmentList,
                 ulong * pExprLength );
    static BOOL 
        IsConstantExpr (expr_node * pExpr );
    
    static NDR64_FORMAT_CHARACTER
        GetTypeForExpression( node_skl *pType );

    static FormatFragment * 
        GenExprFormatString(
            CCB *pCCB,
            expr_node *pSizeExpr,
            CompositeFormatFragment *FragmentList,
            BOOL * pIsEarly,
            ulong * pExprLength );

    static CG_FIELD* 
        FindField( 
            node_skl * pFieldType,
            CG_STRUCT *pStruct,
            const char *pPrintPrefix,
            unsigned long *pMemOffset );

    static void 
        ComputeFieldCorrelationOffset( 
            CCB *pCCB,
            node_skl *pFieldType,
            // return parameters
            CG_FIELD **ppVariableField, // var in expression
            long *pOffset,
            BOOL *pIsEarly );
};

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenerateCorrelationDescriptor
//
//  Synopsis:   
//
//---------------------------------------------------------------------------

FormatFragment*
GenNdr64Format::GenerateCorrelationDescriptor( expr_node *pExpr )
{     
    MIDL_ASSERT(NULL != pExpr);
    
    FormatFragment *pCorrelationDescriptor =
                                ExpressionGenerator::Generate( pCCB, pExpr );
     
    GetRoot()->AddFragment( pCorrelationDescriptor );
    GetRoot()->OptimizeFragment( pCorrelationDescriptor );

    return pCorrelationDescriptor;
}

//+--------------------------------------------------------------------------
//
//  Method:     Generate
//
//  Synopsis:   generate correlation expression. 
//              
//
//---------------------------------------------------------------------------

CompositeFormatFragment *
ExpressionGenerator::Generate( CCB *         pCCB,
                               expr_node *   pSizeExpr
                               )
{
    
    if ( NULL == pSizeExpr )
        return NULL ;

#if defined(DBG)

     CG_CLASS *pAttributedNode = pCCB->GetLastPlaceholderClass( );

     MIDL_ASSERT( ( NULL != dynamic_cast<CG_PARAM*>( pAttributedNode ) ) ||
             ( NULL != dynamic_cast<CG_FIELD*>( pAttributedNode ) ) );

#endif

    BOOL                IsEarly = FALSE;
    CompositeFormatFragment * pExprComposite = new CompositeFormatFragment;
    MIDL_NDR_FORMAT_UINT32  * pFlag = new MIDL_NDR_FORMAT_UINT32;
    ulong               ulExprLength = 0;

    // correlation flags. 4 bytes.
    pExprComposite->AddFragment( pFlag );
    ulExprLength = sizeof( NDR64_UINT32 );

    // recursive code to generate the expression stack.
    GenExprFormatString( pCCB, pSizeExpr, pExprComposite, &IsEarly, &ulExprLength );   

    pFlag->Data = 0;
    if ( IsEarly )
        pFlag->Data |= FC_NDR64_EARLY_CORRELATION;
        
    return pExprComposite;
}

void 
ExpressionGenerator::GenExprPadIfNecessary( 
                 CompositeFormatFragment * FragmentList,
                 ulong *    pExprLength,
                 ulong      Align )
{
    MIDL_NDR64_EXPR_NOOP * pExprPad = NULL;
    if ( *pExprLength & ( Align - 1 ) )
        {
        // need to add padding to align next element
        pExprPad = new MIDL_NDR64_EXPR_NOOP;
        pExprPad->Size = (NDR64_UINT8) ( ( Align - 1 ) & *pExprLength );
        FragmentList->AddFragment( pExprPad );
        *pExprLength += sizeof( NDR64_EXPR_NOOP );
        }
    else
        return;
}

FormatFragment * 
ExpressionGenerator::GenExprConstant(
                 NDR64_FORMAT_CHARACTER fc,
                 EXPR_VALUE lValue,
                 CompositeFormatFragment * FragmentList,
                 ulong * pExprLength )
{
    if ( fc == FC64_INT64 )
        {
        MIDL_NDR64_EXPR_CONST64 * pFormat;

        pFormat = new MIDL_NDR64_EXPR_CONST64;
        pFormat->ConstValue = lValue;
        GenExprPadIfNecessary( FragmentList, pExprLength, 8 ); 
        FragmentList->AddFragment( pFormat );
        *pExprLength += sizeof( NDR64_EXPR_CONST64 );
        return pFormat;
        }
    else
        {
        MIDL_NDR64_EXPR_CONST32 *pFormat;

        pFormat = new MIDL_NDR64_EXPR_CONST32;
        pFormat->ConstValue = (NDR64_UINT32) lValue;
        GenExprPadIfNecessary( FragmentList, pExprLength, 4 ); 
        FragmentList->AddFragment( pFormat );
        *pExprLength += sizeof( NDR64_EXPR_CONST64 );
        return pFormat;
        }
    
}


// check if the expression (including all sub expressions ) is a constant expression
BOOL 
ExpressionGenerator::IsConstantExpr (expr_node * pExpr )
{
    if ( pExpr->IsConstant() )
        return TRUE;

    if ( pExpr->IsAVariable() )
        return FALSE;


    if ( pExpr->IsBinaryOperator() )
        {
        return IsConstantExpr( ((expr_op_binary *)pExpr)->GetLeft() ) && 
               IsConstantExpr( ((expr_op_binary *)pExpr)->GetRight() ); 
        }
    else
        {
        if ( pExpr->IsUnaryOperator() )
            {
            return IsConstantExpr( ((expr_op_unary *)pExpr)->GetLeft() );
            }
        else
            {
            MIDL_ASSERT( pExpr->IsRelationalOperator() );
            return IsConstantExpr( ((expr_ternary *)pExpr)->GetLeft() ) && 
                   IsConstantExpr( ((expr_ternary *)pExpr)->GetRight() ) &&
                   IsConstantExpr( ((expr_ternary *)pExpr)->GetRelational() ) ; 
            }
        }                  
}

NDR64_FORMAT_CHARACTER
ExpressionGenerator::GetTypeForExpression(
    node_skl *pType
    )
{


    // Get the size of the type.
    unsigned long Size = pType->GetSize();

    // determine if the type is signed or unsigned.
    bool IsSigned = true;
    node_base_type *pBaseType = dynamic_cast<node_base_type*>( pType->GetBasicType() );

    if ( pBaseType )
        {
        IsSigned = !pBaseType->IsUnsigned();
        }

    switch ( Size )
        {
        case 1:
            return IsSigned ? FC64_INT8 : FC64_UINT8;
        case 2:
            return IsSigned ? FC64_INT16 : FC64_UINT16;
        case 4:
            return IsSigned ? FC64_INT32 : FC64_UINT32;
        case 8:
            return IsSigned ? FC64_INT64 : FC64_UINT64;
        default:
            RpcError( NULL, 0, EXPR_NOT_EVALUATABLE, pType->GetSymName() );
            return FC64_ZERO;  // Keep the compiler happy
        }
}

FormatFragment * 
ExpressionGenerator::GenExprFormatString(
    CCB *pCCB,
    expr_node *pSizeExpr,
    CompositeFormatFragment *FragmentList,
    BOOL * pIsEarly,
    ulong * pExprLength )
{
    node_skl *          pAttributeNodeType;
    EXPR_TOKEN          Op;
    long                Offset;

    CG_PARAM *      pParam = NULL;
    CG_NDR   *      pSwitchNode = NULL;
   
    // BUGBUG: how  to generate 32bit constant? 
    if ( IsConstantExpr( pSizeExpr ) )
        {

        // Constant expressions are always early!
        *pIsEarly = TRUE;

        return GenExprConstant( FC64_INT64, pSizeExpr->GetValue(), FragmentList, pExprLength );

        }

    if ( pSizeExpr->IsAVariable() )
        // variable
        {
        Op = FC_EXPR_VAR;
        MIDL_NDR64_EXPR_VAR * pFormat;
        
        CG_NDR * pNdr = pCCB->GetCGNodeContext();
        CG_ITERATOR     Iterator;

        pAttributeNodeType = pSizeExpr->GetType();

        if ( pNdr->IsProc() )
            // top level param
            {
            CG_PARAM*       pCurrentParam   = (CG_PARAM*) pCCB->GetCurrentParam();
            CG_PROC*        pCurrentProc    = (CG_PROC*) pNdr;
            
            *pIsEarly = TRUE;
            
            if ( ( (node_param *) pAttributeNodeType )->IsSaveForAsyncFinish() && 
                 pCurrentProc->IsFinishProc() )
                {

                // This is an async split where the finish proc is using
                // a param from the begin proc.   Since the parameter 
                // was stored on the split stack, the expression will
                // always be early correlation.   So all that is needed
                // here is to find the parameter in the begin proc.

                CG_PROC* pBeginProc = pCurrentProc->GetAsyncRelative();
                pBeginProc->GetMembers( Iterator );
                
                for (;;)
                    {
                    if (!ITERATOR_GETNEXT( Iterator, pParam ))
                        {
                        // Didn't find the parameter.  We are in trouble!
                        MIDL_ASSERT(0);
                        return NULL;
                        }

                    if ( pParam->GetType()  == pAttributeNodeType )
                        {
                        break;
                        }
                    }

                }

            else 
                {

                // Typical case of correlation in the same parameter.

                pCurrentProc->GetMembers( Iterator);

                if ( pCurrentParam->GetType() == pAttributeNodeType  )
                    *pIsEarly = FALSE;

                for(;;)
                    {

                    if (!ITERATOR_GETNEXT( Iterator, pParam ))
                        {
                        // Didn't find the parameter.  We are in trouble!
                        MIDL_ASSERT(0);
                        return NULL;
                        }

                    // If we find the current parameter before the variable,
                    // parameter, then late correlation is needed.
                    if ( pParam == pCurrentParam )
                        *pIsEarly = FALSE;

                    if ( pParam->GetType() == pAttributeNodeType )
                        break;
                    }

                }

            pSwitchNode = (CG_NDR *) pParam->GetChild();

            }
        else
            // structure /union etc.
            {
            CG_FIELD *pSwitchField;
            ComputeFieldCorrelationOffset( pCCB,
                                           pAttributeNodeType,
                                           // return parameters
                                           &pSwitchField, 
                                           &Offset,
                                           pIsEarly );
            pSwitchNode = (CG_NDR*)pSwitchField->GetChild();                
            }
            
        // Code the type of the size_is etc. expression.

        NDR64_FORMAT_CHARACTER Type = GetTypeForExpression( pSwitchNode->GetType() );
            
        pAttributeNodeType = pSizeExpr->GetType();      

        pFormat = new MIDL_NDR64_EXPR_VAR;

        pFormat->ExprType = FC_EXPR_VAR;
        pFormat->VarType = (NDR64_UINT8)Type;

        if ( pNdr->IsProc() )
            {
            CG_NDR* pOld = 0;
            BOOL IsFinish = FALSE;
            MIDL_NDR64_EXPR_OPERATOR * pAsyncOp; 
            if ( ( (node_param *) pAttributeNodeType )->IsSaveForAsyncFinish() )
                {
                pAsyncOp = new MIDL_NDR64_EXPR_OPERATOR;
                if ( ( (CG_PROC *)pNdr )->IsFinishProc() )
                    {
                    pOld = pCCB->SetCGNodeContext( ( (CG_PROC *)pNdr )->GetAsyncRelative() );
                    IsFinish = TRUE;
                    }
                    
                pAsyncOp->ExprType = (NDR64_FORMAT_CHAR) FC_EXPR_OPER;
                pAsyncOp->Operator = (NDR64_FORMAT_CHAR) OP_ASYNCSPLIT;
                FragmentList->AddFragment( pAsyncOp );
                *pExprLength += sizeof( NDR64_EXPR_OPERATOR );
                }
            pFormat->fStackOffset = TRUE;
            pFormat->ia64Offset = pParam->GetStackOffset( pCCB, I386_STACK_SIZING );

            if ( IsFinish )
                pCCB->SetCGNodeContext( pOld );               
            }
        else
            {
            // Structure
            pFormat->fStackOffset = FALSE;
            pFormat->Offset = Offset;
            }

        GenExprPadIfNecessary( FragmentList, pExprLength, 4 );
        FragmentList->AddFragment( pFormat );
        *pExprLength += sizeof( NDR64_EXPR_VAR );           

        return pFormat;
        
        }
    else
        // operator
        {
        expr_node * pLeftExpr = NULL;
        BOOL bLeftExprIsEarly = TRUE;
        
        expr_node * pRightExpr = NULL;
        BOOL bRightExprIsEarly = TRUE;

        expr_node * pRationalExpr = NULL;
        BOOL bRationalExprIsEarly = TRUE;

        MIDL_NDR64_EXPR_OPERATOR *pFormat;
        NDR64_FORMAT_CHARACTER fcKind = (NDR64_FORMAT_CHARACTER)0;

        OPERATOR Operator ;

        if ( pSizeExpr->IsBinaryOperator() )
            {
            Operator = ((expr_op_binary *)pSizeExpr)->GetOperator();
            pLeftExpr = ((expr_op_binary *)pSizeExpr)->GetLeft();
            pRightExpr = ((expr_op_binary *)pSizeExpr)->GetRight();
            }
        else
            {
            if ( pSizeExpr->IsUnaryOperator() )
                {
                Operator = ((expr_op_unary *)pSizeExpr)->GetOperator();
                pLeftExpr = ((expr_op_unary *)pSizeExpr)->GetLeft();
                }
            else
                {
                Operator = ((expr_ternary *)pSizeExpr)->GetOperator();
                pLeftExpr = ((expr_ternary *)pSizeExpr)->GetLeft();
                pRightExpr = ((expr_ternary *)pSizeExpr)->GetRight();
                pRationalExpr = ((expr_ternary *)pSizeExpr)->GetRelational();
                }
            }           

        switch ( Operator )
            {
            case OP_UNARY_SIZEOF:
                EXPR_VALUE lSize;
                lSize = pSizeExpr->GetType()->GetSize();
                
                *pIsEarly = TRUE;

                return GenExprConstant( FC64_INT8, lSize, FragmentList, pExprLength);

            case OP_UNARY_CAST:
            case OP_UNARY_INDIRECTION:
                fcKind = GetTypeForExpression( pSizeExpr->GetType() );  
                break;
            }

            pFormat = new MIDL_NDR64_EXPR_OPERATOR;

            pFormat->ExprType = (NDR64_FORMAT_CHAR) FC_EXPR_OPER;
            pFormat->Operator = (NDR64_FORMAT_CHAR) Operator;
            // This was initially 0
            pFormat->CastType = (NDR64_FORMAT_CHAR) fcKind;

            FragmentList->AddFragment( pFormat );
            *pExprLength += sizeof( NDR64_EXPR_OPERATOR );

            GenExprFormatString( pCCB, pLeftExpr, FragmentList, &bLeftExprIsEarly, pExprLength );

            if ( pRightExpr )
                GenExprFormatString( pCCB, pRightExpr, FragmentList, &bRightExprIsEarly, pExprLength );
            if  ( pRationalExpr )
                GenExprFormatString( pCCB, pRationalExpr, FragmentList, &bRationalExprIsEarly, pExprLength );
            
            //
            // An operator is early if and only if all the arguments to the
            // operator are early.
            //

            *pIsEarly = bLeftExprIsEarly && bRightExprIsEarly && bRationalExprIsEarly;

            return pFormat;
        }
}


CG_FIELD* 
ExpressionGenerator::FindField( 
    node_skl * pFieldType,
    CG_STRUCT *pStruct,
    const char *pPrintPrefix,
    unsigned long *pMemOffset )
{
   CG_ITERATOR Iterator;

   pStruct->GetMembers( Iterator );
   ITERATOR_INIT( Iterator );

   CG_FIELD *pField;
   while ( ITERATOR_GETNEXT( Iterator, pField ) )
       {

       // First check if the fields are the same type.  If they
       // are, then check the print prefixes to make sure the fields came 
       // from the same structure.

       if ( ( pField->GetType() == pFieldType ) &&
            ( strcmp( pField->GetPrintPrefix(), pPrintPrefix ) == 0 ) )
           {

           *pMemOffset = pField->GetMemOffset();
           return pField;
           }

       CG_CLASS * pChildClass = pField->GetChild();
       
       if ( pChildClass->IsStruct() )
           {
           unsigned long TempMemOffset;
           CG_STRUCT *pChildStruct = (CG_STRUCT*)pChildClass;
           
           CG_FIELD *pTempField = FindField( pFieldType,
                                             pChildStruct,
                                             pPrintPrefix,
                                             &TempMemOffset );

           if ( NULL != pTempField )
               {
               *pMemOffset = TempMemOffset + pField->GetMemOffset(); 
               return pTempField;
               }
           }
       
       }

   return NULL;
}

void 
ExpressionGenerator::ComputeFieldCorrelationOffset( 
    CCB *pCCB,
    node_skl *pFieldType,
    // return parameters
    CG_FIELD **ppVariableField, // var in expression
    long *pOffset,
    BOOL *pIsEarly )
{

    //
    // Find the fields.
    //
    CG_FIELD *pCurrentField = dynamic_cast<CG_FIELD*>( pCCB->GetLastPlaceholderClass() );
    MIDL_ASSERT( NULL != pCurrentField );
    const char *pPrintPrefix = pCurrentField->GetPrintPrefix();

    CG_STRUCT *pContext = dynamic_cast<CG_STRUCT*>( pCCB->GetCGNodeContext() );
    MIDL_ASSERT( NULL != pContext );

    unsigned long VariableOffset;
    CG_FIELD* pVariableField = FindField( pFieldType, 
                                          pContext,
                                          pPrintPrefix,
                                          &VariableOffset );
    MIDL_ASSERT( NULL != pVariableField );
    *ppVariableField = pVariableField;

    unsigned long CurrentOffset;
    CG_FIELD* pAlsoCurrentField = FindField( pCurrentField->GetType(),
                                             pContext,
                                             pPrintPrefix,
                                             &CurrentOffset );
    pAlsoCurrentField;
    MIDL_ASSERT( pAlsoCurrentField == pCurrentField );

    //
    // Determine the correlation type.
    // The correlation type is early if the variable field will
    // be completely marshalled before the current field.
    //
    BOOL bVariableIsPointer = pVariableField->GetChild()->IsPointer();
    BOOL bCurrentFieldIsPointer = pCurrentField->GetChild()->IsPointer();
    
    BOOL bOnlyVariableIsPointer = bVariableIsPointer && !bCurrentFieldIsPointer;

    *pIsEarly = ( CurrentOffset > VariableOffset ) && !bOnlyVariableIsPointer;

    // In the land of the new transfer syntax, all offsets are a positive offset
    // from the start of the stack or the last structure/region that was passed.

    CG_FIELD *pRegionField = pCCB->GetCurrentRegionField();

    // Make offset relative to start of region
    if (NULL != pRegionField)
        VariableOffset -= pRegionField->GetMemOffset(); 

    *pOffset = VariableOffset;

}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_TRANSMIT_AS )
//
//  Synopsis:   Generate info for transmit_as types
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_TRANSMIT_AS *pTransmitAs )
{
    MIDL_NDR64_TRANSMIT_AS_FORMAT *format;

    format = new MIDL_NDR64_TRANSMIT_AS_FORMAT( pTransmitAs );

    GetCurrent()->AddFragment( format );

    GenXmitOrRepAsFormat(
            pTransmitAs,
            format,
            pTransmitAs->GetPresentedType()->GetSymName(),
            pTransmitAs->GetPresentedType(),
            pTransmitAs->GetTransmittedType() );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_REPRESENT_AS )
//
//  Synopsis:   Generate info for represent_as types
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_REPRESENT_AS *pRepresentAs )
{
    MIDL_NDR64_REPRESENT_AS_FORMAT *format;

    format = new MIDL_NDR64_REPRESENT_AS_FORMAT( pRepresentAs );

    GetCurrent()->AddFragment( format );

    GenXmitOrRepAsFormat(
            pRepresentAs,
            format,
            pRepresentAs->GetRepAsTypeName(),
            pRepresentAs->GetRepAsType(),
            pRepresentAs->GetTransmittedType() );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenXmitOrRepAsFormat
//
//  Synopsis:   Do the actual work for transmit_as and represent_as types
//
//---------------------------------------------------------------------------

void GenNdr64Format::GenXmitOrRepAsFormat(
        CG_TYPEDEF                     *pXmitNode,
        MIDL_NDR64_TRANSMIT_AS_FORMAT  *format,
        char                           *pPresentedTypeName,
        node_skl                       *pPresentedType,
        node_skl                       *pTransmittedType )
{
    CG_NDR *pChild = (CG_NDR *) pXmitNode->GetChild();
    BOOL    fXmit  = ( NULL == dynamic_cast<CG_REPRESENT_AS *>(pXmitNode) );

    NDR64_UINT16 RoutineIndex = pXmitNode->GenXmitOrRepAsQuintuple(
                                        pCCB,
                                        fXmit,
                                        pXmitNode,
                                        pPresentedTypeName,
                                        (fXmit ? pPresentedType
                                               : pTransmittedType) );


    format->FormatCode = (NDR64_FORMAT_CHAR) ( fXmit ? FC64_TRANSMIT_AS : FC64_REPRESENT_AS );
    format->RoutineIndex = RoutineIndex;
    format->TransmittedTypeWireAlignment = (NDR64_UINT16) ( pChild->GetWireAlignment() - 1 );
            
    // REVIEW: The spec doesn't say whether "MemoryAlignment" is the 
    //         presented type or the transmitted type.  Transmitted doesn't
    //         make much sense but on the other hand presented has some
    //         alignment flags already.
    format->MemoryAlignment = pXmitNode->GetMemoryAlignment();

    if ( pPresentedType )
        format->PresentedTypeMemorySize = (NDR64_UINT16) pPresentedType->GetSize();
    else
        MIDL_ASSERT(!"BUGBUG: unknown rep/transmit_as");
        
    if ( pChild->HasAFixedBufferSize() )
        format->TransmittedTypeBufferSize = (NDR64_UINT16) pChild->GetWireSize();
    else
        format->TransmittedTypeBufferSize = 0;

    format->Flags.PresentedTypeIsArray = 0;
    format->Flags.PresentedTypeAlign4 = 0;
    format->Flags.PresentedTypeAlign8 = 0;
    format->Flags.Reserved = 0;

    if ( pPresentedType )
        {
        if ( pPresentedType->GetBasicType()->NodeKind() == NODE_ARRAY )
            format->Flags.PresentedTypeIsArray = 1;
        else
            {
            if ( pXmitNode->GetMemoryAlignment() == 4 )
                format->Flags.PresentedTypeAlign4 = 1;
            else if ( pXmitNode->GetMemoryAlignment() == 8 )
                format->Flags.PresentedTypeAlign8 = 1;
            }
        }        

    if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
        pChild = (CG_NDR *)pChild->GetChild();

    format->TransmittedType = ContinueGenerationInRoot( pChild );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_USER_MARSHAL )
//
//  Synopsis:   Generate info for user_marshal types
//
//  REVIEW:     user_marshall and represent_as are so close to one another
//              they really should probably be merged
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_USER_MARSHAL *pUserMarshal )
{
    MIDL_NDR64_USER_MARSHAL_FORMAT *format;

    format = new MIDL_NDR64_USER_MARSHAL_FORMAT( pUserMarshal );

    GetCurrent()->AddFragment( format );
 
    CG_NDR *pChild = (CG_NDR *) pUserMarshal->GetChild();

    format->FormatCode = FC64_USER_MARSHAL;
    format->TransmittedTypeWireAlignment = (NDR64_UINT16) (pChild->GetWireAlignment() - 1);
    format->MemoryAlignment = pChild->GetMemoryAlignment();

    memset( &format->Flags, 0, sizeof(format->Flags) );
    if ( pChild->IsPointer() )
        {
        CG_POINTER *pPointer = (CG_POINTER *) pChild;
        MIDL_ASSERT( ! pPointer->IsFull() );

        if ( pPointer->IsUnique() )
            format->Flags.UniquePointer = 1;
        else if ( pPointer->IsRef() )
            format->Flags.RefPointer = 1;
        }

    format->Flags.IID = 0;      // Only used by JIT compiler
    format->Flags.Reserved = 0;

    USER_MARSHAL_CONTEXT * pUserMarshalContext = new USER_MARSHAL_CONTEXT;

    pUserMarshalContext->pTypeName = pUserMarshal->GetRepAsTypeName();
    pUserMarshalContext->pType     = pUserMarshal->GetRepAsType();

    BOOL  Added = pCCB->GetQuadrupleDictionary()->Add( pUserMarshalContext );

    format->RoutineIndex = pUserMarshalContext->Index;

    if ( !Added )
        delete pUserMarshalContext;

    if ( pUserMarshal->GetRepAsType() )
        format->UserTypeMemorySize = pUserMarshal->GetRepAsType()->GetSize();
    else
        MIDL_ASSERT( !"BUGBUG: undefined user_marshal" );

    if ( pChild->HasAFixedBufferSize() )
        format->TransmittedTypeBufferSize = pChild->GetWireSize();
    else
        format->TransmittedTypeBufferSize = 0;

    format->TransmittedType = ContinueGenerationInRoot( pChild );
}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_PIPE )
//
//  Synopsis:   Generate info for [pipe] types
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_PIPE *pPipe )
{
    pCommand->GetNdrVersionControl().SetHasRawPipes();

    MIDL_NDR64_PIPE_FORMAT *format = new MIDL_NDR64_PIPE_FORMAT( pPipe );

    GetCurrent()->AddFragment( format );

    CG_NDR             *pChild     = (CG_NDR *) pPipe->GetChild();
    NDR64_UINT32        BufferSize = 0;
    node_range_attr    *range      = pPipe->GetRangeAttribute();
    NDR64_UINT32        MinValue   = 0;
    NDR64_UINT32        MaxValue   = 0;

    CG_ILANALYSIS_INFO *pAnalysisInfo = pChild->GetILAnalysisInfo();

    if ( pChild->HasAFixedBufferSize() )
        BufferSize = pChild->GetWireSize();

    if ( range )
        {
        MinValue = (NDR64_UINT32) range->GetMinExpr()->GetValue();
        MaxValue = (NDR64_UINT32) range->GetMaxExpr()->GetValue();
        }

    format->FormatCode = FC64_PIPE;
    format->Flags.Reserved1  = 0;
    format->Flags.HasRange   = (bool) ( NULL != range );
    format->Flags.BlockCopy  = !pAnalysisInfo->IsForcedBogus() && !pAnalysisInfo->IsFullBogus();
    format->Flags.Reserved2  = 0;
    format->Alignment  = (NDR64_UINT8) ( pChild->GetWireAlignment() - 1 );
    format->Reserved   = 0;
    format->Type       = ContinueGenerationInRoot( pChild );
    format->MemorySize = pChild->GetMemorySize();
    format->BufferSize = BufferSize;
    format->MinValue   = MinValue;
    format->MaxValue   = MaxValue;
}



//+--------------------------------------------------------------------------
//
//  Method:     OutputParamFlagDescription
//
//  Synopsis:   Output a description string for the ndr64 param flags 
//
//---------------------------------------------------------------------------

void OutputParamFlagDescription( CCB *pCCB, const NDR64_PARAM_FLAGS &flags )
{
    static const PNAME flag_descrip[16] = 
                    {
                    "MustSize",
                    "MustFree",
                    "pipe",
                    "[in]",
                    "[out]",
                    "IsReturn",
                    "Basetype",
                    "ByValue",
                    "SimpleRef",
                    "DontFreeInst",
                    "AsyncFinish",
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    "UseCache"
                    };

    pCCB->GetStream()->Write( "    " );
    OutputFlagDescriptions( pCCB->GetStream(), &flags, sizeof(flags), flag_descrip );
}



//+--------------------------------------------------------------------------
//
//  Method:     OutputFlagDescription
//
//  Synopsis:   Given a set of flags and a description for each flags, 
//              output the corresponding description for flag that is set.
//              usused flags can be marked with a NULL description.
//
//  Notes:      Assumes little-endian memory layout!
//
//---------------------------------------------------------------------------

void OutputFlagDescriptions(
        ISTREAM     *stream, 
        const void  *pvFlags, 
        int          bytes, 
        const PNAME *description)
{
    unsigned char *flags = (unsigned char *) pvFlags;
    bool first = true;

    stream->Write( "/*");

    for (int i = 0; i < (bytes * 8); i++)
        {
        if (    ( NULL == description[i] )
             || ( 0 == ( flags[i / 8] & ( 1 << (i % 8) ) ) ) )
            {
            continue;
            }

        if ( !first )
            stream->Write( "," );

        first = false;

        stream->Write( " " );
        stream->Write( description[i] );
        }

    stream->Write( " */" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\ndrcls.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:
    
    ndrcls.cxx

 Abstract:

    Routines for the ndrcls code generation class.

 Notes:


 History:

    Aug-31-1993     VibhasC     Created.
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

/****************************************************************************
 *  local definitions
 ***************************************************************************/
/****************************************************************************
 *  local data
 ***************************************************************************/

/****************************************************************************
 *  externs
 ***************************************************************************/
/****************************************************************************/

expr_node *
CG_NDR::PresentedLengthExpression( CCB* )
    {
    expr_sizeof *   pExpr   = new expr_sizeof( GetType() );
    return pExpr;
    }

expr_node *
CG_NDR::PresentedSizeExpression( CCB* )
    {
    expr_sizeof *   pExpr   = new expr_sizeof( GetType() );
    return pExpr;
    }
expr_node *
CG_NDR::PresentedFirstExpression( CCB* )
    {
    return new expr_constant(0L);
    }

    
/****************************************************************************
    utility functions
 ****************************************************************************/
CG_STATUS
CG_NDR::SizeAnalysis( ANALYSIS_INFO * pAna )
    {
    pAna;
    return CG_OK;
    }
CG_STATUS
CG_NDR::MarshallAnalysis( ANALYSIS_INFO * pAna )
    {
    pAna;
    return CG_OK;
    }

node_skl    *
CG_NDR::GetBasicType()
    {
    node_skl    *   pT  = GetType();

    switch (pT->NodeKind())
        {
        case NODE_ID:
        case NODE_FIELD:
        case NODE_PARAM:
        case NODE_DEF:
            return pT->GetBasicType();
        }
    return pT;
    }

CG_STATUS
CG_NDR::RefCheckAnalysis(
    ANALYSIS_INFO * pAna )
    {
    CG_NDR * pC = (CG_NDR *)GetChild();

    if( pC )
        pC->RefCheckAnalysis( pAna );

    return CG_OK;
    }

CG_STATUS
CG_NDR::InLocalAnalysis(
    ANALYSIS_INFO * pAna )
    {
    CG_NDR * pC = (CG_NDR *)GetChild();

    if( pC )
        pC->InLocalAnalysis( pAna );

    return CG_OK;
    }

CG_STATUS
CG_NDR::S_GenInitInLocals(
    CCB * pCCB )
    {
    CG_NDR * pC = (CG_NDR *)GetChild();

    if( pC )
        pC->S_GenInitInLocals( pCCB );

    return CG_OK;
    }

CG_STATUS
CG_NDR::GenRefChecks(
    CCB * pCCB )
    {
    CG_NDR * pC = (CG_NDR *)GetChild();

    if( pC )
        pC->GenRefChecks( pCCB );

    return CG_OK;
    }

extern CMD_ARG * pCommand;

void 
CG_NDR::GetNdrParamAttributes( CCB *pCCB, PARAM_ATTRIBUTES *attributes)
{
    CG_PARAM *          pParam;
    CG_NDR *            pChild;
    CG_PROC *           pProc;

    pChild = (CG_NDR *) GetChild();

    if ( pChild && (pChild->GetCGID() == ID_CG_GENERIC_HDL) )
        pChild = (CG_NDR *) pChild->GetChild();

    pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    pProc = (CG_PROC *) pCCB->GetCGNodeContext();

    if ( IsPipeOrPipeReference() )
        {
        // Pipe parameters are never sized.

        attributes->MustSize = 0;
        }
    else
        attributes->MustSize = (unsigned short) pParam->GetInterpreterMustSize();

    attributes->IsIn = (unsigned short) pParam->IsParamIn();
    attributes->IsOut = (unsigned short) pParam->IsParamOut();
    attributes->IsReturn = ( pParam->GetCGID() == ID_CG_RETURN )
                           || ( pProc->HasComplexReturnType() 
                                && NULL == pParam->GetSibling() );
    attributes->IsPartialIgnore = pParam->IsParamPartialIgnore();
    attributes->IsForceAllocate = pParam->IsForceAllocate();
    attributes->IsBasetype = 0;
    // SAFEARRAY(FOO) is being generated as ID_CG_SAFEARRAY. It's in fact user 
    // marshal on the wire.
    attributes->IsByValue = 
            IsStruct() || 
            IsUnion() ||
            ( GetCGID() == ID_CG_TRANSMIT_AS )  ||
            ( GetCGID() == ID_CG_REPRESENT_AS ) ||
            ( GetCGID() == ID_CG_USER_MARSHAL ) ||
            ( GetCGID() == ID_CG_SAFEARRAY )    ||
            ( GetCGID() == ID_CG_CS_TAG ) ;
    attributes->IsSimpleRef = 
            (pParam->GetCGID() != ID_CG_RETURN) &&
            IsPointer() && 
            ((CG_POINTER *)this)->IsBasicRefPointer();
    attributes->IsDontCallFreeInst = (unsigned short) pParam->GetDontCallFreeInst();
    attributes->IsPipe = (unsigned short) IsPipeOrPipeReference();
    attributes->SaveForAsyncFinish = (unsigned short) pParam->IsSaveForAsyncFinish();

    if ( (attributes->IsPipe) || (GetCGID() == ID_CG_CONTEXT_HDL) ||
         (IsPointer() && pChild && (pChild->GetCGID() == ID_CG_CONTEXT_HDL)))
        attributes->MustFree = 0;
    else
        attributes->MustFree = 1;

    attributes->ServerAllocSize = 0;

    if ( GetCGID() == ID_CG_PTR ) 
        {
        long Size = 0;

        (void) 
        ((CG_POINTER *)this)->InterpreterAllocatesOnStack( pCCB, 
                                                           pParam, 
                                                           &Size );

        attributes->ServerAllocSize = unsigned short(Size / 8);
        }

    //
    // Now make a final check for a simple ref pointer to a basetype and for 
    // a ref pointer to pointer.
    //
    // We mark pointers to basetypes as being both a basetype and a simple 
    // ref pointer.  Kind of an anomoly, but it works out well in the 
    // interpreter.  
    //
    // For both of these cases the pointer must have no allocate attributes
    // and can not be a return value.
    //
    if ( 
         IsPointer() && 
         (((CG_POINTER *)this)->GetPtrType() == PTR_REF) &&

         ! IS_ALLOCATE( ((CG_POINTER *)this)->GetAllocateDetails(), 
                        ALLOCATE_ALL_NODES ) &&
         ! IS_ALLOCATE( ((CG_POINTER *)this)->GetAllocateDetails(), 
                        ALLOCATE_DONT_FREE ) &&

         (pParam->GetCGID() != ID_CG_RETURN) 
       )
        {
        //
        // Now make sure it's a pointer to basetype and that it is either 
        // [in] or [in,out] (in which case we use the buffer to hold it) or 
        // that it is [out] and there is room for it on the interpreter's 
        // stack.  We don't mark enum16s as SimpleRef-Basetype because of
        // their special handling (i.e. wire size != memory size).
        //
        if ( ((CG_POINTER *)this)->IsPointerToBaseType() && 
             ( pParam->IsParamIn() ||
               (((CG_POINTER *)this)->GetFormatAttr() & FC_ALLOCED_ON_STACK) ) )
            {
            if ( ((CG_BASETYPE *)pChild)->GetFormatChar() != FC_ENUM16 )
                {
                attributes->IsBasetype = 1;
                attributes->IsSimpleRef = 1;
                }
            attributes->MustFree = 0;
            }
        }
}

void
CG_NDR::GenNdrParamDescription( CCB * pCCB )
{
    FORMAT_STRING *     pProcFormatString;
    PARAM_ATTRIBUTES    Attributes;
    long                FormatStringOffset;
    CG_PARAM *          pParam;
    CG_NDR *            pChild;

    pChild = (CG_NDR *) GetChild();

    if ( pChild && (pChild->GetCGID() == ID_CG_GENERIC_HDL) )
        pChild = (CG_NDR *) pChild->GetChild();

    pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();
    
    pProcFormatString = pCCB->GetProcFormatString();
    
    // Attributes.

    GetNdrParamAttributes( pCCB, &Attributes );

    pProcFormatString->PushParamFlagsShort( *((short *)&Attributes) );

    // Stack offset as number of ints.
    pProcFormatString->PushUShortStackOffsetOrSize(
            pParam->GetStackOffset( pCCB, I386_STACK_SIZING ) );

    //
    // If we found a pointer to a basetype, make sure and emit the basetype's
    // param format.
    //
    if ( Attributes.IsSimpleRef && Attributes.IsBasetype )
        {
        pProcFormatString->PushFormatChar( 
                ((CG_BASETYPE *)pChild)->GetFormatChar() );
        pProcFormatString->PushByte( 0 );
        return;
        }

    if ( Attributes.IsSimpleRef ) 
        {
        CG_POINTER *    pPointer;

        pPointer = (CG_POINTER *) this;

        switch ( pPointer->GetCGID() )
            {
            case ID_CG_STRING_PTR :
                if ( ((CG_STRING_POINTER *)pPointer)->IsStringableStruct() )
                    FormatStringOffset = GetFormatStringOffset();
                else
                    FormatStringOffset = pPointer->GetFormatStringOffset() + 2;
                break;

            case ID_CG_SIZE_STRING_PTR :
                if ( ((CG_STRING_POINTER *)pPointer)->IsStringableStruct() )
                    FormatStringOffset = GetFormatStringOffset();
                else
                    FormatStringOffset = pPointer->GetPointeeFormatStringOffset();
                break;

            case ID_CG_STRUCT_STRING_PTR :
                FormatStringOffset = GetFormatStringOffset();
                break;

            default :
                FormatStringOffset = pPointer->GetPointeeFormatStringOffset();
                break;
            }
        }
    else
        {
        FormatStringOffset = GetFormatStringOffset();
        }

    //
    // Push the offset in the type format string to the param's description.
    //
    pProcFormatString->PushShortTypeOffset( FormatStringOffset );
}

void
CG_NDR::GenNdrParamDescriptionOld( CCB * pCCB )
{
    FORMAT_STRING * pProcFormatString;
    CG_PARAM *      pParam;
    long            StackSize;
    long            StackElem;

    pProcFormatString = pCCB->GetProcFormatString();

    pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    if ( pCommand->Is64BitEnv() )
        StackElem = 8;
    else
        StackElem = 4;
    
    StackSize = pParam->GetStackSize();

    StackSize = (StackSize + StackElem - 1) & ~ (StackElem - 1);

    pProcFormatString->PushSmallStackSize( (char) (StackSize / StackElem) );

    //
    // Push the offset in the type format string to the param's description.
    //
    pProcFormatString->PushShortTypeOffset( GetFormatStringOffset() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\netmon.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1998-2000 Microsoft Corporation

 Module Name:

    netmon.cxx

 Abstract:

    Generate C code for the stub DLL's used for Netmon debugging

 Notes:

    Two files are generated by this file:  
        xxx_netmon_stub.c
        xxx_netmob_stub_obj.c


 History:

    - Created 7/28/98 by Max Attar Feingold
 ----------------------------------------------------------------------------*/

#include "becls.hxx"

// Stub version
#define NETMON_STUB_VERSION "(float) 1.0"

#pragma hdrstop

CG_STATUS
CG_NETMONSTUB_FILE::GenCode(
    CCB     *   pCCB)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the Netmon stub file for classic and object interfaces

 Arguments:

    pCCB    - The code gen controller block.
    
 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
{

    ISTREAM             Stream( GetFileName(), 4 );
    ISTREAM *           pStream = pCCB->SetStream( &Stream, this );

    m_pCCB = pCCB;
    m_pStream = pStream;

    // Scan for interfaces of the appropriate type
    ScanInterfaces();
    if (!m_bDoObject && !m_bClassic ||
        m_bDoObject && !m_bObject) {
        m_pStream->Close();
        return CG_OK;
    }

    // If m_bDoObject is TRUE, then we're producing a stub file for object interfaces;
    // otherwise, we're doing classic interfaces
    if (m_bDoObject) {
        EmitFileHeadingBlock (pCCB, "code for an object interface Netmon stub DLL", 
            "This file should be compiled as source for a DLL, linked with rpcrt4.lib");
    } else {
        EmitFileHeadingBlock (pCCB, "code for a classic interface Netmon stub DLL", 
            "This file should be compiled as source for a DLL, linked with rpcrt4.lib");
    }

    // Write standard include files
    EmitStandardIncludes();

    // Write local include files
    EmitLocalIncludes();

    // Write definitions (#defines and variables needed by the code)
    EmitDefinitions();

    if (m_bDoObject) {
        
        // We seem to need this to solve a link error
        OpenComment();
        EmitComment ("This implementation is needed to solve a link error");
        CloseComment();
        pStream->NewLine();
        pStream->Write ("ULONG STDMETHODCALLTYPE CStdStubBuffer_Release "\
            "(IRpcStubBuffer *This) { ULONG u = 0; return u; }");
        
        // Write the special data for object interfaces
        EmitObjectInterfaceData();
    }

    // Write the server and client debug procedures for each interface
    EmitDebugProcedures();

    // Write the data tables
    EmitDataTables();

    // Close the header block
    EmitFileClosingBlock( pCCB );

    // Close the stream
    pStream->Close();

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Descriptions:

    Determine which types of interfaces (object or classic) we have and how many,
    adding the names to the interface table

 Arguments:
    
 Return Value:

    TRUE if yes
    FALSE if no
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::ScanInterfaces() {
    
    CG_ITERATOR I;
    CG_NDR * pCG;
    
    GetMembers( I );
    while( ITERATOR_GETNEXT( I, pCG ) )
    {
		// We check GetChild()'s non-nullness here and elsewhere in the code because
		// there are object interfaces without children that cause problems, such as IUnknown
        if (pCG->GetChild()) {
            switch(pCG->GetCGID())
            {
            case ID_CG_INTERFACE:
                m_bClassic = TRUE;
                m_lNumClassicInterfaces ++;
                m_itInterfaceTable.AddInterface (((CG_INTERFACE*)pCG)->GetInterfaceName());
                break;
                
            case ID_CG_OBJECT_INTERFACE:
                m_bObject = TRUE;
                m_lNumObjectInterfaces ++;
                m_itInterfaceTable.AddInterface (((CG_INTERFACE*)pCG)->GetInterfaceName());
                break;
                
            default:
                break;
            }
        }
    }

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Descriptions:

    Respectively,
    -Open a comment block
    -Write comments
    -Close a comment block

 Arguments:
    
      pszString is the comment that should be emitted

 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::OpenComment() {
    
    m_pStream->NewLine();
    m_pStream->NewLine();
    m_pStream->Write ("/*");

    return CG_OK;
}

CG_STATUS CG_NETMONSTUB_FILE::EmitComment (char* pszString) {
    
    m_pStream->NewLine();
    m_pStream->Write (" * ");
    m_pStream->Write (pszString);

    return CG_OK;
}

CG_STATUS CG_NETMONSTUB_FILE::CloseComment() {
    
    m_pStream->NewLine();
    m_pStream->Write (" */");

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the standard includes for the netmon stub dll

 Arguments:
    
 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitStandardIncludes() {

	m_pStream->NewLine();
    m_pStream->Write ("#include <stdio.h>");

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the local includes for the netmon stub dll.

 Arguments:
    
 Return Value:

    CG_OK   if all is well.
        
 Notes:

    Local includes are the proxy and iid files for object interfaces
    and the stub file for classic interfaces.

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitLocalIncludes() {

    m_pStream->NewLine(2);
    
    // This is defined to avoid target errors
    m_pStream->Write ("#define _WIN32_DCOM");
    
    // Write includes
    m_pStream->NewLine();
    if (m_bDoObject) {
        m_pStream->Write ("#include \"");
        m_pStream->Write (pCommand->GetProxyFName());
        m_pStream->Write ("\"");
        m_pStream->NewLine();
        m_pStream->Write ("#include \"");
        m_pStream->Write (pCommand->GetIIDFName());
        m_pStream->Write ("\"");
        m_pStream->NewLine();
    } else {
        m_pStream->Write ("#include \"");
        m_pStream->Write (pCommand->GetSstubFName());
        m_pStream->Write ("\"");
        m_pStream->NewLine();
    }

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate any definitions needed by the netmon stub dll.

 Arguments:
    
 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
const char* ppszIncludeBlock[] = {
    "#define DLL_EXPORT_PROC(x) __declspec(dllexport) GLOBAL_INTERFACE_DATA* GetGlobalInterfaceData__##x () { return &GlobalInterfaceData__##x ; }",
    "#define NetmonStubAllocate(x) malloc(x)",
    "#define Debug() *pNull = 0",
    "static DWORD* pNull = NULL;",
    NULL
};

const char* ppszGlobalInterfaceDataStructure[] = {
	"float Version;",
    "char* InterfaceName;",
    "DWORD ProcFormatStringSize;",
    "DWORD NumProcedures;",
    "char** ProcedureNames;",
    "SERVER_ROUTINE* ServerRoutineTable;",
    "SERVER_ROUTINE* ClientRoutineTable;",
    "RPC_SERVER_INTERFACE* RpcServerInterface;",
    "void* DebugArgumentBuffer;",
    NULL
};

CG_STATUS CG_NETMONSTUB_FILE::EmitDefinitions() {

    if (!m_bDoObject) {
        m_pStream->NewLine();
        m_pStream->Write ("#pragma warning (disable : 4700) /* No warnings from the "\
			"use of uninitialized variables */");
        m_pStream->NewLine();
    }
    m_pStream->WriteBlock (ppszIncludeBlock);

    OpenComment();
    EmitComment ("Structure used to encapsulate all relevant interface information");
    CloseComment();

    m_pStream->NewLine(2);
    m_pStream->Write ("typedef struct _GLOBAL_INTERFACE_DATA {");
    Out_IndentInc( m_pCCB );
    m_pStream->WriteBlock (ppszGlobalInterfaceDataStructure);
    Out_IndentDec( m_pCCB );
    m_pStream->NewLine();
    m_pStream->Write ("} GLOBAL_INTERFACE_DATA;");

    OpenComment();
    EmitComment ("Function used to view unmarshalled argument buffers");
    CloseComment();
    m_pStream->NewLine();
    m_pStream->Write ("static void DebugArgumentBuffer (BYTE* ArgumentBuffer, DWORD BufferSize) "\
        "{ Debug(); }");

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the data used specifically by object interfaces.

 Arguments:
    
 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitObjectInterfaceData() {

    CG_ITERATOR I;
    CG_NDR * pCG;

    OpenComment();
    EmitComment ("Data used specifically by object interfaces");
    CloseComment();
    
    // Loop through all interfaces
    GetMembers( I );
    while( ITERATOR_GETNEXT( I, pCG ) ) {
        
        if (pCG->GetChild()) {
            
            switch(pCG->GetCGID()) {

            case ID_CG_OBJECT_INTERFACE:
                
                // Emit the object interface RPC_SERVER_INTERFACE structures
                OpenComment();
                EmitComment ("RPC_SERVER_INTERFACE structure for object interface ");
                m_pStream->Write (pCG->GetSymName());
                CloseComment();
                
                EmitRPCServerInterface ((CG_INTERFACE*) pCG);   
                
                break;
                
            default:
                break;
            }
        }
    }

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate an RPC_SERVER_INTERFACE structure for the given interface

 Arguments:
    
 Return Value:

    CG_OK   if all is well.
        
 Notes:
 
   Most of the code was taken from misccls.cxx -> CG_INTERFACE::GenServerStub

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitRPCServerInterface (CG_INTERFACE* pCG) {
    
    GUID_STRS TransferSyntaxGuid( TRANSFER_SYNTAX_GUID_STR_1,
                                  TRANSFER_SYNTAX_GUID_STR_2,
                                  TRANSFER_SYNTAX_GUID_STR_3,
                                  TRANSFER_SYNTAX_GUID_STR_4,
                                  TRANSFER_SYNTAX_GUID_STR_5);
    GUID_STRS GuidStrs;
    unsigned short M, m;
    char Buffer[ _MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1 ];
    long ProtSeqEPCount = 0;
    ITERATOR * pProtSeqIterator;
    
    GuidStrs = pCG->GetGuidStrs();
    
    m_pCCB->SetInterfaceCG (pCG);
    m_pCCB->SetInterfaceName (pCG->GetInterfaceName());
    m_pCCB->GetVersion( &M,&m );
    
    sprintf( Buffer,
            "&%s_%s_DispatchTable",
            pCG->GetInterfaceName(),
            m_pCCB->GenMangledName()
            );

    if ( ( pProtSeqIterator = pCG->GetProtSeqEps() ) != 0 ) 
        {
            ProtSeqEPCount = ITERATOR_GETCOUNT( *pProtSeqIterator );
            Out_EP_Info( m_pCCB, pProtSeqIterator );
        }

    Out_IFInfo( m_pCCB,                         // controller block.
                RPC_S_INT_INFO_TYPE_NAME,       // interface info type name.
                RPC_S_INT_INFO_STRUCT_NAME,     // variable name.
                SIZEOF_RPC_SERVER_INTERFACE,    // string speicifying size.
                GuidStrs,                       // Guid specified in idl
                M,                              // user specified major version
                m,                              // user specified minor version
//                TransferSyntaxGuid,             // ndr identifying guid.
//                NDR_UUID_MAJOR_VERSION,         // ndr's version
//                NDR_UUID_MINOR_VERSION,
                NULL, //Buffer,
                ProtSeqEPCount,                 // if this is 0, then the next
                // 2 fields are ignored by the call.
                PROTSEQ_EP_TYPE_NAME,           // RPC_PROTSEQ_ENDPOINT
                PROTSEQ_EP_VAR_NAME,            // ___RpcProtSeqEndpoint
                m_pCCB->IsNoDefaultEpv(),
                1,
                pCG->HasPipes()
                );

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the debug procedures for all interfaces

 Arguments:
    
 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitDebugProcedures() {

    CG_ITERATOR I;
    CG_NDR * pCG;
    
    CG_PROC * pProc;
    CG_INTERFACE * pInt;

    ID_CG idCg;

    ITERATOR IProc;

    char* pszInterfaceName, * pszLastInterfaceName, * pszOurInterfaceName;

    // Write midl malloc and free if we're writing a classic interface stub
    if (!m_bDoObject) {
        OpenComment();
        EmitComment ("Procedures used by the runtime to allocate and free memory");
        CloseComment();

        m_pStream->NewLine(2);
        m_pStream->Write (
            "static void * __RPC_API midl_user_allocate(size_t len) { return NetmonStubAllocate(len); }");
        m_pStream->NewLine();
        m_pStream->Write (
            "static void __RPC_API midl_user_free(void * ptr) { free(ptr); }");
    }

    OpenComment();
    EmitComment ("Implementation of debug server and client functions for all ");
    if (m_bDoObject) {
        m_pStream->Write ("object");
    } else {
        m_pStream->Write ("classic");
    }
    m_pStream->Write (" interfaces");
    CloseComment();

    // Loop through all interfaces
    GetMembers( I );
    while( ITERATOR_GETNEXT( I, pCG ) )
    {
        if (pCG->GetChild()) {
            
            pInt = (CG_INTERFACE*) pCG;
            idCg = pCG->GetCGID();
            
            switch(idCg) {
                
            case ID_CG_INTERFACE:
                
                if (!m_bDoObject) {
                    
                    // Loop through all member functions
                    pInt->GetAllMemberFunctions( IProc );
                    while( ITERATOR_GETNEXT( IProc, pProc ) ) {
                        
                        EmitServerClientDebugProcedure (pProc, FALSE);
                        
                        // Emit the procedure as is (to avoid link errors)
                        m_pStream->NewLine(2);
                        m_pStream->Write ("static");
                        Out_ClientProcedureProlog( m_pCCB, pProc->GetType() );
                        Out_IndentInc( m_pCCB );
                        
                        // Return a variable of the appropriate return value
                        if (((node_proc*) pProc->GetType())->HasReturn()) {
                            m_pStream->Spaces( STANDARD_STUB_TAB );
                            m_pStream->Write( pProc->GetReturnType()->GetSymName() );
                            m_pStream->Write(" RetVal;");
                            m_pStream->NewLine();
                            m_pStream->Write( "return RetVal;" );
                        }
                        
                        // Close the procedure
                        Out_IndentDec( m_pCCB );
                        Out_ProcClosingBrace( m_pCCB );
                    }
                }
                
                break;
                
            case ID_CG_OBJECT_INTERFACE:
                
                if (m_bDoObject) {
                    
                    pszOurInterfaceName = pInt->GetInterfaceName();
                    pszLastInterfaceName = NULL;

                    // Loop through all member functions
                    pInt->GetAllMemberFunctions ( IProc);
                    while( ITERATOR_GETNEXT( IProc, pProc ) ) {
                        
                        // Get the procedure's real interface name
                        pszInterfaceName = pProc->GetInterfaceNode()->GetInterfaceName();
                        
                        // Write the function if:
                        // a) We're its real interface.
                        // b) The interface hasn't been used yet and it's not IUnknown
                        // c) The interface name is the same as the last one we used
                        // (so it's OK to use it again)
                        if (strcmp (pszInterfaceName, pszOurInterfaceName) == 0 ||
                            (!m_itOutputInterfaceTable.FindInterface (pszInterfaceName) &&
                             strcmp (pszInterfaceName, "IUnknown") != 0) ||
                            (pszLastInterfaceName != NULL &&
                             strcmp (pszInterfaceName, pszLastInterfaceName) == 0)
                             ) {
                            
                            // Write the server and client debug procedures
                            EmitServerClientDebugProcedure (pProc, TRUE);

                            // Add the interface name to the table of used interfaces
                            m_itOutputInterfaceTable.AddInterface (pszInterfaceName);

                            // Record the last interface name used
                            pszLastInterfaceName = pszInterfaceName;
                        }
                    }
                }
                
                break;
                
            default:
                break;
            }
        }
    }

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate server, client and link stub procedures for a given procedure

 Arguments:
    
      pProc -> The procedure to be processed
      bIsObject ->  TRUE if the procedure belongs to an object interface
                    FALSE otherwise
 Return Value:

    CG_OK   if all is well.
        
 Notes:
 
   This function is long and ugly

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitServerClientDebugProcedure (CG_PROC* pProc, BOOL bIsObject) {

    PNAME pszProcName, pszNewProcName;

    node_proc * pNodeProc = ((node_proc*) pProc->GetType());
    node_param * pRetValParam, * pThisParam, * pParam;
    node_skl * pOldRetType;
    node_base_type * pVoidBaseType;
    type_node_list ITypeNodeList;
    
    short i, siNumArgs;
    PNAME* ppszOldArgName;
    PNAME* ppszNewArgName;
    node_base_attr * pNodeAttribIn, * pNodeAttribOut;

    BOOL bHasReturn = pNodeProc->HasReturn();

    // Get the procedure name
    pszProcName = pProc->GetSymName();
                
    // Rename the procedure to Server__InterfaceName__ProcName
    pszNewProcName = new char [strlen (pProc->GetInterfaceName()) + 
        strlen (pszProcName) + 11];
    sprintf ( pszNewProcName, "Server__%s__%s", pProc->GetInterfaceName(), pszProcName );
    pNodeProc->SetSymName ( pszNewProcName );
                
    // Set void type
    pVoidBaseType = new node_base_type( NODE_VOID, ATTR_BASE );
    pVoidBaseType->SetSymName( "void" );
    pOldRetType = pNodeProc->GetChild();
    pNodeProc->SetChild( pVoidBaseType );
                
    // Rename the arguments to IN__Name, OUT__Name or IN_OUT__name
    i = 0;
    siNumArgs = pNodeProc->GetNumberOfArguments();
        
    ppszOldArgName = new PNAME [siNumArgs];
    ppszNewArgName = new PNAME [siNumArgs];
                
    pNodeProc->GetParameterList (&ITypeNodeList);
    while( ITERATOR_GETNEXT( ITypeNodeList, pParam ) ) {
                
        MIDL_ASSERT (i < siNumArgs);
                    
        ppszOldArgName[i] = pParam->GetSymName();
        ppszNewArgName[i] = new char [strlen (ppszOldArgName[i]) + 10];
                    
        if ((pNodeAttribIn = pParam->GetAttribute (ATTR_IN)) && 
            (pNodeAttribOut = pParam->GetAttribute (ATTR_OUT))) {
            sprintf (ppszNewArgName[i], "IN_OUT__%s", ppszOldArgName[i]);
        } else {
                        
            if (pNodeAttribIn) {
                sprintf (ppszNewArgName[i], "IN__%s", ppszOldArgName[i]);
            } else {
                sprintf (ppszNewArgName[i], "OUT__%s", ppszOldArgName[i]);
            }
        }
        pParam->SetSymName (ppszNewArgName[i]);
        i ++;           
    }
    
    // If proc belongs to an object interface, add the 'this' pointer
    if (bIsObject) {
        pThisParam = new node_param();
        pThisParam->SetAttribute (ATTR_IN);
        pThisParam->SetSymName ("this");
        pThisParam->SetBasicType( (node_skl *) new node_def( "void*" ));
        pThisParam->SetEdgeType( EDGE_USE );
                    
        pNodeProc->AddFirstMember (pThisParam);
    }

    // Emit the server procedure
    m_pStream->NewLine(2);
    m_pStream->Write ("static");
    Out_ClientProcedureProlog( m_pCCB, pNodeProc );
    Out_IndentInc( m_pCCB );
    m_pStream->Spaces( STANDARD_STUB_TAB );
    m_pStream->Write( "Debug();" );
    Out_IndentDec( m_pCCB );
    Out_ProcClosingBrace( m_pCCB );
    
    // Rename the procedure to Client__InterfaceName__ProcName
    sprintf( pszNewProcName, "Client__%s__%s", pProc->GetInterfaceName(), pszProcName );
    
    // Add a RetVal parameter to the param list if the function isn't void
    if (bHasReturn) {
            
        pRetValParam = new node_param();
        pRetValParam->SetAttribute (ATTR_IN);
        pRetValParam->SetSymName ("RetVal");
        pRetValParam->SetBasicType( (node_skl *) new node_def( pProc->GetReturnType()->GetSymName() ));
        pRetValParam->SetEdgeType( EDGE_USE );
                    
        pNodeProc->AddLastMember (pRetValParam);
    }
                
    // Emit the client procedure
    m_pStream->NewLine(2);
    m_pStream->Write ("static");
    Out_ClientProcedureProlog( m_pCCB, pNodeProc );
    Out_IndentInc( m_pCCB );
    m_pStream->Spaces( STANDARD_STUB_TAB );
    m_pStream->Write( "Debug();" );
    Out_IndentDec( m_pCCB );
    Out_ProcClosingBrace( m_pCCB );
    
    // Delete the this parameter we created
    if (bIsObject) {
        pNodeProc->RemoveFirstMember();
        delete pThisParam;
    }

    // Delete the RetVal from the param List
    if (bHasReturn) {
        pNodeProc->RemoveLastMember();
        delete pRetValParam;
    }
                
    // Restore the procedure's name
    pNodeProc->SetSymName( pszProcName );
    
    // Restore the procedure's parameter names
    if (siNumArgs > 0) {
        i = 0;
        pNodeProc->GetParameterList (&ITypeNodeList);
        while( ITERATOR_GETNEXT( ITypeNodeList, pParam ) ) {
            pParam->SetSymName (ppszOldArgName[i]);
            delete [] ppszNewArgName[i];
            i ++;
        }
        delete [] ppszNewArgName;
        delete [] ppszOldArgName;
    }

    // Restore the node's return type
    pNodeProc->SetChild( pOldRetType );
    
    // Delete the fake void type node we created
    delete pVoidBaseType;
                
    // Delete the new name we created
    delete [] pszNewProcName;

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate data tables for each interface

 Arguments:

 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitDataTables() {

    // Write procedure name tables for each interface
    EmitProcNameTables();

    // Write the server and client lookup tables for each interface
    EmitServerClientTables();

    // Write the global_interface_data structures and exports for each interface
    EmitGlobalInterfaceData();

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate tables with each interface's procedure names and the number of 
    procedures in each interface.

 Arguments:

 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitProcNameTables() {

    CG_ITERATOR I;
    CG_NDR * pCG;
    CG_INTERFACE* pInt;

    ITERATOR IProc;
    CG_PROC * pProc;

    long lNumProcs;
    BOOL bBeenHereBefore;

    char* pszInterfaceName;
    char pszTemp [1024];

    GetMembers( I );
    while( ITERATOR_GETNEXT( I, pCG ) ) {
        
        if (pCG->GetChild()) {
            
            pInt = (CG_INTERFACE*) pCG;
            
            if (m_bDoObject && pCG->GetCGID() == ID_CG_OBJECT_INTERFACE ||
                !m_bDoObject && pCG->GetCGID() == ID_CG_INTERFACE) {
                
                lNumProcs = 0;
                bBeenHereBefore = FALSE;
                
                pszInterfaceName = pInt->GetInterfaceName();
                
                OpenComment();
                EmitComment ("Procedure tables for interface ");
                m_pStream->Write (pszInterfaceName);
                CloseComment();
                
                m_pStream->NewLine();
                sprintf (pszTemp, "static char* %s__ProcedureNames[] = {", pszInterfaceName);
                m_pStream->Write (pszTemp);
                
                Out_IndentInc( m_pCCB );
                
                pInt->GetAllMemberFunctions ( IProc);
                while( ITERATOR_GETNEXT( IProc, pProc ) ) {
                    
                    pszInterfaceName = pProc->GetInterfaceNode()->GetInterfaceName();
                    if (strcmp (pszInterfaceName, "IUnknown") != 0) {
                        
                        // Write a comma if we're not the first function in the list
                        if (bBeenHereBefore) {
                            m_pStream->Write (",");
                        } else {
                            bBeenHereBefore = TRUE;
                        }

                        // Write procedure name enclosed in quotes
                        m_pStream->NewLine();
                        m_pStream->Write ("\"");
                        m_pStream->Write (pProc->GetSymName());
                        m_pStream->Write ("\"");

                        // Increment procedure count
                        lNumProcs ++;
                    }
                }
                
                Out_IndentDec( m_pCCB );
                m_pStream->NewLine();
                m_pStream->Write ("};");

                // Set number of procedures in interface table
                m_itInterfaceTable.SetNumProcedures (pszInterfaceName, lNumProcs);
            }
        }   // if
    }   // while

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server and client lookup tables for each interface

 Arguments:

 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitServerClientTables() {

    CG_ITERATOR I;
    CG_NDR * pCG;
    CG_INTERFACE* pInt;

    ITERATOR IProc;
    CG_PROC * pProc;

    char* pszInterfaceName;

    GetMembers( I );
    while( ITERATOR_GETNEXT( I, pCG ) ) {
    
        if (pCG->GetChild()) {
            
            if (m_bDoObject && pCG->GetCGID() == ID_CG_OBJECT_INTERFACE ||
                !m_bDoObject && pCG->GetCGID() == ID_CG_INTERFACE) {
                
                pInt = (CG_INTERFACE*) pCG;
                pszInterfaceName = pInt->GetInterfaceName();
                
                // Write the server table
                OpenComment();
                EmitComment ("Debug server procedures for interface ");
                m_pStream->Write (pszInterfaceName);
                CloseComment();
                m_pStream->NewLine();
                
                m_pStream->Write ("static SERVER_ROUTINE ");
                m_pStream->Write (pszInterfaceName);
                m_pStream->Write ("__ServerRoutineTable[] = {");
                Out_IndentInc( m_pCCB );
                
                // If we're processing an object interface, 
                // we have to make room for the 3 IUnknown procedures
                if (m_bDoObject) {
                    m_pStream->NewLine();
                    m_pStream->Write ("NULL,");
                    m_pStream->NewLine();
                    m_pStream->Write ("NULL,");
                    m_pStream->NewLine();
                    m_pStream->Write ("NULL,");
                }
                
                pInt->GetAllMemberFunctions ( IProc);
                while( ITERATOR_GETNEXT( IProc, pProc ) ) {
                    
                    pszInterfaceName = pProc->GetInterfaceNode()->GetInterfaceName();
                    if (strcmp (pszInterfaceName, "IUnknown") != 0) {
                        m_pStream->NewLine();
                        m_pStream->Write ("(SERVER_ROUTINE)Server__");
                        m_pStream->Write (pProc->GetInterfaceNode()->GetSymName());
                        m_pStream->Write ("__");
                        m_pStream->Write (pProc->GetSymName());
                        m_pStream->Write (",");
                    }
                }
                Out_IndentDec( m_pCCB );
                m_pStream->NewLine();
                m_pStream->Write ("};");
                
                // Write client table
                OpenComment();
                EmitComment ("Debug client procedures for interface ");
                m_pStream->Write (pszInterfaceName);
                CloseComment();
                m_pStream->NewLine();
                
                m_pStream->Write ("static SERVER_ROUTINE ");
                m_pStream->Write (pszInterfaceName);
                m_pStream->Write ("__ClientRoutineTable[] = {");
                Out_IndentInc( m_pCCB );
                
                // If we're processing an object interface, 
                // we have to make room for the 3 IUnknown procedures
                if (m_bDoObject) {
                    m_pStream->NewLine();
                    m_pStream->Write ("NULL,");
                    m_pStream->NewLine();
                    m_pStream->Write ("NULL,");
                    m_pStream->NewLine();
                    m_pStream->Write ("NULL,");
                }
                
                pInt->GetAllMemberFunctions ( IProc);
                while( ITERATOR_GETNEXT( IProc, pProc ) ) {
                    
                    pszInterfaceName = pProc->GetInterfaceNode()->GetInterfaceName();
                    if (strcmp (pszInterfaceName, "IUnknown") != 0) {
                        m_pStream->NewLine();
                        m_pStream->Write ("(SERVER_ROUTINE)Client__");
                        m_pStream->Write (pProc->GetInterfaceNode()->GetSymName());
                        m_pStream->Write ("__");
                        m_pStream->Write (pProc->GetSymName());
                        m_pStream->Write (",");
                    }
                }
                Out_IndentDec( m_pCCB );
                m_pStream->NewLine();
                m_pStream->Write ("};");
            }
        }
    }

    return CG_OK;
}



/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the global interface data structures for each interface, as well
    as the export functions that return them

 Arguments:

 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitGlobalInterfaceData() {

    CG_ITERATOR I;
    CG_NDR * pCG;
    ID_CG idCG;
    
    char pszTemp [100], * pszInterfaceName, * pszFixedUuid;
    char * p1, * p2, * p3, * p4, * p5;
    long lNumProcs;
    size_t lLength;

    GetMembers( I );
    while( ITERATOR_GETNEXT( I, pCG ) ) {

        idCG = pCG->GetCGID();

        if (((idCG == ID_CG_OBJECT_INTERFACE && m_bDoObject) || 
            (idCG == ID_CG_INTERFACE && !m_bDoObject)) &&
            pCG->GetChild()) {

            // Get the underscored uuid
            ((CG_INTERFACE*) pCG)->GetGuidStrs().GetStrs (p1, p2, p3, p4, p5);
            lLength = (long) strlen (p1) + strlen (p2) + strlen (p3) + strlen (p4) + strlen (p5);
            pszFixedUuid = new char [lLength + 5];
            sprintf (pszFixedUuid, "%s_%s_%s_%s_%s", p1, p2, p3, p4, p5);
            pszFixedUuid = _strlwr (pszFixedUuid);

            // Get the interface name
            pszInterfaceName = pCG->GetSymName();

            // Write a comment
            OpenComment();
            EmitComment ("GLOBAL_INTERFACE_DATA structure for interface ");
            m_pStream->Write (pszInterfaceName);
            CloseComment();

            // Header
            m_pStream->NewLine();
            m_pStream->Write ("static GLOBAL_INTERFACE_DATA GlobalInterfaceData__");
            m_pStream->Write (pszFixedUuid);
            m_pStream->Write (" = {");
            Out_IndentInc( m_pCCB );

			// Version
			m_pStream->NewLine();
			m_pStream->Write (NETMON_STUB_VERSION);
			m_pStream->Write (",");

            // Name
            m_pStream->NewLine();
            m_pStream->Write ("\"");
            m_pStream->Write (pszInterfaceName);
            m_pStream->Write ("\",");

            // Proc format string size
            m_pStream->NewLine();
            m_pStream->Write ("PROC_FORMAT_STRING_SIZE,");

            // NumProcs
            m_pStream->NewLine();
            if (m_itInterfaceTable.GetNumProcedures (pszInterfaceName, &lNumProcs)) {
                m_pStream->Write (_itoa (lNumProcs, pszTemp, 10));
            } else {
                MIDL_ASSERT (FALSE);
            }
            m_pStream->Write (",");

            // Proc name table
            m_pStream->NewLine();
            m_pStream->Write (pszInterfaceName);
            m_pStream->Write ("__ProcedureNames,");

            // Server routine table
            m_pStream->NewLine();
            m_pStream->Write (pszInterfaceName);
            m_pStream->Write ("__ServerRoutineTable,");

            // Client routine table
            m_pStream->NewLine();
            m_pStream->Write (pszInterfaceName);
            m_pStream->Write ("__ClientRoutineTable,");
            
            // Rpc server interface pointer
            m_pStream->NewLine();
            m_pStream->Write ("(RPC_SERVER_INTERFACE*) &");
            m_pStream->Write (pszInterfaceName);
            m_pStream->Write ("___RpcServerInterface,");

            // DebugArgumentBuffer
            m_pStream->NewLine();
            m_pStream->Write ("(void*) DebugArgumentBuffer");

            Out_IndentDec( m_pCCB );
            m_pStream->NewLine();
            m_pStream->Write ("};");

            // Export function
            OpenComment();
            EmitComment ("Export function for interface ");
            m_pStream->Write (pszInterfaceName);
            CloseComment();

            m_pStream->NewLine();
            m_pStream->Write ("DLL_EXPORT_PROC (");
            m_pStream->Write (pszFixedUuid);
            m_pStream->Write (")");

            delete [] pszFixedUuid;
        }
    }

    return CG_OK;
}

/****************************************************
* InterfaceTable implementations
****************************************************/
#define NUM_BUCKETS 100
NetmonStubFileInterfaceTable::NetmonStubFileInterfaceTable() {
    m_pTable = new NetmonStubFileInterfaceList [NUM_BUCKETS];
}

NetmonStubFileInterfaceTable::~NetmonStubFileInterfaceTable() {
    delete [] m_pTable;
}

void NetmonStubFileInterfaceTable::AddInterface (char* pszInterface) {
    m_pTable[GetHashValue (pszInterface)].AddInterface (pszInterface);  
}

// Return true if the interface name was found
BOOL NetmonStubFileInterfaceTable::FindInterface (char* pszInterface) {
    return m_pTable[GetHashValue (pszInterface)].FindInterface (pszInterface);
}

// Set the number of procedures in the interface
BOOL NetmonStubFileInterfaceTable::SetNumProcedures (char* pszInterface, long lNumProcs) {
    return m_pTable[GetHashValue (pszInterface)].SetNumProcedures (pszInterface, lNumProcs);
}

// Get the number of procedures in the interface
BOOL NetmonStubFileInterfaceTable::GetNumProcedures (char* pszInterface, long* plNumProcs) {
    return m_pTable[GetHashValue (pszInterface)].GetNumProcedures (pszInterface, plNumProcs);
}

// The hash value is just the sum of the characters in the interface name
// mod the number of buckets in the table
long NetmonStubFileInterfaceTable::GetHashValue (char* pszInterface) {
    
    long i, lSum = 0, lLen = (long) strlen (pszInterface);
    for (i = 0; i < lLen; i ++) {
        lSum += (long) pszInterface[i];
    }
    return lSum % NUM_BUCKETS;
}


/* InterfaceNode */
NetmonStubFileInterfaceNode::NetmonStubFileInterfaceNode (char* pszInterface) {
    m_pszInterface = new char [strlen (pszInterface) + 1];
    strcpy (m_pszInterface, pszInterface);
    m_pNext = NULL;
    m_lNumProcs = 0;
}

NetmonStubFileInterfaceNode::~NetmonStubFileInterfaceNode() {
    delete [] m_pszInterface;
}

void NetmonStubFileInterfaceNode::SetNext (NetmonStubFileInterfaceNode* pNext) {
    m_pNext = pNext;
}

NetmonStubFileInterfaceNode* NetmonStubFileInterfaceNode::GetNext() {
    return m_pNext;
}

char* NetmonStubFileInterfaceNode::GetInterface() {
    return m_pszInterface;
}

void NetmonStubFileInterfaceNode::SetNumProcedures (long lNumProcs) {
    m_lNumProcs = lNumProcs;
}

long NetmonStubFileInterfaceNode::GetNumProcedures() {
    return m_lNumProcs;
}

/* InterfaceList */
NetmonStubFileInterfaceList::NetmonStubFileInterfaceList() {
    m_pHead = NULL;
    m_pTail = NULL;
}

NetmonStubFileInterfaceList::~NetmonStubFileInterfaceList() {
    NetmonStubFileInterfaceNode* pNode = m_pHead, *pDeleteNode;
    while (pNode != NULL) {
        pDeleteNode = pNode;
        pNode = pNode->GetNext();
        delete pDeleteNode;
    }
}

void NetmonStubFileInterfaceList::AddInterface (char* pszInterface) {
    
    NetmonStubFileInterfaceNode* pNode = new NetmonStubFileInterfaceNode (pszInterface);
        
    if (m_pHead == NULL) {
        m_pHead = m_pTail = pNode;
    } else {
        m_pTail->SetNext (pNode);
        m_pTail = pNode;
    }
}

BOOL NetmonStubFileInterfaceList::FindInterface (char* pszInterface) {

    NetmonStubFileInterfaceNode* pNode = m_pHead;
    while (pNode != NULL) {
        if (strcmp (pszInterface, pNode->GetInterface()) == 0) {
            return TRUE;
        }
        pNode = pNode->GetNext();
    }

    return FALSE;
}

BOOL NetmonStubFileInterfaceList::SetNumProcedures (char* pszInterface, long lNumProcs) {

    NetmonStubFileInterfaceNode* pNode = m_pHead;
    while (pNode != NULL) {
        if (strcmp (pszInterface, pNode->GetInterface()) == 0) {
            pNode->SetNumProcedures (lNumProcs);
            return TRUE;
        }
        pNode = pNode->GetNext();
    }

    return FALSE;
}

BOOL NetmonStubFileInterfaceList::GetNumProcedures (char* pszInterface, long* plNumProcs) {
    
    NetmonStubFileInterfaceNode* pNode = m_pHead;
    while (pNode != NULL) {
        if (strcmp (pszInterface, pNode->GetInterface()) == 0) {
            *plNumProcs = pNode->GetNumProcedures();
            return TRUE;
        }
        pNode = pNode->GetNext();
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\output.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

    output.cxx

 Abstract:

    Low level output routines for midl.

 Notes:


 History:

    Sep-18-1993     VibhasC     Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop
#include "buffer.hxx"
#include "midlvers.h"
#include "ndrtypes.h"
#include "rpc.h"

static BOOL HasExprRoutines = FALSE;

#if 0
                            Notes

    A few general rules followed throughout the file.

        1. Never emit tab other than thru the stream.
        2. Never emit a new line other than thru the stream.
        3. Emitting a new line is the responsibility of the entity that wants
           itself to be emitted on a new line. Therefore, say each local
           variable in the stub needs to be on a new line, then the routine
           responsible for emitting the local variable will be responsible
           for setting the new line.

#endif // 0

/****************************************************************************
 *  local definitions
 ***************************************************************************/
/****************************************************************************
 *  local data
 ***************************************************************************/
/****************************************************************************
 *  externs
 ***************************************************************************/
extern  CMD_ARG             *   pCommand;


void
Out_ServerProcedureProlog(
    CCB     *   pCCB,
    node_skl*   pNode,
    ITERATOR&   LocalsList,
    ITERATOR&   ParamsList,
    ITERATOR&   TransientList )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side procedure prolog.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    pNode       - A pointer to the actual procedure node.
    LocalsList  - A list of local resources.
    ParamsList  - A list of param resources.
    TransientList- A list of temp variables.

 Return Value:

 Notes:

    The server side procedure prolog generation cannot use the normal
    printtype method on the procedure node, since the server stub signature
    looks different.

    Also the name of the server side stub is mangled with the interface name.

    All server side procs are void returns.

----------------------------------------------------------------------------*/
{
    CSzBuffer TempBuffer( "void __RPC_STUB\n" );
    TempBuffer.Append( pCCB->GetInterfaceName() );
    TempBuffer.Append( "_" );
    TempBuffer.Append( pNode->GetSymName() );
    TempBuffer.Append( "(" );
    
    Out_ProcedureProlog( pCCB,
                         TempBuffer,
                         pNode,
                         LocalsList,
                         ParamsList,
                         TransientList
                       );

}

void
Out_ProcedureProlog(
    CCB     *   pCCB,
    PNAME       pProcName,
    node_skl*   ,
    ITERATOR&   LocalsList,
    ITERATOR&   ParamsList,
    ITERATOR&   TransientList )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side procedure prolog.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    pName       - A pointer to the procs name string.
    pNode       - A pointer to the actual procedure node.
    LocalsList  - A list of local resources.
    ParamsList  - A list of param resources.

 Return Value:

 Notes:

    Any name mangling is the responsibility of the caller.
----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    RESOURCE*   pRes;
    BOOL fFirst = TRUE;

    pStream->NewLine();
    pStream->Write( pProcName );
    pStream->IndentInc();

    //
    // Emit the list of parameters.
    //

    if( ITERATOR_GETCOUNT( ParamsList ) )
        {
        ITERATOR_INIT( ParamsList );

        while( ITERATOR_GETNEXT( ParamsList, pRes ) )
            {
            if(fFirst != TRUE)
                pStream->Write(',');
            pRes->GetType()->PrintType(
                                        (PRT_PARAM_WITH_TYPE | PRT_CSTUB_PREFIX),
                                        pStream,             // into stream
                                        (node_skl *)0        // no parent.
                                      );
            fFirst = FALSE;
            }
        }

    pStream->IndentDec();

    //
    // Write out the opening brace for the server proc and all that.
    //

    pStream->Write(" )");
    pStream->NewLine();
    pStream->Write( '{' );
    pStream->IndentInc();
    pStream->NewLine();

    //
    // This is where we get off for /Oi.  We have a special routine
    // for local variable declaration for /Oi.
    //
    if ( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER )
        return;

    //
    // Print out declarations for the locals.
    //

    if( ITERATOR_GETCOUNT( LocalsList ) )
        {
        ITERATOR_INIT( LocalsList );

        while( ITERATOR_GETNEXT( LocalsList, pRes ) )
            {
            pRes->GetType()->PrintType( PRT_ID_DECLARATION, // print decl
                                         pStream,        // into stream
                                         (node_skl *)0   // no parent.
                                      );
            }
        }

    if( ITERATOR_GETCOUNT( TransientList ) )
        {
        ITERATOR_INIT( TransientList );

        while( ITERATOR_GETNEXT( TransientList, pRes ) )
            {
            pStream->IndentInc();
            pRes->GetType()->PrintType( PRT_ID_DECLARATION, // print decl
                                         pStream,        // into stream
                                         (node_skl *)0   // no parent.
                                      );
            pStream->IndentDec();
            }
        }

    pStream->Write( RPC_STATUS_TYPE_NAME" "RPC_STATUS_VAR_NAME";" );

    pStream->NewLine();

    //
    // Done.
    //
}

void
Out_ClientProcedureProlog(
    CCB     *   pCCB,
    node_skl*   pNode )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the procedure prolog for the client side.

 Arguments:

    pCCB    - A pointer to the code generation controller block.
    pNode   - A pointer to the procedure node.

 Return Value:

    None.

 Notes:

    The procedure prolog consists of the return type, the proc name and the
    parameters along with the open brace.

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    PRTFLAGS    flags;

    MIDL_ASSERT( NODE_PROC == pNode->NodeKind() );

    flags = PRT_PROC_PROTOTYPE | PRT_CSTUB_PREFIX;

    if ( NULL != ( ( node_proc * ) pNode )->GetCSTagRoutine() )
        flags |= PRT_OMIT_CS_TAG_PARAMS;

    pStream->NewLine();
    pStream->NewLine(); // extra new line.

    pNode->PrintType( 
            flags,            // print the declaration only.
            pStream,          // into this stream.
            (node_skl *)0     // parent pointer not applicable.
                    );

    //
    // Write the opening brace on a new line.
    //

    pStream->WriteOnNewLine( "{" );

    pStream->NewLine();

}

void
Out_ClientLocalVariables(
    CCB             *   pCCB,
    ITERATOR&           LocalVarList )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output the list of client side local variables.


 Arguments:

    pCCB            - A pointer to the code generation controller block.
    LocalVarList    - An iterator containing the list of local variables.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();
    RESOURCE    *   pResTemp;

    ITERATOR_INIT( LocalVarList );


    while( ITERATOR_GETNEXT( LocalVarList, pResTemp ) )
        {
        pStream->IndentInc();
        pStream->NewLine();
        pResTemp->GetType()->PrintType( PRT_ID_DECLARATION,
                                                        // print top level decl
                                        pStream,        // into stream with
                                        (node_skl *)0   // parent not applicable
                                      );
        pStream->IndentDec();
        }
}


void
Out_AllocAndFreeFields(
    CCB *               pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs the alloc and free fields of the stub descriptor.

 Arguments:

    pCCB            - A pointer to the code generation controller block.

----------------------------------------------------------------------------*/
{
    ISTREAM         *   pStream;
    CG_INTERFACE    *   pIntfCG = pCCB->GetInterfaceCG();

    pStream = pCCB->GetStream();

    if ( pIntfCG->IsObject() )
        {
        pStream->Write( OLE_ALLOC_RTN_NAME );
        }
    else if ( pCCB->GetMode() )
        {
        // non-osf modes

        if ( pCCB->GetCodeGenSide() == CGSIDE_CLIENT )
            {
            pStream->Write( pIntfCG->IsAllRpcSS()
                                ? RPC_SM_CLIENT_ALLOCATE_RTN_NAME
                                : DEFAULT_ALLOC_RTN_NAME );
            }
        else
            pStream->Write( pIntfCG->IsAllRpcSS()
                                ? DEFAULT_ALLOC_OSF_RTN_NAME
                                : DEFAULT_ALLOC_RTN_NAME );
        }
    else
        {
        // osf mode

        pStream->Write( (pCCB->GetCodeGenSide() == CGSIDE_CLIENT)
                            ?  RPC_SM_CLIENT_ALLOCATE_RTN_NAME
                            :  DEFAULT_ALLOC_OSF_RTN_NAME );
        }
    pStream->Write(',');
    pStream->NewLine();

    if ( pIntfCG->IsObject() )
        {
        pStream->Write( OLE_FREE_RTN_NAME );
        }
    else if ( pCCB->GetMode() )
        {
        if ( pCCB->GetCodeGenSide() == CGSIDE_CLIENT )
            {
            pStream->Write( pIntfCG->IsAllRpcSS()
                                ? RPC_SM_CLIENT_FREE_RTN_NAME
                                : DEFAULT_FREE_RTN_NAME );
            }
        else
            pStream->Write( pIntfCG->IsAllRpcSS()
                                ? DEFAULT_FREE_OSF_RTN_NAME
                                : DEFAULT_FREE_RTN_NAME );
        }
    else
        {
        pStream->Write( (pCCB->GetCodeGenSide() == CGSIDE_CLIENT)
                            ?  RPC_SM_CLIENT_FREE_RTN_NAME
                            :  DEFAULT_FREE_OSF_RTN_NAME );
        }
    pStream->Write(',');
    pStream->NewLine();
}

void
Out_NotifyTable (
                CCB*        pCCB
                )
    {
    CGSIDE      Side = pCCB->GetCodeGenSide();
    ITERATOR    NotifyProcList;

    pCCB->GetListOfNotifyTableEntries( NotifyProcList );
    ITERATOR_INIT( NotifyProcList );

    if ( Side == CGSIDE_SERVER && pCommand->GetNdrVersionControl().HasInterpretedNotify() )
        { 
        ISTREAM*    pStream = pCCB->GetStream();
        CG_PROC*    pProc   = 0;

        pStream->NewLine();
        pStream->Write( "static const NDR_NOTIFY_ROUTINE " );
        pStream->Write( "_NotifyRoutineTable[] = {" );
        pStream->IndentInc();
        pStream->NewLine();
        while ( ITERATOR_GETNEXT( NotifyProcList, pProc ) )
            {
            pStream->Write( "(NDR_NOTIFY_ROUTINE) " );
            pStream->Write( pProc->GetSymName() );
            pStream->Write( "_notify" );
            if ( pProc->HasNotifyFlag() )
                {
                pStream->Write( "_flag" );
                }
            pStream->Write( "," );
            pStream->NewLine();
            }
        pStream->Write( "0" );
        pStream->NewLine();
        pStream->Write( "};" );
        pStream->IndentDec();
        pStream->NewLine();
        }
    }

void
Out_NotifyTableExtern   (
                        CCB* pCCB
                        )
    {
    if ( pCommand->GetNdrVersionControl().HasInterpretedNotify() )
        {
        ISTREAM*    pStream = pCCB->GetStream();
        pStream->NewLine();
        pStream->Write( "extern const NDR_NOTIFY_ROUTINE _NotifyRoutineTable[];" );
        pStream->NewLine();
        }
    }

void
Out_StubDescriptor(
    CG_HANDLE *         pImplicitHandle,
    CCB *               pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the stub descriptor structure in the client or server stub.

 Arguments:

    pImplicitHandle - A pointer to the implicit CG_HANDLE used in the
                      interface.  Every interface has one of these even if
                      it is not used.
    pCCB            - A pointer to the code gen controller block.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    if ( !pCommand->IsFinalProtocolRun() )
        {
        // Expression routines are generated in dce run, but we are generating stubdesc in
        // ndr64 run. So we need to save the state for second run.
        // better solution would be using expression evaluator for dce. 
        MIDL_ASSERT( pCommand->IsNDRRun() );
        if ( pCommand->NeedsNDR64Run() && pCCB->GetExprEvalIndexMgr()->Lookup(1) )
            {
            HasExprRoutines = TRUE;
            }
        return;
        }

    ISTREAM *       pStream;
    CG_INTERFACE *  pInterface;
    CSzBuffer       Buffer;
    CGSIDE          Side;
    BOOL            fObjectInterface;
    ULONG_PTR       ulMidlFlag = 0;

    pStream = pCCB->GetStream();

    Side = pCCB->GetCodeGenSide();

    pInterface = pCCB->GetInterfaceCG();
    fObjectInterface = pInterface->IsObject();

    if ( pInterface->HasClientInterpretedCommOrFaultProc( pCCB ) )
        {
        CG_ITERATOR Iterator;
        CG_PROC *   pProc;

        pStream->NewLine();
        pStream->Write( "static const COMM_FAULT_OFFSETS " );
        pStream->Write( pCCB->GetInterfaceName() );
        pStream->Write( '_' );
        pStream->Write( "CommFaultOffsets[]" );
        pStream->Write( " = " );
        pStream->NewLine();

        pStream->Write( '{' );
        pStream->NewLine();

        pInterface->GetMembers( Iterator );

        while ( ITERATOR_GETNEXT( Iterator, pProc ) )
            {
            long   CommOffset, FaultOffset;

            if ( ((Side == CGSIDE_CLIENT) &&
                  (pProc->GetCGID() != ID_CG_PROC)) ||
                 ((Side == CGSIDE_SERVER) &&
                  (pProc->GetCGID() != ID_CG_CALLBACK_PROC)) )
                continue;

            if ( pProc->HasStatuses() )
                {
                pProc->GetCommAndFaultOffset( pCCB, CommOffset, FaultOffset );

                Buffer.Set( "\t{ " );
                Buffer.Append( CommOffset );
                Buffer.Append( ", " );
                Buffer.Append( FaultOffset );
                Buffer.Append( " }" );
                Buffer.Append( pProc->GetSibling() ? "," : " " );
                
                if ( ! pCommand->Is32BitEnv() )
                    {
                    Buffer.Append( "\t/* ia64 Offsets for " );
                    }
                else
                    {
                    Buffer.Append( "\t/* x86 Offsets for " );
                    }

                Buffer.Append( pProc->GetSymName() );
                Buffer.Append( " */" );
                pStream->Write( Buffer );
                }
            else
                {
                pStream->Write( "\t{ -2, -2 }" );
                if ( pProc->GetSibling() )
                    pStream->Write( ',' );
                }

            pStream->NewLine();
            }

        pStream->Write( "};" );
        pStream->NewLine();
        pStream->NewLine();
        }

    //
    // If we have an implicit generic handle then output the generic info
    // structure which will be placed in the IMPLICIT_HANDLE_INFO union.
    //

    if ( (Side == CGSIDE_CLIENT) &&
         pImplicitHandle && pImplicitHandle->IsGenericHandle() )
        {
        pStream->NewLine();
        pStream->Write( "static " GENERIC_BINDING_INFO_TYPE );
        pStream->Write( ' ' );
        pStream->Write( pCCB->GetInterfaceName() );
        pStream->Write( '_' );
        pStream->Write( GENERIC_BINDING_INFO_VAR );
        pStream->Write( " = " );
        pStream->IndentInc();
        pStream->NewLine();

        pStream->Write( '{' );
        pStream->NewLine();

        pStream->Write( '&' );
        pStream->Write( pImplicitHandle->GetHandleIDOrParam()->GetSymName() );
        pStream->Write( ',' );
        pStream->NewLine();

        char    Buffer[80];

        sprintf( Buffer, "%d,",
                 ((CG_GENERIC_HANDLE *)pImplicitHandle)->GetImplicitSize() );
        pStream->Write( Buffer );
        pStream->NewLine();

        pStream->Write( "(" GENERIC_BINDING_ROUTINE_TYPE ")" );
        pStream->Write( pImplicitHandle->GetHandleType()->GetSymName() );
        pStream->Write( "_bind," );
        pStream->NewLine();

        pStream->Write( "(" GENERIC_UNBINDING_ROUTINE_TYPE ")" );
        pStream->Write( pImplicitHandle->GetHandleType()->GetSymName() );
        pStream->Write( "_unbind" );
        pStream->NewLine();

        pStream->Write( "};" );
        pStream->IndentDec();
        pStream->NewLine();
        }

    //
    // Emit the stub descriptor structure itself.
    //

    pStream->NewLine();

    pStream->Write( "static const " STUB_DESC_STRUCT_TYPE_NAME );

    pStream->Write( ' ' );

    pStream->Write( pCCB->GetInterfaceCG()->GetStubDescName() );
    pStream->Write( " = " );

    pStream->IndentInc();

    pStream->NewLine();
    pStream->Write('{' );
    pStream->NewLine();

    if( (fObjectInterface == TRUE) )
        pStream->Write( "0," );
    else
        {
        pStream->Write( "(void *)& " );
        pStream->Write( pCCB->GetInterfaceName() );

        if( Side == CGSIDE_SERVER )
            pStream->Write( RPC_S_INT_INFO_STRUCT_NAME"," );
        else
            pStream->Write( RPC_C_INT_INFO_STRUCT_NAME"," );
        }

    pStream->NewLine();

    Out_AllocAndFreeFields( pCCB );

    //
    // Output the implicit handle information on the client side.
    //
    if ( (Side == CGSIDE_CLIENT) && (fObjectInterface != TRUE) )
        {
        if ( ! pImplicitHandle )
            {
            pStream->Write( '&' );
            pStream->Write( pCCB->GetInterfaceName() );
            pStream->Write( AUTO_BH_VAR_NAME );
            }
        else
            {
            if ( pImplicitHandle->IsPrimitiveHandle() )
                {
                pStream->Write( '&' );
                pStream->Write(
                    pImplicitHandle->GetHandleIDOrParam()->GetSymName() );
                }
            else // has to be implicit generic
                {
                MIDL_ASSERT( pImplicitHandle->IsGenericHandle() );

                pStream->Write( "(handle_t *)& " );
                pStream->Write( pCCB->GetInterfaceName() );
                pStream->Write( '_' );
                pStream->Write( GENERIC_BINDING_INFO_VAR );
                }
            }
        }
    else
        pStream->Write( '0' );

    pStream->Write( ',' );
    pStream->NewLine();

    //
    // Output the rundown routine table on the server side interpreted stub
    // if needed.
    //
    if ( (Side == CGSIDE_SERVER) &&
         (pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER) &&
         pCCB->HasRundownRoutines()
       )
        {
        pStream->Write( RUNDOWN_ROUTINE_TABLE_VAR );
        }
    else
        {
        pStream->Write( '0' );
        }

    pStream->Write( ',' );
    pStream->NewLine();

    //
    // Output the generic bind/unbind routine pair table on the client side
    // interpreted stub if needed.
    //
    if ( (Side == CGSIDE_CLIENT) &&
         pCCB->GetInterpretedRoutinesUseGenHandle()
       )
        {
        pStream->Write( BINDING_ROUTINE_TABLE_VAR );
        }
    else
        {
        pStream->Write( '0' );
        }
    pStream->Write( ',' );
    pStream->NewLine();

    //
    // Output the expression evaluation routine table.
    //
    pStream->Write( pCCB->GetExprEvalIndexMgr()->Lookup(1) || HasExprRoutines
                        ? EXPR_EVAL_ROUTINE_TABLE_VAR","
                        : "0," );
    pStream->NewLine();

    //
    // Output the transmit as routine table.
    //
    pStream->Write( pCCB->GetQuintupleDictionary()->GetCount()
                          ?  XMIT_AS_ROUTINE_TABLE_VAR ","
                          :  "0," );
    pStream->NewLine();

    //
    // Output the type format string.
    //
    if ( SYNTAX_DCE == pCommand->GetDefaultSyntax() )
        pStream->Write( FORMAT_STRING_STRING_FIELD );
    else
        pStream->Write( "(unsigned char *) &NDR64_MIDL_FORMATINFO" );
        
    pStream->Write( ',' );
    pStream->NewLine();

    //
    // -error bounds_check flag.
    //
    pStream->Write( pCCB->MustCheckBounds() ? "1" : "0" );
    pStream->Write( ',' );
    pStream->Write( " /* -error bounds_check flag */" );
    pStream->NewLine();

    //
    // Ndr library version.
    //
    unsigned long ulNdrLibVer = NDR_VERSION_1_1;
    if ( pCommand->GetNdrVersionControl().HasNdr60Feature() )
        {
        ulNdrLibVer = NDR_VERSION_6_0;
        }
    else if ( pCommand->GetNdrVersionControl().HasNdr50Feature() )
        {
        if ( pCommand->GetNdrVersionControl().HasOicfPickling() )
            {
            ulNdrLibVer = NDR_VERSION_5_4;
            }
        else if ( pCommand->GetNdrVersionControl().HasNT5VTableSize() )
            {
            ulNdrLibVer = NDR_VERSION_5_3;
            }
        else if (pCommand->GetNdrVersionControl().HasAsyncUUID() ||
            pCommand->GetNdrVersionControl().HasDOA() ||
            pCommand->GetNdrVersionControl().HasContextSerialization() ||
            pCommand->GetNdrVersionControl().HasInterpretedNotify() )
            {
            ulNdrLibVer = NDR_VERSION_5_2;
            }
        else
            {
            ulNdrLibVer = NDR_VERSION_5_0;
            }
        }
    else if ( (pCommand->GetOptimizationFlags() & OPTIMIZE_NON_NT351) ||
          pCommand->GetNdrVersionControl().HasNdr20Feature() )
        {
        ulNdrLibVer = NDR_VERSION_2_0;
        }
    sprintf( Buffer, "0x%x", ulNdrLibVer );

    pStream->Write( Buffer );
    pStream->Write( ',' );
    pStream->Write( " /* Ndr library version */" );
    pStream->NewLine();

    if ( fObjectInterface  &&
         pCommand->GetNdrVersionControl().HasUserMarshal()  &&
         (pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER)  &&
         ! (pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2)
       )
        {
        pStream->NewLine(2);
        pStream->Write( "#error [user_marshal] and [wire_marshal] not supported with -Oi and -Oic" );
        pStream->NewLine();
        pStream->Write( "/* use -Os or -Oicf compiler flag */" );
        pStream->NewLine();

        RpcError( NULL, 0, USER_MARSHAL_IN_OI, "" );
        exit( USER_MARSHAL_IN_OI );
        }

    // Used one reserved field for RpcSs.
    // In ms_ext when explicit, in osf always, to cover some weird cases.

    if ( ( pCCB->GetInterfaceCG()->GetUsesRpcSS() || (pCCB->GetMode() == 0) )
         &&
         ( (Side == CGSIDE_CLIENT) ||
           ((Side == CGSIDE_SERVER) && pCCB->GetMode()) )// because of callbacks
       )
        {
        pStream->Write( "&" MALLOC_FREE_STRUCT_VAR_NAME "," );
        }
    else
        pStream->Write( "0," );
    pStream->NewLine();

    // MIDL version number.

    sprintf( Buffer,
             "0x%x, /* MIDL Version %d.%d.%d */",
             (rmj << 24) | (rmm << 16) | rup,
             rmj,
             rmm,
             rup );
    pStream->Write( Buffer );
    pStream->NewLine();

    // Interpreter comm/fault status info.

    if ( pInterface->HasClientInterpretedCommOrFaultProc( pCCB ) )
        {
        pStream->Write( pCCB->GetInterfaceName() );
        pStream->Write( '_' );
        pStream->Write( "CommFaultOffsets," );
        }
    else
        {
        pStream->Write( "0," );
        }
    pStream->NewLine();

    // Fields for the compiler version 3.0+

    //
    // Output the usr_marshal routine table.
    //
    if ( pCCB->HasQuadrupleRoutines() )
        {
        if ( SYNTAX_DCE == pCommand->GetDefaultSyntax() )
            pStream->Write( USER_MARSHAL_ROUTINE_TABLE_VAR );
        else
            pStream->Write( NDR64_USER_MARSHAL_ROUTINE_TABLE_VAR );
        }
    else
        pStream->Write( "0" );
    pStream->Write( "," );
    pStream->NewLine();

    // notify & notify_flag routine table
    if ( Side == CGSIDE_SERVER && pCommand->GetNdrVersionControl().HasInterpretedNotify() )
        { 
        pStream->Write( "_NotifyRoutineTable" );
        }
    else
        {
        pStream->Write( "0" );
        }
        pStream->Write( ",  /* notify & notify_flag routine table */" );
        pStream->NewLine();

    if ( ! pInterface->GetHasMSConfStructAttr() )
        {
        ulMidlFlag |= 1;
        }

    if ( pCommand->IsSwitchDefined(SWITCH_NOREUSE_BUFFER))
        ulMidlFlag |= 2;

    if ( pCommand->NeedsNDR64Run() )
        ulMidlFlag |= RPCFLG_HAS_MULTI_SYNTAXES;

    sprintf( Buffer,
             "0x%x, /* MIDL flag */",
             ulMidlFlag);
        
    pStream->Write( Buffer );

    if ( pCCB->HasCsTypes() )
        {
        pStream->WriteOnNewLine( '&' );
        pStream->Write( CS_ROUTINE_TABLES_VAR );
        pStream->Write( ',' );
        }
    else
        {
        pStream->WriteOnNewLine( "0, /* cs routines */" );
        }

    if ( !fObjectInterface  && pCommand->NeedsNDR64Run() )
        {
        if ( Side == CGSIDE_SERVER )
            {
            pStream->WriteOnNewLine( "(void *)& " );
            pStream->Write( pCCB->GetInterfaceName() );
            pStream->Write( "_ServerInfo," );
            }
        else
            {
            pStream->WriteOnNewLine( "(void *)& " );
            pStream->Write( pCCB->GetInterfaceName() );
            pStream->Write( "_ProxyInfo," );
            }
        }
    else
        {
        pStream->WriteOnNewLine( "0," );
        }
    pStream->Write( "   /* proxy/server info */" );
        
    //
    // The reserved fields for future use.
    //

    // 1 reserved fields

    pStream->WriteOnNewLine( "0   /* Reserved5 */" );

    // No reserved fields left.
    // Check the compiler version and or lib version if you need to access
    // newer fields.

    pStream->WriteOnNewLine( "};" );
    pStream->IndentDec();
    pStream->NewLine();

}


void CG_INTERFACE::Out_ProxyInfo( CCB * pCCB, 
                                  BOOL IsForCallback )
{
    if ( pCommand->IsNDR64Run() )
        {
        GenSyntaxInfo( pCCB, IsForCallback );
        GenProxyInfo( pCCB, IsForCallback );
        }
}



void CG_INTERFACE::Out_ServerInfo(CCB *pCCB,
                    BOOL fHasThunk,
                    BOOL IsForCallback )
{
    if ( !pCommand->IsFinalProtocolRun() )
        return;

    ISTREAM *       pStream     = pCCB->GetStream();
    CG_INTERFACE *  pInterface  = pCCB->GetInterfaceCG();
    char        *   pItfName    = pInterface->GetSymName();
    BOOL            fObject     = pCCB->GetInterfaceCG()->IsObject();

    pStream->Write( "static const " SERVER_INFO_TYPE_NAME " " );
    pStream->Write( pItfName );
    pStream->Write( SERVER_INFO_VAR_NAME );
    pStream->Write( " = " );
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->NewLine();

    //
    // Stub descriptor.
    //
    pStream->Write( '&' );
    pStream->Write( pInterface->GetStubDescName() );
    pStream->Write( ',' );
    pStream->NewLine();

    //
    // Dispatch table to server routines.
    //
    if ( !pCCB->GetInterfaceCG()->IsObject() )
        {
        pStream->Write( pItfName );
        pStream->Write( SERVER_ROUTINE_TABLE_NAME );
        }
    else
        {
        pStream->Write( '0' );
        }

    pStream->Write( ',' );
    pStream->NewLine();

    //
    // Procedure format string.
    //
    if (pCommand->GetDefaultSyntax() == SYNTAX_NDR64 )
        pStream->Write( "(unsigned char *) &NDR64_MIDL_FORMATINFO" );
    else
        pStream->Write( PROC_FORMAT_STRING_STRING_FIELD );
    pStream->Write( ',' );
    pStream->NewLine();

    //
    // Array of proc format string offsets.
    //
    if ( pCommand->IsNDR64Run() )
        pStream->Write( "(unsigned short *) " );
    if ( fObject )
        pStream->Write( '&' );
    if ( IsForCallback )
        pStream->Write( MIDL_CALLBACK_VAR_NAME );
    pStream->Write( pItfName );
    if ( pCommand->GetDefaultSyntax() == SYNTAX_DCE )
        {
        pStream->Write( FORMAT_STRING_OFFSET_TABLE_NAME );
        }
    else
        {
        pStream->Write( "_Ndr64ProcTable" );
        }
    if ( fObject )
        pStream->Write( "[-3]" );
    pStream->Write( ',' );
    pStream->NewLine();

    //
    // Thunk table.
    //
    if ( fHasThunk )
        {
        if ( fObject )
            pStream->Write( '&' );
        pStream->Write( pItfName );
        pStream->Write( STUB_THUNK_TABLE_NAME );
        if ( fObject )
            pStream->Write( "[-3]" );
       }
    else
        pStream->Write( '0' );

    pStream->Write( ',' );

    pStream->NewLine();

    // old inteface supporting one transfer syntax.
    // old interfaces. 
    if ( !pCommand->NeedsNDR64Run() )
        {
        pStream->Write( "0,");
        pStream->NewLine();
        pStream->Write( "0,");
        pStream->NewLine();
        pStream->Write( "0");
        }
    else
        {
        // default transfer syntax is NDR
        pStream->Write( '&' );
        if ( pCommand->IsNDRRun() )
            pStream->Write( NDR_TRANSFER_SYNTAX_VAR_NAME );
        else
            pStream->Write( NDR64_TRANSFER_SYNTAX_VAR_NAME );
           
        pStream->Write( ',' );
        pStream->NewLine();
        // we only support one additional transfer syntax
        if ( pCommand->NeedsNDRRun() )
            pStream->Write( "2," );
        else
            pStream->Write( "1," );
        pStream->NewLine();
        if ( IsForCallback )
            pStream->Write( MIDL_CALLBACK_VAR_NAME );
        pStream->Write( GetMulSyntaxInfoName() );
        pStream->NewLine();
        }


    pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine();
}

/*
*   Generates MIDL_SERVER_INFO. It'll be generated in:
        . object interface
        . raw RPC server side
        . raw RPC client side, if callback is presented (client side means for callback)
        regardless of transfer syntax.
        
*   
*/
void
CG_INTERFACE::Out_InterpreterServerInfo( CCB *    pCCB,
                           CGSIDE   Side )
{
    if ( !pCommand->IsFinalProtocolRun() )
        return;

    ISTREAM *       pStream     = pCCB->GetStream();
    CG_PROC *       pProc;
    BOOL            fHasThunk;
    char         *  pSStubPrefix;
    CSzBuffer       Buffer;
    BOOL            fObject     = pCCB->GetInterfaceCG()->IsObject();
    char        *   pItfName    = GetSymName();

    pStream->NewLine();

    fHasThunk = FALSE;

    if ( (pSStubPrefix = pCommand->GetUserPrefix( PREFIX_SERVER_MGR ) ) == 0 )
        {
        pSStubPrefix = "";
        }

    //
    // Server routine dispatch table.
    //

    if ( !fObject )
        {
        CG_ITERATOR     Iterator;

        pStream->Write( "static const " SERVER_ROUTINE_TYPE_NAME " " );
        pStream->Write( pItfName );
        pStream->Write( SERVER_ROUTINE_TABLE_NAME "[]" );
        pStream->Write( " = " );
        pStream->IndentInc();
        pStream->NewLine();

        pStream->Write( '{' );
        pStream->NewLine();

        GetMembers( Iterator );

        BOOL fNoProcsEmitted = TRUE;

        while ( ITERATOR_GETNEXT( Iterator, pProc ) )
            {
            if ( (Side == CGSIDE_CLIENT) &&
                 (pProc->GetCGID() != ID_CG_CALLBACK_PROC) )
                continue;

            if ( (Side == CGSIDE_SERVER) &&
                 ( (pProc->GetCGID() == ID_CG_CALLBACK_PROC)
                   || ( pProc->GetCGID() == ID_CG_TYPE_ENCODE_PROC ) ) )
                continue;

            fNoProcsEmitted = FALSE;

            if ( pProc->NeedsServerThunk( pCCB, Side ) )
                {
                fHasThunk = TRUE;
                }

            pStream->Write( "(" SERVER_ROUTINE_TYPE_NAME ")" );

            if ( pProc->GetCallAsName() )
                {
                pStream->Write( pProc->GenMangledCallAsName( pCCB ) );
                }
            else
                {
                if ( pProc->GetCGID() == ID_CG_ENCODE_PROC  ||
                     pProc->GetCGID() == ID_CG_TYPE_ENCODE_PROC ) 
                    pStream->Write( '0' );
                else
                    {
                    Buffer.Set( pSStubPrefix );
                    Buffer.Append( pProc->GetType()->GetSymName() );

                    if ( pProc->HasComplexReturnType() && !pProc->HasAsyncHandle() )
                        Buffer.Append( "_ComplexThunk" );

                    pStream->Write( Buffer );
                    }
                }

            if ( pProc->GetSibling() )
                pStream->Write( ',' );

            pStream->NewLine();
            }

        if ( fNoProcsEmitted )
            {
            pStream->Write( '0' );
            pStream->NewLine();
            }

        pStream->Write( "};" );
        pStream->IndentDec();
        pStream->NewLine( 2 );
        }
    else    // object interfaces only need to know about thunks
        {
        ITERATOR        Iterator;
        CG_OBJECT_PROC  *   pObjProc;

        GetAllMemberFunctions( Iterator );

        while ( ITERATOR_GETNEXT( Iterator, pObjProc ) )
            {
            if ( pObjProc->NeedsServerThunk( pCCB, Side ) && !pObjProc->IsDelegated() )
                fHasThunk = TRUE;
            }
        }

    //
    // Thunk table.
    //
    if ( fHasThunk )
        {
        pStream->Write( "static const " STUB_THUNK_TYPE_NAME " " );
        pStream->Write( pItfName );
        pStream->Write( STUB_THUNK_TABLE_NAME "[]" );
        pStream->Write( " = " );
        pStream->IndentInc();
        pStream->NewLine();

        pStream->Write( '{' );
        pStream->NewLine();

        OutputThunkTableEntries( pCCB, TRUE );

        pStream->Write( "};" );
        pStream->IndentDec();
        pStream->NewLine( 2 );
        }

        

    // ---------------------------
    //
    // Emit the Server Info struct.
    //
    // ---------------------------

    Out_ServerInfo( pCCB , fHasThunk, Side == CGSIDE_CLIENT  );

}


void
Out_EP_Info(
    CCB *   pCCB,
    ITERATOR *  I )
    {
    ISTREAM     *   pStream = pCCB->GetStream();
    int             Count   = ITERATOR_GETCOUNT( *I );
    int             i;
    CSzBuffer   Buffer;
    ENDPT_PAIR  *   pPair;

    pStream->NewLine();
    pStream->Write( "static RPC_PROTSEQ_ENDPOINT __RpcProtseqEndpoint[] = " );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( '{' );

    for( i = 0, ITERATOR_INIT( *I );
         i < Count;
         i++ )
        {
        ITERATOR_GETNEXT( *I, pPair );

        pStream->NewLine();
        pStream->Write( '{' );

        Buffer.Set( "(unsigned char *) \"" );
        Buffer.Append( pPair->pString1 );
        Buffer.Append( "\", (unsigned char *) \"" );
        Buffer.Append( pPair->pString2 );
        Buffer.Append( "\"" );

        pStream->Write( Buffer );
        pStream->Write( '}' );

        if( ITERATOR_PEEKTHIS( *I ) )
            {
            pStream->Write( ',' );
            }

        }

    pStream->NewLine();
    pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine();
    }

void
Out_SetOperationBits(
    CCB         *   pCCB,
    unsigned int  OpBits )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:
    Set the RPC operation flags.

 Arguments:

    pCCB                - A pointer to the code generation controller block.
    OpBits              - Operation bits. These contain datagram related flags.
 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream         = pCCB->GetStream();

    pStream->NewLine();

    if( OpBits != 0 )
        {
        char            Buffer[ 512 ];
        sprintf( Buffer, RPC_MESSAGE_VAR_NAME".RpcFlags = ( RPC_NCA_FLAGS_DEFAULT "  );

        if( OpBits & OPERATION_MAYBE )
            {
            strcat( Buffer, "| RPC_NCA_FLAGS_MAYBE" );
            }

        if( OpBits & OPERATION_BROADCAST )
            {
            strcat( Buffer, "| RPC_NCA_FLAGS_BROADCAST" );
            }

        if( OpBits & OPERATION_IDEMPOTENT )
            {
            strcat( Buffer, "| RPC_NCA_FLAGS_IDEMPOTENT" );
            }

        if( OpBits & OPERATION_INPUT_SYNC )
            {
            strcat( Buffer, "| RPCFLG_INPUT_SYNCHRONOUS" );
            }

        if( OpBits & OPERATION_MESSAGE )
            {
            strcat( Buffer, "| RPCFLG_MESSAGE" );
            pCommand->GetNdrVersionControl().SetHasMessageAttr();
            }

        strcat( Buffer, " );" );

        pStream->Write( Buffer );
        }
}


void
Out_HandleInitialize(
    CCB         *   pCCB,
    ITERATOR&       BindingParamList,
    expr_node  *   ,
    BOOL            ,
    unsigned short  OpBits )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the call for initializing the stub message for a auto_handle
    case.

 Arguments:

    pCCB                - A pointer to the code generation controller block.
    BindingParamList    - List of params to the call.
    pAssignExpr         - if this param is non-null, assign the value of the
                          call to this.
    fAuto               - is this an auto handle call ?

    OpBits              - Operation bits. These contain datagram related flags.
 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream         = pCCB->GetStream();
    PNAME           pName           = CSTUB_INIT_RTN_NAME;

    expr_proc_call *   pProcCall   = MakeProcCallOutOfParamExprList(
                                                     pName,
                                                     (node_skl *)0,
                                                     BindingParamList
                                                                );

    pStream->NewLine();

    pProcCall->PrintCall( pStream, 0, 0 );

    pStream->NewLine();

    Out_SetOperationBits(pCCB, OpBits);
}


void
Out_AutoHandleSendReceive(
    CCB         *   pCCB,
    expr_node  *   pDest,
    expr_node  *   pProc )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit code for an auto handle base send receive call.

 Arguments:

    pCCB    - A pointer to the code gen controller block.
    pDest   - Optional destination for the result of the procedure call.
    pProc   - The procedure to call.

 Return Value:

 Notes:

    If there are no output parameters, we wont pick up the returned
    value of the send receive calls into the local variable for the
    buffer length. In that case the pDest pointer will be null.

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();
    expr_node  *   pExpr   = pProc;

    pStream->NewLine();

    if( pDest )
        {
        pExpr   = new expr_assign( pDest, pProc );
        }

    pExpr->PrintCall( pStream, 0, 0 );
}

void
Out_NormalSendReceive(
    CCB *   pCCB,
    BOOL     )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit code for an auto handle base send receive call.

 Arguments:

    pCCB    - A pointer to the code gen controller block.
    fAnyOuts- Are there any out parameters at all ?

 Return Value:

 Notes:

    If there are no output parameters, we wont pick up the returned
    value of the send receive calls into the local variable for the
    buffer length.

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    CSzBuffer   TempBuf;

    pStream->NewLine();

    //
    // Call the send receive routine.
    //

    TempBuf.Set( NORMAL_SR_NDR_RTN_NAME );
    TempBuf.Append( "( (PMIDL_STUB_MESSAGE) &" );
    TempBuf.Append( STUB_MESSAGE_VAR_NAME );
    TempBuf.Append( ", (unsigned char *)" );
    TempBuf.Append( STUB_MSG_BUFFER_VAR_NAME );
    TempBuf.Append( " );" );
    pStream->Write( TempBuf );
}

void
Out_NormalFreeBuffer(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the free buffer with check for status.

 Arguments:

 Return Value:

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();
    expr_node  *   pExpr   = pCCB->GetStandardResource(
                                ST_RES_STUB_MESSAGE_VARIABLE );
    ITERATOR        ParamList;

    pStream->NewLine();

    ITERATOR_INSERT( ParamList,
                     MakeAddressExpressionNoMatterWhat( pExpr )
                   );
    pExpr   = MakeProcCallOutOfParamExprList(
                                            NORMAL_FB_NDR_RTN_NAME, // rtn name
                                            (node_skl *)0,  // type - dont care
                                            ParamList       // param list
                                            );
    // generate the procedure call.

    pExpr->PrintCall( pStream, 0, 0 );

}

void
Out_IncludeOfFile(
    CCB     *   pCCB,
    PFILENAME       p,
    BOOL            fAngleBrackets )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output a hash include of the given file.

 Arguments:

    pCCB            - A pointer to the code generation controller block.
    p               - The ready to emit file name string.
    fAngleBrackets  - Do we want angle brackets or quotes (TRUE if anglebrackets)

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    CSzBuffer   TempBuf;

    pStream->NewLine();

    TempBuf.Set( "#include " );
    TempBuf.Append( fAngleBrackets ? "<" : "\"" );
    TempBuf.Append( p );
    TempBuf.Append( fAngleBrackets ? ">" : "\"" );
    pStream->Write( TempBuf );
}

void
Out_MKTYPLIB_Guid(
    CCB     *   pCCB,
    GUID_STRS & GStrs,
    char * szPrefix,
    char * szName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output a MKTYPLIB style guid structure.

 Arguments:

    pCCB          - A pointer to the code generation controller block.
    pGString1     - Partial guid strings.
    char * szName - name for the GUID

 Return Value:

 Notes:

    No checks are made for the validity of the string. The front-end has done
    that.

    All strings are emitted with a leading 0x.

    The 5 strings are treated this way:

        1 - 3. Emitted as such
        4 - 5. Broken into and emitted as byte hex values, without
               transformation, so they are just picked up and written out.
----------------------------------------------------------------------------*/
{
    char        TempBuf[256];
    ISTREAM *   pStream = pCCB->GetStream();

    if ( !GStrs.str1 )
        GStrs.str1 = "00000000";
    if ( !GStrs.str2 )
        GStrs.str2 = "0000";
    if ( !GStrs.str3 )
        GStrs.str3 = "0000";
    if ( !GStrs.str4 )
        GStrs.str4 = "00000000";
    if ( !GStrs.str5 )
        GStrs.str5 = "00000000";

    pStream->Write( "DEFINE_GUID(" );
    pStream->Write( szPrefix );
    pStream->Write( szName );
    pStream->Write( ',' );
    sprintf( TempBuf, "0x%s,0x%s,0x%s", GStrs.str1, GStrs.str2, GStrs.str3 );
    pStream->Write( TempBuf );

    //
    // Each of the above strings are just broken down into six 2 byte
    // characters with 0x preceding them.
    //

    strcpy( TempBuf, GStrs.str4 );
    strcat( TempBuf, GStrs.str5 );

    pStream->Write( "," );

    //
    // We will use the iteration counter to index into the string. Since we
    // need 2 per iteration, double the counter. Also pGString4 is actually
    // a 16 bit qty.
    //

    for( int i = 0; i < (6+2)*2 ; i += 2 )
        {
        pStream->Write( "0x");
        pStream->Write( TempBuf[ i ] );
        pStream->Write( TempBuf[ i+1 ] );
        if( i < (6+2)*2-2 )
            pStream->Write( ',' );
        }

    pStream->Write( ");" );
    pStream->NewLine();
}

void
Out_Guid(
    CCB     *   pCCB,
    GUID_STRS & GStrs,
    GUIDFORMAT  format)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output a guid structure.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    pGString1   - Partial guid strings.
    format      - Output format ( MIDL_DEFINE_GUID or const IID = )

 Return Value:

 Notes:

    This routine emits a guid as a inited structure along with the proper
    matched bracing.

    No checks are made for the validity of the string. The front-end has done
    that.

    All strings are emitted with a leading 0x.

    The 5 strings are treated this way:

        1 - 3. Emitted as such
        4 - 5. Broken into and emitted as byte hex values, without
               transformation, so they are just picked up and written out.
----------------------------------------------------------------------------*/
{
    char        TempBuf[ 256 ];
    ISTREAM *   pStream = pCCB->GetStream();

    if ( !GStrs.str1 )
        GStrs.str1 = "00000000";
    if ( !GStrs.str2 )
        GStrs.str2 = "0000";
    if ( !GStrs.str3 )
        GStrs.str3 = "0000";
    if ( !GStrs.str4 )
        GStrs.str4 = "00000000";
    if ( !GStrs.str5 )
        GStrs.str5 = "00000000";

    if (GUIDFORMAT_RAW != format)
        pStream->Write( '{' );

    sprintf( TempBuf, "0x%s,0x%s,0x%s", GStrs.str1, GStrs.str2, GStrs.str3 );
    pStream->Write( TempBuf );

    //
    // Each of the above strings are just broken down into six 2 byte
    // characters with 0x preceding them.
    //

    strcpy( TempBuf, GStrs.str4 );
    strcat( TempBuf, GStrs.str5 );

    pStream->Write( "," );
    if (GUIDFORMAT_RAW != format)
        pStream->Write( "{" );

    //
    // We will use the iteration counter to index into the string. Since we
    // need 2 per iteration, double the counter. Also pGString4 is actually
    // a 16 bit qty.
    //

    for( int i = 0; i < (6+2)*2 ; i += 2 )
        {
        pStream->Write( "0x");
        pStream->Write( TempBuf[ i ] );
        pStream->Write( TempBuf[ i+1 ] );
        if( i < (6+2)*2-2 )
            pStream->Write( ',' );
        }

    if (GUIDFORMAT_RAW != format)
        pStream->Write( "}}" );
}

void
Out_IFInfo(
    CCB             *   pCCB,
    char            *   pIntInfoTypeName,
    char            *   pIntInfoVarName,
    char            *   pIntInfoSizeOfString,
    GUID_STRS       &   UserGuidStr,
    unsigned short      UserMajor,
    unsigned short      UserMinor,
//    GUID_STRS       &   XferGuidStr,
//    unsigned short      XferSynMajor,
//    unsigned short      XferSynMinor,
    char            *   pCallbackDispatchTable,
    int                 ProtSeqEPCount,
    char            *   ,
    char            *   ,
    BOOL                fNoDefaultEpv,
    BOOL                fSide,
    BOOL                fHasPipes
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 Arguments:

    pCCB                    - Ptr to code gen controller block.
    pIntInfoTypeName        - Client InterfaceInfo type name string.
    pIntInfoVarName         - Client InterfaceInfo variable name string.
    pIntInfoSizeOfString    - string sizeof interface.
    UserGuidStr             - User specified Guid string components.
    UserMajor               - User specified major interface version
    UserMinor               - User specified minor interface version
    XferGuidStr             - Xfer syntax identifying Guid string components.
    XferSynMajor            - Transfre syntax major version
    XferSynMinor            - Transfre syntax minor version
    pCallbackDispatchTable  - A pointer to the call back dispatch table name.
    ProtSeqEPCount          - ProtSeq endpoint count.
    ProtSeqEPTypeName       - Protseq endpoint Type name.
    ProtSeqEPVarName        - Protseq endpoint variable name.
    fNoDefaultEpv           - No default epv switch specicied.
    fSide                   - The server side (1) or client side(0)
    fHasPipes               - TRUE if any proc in the Interface has pipes

 Return Value:

    None.

 Notes:

    I'm tired already specifying so many params !
----------------------------------------------------------------------------*/
{
    CSzBuffer TempBuf;
    ISTREAM *   pStream = pCCB->GetStream();
    unsigned int RpcIntfFlag = 0;

    pStream->NewLine( 2 );
    TempBuf.Set( "static const " );
    TempBuf.Append( pIntInfoTypeName );
    TempBuf.Append( " " );
    TempBuf.Append( pCCB->GetInterfaceName() );
    TempBuf.Append( pIntInfoVarName );
    TempBuf.Append( " =" );

    pStream->Write( TempBuf );

    pStream->IndentInc();

    pStream->NewLine();
    pStream->Write( '{' );

    pStream->NewLine();

    TempBuf.Set( pIntInfoSizeOfString );
    TempBuf.Append( "," );

    pStream->Write( TempBuf );

    //
    // Emit the guid.
    //

    pStream->NewLine();
    pStream->Write( '{' );
    Out_Guid( pCCB,
              UserGuidStr
            );

    //
    // Emit the interface version specified by the user.
    //

    TempBuf.Set( ",{" );
    TempBuf.Append( UserMajor );
    TempBuf.Append( "," );
    TempBuf.Append( UserMinor );
    TempBuf.Append( "}" );
    pStream->Write( TempBuf );
    pStream->Write( "}," );

    //
    // Emit the xfer syntax guid.
    //

    pStream->NewLine();
    if ( pCommand->GetDefaultSyntax() == SYNTAX_DCE )
        Out_TransferSyntax( pCCB,
				TransferSyntaxGuidStrs,			// ndr identifying guid.
				NDR_UUID_MAJOR_VERSION,			// ndr's version
				NDR_UUID_MINOR_VERSION );
    else
        {
        if ( pCommand->IsSwitchDefined( SWITCH_INTERNAL ) && 
             pCommand->GetEnv() == ENV_WIN32 )            
            Out_TransferSyntax( pCCB,
                        FakeNDR64TransferSyntaxGuidStrs,
                        NDR64_UUID_MAJOR_VERSION,
                        NDR64_UUID_MINOR_VERSION );
        else
            Out_TransferSyntax( pCCB,
				NDR64TransferSyntaxGuidStrs,			// ndr identifying guid.
				NDR64_UUID_MAJOR_VERSION,			// ndr's version
				NDR64_UUID_MINOR_VERSION );
	    }
        
    pStream->Write( ',' );
                        
                        

    //
    // Emit the callback dispatch table address, if none, emit a NULL
    //
    pStream->NewLine();
    if( pCallbackDispatchTable )
        {
        pStream->Write( pCallbackDispatchTable );
        }
    else
        {
        pStream->Write( '0' );
        }
    pStream->Write( ',' );

    //
    // If there is a protseq ep count, emit a pointer to the ep table
    // else emit a null.
    //

    pStream->NewLine();

    if( ProtSeqEPCount )
        {
        TempBuf.Set(",");
        TempBuf.Prepend(ProtSeqEPCount);
//        sprintf( TempBuf, "%d,", ProtSeqEPCount );
        pStream->Write( TempBuf );
        pStream->NewLine();
        pStream->Write( "__RpcProtseqEndpoint," );
        }
    else
        {
        pStream->Write( "0," );
        pStream->NewLine();
        pStream->Write( "0," );
        }

    pStream->NewLine();

    if( fNoDefaultEpv )
        {
        if( fSide == 1 )
            {
            TempBuf.Set( "(" );
            TempBuf.Append( pCCB->GetInterfaceName() );
            TempBuf.Append( pCCB->GenMangledName() );
            TempBuf.Append( "_" );
            TempBuf.Append( pCCB->IsOldNames() ? "SERVER_EPV" : "epv_t" );
            TempBuf.Append( " *) " );
            TempBuf.Append( "0xffffffff" );
            pStream->Write( TempBuf );
            }
        else
            {
            pStream->Write( '0' );
            }
        }
    else if( pCCB->IsMEpV() )
        {
        if( fSide == 1)
            pStream->Write( "&DEFAULT_EPV" );
        else
            pStream->Write( '0' );
        }
    else
        {
        pStream->Write('0');
        }

    //
    // Intepreter info.
    //
    pStream->Write( ',' );
    pStream->NewLine();

    if ( ( pCCB->GetCodeGenSide() == CGSIDE_SERVER &&
           pCCB->GetInterfaceCG()->HasInterpretedProc() ) ||
         ( pCCB->GetCodeGenSide() == CGSIDE_CLIENT &&
           pCCB->GetInterfaceCG()->HasInterpretedCallbackProc() ) )
        {
        RpcIntfFlag |= RPCFLG_HAS_CALLBACK;
        pStream->Write( '&' );
        pStream->Write( pCCB->GetInterfaceCG()->GetType()->GetSymName() );
        pStream->Write( SERVER_INFO_VAR_NAME );
        }
    else if ( pCommand->NeedsNDR64Run() )
        {
        pStream->Write( '&' );
        pStream->Write( pCCB->GetInterfaceCG()->GetType()->GetSymName() );
        pStream->Write( MIDL_PROXY_INFO_VAR_NAME );
        }
        else 
        {
        pStream->Write( '0' );
        }

    //
    // Emit flags
    //
    pStream->Write( ',' );
    pStream->NewLine();
    
    if (fHasPipes)
        {
        RpcIntfFlag |= RPC_INTERFACE_HAS_PIPES;
        }
        
    if ( pCommand->NeedsBothSyntaxes() )
        {
        RpcIntfFlag |= RPCFLG_HAS_MULTI_SYNTAXES;
        }

    pStream->WriteNumber( "0x%08x",(unsigned long )RpcIntfFlag );
    
    //
    // All Done. Phew !!
    //

    pStream->NewLine();
    pStream->Write( "};" );
    pStream->IndentDec();
}

void Out_OneSyntaxInfo( CCB * pCCB,
                        BOOL IsForCallback,
                        SYNTAX_ENUM syntaxType )
{
    ISTREAM *pStream = pCCB->GetStream();
    char                Buffer[_MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT+1];

    pStream->Write( "{" );
    pStream->NewLine();
    
    if ( syntaxType == SYNTAX_NDR64 )
        {
        if ( pCommand->IsSwitchDefined( SWITCH_INTERNAL ) && 
             pCommand->GetEnv() == ENV_WIN32 )            
            Out_TransferSyntax( pCCB,
                        FakeNDR64TransferSyntaxGuidStrs,
                        NDR64_UUID_MAJOR_VERSION,
                        NDR64_UUID_MINOR_VERSION );
        else
            Out_TransferSyntax( pCCB,
                        NDR64TransferSyntaxGuidStrs,
                        NDR64_UUID_MAJOR_VERSION,
                        NDR64_UUID_MINOR_VERSION );
        
        }
    if ( syntaxType == SYNTAX_DCE )
        Out_TransferSyntax( pCCB,
                        TransferSyntaxGuidStrs,
                        NDR_UUID_MAJOR_VERSION,
                        NDR_UUID_MINOR_VERSION );

                        
    pStream->Write( ',' );

    // yongqu: DispatchTable: we need only one dispatch table for now.

    // we need to generate dispatch table for syntax_info in MIDL_SERVER_INFO, where
    // runtime will use it to dispatch call. This include regular server side syntaxinfo
    // and client side callback syntax info. 
    if ( ! pCCB->GetInterfaceCG()->IsObject() && 
         ( ( ( pCCB->GetCodeGenSide() == CGSIDE_SERVER ) && !IsForCallback ) ||
         ( ( pCCB->GetCodeGenSide() == CGSIDE_CLIENT ) && IsForCallback ) ) )
        {
        pStream->WriteOnNewLine( "&" );
        sprintf( Buffer, 
                "%s%s%s%_DispatchTable,",
                pCCB->GetInterfaceName(),
                ( syntaxType == SYNTAX_NDR64 )?"_NDR64_":"",
                pCCB->GenMangledName() );

        pStream->Write(Buffer );
        }
    else 
        pStream->WriteOnNewLine( "0," );
        
    pStream->NewLine();

    // proc format string.
    if ( syntaxType == SYNTAX_DCE )
        {
        pStream->Write( PROC_FORMAT_STRING_STRING_FIELD );
        }
    else
        {
        pStream->Write( "(unsigned char *) &NDR64_MIDL_FORMATINFO" );
        }
    pStream->Write( ',' );
    pStream->NewLine();

    // The reference to the proc offset table

    if ( SYNTAX_NDR64 == syntaxType)
        pStream->Write( "(unsigned short *) " );

    if ( pCCB->GetInterfaceCG()->IsObject() )
        pStream->Write( '&' );
    
    if ( IsForCallback )
        pStream->Write( MIDL_CALLBACK_VAR_NAME );
        
    pStream->Write( pCCB->GetInterfaceCG()->GetSymName() );

    if ( syntaxType == SYNTAX_DCE )
        pStream->Write( FORMAT_STRING_OFFSET_TABLE_NAME );
    else
        pStream->Write( "_Ndr64ProcTable" );

    if ( pCCB->GetInterfaceCG()->IsObject() )
        pStream->Write( "[-3]," );
    else    
        pStream->Write( ',' );
    pStream->NewLine();

    //

    if ( syntaxType == SYNTAX_DCE )
        {
        pStream->Write( FORMAT_STRING_STRING_FIELD );
        }
    else
        pStream->Write( "(unsigned char *) &NDR64_MIDL_FORMATINFO" );

    pStream->Write( ',' );

    // TODO: Usermarshal routines?
    pStream->NewLine();

    if ( pCCB->HasQuadrupleRoutines() )
        {
        if ( syntaxType == SYNTAX_DCE )
            pStream->Write( USER_MARSHAL_ROUTINE_TABLE_VAR );
        else
            pStream->Write( NDR64_USER_MARSHAL_ROUTINE_TABLE_VAR );            
        pStream->Write( "," );
        }
    else
        pStream->Write( "0," );
        
    pStream->WriteOnNewLine( "0," );
    pStream->WriteOnNewLine( "0" );

    pStream->NewLine();
    pStream->Write( "}" );
    pStream->NewLine();

   
}


// separate out because this is being called from multiple places.
void 
Out_TransferSyntax(
    CCB *               pCCB,
    GUID_STRS       &   XferGuidStr,
    unsigned short      XferSynMajor,
    unsigned short      XferSynMinor )
{
    CSzBuffer TempBuf;
    ISTREAM *pStream = pCCB->GetStream();
   
    pStream->Write( '{' );
    Out_Guid( pCCB,
              XferGuidStr
            );

    //
    // Emit the interface version specified by the user.
    //

    TempBuf.Set( ",{" );
    TempBuf.Append( XferSynMajor );
    TempBuf.Append( "," );
    TempBuf.Append( XferSynMinor );
    TempBuf.Append( "}" );
    pStream->Write( TempBuf );
    pStream->Write( "}" );
}    

void
Out_MarshallSimple(
    CCB         *   pCCB,
    RESOURCE    *   pResource,
    node_skl    *   pType,
    expr_node  *   pSource,
    BOOL            fIncr,
    unsigned short  Size )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate marshalling for a type of a given alignment.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    pResource   - The marshalling buffer pointer resource.
    pType       - A pointer to the type of the entity being marshalled.
    pSource     - A pointer to the expression representing the source of
                  the marshalling.
    fIncr       - Output pointer increment code.
    Size        - The target alignment.

 Return Value:

 Notes:

----------------------------------------------------------------------------*/
{
    BOOL        fUnsigned   = pType->FInSummary( ATTR_UNSIGNED );
    CSzBuffer   TempBuf;
    ISTREAM *   pStream = pCCB->GetStream();
    char    *   pRtn;

    switch( Size )
        {
        case 1: pRtn = "char"; break;
        case 2: pRtn = "short"; break;
        case 4: pRtn = "long"; break;
        case 8: pRtn = "hyper";break;
        default: break;
        }

    pStream->NewLine();

    TempBuf.Set( "*((" );
    if (fUnsigned)
        TempBuf.Append( "unsigned " );
    TempBuf.Append( pRtn );
    TempBuf.Append( "*)" );
    TempBuf.Append( pResource->GetResourceName() );
    TempBuf.Append( ")" );
    if (fIncr)
        TempBuf.Append( "++" );
    TempBuf.Append( " = " );

    pStream->Write( TempBuf );
    pSource->Print( pStream );
    pStream->Write(';');
}

void
Out_AddToBufferPointer(
    CCB         *   pCCB,
    expr_node  *   pSource,
    expr_node  *   pExprAmount )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a force alignment by the specified alignment.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    pSource     - A source pointer
    pExprAmount - The amount to add

 Return Value:

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();
    expr_node  *   pExpr;

    pStream->NewLine();
    pExpr   = new expr_b_arithmetic( OP_PLUS,
                                      pSource,
                                      pExprAmount
                                    );
    pExpr   = new expr_assign( pSource, pExpr );
    pExpr->Print( pStream );
    pStream->Write(';');
}

void
Out_DispatchTableStuff(
    CCB     *   pCCB,
    ITERATOR&   ProcList,
    short       CountOfProcs)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the dispatch table and related data structures.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    ProcList    - A list of all the procedure names in the dispatch table.
    CountOfProcs- The number of procedures in the list.

 Return Value:

    None.

 Notes:

    Generate the dispatch table entries and then the dispatch table stuff.

----------------------------------------------------------------------------*/
{
//    if ( !pCommand->IsFinalProtocolRun() )
//        return;

    ISTREAM *   pStream = pCCB->GetStream();
    CSzBuffer   TempBuf;
    unsigned short M, m;

    pStream->NewLine();


    //
    // Generate the dispatch table structure name. Currently we just do
    // simple name mangling. This needs to be changed for dce stuff.
    //

    TempBuf.Set( "static " );
    TempBuf.Append( RPC_DISPATCH_FUNCTION_TYPE_NAME );
    TempBuf.Append( " " );
    TempBuf.Append( pCCB->GetInterfaceName() );
    if ( pCommand->IsNDR64Run() )
        TempBuf.Append( "_NDR64_" );

    TempBuf.Append( "_table[] =" );

    pStream->Write( TempBuf );

    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write('{');
    pStream->NewLine();

    //
    // Now print out the names of all the procedures.
    //

    ITERATOR_INIT( ProcList );

    for( int i = 0; i < CountOfProcs; ++i )
        {
        DISPATCH_TABLE_ENTRY    *   p;
        node_skl                *   pNode;

        ITERATOR_GETNEXT( ProcList, p );

        if ( p->Flags & DTF_PICKLING_PROC )
            pStream->Write( '0' );

//  BUGBUG: yongqu: code cleanup needed.
// -----------------------------------------------------------------
//      Server dispatch routine names:
//  raw rpc:
//      sync interface
//          ndr64 only:     NdrServerCallNdr64
//          ndr20 only:     NdrServerCall2
//          both syntaxes:  NdrServerCallAll
//      async interface
//          ndr64 only:     Ndr64AsyncServerCall64
//          ndr20 only:     NdrAsyncServerCall
//          both syntaxes:  Ndr64AsyncServerCallAll
//  ORPC:
//      sync interface
//          ndr64 only:     NdrStubCall3
//          both syntaxes:  NdrStubCall3
//          ndr20 only:     NdrStubCall2
//      async interface
//          ndr64 only:     NdrDcomAsyncStubCall
//          ndr20 only:     NdrDcomAsyncStubCall
//          both syntaxes:  NdrDcomAsyncStubCall
//
// reason for so many different entries:
//      In raw RPC, there is one dispatch table for each transfer syntax. RPC runtime
//      will call into the right dispatch table according to the syntax being used.
//      for raw rpc interface, we want to improvement server performance. 
//      after runtime select the right transfer syntax and called into 
//      right dispatch table, we know where MIDL_SYNTAX_INFO is and we can 
//      pickup the right format string etc. directly.
// 
//      In ORPC, all calls will be forwarded to the stub's Invoke, so we don't know
//      which transfer syntax is being used when ole dispatch the call to engine. 
//      we need to find out the selected syntax anyway. 
//      
// ------------------------------------------------------------------
#ifndef TEMPORARY_OI_SERVER_STUBS
        else if ( p->Flags & DTF_INTERPRETER )
            {
            if ( ((node_proc *)p->pNode)->HasAsyncUUID() )
                {
                if ( pCommand->IsNDR64Run() )
                    pStream->Write( S_NDR64_CALL_RTN_NAME_DCOM_ASYNC );
                else
                    pStream->Write( S_NDR_CALL_RTN_NAME_DCOM_ASYNC );
                }
            else if ( ((node_proc *)p->pNode)->HasAsyncHandle() )
                {
                if ( pCommand->IsNDR64Run() )
                    {
                    if ( pCommand->NeedsBothSyntaxes() )
                        pStream->Write( S_ALL_CALL_RTN_NAME_ASYNC );
                    else
                        pStream->Write( S_NDR64_CALL_RTN_NAME_ASYNC );
                    }
                else
                    pStream->Write( S_NDR_CALL_RTN_NAME_ASYNC );
                }
            else if ( ((node_proc *)p->pNode)->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 )
                {
                if ( pCommand->IsNDR64Run() )
                    {
                    if ( pCommand->NeedsBothSyntaxes() )
                        pStream->Write( S_ALL_CALL_RTN_NAME );
                    else
                        pStream->Write( S_NDR64_CALL_RTN_NAME );
                    }
                else
                    pStream->Write( S_NDR_CALL_RTN_NAME_V2 );
                }
            else
                pStream->Write( S_NDR_CALL_RTN_NAME );
            }
#endif // TEMPORARY_OI_SERVER_STUBS

        else
            {

            pNode = p->pNode;

            TempBuf.Set( pCCB->GetInterfaceName() );
            TempBuf.Append( "_" );
            TempBuf.Append( pNode->GetSymName() );

            pStream->Write( TempBuf );
            }
        pStream->Write( ',' );
        pStream->NewLine();
        }

    //
    // Write out a null and the closing brace.
    //

    pStream->Write( '0' ); pStream->NewLine();
    pStream->Write( "};" );

    pStream->IndentDec();

    //
    // Write out the dispatch table.
    //

    pCCB->GetVersion( &M, &m );

    pStream->NewLine();

    TempBuf.Set( RPC_DISPATCH_TABLE_TYPE_NAME );
    TempBuf.Append( " " );
    TempBuf.Append( pCCB->GetInterfaceName() );
    if ( pCommand->IsNDR64Run() )
        TempBuf.Append( "_NDR64_" );
    TempBuf.Append( pCCB->GenMangledName() );
    TempBuf.Append( "_DispatchTable = " );

    pStream->Write( TempBuf );
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->NewLine();

    TempBuf.Set( "" );
    TempBuf.Append( CountOfProcs );
    TempBuf.Append( "," );

    pStream->Write( TempBuf );
    pStream->NewLine();

    TempBuf.Set( pCCB->GetInterfaceName() );
    if ( pCommand->IsNDR64Run() )
        TempBuf.Append( "_NDR64_" );   
    TempBuf.Append( "_table" );

    pStream->Write( TempBuf ); pStream->NewLine(); pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine();


}

void
Out_CallManager(
    CCB         *   pCCB,
    expr_proc_call *   pProcExpr,
    expr_node      *   pRet,
    BOOL                fIsCallback )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a call to the manager routine.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    pProcExpr   - A pointer to the complete procedure expression.
    pRet        - An optional pointer to ther return variable.
    fIsCallback - Is this a callback proc ?

 Return Value:

    None.
 Notes:

    Emit code to check for the manager epv also.
----------------------------------------------------------------------------*/
{
    expr_node  *   pAss    = pProcExpr;
    expr_node  *   pExpr;
    CSzBuffer       Buffer;
    ISTREAM     *   pStream = pCCB->GetStream();
    unsigned short  M, m;
    char        *   pTemp;
    short           Indent  = 0;

    pCCB->GetStream()->NewLine();

    // If he specified the -epv flag, then dont generate the call to the
    // static procedure. This is the opposite of the dce functionality.

    //
    // In case of -epv:
    //   ((interface_...) -> proc( ... );
    // else
    //   proc ( ... );
    //

    if( pCCB->IsMEpV() && !fIsCallback  )
        {
        pCCB->GetVersion( &M, &m );

        Buffer.Set( "((" );
        Buffer.Append( pCCB->GetInterfaceName() );
        Buffer.Append( pCCB->GenMangledName() );
        Buffer.Append( "_" );
        Buffer.Append( pCCB->IsOldNames() ? "SERVER_EPV" : "epv_t" );
        Buffer.Append( " *)(" );
        Buffer.Append( PRPC_MESSAGE_MANAGER_EPV_NAME );
        Buffer.Append( "))" );

        pTemp = new char [ strlen( Buffer ) + 1 ];
        strcpy( pTemp, Buffer );

        pExpr = new expr_variable( pTemp );//this has the rhs expr for the
                                           // manager epv call. Sneaky !
        pExpr = new expr_pointsto( pExpr, pProcExpr );
        pAss = pExpr;
        if( pRet )
            {
            pAss    = new expr_assign( pRet, pExpr );
            Indent  = 7;        // sizeof "_RetVal"
            }
        pStream->NewLine();
        }
    else
        {
        pAss = pProcExpr;
        if( pRet )
            {
            pAss    = new expr_assign( pRet, pProcExpr );
            Indent  = 7;        // sizeof "_RetVal"
            }
        pStream->NewLine();
        }
    pAss->PrintCall( pStream, Indent, 0 );


}

void
Out_FormatInfoExtern( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generates the forward extern declaration for the FormatInfo.
    (64bit format string)

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/

{
    ISTREAM *   pStream = pCCB->GetStream();
    
    if ( pCommand->NeedsNDR64Run() )
        {
        pStream->NewLine();

        // BUGBUG: We really don't need this anymore.
        pStream->WriteOnNewLine( 
                        "static const int NDR64_MIDL_FORMATINFO = 0;" );
        }
}

void
Out_TypeFormatStringExtern( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generates the forward extern declaration of the global type format string.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();

    if ( pCommand->NeedsNDRRun() )
        {
        pStream->NewLine( 1 );
        pStream->Write( "extern const " FORMAT_STRING_TYPE_NAME " " );
        pStream->Write( FORMAT_STRING_STRUCT_NAME ";" );
        }
}


void
Out_ProcFormatStringExtern( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generates the forward extern declaration of the interface-wide
    procedure/parameter format string.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();

    if ( pCommand->NeedsNDRRun() )
        {
        pStream->NewLine( 1 );
        pStream->Write( "extern const " PROC_FORMAT_STRING_TYPE_NAME " " );
        pStream->Write( PROC_FORMAT_STRING_STRUCT_NAME ";" );
        }
}


void
Out_StubDescriptorExtern(
    CCB *           pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generates the forward extern declaration of the global stub descriptor
    variable.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine( 2 );

    pStream->Write( "extern const " STUB_DESC_STRUCT_TYPE_NAME );

    pStream->Write( ' ' );

    pStream->Write( pCCB->GetInterfaceCG()->GetStubDescName() );
    pStream->Write( ';' );

    pStream->NewLine();
}

void 
Out_ProxyInfoExtern( CCB * pCCB )
{
    ISTREAM * pStream = pCCB->GetStream();

    pStream->NewLine();

    pStream->Write( " extern const " MIDL_PROXY_INFO_TYPE_NAME );

    pStream->Write( ' ' );
    pStream->Write( pCCB->GetInterfaceCG()->GetType()->GetSymName() );
    pStream->Write( MIDL_PROXY_INFO_VAR_NAME );
    pStream->Write( ';' );
}


void
Out_InterpreterServerInfoExtern( CCB * pCCB )
{
    ISTREAM * pStream;

    pStream = pCCB->GetStream();

    pStream->NewLine( 2 );

    pStream->Write( "extern const " SERVER_INFO_TYPE_NAME );

    pStream->Write( ' ' );

    pStream->Write( pCCB->GetInterfaceCG()->GetType()->GetSymName() );
    pStream->Write( SERVER_INFO_VAR_NAME );
    pStream->Write( ';' );
}

void
Out_NdrMarshallCall( CCB *      pCCB,
                     char *     pRoutineName,
                     char *     pParamName,
                     long       FormatStringOffset,
                     BOOL       fTakeAddress,
                     BOOL       fDereference )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Ouputs a call to an Ndr marshalling routine.

 Arguments:

    pStream             - the stream to write the output to
    pRoutineName        - the routine name (without the trailing "Marshall")
    pParamName          - the name of the parameter/variable being marshalled
    FormatStringOffset  - the offset into the format string where this
                          parameter's/variable's description begins

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *       pStream = pCCB->GetStream();
    unsigned short  Spaces;
    char            Buf[80];

    pStream->NewLine();

    Spaces = (unsigned short)(strlen(pRoutineName) + 10); // strlen("Marshall( ");

    pStream->Write( pRoutineName );
    pStream->Write( "Marshall( (PMIDL_STUB_MESSAGE)& "STUB_MESSAGE_VAR_NAME"," );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( "(unsigned char *)" );
    if ( fTakeAddress )
        pStream->Write( '&' );
    if ( fDereference )
        pStream->Write( '*' );
    pStream->Write( pParamName );
    pStream->Write( ',' );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( "(PFORMAT_STRING) &" );
    pStream->Write( FORMAT_STRING_STRUCT_NAME );
    sprintf( Buf, ".Format[%d] );", FormatStringOffset );
    pStream->Write( Buf );
    pStream->NewLine();
}

void
Out_NdrUnmarshallCall( CCB *        pCCB,
                       char *       pRoutineName,
                       char *       pParamName,
                       long         FormatStringOffset,
                       BOOL         fTakeAddress,
                       BOOL         fMustAllocFlag )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to an Ndr unmarshalling routine.

 Arguments:

    pStream             - the stream to write the output to
    pRoutineName        - the routine name (without the trailing "Unmarshall")
    pParamName          - the name of the parameter/variable being unmarshalled
    FormatStringOffset  - the offset into the format string where this
                          parameter's/variable's description begins

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *       pStream = pCCB->GetStream();
    unsigned short  Spaces = 0;
    char            Buf[80];

    pStream->NewLine();

    Spaces = (unsigned short)(strlen(pRoutineName) + 12); // strlen("Unmarshall( ");

    pStream->Write( pRoutineName );
    pStream->Write( "Unmarshall( (PMIDL_STUB_MESSAGE) &"STUB_MESSAGE_VAR_NAME"," );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( "(unsigned char * *)" );
    if ( fTakeAddress )
        pStream->Write( '&' );
    pStream->Write( pParamName );
    pStream->Write( ',' );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( "(PFORMAT_STRING) &" );
    pStream->Write( FORMAT_STRING_STRUCT_NAME );
    sprintf( Buf, ".Format[%d],", FormatStringOffset );
    pStream->Write( Buf );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( "(unsigned char)" );
    pStream->Write( fMustAllocFlag ? "1" : "0" );
    pStream->Write( " );" );
    pStream->NewLine();
}

void
Out_NdrBufferSizeCall( CCB *        pCCB,
                       char *       pRoutineName,
                       char *       pParamName,
                       long         FormatStringOffset,
                       BOOL         fTakeAddress,
                       BOOL         fDereference,
                       BOOL         fPtrToStubMsg )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to an Ndr buffer sizing routine.

 Arguments:

    pStream             - the stream to write the output to
    pRoutineName        - the routine name (without the trailing "BufferSize")
    pParamName          - the name of the parameter/variable being sized
    FormatStringOffset  - the offset into the format string where this
                          parameter's/variable's description begins
    fPtrToStubMsg       - defines how the StubMsg should be referenced to
                            FALSE:  &_StubMsg
                            TRUE :  pStupMsg

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *       pStream = pCCB->GetStream();
    unsigned short  Spaces;
    char            Buf[80];

    pStream->NewLine();

    Spaces = (unsigned short)(strlen(pRoutineName) + 12); // strlen("BufferSize( ");

    // Stub message
    pStream->Write( pRoutineName );
    pStream->Write( fPtrToStubMsg ? "BufferSize( (PMIDL_STUB_MESSAGE) "PSTUB_MESSAGE_PAR_NAME","
                                  : "BufferSize( (PMIDL_STUB_MESSAGE) &"STUB_MESSAGE_VAR_NAME"," );
    pStream->NewLine();

    // Param
    pStream->Spaces( Spaces );
    pStream->Write( "(unsigned char *)" );
    if ( fTakeAddress )
        pStream->Write( '&' );
    if ( fDereference )
        pStream->Write( '*' );
    pStream->Write( pParamName );
    pStream->Write( ',' );
    pStream->NewLine();

    // Format string
    pStream->Spaces( Spaces );
    pStream->Write( "(PFORMAT_STRING) &" );
    pStream->Write( FORMAT_STRING_STRUCT_NAME );
    sprintf( Buf, ".Format[%d] );", FormatStringOffset );
    pStream->Write( Buf );
    pStream->NewLine();
}

void
Out_NdrFreeCall( CCB *      pCCB,
                 char *     pRoutineName,
                 char *     pParamName,
                 long       FormatStringOffset,
                 BOOL       fTakeAddress,
                 BOOL       fDereference )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to an Ndr unmarshalling routine.

 Arguments:

    pStream             - the stream to write the output to
    pRoutineName        - the routine name (without the trailing "Free")
    pParamName          - the name of the parameter/variable being freed
    FormatStringOffset  - the offset into the format string where this
                          parameter's/variable's description begins

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *       pStream = pCCB->GetStream();
    unsigned short  Spaces;
    char            Buf[80];

    pStream->NewLine();

    Spaces = (unsigned short)(strlen(pRoutineName) + 6); // strlen("Free( ");

    pStream->Write( pRoutineName );
    pStream->Write( "Free( &"STUB_MESSAGE_VAR_NAME"," );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( "(unsigned char *)" );
    if ( fTakeAddress )
        pStream->Write( '&' );
    if ( fDereference )
        pStream->Write( '*' );
    pStream->Write( pParamName );
    pStream->Write( ',' );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( '&' );
    pStream->Write( FORMAT_STRING_STRUCT_NAME );
    sprintf( Buf, ".Format[%d] );", FormatStringOffset );
    pStream->Write( Buf );
    pStream->NewLine();
}

void
Out_NdrConvert( CCB *           pCCB,
                long            FormatStringOffset,
                long            ParamTotal,
                unsigned short  ProcOptimFlags )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to NdrConvert().

 Arguments:

    None.

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    char        Buf[80];

    pStream->NewLine();
    pStream->Write( "if ( ("  );
    pStream->Write( (pCCB->GetCodeGenSide() == CGSIDE_CLIENT) ?
                        RPC_MESSAGE_VAR_NAME"." : PRPC_MESSAGE_VAR_NAME"->" );
    pStream->Write( "DataRepresentation & 0X0000FFFFUL) != "
                    "NDR_LOCAL_DATA_REPRESENTATION )" );
    pStream->IndentInc();
    pStream->NewLine();

    if ( ProcOptimFlags  &  OPTIMIZE_NON_NT351 )
        pStream->Write( NDR_CONVERT_RTN_NAME_V2 );
    else
        pStream->Write( NDR_CONVERT_RTN_NAME );
    pStream->Write( "( (PMIDL_STUB_MESSAGE) &" );
    pStream->Write( STUB_MESSAGE_VAR_NAME ", " );

    pStream->Write( "(PFORMAT_STRING) &" );
    pStream->Write( PROC_FORMAT_STRING_STRING_FIELD );
    sprintf( Buf, "[%d]", FormatStringOffset );
    pStream->Write( Buf );

    //
    // NdrConvert2 takes a third parameter.
    //
    if ( ProcOptimFlags  &  OPTIMIZE_NON_NT351 )
        {
        sprintf( Buf, ", %d", ParamTotal );
        pStream->Write( Buf );
        }

    pStream->Write( " );" );

    pStream->IndentDec();
    pStream->NewLine();
}

void
Out_NdrNsGetBuffer( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to NdrNsGetBuffer().

 Arguments:

    None.

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( AUTO_NDR_GB_RTN_NAME );
    pStream->Write( "( (PMIDL_STUB_MESSAGE) &" );
    pStream->Write( STUB_MESSAGE_VAR_NAME ", " );
    pStream->Write( STUB_MSG_LENGTH_VAR_NAME ", " );

    if( pCCB->GetCodeGenSide() == CGSIDE_CLIENT )
        {
        pStream->Write( pCCB->GetInterfaceName() );
        pStream->Write( AUTO_BH_VAR_NAME );
        }
    else
        pStream->Write( '0' );

    pStream->Write( " );" );
    pStream->NewLine();
}

void
Out_NdrGetBuffer( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to NdrGetBuffer().

 Arguments:

    None.

----------------------------------------------------------------------------*/
{
    ISTREAM *       pStream = pCCB->GetStream();
    unsigned short  Env;

    Env = pCommand->GetEnv();

    if (pCCB->GetCodeGenSide() == CGSIDE_CLIENT)
        {
        pStream->NewLine();
        pStream->Write( DEFAULT_NDR_GB_RTN_NAME );
        pStream->Write( "( (PMIDL_STUB_MESSAGE) &" );
        pStream->Write( STUB_MESSAGE_VAR_NAME ", " );
        pStream->Write( STUB_MSG_LENGTH_VAR_NAME ", " );

        if( pCCB->GetCodeGenSide() == CGSIDE_CLIENT )
            pStream->Write( BH_LOCAL_VAR_NAME );
        else
            pStream->Write( '0' );

        pStream->Write( " );" );
        pStream->NewLine();
        }
    else
        {
        //
        // This saves us at least 15 instructions on an x86 server.
        //
        pStream->NewLine();
        pStream->Write( PRPC_MESSAGE_VAR_NAME "->BufferLength = "
                        STUB_MSG_LENGTH_VAR_NAME ";" );
        pStream->NewLine();
        pStream->NewLine();

        pStream->Write( RPC_STATUS_VAR_NAME" = I_RpcGetBuffer( "
                        PRPC_MESSAGE_VAR_NAME " ); ");
        pStream->NewLine();
        pStream->Write( "if ( "RPC_STATUS_VAR_NAME" )" );
        pStream->IndentInc();
        pStream->NewLine();
        pStream->Write( "RpcRaiseException( "RPC_STATUS_VAR_NAME" );" );
        pStream->IndentDec();
        pStream->NewLine();
        pStream->NewLine();

        pStream->Write( STUB_MSG_BUFFER_VAR_NAME
                        " = (unsigned char *) "
                        PRPC_MESSAGE_VAR_NAME "->Buffer;" );
        pStream->NewLine();
        }
}

void
Out_NdrNsSendReceive( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to NdrNsSendReceive().

 Arguments:

    None.

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( AUTO_NDR_SR_RTN_NAME );
    pStream->Write( "( (PMIDL_STUB_MESSAGE) &" );
    pStream->Write( STUB_MESSAGE_VAR_NAME ", " );
    pStream->Write( "(unsigned char *) "STUB_MESSAGE_VAR_NAME ".Buffer, " );
    pStream->Write( "(RPC_BINDING_HANDLE *) ""&" );
    pStream->Write( pCCB->GetInterfaceName() );
    pStream->Write( AUTO_BH_VAR_NAME );
    pStream->Write( " );" );
    pStream->NewLine();
}

void
Out_NdrSendReceive( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to NdrSendReceive().

 Arguments:

    None.

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( DEFAULT_NDR_SR_RTN_NAME );
    pStream->Write( "( (PMIDL_STUB_MESSAGE) &" );
    pStream->Write( STUB_MESSAGE_VAR_NAME ", " );
    pStream->Write( "(unsigned char *) "STUB_MESSAGE_VAR_NAME ".Buffer" );
    pStream->Write( " );" );
    pStream->NewLine();
}

void
Out_FreeParamInline( CCB *  pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Frees a top level param using the current stub message deallocator.

 Arguments:

    pCCB    - Code control block.

----------------------------------------------------------------------------*/
{
    CG_PARAM *  pParam;
    ISTREAM *   pStream;

    pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( "if ( " );
    pStream->Write( pParam->GetResource()->GetResourceName() );
    pStream->Write( " )" );
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( STUB_MESSAGE_VAR_NAME ".pfnFree( " );
    pStream->Write( pParam->GetResource()->GetResourceName() );
    pStream->Write( " );" );

    pStream->IndentDec();
    pStream->NewLine();
}

void
Out_CContextHandleMarshall( CCB *   pCCB,
                            char *  pName,
                            BOOL    IsPointer )
{
    ISTREAM *           pStream;
    expr_proc_call *   pCall;
    expr_node *        pHandle;
    expr_node  *       pExpr;

    pStream = pCCB->GetStream();

    pStream->NewLine();

    pCall = new expr_proc_call( "NdrClientContextMarshall" );

    pExpr = new expr_u_address( new expr_variable( STUB_MESSAGE_VAR_NAME ));
    pExpr = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME , pExpr );

    pCall->SetParam( new expr_param( pExpr ) );

    pHandle = new expr_variable( pName );

    if ( IsPointer )
        pHandle = new expr_u_deref( pHandle );

    pHandle = MakeExpressionOfCastToTypeName( CTXT_HDL_C_CONTEXT_TYPE_NAME,
                                              pHandle );

    pCall->SetParam( new expr_param( pHandle ) );

    pCall->SetParam( new expr_param(
                     new expr_variable( IsPointer ? "0" : "1" ) ) );

    pCall->PrintCall( pStream, 0, 0 );
}

void
Out_SContextHandleMarshall( CCB *   pCCB,
                            char *  pName,
                            char *  pRundownRoutineName )
{
    ISTREAM *           pStream;
    expr_proc_call *   pCall;
    expr_node *        pHandle;
    expr_node *        pRoutine;
    expr_node  *       pExpr;

    pStream = pCCB->GetStream();

    pStream->NewLine();

    pCall = new expr_proc_call( "NdrServerContextMarshall" );

    pExpr = new expr_u_address( new expr_variable( STUB_MESSAGE_VAR_NAME ));
    pExpr = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME , pExpr );

    pCall->SetParam( new expr_param( pExpr ) );

    pHandle = new expr_variable( pName );

    pHandle = MakeExpressionOfCastToTypeName( CTXT_HDL_S_CONTEXT_TYPE_NAME,
                                              pHandle );

    pCall->SetParam( new expr_param( pHandle ) );

    pRoutine =  new expr_variable( pRundownRoutineName );

    pRoutine = MakeExpressionOfCastToTypeName( CTXT_HDL_RUNDOWN_TYPE_NAME,
                                               pRoutine );

    pCall->SetParam( new expr_param( pRoutine ) );

    pCall->PrintCall( pStream, 0, 0 );

    pStream->NewLine();
}

void
Out_SContextHandleNewMarshall( CCB *   pCCB,
                               char *  pName,
                               char *  pRundownRoutineName,
                               long    TypeOffset )
{
    ISTREAM *           pStream;
    unsigned short  Spaces;
    char            Buf[80];

    pStream = pCCB->GetStream();

    pStream->NewLine();

    pStream->Write( "NdrServerContextNewMarshall(" );
    pStream->NewLine();
    Spaces = 20;
    pStream->Spaces( Spaces );
    pStream->Write( "( PMIDL_STUB_MESSAGE )& "STUB_MESSAGE_VAR_NAME"," );
    pStream->NewLine();
    pStream->Spaces( Spaces );
    pStream->Write( "( " CTXT_HDL_S_CONTEXT_TYPE_NAME " ) " );
    pStream->Write( pName );
    pStream->Write( "," );
    pStream->NewLine();
    pStream->Spaces( Spaces );
    pStream->Write( "( " CTXT_HDL_RUNDOWN_TYPE_NAME " ) " );
    pStream->Write( pRundownRoutineName );
    pStream->Write( "," );
    pStream->NewLine();
    pStream->Spaces( Spaces );
    pStream->Write( "(PFORMAT_STRING) &" );
    pStream->Write( FORMAT_STRING_STRUCT_NAME );
    sprintf( Buf, ".Format[%d] );", TypeOffset );
    pStream->Write( Buf );

    pStream->NewLine();
}

void
Out_CContextHandleUnmarshall( CCB *     pCCB,
                              char *    pName,
                              BOOL      IsPointer,
                              BOOL      IsReturn )
{
    ISTREAM *           pStream;
    expr_proc_call *   pCall;
    expr_node *        pHandle;
    expr_node  *       pExpr;

    pStream = pCCB->GetStream();

    pStream->NewLine();

    if ( IsPointer )
        {
        pStream->Write( '*' );
        pStream->Write( pName );
        pStream->Write( " = (void *)0;" );
        pStream->NewLine();
        }
    else if ( IsReturn )
        {
        pStream->Write( pName );
        pStream->Write( " = 0;" );
        pStream->NewLine();
        }

    pCall = new expr_proc_call( "NdrClientContextUnmarshall" );

    pExpr = new expr_u_address( new expr_variable( STUB_MESSAGE_VAR_NAME ));
    pExpr = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME , pExpr );

    pCall->SetParam( new expr_param( pExpr ) );

    pHandle = new expr_variable( pName );

    if ( ! IsPointer && IsReturn )
        pHandle = new expr_u_address( pHandle );

    pHandle = MakeExpressionOfCastPtrToType(
                    (node_skl *) new node_def(CTXT_HDL_C_CONTEXT_TYPE_NAME),
                    pHandle );

    pCall->SetParam( new expr_param( pHandle ) );

    CG_PROC * pProc;

    pProc = (CG_PROC *)pCCB->GetCGNodeContext();

    char * FullAutoHandleName = NULL;

    if ( pProc->IsAutoHandle() )
        {
        FullAutoHandleName = new char[ strlen( pCCB->GetInterfaceName()) +
                                       strlen( AUTO_BH_VAR_NAME ) + 1 ];
        strcpy( FullAutoHandleName, pCCB->GetInterfaceName() );
        strcat( FullAutoHandleName, AUTO_BH_VAR_NAME );
        }

    pCall->SetParam( new expr_param(
                     new expr_variable( pProc->IsAutoHandle()
                                            ? FullAutoHandleName
                                            : BH_LOCAL_VAR_NAME ) ) );

    pCall->PrintCall( pStream, 0, 0 );

    pStream->NewLine();
}

void
Out_SContextHandleUnmarshall( CCB *     pCCB,
                              char *    pName,
                              BOOL      IsOutOnly )
{
    ISTREAM *           pStream;
    expr_proc_call *   pCall;
    expr_node  *       pExpr;

    pStream = pCCB->GetStream();

    pStream->NewLine();

    if ( IsOutOnly )
        {
        CSzBuffer Buffer;

        Buffer.Set( pName );
        Buffer.Append( " = NDRSContextUnmarshall( (uchar *)0, " );
        Buffer.Append( PRPC_MESSAGE_VAR_NAME "->DataRepresentation" );
        Buffer.Append( " );" );

        pStream->Write(Buffer);
        pStream->NewLine();

        return;
        }

    pCall = new expr_proc_call( "NdrServerContextUnmarshall" );

    pExpr = new expr_u_address( new expr_variable( STUB_MESSAGE_VAR_NAME ));
    pExpr = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME , pExpr );

    pCall->SetParam( new expr_param( pExpr ) );

    pExpr = new expr_variable( pName );

    pExpr = new expr_assign( pExpr, pCall );

    pExpr->PrintCall( pStream, 0, 0 );

    pStream->NewLine();
}

void
Out_SContextHandleNewUnmarshall( CCB *  pCCB,
                              char *    pName,
                              BOOL      IsOutOnly,
                              long      TypeOffset )
{
    ISTREAM *           pStream;
    unsigned short      Spaces;
    char                Buf[80];

    if ( IsOutOnly )
        return; 

    pStream = pCCB->GetStream();

    pStream->NewLine();

    pStream->Write( pName );
    pStream->Write( " = " );
    pStream->Write( "NdrServerContextNewUnmarshall(" );
    pStream->NewLine();
    Spaces = (unsigned short)(strlen( pName ) + 7);
    pStream->Spaces( Spaces );
    pStream->Write( "( PMIDL_STUB_MESSAGE )& "STUB_MESSAGE_VAR_NAME"," );
    pStream->NewLine();
    pStream->Spaces( Spaces );
    pStream->Write( "( PFORMAT_STRING )& " );
    pStream->Write( FORMAT_STRING_STRUCT_NAME );
    sprintf( Buf, ".Format[%d] );", TypeOffset );
    pStream->Write( Buf );

    pStream->NewLine();
}

void
Out_NdrFreeBuffer( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to NdrFreeBuffer().

 Arguments:

    None.

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( DEFAULT_NDR_FB_RTN_NAME );
    pStream->Write( "( (PMIDL_STUB_MESSAGE) &" );
    pStream->Write( STUB_MESSAGE_VAR_NAME );
    pStream->Write( " );" );
    pStream->NewLine();
}

void
Out_FullPointerInit( CCB * pCCB )
{
    ISTREAM *           pStream = pCCB->GetStream();
    expr_proc_call *   pProc;
    expr_node *        pExpr;

    pProc   = new expr_proc_call( FULL_POINTER_INIT_RTN_NAME );

    pProc->SetParam( new expr_param(
                     new expr_constant( (long) 0 ) ) );

    pProc->SetParam( new expr_param(
                     new expr_variable(
                        (pCCB->GetCodeGenSide() == CGSIDE_SERVER)
                            ? "XLAT_SERVER" : "XLAT_CLIENT" ) ) );

    pExpr = new expr_variable( STUB_MESSAGE_VAR_NAME ".FullPtrXlatTables" );

    pExpr = new expr_assign( pExpr, pProc );

    pStream->NewLine();

    pExpr->PrintCall( pStream, 0, 0 );

    pStream->NewLine();
}

void
Out_FullPointerFree( CCB * pCCB )
{
    ISTREAM *           pStream = pCCB->GetStream();
    expr_proc_call *   pProc;

    pProc   = new expr_proc_call( FULL_POINTER_FREE_RTN_NAME );

    pProc->SetParam( new expr_param(
                     new expr_variable(
                        STUB_MESSAGE_VAR_NAME ".FullPtrXlatTables" ) ) );

    pStream->NewLine();

    pProc->PrintCall( pStream, 0, 0 );

    pStream->NewLine();
}

void
Out_NdrInitStackTop( CCB * pCCB )
{
    ISTREAM * pStream;

    pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( STUB_MESSAGE_VAR_NAME ".StackTop = 0;" );
    pStream->NewLine();
}


void
Out_DispatchTableTypedef(
    CCB     *   pCCB,
    PNAME       pInterfaceName,
    ITERATOR&   ProcNodeList,
    int         flag )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output the dispatch table typedef.

 Arguments:

    pCCB            - A pointer to the code gen controller block.
    pInterfacename  - The base interface name.
    ProcNodeList    - The list of procedure node_proc nodes.
    flag            - 0 : normal, 1 : callback

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM         *   pStream = pCCB->GetStream();
    CSzBuffer       Buffer;
    node_skl        *   pNode;
    node_pointer    *   pPtr;
    node_id         *   pID;
    unsigned short      M, m;
    DISPATCH_TABLE_ENTRY    *   pDEntry;

    if( flag == 1 )
        return;

    pCCB->GetVersion( &M, &m );

    pStream->NewLine();

    if( flag == 0 )
        {
        Buffer.Set( "typedef struct _" );
        Buffer.Append( pInterfaceName );
        Buffer.Append( pCCB->GenMangledName() );
        Buffer.Append( "_" );
        Buffer.Append( pCCB->IsOldNames() ? "SERVER_EPV" : "epv_t" );

        pStream->Write( Buffer );
        pStream->NewLine();
        pStream->IndentInc();
        pStream->Write('{');
        pStream->NewLine();
        }
#if 0
    else
        {
        Buffer.Set( "typedef struct _" );
        Buffer.Append( pInterfaceName );
        Buffer.Append( pCCB->GenMangledName() );
        Buffer.Append( "_CLIENT_EPV" );
        }
#endif // 0


    ITERATOR_INIT( ProcNodeList );
    while( ITERATOR_GETNEXT( ProcNodeList, pDEntry ) )
        {
        pNode = pDEntry->pNode;
        pID     = new node_id( pNode->GetSymName() );
        pPtr    = new node_pointer( pNode );
        pID->SetBasicType( pPtr );
        pPtr->SetBasicType( pNode );
        pID->SetEdgeType( EDGE_DEF );
        pPtr->SetEdgeType( EDGE_USE );

        pID->PrintType( PRT_PROC_PTR_PROTOTYPE, pStream, (node_skl *)0 );
        }

    pStream->NewLine();
    pStream->IndentDec();

    if( flag == 0 )
        {
        Buffer.Set( "} " );
        Buffer.Append( pInterfaceName );
        Buffer.Append( pCCB->GenMangledName() );
        Buffer.Append( "_" );
        Buffer.Append( pCCB->IsOldNames() ?"SERVER_EPV" : "epv_t" );
        Buffer.Append( ";" );
        }
    else
        {
        Buffer.Set( "} " );
        Buffer.Append( pInterfaceName );
        Buffer.Append( pCCB->GenMangledName() );
        Buffer.Append( "_" );
        Buffer.Append( (flag == 0) ?"SERVER" : "CLIENT" );
        Buffer.Append( "_EPV;" );
        }
    pStream->Write( Buffer );
    pStream->NewLine();

}

void
Out_ManagerEpv(
    CCB     *   pCCB,
    PNAME       pInterfaceName,
    ITERATOR&   ProcNodeList,
    short       Count )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output the manager epv table.

 Arguments:

    pCCB            - A pointer to the code gen controller block.
    pInterfacename  - The base interface name.
    ProcNodeList    - The list of procedure node_proc nodes.
    Count           - Count of procs.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    if ( !pCommand->IsFinalProtocolRun() )
        return;

    ISTREAM         *   pStream = pCCB->GetStream();
    CSzBuffer       Buffer;
    unsigned short      M, m;
    DISPATCH_TABLE_ENTRY    *   pDEntry;

    pCCB->GetVersion( &M, &m );

    pStream->NewLine();

    Buffer.Set( "static " );
    Buffer.Append( pInterfaceName );
    Buffer.Append( pCCB->GenMangledName() );
    Buffer.Append( "_" );
    Buffer.Append( pCCB->IsOldNames() ? "SERVER_EPV" : "epv_t" );
    Buffer.Append( " DEFAULT_EPV = " );

    pStream->Write( Buffer );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write('{');
    pStream->NewLine();

    ITERATOR_INIT( ProcNodeList );
    while( ITERATOR_GETNEXT( ProcNodeList, pDEntry ) )
        {
    char    *   pPrefix = pCommand->GetUserPrefix( PREFIX_SERVER_MGR );
        if ( pPrefix )
        pStream->Write( pPrefix );

        pStream->Write( pDEntry->pNode->GetSymName() );
        if( --Count != 0 )
            {
            pStream->Write( ',' );
            pStream->NewLine();
            }
        }

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( "};" );
    pStream->NewLine();
}

void
Out_GenHdlPrototypes(
    CCB *   pCCB,
    ITERATOR& List )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output a list of generic handle prototypes.

 Arguments:

    pCCB    - A pointer to the code gen controller block.
    List    - List of type nodes.

 Return Value:

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    CSzBuffer   Buffer;
    node_skl*   pN;

    pStream->NewLine();

    while( ITERATOR_GETNEXT( List, pN ) )
        {
        PNAME   pName = pN->GetSymName();

        Buffer.Set( "handle_t __RPC_USER " );
        Buffer.Append( pName );
        Buffer.Append( "_bind  ( " );
        Buffer.Append( pName );
        Buffer.Append( " );" );
        pStream->Write( Buffer );
        pStream->NewLine();

        Buffer.Set( "void     __RPC_USER " );
        Buffer.Append( pName );
        Buffer.Append( "_unbind( " );
        Buffer.Append( pName );
        Buffer.Append( ", handle_t );" );
        pStream->Write( Buffer );
        pStream->NewLine();
        }
}

void
Out_CtxtHdlPrototypes(
    CCB *   pCCB,
    ITERATOR& List )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output a list of context handle prototypes.

 Arguments:

    pCCB    - A pointer to the code gen controller block.
    List    - List of type nodes.

 Return Value:

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    CSzBuffer   Buffer;
    node_skl*   pN;

    pStream->NewLine();

    while( ITERATOR_GETNEXT( List, pN ) )
        {
        PNAME   pName = pN->GetSymName();

        // A name can be a "" (an empty string).

        if ( strlen(pName) )
            {
            Buffer.Set( "void __RPC_USER " );
            Buffer.Append( pName );
            Buffer.Append( "_rundown( " );
            Buffer.Append( pName );
            Buffer.Append( " );" );
            pStream->Write( Buffer );
            pStream->NewLine();
            }
        }
}


void
Out_TransmitAsPrototypes(
    CCB     *   pCCB,
    ITERATOR&   ListOfPresentedTypes )
{
    ISTREAM *   pStream = pCCB->GetStream();
    ISTREAM *   pMemoryStream = new ISTREAM;
    CSzBuffer   Buffer;
    node_skl *  pXmittedType;
    node_skl *  pPresentedType;

    char *      pMemBufferStart = pMemoryStream->GetCurrentPtr();

    pStream->NewLine();

    while( ITERATOR_GETNEXT( ListOfPresentedTypes, pPresentedType ) )
        {
        // we reuse the same memory stream.
        pMemoryStream->SetCurrentPtr( pMemBufferStart );

        pXmittedType = ((node_def *)pPresentedType)->GetTransmittedType();

        PNAME   pPresentedTypeName  = pPresentedType->GetSymName();
        PNAME   pTransmittedTypeName= pXmittedType->GetSymName();

        pXmittedType->PrintType( PRT_TYPE_SPECIFIER,
                                 pMemoryStream,       // into stream
                                 (node_skl *)0        // no parent.
                               );
        //
        // The type spec is in the stream, except that it needs a terminating
        // null to use it as a string.
        //

        pTransmittedTypeName = pMemBufferStart;
        *(pMemoryStream->GetCurrentPtr()) = 0;

        pStream->NewLine();
        Buffer.Set( "void __RPC_USER " );
        Buffer.Append( pPresentedTypeName );
        Buffer.Append( "_to_xmit( " );
        Buffer.Append( pPresentedTypeName );
        Buffer.Append( " *, " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( " * * );" );
        pStream->Write( Buffer );

        pStream->NewLine();
        Buffer.Set( "void __RPC_USER " );
        Buffer.Append( pPresentedTypeName );
        Buffer.Append( "_from_xmit( " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( " *, " );
        Buffer.Append( pPresentedTypeName );
        Buffer.Append( " * );" );
        pStream->Write( Buffer );

        pStream->NewLine();
        Buffer.Set( "void __RPC_USER " );
        Buffer.Append( pPresentedTypeName );
        Buffer.Append( "_free_inst( " );
        Buffer.Append( pPresentedTypeName );
        Buffer.Append( " * );" );
        pStream->Write( Buffer );

        pStream->NewLine();
        Buffer.Set( "void __RPC_USER " );
        Buffer.Append( pPresentedTypeName );
        Buffer.Append( "_free_xmit( " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( " * );" );
        pStream->Write( Buffer );

        pStream->NewLine();
        }

    delete pMemoryStream;
}


void
Out_RepAsPrototypes(
    CCB     *   pCCB,
    ITERATOR&   ListOfRepAsWireTypes )
    {
    ISTREAM *   pStream = pCCB->GetStream();
    CSzBuffer   Buffer;
    node_skl *  pWireType;

    pStream->NewLine();

    while( ITERATOR_GETNEXT( ListOfRepAsWireTypes, pWireType ) )
        {
        PNAME   pRepAsTypeName = ((node_def *)pWireType)->GetRepresentationName();
        PNAME   pTransmittedTypeName= pWireType->GetSymName();

        pStream->NewLine();
        Buffer.Set( "void __RPC_USER " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( "_from_local( " );
        Buffer.Append( pRepAsTypeName );
        Buffer.Append( " *, " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( " * * );" );
        pStream->Write( Buffer );

        pStream->NewLine();
        Buffer.Set( "void __RPC_USER ");
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( "_to_local( " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( " *, " );
        Buffer.Append( pRepAsTypeName );
        Buffer.Append( " * );" );
        pStream->Write( Buffer );

        pStream->NewLine();
        Buffer.Set(" void __RPC_USER " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( "_free_inst( " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( " * );" );
        pStream->Write( Buffer );

        pStream->NewLine();
        Buffer.Set( "void __RPC_USER " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( "_free_local( " );
        Buffer.Append( pRepAsTypeName );
        Buffer.Append( " * );" );
        pStream->Write( Buffer );

        pStream->NewLine();
        }
    }



#define USRM_SIZE      0
#define USRM_FREE      3


char * UserMProtoName[ 4 ] =
    {
    USER_MARSHAL_SIZE "(     ",
    USER_MARSHAL_MARSHALL "(  ",
    USER_MARSHAL_UNMARSHALL "(",
    USER_MARSHAL_FREE "(     "
    };

char * NDR64_UserMProtoName[ 4 ] =
    {
    NDR64_USER_MARSHAL_SIZE "(     ",
    NDR64_USER_MARSHAL_MARSHALL "(  ",
    NDR64_USER_MARSHAL_UNMARSHALL "(",
    NDR64_USER_MARSHAL_FREE "(     "
    };

void
Out_UserMarshalSingleProto(
    ISTREAM *   pStream,
    char *      pTypeName,
    int         fProto,
    SYNTAX_ENUM SyntaxType )
{
    switch ( fProto )
        {
        case USRM_SIZE:
            pStream->Write( "unsigned long             __RPC_USER  " );
            break;
        case USRM_FREE:
            pStream->Write( "void                      __RPC_USER  " );
            break;
        default:
            pStream->Write( "unsigned char * __RPC_USER  " );
            break;
        }
    pStream->Write( pTypeName );
    if ( SyntaxType == SYNTAX_NDR64 )
        pStream->Write( NDR64_UserMProtoName[ fProto ] );
    else
        pStream->Write( UserMProtoName[ fProto ] );
        
    pStream->Write( "unsigned long *, " );  // flags
    switch ( fProto )
        {
        case USRM_SIZE:
            pStream->Write( "unsigned long            , " );
            break;
        case USRM_FREE:
            break;
        default:
            pStream->Write( "unsigned char *, " );
            break;
        }
    pStream->Write( pTypeName );
    pStream->Write( " * ); " );
    pStream->NewLine();
}

void
Out_OneUserMarshalProtoTypes(
    CCB     *   pCCB,
    ITERATOR&   ListOfPresentedTypes,
    SYNTAX_ENUM SyntaxType )
{
    USER_MARSHAL_CONTEXT * pUsrContext;

    ISTREAM *   pStream = pCCB->GetStream();

    ITERATOR_INIT( ListOfPresentedTypes );
    
    while( ITERATOR_GETNEXT( ListOfPresentedTypes, pUsrContext ) )
        {
        pStream->NewLine();

        for (int i=0; i < 4; i++)
            Out_UserMarshalSingleProto( pStream,
                                       pUsrContext->pTypeName,
                                       i,
                                       SyntaxType );
        }

    
}

void
Out_UserMarshalPrototypes(
    CCB     *   pCCB,
    ITERATOR&   ListOfPresentedTypes )
{
    if ( pCommand->NeedsNDRRun() )
        Out_OneUserMarshalProtoTypes( pCCB, ListOfPresentedTypes, SYNTAX_DCE );

    if ( pCommand->NeedsNDR64Run() ||
         pCommand->NeedsNDR64Header() )
        Out_OneUserMarshalProtoTypes( pCCB, ListOfPresentedTypes, SYNTAX_NDR64 );
    
}


char CsNetSizePrototype[] = 
        "_net_size(\n"
        "        RPC_BINDING_HANDLE     hBinding,\n"
        "        unsigned long          ulNetworkCodeSet,\n"
        "        unsigned long          ulLocalBufferSize,\n"
        "        IDL_CS_CONVERT *       conversionType,\n"
        "        unsigned long *        pulNetworkBufferSize,\n"
        "        error_status_t *       pStatus);\n\n";

char CsLocalSizePrototype[] = 
        "_local_size(\n"
        "        RPC_BINDING_HANDLE     hBinding,\n"
        "        unsigned long          ulNetworkCodeSet,\n"
        "        unsigned long          ulNetworkBufferSize,\n"
        "        IDL_CS_CONVERT *       conversionType,\n"
        "        unsigned long *        pulLocalBufferSize,\n"
        "        error_status_t *       pStatus);\n\n";
        
char CsToNetCsPrototype[] =
        "_to_netcs(\n"
        "       RPC_BINDING_HANDLE      hBinding,\n"
        "       unsigned long           ulNetworkCodeSet,\n"
        "       void *                  pLocalData,\n"
        "       unsigned long           ulLocalDataLength,\n"
        "       byte *                  pNetworkData,\n"
        "       unsigned long *         pulNetworkDataLength,\n"
        "       error_status_t *        pStatus);\n\n";

char CsFromNetCsPrototype[] = 
        "_from_netcs(\n"
        "       RPC_BINDING_HANDLE      hBinding,\n"
        "       unsigned long           ulNetworkCodeSet,\n"
        "       byte *                  pNetworkData,\n"
        "       unsigned long           ulNetworkDataLength,\n"
        "       unsigned long           ulLocalBufferSize,\n"
        "       void *                  pLocalData,\n"
        "       unsigned long *         pulLocalDataLength,\n"
        "       error_status_t *        pStatus);\n\n";

void
Out_CSSizingAndConversionPrototypes(
    CCB        * pCCB,
    ITERATOR & types )
{
    PNAME     pTypeName;
    ISTREAM * pStream = pCCB->GetStream();

    ITERATOR_INIT( types );

    while ( ITERATOR_GETNEXT( types, pTypeName ) )
        {
        pStream->Write( "void __RPC_USER " );
        pStream->Write( pTypeName );
        pStream->Write( CsNetSizePrototype );
    
        pStream->Write( "void __RPC_USER " );
        pStream->Write( pTypeName );
        pStream->Write( CsLocalSizePrototype );
    
        pStream->Write( "void __RPC_USER " );
        pStream->Write( pTypeName );
        pStream->Write( CsToNetCsPrototype );
    
        pStream->Write( "void __RPC_USER " );
        pStream->Write( pTypeName );
        pStream->Write( CsFromNetCsPrototype );
        }
}


void
Out_CallAsServerPrototypes(
    CCB     *   pCCB,
    ITERATOR&   ListOfCallAsRoutines )
    {
    ISTREAM *   pStream = pCCB->GetStream();
    node_proc * pProc;

    pStream->NewLine();

    while( ITERATOR_GETNEXT( ListOfCallAsRoutines, pProc ) )
        {
        // keep these on the stack...
        CSzBuffer           NewName;
        char                TempBuf[40];
        node_call_as    *   pCallAs = (node_call_as *)
                                            pProc->GetAttribute( ATTR_CALL_AS );
        unsigned short      M, m;
        node_interface  *   pIntf   = pProc->GetMyInterfaceNode();
    
        // don't emit the server prototype for object routines
        if ( pIntf->FInSummary( ATTR_OBJECT ) )
            continue;

        // local stub routine, with remote param list
        node_proc           NewStubProc( pProc );

        pIntf->GetVersionDetails( &M, &m );
        sprintf( TempBuf,
                "_v%d_%d",
                M,
                m );
        NewName.Set( pIntf->GetSymName() );
        NewName.Append( TempBuf );
        NewName.Append( "_" );
        NewName.Append( pCallAs->GetCallAsName() );

        NewStubProc.SetSymName( NewName );

        NewStubProc.PrintType( PRT_PROC_PROTOTYPE_WITH_SEMI,
                            pCCB->GetStream(),
                            NULL ,
                            pIntf );

        pCCB->GetStream()->NewLine();

        }
    }

void
Out_NotifyPrototypes(
    CCB     *   pCCB,
    ITERATOR&   ListOfNotifyProcedures)
/*
    We generate
        void  <proc_name>_notify( void );
        void  <proc_name>_notify_flag( boolean );

*/
    {
    ISTREAM *   pStream = pCCB->GetStream();
    CG_PROC   * pProcCG;
    node_proc * pProc;
    node_skl  * pRet;
    BOOL        fHasFlag;

    GetBaseTypeNode( &pRet, SIGN_UNDEF, SIZE_UNDEF, TYPE_VOID );

    pStream->NewLine();

    while( ITERATOR_GETNEXT( ListOfNotifyProcedures, pProcCG ) )
        {
        // keep these on the stack...
        CSzBuffer           NewName;
        node_proc           NewStubProc( 0, 0 );
        node_param          FlagParam;

        fHasFlag = pProcCG->HasNotifyFlag();
        pProc    = (node_proc *) pProcCG->GetType();

        NewStubProc.SetChild( pRet );

        if ( fHasFlag )
            {
            node_skl  * pParamType;

            GetBaseTypeNode( &pParamType, SIGN_UNDEF, SIZE_UNDEF, TYPE_BOOLEAN );

            FlagParam.SetChild( pParamType );
            FlagParam.SetSymName( NOTIFY_FLAG_VAR_NAME );
            
            NewStubProc.SetFirstMember( & FlagParam );
            }

        NewName.Set( pProc->GetSymName() );
        NewName.Append( (fHasFlag ? NOTIFY_FLAG_SUFFIX
                                  : NOTIFY_SUFFIX )  );
        NewStubProc.SetSymName( NewName );

        NewStubProc.PrintType( PRT_PROC_PROTOTYPE_WITH_SEMI,
                               pStream,
                               NULL );

        pCCB->GetStream()->NewLine();

        }
    }


void
Out_PatchReference(
    CCB     *   pCCB,
    expr_node  *   pDest,
    expr_node  *   pSrc,
    BOOL            fIncr )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output a patch of a pointer to the source pointer.

 Arguments:

    pCCB    - The cg cont. block.
    pDest   - The destination expression
    pSrc    - The source expression.
    fIncr   - Should we increment the ptr ?

 Return Value:

    None.

 Notes:

    Both the expressions must be pointers.
    Cast the source expression to the destination.
----------------------------------------------------------------------------*/
{
    ISTREAM     * pStream = pCCB->GetStream();

    node_skl    * pType = pDest->GetType();
    NODE_T        NT    = pType->NodeKind();
    expr_node  * pCast;
    expr_node  * pAss;

    if( (NT == NODE_ID) || (NT == NODE_PARAM) || (NT == NODE_FIELD) )
        {
        pType   = pType->GetBasicType();
        }

    pCast   = (expr_node *) new expr_cast( pType, pSrc );
    if( fIncr )
        pCast   = (expr_node *) new expr_post_incr( pCast );
    pAss    = (expr_node *) new expr_assign( pDest, pCast );
    pStream->NewLine();

    pAss->Print( pStream );
    pStream->Write(';');

}

void
Out_Endif( CCB * pCCB )
    {
    pCCB->GetStream()->NewLine();
    pCCB->GetStream()->Write( '}' );
    Out_IndentDec( pCCB );
    }

void
Out_If(
    CCB         *   pCCB,
    expr_node  *   pExpr )
    {
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( "if(" );
    pExpr->Print( pStream );
    pStream->Write( ')' );
    Out_IndentInc( pCCB );
    pStream->NewLine();
    pStream->Write( '{' );
    }
void
Out_Else(
    CCB         *   pCCB )
    {
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( "else" );
    Out_IndentInc( pCCB );
    pStream->NewLine();
    pStream->Write( '{' );
    }
void
Out_UniquePtrMarshall(
    CCB         *   pCCB,
    expr_node  *   pDestExpr,
    expr_node  *   pSrcExpr )
    {

    ISTREAM         *   pStream = pCCB->GetStream();
    expr_proc_call *   pProc;

    pStream->NewLine();

    pProc   = new expr_proc_call( MARSHALL_UNIQUE_PTR_RTN_NAME );

    pProc->SetParam(new expr_param( pDestExpr ));
    pProc->SetParam(new expr_param( pSrcExpr ));

    pProc->PrintCall( pStream, 0, 0 );
    }
void
Out_IfUniquePtrInBuffer(
    CCB         *   pCCB,
    expr_node  *   pSrc )
//
//  This appears to be a fossil. Ryszard 3/30/98.
//  However, the routine above appears to be used.
//
    {

    expr_proc_call *   pProc   = new expr_proc_call( CHECK_UNIQUE_PTR_IN_BUFFER );
    ISTREAM         *   pStream = pCCB->GetStream();

    pProc->SetParam( new expr_param( pSrc ) );

    pStream->NewLine();
    pStream->Write( "if(" );
    pProc->Print( pStream );
    pStream->Write( ')' );
    Out_IndentInc( pCCB );
    pStream->NewLine();
    pStream->Write( '{' );
    }

void
Out_Assign( CCB * pCCB,
            expr_node * pDest,
            expr_node * pSrc )
    {
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine();
    pDest->Print( pStream );
    pStream->Write( " = " );
    pSrc->Print( pStream );
    pStream->Write( ';' );
    }

void
Out_Memcopy(
    CCB *   pCCB,
    expr_node  *   pDest,
    expr_node  *   pSource,
    expr_node  *   pLength )
    {
    ISTREAM *   pStream = pCCB->GetStream();
    expr_proc_call *   pCall   = new expr_proc_call( "memcpy" );

    pStream->NewLine();
    pCall->SetParam( new expr_param( pDest ) );
    pCall->SetParam( new expr_param( pSource ) );
    pCall->SetParam( new expr_param( pLength ) );
    pCall->PrintCall( pStream, 0, 0 );

    }
void
Out_strlen(
    CCB *   pCCB,
    expr_node  *   pDest,
    expr_node  *   pSource,
    unsigned short  Size )
    {
    ISTREAM *   pStream         = pCCB->GetStream();
    PNAME       pName           = (Size == 1) ? "strlen" : "MIDL_wchar_strlen";
    expr_proc_call *   pCall   = new expr_proc_call( pName );
    expr_node      *   pExpr;

    pStream->NewLine();
    pCall->SetParam( new expr_param( pSource ) );
    if( pDest )
        pExpr = new expr_assign( pDest, pCall );
    else
        pExpr = pCall;

    pExpr->PrintCall( pStream, 0, 0 );

    }
void
Out_For(
    CCB         *   pCCB,
    expr_node  *   pIndexExpr,
    expr_node  *   pInitialValue,
    expr_node  *   pFinalValue,
    expr_node  *   pIncrExpr )
    {

    ISTREAM     *   pStream = pCCB->GetStream();
    expr_node  *   pExpr;

    pStream->NewLine();
    pStream->Write( "for( " );

    pExpr   = new expr_assign( pIndexExpr, pInitialValue );
    pExpr->Print( pStream );
    pStream->Write( ';' );

    pExpr   = new expr_op_binary( OP_LESS, pIndexExpr, pFinalValue );
    pExpr->Print( pStream );
    pStream->Write( ';' );

    pExpr   = new expr_op_binary( OP_PLUS, pIndexExpr, pIncrExpr );
    pExpr   = new expr_assign( pIndexExpr, pExpr );
    pExpr->Print( pStream );
    pStream->Write( ')' );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( '{' );
    }

void
Out_EndFor( CCB * pCCB )
    {
    pCCB->GetStream()->NewLine();
    pCCB->GetStream()->Write( '}' );
    Out_IndentDec( pCCB );
    }

void
Out_PlusEquals(
    CCB *   pCCB,
    expr_node  *pL,
    expr_node  *pR )
    {
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine();
    pL->Print( pStream );
    pStream->Write( " += " );
    pR->Print( pStream );
    pStream->Write(';');

    }

void
Out_Comment(
    CCB     *   pCCB,
    char    *   pComment )
    {
    ISTREAM *   pStream = pCCB->GetStream();
    pStream->NewLine();
    pStream->Write( "/* " );
    pStream->Write( pComment );
    pStream->Write( " */" );

    }

void
Out_RpcSSEnableAllocate(
    CCB *   pCCB )
    {
    expr_proc_call * pCall = new expr_proc_call( RPC_SS_ENABLE_ALLOCATE_RTN_NAME );

    pCall->SetParam( new expr_param (
                     new expr_u_address (
                     new expr_variable( STUB_MESSAGE_VAR_NAME ) ) ) );

    pCCB->GetStream()->NewLine();
    pCall->PrintCall( pCCB->GetStream(), 0, 0 );
    }

void
Out_RpcSSSetClientToOsf(
    CCB *   pCCB )
    {
    expr_proc_call * pCall = new expr_proc_call( RPC_SM_SET_CLIENT_TO_OSF_RTN_NAME );

    pCall->SetParam( new expr_param (
                     new expr_u_address (
                     new expr_variable( STUB_MESSAGE_VAR_NAME ) ) ) );

    pCCB->GetStream()->NewLine();
    pCall->PrintCall( pCCB->GetStream(), 0, 0 );
    }

void
Out_RpcSSDisableAllocate(
    CCB *   pCCB )
    {
    expr_proc_call * pCall = new expr_proc_call( RPC_SS_DISABLE_ALLOCATE_RTN_NAME );

    pCall->SetParam( new expr_param (
                     new expr_u_address (
                     new expr_variable( STUB_MESSAGE_VAR_NAME ) ) ) );

    pCCB->GetStream()->NewLine();
    pCall->PrintCall( pCCB->GetStream(), 0, 0 );
    }

void
Out_MemsetToZero(
    CCB *   pCCB,
    expr_node  *   pDest,
    expr_node  *   pSize )
    {
    expr_proc_call *   pProc   = new expr_proc_call( (PNAME) MIDL_MEMSET_RTN_NAME );

    pProc->SetParam( new expr_param( pDest ) );
    pProc->SetParam( new expr_param( new expr_constant(0L) ) );
    pProc->SetParam( new expr_param( pSize ) );

    pCCB->GetStream()->NewLine();
    pProc->PrintCall( pCCB->GetStream(), 0, 0 );
    }

void
Out_CallAsProxyPrototypes(
    CCB     *   pCCB,
    ITERATOR&   ListOfCallAsRoutines )
/*++

Routine Description:

    This routine generates the call_as function prototypes.

    One for the proxy( with local param list )
    One for the stub( with remote param list )

Arguments:

    pCCB    - a pointer to the code generation control block.

--*/
    {
    ISTREAM *   pStream = pCCB->GetStream();
    node_proc * pProc;

    pStream->NewLine();

    while( ITERATOR_GETNEXT( ListOfCallAsRoutines, pProc ) )
    {
        node_interface  *   pIntf   = pProc->GetMyInterfaceNode();

        // skip for non-object routines
        if ( !pIntf->FInSummary( ATTR_OBJECT ) )
            continue;

        // keep these on the stack...
        CSzBuffer   NewName;
        node_call_as    *   pCallAs = (node_call_as *)
                                            pProc->GetAttribute( ATTR_CALL_AS );
        node_proc   NewProc( pCallAs->GetCallAsType() );

        // local proxy routine with local param list
        NewName.Set( pIntf->GetSymName() );
        NewName.Append( "_" );
        NewName.Append( pCallAs->GetCallAsName() );
        NewName.Append( "_Proxy" );

        NewProc.SetSymName( NewName );

        NewProc.PrintType( PRT_PROC_PROTOTYPE_WITH_SEMI | PRT_THIS_POINTER | PRT_FORCE_CALL_CONV,
                            pCCB->GetStream(),
                            NULL ,
                            pIntf );
        pStream->NewLine();

        // local stub routine, with remote param list
        node_proc   NewStubProc( pProc );
        NewName.Set( pIntf->GetSymName() );
        NewName.Append( "_" );
        NewName.Append( pCallAs->GetCallAsName() );
        NewName.Append( "_Stub" );

        NewStubProc.SetSymName( NewName );

        pStream->NewLine();
        NewStubProc.PrintType( PRT_PROC_PROTOTYPE_WITH_SEMI | PRT_THIS_POINTER | PRT_FORCE_CALL_CONV,
                            pStream,
                            NULL ,
                            pIntf );
        pStream->NewLine();

    }
}

void
CG_OBJECT_PROC::Out_ProxyFunctionPrototype(CCB *pCCB, PRTFLAGS F )
/*++

Routine Description:

    This routine generates a proxy function prototype.

Arguments:

    pCCB    - a pointer to the code generation control block.

--*/
{
    // keep these on the stack...
    CSzBuffer NewName;
    node_proc   *   pProc               = (node_proc *)GetType();
    node_proc       NewProc( pProc );

    NewName.Set( pCCB->GetInterfaceName() );
    NewName.Append( "_" );
    NewName.Append( pProc->GetSymName() );
    NewName.Append( "_Proxy" );

    NewProc.SetSymName( NewName );

    pCCB->GetStream()->NewLine();
    NewProc.PrintType( PRT_PROC_PROTOTYPE | PRT_THIS_POINTER | F | PRT_FORCE_CALL_CONV,
                        pCCB->GetStream(),
                        NULL ,
                        pCCB->GetInterfaceCG()->GetType() );

}


void
Out_IID(CCB *pCCB)
/*++

Routine Description:

    This routine generates an IID declaration for the current interface.

Arguments:

    pCCB    - a pointer to the code generation control block.

--*/
{
    ISTREAM *pStream = pCCB->GetStream();

    pStream->NewLine();
    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
    {
        node_guid * pGuid = (node_guid *) ((node_interface *)pCCB->GetInterfaceCG()->GetType())->GetAttribute(ATTR_GUID);
        if (pGuid)
            Out_MKTYPLIB_Guid(pCCB, pGuid->GetStrs(), "IID_", pCCB->GetInterfaceName());
    }
    else
    {
        pStream->Write("EXTERN_C const IID IID_");
        pStream->Write(pCCB->GetInterfaceName());
        pStream->Write(';');
        pStream->NewLine();
    }
}

void
Out_CLSID(CCB *pCCB)
/*++

Routine Description:

    This routine generates an CLSID declaration for the current com class.

Arguments:

    pCCB    - a pointer to the code generation control block.

--*/
{
    ISTREAM *pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("EXTERN_C const CLSID CLSID_");
    pStream->Write(pCCB->GetInterfaceName());
    pStream->Write(';');
    pStream->NewLine();
}


void
CG_OBJECT_PROC::Out_StubFunctionPrototype(CCB *pCCB)
{
    ISTREAM *   pStream = pCCB->GetStream();
    CSzBuffer   TempBuffer;

    TempBuffer.Set( "void __RPC_STUB " );
    TempBuffer.Append( pCCB->GetInterfaceName() );
    TempBuffer.Append( "_" );
    TempBuffer.Append( GetType()->GetSymName() );
    TempBuffer.Append( "_Stub(" );

    pStream->NewLine();
    pStream->Write( TempBuffer );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write("IRpcStubBuffer *This,");
    pStream->NewLine();
    pStream->Write("IRpcChannelBuffer *_pRpcChannelBuffer,");
    pStream->NewLine();
    pStream->Write("PRPC_MESSAGE _pRpcMessage,");
    pStream->NewLine();
    pStream->Write("DWORD *_pdwStubPhase)");
    pStream->IndentDec();
}

void
CG_OBJECT_PROC::Out_ServerStubProlog(
    CCB     *   pCCB,
    ITERATOR&   LocalsList,
    ITERATOR&   TransientList )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side procedure prolog.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    LocalsList  - A list of local resources.
    TransientList- A list of temp variables.

 Return Value:

 Notes:

    The server side procedure prolog generation cannot use the normal
    printtype method on the procedure node, since the server stub signature
    looks different.

    Also the name of the server side stub is mangled with the interface name.

    All server side procs are void returns.

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    RESOURCE*   pRes;

    Out_StubFunctionPrototype(pCCB);

    //
    // Write out the opening brace for the server proc and all that.
    //

    pStream->NewLine();
    pStream->Write( '{' );
    pStream->IndentInc();
    pStream->NewLine();

    //
    // This is where we get off for /Oi.  We have a special routine
    // for local variable declaration for /Oi.
    //
    if ( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER )
        return;

    //
    // Print out declarations for the locals.
    //

    if( ITERATOR_GETCOUNT( LocalsList ) )
        {
        ITERATOR_INIT( LocalsList );

        while( ITERATOR_GETNEXT( LocalsList, pRes ) )
            {
            pRes->GetType()->PrintType( PRT_ID_DECLARATION, // print decl
                                         pStream,        // into stream
                                         (node_skl *)0   // no parent.
                                      );
            }
        }

    if( ITERATOR_GETCOUNT( TransientList ) )
        {
        ITERATOR_INIT( TransientList );

        while( ITERATOR_GETNEXT( TransientList, pRes ) )
            {
            pStream->IndentInc();
            pRes->GetType()->PrintType( PRT_ID_DECLARATION, // print decl
                                         pStream,        // into stream
                                         (node_skl *)0   // no parent.
                                      );
            pStream->IndentDec();
            }
        }

    pStream->IndentDec();
    pStream->NewLine();

    //
    // Done.
    //
}

void
Out_CallMemberFunction(
    CCB         *   pCCB,
    expr_proc_call *   pProcExpr,
    expr_node      *   pRet,
    BOOL                fThunk)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a call to the manager routine.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    pProcExpr   - A pointer to the complete procedure expression.
    pRet        - An optional pointer to ther return variable.
    fThunk      - flag for "this call is in a thunk with a param struct"

 Return Value:

    None.

 Notes:

    //call server
    _RetVal = (((IClassFactory *) ((CStdStubBuffer*)This)->pvServerObject)->lpVtbl) -> LockServer((IClassFactory *) ((CStdStubBuffer *)This)->pvServerObject,fLock);

----------------------------------------------------------------------------*/
{
    expr_node  *   pAss    = pProcExpr;
    expr_node  *   pExpr;
    CSzBuffer   Buffer;
    ISTREAM     *   pStream = pCCB->GetStream();
    char        *   pTemp;

    if ( fThunk )
        {
        // ((IFoo*) ((CStdStubBuffer*)pParamStruct->This)->lpVtbl)->Bar();
        Buffer.Set( "((" );
        Buffer.Append( pCCB->GetInterfaceName() );
        Buffer.Append( "*) ((CStdStubBuffer*)pParamStruct->This)->lpVtbl)" );
        }
    else
        {
        // (((IFoo*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl)->Bar();
        Buffer.Set( "(((" );
        Buffer.Append( pCCB->GetInterfaceName() );
        Buffer.Append( "*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl)" );
        }

    pTemp = new char [ strlen( Buffer ) + 1 ];
    strcpy( pTemp, Buffer );

    pExpr = new expr_variable( pTemp );//this has the rhs expr for the
                                       // manager epv call. Sneaky !
    pExpr = new expr_pointsto( pExpr, pProcExpr );
    pAss = pExpr;
    if( pRet )
        {
        pAss    = new expr_assign( pRet, pExpr );
        }

    pAss->PrintCall( pStream, 0, 0 );


}

void
OutputNdrAlignment( CCB * pCCB,
                    unsigned short Alignment )
{
    ISTREAM *   pStream;
    unsigned long Align = Alignment - 1;
    CSzBuffer   Buffer;

    pStream = pCCB->GetStream();

    Buffer.Set( STUB_MSG_BUFFER_VAR_NAME );
    Buffer.Append( " = (unsigned char *)(((" );
    Buffer.Append( (pCommand->Is64BitEnv() ? "__int64"
                                           : "long" ));
    Buffer.Append( ")" STUB_MSG_BUFFER_VAR_NAME " + " );
    Buffer.Append( Align );
    char sz[100];
    sprintf( sz, ") & ~ %#x);", Align);
    Buffer.Append( sz );

    pStream->Write( Buffer );
    pStream->NewLine();
}

CG_NDR * 
GetFirstMulti( 
    CG_NDR * pNdr )
{
    // Skip pointers leading to a multi-dimensional object.

    while ( pNdr->GetCGID() == ID_CG_GENERIC_HDL  ||
            pNdr->GetCGID() == ID_CG_PTR ) 
        {
        pNdr = (CG_NDR *) pNdr->GetChild();
        }

    return pNdr;
}

void
Out_MultiDimVars(
    CCB * pCCB,
    CG_PARAM * pParam
    )
/*
    Output local resources related to multi-dimensional conf or varying arrays.
    Note that the parameter may be a pointer to multidimensional object.
*/
{
    ISTREAM *   pStream;
    CG_NDR *    pNdr;
    char *      pParamName;
    long        dim;
    CSzBuffer   Buffer;

    pStream = pCCB->GetStream();

    pParamName = pParam->GetType()->GetSymName();

    pNdr = (CG_NDR *) pParam->GetChild();

    pNdr = GetFirstMulti( pNdr );

    if ( pNdr->IsArray() )
        dim = ((CG_ARRAY *)pNdr)->GetDimensions();
    else // pNdr->IsPointer()
        dim = ((CG_POINTER *)pNdr)->SizedDimensions();

    Buffer.Set( "unsigned long _maxcount_" );
    Buffer.Append( pParamName );
    Buffer.Append( "[" );
    Buffer.Append( dim );
    Buffer.Append( "]" );

    pStream->Write( Buffer );
    pStream->Write( ";" );
    pStream->NewLine( 2 );

    Buffer.Set( "unsigned long _offset_" );
    Buffer.Append( pParamName );
    Buffer.Append( "[" );
    Buffer.Append( dim );
    Buffer.Append( "]" );
    pStream->Write( Buffer );
    pStream->Write( ';' );
    pStream->NewLine();

    Buffer.Set( "unsigned long _length_" );
    Buffer.Append( pParamName );
    Buffer.Append( "[" );
    Buffer.Append( dim );
    Buffer.Append( "]" );
    pStream->Write( Buffer );
    pStream->Write( ';' );
    pStream->NewLine();
}

void
Out_MultiDimVarsInit(
    CCB * pCCB,
    CG_PARAM * pParam
    )
/*
    Output local resources related to multi-dimensional conf or varying arrays.
    Note that the parameter may be a pointer to multidimensional object.
*/
{
    ISTREAM *   pStream;
    CG_NDR *    pNdr;
    char *      pParamName;
    long        i, dim;
    CSzBuffer   Buffer;

    pStream = pCCB->GetStream();

    pParamName = pParam->GetType()->GetSymName();

    pNdr = (CG_NDR *) pParam->GetChild();
    pNdr = GetFirstMulti( pNdr );

    if ( pNdr->IsArray() )
        dim = ((CG_ARRAY *)pNdr)->GetDimensions();
    else // pNdr->IsPointer()
        dim = ((CG_POINTER *)pNdr)->SizedDimensions();

    pStream->NewLine();

    //
    // Max count var.
    //
/*
    if ( (pNdr->GetCGID() == ID_CG_CONF_ARRAY) ||
         (pNdr->GetCGID() == ID_CG_CONF_VAR_ARRAY) ||
         (pNdr->GetCGID() == ID_CG_SIZE_PTR) ||
         (pNdr->GetCGID() == ID_CG_SIZE_LENGTH_PTR) )
*/
        {
        expr_node * pSizeIsExpr = 0;

        for ( i = 0; i < dim; pNdr = (CG_NDR *) pNdr->GetChild(), i++ )
            {
            Buffer.Set( "_maxcount_" );
            Buffer.Append( pParamName );
            Buffer.Append( "[" );
            Buffer.Append( i );
            Buffer.Append( "] = " );

            pStream->Write( Buffer );

            switch ( pNdr->GetCGID() )
                {
                case ID_CG_CONF_ARRAY :
                case ID_CG_CONF_VAR_ARRAY :
                case ID_CG_CONF_STRING_ARRAY :
                case ID_CG_STRING_ARRAY :
                    pSizeIsExpr = ((CG_ARRAY *)pNdr)->GetSizeIsExpr();
                    break;
                case ID_CG_SIZE_PTR :
                    pSizeIsExpr =
                        ((CG_SIZE_POINTER *)pNdr)->GetSizeIsExpr();
                    break;
                case ID_CG_SIZE_LENGTH_PTR :
                    pSizeIsExpr =
                        ((CG_SIZE_LENGTH_POINTER *)pNdr)->GetSizeIsExpr();
                    break;
                case ID_CG_SIZE_STRING_PTR :
                    pSizeIsExpr =
                        ((CG_SIZE_STRING_POINTER *)pNdr)->GetSizeIsExpr();
                    break;
                }

            if ( pSizeIsExpr )
                pSizeIsExpr->Print( pStream );
            else
                pStream->Write( '0' );

            pStream->Write( ';' );
            pStream->NewLine();
            }
        }

    pNdr = (CG_NDR *) pParam->GetChild();
    pNdr = GetFirstMulti( pNdr );

    //
    // Offset and Length vars.
    //
/*
    if ( (pNdr->GetCGID() == ID_CG_VAR_ARRAY) ||
         (pNdr->GetCGID() == ID_CG_CONF_VAR_ARRAY) ||
         (pNdr->GetCGID() == ID_CG_SIZE_LENGTH_PTR) )
*/
        {
        expr_node *     pFirstIsExpr = 0;
        expr_node *     pLengthIsExpr = 0;

        for ( i = 0; i < dim; pNdr = (CG_NDR *) pNdr->GetChild(), i++ )
            {
            Buffer.Set( "_offset_" );
            Buffer.Append( pParamName );
            Buffer.Append( "[" );
            Buffer.Append( i );
            Buffer.Append( "] = " );

            pStream->Write( Buffer );

            switch ( pNdr->GetCGID() )
                {
                case ID_CG_VAR_ARRAY :
                    pFirstIsExpr = ((CG_VARYING_ARRAY *)pNdr)->
                                        GetFirstIsExpr();
                    break;
                case ID_CG_CONF_VAR_ARRAY :
                    pFirstIsExpr = ((CG_CONFORMANT_VARYING_ARRAY *)pNdr)->
                                        GetFirstIsExpr();
                    break;
                case ID_CG_CONF_STRING_ARRAY :
                case ID_CG_STRING_ARRAY :
                    pFirstIsExpr = 0;
                    break;
                case ID_CG_SIZE_LENGTH_PTR :
                    pFirstIsExpr = ((CG_SIZE_LENGTH_POINTER *)pNdr)->
                                        GetFirstIsExpr();
                    break;
                }

            if ( pFirstIsExpr )
                pFirstIsExpr->Print( pStream );
            else
                pStream->Write( '0' );

            pStream->Write( ';' );
            pStream->NewLine();
            }

        pNdr = (CG_NDR *) pParam->GetChild();
        pNdr = GetFirstMulti( pNdr );

        for ( i = 0; i < dim; pNdr = (CG_NDR *) pNdr->GetChild(), i++ )
            {
            Buffer.Set( "_length_" );
            Buffer.Append( pParamName );
            Buffer.Append( "[" );
            Buffer.Append( i );
            Buffer.Append( "] = " );

            pStream->Write( Buffer );

            switch ( pNdr->GetCGID() )
                {
                case ID_CG_VAR_ARRAY :
                    pLengthIsExpr = ((CG_VARYING_ARRAY *)pNdr)->
                        GetLengthIsExpr();
                    break;
                case ID_CG_CONF_VAR_ARRAY :
                    pLengthIsExpr = ((CG_CONFORMANT_VARYING_ARRAY *)pNdr)->
                        GetLengthIsExpr();
                    break;
                case ID_CG_CONF_STRING_ARRAY :
                case ID_CG_STRING_ARRAY :
                    pLengthIsExpr = 0;
                    break;
                case ID_CG_SIZE_LENGTH_PTR :
                    pLengthIsExpr = ((CG_SIZE_LENGTH_POINTER *)pNdr)->
                        GetLengthIsExpr();
                    break;
                }

            if ( pLengthIsExpr )
                pLengthIsExpr->Print( pStream );
            else
                pStream->Write( '0' );

            pStream->Write( ';' );
            pStream->NewLine();
            }
        }
}

void
Out_CheckUnMarshallPastBufferEnd(
    CCB *   pCCB,
    ulong   size )
    {
/*
    This method will be called only within the try-except of
    unmarshalling on the server side.

    Generate an expression of the form:
        if( (StubMessage.pBuffer + size) > StubMessage.BufferEnd )
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
*/

    expr_node  *   pBufferExpr     =
                         new expr_variable( STUB_MSG_BUFFER_VAR_NAME , 0);

    if ( 0 != size )
        {
        pBufferExpr = new expr_op_binary( 
                            OP_PLUS,
                            pBufferExpr,
                            new expr_constant( size ) );
        }

    expr_node  *   pBufferEndExpr  =
                         new expr_variable( STUB_MSG_BUFFER_END_VAR_NAME, 0);
    expr_node  *   pExpr           = new expr_relational( OP_GREATER,
                                                            pBufferExpr,
                                                            pBufferEndExpr );

    Out_If( pCCB, pExpr );
    Out_RaiseException( pCCB, "RPC_X_BAD_STUB_DATA" );
    Out_Endif( pCCB );
    }


void
Out_TypePicklingInfo(
    CCB *   pCCB )
{
    ISTREAM     *   pStream;
    MIDL_TYPE_PICKLING_FLAGS   Flags;
    unsigned long             &intFlags = * (unsigned long *) &Flags;
             
    static const char  *pFlagNames[] = 
                        {
                         "Oicf "
                        ,"NewCorrDesc "
                        };
                        
    pStream = pCCB->GetStream();

    if ( pCommand->NeedsNDR64Run() )
        {
        pStream->WriteOnNewLine( 
                    "extern unsigned long * TypePicklingOffsetTable[]; " );
        pStream->NewLine();
        }

    pStream->WriteOnNewLine("static " MIDL_TYPE_PICKLING_INFO_NAME
                                          " " PICKLING_INFO_STRUCT_NAME " =");
    pStream->IndentInc();
    pStream->WriteOnNewLine( "{" );
    
    pStream->NewLine();
    pStream->WriteNumber( "0x%x, /* Signature & version: TP 1 */", 0x33205054 );

    intFlags = 0;

    MIDL_ASSERT( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER_V2 ); 
    Flags.Oicf = 1;

    if ( pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
        Flags.HasNewCorrDesc = 1;

    pStream->NewLine();
    pStream->WriteNumber( "0x%x,", intFlags );
    if ( 0 != intFlags )
        {
        pStream->Write( " /* Flags: " );
        for ( int i = 0; i < sizeof(pFlagNames)/sizeof(char*); i++ )
            {
            if ( intFlags & ( 1 << i ) )
                pStream->Write( pFlagNames[i] );
            }
        pStream->Write( "*/" );
        }
 
    pStream->WriteOnNewLine( "0," );
    pStream->WriteOnNewLine( "0," );
    pStream->WriteOnNewLine( "0," );

    pStream->WriteOnNewLine( "};" );
    pStream->IndentDec();

    pStream->NewLine();
}

void                Out_PartialIgnoreClientBufferSize( CCB *pCCB, char *pParamName );

void
Out_PartialIgnoreClientMarshall( 
    CCB *pCCB,
    char *pParamName )
{
    ISTREAM     *pStream = pCCB->GetStream();
    unsigned short Spaces = sizeof("NdrPartialIgnoreClientMarshall( ")-1;

    pStream->WriteOnNewLine( "NdrPartialIgnoreClientMarshall( (PMIDL_STUB_MESSAGE) &" 
                             STUB_MESSAGE_VAR_NAME "," );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( pParamName );
    pStream->Write( " ); " );
    pStream->NewLine();

}

void 
Out_PartialIgnoreServerUnmarshall(
    CCB *pCCB,
    char *pParamName )
{
    ISTREAM     *pStream = pCCB->GetStream();
    unsigned short Spaces = sizeof("NdrPartialIgnoreServerUnmarshall( ")-1;

    pStream->WriteOnNewLine( "NdrPartialIgnoreServerUnmarshall( (PMIDL_STUB_MESSAGE) &" 
                             STUB_MESSAGE_VAR_NAME ", " );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( "&" );
    pStream->Write( pParamName );
    pStream->Write( " ); " );
    pStream->NewLine();
}

void 
Out_PartialIgnoreClientBufferSize( 
    CCB *pCCB,
    char *pParamName )
{
    ISTREAM     *pStream = pCCB->GetStream();
    unsigned short Spaces = sizeof("NdrPartialIgnoreClientBufferSize( ")-1;

    pStream->WriteOnNewLine( "NdrPartialIgnoreClientBufferSize( (PMIDL_STUB_MESSAGE) &" 
                             STUB_MESSAGE_VAR_NAME ", " );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( pParamName );
    pStream->Write( " ); " );
    pStream->NewLine();

}

void                
Out_PartialIgnoreServerInitialize( 
    CCB *pCCB, 
    char *pParamName, 
    long FormatStringOffset )
{

    ISTREAM     *pStream = pCCB->GetStream();
    char Buffer[256];
    unsigned short Spaces = sizeof("NdrPartialIgnoreServerInitialize( ")-1;

    pStream->WriteOnNewLine( "NdrPartialIgnoreServerInitialize( (PMIDL_STUB_MESSAGE) &" 
                             STUB_MESSAGE_VAR_NAME ", " );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( "&" );
    pStream->Write( pParamName );
    pStream->Write( ", " );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    sprintf( Buffer, "(PFORMAT_STRING) &" FORMAT_STRING_STRUCT_NAME ".Format[%d] );", 
             FormatStringOffset );
    pStream->Write( Buffer );
    pStream->NewLine();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\output1.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

	output.cxx

 Abstract:

	Low level output routines for midl.

 Notes:


 History:

 	Sep-18-1993		VibhasC		Created.

 ----------------------------------------------------------------------------*/

 #pragma warning ( disable : 4127 )

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop
#if 0
							Notes

	A few general rules followed throughout the file.

		1. Never emit tab other than thru the stream.
		2. Never emit a new line other than thru the stream.
		3. Emitting a new line is the responsibility of the entity that wants
		   itself to be emitted on a new line. Therefore, say each local
		   variable in the stub needs to be on a new line, then the routine
		   responsible for emitting the local variable will be responsible
		   for setting the new line.

#endif // 0

/****************************************************************************
 *	local definitions
 ***************************************************************************/

#define NDR_UP_DECISION_RTN_NAME		"NdrSH_UPDecision"
#define NDR_TLUP_DECISION_RTN_NAME		"NdrSH_TLUPDecision"
#define NDR_TLUP_DECISION_RTN_B_ONLY	"NdrSH_TLUPDecisionBuffer"
#define NDR_IF_ALLOC_RTN_NAME			"NdrSH_IfAlloc"
#define NDR_IF_ALLOC_REF_RTN_NAME		"NdrSH_IfAllocRef"
#define NDR_IF_ALLOC_COPY_RTN_NAME		"NdrSH_IfAllocCopy"
#define NDR_IF_ALLOC_SET_RTN_NAME		"NdrSH_IfAllocSet"
#define NDR_IF_COPY_RTN_NAME			"NdrSH_IfCopy"
#define NDR_COPY_RTN_NAME				"NdrSH_Copy"
#define NDR_CONF_STRING_HDR_MARSHALL	"NdrSH_MarshConfStringHdr"
#define NDR_CONF_STRING_HDR_UNMARSHALL	"NdrSH_UnMarshConfStringHdr"
#define NDR_C_CTXT_HDL_MARSHALL			"NdrSH_MarshCCtxtHdl"
#define NDR_C_CTXT_HDL_UNMARSHALL		"NdrSH_UnMarshCCtxtHdl"
#define NDR_S_CTXT_HDL_MARSHALL			"NdrSH_MarshSCtxtHdl"
#define NDR_S_CTXT_HDL_UNMARSHALL		"NdrSH_UnMarshSCtxtHdl"
#define NDR_IF_FREE_RTN_NAME			"NdrSH_IfFree"
#define NDR_CONF_STR_M_RTN_NAME			"NdrSH_ConfStringMarshall"
#define NDR_CONF_STR_UN_RTN_NAME		"NdrSH_ConfStringUnMarshall"
#define NDR_MAP_COMM_FAULT_RTN_NAME		"NdrMapCommAndFaultStatus"

/****************************************************************************
 *	local data
 ***************************************************************************/
/****************************************************************************
 *	externs
 ***************************************************************************/
void
Out_UPDecision(
	CCB			*	pCCB,
	expr_node	*	pPtrInBuffer,
	expr_node	*	pPtrInMemory )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_UP_DECISION_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );

	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));
	pPtrInBuffer = MakeRefExprOutOfDeref( pPtrInBuffer );
	pProc->SetParam( new expr_param( pPtrInBuffer ) );
	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar(pPtrInMemory) ) );

	Out_If( pCCB, pProc );
	}

void
Out_TLUPDecision(
	CCB			*	pCCB,
	expr_node	*	,
	expr_node	*	pPtrInMemory )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_TLUP_DECISION_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );

	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ) );
	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar( pPtrInMemory) ) );

	Out_If( pCCB, pProc );
	}

void
Out_TLUPDecisionBufferOnly(
	CCB			*	pCCB,
	expr_node	*	,
	expr_node	*	pPtrInMemory )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_TLUP_DECISION_RTN_B_ONLY );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );

	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ) );
	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar( pPtrInMemory ) ) );

	Out_If( pCCB, pProc );
	}

void
Out_IfAlloc(
	CCB			*	pCCB,
	expr_node	*	pPtrInMemory,
	expr_node	*	,
	expr_node	*	pExprCount )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_IF_ALLOC_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));

	pPtrInMemory = MakeAddressExpressionNoMatterWhat( pPtrInMemory );
	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar( pPtrInMemory ) ));
	pProc->SetParam( new expr_param( pExprCount ));
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_If_IfAlloc(
	CCB			*	pCCB,
	expr_node	*	pPtrInMemory,
	expr_node	*	,
	expr_node	*	pExprCount )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_IF_ALLOC_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));

	pPtrInMemory = MakeAddressExpressionNoMatterWhat( pPtrInMemory );
	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar( pPtrInMemory ) ));
	pProc->SetParam( new expr_param( pExprCount ));
	pCCB->GetStream()->NewLine();
	Out_If( pCCB, pProc );
	// pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_If_IfAllocRef(
	CCB			*	pCCB,
	expr_node	*	pPtrInMemory,
	expr_node	*	,
	expr_node	*	pExprCount )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_IF_ALLOC_REF_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));

	pPtrInMemory = MakeAddressExpressionNoMatterWhat( pPtrInMemory );
	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar( pPtrInMemory ) ));
	pProc->SetParam( new expr_param( pExprCount ));
	pCCB->GetStream()->NewLine();
	Out_If( pCCB, pProc );
	// pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_Alloc(
	CCB			*	pCCB,
	expr_node	*	pPtrInMemory,
	expr_node	*	,
	expr_node	*	pExprCount )
	{
	expr_proc_call	*	pProc;
	expr_node	*	pExpr;

	if( pCCB->MustCheckAllocationError() )
		{
		expr_node		*	pStubMsg
				= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
		pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
		pProc	= new expr_proc_call( ENGINE_CHECKED_ALLOC_RTN_NAME );
		pProc->SetParam( new expr_param( pStubMsg ) );
		}
	else
		pProc	= new expr_proc_call( STUB_MSG_ALLOCATE_RTN_NAME );
		
	pProc->SetParam( new expr_param( pExprCount ));
	pExpr = new expr_assign( pPtrInMemory, pProc );
	pCCB->GetStream()->NewLine();
	pExpr->PrintCall( pCCB->GetStream(), 0, 0 );
	}
void
Out_IfAllocSet(
	CCB			*	pCCB,
	expr_node	*	pPtrInMemory,
	expr_node	*	,
	expr_node	*	pExprCount )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_IF_ALLOC_SET_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));

	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar( pPtrInMemory )));
	pProc->SetParam( new expr_param( pExprCount ));
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_AllocSet(
	CCB			*	pCCB,
	expr_node	*	pPtrInMemory,
	expr_node	*	pBuffer,
	expr_node	*	pExprCount )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( MIDL_MEMSET_RTN_NAME );
	expr_node		*	pExpr;
	Out_Alloc( pCCB, pPtrInMemory, pBuffer, pExprCount );

	pExpr	= new expr_u_deref( pPtrInMemory );
	pProc->SetParam( new expr_param( pExpr ) );
	pProc->SetParam( new expr_param( pExprCount ) );
	pProc->SetParam( new expr_param( new expr_constant(0L) ) );
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_IfCopy(
	CCB			*	pCCB,
	expr_node	*	pPtrInMemory,
	expr_node	*	,
	expr_node	*	pExprCount )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_IF_COPY_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );

	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));

	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar( pPtrInMemory ) ));
	pProc->SetParam( new expr_param( pExprCount ));
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_IfAllocCopy(
	CCB			*	pCCB,
	expr_node	*	pPtrInMemory,
	expr_node	*	,
	expr_node	*	pExprCount )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_IF_ALLOC_COPY_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );

	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));

	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar( pPtrInMemory )));
	pProc->SetParam( new expr_param( pExprCount ));
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_Copy(
	CCB		*	pCCB,
	expr_node	*	pDest,
	expr_node	*	pSource,
	expr_node	*	pExprCount,
	expr_node	*	pAssign )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_COPY_RTN_NAME );

	pProc->SetParam( new expr_param( pDest ));
	pProc->SetParam( new expr_param( pSource ));
	pProc->SetParam( new expr_param( pExprCount ));
	pCCB->GetStream()->NewLine();

	if( pAssign )
		{
		Out_PlusEquals( pCCB, pAssign, pProc );
		}
	else
		{
		pProc->PrintCall( pCCB->GetStream(), 0, 0 );
		}
	}
void
Out_IfFree(
	CCB		*	pCCB,
	expr_node	*	pSrc )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_IF_FREE_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ) );
	pProc->SetParam( new expr_param( MakeCastExprPtrToUChar( pSrc ) ) );
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_ConfStringHdr(
	CCB			*	pCCB,
	expr_node	*	pDest,
	expr_node	*	pSize,
	expr_node	*	pLength,
	BOOL			fMarsh )
	{
	PNAME	pName;

	if( fMarsh == TRUE )
		{
		pName	= NDR_CONF_STRING_HDR_MARSHALL;
		}
	else
		pName	= NDR_CONF_STRING_HDR_UNMARSHALL;

	expr_proc_call	*	pProc	= new expr_proc_call( pName );
	pProc->SetParam( new expr_param( pDest ) );
	pProc->SetParam( new expr_param( pSize ) );
	pProc->SetParam( new expr_param( pLength ) );

	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}
void
Out_CContextMarshall(
	CCB		*	pCCB,
	expr_node	*	pDest,
	expr_node	*	pSource )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_C_CTXT_HDL_MARSHALL );
	expr_node	*	pExpr;

	pProc->SetParam( new expr_param( pSource ) );
	pProc->SetParam( new expr_param( pDest ) );
	pExpr	= new expr_assign( pDest, pProc );
	pCCB->GetStream()->NewLine();
	pExpr->PrintCall( pCCB->GetStream(), 0, 0 );
	}
void
Out_SContextMarshall(
	CCB			*	pCCB,
	expr_node	*	pDest,
	expr_node	*	pSource,
	expr_node	*	pRDRtn )
	{
	expr_proc_call	* pProc	= new expr_proc_call( NDR_S_CTXT_HDL_MARSHALL );
	expr_node	*	pExpr;

	pProc->SetParam( new expr_param( pSource ) );
	pProc->SetParam( new expr_param( pDest ) );
	pProc->SetParam( new expr_param( pRDRtn ) );
	pExpr	= new expr_assign( pDest, pProc );
	pCCB->GetStream()->NewLine();
	pExpr->PrintCall( pCCB->GetStream(), 0, 0 );
	}
void
Out_CContextUnMarshall(
	CCB			*	pCCB,
	expr_node	*	pDest,
	expr_node	*	pSource,
	expr_node	*	pHandle,
	expr_node	*	pDRep )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_C_CTXT_HDL_UNMARSHALL );
	expr_node		*	pExpr;

	pProc->SetParam( new expr_param( pDest ) );
	pProc->SetParam( new expr_param( pHandle ) );
	pProc->SetParam( new expr_param( pSource ) );
	pProc->SetParam( new expr_param( pDRep ) );

	pExpr	= new expr_assign( pSource, pProc );
	pCCB->GetStream()->NewLine();
	pExpr->PrintCall( pCCB->GetStream(), 0, 0 );
	}
void
Out_SContextUnMarshall(
	CCB			*	pCCB,
	expr_node	*	pDest,
	expr_node	*	pSource,
	expr_node	*	pDRep )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_S_CTXT_HDL_UNMARSHALL );
	expr_node		*	pExpr;

	pProc->SetParam( new expr_param( pSource ) );
	pProc->SetParam( new expr_param( pDRep ) );
	pExpr	= new expr_assign( pDest, pProc );
	pCCB->GetStream()->NewLine();
	pExpr->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_RaiseException(
	CCB			*	pCCB,
	PNAME			pExceptionName)
	{
	expr_proc_call	*	pProc	= new expr_proc_call( "RpcRaiseException" );
	
	pProc->SetParam( new expr_param( new expr_variable( pExceptionName ) ) );
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}
void
Out_RpcTryFinally(
	CCB		*	pCCB )
	{
	ISTREAM		*	pStream	= pCCB->GetStream();

	pStream->NewLine();
	pStream->Write( "RpcTryFinally" );
	pStream->IndentInc();
	pStream->NewLine();
	pStream->Write( '{' );
	}
void
Out_RpcFinally(
	CCB		*	pCCB )
	{
	ISTREAM		*	pStream	= pCCB->GetStream();

	pStream->NewLine();
	pStream->Write( '}' );
	pStream->IndentDec();
	pStream->NewLine();
	pStream->Write( "RpcFinally" );
	pStream->IndentInc();
	pStream->NewLine();
	pStream->Write('{');
	}
void
Out_RpcEndFinally(
	CCB		*	pCCB )
	{
	ISTREAM		*	pStream	= pCCB->GetStream();

	pStream->NewLine();
	pStream->Write( '}' );
	pStream->IndentDec();
	pStream->NewLine();
	pStream->Write( "RpcEndFinally" );
	pStream->NewLine();
	}
void
Out_RpcTryExcept( CCB * pCCB )
	{
	ISTREAM * pStream = pCCB->GetStream();
	pStream->NewLine();
	pStream->Write( "RpcTryExcept" );
	pStream->IndentInc();
	pStream->NewLine();
	pStream->Write( '{' );
	}

void
Out_RpcExcept(
    CCB * pCCB,
    char * pFilterString )
{
    ISTREAM	*	pStream	= pCCB->GetStream();
    pStream->NewLine();
    pStream->Write('}');
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( "RpcExcept( " );
    pStream->Write( pFilterString );
    pStream->Write( " )" );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( '{' );
}

void
Out_RpcEndExcept( CCB * pCCB )
	{
	ISTREAM	*	pStream	= pCCB->GetStream();
	pStream->NewLine();
	pStream->Write( '}' );
	pStream->IndentDec();
	pStream->NewLine();
	pStream->Write( "RpcEndExcept" );
	}
void
Out_CallNdrMapCommAndFaultStatus(
	 CCB * pCCB,
	expr_node * pAddrOfStubMsg,
	expr_node * StatRes,
	expr_node * pCommExpr,
	expr_node * pFaultExpr )
	{
	node_skl	*	pType;
	expr_proc_call * pProc = new expr_proc_call( NDR_MAP_COMM_FAULT_RTN_NAME );
	expr_node * pExpr;
	expr_variable * pExceptionCode = new expr_variable( "RpcExceptionCode()",0);


	pAddrOfStubMsg = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME,
									 				 pAddrOfStubMsg );


	GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );

	pCommExpr = MakeExpressionOfCastPtrToType( pType, pCommExpr );
	pFaultExpr = MakeExpressionOfCastPtrToType( pType, pFaultExpr );

	pProc->SetParam( new expr_param( pAddrOfStubMsg ));
	pProc->SetParam( new expr_param( pCommExpr ));
	pProc->SetParam( new expr_param( pFaultExpr ));
	pProc->SetParam( new expr_param( pExceptionCode ));
	pExpr = new expr_assign( StatRes, pProc );

	Out_If( pCCB, pExpr );
	Out_RaiseException( pCCB, ((RESOURCE * )StatRes)->GetResourceName() );
	Out_Endif(pCCB);
	}
void
Out_CallToXmit(
	CCB	*	pCCB,
	PNAME	XmittedTypeName,
	expr_node * pPresented,
	expr_node * pTransmitted )
	{
	ISTREAM	*	pStream	= pCCB->GetStream();
	char 	*	p	= new char [strlen( XmittedTypeName )+10+1];

	strcpy( p, XmittedTypeName );
	strcat( p, "_to_xmit" );
	expr_proc_call	*	pProc = new expr_proc_call( p );
	pProc->SetParam( new expr_param( pPresented ) );
	pProc->SetParam( new expr_param(
						 MakeAddressExpressionNoMatterWhat( pTransmitted ) ));

	pStream->NewLine();
	pProc->PrintCall( pStream, 0, 0 );
	}

void
Out_CallFromXmit(
	CCB	*	pCCB,
	PNAME	XmittedTypeName,
	expr_node * pPresented,
	expr_node * pTransmitted )
	{
	ISTREAM	*	pStream	= pCCB->GetStream();
	char 	*	p	= new char [strlen( XmittedTypeName )+10+1];

	strcpy( p, XmittedTypeName );
	strcat( p, "_from_xmit" );
	expr_proc_call	*	pProc = new expr_proc_call( p );
	pProc->SetParam( new expr_param( pTransmitted ));
	pProc->SetParam( new expr_param( pPresented ) );

	pStream->NewLine();
	pProc->PrintCall( pStream, 0, 0 );
	}
void
Out_CallFreeXmit(
	CCB		*	pCCB,
	PNAME		XmittedTypeName,
	expr_node * pTransmitted )
	{
	ISTREAM	*	pStream	= pCCB->GetStream();
	char 	*	p	= new char [strlen( XmittedTypeName )+15+1];

	strcpy( p, XmittedTypeName );
	strcat( p, "_free_xmit" );
	expr_proc_call * pProc = new expr_proc_call( p );

	pProc->SetParam( new expr_param( pTransmitted ) );

	pStream->NewLine();
	pProc->PrintCall( pStream, 0, 0 );
	}
void
Out_CallFreeInst(
	CCB		*	pCCB,
	PNAME		XmittedTypeName,
	expr_node *	pPresented )
	{
	ISTREAM	*	pStream	= pCCB->GetStream();
	char 	*	p	= new char [strlen( XmittedTypeName )+15+1];

	strcpy( p, XmittedTypeName );
	strcat( p, "_free_inst" );
	expr_proc_call * pProc = new expr_proc_call( p );

	pProc->SetParam( new expr_param( pPresented ) );

	pStream->NewLine();
	pProc->PrintCall( pStream, 0, 0 );
	}

void
Out_StringMarshall(
	CCB			*	pCCB,
	expr_node	*	pMemory,
	expr_node	*	pCount,
	expr_node	*	pSize )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_CONF_STR_M_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
	ISTREAM			*	pStream = pCCB->GetStream();

	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));
	pProc->SetParam( new expr_param( MakeCastExprPtrToUChar( pMemory ) ) );
	pProc->SetParam( new expr_param( pCount ) );
	pProc->SetParam( new expr_param( pSize ) );
	pStream->NewLine();
	pProc->PrintCall( pStream, 0, 0 );
	}
void
Out_StringUnMarshall(
	CCB			*	pCCB,
	expr_node	*	pMemory,
	expr_node	*	pSize )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_CONF_STR_UN_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
	ISTREAM			*	pStream = pCCB->GetStream();

	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));
	pProc->SetParam( new expr_param( MakeAddressExpressionNoMatterWhat( MakeCastExprPtrToPtrToUChar( pMemory ) )) );
	pProc->SetParam( new expr_param( pSize ) );
	pStream->NewLine();
	pProc->PrintCall( pStream, 0, 0 );
	}

char *
MakeRtnName(
	char * pBuffer, // if 0 it means allocate anew buffer and return.
	char * pName,
	int Code )
	{
	char * p;

	switch( Code )
		{
		case NC_SIZE_RTN_NAME: p = "Sizing"; break;
		case NC_MARSHALL_RTN_NAME: p = "Marshall"; break;
		case NC_UNMARSHALL_RTN_NAME: p = "UnMarshall"; break;
		case NC_MEMSIZE_RTN_NAME: p = "MemSize"; break;
		case NC_FREE_RTN_NAME: p = "Free"; break;
		}

	if( !pBuffer )
		{
		pBuffer = new char[ strlen( pName ) +		// name of structure
							1 +						// underscore.
							strlen( p ) 	+		// name of rtn
							1						// 0 terminator.
						  ];
		}

	sprintf( pBuffer, "%s_%s", pName, p );

	return pBuffer;
	}

void
Out_TypeAlignSizePrototypes(
    CCB *   pCCB,
    ITERATOR&   I )
{
    TYPE_ENCODE_INFO    *p;
    ISTREAM *   pStream = pCCB->GetStream();

    // The iterator items are really a set of name pointers.

    pStream->NewLine();
    while( ITERATOR_GETNEXT( I, p ) )
        {
        GenStdMesPrototype(
                         pCCB,
                         p->pName,
                         TYPE_ALIGN_SIZE_CODE,
                         (p->Flags == TYPE_ENCODE_WITH_IMPL_HANDLE));

        pStream->Write(';');
        pStream->NewLine();
        }

}
void
Out_TypeEncodePrototypes(
    CCB *   pCCB,
    ITERATOR&   I )
{
    TYPE_ENCODE_INFO    *p;
    ISTREAM *   pStream = pCCB->GetStream();

    // The iterator items are really a set of name pointers.

    pStream->NewLine();
    while( ITERATOR_GETNEXT( I, p ) )
        {
        GenStdMesPrototype(
                         pCCB,
                         p->pName,
                         TYPE_ENCODE_CODE,
                         (p->Flags == TYPE_ENCODE_WITH_IMPL_HANDLE));
        pStream->Write(';');
        pStream->NewLine();
        }

}
void
Out_TypeDecodePrototypes(
    CCB *   pCCB,
    ITERATOR&   I )
{
    TYPE_ENCODE_INFO    *p;
    ISTREAM *   pStream = pCCB->GetStream();

    // The iterator items are really a set of name pointers.

    pStream->NewLine();
    while( ITERATOR_GETNEXT( I, p ) )
        {
        GenStdMesPrototype(
                         pCCB,
                         p->pName,
                         TYPE_DECODE_CODE,
                         (p->Flags == TYPE_ENCODE_WITH_IMPL_HANDLE));
        pStream->Write(';');
        pStream->NewLine();
        }
}


void
Out_TypeFreePrototypes(
    CCB *   pCCB,
    ITERATOR&   I )
{
    // Freeing is not supported for the v1 interpreter

    if ( ! ( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER_V2 ) )
        return;

    TYPE_ENCODE_INFO    *p;
    ISTREAM *   pStream = pCCB->GetStream();

    // The iterator items are really a set of name pointers.

    pStream->NewLine();
    while( ITERATOR_GETNEXT( I, p ) )
        {
        GenStdMesPrototype(
                         pCCB,
                         p->pName,
                         TYPE_FREE_CODE,
                         (p->Flags == TYPE_ENCODE_WITH_IMPL_HANDLE));
        pStream->Write(';');
        pStream->NewLine();
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\paddict.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
    
    paddict.cxx

 Abstract:

    Implement a counted dictionary class.

    Implements a dictionary for handling padding expressions for unknown
    represent as data types.

    Implements a dictionary for handling sizing macro for unknown
    represent as data types.

    Implements Quintuple dictionary for registering all type names for both
    transmit_as and represent_as.

    Implements Quadruple dictionary for handling usr_marshal.

 Notes:


 History:

     Jan 25, 1994        RyszardK        Created

 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

#include "typecls.hxx"

/////////////////////////////////////////////////////////////////////////////
//
//  CountedDictionary class.
//
/////////////////////////////////////////////////////////////////////////////

unsigned short
CountedDictionary::GetListOfItems(
    ITERATOR&    ListIter )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

     Get a list of dict items into the specified iterator.

 Arguments:
    
    ListIter    - A reference to the iterator class where the list is
                  accumulated.

 Return Value:
    
    A count of the number of dictionary elements.

 Notes:

----------------------------------------------------------------------------*/
{
    Dict_Status     Status;
    void *          pR;
    short           Count = 0;
    
    //
    // Get to the top of the dictionary.
    //

    Status = Dict_Next( (pUserType) 0 );

    //
    // Iterate till the entire dictionary is done.
    //

    while( SUCCESS == Status )
        {
        pR = Dict_Curr_Item();
        ITERATOR_INSERT( ListIter, pR );
        Count++;
        Status = Dict_Next( pR );
        }

    return Count;
}

void *
CountedDictionary::GetFirst()
{
    Dict_Status     Status;
    void *          pFirst = 0;

    Status = Dict_Next( 0 );

    if ( Status == SUCCESS )
        pFirst = Dict_Curr_Item();

    return( pFirst );
}

void *
CountedDictionary::GetNext()
{
    Dict_Status     Status;
    void            *pCurr, *pNext = 0;

    pCurr = Dict_Curr_Item();

    if ( pCurr )
        {
        Status = Dict_Next( pCurr );
        if ( Status == SUCCESS )
            pNext = Dict_Curr_Item();
        }

    return( pNext );
}


SSIZE_T
CountedDictionary::Compare(
    pUserType   pE1,
    pUserType   pE2
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

     Compare two Counted types. Defaults to string comparison.

 Arguments:

 Return Value:
    
----------------------------------------------------------------------------*/
{
    return( strcmp( (char *)pE1, (char *)pE2) );
}

//===========================================================================


void 
RepAsPadExprDict::Register(
    unsigned long   Offset,
    node_skl *      pStructType,
    char *          pFieldName,
    node_skl *      pPrevFieldType
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    Adds a padding expression description to the dictionary

Arguments:

    Offset          - offset of the padding field
    pPaddingExpr    - text of the expression to be printed out
    
----------------------------------------------------------------------------*/
{
    Dict_Status    Status;

    REP_AS_PAD_EXPR_DESC * pOldEntry;
    REP_AS_PAD_EXPR_DESC * pEntry = new REP_AS_PAD_EXPR_DESC;

    pEntry->KeyOffset = Offset;
    pEntry->pStructType = pStructType;
    pEntry->pFieldName =  pFieldName;
    pEntry->pPrevFieldType =  pPrevFieldType;

    Status    = Dict_Find( pEntry );

    switch( Status )
        {
        case EMPTY_DICTIONARY:
        case ITEM_NOT_FOUND:

            Dict_Insert( pEntry );
            EntryCount++;
            break;

        default:
            // The only reason for an entry (offset) to be used already
            // would be that the otimization has shrunk the format string.
            // This means that the old entry should be deleted.

            pOldEntry = (REP_AS_PAD_EXPR_DESC *)Dict_Curr_Item();

            Dict_Delete( (pUserType *) &pOldEntry );
            Dict_Insert( pEntry );
            break;
        }
    return;
}


SSIZE_T
RepAsPadExprDict::Compare(
    pUserType   pE1,
    pUserType   pE2
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

     Compare pad expr descriptors.
     KeyOffset is the key that orders the entries.

 Arguments:

 Return Value:
    
----------------------------------------------------------------------------*/
{
    if( ((REP_AS_PAD_EXPR_DESC *)pE1)->KeyOffset <
                                ((REP_AS_PAD_EXPR_DESC *)pE2)->KeyOffset )
        return( -1 );
    else
    if( ((REP_AS_PAD_EXPR_DESC *)pE1)->KeyOffset >
                                ((REP_AS_PAD_EXPR_DESC *)pE2)->KeyOffset )
        return( 1 );
    else
        return( 0 );
}

REP_AS_PAD_EXPR_DESC *
RepAsPadExprDict::GetFirst()
{
    Dict_Status             Status;
    REP_AS_PAD_EXPR_DESC *  pFirst = 0;

    Status = Dict_Next( 0 );

    if ( Status == SUCCESS )
        pFirst = (REP_AS_PAD_EXPR_DESC *)Dict_Curr_Item();

    return( pFirst );
}

REP_AS_PAD_EXPR_DESC *
RepAsPadExprDict::GetNext()
{
    Dict_Status             Status;
    REP_AS_PAD_EXPR_DESC    *pCurr, *pNext = 0;

    pCurr = (REP_AS_PAD_EXPR_DESC *)Dict_Curr_Item();

    if ( pCurr )
        {
        Status = Dict_Next( pCurr );
        if ( Status == SUCCESS )
            pNext = (REP_AS_PAD_EXPR_DESC *)Dict_Curr_Item();
        }

    return( pNext );
}

void
RepAsPadExprDict::WriteCurrentPadDesc(
    ISTREAM * pStream
    )
/*++

Routine description:

    Writes out the following string:

        (unsigned char)(NdrFieldPad(pSN,pFN,pPFN,pPFT))

Arguments:

    pStream -   stream to write to.

--*/
{
    REP_AS_PAD_EXPR_DESC    *pCurr = (REP_AS_PAD_EXPR_DESC *)Dict_Curr_Item();

    if ( pCurr  &&  pCurr->pPrevFieldType )
        {
        pStream->Write( "(unsigned char)("FC_FIELD_PAD_MACRO"(" );
        pCurr->pStructType->PrintType( PRT_TYPE_SPECIFIER, pStream );
        pStream->Write( ',' );
        pStream->Write( pCurr->pFieldName );
        pStream->Write( ',' );
        pStream->Write( pCurr->pPrevFieldType->GetSymName() );
        pStream->Write( ',' );
        pCurr->pPrevFieldType->GetChild()->
                                PrintType( PRT_TYPE_SPECIFIER, pStream );
        pStream->Write( "))," );
        }
    else
        pStream->Write( "0," );
}


//========================================================================


void 
RepAsSizeDict::Register(
    unsigned long   Offset,
    char *          pTypeName
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    Adds a sizing macro description to the dictionary

Arguments:

    Offset          - offset of the padding field
    pPaddingExpr    - text of the expression to be printed out
    
----------------------------------------------------------------------------*/
{
    Dict_Status    Status;

    REP_AS_SIZE_DESC * pOldEntry;
    REP_AS_SIZE_DESC * pEntry = new REP_AS_SIZE_DESC;

    pEntry->KeyOffset = Offset;
    pEntry->pTypeName =  pTypeName;

    Status    = Dict_Find( pEntry );

    switch( Status )
        {
        case EMPTY_DICTIONARY:
        case ITEM_NOT_FOUND:

            Dict_Insert( pEntry );
            EntryCount++;
            break;

        default:
            // The only reason for an entry (offset) to be used already
            // would be that the otimization has shrunk the format string.
            // This means that the old entry should be deleted.

            pOldEntry = (REP_AS_SIZE_DESC *)Dict_Curr_Item();

            Dict_Delete( (pUserType *) &pOldEntry );
            Dict_Insert( pEntry );
            break;
        }
    return;
}


SSIZE_T
RepAsSizeDict::Compare(
    pUserType   pE1,
    pUserType   pE2
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

     Compare size descriptors.
     KeyOffset is the key that orders the entries.

 Arguments:

 Return Value:
    
----------------------------------------------------------------------------*/
{
    if( ((REP_AS_SIZE_DESC *)pE1)->KeyOffset <
                                ((REP_AS_SIZE_DESC *)pE2)->KeyOffset )
        return( -1 );
    else
    if( ((REP_AS_SIZE_DESC *)pE1)->KeyOffset >
                                ((REP_AS_SIZE_DESC *)pE2)->KeyOffset )
        return( 1 );
    else
        return( 0 );
}

REP_AS_SIZE_DESC *
RepAsSizeDict::GetFirst()
{
    Dict_Status         Status;
    REP_AS_SIZE_DESC *  pFirst = 0;

    Status = Dict_Next( 0 );

    if ( Status == SUCCESS )
        pFirst = (REP_AS_SIZE_DESC *)Dict_Curr_Item();

    return( pFirst );
}

REP_AS_SIZE_DESC *
RepAsSizeDict::GetNext()
{
    Dict_Status         Status;
    REP_AS_SIZE_DESC    *pCurr, *pNext = 0;

    pCurr = (REP_AS_SIZE_DESC *)Dict_Curr_Item();

    if ( pCurr )
        {
        Status = Dict_Next( pCurr );
        if ( Status == SUCCESS )
            pNext = (REP_AS_SIZE_DESC *)Dict_Curr_Item();
        }

    return( pNext );
}

void
RepAsSizeDict::WriteCurrentSizeDesc(
    ISTREAM * pStream
    )
/*++

Routine description:

    Writes out the following string:

        NdrFcShort( sizeof(<type>) 

Arguments:

    pStream -   stream to write to.

--*/
{
    REP_AS_SIZE_DESC    *pCurr = (REP_AS_SIZE_DESC *)Dict_Curr_Item();

    if ( pCurr )
        {
        pStream->Write( "NdrFcShort( sizeof(" );
        pStream->Write( pCurr->pTypeName );
        pStream->Write( "))," );
        }
    else
        pStream->Write( "0," );
}


//========================================================================


BOOL 
QuintupleDict::Add(
    void *          pContext
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    Adds a Quintuple description to the dictionary.

Arguments:

Returns:

    TRUE    - when a new entry has been registered,
    FALSE   - otherwise

    Index field gets set to appropriate index.

    
----------------------------------------------------------------------------*/
{
    Dict_Status         Status;
    XMIT_AS_CONTEXT  *  pEntry = (XMIT_AS_CONTEXT *) pContext;

    Status = Dict_Find( pEntry );

    if( Status == EMPTY_DICTIONARY  ||  Status == ITEM_NOT_FOUND )
        {
        pEntry->Index = CurrentIndex;
        Dict_Insert( pEntry );
        CurrentIndex++;
        return TRUE;
        }
    else
        {
        pEntry->Index = ((XMIT_AS_CONTEXT *)Dict_Curr_Item())->Index;
        return FALSE;
        }
}


SSIZE_T
QuintupleDict::Compare(
    pUserType   pE1,
    pUserType   pE2
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

     Compare two quintuple types.
     Both fXmit and the name have to match.

     fXmit allows for comparing xmit_as with xmit_as and rep_as with rep_as.
     For xmit_as we compare the presented types.
     For rep_as we compare the wire types (not the local types).

 Arguments:

 Return Value:
    
----------------------------------------------------------------------------*/
{
    if( ((XMIT_AS_CONTEXT *)pE1)->fXmit == ((XMIT_AS_CONTEXT *)pE2)->fXmit )
        if ( ((XMIT_AS_CONTEXT *)pE1)->fXmit )
            return( strcmp( ((XMIT_AS_CONTEXT *)pE1)->pTypeName,
                            ((XMIT_AS_CONTEXT *)pE2)->pTypeName ) );
        else
            return( strcmp(
                ((CG_REPRESENT_AS *)((XMIT_AS_CONTEXT *)pE1)->pXmitNode)->
                            GetTransmittedType()->GetSymName(),
                ((CG_REPRESENT_AS *)((XMIT_AS_CONTEXT *)pE2)->pXmitNode)->
                            GetTransmittedType()->GetSymName()
                           ) );
    else
    if( ((XMIT_AS_CONTEXT *)pE1)->fXmit )
        return( -1 );
    else
        return( 1 );
}

void *
QuintupleDict::GetFirst()
{
    Dict_Status             Status;
    XMIT_AS_CONTEXT *  pFirst = 0;

    Status = Dict_Next( 0 );

    if ( Status == SUCCESS )
        pFirst = (XMIT_AS_CONTEXT *)Dict_Curr_Item();

    return( pFirst );
}

void *
QuintupleDict::GetNext()
{
    Dict_Status             Status;
    XMIT_AS_CONTEXT    *pCurr, *pNext = 0;

    pCurr = (XMIT_AS_CONTEXT *)Dict_Curr_Item();

    if ( pCurr )
        {
        Status = Dict_Next( pCurr );
        if ( Status == SUCCESS )
            pNext = (XMIT_AS_CONTEXT *)Dict_Curr_Item();
        }

    return( pNext );
}

//========================================================================


BOOL 
QuadrupleDict::Add(
    void *          pContext
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    Adds a Quadruple description to the dictionary.

Arguments:

Returns:

    TRUE    - when a new entry has been registered,
    FALSE   - otherwise entry exist already

    Index field gets set to appropriate index.

    
----------------------------------------------------------------------------*/
{
    Dict_Status             Status;
    USER_MARSHAL_CONTEXT *  pEntry = (USER_MARSHAL_CONTEXT *) pContext;

    Status = Dict_Find( pEntry );

    if( Status == EMPTY_DICTIONARY  ||  Status == ITEM_NOT_FOUND )
        {
        pEntry->Index = GetCount();
        Dict_Insert( pEntry );
        IncrementCount();
        return TRUE;
        }
    else
        {
        pEntry->Index = ((USER_MARSHAL_CONTEXT *)Dict_Curr_Item())->Index;
        return FALSE;
        }
}


SSIZE_T
QuadrupleDict::Compare(
    pUserType   pE1,
    pUserType   pE2
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

     Compare two Quadruple types.
     For usr_marshall we compare the types.

 Arguments:

 Return Value:
    
----------------------------------------------------------------------------*/
{
    return( strcmp( ((USER_MARSHAL_CONTEXT *)pE1)->pTypeName,
                    ((USER_MARSHAL_CONTEXT *)pE2)->pTypeName ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\ilxlat.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    ilxlat.cxx

 Abstract:

    Intermediate Language translator

 Notes:


 Author:

    GregJen Jun-11-1993 Created.

 Notes:


 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

#include "ilxlat.hxx"
#include "ilreg.hxx"
#include "control.hxx"
#include "tlgen.hxx"

/****************************************************************************
 *  local data
 ***************************************************************************/

// #define trace_cg 1

/****************************************************************************
 *  externs
 ***************************************************************************/

extern  CMD_ARG             *   pCommand;
extern  BOOL                    IsTempName( char *);
extern  ccontrol            *   pCompiler;
extern  REUSE_DICT          *   pReUseDict;
extern  SymTable            *   pBaseSymTbl;

/****************************************************************************
 *  definitions
 ***************************************************************************/

        
void
AddToCGFileList( CG_FILE *& pCGList, CG_FILE * pFile )
{
    if (pFile)
        {
        pFile->SetSibling( pCGList );
        pCGList = pFile;
        }
}

void XLAT_CTXT::InitializeMustAlign( node_skl * pPar ) 
{
    if (pPar)
        {
        if (pPar->GetModifiers().IsModifierSet(ATTR_DECLSPEC_ALIGN))
            {
            GetMustAlign() = true;
            GetMemAlign() = __max(GetMemAlign(),
                                  pPar->GetModifiers().GetDeclspecAlign());
            }
        }
}



//--------------------------------------------------------------------
//
// XLAT_CTXT::~XLAT_CTXT
//
// Notes:  If the node that created this context didn't remove all
//         the attributes it added, force the issue.  This is done
//         mostly because tlb generation short-circuits code
//         generation and tends to leave attributes hanging around.
//         This causes asserts and possibly other problems in random
//         places later on.  Also note that a lot of the top-level
//         stuff (interfaces, etc) don't strip much so you get lots
//         of hits with those.
//
//--------------------------------------------------------------------

XLAT_CTXT::~XLAT_CTXT()
{
    if ( !GetParent() || !GetParent()->HasAttributes() )
        return;
    
    named_node     *pNode = dynamic_cast<named_node *>(GetParent());
    type_node_list  attrs;
    node_base_attr *pAttr;

    MIDL_ASSERT( NULL != pNode);

    pNode->GetAttributeList(&attrs);

    while (ITERATOR_GETNEXT(attrs, pAttr))
    {
#ifdef DUMP_UNEXTRACTED_ATTRIBUTES
        extern void GetSemContextString(char *, node_skl *, WALK_CTXT *);
        char    szContext[1024];

        GetSemContextString(szContext, pNode, this);

        fprintf(
                stderr, 
                "Unextracted attribute: %s: %s\n", 
                pAttr->GetNodeNameString(),
                szContext );
#endif

        ExtractAttribute( pAttr->GetAttrID() );
    }
}



//--------------------------------------------------------------------
//
// IsComplexReturn
//
// Notes:  A complex return value is one that isn't be returned in an
//         ordinary register.  structs, unions, and floating point
//         values are complex
//
//--------------------------------------------------------------------

bool IsComplexReturn(node_skl *node)
{
    // straight dce doesn't support complex returns in intrepreted mode yet

    if ( !pCommand->NeedsNDR64Run() )
        return false;

    node = node->GetNonDefSelf();

    NODE_T kind = node->NodeKind();

    if (   NODE_STRUCT == kind
        || NODE_UNION  == kind
        || NODE_ARRAY  == kind
        || NODE_FLOAT  == kind
        || NODE_DOUBLE == kind 
        || ( NODE_HYPER == kind && pCommand->Is32BitEnv() ) )
    {
        return true;
    }
    
    // REVIEW: NODE_INT64, NODE_LONGLONG

    return false;
}


//--------------------------------------------------------------------
//
// node_file::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_file::ILxlate( XLAT_CTXT * pContext )
{
    node_interface  *   pI = 0;
    CG_CLASS        *   pcgInterfaceList = NULL;
    CG_CLASS        *   pPrevChildCG = NULL;

    CG_PROXY_FILE       *   pProxyCG    = NULL;
    CG_IID_FILE         *   pIidCG      = NULL;
    CG_TYPELIBRARY_FILE *   pLibCG      = NULL; 
    CG_NETMONSTUB_FILE  *   pNetmonCG   = NULL;
    CG_NETMONSTUB_FILE  *   pNetmonObjCG   = NULL;

    CG_CSTUB_FILE           *   pCCG        = NULL;
    CG_SSTUB_FILE           *   pSCG        = NULL;
    CG_HDR_FILE             *   pHCG        = NULL;

    CG_CLASS        *   pChildCG    = NULL;
    CG_FILE         *   pCGList     = NULL;

    char            *   pHdrName    = pCommand->GetHeader();
    XLAT_CTXT           MyContext(this);

    BOOL                HasObjectInterface  = FALSE;
    BOOL                HasRemoteProc       = FALSE;
    BOOL                HasRemoteObjectProc = FALSE;
    BOOL                HasDefs             = FALSE;
    BOOL                HasLibrary          = FALSE;
#ifdef trace_cg
    printf("..node_file,\t%s\n", GetSymName());
#endif

    // don't process for imported stuff
    if ( ImportLevel > 0 )
        {
        return NULL;
        }

    // at this point, there should be no more attributes...

    MIDL_ASSERT( !MyContext.HasAttributes() );

    //////////////////////////////////////////////////////////////////////
    // compute all the child nodes

    for(pI = (node_interface *)GetFirstMember();
        pI;
        pI = (node_interface *)pI->GetSibling())
    {
        // build a linked list of CG_INTERFACE and CG_OBJECT_INTERFACE nodes.
        // Notes: pChildCG points to first node.  pPrevChildCG points to last node.

        MyContext.SetInterfaceContext( &MyContext );
        pcgInterfaceList = pI->ILxlate( &MyContext );
        if(pcgInterfaceList)
            {
            if (pPrevChildCG)
                {
                pPrevChildCG->SetSibling( pcgInterfaceList );
                }
            else
                {
                pChildCG = pcgInterfaceList;
                }
            pPrevChildCG = pcgInterfaceList;
            // advance to the end of the list (skipping inherited interfaces)
            while ( pPrevChildCG->GetSibling() )
                pPrevChildCG = pPrevChildCG->GetSibling();

            switch(pPrevChildCG->GetCGID())
                {
                case ID_CG_INTERFACE:
                    //Check for a remote procedure.
                    if(pPrevChildCG->GetChild())
                        HasRemoteProc = TRUE;
                    HasDefs = TRUE;
                    break;
                case ID_CG_OBJECT_INTERFACE:
                case ID_CG_INHERITED_OBJECT_INTERFACE:
                    HasDefs = TRUE;
                    HasObjectInterface = TRUE;

                    //Check for a remote object procedure or base interface
                    if( pPrevChildCG->GetChild() ||
                        ((CG_OBJECT_INTERFACE *)pPrevChildCG)->GetBaseInterfaceCG() )
                        HasRemoteObjectProc = TRUE;
                    break;
                case ID_CG_LIBRARY:
                    HasLibrary = TRUE;
                    if( pCommand->IsSwitchDefined( SWITCH_HEADER ) )
                        HasDefs = TRUE;
                    break;
                default:
                    break;
                }
            }
    }

    // process the server and client stubs

    // make the list of imported files

    ITERATOR        *   pFileList   = new ITERATOR;
    named_node      *   pCur;

    // make a list of the file nodes included directly by the main file

    // start with the first child of our parent
    pCur = (named_node *)
            ((node_source *) pContext->GetParent())
                ->GetFirstMember();

    while ( pCur )
        {
        if ( ( pCur->NodeKind() == NODE_FILE ) &&
             ( ( (node_file *) pCur )->GetImportLevel() == 1 ) )
            {
            // add all the files imported at lex level 1
            ITERATOR_INSERT( (*pFileList), ((void *) pCur) );
            }
        pCur    = pCur->GetSibling();
        }

    ITERATOR_INIT( (*pFileList) );

    //////////////////////////////////////////////////////////////////////
    // manufacture the header file node

    if ( HasDefs )
        {
        pHCG    = new CG_HDR_FILE( this,
                                    pHdrName,
                                    pFileList);

        pHCG->SetChild( pChildCG );
        }

    //////////////////////////////////////////////////////////////////////
    // manufacture the CG_SSTUB_FILE

    // if the IDL file contains at least one remotable function in a
    // non-object interface, then generate a server stub file.
    //

    if ( HasRemoteProc &&
         (pChildCG != NULL) )   // if server stub desired
        {
        pSCG = new CG_SSTUB_FILE(
                             this,
                             ( pCommand->GenerateSStub() ) ?
                                    pCommand->GetSstubFName():
                                    NULL,
                             pHdrName
                              );

        // plug in the child subtree and add the sstub to the head of the list
        pSCG->SetChild( pChildCG );

        }

    //////////////////////////////////////////////////////////////////////
    // manufacture the CG_CSTUB_FILE

    // if the IDL file contains at least one remotable function in a
    // non-object interface, then generate a client stub file.

    if ( HasRemoteProc &&
         (pChildCG != NULL) )   // if client stub desired
        {
        pCCG = new CG_CSTUB_FILE(
                             this,
                             ( pCommand->GenerateCStub() ) ?
                                    pCommand->GetCstubFName():
                                    NULL,
                             pHdrName
                              );

        pCCG->SetChild( pChildCG );
       
        }

    // If the IDL file contains at least one remotable function in an
    // object interface, then generate a proxy file.
    if ( HasRemoteObjectProc &&
        (pChildCG != NULL) )    // if proxy file desired
        {
        pProxyCG = new CG_PROXY_FILE(
                             this,
                             ( pCommand->GenerateProxy() ) ?
                                    pCommand->GetProxyFName():
                                    NULL,
                             pHdrName
                              );

        pProxyCG->SetChild( pChildCG );

        }


    // If the IDL file contains at least one object interface,
    // then generate an IID file.
    if ( (HasObjectInterface || (HasLibrary && HasDefs) )&&
        (pChildCG != NULL) )    // if IID file desired
        {
        pIidCG = new CG_IID_FILE(
                             this,
                             ( pCommand->GenerateIID() ) ?
                                    pCommand->GetIIDFName():
                                    NULL);

        pIidCG->SetChild( pChildCG );
        }

    // If the IDL file contains a library then gnerate a TYPELIBRARY_FILE
    if (HasLibrary && (NULL != pChildCG) )
        {
#ifdef _WIN64
        bool fGenTypeLib = pCommand->Is64BitEnv() || ( pCommand->Is32BitEnv() && pCommand->IsSwitchDefined( SWITCH_ENV ) );
#else
        bool fGenTypeLib = pCommand->Is32BitEnv() || ( pCommand->Is64BitEnv() && pCommand->IsSwitchDefined( SWITCH_ENV ) );
#endif

        if ( fGenTypeLib && pCommand->GenerateTypeLibrary() )
            {
            pLibCG = new CG_TYPELIBRARY_FILE(
                            this,
                            pCommand->GetTypeLibraryFName() ) ;
            pLibCG->SetChild( pChildCG );
            }
        }

    // If the -netmon switch was used, generate the two NETMONSTUB_FILE's
    if ( pCommand->IsNetmonStubGenerationEnabled() ) 
        {
        if (HasRemoteProc) 
            {
            pNetmonCG = new CG_NETMONSTUB_FILE(
                FALSE,
                this,
                pCommand->GetNetmonStubFName());

            pNetmonCG->SetChild( pChildCG );
            }

        if (HasRemoteObjectProc) 
            {
            pNetmonObjCG = new CG_NETMONSTUB_FILE(
                TRUE,
                this,
                pCommand->GetNetmonStubObjFName());
            pNetmonObjCG->SetChild( pChildCG );
            }
        }

    /////////////////////////////////////////////////////////////////////
    // glue all the parts together by tacking onto the head of the list.
    // the final order is:
    // CStub - SStub - Proxy - IID - Hdr
    // doesn't need to create Hdr & tlb in ndr64 run. 
    pCGList = NULL;

    AddToCGFileList( pCGList, pNetmonObjCG );
    AddToCGFileList( pCGList, pNetmonCG );

    if ( !pCommand->Is2ndCodegenRun() )
        AddToCGFileList( pCGList, pHCG );

    if ( !pCommand->Is2ndCodegenRun() )
        AddToCGFileList( pCGList, pIidCG );
    AddToCGFileList( pCGList, pProxyCG );

    AddToCGFileList( pCGList, pSCG );
    AddToCGFileList( pCGList, pCCG );

    if ( !pCommand->Is2ndCodegenRun() )
        AddToCGFileList( pCGList, pLibCG );

    return pCGList;

};

//--------------------------------------------------------------------
//
// node_implicit::ILxlate
//
// Notes:
//
// This is a little bit different, since it is not a node_skl...
// therefore, it will not set up its own context
//
//--------------------------------------------------------------------

CG_CLASS *
node_implicit::ILxlate( XLAT_CTXT * pContext )
{
    CG_NDR      *   pCG;

    if ( pHandleType->NodeKind() == NODE_HANDLE_T )
        {
        pCG = new CG_PRIMITIVE_HANDLE( pHandleType,
                                         pHandleID,
                                         *pContext );
        }
    else    // assume generic handle
        {
        pCG = new CG_GENERIC_HANDLE( pHandleType,
                                       pHandleID,
                                       *pContext );
        }
#ifdef trace_cg
    printf("..node_implicit,\t\n");
#endif
    return pCG;
}


//--------------------------------------------------------------------
//
// node_proc::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_proc::ILxlate( XLAT_CTXT * pContext )
{
    MEM_ITER            MemIter( this );
    node_param      *   pN;
    CG_PROC         *   pCG;
    CG_CLASS        *   pChildCG        = NULL;
    CG_CLASS        *   pPrevChildCG    = NULL;
    CG_CLASS        *   pFirstChildCG   = NULL;
    CG_RETURN       *   pReturnCG       = NULL;
    CG_CLASS        *   pBinding        = NULL;
    CG_CLASS        *   pBindingParam   = NULL;
    BOOL                fHasCallback    = FALSE;
    BOOL                fNoCode         = FALSE;
    BOOL                fObject;
    BOOL                fRetHresult     = FALSE;
    BOOL                fEnableAllocate;
    XLAT_CTXT           MyContext( this, pContext );
    unsigned short      OpBits          = MyContext.GetOperationBits();
    XLAT_CTXT       *   pIntfCtxt       = (XLAT_CTXT *)
                                                MyContext.GetInterfaceContext();
    node_interface  *   pIntf           = (node_interface *)
                                                pIntfCtxt->GetParent();
    node_base_attr  *   pNotify,
                    *   pNotifyFlag;
    BOOL                HasEncode       = (NULL !=
                                            MyContext.ExtractAttribute( ATTR_ENCODE ) );
    BOOL                HasDecode       = (NULL !=
                                            MyContext.ExtractAttribute( ATTR_DECODE ) );
    node_call_as    *   pCallAs         = (node_call_as *)
                                            MyContext.ExtractAttribute( ATTR_CALL_AS );
    bool                fLocalProc      = MyContext.ExtractAttribute( ATTR_LOCAL ) != 0;
    BOOL                fLocal          = (BOOL ) fLocalProc ||
                                        pIntfCtxt->FInSummary( ATTR_LOCAL );
    BOOL                fLocalCall      = IsCallAsTarget();
    unsigned short      SavedProcCount = 0;
    unsigned short      SavedCallbackProcCount = 0;
    node_param      *   pComplexReturn = NULL;


    MyContext.ExtractAttribute( ATTR_ENTRY );
    MyContext.ExtractAttribute( ATTR_ID );
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    MyContext.ExtractAttribute( ATTR_IDLDESCATTR );
    MyContext.ExtractAttribute( ATTR_FUNCDESCATTR );
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    MyContext.ExtractAttribute( ATTR_ASYNC );
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
#ifdef trace_cg
    printf("..node_proc,\t%s\n", GetSymName());
#endif
    BOOL fSupressHeader = FALSE;
    unsigned long ulOptFlags;
    unsigned long ulStackSize = 0;

    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 );

    // do my attribute parsing...
    fHasCallback = (NULL != MyContext.ExtractAttribute( ATTR_CALLBACK ) );

    fObject = (NULL != MyContext.ExtractAttribute( ATTR_OBJECT )) ||
                        pIntfCtxt->FInSummary( ATTR_OBJECT );

    // do my attribute parsing... attributes to ignore here

    MyContext.ExtractAttribute( ATTR_OPTIMIZE );

    MyContext.ExtractAttribute( ATTR_EXPLICIT );

    HasEncode = HasEncode || pIntfCtxt->FInSummary( ATTR_ENCODE );
    HasDecode = HasDecode || pIntfCtxt->FInSummary( ATTR_DECODE );


    pNotify     = MyContext.ExtractAttribute( ATTR_NOTIFY );
    pNotifyFlag = MyContext.ExtractAttribute( ATTR_NOTIFY_FLAG );
    fEnableAllocate = (NULL != MyContext.ExtractAttribute( ATTR_ENABLE_ALLOCATE ));
    fEnableAllocate = fEnableAllocate ||
                      pIntfCtxt->FInSummary( ATTR_ENABLE_ALLOCATE ) ||
                      pCommand->IsRpcSSAllocateEnabled();

    // do my attribute parsing...
    // locally applied [code] attribute overrides global [nocode] attribute
    fNoCode = MyContext.ExtractAttribute( ATTR_NOCODE ) ||
              pIntfCtxt->FInSummary( ATTR_NOCODE );
    fNoCode = !MyContext.ExtractAttribute( ATTR_CODE ) && fNoCode;

    if ( NULL != MyContext.ExtractAttribute( ATTR_CSTAGRTN ) )
        MyContext.SetAncestorBits( IL_CS_HAS_TAG_RTN );

    BOOL fImported = FALSE;
    if ( GetDefiningFile() )
        {
        fImported = GetDefiningFile()->GetImportLevel() != 0;
        }

    if ( fLocalProc && !IsCallAsTarget() && fObject )
        {
        SemError( this, MyContext, LOCAL_NO_CALL_AS, 0 );
        }

    // determine if the proc is local and 
    // determine the proc number (local procs don't bump the number)
    if (fLocalCall || (fLocal && !fObject))
    {
            // return without making anything
            return NULL;
    }
    else
    {
        if ( fHasCallback )
            {
            ProcNum = ( pIntf ->GetCallBackProcCount() )++;
            }
        else
            {
            ProcNum = ( pIntf ->GetProcCount() )++;
            }
    }
   
    if ( fLocal && fObject && !MyContext.AnyAncestorBits(IL_IN_LIBRARY) )
        {

        if ( pIntf->IsValidRootInterface() )
            {
            pCG = new CG_IUNKNOWN_OBJECT_PROC( ProcNum,
                                             this,
                                             GetDefiningFile()->GetImportLevel() > 0,
                                             GetOptimizationFlags(),
                                             fHasDeny );
            }
        else
            {
            pCG = new CG_LOCAL_OBJECT_PROC( ProcNum,
                                             this,
                                             GetDefiningFile()->GetImportLevel() > 0,
                                             GetOptimizationFlags(),
                                             fHasDeny );
            }

        goto done;

        }

    SavedProcCount = pIntf->GetProcCount();
    SavedCallbackProcCount = pIntf->GetCallBackProcCount();

    // add the return type
    if ( HasReturn() )
        {
        node_skl    *   pReturnType = GetReturnType();
        CG_CLASS    *   pRetCG;

        // If the return value is complex it is treated in ndr as if a ref
        // pointer to the complex type was in the parameter list instead of
        // a true return value.  Temporarily add a parameter to the type
        // to get the back-end parameter created.

        if ( IsComplexReturn( pReturnType ) )
            {
            pComplexReturn = new node_param;
            pComplexReturn->SetSymName( RETURN_VALUE_VAR_NAME );
            pComplexReturn->SetChild( new node_pointer( pReturnType) );
            pComplexReturn->GetChild()->GetModifiers().SetModifier( ATTR_TAGREF );
            pComplexReturn->SetAttribute( new node_base_attr( ATTR_OUT ) );

            MemIter.AddLastMember( pComplexReturn );
            ITERATOR_INIT( MemIter );
            }
        else
            {
            pRetCG      = pReturnType->ILxlate( &MyContext );
            fRetHresult = (BOOL) ( pRetCG->GetCGID() == ID_CG_HRESULT );
            pReturnCG   = new CG_RETURN( pReturnType,
                                         MyContext,
                                         (unsigned short) RTStatuses );
            pReturnCG->SetChild( pRetCG );
            }
        }

    // at this point, there should be no more attributes...
    MIDL_ASSERT( !MyContext.HasAttributes() );

    pContext->ReturnSize( MyContext );

    if ( MemIter.GetNumberOfArguments() > 0 )
        {
        //
        // for each of the parameters, call the core transformer.
        //

        while ( ( pN = (node_param *) MemIter.GetNext() ) != 0 )
            {
            // REVIEW: One could argue that hidden status params
            //         aren't on the wire so there shouldn't be a CG node
            //         for them.  The main problem with this is that we
            //         need to be able to calculate a stack offset for the
            //         hidden param and that can only be done in the
            //         back end.

            // Hidden status params are not really [out] params but the way
            // the -Os generator builds up local resources requires them to
            // be.

            if ( pN->IsExtraStatusParam() 
                && ! ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) )
                {
                pN->SetAttribute( ATTR_OUT );
                }

            pChildCG = pN->ILxlate( &MyContext );

#ifdef trace_cg
    printf("back from..node_param %s\n",pN->GetSymName());
    printf("binding is now %08x\n",pBindingParam );
    printf("child is now %08x\n",pChildCG );
#endif

            // pChildCG could be NULL if it's imported from .tlb somewhere else already
            if ( pChildCG )
                {
                // the first binding param gets picked up for binding
                if ( !pBindingParam
                     && pN->IsBindingParam() )
                    {
#ifdef trace_cg
    printf("value for IsBindingParam is %08x\n",pN->IsBindingParam() );
    printf("binding found on node_param %s\n",pN->GetSymName());
    printf("binding is now %08x\n",pBindingParam );
#endif
                    pBindingParam = pChildCG;
                    }
    
                // build up the parameter list
                if( pPrevChildCG )
                    {
                    pPrevChildCG->SetSibling( pChildCG );
                    }
                else
                    {
                    pFirstChildCG = pChildCG;
                    };

            // this is only a calculated guess. We need more information to make an accurate
            // estimate.
                unsigned long ulSize = ( ( CG_PARAM* ) pChildCG )->GetStackSize();
                ulSize += (8 - (ulSize % 8));
                ulStackSize += ulSize;

                pPrevChildCG = pChildCG;
                }
            else
                SemError( this, MyContext, FAILED_TO_GENERATE_PARAM, pN->GetSymName() );
            }
        }

    ulOptFlags = GetOptimizationFlags();
    if ( ( ulOptFlags & OPTIMIZE_INTERPRETER ) &&
         !( ulOptFlags & OPTIMIZE_INTERPRETER_V2 ) &&
         ( ulStackSize > INTERPRETER_THUNK_PARAM_SIZE_THRESHOLD ) )
        {
        if ( ForceNonInterpret() )
            {
            SemError( this, *pContext, OI_STACK_SIZE_EXCEEDED, 0 );
            }
        }
    if ( ulOptFlags & OPTIMIZE_INTERPRETER && ulStackSize > INTERPRETER_PROC_STACK_FRAME_SIZE_THRESHOLD )
        {
        if ( ForceNonInterpret() )
            {
            SemError( this, *pContext, STACK_FRAME_SIZE_EXCEEDED, GetSymName() );
            exit ( STACK_FRAME_SIZE_EXCEEDED );
            }
        }
    if (fForcedI2 && fForcedS)
        {
        // ERROR - Can't force it both ways.
        SemError( this, *pContext, CONFLICTING_OPTIMIZATION_REQUIREMENTS, 0 );
        exit ( CONFLICTING_OPTIMIZATION_REQUIREMENTS );
        }


#ifdef trace_cg
    printf("done with param list for %s\n",GetSymName());
    printf("binding is now %08x\n",pBindingParam );
#endif

    // get the binding information
    if ( pBindingParam )
        {
        pBinding    = pBindingParam;

        while (! ((CG_NDR *) pBinding)->IsAHandle() )
            pBinding = pBinding->GetChild();
        // pBinding now points to the node for the binding handle
        }
    else    // implicit handle or auto handle
        {
        // note: if no implicit handle,
        //      then leave pBinding NULL for auto_handle
        if (pIntfCtxt->FInSummary( ATTR_IMPLICIT ) )
            {
            node_implicit   *   pImplAttr;
            pImplAttr = (node_implicit *) pIntf->GetAttribute( ATTR_IMPLICIT );

            pBinding = pImplAttr->ILxlate( &MyContext );
            }
        }

#ifdef trace_cg
    printf("done with binding for %s",GetSymName());
    printf("binding is now %08x\n",pBinding );
#endif

    // see if thunked interpreter needed for server side
    if ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER )
        {   // check for non-stdcall
        ATTR_T      CallingConv;

        GetCallingConvention( CallingConv );

        if ( ( CallingConv != ATTR_STDCALL ) &&
             ( CallingConv != ATTR_NONE ) )
            {
            SetOptimizationFlags( unsigned short( GetOptimizationFlags() | OPTIMIZE_THUNKED_INTERPRET ) );
            }
        else if ( pCallAs )
            {
            SetOptimizationFlags( unsigned short( GetOptimizationFlags() | OPTIMIZE_THUNKED_INTERPRET ) );
            }
        else if ( pReturnCG )   // check the return type
            {
            CG_NDR  *   pRetTypeCG  = (CG_NDR *) pReturnCG->GetChild();

            if ( !pCommand->NeedsNDR64Run() 
                 && pRetTypeCG->GetCGID() != ID_CG_CONTEXT_HDL )
                {
                // This check is bogus.  First off, it should be checking the
                // memory size, not the wire size.  Secondly, for straight dce
                // mode large (i.e. complex) return types are prohibited in
                // semantic analysis.  Finally, it should be checking the size
                // against the pointer size, not 4.

                if ( ( pRetTypeCG->GetWireSize() > 4 ) ||
                     ( !pRetTypeCG->IsSimpleType() && 
                       !pRetTypeCG->IsPointer() ) )
                    SetOptimizationFlags( unsigned short( GetOptimizationFlags() | OPTIMIZE_THUNKED_INTERPRET ) );
                }
            }

        }

    if ( fHasCallback )
        {
        pCG     = new CG_CALLBACK_PROC(
                                       ProcNum,
                                       this,
                                       (CG_HANDLE *) pBinding,
                                       (CG_PARAM *) pBindingParam,
                                       HasAtLeastOneIn(),
                                       HasAtLeastOneOut(),
                                       HasAtLeastOneShipped(),
                                       fHasStatuses,
                                       fHasFullPointer,
                                       pReturnCG,
                                       GetOptimizationFlags(),
                                       OpBits,
                                       fHasDeny
                                     );
        }
    else if ( fObject )
        {
        BOOL                fInherited = 0;
        if ( GetDefiningFile() )
            {
            fInherited = GetDefiningFile()->GetImportLevel() > 0;
            }
        if ( fInherited )
            {
            pCG     = new CG_INHERITED_OBJECT_PROC(
                                   ProcNum,
                                   this,
                                   (CG_HANDLE *) pBinding,
                                   (CG_PARAM *) pBindingParam,
                                   HasAtLeastOneIn(),
                                   HasAtLeastOneOut(),
                                   HasAtLeastOneShipped(),
                                   fHasStatuses,
                                   fHasFullPointer,
                                   pReturnCG,
                                   GetOptimizationFlags(),
                                   OpBits,
                                   fHasDeny
                                 );
            }
        else
            {
            pCG     = new CG_OBJECT_PROC(
                                   ProcNum,
                                   this,
                                   (CG_HANDLE *) pBinding,
                                   (CG_PARAM *) pBindingParam,
                                   HasAtLeastOneIn(),
                                   HasAtLeastOneOut(),
                                   HasAtLeastOneShipped(),
                                   fHasStatuses,
                                   fHasFullPointer,
                                   pReturnCG,
                                   GetOptimizationFlags(),
                                   OpBits,
                                   fHasDeny
                                 );
            }
        }
    else if ( HasEncode || HasDecode )
        {
        pCG     = new CG_ENCODE_PROC(
                               ProcNum,
                               this,
                               (CG_HANDLE *) pBinding,
                               (CG_PARAM *) pBindingParam,
                               HasAtLeastOneIn(),
                               HasAtLeastOneOut(),
                               HasAtLeastOneShipped(),
                               fHasStatuses,
                               fHasFullPointer,
                               pReturnCG,
                               GetOptimizationFlags(),
                               OpBits,
                               HasEncode,
                               HasDecode,
                               fHasDeny
                             );
        }
    else
        {
        pCG     = new CG_PROC(
                               ProcNum,
                               this,
                               (CG_HANDLE *) pBinding,
                               (CG_PARAM *) pBindingParam,
                               HasAtLeastOneIn(),
                               HasAtLeastOneOut(),
                               HasAtLeastOneShipped(),
                               fHasStatuses,
                               fHasFullPointer,
                               pReturnCG,
                               GetOptimizationFlags(),
                               OpBits,
                               fHasDeny
                             );
        }

    pCG->SetChild( pFirstChildCG );

#ifdef trace_cg
    printf("....returning from %s\n",GetSymName());
#endif
    
    pIntf->GetProcCount() = SavedProcCount;
    pIntf->GetCallBackProcCount() = SavedCallbackProcCount;

done:
    // save a pointer to the interface CG node
    pCG->SetInterfaceNode( (CG_INTERFACE*) pIntf->GetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY) ) );

    if (fSupressHeader)
        pCG->SetSupressHeader();

    // mark nocode procs
    if ( fNoCode )
        pCG->SetNoCode();

    if ( pNotify )
        pCG->SetHasNotify();

    if ( pNotifyFlag )
        pCG->SetHasNotifyFlag();

    if ( fEnableAllocate )
        pCG->SetRpcSSSpecified( 1 );

    if ( fRetHresult )
        pCG->SetReturnsHRESULT();

    if (HasPipes())
        pCG->SetHasPipes(1);

    if ( pCallAs )
        pCG->SetCallAsName( pCallAs->GetCallAsName() );

    if ( HasExtraStatusParam() )
        pCG->SetHasExtraStatusParam();

    if ( HasAsyncHandle() )
        pCG->SetHasAsyncHandle();

    if ( HasAsyncUUID() )
        pCG->SetHasAsyncUUID();

    if ( HasServerCorr() )
        pCG->SetHasServerCorr();

    if ( HasClientCorr() )
        pCG->SetHasClientCorr();

    // A fake parameter was added to the type for complex return values.
    // Remove it.

    if ( pComplexReturn )
        {
        pCG->SetHasComplexReturnType();
        MemIter.RemoveLastMember();
        }

    pCG->SetCSTagRoutine( GetCSTagRoutine() );

    // Typelib generation does not remove ATTR_V1_ENUM.
    MyContext.ExtractAttribute( ATTR_V1_ENUM );
    
    // at this point, there should be no more attributes...
    MIDL_ASSERT( !MyContext.HasAttributes() );

    if (  ( pCG->GetOptimizationFlags() & OPTIMIZE_INTERPRETER ) && 
            !( pCG->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) &&
                pCommand->Is64BitEnv() )
        {
        SemError( this, *pContext, NO_OLD_INTERPRETER_64B, GetSymName() );
        exit ( NO_OLD_INTERPRETER_64B );
        }

    return pCG;
}

//--------------------------------------------------------------------
//
// node_param::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_param::ILxlate( XLAT_CTXT * pContext )
{
    CG_PARAM    *   pCG;
    CG_CLASS    *   pChildCG    = NULL;
    expr_node   *   pSwitchExpr = NULL;

#ifdef trace_cg
    printf("..node_param,\t%s\n",GetSymName());
#endif

    PARAM_DIR_FLAGS F = 0;
    XLAT_CTXT   MyContext( this, pContext );

    // make sure all member attributes get processed
    node_member_attr * pMA;

    MyContext.ExtractAttribute(ATTR_IDLDESCATTR);
    MyContext.ExtractAttribute(ATTR_DEFAULTVALUE);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));

    if ( MyContext.ExtractAttribute(ATTR_FLCID) )
        {
        LCID();
        }

    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_RETVAL:
                Retval();
                break;
            case MATTR_OPTIONAL:
            {
                Optional();
            }
                break;
            default:
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
            }
        }
  
    if( MyContext.ExtractAttribute( ATTR_IN ) )
        {
        F   |= IN_PARAM;
        }

    if( MyContext.ExtractAttribute( ATTR_OUT ) )
        {
        F   |= OUT_PARAM;
        }

    if ( MyContext.ExtractAttribute( ATTR_PARTIAL_IGNORE ) )
        {
        F   |= PARTIAL_IGNORE_PARAM; 
        }

    // default to in
    if ( F == 0 && !IsExtraStatusParam() )
        F   |= IN_PARAM;

    if ( MyContext.FInSummary( ATTR_SWITCH_IS ) )
        {
        node_switch_is  *   pAttr;
         
        if ( pCommand->IsNDR64Run() )
            {
            pAttr = (node_switch_is *) MyContext.GetAttribute( ATTR_SWITCH_IS );
            }
        else 
            {
            pAttr = (node_switch_is *) MyContext.ExtractAttribute( ATTR_SWITCH_IS );
            }
        pSwitchExpr = pAttr->GetExpr();
        }

    BOOL fHasCSSTag = ( NULL != MyContext.ExtractAttribute( ATTR_STAG ) );
    BOOL fHasCSDRTag = ( NULL != MyContext.ExtractAttribute( ATTR_DRTAG ) );
    BOOL fHasCSRTag = ( NULL != MyContext.ExtractAttribute( ATTR_RTAG ) );

    MyContext.SetAncestorBits(
                      ( fHasCSSTag  ? IL_CS_STAG  : 0 )
                    | ( fHasCSDRTag ? IL_CS_DRTAG : 0 )
                    | ( fHasCSRTag  ? IL_CS_RTAG  : 0 ) );

    BOOL HasForceAllocate = ( NULL != MyContext.ExtractAttribute( ATTR_FORCEALLOCATE ) );
    
	pChildCG = GetChild()->ILxlate( &MyContext );

    pContext->ReturnSize( MyContext );

#ifdef trace_cg
    printf("..node_param back.. %s\n",GetSymName());
#endif
    // make sure void parameters get skipped
    if ( !pChildCG )
        return NULL;

    pCG = new CG_PARAM( this,
                        F,
                        MyContext,
                        pSwitchExpr,
                        (unsigned short) Statuses );

#ifdef trace_cg
    printf("..node_param ..... %08x child=%08x\n", pCG, pChildCG );
    fflush(stdout);
#endif

    if ( IsExtraStatusParam() )
        pCG->SetIsExtraStatusParam();

    // only set the bit if there was non-toplevel only
    if ( fDontCallFreeInst == 1 )
        pCG->SetDontCallFreeInst( TRUE );


#ifdef trace_cg
    printf("..node_param ........ %08x child=%08x\n", pCG, pChildCG );
    fflush(stdout);
#endif
    pCG->SetChild( pChildCG );

    if (IsAsyncHandleParam())
        {
        pCG->SetIsAsyncHandleParam();
        }
    if ( IsSaveForAsyncFinish() )
        {
        pCG->SaveForAsyncFinish();
        }

    pCG->SetIsCSSTag( fHasCSSTag );
    pCG->SetIsCSDRTag( fHasCSDRTag );
    pCG->SetIsCSRTag( fHasCSRTag );

    if ( MyContext.AnyAncestorBits( IL_CS_HAS_TAG_RTN ) && pCG->IsSomeCSTag() )
        pCG->SetIsOmittedParam();

#ifdef trace_cg
    printf("..node_param return %s\n",GetSymName());
    fflush(stdout);
#endif
    if ( HasForceAllocate )
        {
    	pCG->SetForceAllocate( );
    	}


    if ( !MyContext.AnyAncestorBits(IL_IN_LIBRARY) )
        {
        SetCG( pCG );
        }

    // REVIEW: There is no concept of switch_type in a library block.
    //         Perhaps issue an error in semantic analysis.

    if ( MyContext.AnyAncestorBits( IL_IN_LIBRARY )
         && MyContext.ExtractAttribute( ATTR_SWITCH_TYPE ) )
        {
        SemError(
                this, 
                MyContext, 
                IGNORE_UNIMPLEMENTED_ATTRIBUTE, 
                "[switch_type] in a library block");
        }

    return pCG;
}

const GUID_STRS DummyGuidStrs( "00000000", "0000", "0000", "0000", "000000000000" );

// helper function for adding a new list to the end of the list of children
inline
void    AddToCGList(
    const CG_CLASS * pCNew,
    CG_CLASS * * ppChild,
    CG_CLASS * * ppLastSibling )
{
    CG_CLASS * pCurrent;
    CG_CLASS * pNew         = (CG_CLASS *) pCNew;

    // hook the head on
    if ( !*ppChild )
        *ppChild = pNew;
    else
        (*ppLastSibling)->SetSibling( pNew );

    // advance the last sibling pointer
    *ppLastSibling = pNew;
    while ( ( pCurrent = (*ppLastSibling)->GetSibling() ) != 0 )
        *ppLastSibling = pCurrent;

}

//--------------------------------------------------------------------
//
// node_interface::ILxlate
//
// Notes: This function returns either a CG_INTERFACE or a
//        CG_OBJECT_INTERFACE node.
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_interface::ILxlate( XLAT_CTXT * pContext )
{
    CG_NDR          *   pcgInterface    = NULL;
    CG_NDR          *   pResultCG       = NULL;
    CG_CLASS        *   pCG             = NULL;
    CG_CLASS        *   pChildCG        = NULL;
    CG_CLASS        *   pPrevChildCG    = NULL;
    MEM_ITER            MemIter( this );
    node_skl        *   pN;
    XLAT_CTXT           MyContext( this, pContext );
    XLAT_CTXT           ChildContext( MyContext );
    node_guid       *   pGuid       = (node_guid *)
                                            MyContext.ExtractAttribute( ATTR_GUID );
    GUID_STRS           GuidStrs;
    node_implicit   *   pImpHdl     = NULL;
    CG_HANDLE       *   pImpHdlCG   = NULL;
    NODE_T              ChildKind;
    BOOL                IsPickle    = MyContext.FInSummary( ATTR_ENCODE ) ||
                                      MyContext.FInSummary( ATTR_DECODE );
    BOOL                fAllRpcSS   = MyContext.FInSummary( ATTR_ENABLE_ALLOCATE ) ||
                                        pCommand->IsRpcSSAllocateEnabled();
    BOOL                fObject     = MyContext.FInSummary( ATTR_OBJECT );

    node_interface  *   pBaseIntf       = GetMyBaseInterface();
    CG_OBJECT_INTERFACE     *   pBaseCG = NULL;
    CG_OBJECT_INTERFACE     *   pCurrentCG  = NULL;
    CG_OBJECT_INTERFACE     *   pLastItfCG = 0;
    BOOL                        fInheritedIntf = NULL;

    MyContext.ExtractAttribute( ATTR_TYPEDESCATTR );
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    MyContext.ExtractAttribute( ATTR_ASYNC );
    MyContext.ExtractAttribute( ATTR_CSTAGRTN );
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));

#ifdef trace_cg
    printf("..node_interface,\t%s\n", GetSymName());
#endif

    if( FInSummary( ATTR_IMPLICIT ) )
        {
        pImpHdl = (node_implicit *) GetAttribute( ATTR_IMPLICIT );
        if (pImpHdl)
            pImpHdlCG = (CG_HANDLE *) pImpHdl->ILxlate( &MyContext );
        }

    if (pGuid)
        GuidStrs = pGuid->GetStrs();
    else
        GuidStrs = DummyGuidStrs;

    // don't pass the interface attributes down...
    // save them off elsewhere

    ChildContext.SetInterfaceContext( &MyContext );

    // if we already got spit out, don't do it again...
    if ( GetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY) ) )
        return NULL;
        
    // start the procnum counting over
    GetProcCount() = 0;
    GetCallBackProcCount() = 0;

    // Generate the interface's CG node first
    if( fObject || MyContext.AnyAncestorBits(IL_IN_LIBRARY))
        {
        // object interfaces need to have their base classes generated, too
        if ( pBaseIntf )
            {
            pBaseCG = (CG_OBJECT_INTERFACE *) pBaseIntf->GetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY) );
            if ( !pBaseCG )
                {
                XLAT_CTXT       BaseCtxt( &ChildContext );

                BaseCtxt.SetInterfaceContext( &BaseCtxt );
                pCurrentCG  = (CG_OBJECT_INTERFACE *)
                                pBaseIntf->ILxlate( &BaseCtxt );
                AddToCGList( pCurrentCG, (CG_CLASS**) &pResultCG, (CG_CLASS**) &pLastItfCG );

                // our base interface made the last one on the list
                pBaseCG = pLastItfCG;
                }

            // start the procnum from our base interface
            GetProcCount()          = pBaseIntf->GetProcCount();
            GetCallBackProcCount()  = pBaseIntf->GetCallBackProcCount();

            }

        if ( GetFileNode() )
            {
            fInheritedIntf = GetFileNode()->GetImportLevel() > 0;
            }

        if ( IsValidRootInterface() )
            {
            pcgInterface = new CG_IUNKNOWN_OBJECT_INTERFACE(this,
                                            GuidStrs,
                                            FALSE,
                                            FALSE,
                                            pBaseCG,
                                            fInheritedIntf);
            }
        else if ( fInheritedIntf )
            {
            pcgInterface = new CG_INHERITED_OBJECT_INTERFACE(this,
                                            GuidStrs,
                                            FALSE,
                                            FALSE,
                                            pBaseCG);
            }
        else
            {
            pcgInterface = new CG_OBJECT_INTERFACE(this,
                                            GuidStrs,
                                            FALSE,
                                            FALSE,
                                            pBaseCG);
            }
        }
    else
        {
        pcgInterface = new CG_INTERFACE(this,
                                        GuidStrs,
                                        FALSE,
                                        FALSE,
                                        pImpHdlCG,
                                        pBaseCG);
        }

    if ( fHasMSConfStructAttr )
        {
        ( (CG_INTERFACE*) pcgInterface)->SetHasMSConfStructAttr();
        }

    // store a pointer to our CG node
    SetCG(  MyContext.AnyAncestorBits(IL_IN_LIBRARY), pcgInterface );

    // if we generated a bunch of new inherited interfaces, link us to the end
    // of the list, and return the list
    AddToCGList( pcgInterface, (CG_CLASS**) &pResultCG, (CG_CLASS**) &pLastItfCG );

    BOOL fImported = FALSE;
    if ( GetDefiningFile() )
        {
        fImported = GetDefiningFile()->GetImportLevel() != 0;
        }

    // if they specified LOCAL, don't generate any CG nodes (except for object)
    if ( MyContext.FInSummary(ATTR_LOCAL) && !fObject )
        {
        return pResultCG;
        }

    //
    // for each of the procedures.
    //

    CG_PROC * pBeginProc = NULL;

    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        ChildKind = pN->NodeKind();

        // proc nodes may hang under node_id's
        if( ( ChildKind == NODE_PROC )  ||
            (   ( ChildKind == NODE_ID )
             && ( pN->GetChild()->NodeKind() == NODE_PROC ) ) ||
            (   ( ChildKind == NODE_DEF )
             && ( IsPickle ||
                  pN->FInSummary( ATTR_ENCODE ) ||
                  pN->FInSummary( ATTR_DECODE ) ) ) )
            {
            // skip call_as targets
            if (ChildKind == NODE_PROC && ((node_proc *)pN)->IsCallAsTarget())
                continue;

            // translate target of call_as proc
            CG_PROC * pTarget = NULL;
            if (ChildKind == NODE_PROC)
            {
                node_proc * p = ((node_proc *)pN)->GetCallAsType();
                if (p)
                {
                    pTarget = (CG_PROC *) p->ILxlate( &ChildContext);
                }
            }

            // translate CG_NODE
            pChildCG    = pN->ILxlate( &ChildContext );

            // attach target of call_as proc
            if ( pChildCG )
                {
                if (pTarget)
                    ((CG_PROC *)pChildCG)->SetCallAsCG(pTarget);
                    
                AddToCGList( pChildCG, &pCG, &pPrevChildCG );
                }
            
            // Connect Begin and Finish async DCOM procs together.
            // CloneIFAndSplitMethods always places the procedures
            // immediatly under the interface with the Finish proc
            // immediatly following the begin proc.  This code
            // will need to be changed if CloneIFAndSplitMethods
            // changes.
            if ( NODE_PROC == ChildKind ) 
                {

                node_proc *pProc = ( node_proc * ) pN;

                if ( pProc->IsBeginProc() )
                    {

                    MIDL_ASSERT( ( ( CG_NDR * ) pChildCG )->IsProc() );
                    pBeginProc = ( CG_PROC * )pChildCG;
#ifndef NDEBUG                    
                    // assert that the next proc is the finish proc
                    MEM_ITER NewMemIter = MemIter;
                    named_node *pNextNode = NewMemIter.GetNext();
                    MIDL_ASSERT( pNextNode );
                    MIDL_ASSERT( NODE_PROC == pNextNode->NodeKind() );
                    MIDL_ASSERT( ( (node_proc *)pNextNode )->IsFinishProc() );
#endif // NDEBUG
                    }

                else if ( pProc->IsFinishProc() )
                    {
                    
                    MIDL_ASSERT( ( ( CG_NDR * ) pChildCG )->IsProc() );
                    CG_PROC *pFinishProc = ( CG_PROC * )pChildCG;
                                        
                    // Link the begin and finsh procs together
                    pBeginProc->SetIsBeginProc();
                    pBeginProc->SetAsyncRelative( pFinishProc );
                    pFinishProc->SetIsFinishProc();
                    pFinishProc->SetAsyncRelative( pBeginProc );

                    pBeginProc = NULL;
                    }

                }
            
            }

        }

    // make sure we don't have too many procs
    if ( fObject && fInheritedIntf )
        {
        if ( ( GetProcCount() > 256 ) )
            {
            // complain about too many delegated routines
            SemError(this, MyContext, TOO_MANY_DELEGATED_PROCS, NULL);
            }
        else if ( GetProcCount() > 64 )
            {
            pCommand->GetNdrVersionControl().SetHasMoreThan64DelegatedProcs();
            }
        }

        // mark ourselves if we are an all RPC SS interface
    // or if enable is used anywhere within.

    if ( fAllRpcSS )
        {
        ((CG_INTERFACE *)pcgInterface)->SetAllRpcSS( TRUE );
        }
    if ( fAllRpcSS  ||  GetHasProcsWithRpcSs() )
        {
        ((CG_INTERFACE *)pcgInterface)->SetUsesRpcSS( TRUE );
        }

    // consume all the interface attributes
    MyContext.ClearAttributes();
    pContext->ReturnSize( MyContext );

    pcgInterface->SetChild(pCG);

    return pResultCG;
}

//--------------------------------------------------------------------
//
// node_interface_reference::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_interface_reference::ILxlate( XLAT_CTXT * pContext )
{
    XLAT_CTXT       MyContext( this, pContext );
    CG_CLASS    *   pCG       = NULL;

#ifdef trace_cg
    printf("..node_interface_reference,\t%s\n", GetSymName());
#endif

    pCG = new CG_INTERFACE_POINTER( this,
                                    (node_interface *) GetChild() );

    pContext->ReturnSize( MyContext );

    return pCG;
};

//--------------------------------------------------------------------
//
// node_source::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_source::ILxlate( XLAT_CTXT * pContext )
{
    MEM_ITER        MemIter( this );
    CG_CLASS    *   pCG;
    CG_CLASS    *   pNew;
    CG_CLASS    *   pChildCG        = NULL;
    CG_CLASS    *   pPrevChildCG    = NULL;
    node_skl    *   pN;
    XLAT_CTXT       MyContext( this, pContext );


#ifdef trace_cg
    printf("..node_source,\t%s\n", GetSymName());
#endif

    pCG =  (CG_CLASS *) new CG_SOURCE( this );

    //
    // for each of the children.
    //

    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        pChildCG    = pN->ILxlate( &MyContext );

        if ( pChildCG )
            {
            if (pPrevChildCG)
                {
                pPrevChildCG->SetSibling( pChildCG );
                }
            else
                {
                pCG->SetChild(pChildCG);
                };

            pPrevChildCG    = pChildCG;
            while ( ( pNew = pPrevChildCG->GetSibling() ) != 0 )
                pPrevChildCG = pNew;
            }
        }

    pContext->ReturnSize( MyContext );

    return pCG;
};


//--------------------------------------------------------------------
//
// node_echo_string::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_echo_string::ILxlate( XLAT_CTXT* )
{

#ifdef trace_cg
    printf("..node_echo_string,\t%s\n", GetSymName());
#endif

return 0;
};


//--------------------------------------------------------------------
//
// node_error::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_error::ILxlate( XLAT_CTXT* )
{

#ifdef trace_cg
    printf("..node_error,\t%s\n", GetSymName());
#endif

return 0;
};


CG_CLASS *
Transform(
    IN              node_skl    *   pIL )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    This routine performs the translation from the type graph into the
    code generation classes.

 Arguments:

    pIL     - a pointer to the il tranformer controlling structure.

 Return Value:

    A pointer to the new code generator class.

 Notes:

    This method should be called only on placeholder nodes like struct / proc
    interface, file etc.

----------------------------------------------------------------------------*/

{
    XLAT_CTXT   MyContext;

#ifdef trace_cg
    printf("transforming...\n");
#endif

    pReUseDict  = new REUSE_DICT;
    
    return pIL->ILxlate( &MyContext );
};


//--------------------------------------------------------------------
//
// node_library::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_library::ILxlate( XLAT_CTXT * pContext )
{
    MEM_ITER MemIter(this);
#ifdef trace_cg
    printf("..node_library,\t%s\n", GetSymName());
#endif
    XLAT_CTXT MyContext( this, pContext);

    if ( pCommand->IsNDR64Run() )
        {
        if ( !pCommand->NeedsNDRRun() )
            {
            
            SemError( this, MyContext , NDR64_ONLY_TLB, GetSymName() );        
            }
        return NULL;
        }

    MyContext.SetAncestorBits(IL_IN_LIBRARY);
    XLAT_CTXT  ChildContext( MyContext );

    // don't pass the interface attributes down...
    // save them off elsewhere

    ChildContext.SetInterfaceContext( &MyContext );

    CG_LIBRARY * pLib = new CG_LIBRARY(this, MyContext);

    named_node * pN;

    CG_CLASS * pLast    = NULL;
    CG_CLASS * pChild   = 0;

    while ( ( pN = MemIter.GetNext() ) != 0 )
    {
        switch(pN->NodeKind())
        {
        case NODE_FORWARD:
            {
                node_interface_reference * pIRef = (node_interface_reference *)pN->GetChild();
                if (pIRef)
                    {
                    if (pIRef->NodeKind() == NODE_INTERFACE_REFERENCE)
                        {
                            // create a CG_INTEFACE_REFERENCE node that points to this node
                            pChild = new CG_INTERFACE_REFERENCE(pIRef, ChildContext);
                            // make sure that the interface gets ILxlated.
                            CG_CLASS * pRef = pIRef->GetRealInterface()->ILxlate(&ChildContext);
                            pChild->SetSibling(pRef);
                        }
                    else 
                        {
                        if (pIRef->NodeKind() == NODE_COCLASS)
                            {
                                // don't process this type early
                                pChild = NULL;
                            }
                        else
                            {
                                pChild = pN->ILxlate(&ChildContext);
                                if (pChild && pChild->GetSibling())
                                    pChild = NULL;
                            }
                        }
                    }
                else
                    {
                    pChild = 0;
                    }
            }
            break;
        case NODE_INTERFACE:
            {
                pChild = pN->ILxlate(&ChildContext);
                // skip over inherited interfaces
                while (pChild && pChild->GetCGID() == ID_CG_INHERITED_OBJECT_INTERFACE)
                    pChild=pChild->GetSibling();
            }
            break;
        default:
            // create the appropriate CG node
            pChild = pN->ILxlate(&ChildContext);
            if (pChild && pChild->GetSibling())   // We must have already entered this one.
                pChild = NULL; 
            break;
        }
        // attach the CG_NODE to the end of my child list
        if (NULL != pChild && pChild != pLast)
        {
            if (pLast)
            {
                pLast->SetSibling(pChild);
            }
            else
            {
                pLib->SetChild(pChild);
            }
            pLast = pChild;
            // advance past the end of the list
            while (pLast->GetSibling())
                pLast = pLast->GetSibling();
        }
    }

    SetCG(FALSE, pLib);
    SetCG(TRUE, pLib);

    return pLib;
}

//--------------------------------------------------------------------
//
// node_module::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_module::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_module,\t%s\n", GetSymName());
#endif

    CG_NDR          *   pcgModule    = NULL;
    CG_CLASS        *   pCG             = NULL;
    CG_CLASS        *   pChildCG        = NULL;
    CG_CLASS        *   pPrevChildCG    = NULL;
    MEM_ITER            MemIter( this );
    node_skl        *   pN;
    XLAT_CTXT           MyContext( this, pContext );
    XLAT_CTXT           ChildContext( MyContext );
    
    MyContext.ExtractAttribute( ATTR_GUID );
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
    while (MyContext.ExtractAttribute(ATTR_TYPE));
    // clear member attributes
    while (MyContext.ExtractAttribute(ATTR_MEMBER));

    // don't pass the interface attributes down...
    // save them off elsewhere

    ChildContext.SetInterfaceContext( &MyContext );

    // if we already got spit out, don't do it again...
    if ( GetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY) ) )
        return NULL;

    // generate our CG node

    pcgModule = new CG_MODULE(this, MyContext);

    // store a pointer to our CG node
    SetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY), pcgModule );

    //
    // for each of the members.
    //

    while ( ( pN = MemIter.GetNext() ) != 0 )
    {
        pChildCG    = pN->ILxlate( &ChildContext );

        if ( pChildCG )
        {
            if (NODE_PROC == pN->NodeKind())
            {
                ((CG_PROC *)pChildCG)->SetProckind(PROC_STATIC);
            }
            AddToCGList( pChildCG, &pCG, &pPrevChildCG );
        }
    }

    // consume all the interface attributes
    MyContext.ClearAttributes();
    pContext->ReturnSize( MyContext );

    pcgModule->SetChild(pCG);

    return pcgModule;
}

//--------------------------------------------------------------------
//
// node_coclass::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_coclass::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_coclass,\t%s\n", GetSymName());
#endif
    CG_NDR          *   pcgCoclass    = NULL;
    CG_CLASS        *   pCG             = NULL;
    CG_CLASS        *   pChildCG        = NULL;
    CG_CLASS        *   pPrevChildCG    = NULL;
    MEM_ITER            MemIter( this );
    node_skl        *   pN;
    XLAT_CTXT           MyContext( this, pContext );
    XLAT_CTXT           ChildContext(MyContext);
    MyContext.ExtractAttribute( ATTR_GUID );
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
    while (MyContext.ExtractAttribute(ATTR_TYPE));
    // clear member attributes
    while (MyContext.ExtractAttribute(ATTR_MEMBER));
    
    // don't pass the interface attributes down...
    // save them off elsewhere

    ChildContext.SetInterfaceContext( &MyContext );
    // if we already got spit out, don't do it again...
    if ( GetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY) ) )
        return NULL ;

    // generate our CG node

    pcgCoclass = new CG_COCLASS(this, MyContext);

    // store a pointer to our CG node
    SetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY), pcgCoclass );

    //
    // for every member of the coclass
    //

    node_skl * pChild = 0;
    while ( ( pN = MemIter.GetNext()) != 0 )
        {
        pChild = pN;
        while(NODE_FORWARD == pChild->NodeKind() || NODE_HREF == pChild->NodeKind())
            {
            pChild = pChild->GetChild();
            if ( !pChild )
                {
                XLAT_CTXT ChildErrContext( pN, &MyContext ); 
                SemError( pN, ChildErrContext, UNSATISFIED_FORWARD, pN->GetSymName() );
                exit( UNSATISFIED_FORWARD );
                }
            }
        pChildCG    = pChild->ILxlate( &ChildContext );
        if (pChild->IsInterfaceOrObject())
        {
//            pChildCG = ((node_interface * )pChild)->GetCG(TRUE);
            pChildCG = new CG_INTERFACE_POINTER(this, (node_interface *)pChild );
        }
/*
        if ( pChildCG && NODE_DISPINTERFACE == pChild->NodeKind())
        {
            pChildCG = new CG_INTERFACE_POINTER(this, pChild, NULL);
            //((node_dispinterface *) pChild)->GetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY) );
        }
*/
        if ( pChildCG )
            AddToCGList( pChildCG, &pCG, &pPrevChildCG );
        }

    // consume all the interface attributes
    MyContext.ClearAttributes();
    pContext->ReturnSize( MyContext );

    pcgCoclass->SetChild(pCG);

    return pcgCoclass;
}

//--------------------------------------------------------------------
//
// node_dispinterface::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_dispinterface::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_dispinterface,\t%s\n", GetSymName());
#endif

    CG_NDR          *   pcgInterface    = NULL;
    CG_CLASS        *   pCG             = NULL;
    CG_CLASS        *   pChildCG        = NULL;
    CG_CLASS        *   pPrevChildCG    = NULL;
    CG_CLASS        *   pcgDispatch     = NULL;
    MEM_ITER            MemIter( this );
    node_skl        *   pN;
    XLAT_CTXT           MyContext( this, pContext );
    XLAT_CTXT           BaseContext( MyContext );  // context passed to IDispatch
    XLAT_CTXT           ChildContext( MyContext );
    node_guid       *   pGuid       = (node_guid *)
                                            MyContext.ExtractAttribute( ATTR_GUID );
    GUID_STRS           GuidStrs;
    NODE_T              ChildKind;

    node_interface          *   pBaseIntf;
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
    while (MyContext.ExtractAttribute(ATTR_TYPE));
    // clear member attributes
    while (MyContext.ExtractAttribute(ATTR_MEMBER));

    if (pGuid)
        GuidStrs = pGuid->GetStrs();

    // don't pass the interface attributes down...
    // save them off elsewhere

    BaseContext.SetInterfaceContext( &MyContext );
    ChildContext.SetInterfaceContext( &MyContext );

    // if we already got spit out, don't do it again...
    if ( GetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY) ) )
        return NULL;

    //
    // ILxlate IDispatch
    //
    pcgDispatch = GetIDispatch()->ILxlate(&BaseContext);
    pcgDispatch = ((node_interface *)GetIDispatch())->GetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY) );

    // generate our CG node

    pcgInterface = new CG_DISPINTERFACE(this, GuidStrs,(CG_OBJECT_INTERFACE *)pcgDispatch);

    // store a pointer to our CG node
    SetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY), pcgInterface );

    // Either we have a single base interface, or we have no base interface.

    pN = MemIter.GetNext();
    if (pN)
    {
        ChildKind = pN->NodeKind();
        if (ChildKind == NODE_FORWARD)
        {
            // We have a base interface
            pBaseIntf = (node_interface *)GetMyBaseInterfaceReference();
            // process the base interface
            if (pBaseIntf)
            {
                pChildCG = pBaseIntf->ILxlate(&ChildContext);
                if ( pChildCG )
                    AddToCGList( pChildCG, &pCG, &pPrevChildCG );
            }
        }
    }

    //
    // for each of the procedures.
    //

    while( pN )
        {
        ChildKind = pN->NodeKind();

        // proc nodes may hang under node_id's
        if( (ChildKind == NODE_FIELD) ||
            ( ChildKind == NODE_PROC )  ||
            ( ( ChildKind == NODE_ID ) && ( pN->GetChild()->NodeKind() == NODE_PROC ) ) )
            {
            pChildCG    = pN->ILxlate( &ChildContext );

            if ( pChildCG )
                AddToCGList( pChildCG, &pCG, &pPrevChildCG );
            }

        pN = MemIter.GetNext();
        }

    // consume all the interface attributes
    MyContext.ClearAttributes();
    pContext->ReturnSize( MyContext );

    pcgInterface->SetChild(pCG);

    return pcgInterface;
}

//--------------------------------------------------------------------
//
// node_pipe::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_pipe::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_pipe,\t%s\n", GetSymName());
#endif

    CG_CLASS     *  pChildCG;
    XLAT_CTXT       MyContext( this, pContext );
    CG_PIPE      *  pCG = new CG_PIPE   (
                                        this,
                                        MyContext
                                        );
    // if /deny is not specified, ignore [range]
    // if [range] is not ignored, new format string is
    // generated for pipes.
    if ( pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
        {
        pCG->SetRangeAttribute( ( node_range_attr* ) MyContext.ExtractAttribute( ATTR_RANGE ) );
        }
    pChildCG = GetChild()->ILxlate( &MyContext );

    pContext->ReturnSize( MyContext );
    pCG->SetChild( pChildCG );

    return pCG;
};

//--------------------------------------------------------------------
//
// node_safearray::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_safearray::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_safearray,\t%s\n", GetSymName());
#endif

    CG_CLASS     *  pChildCG;
    XLAT_CTXT       MyContext( this, pContext );
    CG_SAFEARRAY *  pCG = new CG_SAFEARRAY(this, MyContext);

    // SAFEARRAY, being defined in the public IDL files, has a known
    // alignment of 4. Now the struct etc. that embeds the SAFEARRAY
    // may have a different alignment but the struct code will make it
    // right by choosing min(ZeePee, max(children)).
    // The child of the node is a type specifier from SAFEARRAY(type).
    // The type alias is the LPSAFEARRAY

    pCG->SetMemoryAlignment( 4 );

    MyContext.GetMemAlign() = 4;
    pContext->ReturnSize( MyContext );

    pChildCG = GetChild()->ILxlate( &MyContext );

    pCG->SetChild( pChildCG );

    // If the SAFEARRAY was not used in a proxy, just pass up the SAFEARRAY class.  
    if ( ! fInProxy )
        return pCG;

    // If the SAFEARRAY was used in a proxy, pass up the the annoted node for
    // LPSAFEARRAY.

    CG_NDR *pTypeAliasCG = (CG_NDR*) ( GetTypeAlias()->ILxlate( pContext ) );

    MIDL_ASSERT( pTypeAliasCG->GetCGID() == ID_CG_USER_MARSHAL );

    CG_USER_MARSHAL *pUserMarshalCG = (CG_USER_MARSHAL *)pTypeAliasCG;

    pUserMarshalCG->SetTypeDescGenerator( pCG );
    
    return pUserMarshalCG;
}


CG_CLASS*
node_async_handle::ILxlate(  XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_async_handle,\t%s\n", GetSymName());
#endif
    XLAT_CTXT           MyContext( this, pContext );
    CG_ASYNC_HANDLE*    pAsyncHdl = new CG_ASYNC_HANDLE( this, MyContext );

    return pAsyncHdl;
}

CG_CLASS*
node_midl_pragma::ILxlate( XLAT_CTXT* )
{
    return 0;
}

CG_CLASS*
node_decl_guid::ILxlate( XLAT_CTXT* )
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\pickle.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:
    
    pickle.cxx

 Abstract:

    Generates stub routines to call the pickle engine.

 Notes:


 History:

    Mar-22-1994 VibhasC     Created

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

#pragma warning ( disable : 4127 )

#include "szbuffer.h"

/****************************************************************************
 *  local definitions
 ***************************************************************************/

/****************************************************************************
 *  local data
 ***************************************************************************/

/****************************************************************************
 *  externs
 ***************************************************************************/
/****************************************************************************/


CG_STATUS
CG_ENCODE_PROC::GenClientStubV1(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate DCE style procedure pickling stub code for the V1 interpreter.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

        CG_OK

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();

    // Register this procedure as a proc-encoding procedure.

    pCCB->RegisterEncodeDecodeProc( this );

    // Generate the format strings.

    MIDL_ASSERT( pCommand->IsNDRRun() );
    GenNdrFormat( pCCB );

    // Print the prolog of procedure.

    Out_ClientProcedureProlog( pCCB, GetType() );

    // If there exists a return type, declare a local resource of that
    // type.

    if( GetReturnType() )
        {
        node_id *node = MakeIDNode( RETURN_VALUE_VAR_NAME, GetReturnType()->GetType() );

        pStream->Write( "    " );
        node->PrintType(
                                (PRT_PARAM_WITH_TYPE | PRT_CSTUB_PREFIX),
                                pStream,
                                (node_skl *)0 );
        pStream->NewLine();
        }

    //
    // The V1 interpreter calls NdrMesProcEncodeDecode and passes the addresses
    // of all the parameters that were passed to the stub.
    //

    GenMesProcEncodeDecodeCall( pCCB, PROC_PLATFORM_V1_INTERPRETER );

    GenEpilog( pCCB );

    return CG_OK;
}


CG_STATUS
CG_ENCODE_PROC::GenClientStub(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate DCE style procedure pickling stub code.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    CG_OK
    
 Notes:

----------------------------------------------------------------------------*/
{
    if ( ! ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) )
        return GenClientStubV1( pCCB );

    ISTREAM         *   pStream = pCCB->GetStream();

    // Register this procedure as a proc-encoding procedure.

    pCCB->RegisterEncodeDecodeProc( this );

    // Generate the format strings.

    if ( pCommand->IsNDRRun() )
        {
        GenNdrFormat( pCCB );
        }
    else
        {
        pCCB->GetNdr64Format()->Generate( this );
        }

    // Print the prolog of procedure.

    Out_ClientProcedureProlog( pCCB, GetType() );

    // If there exists a return type, declare a local resource of that
    // type.

    if( GetReturnType() || HasComplexReturnType() )
        {
        pStream->IndentInc();

            if ( HasComplexReturnType() )
                {
                pStream->NewLine();
                ( (node_proc *) GetType() )
                        ->GetReturnType()->PrintType(PRT_DECL, pStream);
                }
            else
                pStream->WriteOnNewLine( "CLIENT_CALL_RETURN " );

        pStream->Write( RETURN_VALUE_VAR_NAME ";" );
        pStream->IndentDec();
        pStream->NewLine( 2 );
        }

    // Generate ia64 or x86 code

    if (  pCommand->Is64BitEnv() )
        {
        GenMesProcEncodeDecodeCall( pCCB, PROC_PLATFORM_IA64) ;
        }
    else
        {
        GenMesProcEncodeDecodeCall( pCCB, PROC_PLATFORM_X86 );
        }

    if ( GetReturnType() || HasComplexReturnType() )
        {
        CG_NDR*     pNdr;
        node_skl*   pType;

        if ( GetReturnType() )
            {
            pNdr = (CG_NDR *) GetReturnType()->GetChild();
            pType = GetReturnType()->GetType();
            }

        pStream->NewLine( 2 );
        pStream->Write("return ");

        //
        // byval structures, unions, floats, doubles
        //

        if ( HasComplexReturnType() )
            {
            pStream->Write( RETURN_VALUE_VAR_NAME ";");
            }

        //
        // Base type return value.
        //
        else if ( pNdr->IsSimpleType() )
            {
            pType->PrintType( PRT_CAST_TO_TYPE, pStream );
            pStream->Write( RETURN_VALUE_VAR_NAME ".Simple;" );
            }
        //
        // old-style byval structs and unions
        //
        else if ( pNdr->IsStruct() || pNdr->IsUnion() )
            {
            expr_node * pExpr;

            pExpr = new expr_variable( RETURN_VALUE_VAR_NAME ".Pointer" );

            pExpr = MakeDerefExpressionOfCastPtrToType( pType, pExpr );

            pExpr->Print( pStream );

            pStream->Write( ';' );
            }
        //
        // Otherwise pointer or array.
        //
        else
            {
            pType->PrintType( PRT_CAST_TO_TYPE, pStream );
            pStream->Write( RETURN_VALUE_VAR_NAME ".Pointer;" );
            }
        }

    pStream->IndentDec();
    pStream->WriteOnNewLine("}");

    return CG_OK;
}


CG_STATUS
CG_ENCODE_PROC::GenMesProcEncodeDecodeCall(
    CCB *               pCCB,
    PROC_CALL_PLATFORM  Platform )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate DCE style procedure pickling stub code.

 Arguments:

    pCCB        - The code gen controller block.
    Platform    - ia64, etc

 Return Value:

    CG_OK
    
 Notes:

----------------------------------------------------------------------------*/
{
    expr_proc_call  *   pProc;
    node_skl        *   pType;
    expr_node       *   pExpr;
    CG_ITERATOR         I;
    CG_PARAM        *   pCG;
    ISTREAM         *   pStream = pCCB->GetStream();
    PNAME               pHandleName;
    RESOURCE        *   pReturnResource = 0;
    bool                fOutputConstantZero = true;

    //
    // Generate a call to the single encode proc engine call.

    if ( pCommand->NeedsNDR64Run() )
        pProc = new expr_proc_call( "NdrMesProcEncodeDecode3" );
    else if ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) 
        pProc = new expr_proc_call( PROC_ENCODE_DECODE_RTN_NAME2 );
    else
        pProc = new expr_proc_call( PROC_ENCODE_DECODE_RTN_NAME );

    // Handle. If the handle is explicit, then it must be a MIDL_ES_HANDLE

    if( GetHandleUsage() == HU_EXPLICIT )
        {
        pHandleName = SearchForBindingParam()->GetName();
        pType   = MakeIDNodeFromTypeName( pHandleName,
                                          MIDL_ES_HANDLE_TYPE_NAME );
        }
    else
        {
        MIDL_ASSERT( pCCB->GetInterfaceCG()->GetImplicitHandle() != 0 );

        pType = (node_id *)pCCB->GetInterfaceCG()->GetImplicitHandle()->
                                                        GetHandleIDOrParam();
        pHandleName = pType->GetSymName();
        }

    pProc->SetParam( new expr_variable( pHandleName, pType ) );

    // ProcEncodeDecode3 needs a proxy info and a proc number.  1 and 2
    // need a stub descriptor and a format string

    if ( pCommand->NeedsNDR64Run() )
        {
        long ProcNum = GetProcNum();

        pExpr = new expr_variable(pCCB->GetInterfaceCG()->GetProxyInfoName());
        pExpr = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr = MakeExpressionOfCastToTypeName(
                                        PMIDL_PROXY_INFO_TYPE_NAME, 
                                        pExpr);

        pProc->SetParam( new expr_param( pExpr ) );
        pProc->SetParam( new expr_param( new expr_constant( ProcNum ) ) );

        if ( HasComplexReturnType() )
            {
            pExpr = new expr_variable( RETURN_VALUE_VAR_NAME );
            pExpr = MakeAddressExpressionNoMatterWhat( pExpr );
            }
        else
            {
            pExpr = new expr_param( new expr_constant( (long) 0 ) );
            }

        pProc->SetParam( pExpr );
        }
    else
        {
        // Stub descriptor.

        pExpr   = new RESOURCE( pCCB->GetInterfaceCG()->GetStubDescName(),
                                (node_skl *)0 );

        pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr   = MakeExpressionOfCastToTypeName( PSTUB_DESC_STRUCT_TYPE_NAME,
                                                      pExpr );

        pProc->SetParam( pExpr );

        // Offset into the format string.

        pExpr   =  Make_1_ArrayExpressionFromVarName(
                                        PROC_FORMAT_STRING_STRING_FIELD,
                                        GetFormatStringOffset() );

        pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr   = MakeExpressionOfCastToTypeName( 
                                        PFORMAT_STRING_TYPE_NAME, 
                                        pExpr );
        pProc->SetParam( pExpr );
        }

    switch ( Platform ) 
        {
    case PROC_PLATFORM_V1_INTERPRETER:
        {
        // Parameters to the engine are the address of each of the parameters to
        // this procedure. If there is no parameter AND no return type, push a
        // null (0).

        if( GetMembers( I ) )
            {
            fOutputConstantZero = false;
            while( ITERATOR_GETNEXT( I, pCG ) )
                {
                pExpr   = new expr_variable( pCG->GetType()->GetSymName(),
                                              pCG->GetType());
                pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
                pExpr   = MakeCastExprPtrToUChar( pExpr );
                pProc->SetParam( pExpr );
                }
            }
        break;
        }

    case PROC_PLATFORM_IA64:
        {
        // Parameters to the engine are the actual parameter to this
        // this procedure. If there is no parameter AND no return type, push a
        // null (0).

        if( GetMembers( I ) )
            {
            fOutputConstantZero = false;
            while( ITERATOR_GETNEXT( I, pCG ) )
                {
                pExpr   = new expr_variable( pCG->GetType()->GetSymName(),
                                              pCG->GetType());
                pProc->SetParam( pExpr );
                }
            }
        break;
        }

    default:    // PROC_PLATFORM_DEFAULT (i.e. x86)
        {
        CG_PARAM * pParam = (CG_PARAM *) GetChild();

        if (NULL != pParam)
            {
            fOutputConstantZero = false;
            pExpr = new expr_variable( pParam->GetType()->GetSymName(), pParam->GetType() );
            pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
            pExpr   = MakeCastExprPtrToUChar( pExpr );
            pProc->SetParam( pExpr );
            }
        }
        break;
        }

    //
    // If there is a return value, for the V1 interpreter add another 
    // parameter to the generated procedure expression.  For the V2
    // interpreter assign the return value from the engine to the local 
    // return value variable.
    //

    expr_node *pFinalExpr = pProc;

    if( GetReturnType() && !HasComplexReturnType() )
        {

        if ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) 
            {
            pFinalExpr = new expr_assign(
                                new expr_variable( RETURN_VALUE_VAR_NAME ),
                                pProc );
            }
        else
            {
            pReturnResource = new RESOURCE( RETURN_VALUE_VAR_NAME,
                                            GetReturnType()->GetType() );
            pExpr   = MakeAddressExpressionNoMatterWhat( pReturnResource );
            pExpr   = MakeCastExprPtrToUChar( pExpr );
            pProc->SetParam( pExpr );
            }
        }
    else if (fOutputConstantZero )
        {
        pProc->SetParam( new expr_constant( 0L ) );
        }

    // Now print the call out.

    pStream->IndentInc();
    pStream->NewLine();

    pFinalExpr->PrintCall( pStream, 0, 0 );

    pStream->NewLine();
    pStream->IndentDec();

    return CG_OK;
}



CG_STATUS
CG_TYPE_ENCODE_PROC::GenClientStub(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the client side type encoding stub for this proc.

 Arguments:

    pCCB    - The code gen controller block.


 Return Value:

    CG_OK
    
 Notes:

    This proc node hanging under the encode interface node is really a dummy
    proc, put in so that the format string generator can have a placeholder
    node to look at.
----------------------------------------------------------------------------*/
{
    return ((CG_PARAM *)GetChild())->GenTypeEncodingStub( pCCB );
}


CG_STATUS
CG_PARAM::GenTypeEncodingStub(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the client side type encoding stub for this param.

 Arguments:

    pCCB    - The code gen controller block.


 Return Value:

    CG_OK
    
 Notes:

    This param is really a dummy param, put in so that the format string
    generator can have a placeholder node to look at.
----------------------------------------------------------------------------*/
{
    CG_STATUS   Status;
    CG_NDR  *   pLast = pCCB->SetLastPlaceholderClass( this );

    Status =  ((CG_TYPE_ENCODE *)GetChild())->GenTypeEncodingStub( pCCB );

    pCCB->SetLastPlaceholderClass( pLast );

    return Status;
}


CG_STATUS
CG_TYPE_ENCODE::GenTypeEncodingStub(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the pickling stubs for a given type.

 Arguments:

    pCCB    - A pointer to the code generator control block.

 Return Value:

    CG_OK
    
 Notes:

    Emit the Type_Encode(), Type_Size() and Type_Decode() routines.
    If the encode is needed, then sizing is needed too !.
----------------------------------------------------------------------------*/
{
    CG_NDR  *   pChild  = (CG_NDR *)GetChild();

    // Generate the ndr format for the types.

    if( ! pChild->IsSimpleType() )
        {
        if ( pCommand->IsNDRRun() )
            pChild->GenNdrFormat( pCCB );
        else
            pCCB->GetNdr64Format()->Generate( pChild );

        // Register this type so we can output a table of type offsets later

        if ( pCommand->NeedsNDR64Run() )
            TypeIndex = pCCB->RegisterPickledType( this );
        }

    // Check if implicit binding exists.

    if( pCCB->GetInterfaceCG()->GetImplicitHandle() )
        {
        SetHasImplicitHandle();
        }

    // Create a resource dictionary database.

    pCCB->SetResDictDatabase( new RESOURCE_DICT_DATABASE );
    pCCB->ClearParamResourceDict();

    if ( ! pCCB->HasTypePicklingInfoBeenEmitted()  && 
                ( pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) )
        {
        Out_TypePicklingInfo( pCCB );
        pCCB->SetTypePicklingInfoEmitted();
        }

    // If the type has [encode] on it, generate the sizing and encode routines.

    if( IsEncode() )
        {
        // Allocate standard resources for type encoding.

        AllocateEncodeResources( pCCB );

        // Generate the sizing and encode routines.

        GenTypeSize( pCCB );
        GenTypeEncode( pCCB );

        }

    pCCB->ClearParamResourceDict();

    // If the type has [decode] on it, generate the decode routine.

    if( IsDecode() )
        {
        // Allocate standard resources for type decoding.

        AllocateEncodeResources( pCCB );

        GenTypeDecode( pCCB );
        GenTypeFree( pCCB );
        }

    return CG_OK;
}


CG_STATUS
CG_TYPE_ENCODE::GenTypeSize(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the type sizing routine for the type.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    CG_OK
    
 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    PNAME       pName;
    TYPE_ENCODE_INFO    *   pTEInfo = new TYPE_ENCODE_INFO;

    // Generate the standard prototype. This really means emit the proto of
    // the proc in the stub file. Remember, a real proc node does not exist
    // for this pickling type. So we emit a prototype by hand (so to speak).
    // The body of the function is output later,

    GenStdMesPrototype( pCCB,
                        (pName = GetType()->GetSymName()),
                        TYPE_ALIGN_SIZE_CODE,
                        HasImplicitHandle()
                      );

    pStream->NewLine();
    pStream->Write( '{' );
    pStream->IndentInc();
    pStream->NewLine();

    // The procedure body consists of a single procedure call.

    expr_proc_call *   pProc = CreateStdMesEngineProc( pCCB, TYPE_ALIGN_SIZE_CODE);

    pStream->Write( "return " );
    pProc->PrintCall( pStream, 0, 0 );

    // Terminate the procedure body.

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( '}' );
    pStream->NewLine();

    // Register the routine with the ccb to enable emitting of prototypes.

    pTEInfo->pName = pName;
    pTEInfo->Flags = HasImplicitHandle() ? TYPE_ENCODE_WITH_IMPL_HANDLE : TYPE_ENCODE_FLAGS_NONE;
    pCCB->RegisterTypeAlignSize( pTEInfo );

    return CG_OK;

}


CG_STATUS
CG_TYPE_ENCODE::GenTypeEncode(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the type encoding routine for the type.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    CG_OK
    
 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    PNAME       pName;
    TYPE_ENCODE_INFO    *   pTEInfo = new TYPE_ENCODE_INFO;

    // Generate the standard prototype. This really means emit the proto of
    // the proc in the stub file. The body of the function output later,

    GenStdMesPrototype( pCCB,
                        (pName = GetType()->GetSymName()),
                        TYPE_ENCODE_CODE,
                        HasImplicitHandle()
                      );

    pStream->NewLine();
    pStream->Write( '{' );
    pStream->IndentInc();pStream->NewLine();

    // The procedure body consists of a single procedure call.

    expr_proc_call *   pProc = CreateStdMesEngineProc( pCCB, TYPE_ENCODE_CODE);

    pProc->PrintCall( pCCB->GetStream(), 0, 0 );

    // Terminate the procedure body.

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( '}' );
    pStream->NewLine();

    // Register the routine with the ccb to enable emitting of prototypes.

    pTEInfo->pName = pName;
    pTEInfo->Flags = HasImplicitHandle() ? TYPE_ENCODE_WITH_IMPL_HANDLE : TYPE_ENCODE_FLAGS_NONE;
    pCCB->RegisterTypeEncode( pTEInfo );

    return CG_OK;

}


CG_STATUS
CG_TYPE_ENCODE::GenTypeDecode(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the type sizing routine for the type.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    CG_OK
    
 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    PNAME       pName;
    TYPE_ENCODE_INFO    *   pTEInfo = new TYPE_ENCODE_INFO;

    // Generate the standard prototype. This really means emit the proto of
    // the proc in the stub file. The body of the function output later,

    GenStdMesPrototype( pCCB,
                        ( pName = GetType()->GetSymName()),
                        TYPE_DECODE_CODE,
                        HasImplicitHandle()
                       );

    pStream->NewLine();
    pStream->Write( '{' );
    pStream->IndentInc();pStream->NewLine();

    // The procedure body consists of a single procedure call.

    expr_proc_call *   pProc = CreateStdMesEngineProc( pCCB, TYPE_DECODE_CODE);

    pProc->PrintCall( pCCB->GetStream(), 0, 0 );

    // Terminate the procedure body.

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( '}' );
    pStream->NewLine();

    // Register the routine with the ccb to enable emitting of prototypes.

    pTEInfo->pName = pName;
    pTEInfo->Flags = HasImplicitHandle() ? TYPE_ENCODE_WITH_IMPL_HANDLE : TYPE_ENCODE_FLAGS_NONE;
    pCCB->RegisterTypeDecode( pTEInfo );

    return CG_OK;

}


CG_STATUS
CG_TYPE_ENCODE::GenTypeFree( CCB* pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the type freeing routine for the type.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    CG_OK
    
 Notes:

----------------------------------------------------------------------------*/
{
    // Freeing is only allowed under the new intrepreter

    if ( ! ( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER_V2 ) )
        return CG_OK;

    ISTREAM *   pStream = pCCB->GetStream();
    PNAME       pName;
    TYPE_ENCODE_INFO    *   pTEInfo = new TYPE_ENCODE_INFO;

    // Generate the standard prototype. This really means emit the proto of
    // the proc in the stub file. The body of the function output later,

    if ( ((CG_NDR *)GetChild())->IsSimpleType() )
        return CG_OK;

    GenStdMesPrototype( pCCB,
                        ( pName = GetType()->GetSymName()),
                        TYPE_FREE_CODE,
                        HasImplicitHandle()
                       );

    pStream->NewLine();
    pStream->Write( '{' );
    pStream->IndentInc();pStream->NewLine();

    // The procedure body consists of a single procedure call.

    expr_proc_call *   pProc = CreateStdMesEngineProc( pCCB, TYPE_FREE_CODE);

    pProc->PrintCall( pCCB->GetStream(), 0, 0 );

    // Terminate the procedure body.

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( '}' );
    pStream->NewLine();

    // Register the routine with the ccb to enable emitting of prototypes.

    pTEInfo->pName = pName;
    pTEInfo->Flags = HasImplicitHandle() ? TYPE_ENCODE_WITH_IMPL_HANDLE : TYPE_ENCODE_FLAGS_NONE;
    pCCB->RegisterTypeFree( pTEInfo );

    return CG_OK;
}

void
CG_TYPE_ENCODE::AllocateEncodeResources(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Allocate predefined resources for type pickling.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    CG_OK
    
 Notes:

    Resources are:

    1. The MIDL_ES_HANDLE if explicit binding.
    2. A pointer to the type.

    If there is no explicit binding set the implicit binding resource.
----------------------------------------------------------------------------*/
{
    node_id         *   pMidlESHandle;
    RESOURCE        *   pBindingResource;
    node_id         *   pType           = MakeIDNode( PTYPE_VAR_NAME,GetType());

    // If explicit binding, then a parameter of the type MIDL_ES_HANDLE will
    // be specified by the user. This must be added to the dictionary of
    // parameter resources.

    if( !HasImplicitHandle() )
        {
        pMidlESHandle   = MakeIDNodeFromTypeName( MIDL_ES_HANDLE_VAR_NAME,
                                                  MIDL_ES_HANDLE_TYPE_NAME
                                                );
        pBindingResource = pCCB->AddParamResource(
                                                  MIDL_ES_HANDLE_VAR_NAME,
                                                  pMidlESHandle
                                                 );
        }
    else
        {

        PNAME   pName;

        // If an implicit binding has been specified, a global variable of the
        // type MIDL_ES_HANDLE will have been specified by the user. Pick that
        // up and use as the binding resource.

        MIDL_ASSERT( pCCB->GetInterfaceCG()->GetImplicitHandle() != 0 );

        pMidlESHandle =
           (node_id *)pCCB->GetInterfaceCG()->
                                GetImplicitHandle()->
                                    GetHandleIDOrParam();
        pName   = pMidlESHandle->GetSymName();

        pBindingResource = new RESOURCE( pName,
                                         MakeIDNodeFromTypeName(
                                                    pName,
                                                    MIDL_ES_HANDLE_TYPE_NAME));

        }

    SetBindingResource( pBindingResource );

    // Add a param for the type being pickled.

    pCCB->AddParamResource( PTYPE_VAR_NAME, pType );
}


expr_proc_call *
CG_TYPE_ENCODE::CreateStdMesEngineProc(
    CCB *   pCCB,
    int     Code )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Create a standard proc expression for calls to the engine for encode, 
    decode, align/size, and free.

 Arguments:

    pCCB        -   The code gen controller block.
    Code        -   Which can be any standard encoding services code.

 Return Value:

    CG_OK
    
 Notes:

    If the child is a base type that is being pickled, make direct calls
    to the internal apis.

    In -Oicf mode the emitted stub looks like the following with Encode
    changed to whichever operation [Code] specifies:

        void
        <typename>_Encode(
                        <object>)
        {
            NdrMesTypeEncodeXXX();
        }

    For pre -Oicf modes the <&type_pickling_info> parameter is omitted.

----------------------------------------------------------------------------*/
{
    expr_node       *   pExpr;
    expr_proc_call  *   pProc;
    PNAME               pProcName;
    CG_NDR          *   pChild  = (CG_NDR *)GetChild();
    CSzBuffer           ProcNameBuf;
    BOOL                fIsBaseType;
    bool                fNeedPicklingInfoParam = false;
    int                 fNeedsNDR64;

    fIsBaseType = pChild->IsSimpleType();
    fNeedsNDR64 = pCommand->NeedsNDR64Run();

    // 
    // Figure out what the name of the routine to call is
    //

    PNAME pNdrMesProcNames[4] = 
        {
        "NdrMesTypeAlignSize",
        "NdrMesTypeEncode",
        "NdrMesTypeDecode",
        "NdrMesTypeFree"
        };

    if ( fIsBaseType )
        {
        MIDL_ASSERT( Code != TYPE_FREE_CODE );

        ProcNameBuf.Set("NdrMesSimpleType");
        ProcNameBuf.Append((Code == TYPE_ALIGN_SIZE_CODE) ? "AlignSize" :
                    (Code == TYPE_ENCODE_CODE) ? "Encode" : "Decode");

        if ( fNeedsNDR64 )
            {
            ProcNameBuf.Append( "All" );
            }           
        }
    else
        {
        ProcNameBuf.Set( pNdrMesProcNames[Code] );

        // -protocol all and ndr64 uses "3" routines.
        // -Oicf in straight dce mode uses "2" routines
        // otherwise uses unnumbered routines

        if ( fNeedsNDR64 )
            {
            ProcNameBuf.Append( "3" );
            fNeedPicklingInfoParam = true;
            }   
        else if ( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER_V2 )
            {
            ProcNameBuf.Append( "2" );
            fNeedPicklingInfoParam = true;
            }
        else
            {
            MIDL_ASSERT( TYPE_FREE_CODE != Code );
            }
        }

    pProcName = new char [strlen( ProcNameBuf ) + 1];
    strcpy( pProcName, ProcNameBuf );

    //
    // Start putting together the proc call
    //

    pProc = new expr_proc_call( pProcName );

    // Set parameters. 
    
    // First the encoding handle. 

    pProc->SetParam( GetBindingResource() );

    // Then pickling info structure

    if( fNeedPicklingInfoParam )
        {
        pExpr   = new RESOURCE( PICKLING_INFO_STRUCT_NAME,
                                (node_skl *)0 );

        pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr   = MakeExpressionOfCastToTypeName( PMIDL_TYPE_PICKLING_INFO_NAME,
                                                  pExpr );

        pProc->SetParam( pExpr );
        }

    // Next the stub descriptor or the proxy info

    if ( !fIsBaseType || fNeedsNDR64 || Code == TYPE_ENCODE_CODE )
        {
        PNAME StubOrProxy;

        if ( fNeedsNDR64 )
            StubOrProxy = pCCB->GetInterfaceCG()->GetProxyInfoName();
        else
            StubOrProxy = pCCB->GetInterfaceCG()->GetStubDescName();

        pExpr   = new RESOURCE( StubOrProxy,
                                (node_skl *)0 );

        pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );

        pProc->SetParam( pExpr );
        }
    
    // Next in straight dce, if it's not a simple type, comes the offset into
    // the format string of the type

    if( !fNeedsNDR64 && !fIsBaseType )
        {
        // Next parameter is the address of the format string indexed by the
        // correct offset i.e &__MIDLFormatString[ ? ].

        pExpr   =  Make_1_ArrayExpressionFromVarName(FORMAT_STRING_STRING_FIELD,
                                                     pChild->GetFormatStringOffset());
        pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr   = MakeExpressionOfCastToTypeName( PFORMAT_STRING_TYPE_NAME, pExpr );
        pProc->SetParam( pExpr );

        }

    // For -protocol all or ndr64, the table of type offset tables is next
    // followed by the index of this type into the tables.

    if ( fNeedsNDR64 && !fIsBaseType )
        {
        pExpr = new RESOURCE( "TypePicklingOffsetTable", NULL );
        pProc->SetParam( pExpr );

        pExpr = new expr_constant( this->TypeIndex );
        pProc->SetParam( pExpr );
        }

    // Now for everything except simply type AlignSize, we need the object
    // itself

    if ( ! (fIsBaseType  &&  Code == TYPE_ALIGN_SIZE_CODE) )
        {
        pExpr = pCCB->GetParamResource( PTYPE_VAR_NAME );
        pProc->SetParam( pExpr );
        }

    // Data size for simple type encoding and decoding

    if ( fIsBaseType )
        {
        switch ( Code )
            {
            case TYPE_ALIGN_SIZE_CODE:
                break;

            case TYPE_ENCODE_CODE:
                {
                pExpr = new expr_constant( (short) pChild->GetMemorySize() );
                pProc->SetParam( pExpr );

                }
                break;

            case TYPE_DECODE_CODE:
                // We need format char because of conversion.

                pExpr = new expr_constant( (short)
                                 ((CG_BASETYPE *)pChild)->GetFormatChar() );
                pProc->SetParam( pExpr );
                break;

            default:
                MIDL_ASSERT( FALSE );
                break;
            }
        }

    return pProc;
}


void
GenStdMesPrototype(
    CCB *   pCCB,
    PNAME   TypeName,
    int     Code,
    BOOL    fImplicitHandle )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a standard prototype for the type pickle routines.

 Arguments:

    pCCB            - The code gen controller block.
    PNAME           - Name of the type.
    Code            - Size / Encode / Decode code.
    fImplicitImplicitHandle - TRUE if implicit binding handle used.

 Return Value:
    
 Notes:

----------------------------------------------------------------------------*/
    {
    CSzBuffer   Buffer;
    char    *   p;

    switch( Code )
        {
        case TYPE_ALIGN_SIZE_CODE: p = "AlignSize"; break;
        case TYPE_ENCODE_CODE: p = "Encode"; break;
        case TYPE_DECODE_CODE: p = "Decode"; break;
        case TYPE_FREE_CODE:   p = "Free"; break;
        default:
            MIDL_ASSERT( FALSE );
        }

    if( fImplicitHandle )
        {
        Buffer.Set("\n");
        Buffer.Append((Code == TYPE_ALIGN_SIZE_CODE) ? "size_t" : "void");
        Buffer.Append("\n");
        Buffer.Append(TypeName);
        Buffer.Append("_");
        Buffer.Append(p);
        Buffer.Append("(\n    ");
        Buffer.Append(TypeName);
        Buffer.Append(" * ");
        Buffer.Append(PTYPE_VAR_NAME);
        Buffer.Append(")");
        }
    else
        {
        Buffer.Set("\n");
        Buffer.Append((Code == TYPE_ALIGN_SIZE_CODE) ? "size_t" : "void");
        Buffer.Append("\n");
        Buffer.Append(TypeName);
        Buffer.Append("_");
        Buffer.Append(p);
        Buffer.Append("(\n    ");
        Buffer.Append(MIDL_ES_HANDLE_TYPE_NAME);
        Buffer.Append(" ");
        Buffer.Append(MIDL_ES_HANDLE_VAR_NAME);
        Buffer.Append(",\n    ");
        Buffer.Append(TypeName);
        Buffer.Append(" * ");
        Buffer.Append(PTYPE_VAR_NAME);
        Buffer.Append(")");
        }

    pCCB->GetStream()->Write( Buffer );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\proccls.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

        proccls.cxx

 Abstract:

        Implementation of offline methods for the proc / param code generation
        classes.

 Notes:

 History:

        Sep-14-1993             VibhasC         Created.
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *      include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

extern CMD_ARG * pCommand;

/* 
    These flags could be picked up from the actual rpcdcep.h file.
    However, this would give us a bad dependency and the flags cannot change anyway
    because of backward compatibility reasons: in the interpreted modes the value
    of the flag is used in format strings, not the name like in the -Os code.
*/

#define RPC_NCA_FLAGS_DEFAULT       0x00000000  /* 0b000...000 */
#define RPC_NCA_FLAGS_IDEMPOTENT    0x00000001  /* 0b000...001 */
#define RPC_NCA_FLAGS_BROADCAST     0x00000002  /* 0b000...010 */
#define RPC_NCA_FLAGS_MAYBE         0x00000004  /* 0b000...100 */

#define RPCFLG_MESSAGE              0x01000000
#define RPCFLG_INPUT_SYNCHRONOUS    0x20000000
// the following flag is now redundant
// #define RPCFLG_ASYNCHRONOUS         0x40000000


/****************************************************************************/

/****************************************************************************
 *      procedure class methods.
 ***************************************************************************/
CG_PROC::CG_PROC(
        unsigned int    ProcNumber,
        node_skl        *       pProc,
        CG_HANDLE       *       pBH,
        CG_PARAM        *       pHU,
        BOOL                    fIn,
        BOOL                    fOut,
        BOOL                    fAtLeastOneShipped,
        BOOL                    fHasStat,
        BOOL                    fHasFull,
        CG_RETURN       *       pRT,
        OPTIM_OPTION    OptimFlags,
        unsigned short  OpBits, 
        BOOL            fDeny
        ) : 
        CG_NDR(pProc, XLAT_SIZE_INFO() ),
        fHasAsyncHandle( FALSE ),
        fHasDeny( fDeny ),
        fHasAsyncUUID( FALSE ),
        uNotifyTableOffset( 0 )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

        Constructor for the parm cg class.

 Arguments:

        ProcNumber                      - The procedure number in the interface.
        pProc                           - a pointer to the original node in the type graph.
        pBH                                     - a pointer to a binding handle cg class.
        pHU                                     - the usage of the handle, a CG_PARAM or NULL
        fIn                                     - flag specifying at least one in param.
        fOut                            - flag specifying at least one out param.
        fAtLeastOneShipped      - flag specifying that at least one param is shipped.
        fHasStat                        - flag for any comm/fault statuses on return or params
        pRT                                     - pointer to CG_PARAM or NULL.
        OptimFlags                      - optimization flags for this proc

 Return Value:

        NA.

 Notes:

        The procedure number is the lexical sequence number of the procedure as
        specified in the interface, not counting the callback procedures. The
        type of the procnum matches the corresponding field of the rpc message.

----------------------------------------------------------------------------*/
{
    SetProcNum( ProcNumber );
    SetHandleClassPtr( pBH );
    SetHandleUsagePtr( pHU );
    SetOptimizationFlags( OptimFlags );
    SetOperationBits( OpBits );
    SetHasFullPtr( fHasFull );
    SetProckind(PROC_PUREVIRTUAL);

    fNoCode         = FALSE;
    fHasNotify      = FALSE;
    fHasNotifyFlag  = FALSE;
    fReturnsHRESULT = FALSE;

    fHasStatuses    = fHasStat;
    fHasExtraStatusParam  = 0;
    fOutLocalAnalysisDone = 0;
    pCallAsName     = NULL;

    if( fIn == TRUE )
        SetHasAtLeastOneIn();
    else
        ResetHasAtLeastOneIn();

    if( fOut == TRUE )
        SetHasAtLeastOneOut();
    else
        ResetHasAtLeastOneOut();

    SetReturnType( pRT );

    if( fAtLeastOneShipped )
        {
        SetHasAtLeastOneShipped();
        }
    else
        ResetHasAtLeastOneShipped();

    SetSStubDescriptor( 0 );
    SetCStubDescriptor( 0 );
    SetStatusResource( 0 );

    SetFormatStringParamStart(-1);

    SetMustInvokeRpcSSAllocate( 0 );

    SetRpcSSSpecified( 0 );

    SetContextHandleCount( 0 );

    SetHasPipes( 0 );
    fSupressHeader = FALSE;
    pSavedProcFormatString = NULL;
    pSavedFormatString = NULL;
    cRefSaved = 0;
    pCallAsType = NULL;

    fHasServerCorr = FALSE;
    fHasClientCorr = FALSE;

    fIsBeginProc = FALSE;
    fIsFinishProc = FALSE;
    pAsyncRelative = NULL;

    pCSTagRoutine = NULL;

    fHasComplexReturn = FALSE;
}

char    *
CG_PROC::GetInterfaceName()
        {
        return GetInterfaceNode()->GetSymName();
        }

BOOL CG_PROC::SetHasPipes(BOOL f)
        {
        if (f)
            GetInterfaceNode()->SetHasPipes(TRUE);
        return (fHasPipes = f);
        }

short
CG_PROC::GetInParamList(
        ITERATOR&       I )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

        Get the list of [in] parameters.

 Arguments:

        I       - An iterator supplied by the caller.

 Return Value:

        Count of the number of in parameters.

 Notes:

----------------------------------------------------------------------------*/
{
        CG_ITERATOR             I1;
        CG_PARAM        *       pParam;
        short                   Count = 0;

        //
        // Get all the members of this cg class and pick ones which are in params.
        //

        GetMembers( I1 );

        ITERATOR_INIT( I1 );

        while( ITERATOR_GETNEXT( I1, pParam ) )
                {
                if( pParam->IsParamIn() && (pParam->GetType()->GetBasicType()->NodeKind() != NODE_VOID) )
                        {
                        ITERATOR_INSERT( I, pParam );
                        Count++;
                        }
                }
        return Count;
}

short
CG_PROC::GetOutParamList(
        ITERATOR&       I )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

        Get the list of [out] parameters.

 Arguments:

        I       - An iterator supplied by the caller.

 Return Value:

        Count of the number of out parameters.

 Notes:

----------------------------------------------------------------------------*/
{
        CG_ITERATOR             I1;
        CG_PARAM        *       pParam;
        short                   Count = 0;

        //
        // Get all the members of this cg class and pick ones which are out params.
        //

        GetMembers( I1 );

        ITERATOR_INIT( I1 );

        while( ITERATOR_GETNEXT( I1, pParam ) )
                {
                if( pParam->IsParamOut() )
                        {
                        ITERATOR_INSERT( I, pParam );
                        Count++;
                        }
                }
        return Count;
}

long
CG_PROC::GetTotalStackSize(
     CCB  * pCCB 
     )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
----------------------------------------------------------------------------*/
{
    //
    // Figure out the total stack size of all parameters.
    //
    CG_ITERATOR Iterator;
    CG_PARAM *  pParam;
    long        Size;
    BOOL        f64 = pCommand->Is64BitEnv();

    GetMembers( Iterator );

    Size = 0;

    pParam = 0;

    // Get the last parameter.
    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        ;

    if ( pParam )
        {
        Size += pParam->GetStackOffset( pCCB, I386_STACK_SIZING ) +
                pParam->GetStackSize();
        if ( f64 )
            Size = (Size + 7) & ~ 0x7;
        else
            Size = (Size + 3) & ~ 0x3;
        }
    else
        if ( IsObject() )
            {
            //
            // If our stack size is still 0 and we're an object proc then
            // add in the 'this' pointer size.
            //
            Size = SIZEOF_PTR( f64 );
            }

    if ( ( pParam = GetReturnType() ) != 0 )
        {
        Size += pParam->GetStackSize();
        if ( f64 )
            Size = (Size + 7) & ~ 0x7;
        else
            Size = (Size + 3) & ~ 0x3;
        }

    return Size;
}


BOOL
CG_PROC::MustUseSingleEngineCall(
         CCB    *       pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

        Must we generate code for a single call to the marshalling engine routine ?

 Arguments:

        pCCB    - A pointer to the code gen controller block.

 Return Value:

        TRUE if one call is recommended.
        FALSE otherwise.

 Notes:

        If all parameters recommend that a single engine call be used, then
        recommend that.
----------------------------------------------------------------------------*/
{
    return (pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER);
}

BOOL
CG_PROC::UseOldInterpreterMode( CCB* )
{
#ifdef TEMPORARY_OI_SERVER_STUBS
    return TRUE;
#else //  TEMPORARY_OI_SERVER_STUBS
    return FALSE;
#endif //  TEMPORARY_OI_SERVER_STUBS
}

BOOL
CG_PROC::NeedsServerThunk( CCB *    pCCB,
                           CGSIDE   Side )
{
    OPTIM_OPTION OptimizationFlags = GetOptimizationFlags();

    // -Os
    if ( ( ( (unsigned long)OptimizationFlags ) & OPTIMIZE_INTERPRETER ) == 0 )
        return FALSE;


    if ( (Side == CGSIDE_CLIENT) && (GetCGID() != ID_CG_CALLBACK_PROC) )
        return FALSE;

    pCCB->SetCGNodeContext( this );

    // not -Oicf
    if ( !( OptimizationFlags & OPTIMIZE_INTERPRETER_V2 ) )
        {
        long x86StackSize = GetTotalStackSize( pCCB );

        //
        // Now check if the parameter size threshold is exceeded on any of the
        // four platforms.  On the Alpha and win64 we allow a size twice as big to
        // compensate for the 8 byte aligned stacks.  The interpreter has the
        // necessary #ifdefs to handle this anomoly.
        // We ignore non-server platforms.

        long x86Limit;

        x86Limit = (long)(pCommand->Is64BitEnv() ? INTERPRETER_THUNK_PARAM_SIZE_THRESHOLD * 2
                                                 : INTERPRETER_THUNK_PARAM_SIZE_THRESHOLD);

        if ( x86StackSize > x86Limit )
            {
            return TRUE;
            }
        }

    return OptimizationFlags & OPTIMIZE_THUNKED_INTERPRET;
}


expr_node *
CG_PROC::GenBindOrUnBindExpression(
        CCB             *       pCCB,
        BOOL            fBind )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

        Create the final binding expression for the procedure.

 Arguments:

        pCCB    - A pointer to the code gen controller block.
        fBind   - TRUE if called for binding, FALSE for unbinding.

 Return Value:

        The final expression.

 Notes:

        1. If the procedure is an auto binding handle procedure, then the final
           binding expression is the address of the AutoBindVariable.
        2. If the handle is a generic handle, then the binding expression is the
           call to the generic bind routine.
        3. If the handle is a context handle, then the bindiing expression is the
           NDRCContextBinding Expression.


        The Binding expression is passed on to the initialize routine or the
        single call engine routine.

----------------------------------------------------------------------------*/
{
    expr_node       *       pExpr   = 0;

    if( IsAutoHandle() )
        {
        if( fBind == TRUE )
            {
            RESOURCE * pR = pCCB->GetStandardResource( ST_RES_AUTO_BH_VARIABLE );

            // Make the code generator believe we have a binding resource.
            SetBindingResource( pR );
            }
        }
    else if( IsGenericHandle() )
        {

        // For a generic handle, the expression is the call to the generic
        // handle bind routine. To do this, we need to send the message to
        // the handle param to generate the parameter passed to this routine
        // and then generate an expression for the call to the procedure.

        ITERATOR        I;
        PNAME           p;
        node_skl*       pType   = ((CG_GENERIC_HANDLE *)GetHandleClassPtr())->GetHandleType();
        char    *       pName   = pType->GetSymName();

        if( GetHandleUsage() == HU_IMPLICIT )
            {
            node_skl * pID;

            if( (pID = pCCB->GetImplicitHandleIDNode()) == 0 )
                {
                pID = pCCB->SetImplicitHandleIDNode(
                                 GetHandleClassPtr()->GetHandleIDOrParam() );
                }
            pExpr   = new expr_variable( pID->GetSymName() );
            }
        else
            {

            // An explicit parameter is specified for the binding handle.

            pExpr   = ((CG_NDR *)SearchForBindingParam())->GenBindOrUnBindExpression    (
                                                                                        pCCB,
                                                                                        fBind
                                                                                        );

            // Register this genric handle with the ccb.

            }

        pCCB->RegisterGenericHandleType( pType );

        ITERATOR_INSERT( I, pExpr );

        // For unbind we have to specify the original binding handle variable
        // also as a parameter.

        if( fBind == FALSE )
            {
            RESOURCE * pTR = GetBindingResource();
            ITERATOR_INSERT( I, pTR );
            }

        // Generate the name: Type_bind;

        p       = new char [ strlen(pName) + 10 ];
        strcpy( p, pName );
        strcat( p, fBind ? "_bind" : "_unbind" );

        pExpr = MakeProcCallOutOfParamExprList( p,
                                                GetType(),
                                                I
                                              );
        if( fBind == TRUE )
            {
            pExpr = new expr_assign( GetBindingResource(), pExpr );
            }
        }
    else if(IsPrimitiveHandle() )
        {

        // This should never be called for an unbind request.

        MIDL_ASSERT( fBind == TRUE );

        // may be an explicit or implicit primitive handle.

        if( GetHandleUsage() == HU_IMPLICIT )
            {
            node_skl * pID;

            if( (pID = pCCB->GetImplicitHandleIDNode()) == 0 )
                {
                pID = pCCB->SetImplicitHandleIDNode(
                                 GetHandleClassPtr()->GetHandleIDOrParam() );
                }
            pExpr   = new expr_variable( pID->GetSymName() );
            }
        else
            {

            // The binding handle parameter derives the expression.
            pExpr   = ((CG_NDR *)SearchForBindingParam())->
                                GenBindOrUnBindExpression( pCCB, fBind );
            }

        if( fBind == TRUE )
            {
            pExpr = new expr_assign( GetBindingResource(), pExpr );
            }
        }
    else
        {
        // Context handles.
        // This method should never be called on an unbind.
        MIDL_ASSERT( fBind == TRUE );

        node_skl* pType = ((CG_CONTEXT_HANDLE *)GetHandleClassPtr())->GetHandleType();
        if( pType->NodeKind() == NODE_DEF )
            {
            pCCB->RegisterContextHandleType( pType );
            }
        }

    return pExpr;
}

unsigned int
CG_PROC::TranslateOpBitsIntoUnsignedInt()
        {
        unsigned int    OpBits  = GetOperationBits();
        unsigned int    Flags   = RPC_NCA_FLAGS_DEFAULT;

        if( OpBits & OPERATION_MAYBE )
                {
                Flags |= RPC_NCA_FLAGS_MAYBE;
                }

        if( OpBits & OPERATION_BROADCAST )
                {
                Flags |= RPC_NCA_FLAGS_BROADCAST;
                }

        if( OpBits & OPERATION_IDEMPOTENT )
                {
                Flags |= RPC_NCA_FLAGS_IDEMPOTENT;
                }

        if( OpBits & OPERATION_MESSAGE )
                {
                Flags |= RPCFLG_MESSAGE;
                pCommand->GetNdrVersionControl().SetHasMessageAttr();
                }

        if( OpBits & OPERATION_INPUT_SYNC )
                {
                Flags |= RPCFLG_INPUT_SYNCHRONOUS;
                }

        return Flags;
        }

BOOL
CG_PROC::HasInterpreterDeferredFree()
{
    CG_ITERATOR Iterator;
    CG_PARAM *  pParam;

    GetMembers( Iterator );

    //
    // Just check for pointers to basetypes for now.  Eventually we'll have
    // to check if a pointer to basetype actually occurs in any *_is
    // expression.
    //
    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        if ( ((CG_NDR *)pParam->GetChild())->IsPointerToBaseType() )
            return TRUE;
        }

    // Don't have to check return type since it can't be part of a *_is
    // expression.

    return FALSE;
}

/****************************************************************************
 *      parameter class methods.
 */

CG_PARAM::CG_PARAM(
    node_skl      *     pParam,
    PARAM_DIR_FLAGS     Dir,
    XLAT_SIZE_INFO &    Info,
    expr_node *         pSw,
    unsigned short      Stat 
    )  
    : CG_NDR( pParam, Info ),
    fIsAsyncHandle( FALSE ),
    fSaveForAsyncFinish( false )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Constructor for the parm cg class.

 Arguments:

    pParam  - a pointer to the original node in the type graph.
    Dir     - the direction : IN_PARAM, OUT_PARAM or IN_OUT_PARAM
    WA      - wire alignment.
    pSw     - any switch_is expression on the param
    Stat    - any comm/fault statuses on the param

 Notes:

----------------------------------------------------------------------------*/
{
    //
    // set the direction indicator for quick future reference.
    //
    fDirAttrs       = Dir;

    fDontCallFreeInst    = 0;
    fInterpreterMustSize = 1;
    fIsExtraStatusParam  = 0;
    fIsForceAllocate    = FALSE;

    // save the optional attributes; switch_is, comm/fault statuses

    pSwitchExpr = pSw;
    Statuses    = Stat;

    //
    // initialize phase specific information array.
    //

    SetFinalExpression( 0 );
    SetSizeExpression( 0 );
    SetSizeResource(0);
    SetLengthResource(0);
    SetFirstResource(0);
    SetSubstitutePtrResource(0);

    SetUnionFormatStringOffset(-1);

    SetParamNumber( -1 );

    SetIsCSSTag( FALSE );
    SetIsCSDRTag( FALSE );
    SetIsCSRTag( FALSE );
    SetIsOmittedParam( FALSE );
}

expr_node *
CG_PARAM::GenBindOrUnBindExpression(
        CCB     *       pCCB,
        BOOL    fBind )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

        Generate the binding expression.

 Arguments:

        pCCB    - A pointer to the code generator controller block.
        fBind   - bool to indicate a bind or unbind generation.

 Return Value:

 Notes:

        Actually for a param node, the expression remains the same whether it
        is being called for a bind or unbind.
----------------------------------------------------------------------------*/
{
    RESOURCE *  pR = pCCB->GetParamResource( GetType()->GetSymName() );

    MIDL_ASSERT( pR != 0 );

    pCCB->SetSourceExpression( pR );

    return ((CG_NDR *)GetChild())->GenBindOrUnBindExpression( pCCB, fBind );
}

long
CG_PARAM::GetStackOffset(
    CCB * pCCB,
    long  PlatformForSizing )
/*++

Routine Description :

        Returns the offset on the stack to the parameter.

--*/
{
    CG_ITERATOR     Iterator;
    CG_PROC *       pProc;
    CG_PARAM *      pParam;
    CG_NDR *        pNdr;
    long            Offset;
    long            Align;

    BOOL  fForIA64  = pCommand->Is64BitEnv() && 
                             (PlatformForSizing & I386_STACK_SIZING);

    pProc = (CG_PROC *) pCCB->GetCGNodeContext();

    //
    // If this is a cs_tag param and there is a tag routine it is not
    // pushed on the stack.
    //

    if ( this->IsSomeCSTag() && pProc->GetCSTagRoutine() )
        return 0;

    pProc->GetMembers( Iterator );

    Offset = 0;

    //
    // Add in size of 'this' pointer for object procs.
    //
    if ( pProc->IsObject() )
        {
        Offset += fForIA64 ? 8 : 4;
        }

    Align = 0x3;

    // Override for ia64.
    if ( fForIA64 )
        Align = 0x7;

    pParam = 0;

    for ( ; ITERATOR_GETNEXT( Iterator, pParam );
            Offset += Align, Offset = Offset & ~ Align )
        {
        if ( pParam->IsSomeCSTag() && pProc->GetCSTagRoutine() )
            continue;

        pNdr = (CG_NDR *) pParam->GetChild();

        //
        // For CG_CSARRAY, the size is the size of the underlying type
        //

        if ( pNdr->GetCGID() == ID_CG_CS_ARRAY )
            pNdr = (CG_NDR *) pNdr->GetChild();

        //
        // If this is a generic handle then re-set the ndr pointer to the
        // handle's child, which is what is actually being pushed on the
        // stack.
        //
        if ( pNdr->GetCGID() == ID_CG_GENERIC_HDL )
            pNdr = (CG_NDR *) pNdr->GetChild();

        // The IA64 stack rules as of Jan 14, 2000.
        // The following is a quote from ver. 2.5 of Intel's doc:
        //
        //     Table 8-1. Rules for Allocating Parameter Slots
        // ---------------------------------------------------------------------
        //     Type            Size(bits)  Slot         How many       Alignment
        // ---------------------------------------------------------------------
        // Integer/Pointer       1-64      next             1             LSB
        // Integer               65-128    next even        2             LSB
        // Single-Precision FP   32        next             1             LSB
        // Double-Precision FP   64        next             1             LSB
        // Double-Extended  FP   80        next even        2             byte 0
        // Quad-Precision FP     128       next even        2             byte 0
        // Aggregates            any       next aligned   (size+63)/64    byte 0
        // ---------------------------------------------------------------------
        //
        // Notes. 
        //  "next aligned" is for aggregates with alignment of 16 (becomes next even).
        //  The padding is always to a single slot boundary, padding is undefined.
        //  As of this writing the C++ compiler does not support any of these:
        //     __int128, float128, float80.
        //

        if ( fForIA64  )
            {
            // Slightly simplified rules as no int or FP is bigger than 64b.

            if ( (pNdr->GetMemoryAlignment() > 8)  &&
                 (pNdr->GetMemorySize() > 8)  &&
                 ! pNdr->IsArray() )
                {
                if (pNdr->IsStruct()  || pNdr->IsUnion()) 
                    {
                    Offset = (Offset + 15) & ~ 0xf;
                    }
                else if ( (pNdr->GetCGID() == ID_CG_TRANSMIT_AS) ||
                          (pNdr->GetCGID() == ID_CG_REPRESENT_AS) ||
                          (pNdr->GetCGID() == ID_CG_USER_MARSHAL) )
                    {
                    node_skl *  pPresented;

                    //
                    // Presented type alignment is 16 and
                    // Since we know the presented type is >= 8 bytes in
                    // size, we just have to make sure it's not an array
                    // (could be a large fixed array of alignment < 8).
                    //

                    if ( pNdr->GetCGID() == ID_CG_TRANSMIT_AS )
                        pPresented = ((CG_TRANSMIT_AS *)pNdr)->GetPresentedType();
                    else if ( (pNdr->GetCGID() == ID_CG_REPRESENT_AS) ||
                         (pNdr->GetCGID() == ID_CG_USER_MARSHAL) )
                        pPresented = ((CG_REPRESENT_AS *)pNdr)->GetRepAsType();

                    //
                    // We could have a null presented type for unknown rep_as.
                    // If it is null then the proc will have been changed
                    // to -Os and the stub won't need the stack sizes anyway.
                    //
                    if ( pPresented &&
                         (pPresented->GetBasicType()->NodeKind() != NODE_ARRAY) )
                        Offset = (Offset + 15) & ~ 0xf;
                    }
                }
            } // ia64

        //
        // Do the exit condition check AFTER the above three alignment checks.
        //

        if ( pParam == this )
            break;

        //
        // Add in the stack size of this parameter.
        //

        // If this is a pipe, then we need to ensure proper alignment and
        // then bump the stack by the size of the pipe structure
        // (four far pointers)

        if ( pNdr->GetCGID() == ID_CG_PIPE )
            {
            // Pipes don't need any special treatment on ia64.
            // For ia64 offset is already aligned to 8.

            Offset += 4 * SIZEOF_MEM_PTR();
            continue;
            }

        if ( pNdr->IsSimpleType() )
            {
            ((CG_BASETYPE *)pNdr)->IncrementStackOffset( &Offset );
            continue;
            }

        if ( pNdr->IsPointer() || pNdr->IsArray() ||
                         (pNdr->IsInterfacePointer() ) )
            {
            Offset += SIZEOF_MEM_PTR();
            continue;
            }

        if ( pNdr->IsStruct() || pNdr->IsUnion() || ID_CG_CS_TAG == pNdr->GetCGID() )
            {
            // Already aligned for the bigger-than-8 rule on ia64.

            Offset += pParam->GetStackSize();
            continue;
            }

        if ( pNdr->IsAHandle() )
            {
            //
            // We only get here for primitive and context handles.  For
            // primitive handles we know the pushed size is always 4.
            //
            // For context handles this is a major hassle and for now we assume
            // that the underlying user defined type is a pointer.
            //

            Offset += SIZEOF_MEM_PTR();
            continue;
            }

        if (pParam->IsAsyncHandleParam())
            {
            Offset += SIZEOF_MEM_PTR();
            continue;
            }

        if ( pNdr->GetCGID() == ID_CG_TRANSMIT_AS )
            {
            Offset += ((CG_TRANSMIT_AS *)pNdr)->GetStackSize();
            continue;
            }

        if ( pNdr->GetCGID() == ID_CG_REPRESENT_AS )
            {
            Offset += ((CG_REPRESENT_AS *)pNdr)->GetStackSize();
            continue;
            }

        if ( pNdr->GetCGID() == ID_CG_USER_MARSHAL )
            {
            Offset += ((CG_USER_MARSHAL *)pNdr)->GetStackSize();
            continue;
            }

        // Should never get here.
        MIDL_ASSERT(0);

        } //for

    return Offset;
}

long
CG_PARAM::GetStackSize()
/*++

Routine Description :

        Returns the size of the parameter.

--*/
{
    CG_NDR* pNdr      = (CG_NDR *) GetChild();

    // if this is a pipe then return the size of the pipe structure
    if ( pNdr->GetCGID() == ID_CG_PIPE )
        return (4 * SIZEOF_MEM_PTR());  // four pointers

    //
    // If this is a generic handle then re-set the ndr pointer to the
    // handle's child, which is what is actually being pushed on the
    // stack.  Same for CsArray's
    //
    if ( pNdr->GetCGID() == ID_CG_GENERIC_HDL 
         || pNdr->GetCGID() == ID_CG_CS_ARRAY )
        {
        pNdr = (CG_NDR *) pNdr->GetChild();
        }

    if ( pNdr->GetCGID() == ID_CG_TYPE_ENCODE )
        pNdr = (CG_NDR *) ((CG_TYPE_ENCODE *) pNdr)->GetChild();

    if ( pNdr->IsPointer() || pNdr->IsArray() ||
            (pNdr->IsInterfacePointer() ) )
        return SIZEOF_MEM_PTR();

    if ( pNdr->IsSimpleType() || pNdr->IsStruct() || pNdr->IsUnion() )
        return pNdr->GetMemorySize();

    if ( pNdr->IsAHandle() )
        {
        //
        // We only get here for primitive and context handles.  For
        // primitive handles we know the pushed size is always 4.
        //
        // For context handles this is a major hassle and for now we assume
        // that the underlying user defined type is a pointer.
        //

        return SIZEOF_MEM_PTR();
        }

    if ( pNdr->GetCGID() == ID_CG_TRANSMIT_AS )
        return ((CG_TRANSMIT_AS *)pNdr)->GetStackSize();

    if ( pNdr->GetCGID() == ID_CG_REPRESENT_AS )
        return ((CG_REPRESENT_AS *)pNdr)->GetStackSize();

    if ( pNdr->GetCGID() == ID_CG_USER_MARSHAL )
        return ((CG_USER_MARSHAL *)pNdr)->GetStackSize();

    if (IsAsyncHandleParam())
        return SIZEOF_MEM_PTR();

    return 0;
}



short CG_PROC::GetFloatArgMask( CCB * pCCB )
/*++
Routine Description:

    On Ia64 floating point types are passed in floating point registers 
    instead of general registers.  Just to make life difficult "homogenous
    floating point aggregates" (structs that only contain floats/doubles or
    other HFA's) are also passed in floating point registers.  Floating point
    registers are allocated sequentially and out of sync with general 
    registers so e.g. if the third paramater was the first floating point
    argument it would go in the first floating point register and a "hole" 
    would be left in the third general register.

    The floating point mask consists of a series of 2-bit nibbles, one for 
    each general register slot.  This nibble contains a 0 if the register slot
    does not have a floating point value, a 1 for single precsion, a 2 for
    double, and a 3 for dual singles.

--*/
{
    MIDL_ASSERT( pCommand->Is64BitEnv() );

    enum FloatType
    {
        NonFloat    = 0,
        Single      = 1,
        Double      = 2,
        DualSingle  = 3
    };

    CG_ITERATOR Iterator;
    CG_PARAM   *pParam;
    unsigned    mask = 0;
    int         floatslot = 0;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pParam ) && floatslot < 8 )
        {
        CG_NDR *pChild = (CG_NDR *) pParam->GetChild();

        bool issingle = pChild->IsHomogeneous(FC_FLOAT);
        bool isdouble = pChild->IsHomogeneous(FC_DOUBLE);

        if ( issingle || isdouble )
            {
            long      slot = pParam->GetStackOffset( pCCB, I386_STACK_SIZING );
            long      size = pParam->GetStackSize();
            FloatType type;

            slot /= 8;
            size /= (isdouble ? 8 : 4);

            while (size > 0 && floatslot < 8)
                {
                if (isdouble)
                    type = Double;
                else if (size > 1 && floatslot < 7)
                    type = DualSingle;
                else 
                    type = Single;

                mask |= type << (slot * 2);

                slot      += 1;
                size      -= 1 + (DualSingle == type);
                floatslot += 1 + (DualSingle == type);
                }
            }
        }

    return (short) (mask & 0xffff);
}



char *
CG_PROC::SetCallAsName( char * pName )
        {
        return (pCallAsName = pName);
        }

void
CG_PROC::GetCommAndFaultOffset(
    CCB *   pCCB,
    long &  CommOffset,
    long &  FaultOffset )
{
    CG_ITERATOR Iterator;
    CG_PARAM *  pParam;
    CG_NDR *    pOldCGNodeContext;

    //
    // 0 is of course a valid offset.
    // -1 offset means it is the return value.
    // -2 offset means it was not specified in the proc.
    //

    CommOffset = -2;
    FaultOffset= -2;

    if ( ! HasStatuses() )
        return;

    pOldCGNodeContext = pCCB->SetCGNodeContext( this );

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        if ( (pParam->GetStatuses() == STATUS_COMM) ||
             (pParam->GetStatuses() == STATUS_BOTH) )
            {
            CommOffset = pParam->GetStackOffset( pCCB, I386_STACK_SIZING );
            }

        if ( (pParam->GetStatuses() == STATUS_FAULT) ||
             (pParam->GetStatuses() == STATUS_BOTH) )
            {
            FaultOffset = pParam->GetStackOffset( pCCB, I386_STACK_SIZING );
            }
        }

    if ( ( pParam = GetReturnType() ) != 0 )
        {
        if ( (pParam->GetStatuses() == STATUS_COMM) ||
             (pParam->GetStatuses() == STATUS_BOTH) )
            {
            CommOffset = -1;
            }

        if ( (pParam->GetStatuses() == STATUS_FAULT) ||
             (pParam->GetStatuses() == STATUS_BOTH) )
            {
            FaultOffset = -1;
            }
        }

    pCCB->SetCGNodeContext( pOldCGNodeContext );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\procndr.cxx ===
/*---------------------------------------------------------------------------
 Copyright (c) 1993-2000 Microsoft Corporation

 Module Name:

    procndr.hxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    the code generation procedure class.

 Notes:


 History:

    DKays     Oct-1993     Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

#include "szbuffer.h"
#include "walkctxt.hxx"
#include <malloc.h>

extern CMD_ARG * pCommand;

void
CG_PROC::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Interpreted procedure format string descriptions.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{

    CG_ITERATOR             Iterator;
    CG_PARAM *              pParam;
    FORMAT_STRING *         pProcFormatString;
    CG_NDR *                pOldCGNodeContext;
    short                   ParamNum;
    long                    ServerBufferSize;
    long                    ClientBufferSize;
    long                    BufSize;
    BOOL                    fServerMustSize;
    BOOL                    fClientMustSize;
    INTERPRETER_OPT_FLAGS   InterpreterOptFlags;

    MIDL_ASSERT( !pCommand->IsNDR64Run() );    

    // make sure that call-as proc targets get processed when necessary.
    CG_PROC * pCallAs = GetCallAsCG();
    if (pCallAs)
        pCallAs->GenNdrFormat(pCCB);
        
    SetupFormatStrings(pCCB);

    if ( ! (GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2) )
        {
        // Generate -Os or -Oi format string.

        GenNdrFormatV1( pCCB );
        UnsetupFormatStrings(pCCB);
        return;
        }

    if ( GetFormatStringOffset() != -1 )
    {
        UnsetupFormatStrings(pCCB);
        return;
    }

    pCCB->SetInObjectInterface( IsObject() );

    pOldCGNodeContext = pCCB->SetCGNodeContext( this );

    //
    // If this procedure uses an explicit handle then set the
    // NdrBindDescriptionOffset to 0 so that it will not try to output it's
    // description when given the GenNdrParamOffLine method in the loop below.
    // It's description must be part of the procedure description.
    //
    if ( GetHandleUsage() == HU_EXPLICIT )
        {
        CG_HANDLE * pHandle = GetHandleClassPtr();

        pHandle->SetNdrBindDescriptionOffset( 0 );

        if ( pHandle->GetCGID() == ID_CG_CONTEXT_HDL )
            {
            // The context handle directs the call.
            ((CG_CONTEXT_HANDLE *)pHandle)->SetCannotBeNull();
            }
        }

    GetMembers( Iterator );

    ParamNum = 0;

    ServerBufferSize = 0;
    ClientBufferSize = 0;

    fServerMustSize = FALSE;
    fClientMustSize = FALSE;

    pCCB->SetInterpreterOutSize( 0 );

    //
    // Generate the offline portion of the format string for all of the params.
    //
    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;

        pChild = (CG_NDR *) pParam->GetChild();

        // Ignore the following type of arguments that don't go on wire:
        //  - async handles
        //  - primitive handles
        //  
        if ( pChild->GetCGID() == ID_CG_PRIMITIVE_HDL  || ( (CG_PARAM*) pParam)->IsAsyncHandleParam() )
            continue;

        pParam->SetParamNumber( ParamNum++ );

        pCCB->SetCurrentParam( (CG_PARAM *) pParam );
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pParam );

        pChild->GenNdrParamOffline( pCCB );
                               
        // A procedure's buffer size does not depend on pipe arguments
        if (pChild->IsPipeOrPipeReference())
            {
                if (pChild->GetChild()->HasAFixedBufferSize())
                    pParam->SetInterpreterMustSize(FALSE);
                else
                    // There must be a union in there somewhere 
                    pParam->SetInterpreterMustSize(TRUE);
            }
        else
            {            

            BufSize = pChild->FixedBufferSize( pCCB );

            if ( BufSize != -1 )
                {
                //
                // If either the client's or server's fixed buffer size gets too
                // big then we force the parameter to be sized.
                //
                if ( (pParam->IsParamIn() &&
                    ((ClientBufferSize + BufSize) >= 65356)) ||
                    (pParam->IsParamOut() &&
                    ((ServerBufferSize + BufSize) >= 65356)) )
                    {
                    fClientMustSize = TRUE;
                    fServerMustSize = TRUE;
                    }
                else
                    {
                    pParam->SetInterpreterMustSize( FALSE );
    
                    if ( pParam->IsParamIn() )
                        ClientBufferSize += BufSize;
                    if ( pParam->IsParamOut() )
                        ServerBufferSize += BufSize;
                    }
                }
            else
                {
                if ( pParam->IsParamIn() )
                    fClientMustSize = TRUE;
                if ( pParam->IsParamOut() )
                    fServerMustSize = TRUE;
                }
            }

        pCCB->SetCurrentParam( 0 );
        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    //
    // Generate the format string for the return type if needed.
    //
    if ( GetReturnType() )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;

        GetReturnType()->SetParamNumber( ParamNum++ );
        
        pChild = (CG_NDR *) GetReturnType()->GetChild();

        pCCB->SetCurrentParam( GetReturnType() );
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( GetReturnType() );

        pChild->GenNdrParamOffline( pCCB );

        BufSize = pChild->FixedBufferSize( pCCB );

        if ( BufSize != -1 )
            {
            if ( (ServerBufferSize + BufSize) >= 65536 )
                {
                fServerMustSize = TRUE;
                }
            else
                {
                ServerBufferSize += BufSize;
                GetReturnType()->SetInterpreterMustSize( FALSE );
                }
            }
        else
            fServerMustSize = TRUE;

        pCCB->SetCurrentParam( 0 );
        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    pCCB->SetCurrentParam( 0 );
    
    pProcFormatString = pCCB->GetProcFormatString();

    SetFormatStringOffset( pProcFormatString->GetCurrentOffset() );

    //
    // Generate procedure description stuff for the interpreter if needed.
    //
    if ( (pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER)
         ||  HasAPicklingAttribute() )
        {
        GenNdrFormatProcInfo( pCCB );

        // Client side constant buffer size.
        pProcFormatString->PushShort( ClientBufferSize );

        // Server side constant buffer size.
        pProcFormatString->PushShort( ServerBufferSize );
        }

    InterpreterOptFlags.ServerMustSize = (unsigned char) fServerMustSize;
    InterpreterOptFlags.ClientMustSize = (unsigned char) fClientMustSize;
    InterpreterOptFlags.HasReturn      = (unsigned char) (GetReturnType() != 0 ? 1 : 0);
    InterpreterOptFlags.HasPipes       = (unsigned char) HasPipes();
    InterpreterOptFlags.Unused         = (unsigned char) 0;
    InterpreterOptFlags.HasAsyncUuid   = (unsigned char) HasAsyncUUID();
    InterpreterOptFlags.HasAsyncHandle = (unsigned char) HasAsyncHandle();
    InterpreterOptFlags.HasExtensions  = (unsigned char) 
                                              (    HasDeny() 
                                                || HasNotify() 
                                                || HasNotifyFlag() 
                                                || HasComplexReturnType() );

    short floatmask = 0;

    if ( pCommand->Is64BitEnv() )
        {
        floatmask = GetFloatArgMask( pCCB );

        InterpreterOptFlags.HasExtensions = (unsigned char)
              InterpreterOptFlags.HasExtensions || (0 != floatmask);
        }

    // New procedure flags.
    pProcFormatString->PushOi2ProcFlagsByte( *((char *)&InterpreterOptFlags) );

    // Number of parameters.
    pProcFormatString->PushByte( ParamNum );

    if ( InterpreterOptFlags.HasExtensions )
        {
        // Extensions layout:
        //   size<1>
        //   flags<1>
        //   client correlation cache size hint<2>
        //   server correlation cache size hint<2>
        //   notify routine index<2>
        //
        INTERPRETER_OPT_FLAGS2   InterpreterOptFlags2;

        InterpreterOptFlags2.Unused             = 0;
        InterpreterOptFlags2.HasNewCorrDesc     = ( unsigned char )HasDeny();
        if ( InterpreterOptFlags2.HasNewCorrDesc )
            {
            InterpreterOptFlags2.ClientCorrCheck    = ( unsigned char )HasClientCorr();
            InterpreterOptFlags2.ServerCorrCheck    = ( unsigned char )HasServerCorr();
            }
        else
            {
            InterpreterOptFlags2.ClientCorrCheck    = 0;
            InterpreterOptFlags2.ServerCorrCheck    = 0;
            }
        InterpreterOptFlags2.HasNotify          = ( unsigned char )HasNotify();
        InterpreterOptFlags2.HasNotify2         = ( unsigned char )HasNotifyFlag();

        InterpreterOptFlags2.HasComplexReturn   = ( unsigned char )HasComplexReturnType();

        if ( pCommand->Is64BitEnv() )
            {
            pProcFormatString->PushByte( sizeof(NDR_PROC_HEADER_EXTS64) );
            }
        else
            {
            pProcFormatString->PushByte( sizeof(NDR_PROC_HEADER_EXTS) );
            }
        pProcFormatString->PushExtProcFlagsByte( *((char *)&InterpreterOptFlags2) );

        node_proc* pProcThis = (node_proc*) GetType();
        pProcFormatString->PushShort( short( pProcThis->GetClientCorrelationCount() ) );  // client
        pProcFormatString->PushShort( short( pProcThis->GetServerCorrelationCount() ) );  //server
#ifdef PRINT_METRICS
        printf  (
                "Client hint is %16d, Server hint is %16d, for %s\n",
                pProcThis->GetClientCorrelationCount(),
                pProcThis->GetServerCorrelationCount(),
                pProcThis->GetSymName()
                );
#endif

        if( HasNotify() || HasNotifyFlag() )
            GetNotifyTableOffset( pCCB );

        pProcFormatString->PushShort( (short)uNotifyTableOffset ); // notify index
        if ( pCommand->Is64BitEnv() )
            {
            pProcFormatString->PushShort( floatmask );
            }
        }

    SetFormatStringParamStart( pProcFormatString->GetCurrentOffset() );

    pCCB->SetInterpreterOutSize( 0 );

    ITERATOR_INIT( Iterator );
    //
    // Now generate the param info at the end of the format string.
    //
    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;

        if (pParam->IsAsyncHandleParam())
            continue;

        pChild = (CG_NDR *) pParam->GetChild();

        if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
            pChild = (CG_NDR *) pChild->GetChild();

        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pParam );

        pChild->GenNdrParamDescription( pCCB );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    if ( GetReturnType() )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;
        
        pChild = (CG_NDR *) GetReturnType()->GetChild();

        if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
            pChild = (CG_NDR *) pChild->GetChild();

        pOldPlaceholder = pCCB->SetLastPlaceholderClass( GetReturnType() );

        pChild->GenNdrParamDescription( pCCB );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    pCCB->SetCGNodeContext( pOldCGNodeContext );

    pCCB->SetInObjectInterface( FALSE );

    SetFormatStringEndOffset( pProcFormatString->GetCurrentOffset() );

    // save delta, in case the routine is optimized
    short   usParamStartDelta   = (short) ( GetFormatStringParamStart() -
                                            GetFormatStringOffset() );

    pProcFormatString->OptimizeFragment( this );

    // Set param start!!!
    SetFormatStringParamStart( GetFormatStringOffset() + usParamStartDelta );

    //
    // For interpreted procs we add some comments to the procedure format
    // strings to make the stubs easier to read.
    //

    if ( ! (pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER) )
        return;

    char *  pComment;
    long    FormatOffset;
    short   Bytes;

    Bytes = short(32 + strlen( GetSymName() ) );
    pComment = new char[Bytes];

    sprintf( pComment, "\n\t/* Procedure %s */\n\n", GetSymName() );
    pProcFormatString->AddComment( GetFormatStringOffset(), pComment );

    GetMembers( Iterator );

    FormatOffset = GetFormatStringParamStart();

    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        if ( pParam->GetCGID() == ID_CG_PRIMITIVE_HDL  || pParam->IsAsyncHandleParam() )
            continue;
        Bytes = short( 32 + strlen( pParam->GetSymName() ) );
        pComment = new char[Bytes];
        sprintf( pComment,
                 "\n\t/* Parameter %s */\n\n",
                 pParam->GetSymName() );
        pProcFormatString->AddComment( FormatOffset, pComment );
        FormatOffset += 6;
        }

    if ( GetReturnType() )
        {
        pProcFormatString->AddComment(
                FormatOffset, "\n\t/* Return value */\n\n" );
        }
    UnsetupFormatStrings(pCCB);
}

void
CG_PROC::GenNdrFormatProcInfo( CCB * pCCB )
/*++
    The layout is:

        handle type<1>
        Oi and pickling flags <1>
        [ rpc flags<4> ]
        proc num <2>
        stack size<2>
        [ explicit handle description <> ]
        [ notify table offset<2> ]
--*/
{
    FORMAT_STRING * pProcFormatString;
    
    SetupFormatStrings(pCCB);
    pProcFormatString = pCCB->GetProcFormatString();

    if ( IsObject() )
        {
        pProcFormatString->PushFormatChar( FC_AUTO_HANDLE );
        }
    else
        {
        if ( pCCB->IsInCallback() )
            {
            pProcFormatString->PushFormatChar( FC_CALLBACK_HANDLE );
            }
        else
            {
            if ( GetHandleUsage() == HU_IMPLICIT )
                {
                //
                // Implicit handle type.
                //
                if ( IsAutoHandle() )
                    pProcFormatString->PushFormatChar( FC_AUTO_HANDLE );
                if ( IsPrimitiveHandle() )
                    pProcFormatString->PushFormatChar( FC_BIND_PRIMITIVE );
                if ( IsGenericHandle() )
                    {
                    pProcFormatString->PushFormatChar( FC_BIND_GENERIC );

                    // implicit generic handle needs to be registered.

                    pCCB->RegisterGenericHandleType(
                                        GetHandleClassPtr()->GetHandleType() );
                    }
                }
            else
                pProcFormatString->PushByte( 0 );
            }
        }

    unsigned char OiFlags = 0;

    // Indicate if there is a need to init the full ptr or rpcss packages.
    if ( HasFullPtr() )
        OiFlags |= Oi_FULL_PTR_USED;

    if ( MustInvokeRpcSSAllocate() )
        OiFlags |= Oi_RPCSS_ALLOC_USED;

    if ( IsObject() )
        {
        OiFlags |= Oi_OBJECT_PROC;

        if ( !ReturnsHRESULT() )
            OiFlags |= Oi_IGNORE_OBJECT_EXCEPTION_HANDLING;

        if ( (GetOptimizationFlags() & OPTIMIZE_INTERPRETER)  &&
             (GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2) )
            OiFlags |= Oi_OBJ_USE_V2_INTERPRETER;
        }

    OiFlags |= Oi_HAS_RPCFLAGS;

    if ( GetCGID() == ID_CG_ENCODE_PROC )
        {
        if ( HasEncode() )
            OiFlags |= ENCODE_IS_USED;
        if ( HasDecode() )
            OiFlags |= DECODE_IS_USED;

        // The Oi_USE_NEW_INIT_ROUTINES and PICKLING_HAS_COMM_OR_FAULT flags
        // are overloaded.  In -Oicf mode, the new routines are always used
        // and the bit specifics comm/fault options (which overriden also).
        // In pre-Oicf comm/fault is not supported.

        if ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 )
            {
            if ( HasStatuses() )
                OiFlags |= PICKLING_HAS_COMM_OR_FAULT;
            }
        else
            {
            OiFlags |= Oi_USE_NEW_INIT_ROUTINES;
            }
        }
    else
        {
        // Always do this.
        OiFlags |= Oi_USE_NEW_INIT_ROUTINES;

        if ( HasStatuses() )
            OiFlags |= Oi_HAS_COMM_OR_FAULT;
        }

    pProcFormatString->PushOldProcFlagsByte( OiFlags );

    pProcFormatString->PushLong( (long) TranslateOpBitsIntoUnsignedInt() );

    // Proc num.
    pProcFormatString->PushShort( (short) GetProcNum() );

    long    Size = GetTotalStackSize( pCCB );

    //
    // Use a push ushort offset or size method which outputs a #ifdef for
    // the various platforms, for which stack offsets are often different.
    //
    pProcFormatString->PushUShortStackOffsetOrSize( Size );

    //
    // Output explicit handle description.
    //
    if ( GetHandleUsage() == HU_EXPLICIT && !IsObject() )
        {
        CG_NDR *    pOldPlaceholder;
        CG_HANDLE * pHandle;

        pHandle = GetHandleClassPtr();

        pOldPlaceholder = pCCB->SetLastPlaceholderClass( GetHandleUsagePtr() );

        pHandle->GenNdrHandleFormat( pCCB );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );

        //
        // Patch up a pointer to context handle's offset<2> field.
        //
        if ( pHandle->GetCGID() == ID_CG_CONTEXT_HDL )
            {
            CG_NDR *    pNdr;
            CG_NDR *    pPointer;

            // Get the handle param's first child node.
            pNdr = (CG_NDR *) GetHandleUsagePtr()->GetChild();
        
            pPointer = 0;

            while ( pNdr->IsPointer() )
                {
                pPointer = pNdr;
                pNdr = (CG_NDR *) GetChild();
                }
            
            if ( pPointer )
                {
                long    OffsetField;
            
                OffsetField = pPointer->GetFormatStringOffset() + 2;

                pCCB->GetFormatString()->PushShortOffset(
                        pHandle->GetFormatStringOffset() - OffsetField,
                        OffsetField );
                }
            }
        }
    UnsetupFormatStrings(pCCB);
}

//
// ##########################################################################
// ----- Interpreted client stub generation. -----###########################
// ##########################################################################
//

void
CG_PROC::GenNdrSingleClientCall( CCB * pCCB )
/*++

Routine Description :

    This is the top level routine for generating code for the single NDR call
    case on the client side.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{
    ISTREAM *           pStream;
    CG_ITERATOR         Iterator;
    expr_node       *   pFinalExpr;
    CG_PARAM        *   pLastParam;
    bool                fIsErrorStatus = false;

    pStream = pCCB->GetStream();

    // Generate the format string.
    if ( pCommand->IsNDRRun() )
        {
        GenNdrFormat( pCCB );        
        }
    else 
        {
        pCCB->GetNdr64Format()->Generate( this );
        }

    if ( GetReturnType() || HasComplexReturnType() )
        {
        if ( HasAsyncHandle() )
            {
            if ( !HasComplexReturnType() 
                 && GetReturnType()->GetChild()->GetCGID() != ID_CG_CONTEXT_HDL )
                {
                fIsErrorStatus = GetReturnType()->GetChild()->GetCGID() == ID_CG_ERROR_STATUS_T;
                }
            if ( fIsErrorStatus || GetCGID() == ID_CG_OBJECT_PROC )
                {
                pStream->Write( "CLIENT_CALL_RETURN " RETURN_VALUE_VAR_NAME );
                pStream->Write( " = {0};" );
                pStream->NewLine( 2 );
                }
            }
        else
            {
            if ( HasComplexReturnType() )
                {
                ( (node_proc *) GetType() )
                            ->GetReturnType()->PrintType(PRT_DECL, pStream);
                }
            else
                pStream->Write( "CLIENT_CALL_RETURN " );

            pStream->Write( RETURN_VALUE_VAR_NAME );
            pStream->Write( ';' );
            pStream->NewLine( 2 );
            }
        }

    GetMembers(Iterator);

    pLastParam = 0;

    while ( ITERATOR_GETNEXT( Iterator, pLastParam ) )
        ;

    // If we have a complex return type the "last parameter" is actually the
    // return value so we need the one before that.

    if ( pLastParam && HasComplexReturnType() )
        {
        CG_PARAM *pPrevLastParam = NULL;

        ITERATOR_INIT( Iterator );
        while ( ITERATOR_GETNEXT( Iterator, pPrevLastParam ) )
            if ( pPrevLastParam->GetSibling() == pLastParam )
                break;

        pLastParam = pPrevLastParam;
        }

    // Now emit code for x86 or ia64.

    if (  pCommand->Is64BitEnv() )
        {
        // Emit code for IA64 platform
        pFinalExpr = GenCoreNdrSingleClientCall( pCCB, PROC_PLATFORM_IA64) ;
        }
    else
        {
        // x86
        pFinalExpr = GenCoreNdrSingleClientCall( pCCB, PROC_PLATFORM_X86 );
        }

    pFinalExpr->PrintCall( pStream, 0, 0 );
    pStream->NewLine();

    if ( GetReturnType() || HasComplexReturnType() )
        {
        if ( HasAsyncHandle() )
            {
            if ( !fIsErrorStatus && GetCGID() != ID_CG_OBJECT_PROC )
                {
                return;
                }
            }

        pStream->Write("return ");
        
        // 
        // Complex return types
        //

        if ( HasComplexReturnType() )
            {
            pStream->Write( RETURN_VALUE_VAR_NAME ";" );
            pStream->NewLine();
            return;
            }

        CG_NDR*     pNdr = (CG_NDR *) GetReturnType()->GetChild();
        node_skl*   pType = GetReturnType()->GetType();

        //
        // Base type return value.
        //
        if ( pNdr->IsSimpleType() )
            {
            switch ( ((CG_BASETYPE *)pNdr)->GetFormatChar() )
                {
                case FC_FLOAT :
                    pType->PrintType( PRT_CAST_TO_TYPE, pStream );
                    pStream->Write( RETURN_VALUE_VAR_NAME ".Float;" );
                    break;
                case FC_DOUBLE :
                    pType->PrintType( PRT_CAST_TO_TYPE, pStream );
                    pStream->Write( RETURN_VALUE_VAR_NAME ".Double;" );
                    break;
                default :
                    pType->PrintType( PRT_CAST_TO_TYPE, pStream );
                    pStream->Write( RETURN_VALUE_VAR_NAME ".Simple;" );
                    break;
                }

            pStream->NewLine();
            return;
            }

        //
        // A by-value struct or union.
        //
        if ( pNdr->IsStruct() || pNdr->IsUnion() )
            {
            expr_node * pExpr;

            pExpr = new expr_variable( RETURN_VALUE_VAR_NAME ".Pointer" );

            pExpr = MakeDerefExpressionOfCastPtrToType( pType, pExpr );

            pExpr->Print( pStream );

            pStream->Write( ';' );
            pStream->NewLine();
            return;
            }

        //
        // Otherwise pointer or array.
        //
        pType->PrintType( PRT_CAST_TO_TYPE, pStream );
        pStream->Write( RETURN_VALUE_VAR_NAME ".Pointer;" );
        pStream->NewLine();
        }
}

//
// ##########################################################################
// ----- Interpreted server stub generation. -----###########################
// ##########################################################################
//

void
CG_PROC::GenNdrSingleServerCall( CCB * pCCB )
/*++

Routine Description :

    This is the top level routine for generating code for the single NDR call
    case on the server side.  It actually ends up being 3 calls.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{
    ISTREAM *           pStream;
//    CG_PARAM *            pParam;
    expr_proc_call *    pCallExpr;
    char                FormatStringExpr[80];

    //
    // On the server side we just use the format string that was generated
    // during client stub generation if such generation occured.
    //    
    if ( pCommand->IsNDRRun() )
        {
        if ( GetFormatStringOffset() == -1 )
            GenNdrFormat( pCCB );        
        }
    else 
        {
        pCCB->GetNdr64Format()->Generate( this );
        }

    pCCB->SetCGNodeContext( this );

    pStream = pCCB->GetStream();

    //
    // Output the server stub locals.  There are two locals : the stub
    // descriptor and the param struct.
    //
    GenNdrInterpretedServerLocals( pCCB );

    pStream->NewLine();

    //
    // Make the single unmarshall call.
    //
    pCallExpr = new expr_proc_call( S_NDR_UNMARSHALL_RTN_NAME );

    // Rpc message.
    pCallExpr->SetParam( new expr_param(
                         new expr_variable( PRPC_MESSAGE_VAR_NAME ) ) );

    // Stub message.
    pCallExpr->SetParam( new expr_param(
                         new expr_u_address (
                         new expr_variable( STUB_MESSAGE_VAR_NAME ) ) ) );

    // Stub descriptor.
    pCallExpr->SetParam( new expr_param(
                         new expr_u_address (
                         new expr_variable(
                            pCCB->GetInterfaceCG()->GetStubDescName() ) ) ) );

    sprintf( FormatStringExpr,
             "&%s[%d]",
             PROC_FORMAT_STRING_STRING_FIELD,
             GetFormatStringOffset() );

    // Format string pointer.
    pCallExpr->SetParam( new expr_param(
                         new expr_variable( FormatStringExpr ) ) );

    // Parameter structure pointer.
    if ( ! IsNullCall() )
        {
        pCallExpr->SetParam( new expr_param(
                             new expr_u_address (
                             new expr_variable( "ParamStruct" ) ) ) );
        }
    else
        {
        pCallExpr->SetParam( new expr_param(
                             new expr_variable( "0" ) ) );
        }

    // Print the unmarshall call.
    pCallExpr->PrintCall( pCCB->GetStream(),
                          0,
                          0 );

    pStream->NewLine();

    //
    // Now make the call to the manager.
    //
    GenNdrInterpretedManagerCall( pCCB );

    //
    // Make the single marshall call.
    //
    pCallExpr = new expr_proc_call( S_NDR_MARSHALL_RTN_NAME );

    // Stub message.
    pCallExpr->SetParam( new expr_param(
                         new expr_u_address (
                         new expr_variable( STUB_MESSAGE_VAR_NAME ) ) ) );

    // Format string pointer.
    pCallExpr->SetParam( new expr_param(
                         new expr_variable( FormatStringExpr ) ) );

    pStream->NewLine( 2 );

    // Print the marshall routine call.
    pCallExpr->PrintCall( pCCB->GetStream(),
                          0,
                          0 );
}

void
CG_PROC::GenNdrInterpretedServerLocals( CCB * pCCB )
/*++

Routine Description :

    This routine outputs the two local variables for an interpreted server
    stub.  The two locals are the stub message and the param struct.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{
    ISTREAM *       pStream;

    pStream = pCCB->GetStream();

    // Stub message local.
    pStream->Write( STUB_MESSAGE_TYPE_NAME " " STUB_MESSAGE_VAR_NAME ";" );
    pStream->NewLine();

    // Generate the param struct for non-null calls only.
    if ( ! IsNullCall() )
        {
        GenNdrInterpreterParamStruct( pCCB );

        pStream->Write( PARAM_STRUCT_TYPE_NAME " ParamStruct;" );
        pStream->NewLine();
        }
}


void
CG_PROC::GenNdrInterpreterParamStruct( 
    CCB *   pCCB)
{
    BOOL   f64 = pCommand->Is64BitEnv();   

    if ( f64)
        GenNdrInterpreterParamStruct64( pCCB);
    else 
        GenNdrInterpreterParamStruct32( pCCB );
}

void
CG_PROC::GenNdrInterpreterParamStruct64( CCB *   pCCB )
{
    CG_ITERATOR     Iterator;
    ISTREAM *       pStream;
    CG_PARAM *      pParam;
    CG_PARAM *      pParamPrev;
    CG_RETURN *     pReturn;
    CG_NDR *        pNdr;
    long            PadNumber;
    char            Buffer[80];
    long            PrevEndOffset;

    pStream = pCCB->GetStream();

    // Register size is 8 for 64b platform.
    pStream->Write( "#pragma pack(8)" );
    pStream->NewLine();

    pStream->Write( PARAM_STRUCT_TYPE_NAME );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( '{' );
    pStream->NewLine();

    PadNumber = 0;

    GetMembers( Iterator );

    if ( IsObject() )
        {
        pCCB->GetInterfaceCG()->GetThisDeclarator()->PrintType(
                    PRT_PARAM_OR_ID_DECLARATION,
                    pStream,
                    (node_skl *)0 );
        PrevEndOffset = 8;
        }
    else
        PrevEndOffset = 0;

    pParamPrev = 0;

    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        pNdr = (CG_NDR *) pParam->GetChild();

        if ( pNdr->GetCGID() == ID_CG_GENERIC_HDL )
            pNdr = (CG_NDR *) pNdr->GetChild();

        // IA64 does not align every big struct to 16b boundary.
        // Only __int128 etc. would be aligned to 16 (and objects embedding it).
        // OPTIMIZE: The code below is correct, as GetStackOffset with PrevEndOffset
        // is a check for alignment of 16, but pParam->GetMemAlign() would be better.

        if ( (pParam->GetStackSize() > 8)  &&  PrevEndOffset > 0 ) 
            {
                long    CurrentIA64Offset;

                if ( pParamPrev )
                    {
                    PrevEndOffset = pParamPrev->GetStackOffset( pCCB, I386_STACK_SIZING )
                                  + pParamPrev->GetStackSize();
                    if ( PrevEndOffset & 7 )  
                        PrevEndOffset += 8 - (PrevEndOffset & 7);  
                    }

                // The additional pad for 16b aligned objects can only be 
                // a full register as the prev param is already padded.

                CurrentIA64Offset = pParam->GetStackOffset( pCCB, I386_STACK_SIZING );

                if ( CurrentIA64Offset - PrevEndOffset )
                    {
                    sprintf( Buffer, "char Pad%d[8];", PadNumber++ );
                    pStream->Write( Buffer );
                    pStream->NewLine();
                    }
            }

        // 
        // For reasons lost to the ages if we have a pointer to a 
        // context handle then it's type gets munged from TYPE* to
        // NDR_SCONTEXT.  This is fine except that it causes type 
        // mismatch errors in the server stub.  Special case it here.
        //

        bool print = true;

        if ( pNdr->IsPointer() )
            {
            CG_CONTEXT_HANDLE *pHandle = dynamic_cast<CG_CONTEXT_HANDLE *>
                                                ( pNdr->GetChild() );

            if ( pHandle )
                {
                pStream->WriteFormat(
                                "%s *%s;",
                                pHandle->GetHandleType()->GetSymName(),
                                pParam->GetSymName());
                pStream->NewLine();
                print = false;
                }
            }

        // Print the field declaration.
        if (print)
            {
            pParam->GetResource()->GetType()->PrintType(
                        PRT_PARAM_OR_ID_DECLARATION,
                        pStream,
                        (node_skl *)0 );
            }

        //
        // Generate some padding if needed.
        //
        if ( pParam->GetStackSize() & 7 )
            {
            long Pad = 8 - (pParam->GetStackSize() & 7);

            sprintf( Buffer, "char Pad%d[%d];", PadNumber++, Pad );
            pStream->Write( Buffer );
            pStream->NewLine();
            }

        pParamPrev = pParam;
        } // while params
        
    // Add the return type if one is present.
    if ( ( pReturn = GetReturnType() ) != 0 )
        {
        pReturn->GetResource()->GetType()->PrintType(
                PRT_PARAM_OR_ID_DECLARATION,    
                pStream,
                (node_skl *)0 );
        // Possibly we could add a padding after the return type member 
        // but it would not be used anyway.
        }

    pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine();

    pStream->Write( "#pragma pack()" );
    pStream->NewLine();
}

void
CG_PROC::GenNdrInterpreterParamStruct32( CCB * pCCB )
{
    CG_ITERATOR     Iterator;
    ISTREAM *       pStream;
    CG_PARAM *      pParam;
    CG_PARAM *      pParamPrev;
    CG_RETURN *     pReturn;
    CG_NDR *        pNdr;
    long            Pad;
    long            PadNumber;
    char            Buffer[80];

    pStream = pCCB->GetStream();

    pStream->Write( "#pragma pack(4)" );
    pStream->NewLine();

    pStream->Write( PARAM_STRUCT_TYPE_NAME );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( '{' );
    pStream->NewLine();

    PadNumber = 0;

    GetMembers( Iterator );

    if ( IsObject() )
        {
        pCCB->GetInterfaceCG()->GetThisDeclarator()->PrintType(
                    PRT_PARAM_OR_ID_DECLARATION,
                    pStream,
                    (node_skl *)0 );
        }

    pParamPrev = 0;

    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        pNdr = (CG_NDR *) pParam->GetChild();

        if ( pNdr->GetCGID() == ID_CG_GENERIC_HDL )
            pNdr = (CG_NDR *) pNdr->GetChild();

        // 
        // For reasons lost to the ages if we have a pointer to a 
        // context handle then it's type gets munged from TYPE* to
        // NDR_SCONTEXT.  This is fine except that it causes type 
        // mismatch errors in the server stub.  Special case it here.
        //

        bool print = true;

        if ( pNdr->IsPointer() )
            {
            CG_CONTEXT_HANDLE *pHandle = dynamic_cast<CG_CONTEXT_HANDLE *>
                                                ( pNdr->GetChild() );

            if ( pHandle )
                {
                pStream->WriteFormat(
                                "%s *%s;",
                                pHandle->GetHandleType()->GetSymName(),
                                pParam->GetSymName());
                pStream->NewLine();
                print = false;
                }
            }

        // Print the field declaration.
        if (print)
            {
            pParam->GetResource()->GetType()->PrintType(
                        PRT_PARAM_OR_ID_DECLARATION,
                        pStream,
                        (node_skl *)0 );
            }

        //
        // Generate some padding if needed.
        //
        if ( pParam->GetStackSize() & 3 )
            {
            Pad = 4 - (pParam->GetStackSize() & 3);

            sprintf( Buffer, "char Pad%d[%d];", PadNumber++, Pad );
            pStream->Write( Buffer );
            pStream->NewLine();
            }

        pParamPrev = pParam;
        } // while params

    // Add the return type if one is present.
    if ( ( pReturn = GetReturnType() ) != 0 )
        {
        pReturn->GetResource()->GetType()->PrintType(
                PRT_PARAM_OR_ID_DECLARATION,    
                pStream,
                (node_skl *)0 );
        }

    pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine();

    pStream->Write( "#pragma pack()" );
    pStream->NewLine();
}



void
CG_PROC::GenNdrInterpretedManagerCall( CCB * pCCB )
/*++

Routine Description :

    This routine outputs the call to the manager for interpreted stubs.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{
    CG_ITERATOR         Iterator;
    CG_PARAM *          pParam;
//  CG_RETURN *         pReturn;
    expr_proc_call *    pCall;
    expr_node *     pExpr;
    
    if ( GetCallAsName() )
        {
        pCall = new expr_proc_call( GenMangledCallAsName( pCCB ) );
        }
    else
        pCall = new expr_proc_call( GetType()->GetSymName() );

    GetMembers( Iterator );

    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        CG_NDR *        pNdr;
        char *          pName;
        expr_node * pExpr;

        pNdr = (CG_NDR *) pParam->GetChild();

        pName = new char[80];

        strcpy( pName, "pParamStruct->" );
        strcat( pName, pParam->GetResource()->GetResourceName() );

        pExpr = new expr_variable( pName );

        pCall->SetParam( new expr_param ( pExpr ) );
        }

    //
    // epv stuff
    //

    expr_node * pExprTemp;

    if( pCCB->IsMEpV() && (GetCGID() != ID_CG_CALLBACK_PROC)  )
        {
        unsigned short M, m;
        CSzBuffer Buffer;
        char * pTemp;

        pCCB->GetVersion( &M, &m );

        Buffer.Set("((");
        Buffer.Append(pCCB->GetInterfaceName());
        Buffer.Append(pCCB->GenMangledName());
        Buffer.Append("_");
        Buffer.Append(pCCB->IsOldNames() ? "SERVER_EPV" : "epv_t");
        Buffer.Append(" *)(");
        Buffer.Append(PRPC_MESSAGE_MANAGER_EPV_NAME);
        Buffer.Append("))");

        pTemp = new char [ strlen( Buffer ) + 1 ];
        strcpy( pTemp, Buffer );

        pExprTemp = new expr_variable( pTemp );//this has the rhs expr for the
                                               // manager epv call. Sneaky !
        pCall = (expr_proc_call *)new expr_pointsto( pExprTemp, pCall );
        }

    //
    // end epv stuff
    //

    // async methods don't have return values
    if ( GetReturnType() && !HasAsyncHandle() )
        {
        CG_NDR  * pC = (CG_NDR *) GetReturnType()->GetChild();

        if( pC->GetCGID() == ID_CG_CONTEXT_HDL )
            {
            expr_proc_call * pProc = new expr_proc_call( "NDRSContextValue" );

            pProc->SetParam( new expr_param(
                             new expr_variable(
                                "pParamStruct->" RETURN_VALUE_VAR_NAME ) ) );

            // cast the proc call to this type.

            pExpr   = MakeDerefExpressionOfCastPtrToType(
                                                 GetReturnType()->GetType(),
                                                 pProc );
            pExpr = new expr_assign (pExpr, pCall );
            }
        else
            {
            pExpr = new expr_assign(
                        new expr_variable(
                            "pParamStruct->" RETURN_VALUE_VAR_NAME ),
                        pCall );
            }
        }
    else
        pExpr = pCall;

    pCCB->GetStream()->NewLine();

    pExpr->PrintCall( pCCB->GetStream(), 0, 0 );

    pCCB->GetStream()->NewLine();
}


void
CG_PROC::GenNdrThunkInterpretedServerStub( CCB * pCCB )
{
    ISTREAM *   pStream;

    pStream = pCCB->GetStream();

    pStream->NewLine();

    if ( pCCB->GetInterfaceCG()->GetCGID() == ID_CG_INHERITED_OBJECT_INTERFACE )
        pStream->Write( "static " );

    pStream->Write( "void __RPC_API" );

    pStream->NewLine();

    pStream->Write( pCCB->GetInterfaceName() );
    pStream->Write( '_' );
    pStream->Write( GetType()->GetSymName() );
//  if ( IsObject() )
        pStream->Write( "_Thunk" );
    pStream->Write( '(' );
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( PSTUB_MESSAGE_TYPE_NAME " " PSTUB_MESSAGE_PAR_NAME " )" );
    pStream->IndentDec();
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->IndentInc();
    pStream->NewLine();

    GenNdrInterpreterParamStruct( pCCB );

    pStream->Write( PARAM_STRUCT_TYPE_NAME " * pParamStruct;" );
    pStream->NewLine( 2 );

    pStream->Write( "pParamStruct = (" PARAM_STRUCT_TYPE_NAME " *) " );
    pStream->Write( PSTUB_MESSAGE_PAR_NAME "->StackTop;" );
    pStream->NewLine();

    GenNdrInterpretedManagerCall( pCCB );

    pStream->IndentDec();
    pStream->NewLine();

    pStream->Write( '}' );
    pStream->NewLine();
}

void
CG_PROC::GenNdrOldInterpretedServerStub( CCB * pCCB )
{
#ifdef TEMPORARY_OI_SERVER_STUBS

    // This code is being generated temporarily to enable easier debugging
    // of server side -Oi stubs. Normally server side stubs do not exist. And
    // the server side runtime calls the Server side interpreter directly. This
    // causes debugging problems if we want to breakpoint on a method on an
    // interface. Therefore till we get the system converted to -Oi and the
    // stress stabilizes, we will emit a server side procedure which will
    // enable breakpointing per interface proc.


    // This emits just the server side prolog for -Oi.

    S_GenProlog( pCCB );

    // Emit the call to NdrStubCall or NdrServerCall.

    PNAME               pProcName = IsObject() ? S_OBJECT_NDR_CALL_RTN_NAME :
                                                 S_NDR_CALL_RTN_NAME;
    expr_proc_call  *   pProc = new expr_proc_call( pProcName );
    ITERATOR            ParamList;
    expr_node       *   pParam;

    // Set the parameters.

    pCCB->GetListOfParamResources( ParamList );

    while( ITERATOR_GETNEXT( ParamList, pParam ) )
        {
        pProc->SetParam( pParam );
        }

    // Emit the call to the interpreter.

    pProc->PrintCall( pCCB->GetStream(), 0, 0 );
    Out_IndentDec( pCCB );
    Out_ProcClosingBrace( pCCB );

#else TEMPORARY_OI_SERVER_STUBS
    //
    // Generate the function header.
    //
    S_GenProlog( pCCB );

    //
    // Do the single call code generation.  This includes the
    // declarations of the three server locals : the stub message, the
    // return variable if needed, and the parameter structure.
    //
    GenNdrSingleServerCall( pCCB );

    // Generate end stuff.
    Out_IndentDec( pCCB );
    Out_ProcClosingBrace( pCCB );

#endif // TEMPORARY_OI_SERVER_STUBS
}

//
// Param format string generation.
//

void
CG_PARAM::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Calls the parameter's child node to generate it's format string.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{
    MIDL_ASSERT( !pCommand->IsNDR64Run() );    

    if ( GetFormatStringOffset() != -1 )
        return;

    // The invisible fault/comm status param added by means of acf definition
    // doesn't go on wire, so it has no format string representation.

    if ( IsExtraStatusParam() )
        return;

    // [async_handle] This parameter is the invisible xxx_AsyncHandle and does not go
    // on the wire, so it has no format representation.
    if ( IsAsyncHandleParam() )
        return;
    //
    // Call the param child to generate it's format string.
    //
    ((CG_NDR *)GetChild())->GenNdrFormat( pCCB );

    //
    // Set the param node's format string offset equal to the child.
    //
    SetFormatStringOffset( ((CG_NDR *)GetChild())->GetFormatStringOffset() );
}

//
// Individual NDR routine calls output.
//

void
CG_PARAM::GenNdrMarshallCall( CCB * pCCB )
/*++

Routine Description :

    Outputs a parameter's ndr marshall routine call.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{
    ISTREAM *           pStream;
    CG_NDR *            pChild;
    FORMAT_STRING *     pFormatString;
    PNAME               pParamName;
    ID_CG               ParamId;
    long                NameIndex;
    long                FormatOffset;
    BOOL                fTakeAddress;
    BOOL                fDereference;
    unsigned short WireAlign;

    // BUG BUG, this needs to be cleaned up for NDR64
    MIDL_ASSERT( !pCommand->IsNDR64Run() );

    pStream = pCCB->GetStream();

    pChild = (CG_NDR *)GetChild();

    ParamId = pChild->GetCGID();

    pParamName = GetResource()->GetResourceName();

    if ( IsParamPartialIgnore() &&
         ( pCCB->GetCodeGenSide() == CGSIDE_CLIENT ) )
        {
        Out_PartialIgnoreClientMarshall( pCCB, pParamName );
        return;
        }

    if ( (ParamId == ID_CG_PRIMITIVE_HDL) ||
         ((ParamId == ID_CG_PTR) &&
          (((CG_NDR *)pChild->GetChild())->GetCGID() == ID_CG_PRIMITIVE_HDL)) )
        return;

    //
    // For a generic handle, get the handle data type and then continue.
    //
    if ( ParamId == ID_CG_GENERIC_HDL )
        {
        pChild = (CG_NDR *)pChild->GetChild();
        ParamId = pChild->GetCGID();
        }

    //
    // Since a ref pointer is not shipped, we must use it's child to figure
    // out the alignment action and next alignment state.
    //
    if ( pChild->IsPointer() &&
         ( !pChild->IsInterfacePointer() ) && 
         (pChild->GetCGID() != ID_CG_STRING_PTR) &&
         (pChild->GetCGID() != ID_CG_STRUCT_STRING_PTR) &&
         (pChild->GetCGID() != ID_CG_SIZE_STRING_PTR) &&
         (pChild->GetCGID() != ID_CG_SIZE_PTR) &&
         (pChild->GetCGID() != ID_CG_SIZE_LENGTH_PTR) &&
         (((CG_POINTER *)pChild)->GetPtrType() == PTR_REF) )
        {
        CG_NDR * pPtrChild = (CG_NDR *) pChild->GetChild();

        if ( ! pChild->IsPipeOrPipeReference() )
            {
            WireAlign = pPtrChild->GetWireAlignment();
            }
        }
    else
        {
        // We shouldn't do that for pipe and object pipe args

        if ( ! pChild->IsPipeOrPipeReference() )
            {
            WireAlign = pChild->GetWireAlignment();
            }
        }

    // For context handles, generate an optimized code for the client side and
    // also an optimize code for common context handles at the server side but
    // except that for new context handle flavors the call is slightly different.

    if ( (ParamId == ID_CG_CONTEXT_HDL) ||
         ((ParamId == ID_CG_PTR) &&
          (((CG_NDR *)pChild->GetChild())->GetCGID() == ID_CG_CONTEXT_HDL)) )
        {
        if ( pCCB->GetCodeGenSide() == CGSIDE_CLIENT )
            {
            Out_CContextHandleMarshall( pCCB,
                                        pParamName,
                                        (ParamId == ID_CG_PTR) );
            }
        else
            {
            CG_CONTEXT_HANDLE * pContextHandle;

            pContextHandle = (ParamId == ID_CG_PTR) ?
                             (CG_CONTEXT_HANDLE *) pChild->GetChild() :
                             (CG_CONTEXT_HANDLE *) pChild;

            pCCB->RegisterContextHandleType( pContextHandle->GetHandleType() );

            if ( pContextHandle->HasNewContextFlavor() )
                {
                Out_SContextHandleNewMarshall( pCCB,
                                               pParamName, 
                                               pContextHandle->GetRundownRtnName(),
                                               pContextHandle->GetFormatStringOffset() );
                }
            else
                {
                Out_SContextHandleMarshall( pCCB,
                                            pParamName, 
                                            pContextHandle->GetRundownRtnName() );
                }
            }

        return;
        }

    if ( pChild->GetCGID() == ID_CG_ENUM  ||  pChild->GetCGID() == ID_CG_INT3264 )
        {
        expr_proc_call *    pCall;
        FORMAT_CHARACTER    fc;
        expr_node       *   pExpr;

        if ( pChild->GetCGID() == ID_CG_ENUM )
            fc = ((CG_ENUM *)pChild)->GetFormatChar();
        else
            fc = ((CG_BASETYPE *)pChild)->GetSignedFormatChar();

        pCall = new expr_proc_call( "NdrSimpleTypeMarshall" );

        pExpr = new expr_u_address (
                         new expr_variable( STUB_MESSAGE_VAR_NAME ) );
        pExpr = MakeExpressionOfCastToTypeName(PSTUB_MESSAGE_TYPE_NAME , pExpr);

        pCall->SetParam( new expr_param( pExpr ) );

        pExpr =  new expr_u_address ( new expr_variable( pParamName ) );
        pExpr = MakeCastExprPtrToUChar( pExpr );

        pCall->SetParam( new expr_param( pExpr ) );

        // Don't emit names like FC_ENUM16 or FC_INT3264 as constants are not public.
        pCall->SetParam( new expr_param(
                         new expr_constant( (long)fc ) ) );

        pStream->NewLine();

        pCall->PrintCall( pStream, 0, 0 );

        return;
        }

    if ( pChild->IsSimpleType() )
        {
        pStream->NewLine();

        OutputNdrAlignment( pCCB, WireAlign );

        //
        // Now make the assignment expression and increment with cast, like :
        //
        //   *((<type> *)_StubMsg.Buffer)++ = <var>;
        //
        expr_node *     pExpr;
        expr_variable * pBufVar;
        expr_variable * pVar;

        pBufVar = new expr_variable( STUB_MSG_BUFFER_VAR_NAME );

        pVar = new expr_variable( pParamName );

        pExpr = MakeExpressionOfCastPtrToType( pChild->GetType(), pBufVar );

        pExpr = new expr_post_incr( pExpr );
        pExpr = new expr_u_deref( pExpr );
        pExpr = new expr_assign( pExpr, pVar );

        pExpr->Print( pStream );
        pStream->Write( ';' );
        pStream->NewLine();

        return;
        }

    if ( pChild->IsPointerToBaseType() &&
         (((CG_POINTER *)pChild)->GetPtrType() == PTR_REF) &&
         (((CG_NDR *)pChild->GetChild())->GetCGID() != ID_CG_ENUM)  &&
         (((CG_NDR *)pChild->GetChild())->GetCGID() != ID_CG_INT3264) )
        {
        CG_POINTER *        pPointer;
        CG_NDR *            pBasetype;
        expr_node *     pExpr;
        expr_variable * pBufVar;
        expr_variable * pVar;

        pPointer = (CG_POINTER *) pChild;

        pBasetype = (CG_NDR *) pPointer->GetChild();

        if ( pBasetype->GetCGID() == ID_CG_GENERIC_HDL )
            pBasetype = (CG_NDR *) pBasetype->GetChild();

        pBufVar = new expr_variable( STUB_MSG_BUFFER_VAR_NAME );

        pVar = new expr_variable( pParamName );

        pStream->NewLine();

        OutputNdrAlignment( pCCB, WireAlign );

        //
        // Now make the assignment expression and increment with cast, like :
        //
        //   *((<type>)_StubMsg.Buffer)++ = *<var>;
        //

        pExpr = MakeExpressionOfCastPtrToType( pBasetype->GetType(), pBufVar );

        pExpr = new expr_post_incr( pExpr );
        pExpr = new expr_u_deref( pExpr );
        pExpr = new expr_assign( pExpr, new expr_u_deref(pVar) );

        pExpr->Print( pStream );
        pStream->Write( ';' );
        pStream->NewLine();

        return;
        }

    GenNdrTopLevelAttributeSupport( pCCB );
    
    pFormatString = pCCB->GetFormatString();

    FormatOffset = pChild->GetFormatStringOffset();
    NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );

    //
    // If the param is a by-value struct or union then set the fTakeAddress
    // flag.
    //
    fTakeAddress =  pChild->IsStruct() || pChild->IsUnion()
                    || pChild->IsXmitRepOrUserMarshal();

    //
    // If the param is an array and we're in the server stub then we
    // must dereference it.
    //
    fDereference =  (pCCB->GetCodeGenSide() == CGSIDE_SERVER) &&
                    pChild->IsArray();

    //
    // If the param is an omitted cs_tag param, the marshalling code takes
    // care of handling the call to the tag routine to get the actual value.
    // Also, since we don't have the parameter on the stack we don't have a
    // name to pass to Marshall so just pass "0" (NULL)
    //
    if ( IsOmittedParam() )
        {
        PNAME pNewName = (PNAME) alloca( sizeof("0 /*  */") 
                                            + strlen(pParamName) );
        strcpy( pNewName, "0 /* ");
        strcat( pNewName, pParamName );
        strcat( pNewName, " */");
        pParamName = pNewName;
        fTakeAddress = FALSE;   // Probably don't need these but be safe
        fDereference = FALSE;
        }

    //
    // For ref pointers with no funky attributes, we optimize by calling
    // the pointee's routine directly.
    //
    if ( pChild->IsPointer() && ((CG_POINTER *)pChild)->IsBasicRefPointer() )
        {
        CG_POINTER *    pPointer;

        pPointer = (CG_POINTER *) pChild;

        switch ( pPointer->GetCGID() )
            {
            case ID_CG_STRING_PTR :
                if ( ((CG_STRING_POINTER *)pPointer)->IsStringableStruct() )
                    break;

                FormatOffset = pPointer->GetFormatStringOffset() + 2;
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;

            case ID_CG_SIZE_STRING_PTR :
                if ( ((CG_STRING_POINTER *)pPointer)->IsStringableStruct() )
                    break;

                FormatOffset = pPointer->GetPointeeFormatStringOffset();
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;

            case ID_CG_STRUCT_STRING_PTR :
                break;

            default :
                FormatOffset = pPointer->GetPointeeFormatStringOffset();
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;
            }
        }

    Out_NdrMarshallCall( pCCB,
                         pNdrRoutineNames[NameIndex],
                         pParamName,
                         FormatOffset,
                         fTakeAddress,
                         fDereference );
}

void
CG_PARAM::GenNdrUnmarshallCall( CCB * pCCB )
/*++

Routine Description :

    Outputs a parameter's ndr unmarshall routine call.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{

    // BUG BUG, this needs to be cleaned up for NDR64
    MIDL_ASSERT( !pCommand->IsNDR64Run() );

    ISTREAM *           pStream;
    CG_NDR *            pChild;
    FORMAT_STRING *     pFormatString;
    PNAME               pParamName;
    ID_CG               ParamId;
    long                NameIndex;
    long                FormatOffset;
    BOOL                fMustAllocFlag = FALSE;
    BOOL                fTakeAddress = TRUE;

    unsigned short WireAlign;

    pStream = pCCB->GetStream();

    pChild = (CG_NDR *)GetChild();

    ParamId = pChild->GetCGID();
    
    pParamName = GetResource()->GetResourceName();

    if ( IsParamPartialIgnore() &&
         ( pCCB->GetCodeGenSide() == CGSIDE_SERVER ) )
        {
        Out_PartialIgnoreServerUnmarshall( pCCB, pParamName );
        return;
        }

    if ( (ParamId == ID_CG_PRIMITIVE_HDL) ||
         ((ParamId == ID_CG_PTR) &&
          (((CG_NDR *)pChild->GetChild())->GetCGID() == ID_CG_PRIMITIVE_HDL)) )
        return;

    //
    // For a generic handle, get the handle data type and then continue.
    //
    if ( ParamId == ID_CG_GENERIC_HDL )
        {
        pChild = (CG_NDR *)pChild->GetChild();
        ParamId = pChild->GetCGID();
        }

    BOOL IsOutOnly;

    IsOutOnly = ! IsParamIn() || (GetCGID() == ID_CG_RETURN);

    //
    // Since a ref pointer is not shipped, we must use it's child to figure
    // out the alignment action and next alignment state.
    //
    if ( pChild->IsPointer() &&
         (!pChild->IsInterfacePointer()) &&
         (pChild->GetCGID() != ID_CG_STRING_PTR) &&
         (pChild->GetCGID() != ID_CG_STRUCT_STRING_PTR) &&
         (pChild->GetCGID() != ID_CG_SIZE_STRING_PTR) &&
         (pChild->GetCGID() != ID_CG_SIZE_PTR) &&
         (pChild->GetCGID() != ID_CG_SIZE_LENGTH_PTR) &&
         (((CG_POINTER *)pChild)->GetPtrType() == PTR_REF) )
        {
        CG_NDR * pPtrChild = (CG_NDR *) pChild->GetChild();

        if ( ! (IsExtraStatusParam()  ||  pChild->IsPipeOrPipeReference()) )
            {
            WireAlign = pPtrChild->GetWireAlignment();
            }
        }
    else
        {
        // We should not do that for pipe or object pipe args
        // However, we do not support -Os pipes as yet.

        if ( ! pChild->IsPipeOrPipeReference() )
            {
            WireAlign = pChild->GetWireAlignment();
            }
        }

    // For context handles, generate an optimized code for the client side and
    // also an optimize code for common context handles at the server side but
    // except that for new context handle flavors the call is slightly different.

    if ( (ParamId == ID_CG_CONTEXT_HDL) ||
         ( (ParamId == ID_CG_PTR) &&
           (((CG_NDR *)pChild->GetChild())->GetCGID() == ID_CG_CONTEXT_HDL) ) )
        {
        if ( pCCB->GetCodeGenSide() == CGSIDE_CLIENT )
            {
            BOOL    Initialize;

            Initialize = IsOutOnly && (ParamId == ID_CG_PTR);

            Out_CContextHandleUnmarshall( pCCB,
                                          pParamName,
                                          Initialize,
                                          GetCGID() == ID_CG_RETURN );
            }
        else
            {
            CG_CONTEXT_HANDLE * pContextHandle;

            pContextHandle = (ParamId == ID_CG_PTR) ?
                             (CG_CONTEXT_HANDLE *) pChild->GetChild() :
                             (CG_CONTEXT_HANDLE *) pChild;

            if ( pContextHandle->HasNewContextFlavor()  ||  
                 pCommand->GetNdrVersionControl().IsNdr50orLaterRequired() )
                {
                Out_SContextHandleNewUnmarshall( pCCB,
                                                 pParamName,   
                                                 IsOutOnly,
                                                 pContextHandle->GetFormatStringOffset() );
                }
            else
                {
                Out_SContextHandleUnmarshall( pCCB,
                                              pParamName,   
                                              IsOutOnly );
                }
            }

        return;
        }

    if ( pChild->GetCGID() == ID_CG_ENUM  ||  pChild->GetCGID() == ID_CG_INT3264 )
        {
        expr_proc_call *    pCall;
        FORMAT_CHARACTER    fc;
        expr_node       *   pExpr;

        if ( pChild->GetCGID() == ID_CG_ENUM )
            fc = ((CG_ENUM *)pChild)->GetFormatChar();
        else
            fc = ((CG_BASETYPE *)pChild)->GetSignedFormatChar();

        pCall = new expr_proc_call( "NdrSimpleTypeUnmarshall" );

        pExpr = new expr_u_address(new expr_variable(STUB_MESSAGE_VAR_NAME));
        pExpr = MakeExpressionOfCastToTypeName(PSTUB_MESSAGE_TYPE_NAME , pExpr);

        pCall->SetParam( new expr_param( pExpr ) );

        pExpr =  new expr_u_address ( new expr_variable( pParamName ) );
        pExpr = MakeCastExprPtrToUChar( pExpr );

        pCall->SetParam( new expr_param( pExpr ) );

        pCall->SetParam( new expr_param(
                         new expr_constant( (long)fc ) ) );

        pStream->NewLine();

        pCall->PrintCall( pStream, 0, 0 );

        return;
        }

    if ( pChild->IsSimpleType() )
        {
        pStream->NewLine();

        OutputNdrAlignment( pCCB, WireAlign );
        Out_CheckUnMarshallPastBufferEnd( pCCB, pChild->GetWireSize() );
        pStream->NewLine();

        //
        // Now make the assignment expression and increment with cast, like :
        //
        //   <var> = *((<type> *)_StubMsg.Buffer)++;
        //
        expr_node *     pExpr;
        expr_variable * pBufVar;
        expr_variable * pVar;

        pBufVar = new expr_variable( STUB_MSG_BUFFER_VAR_NAME );

        pVar = new expr_variable( pParamName );

        pExpr = MakeExpressionOfCastPtrToType( pChild->GetType(), pBufVar );

        pExpr = new expr_post_incr( pExpr );
        pExpr = new expr_u_deref( pExpr );
        pExpr = new expr_assign( pVar, pExpr );

        pExpr->Print( pStream );
        pStream->Write( ';' );
        pStream->NewLine();

        return;
        }

    if ( pChild->IsPointerToBaseType() &&
         (((CG_POINTER *)pChild)->GetPtrType() == PTR_REF) &&
         (((CG_NDR *)pChild->GetChild())->GetCGID() != ID_CG_ENUM) &&
         (((CG_NDR *)pChild->GetChild())->GetCGID() != ID_CG_INT3264) )
        {
        CG_POINTER *        pPointer;
        CG_NDR *            pBasetype;
        expr_node *     pExpr;
        expr_variable * pBufVar;
        expr_variable * pVar;

        pStream->NewLine();

        pPointer = (CG_POINTER *) pChild;

        pBasetype = (CG_NDR *) pPointer->GetChild();

        if ( pBasetype->GetCGID() == ID_CG_GENERIC_HDL )
            pBasetype = (CG_NDR *) pBasetype->GetChild();
    
        pBufVar = new expr_variable( STUB_MSG_BUFFER_VAR_NAME );
    
        pVar = new expr_variable( pParamName );
    
        if ( IsExtraStatusParam() )
            {
            // For the extra (invisible) fault/comm status parameter, that 
            // does *not* go on the wire, we need to generate an assignment 
            // when unmarshaling on the client (the arg can only be [out]).
            // The value to be assigned is error_status_ok, which maps to 0.

            pExpr = new expr_constant( (long)0 );
            pExpr = new expr_assign( new expr_u_deref( pVar ), 
                                     pExpr );
    
            pExpr->Print( pStream );
            pStream->Write( ';' );
            pStream->NewLine();
            }
        else
            {
            // For other types generate unmarshaling assignment.

            OutputNdrAlignment( pCCB, WireAlign );

            //
            // Now make the assignment of the pointer to the current buffer
            // pointer (server) or copy the incomming referent's value (client)
            // and increment the buffer pointer.
            //
    
            pExpr = MakeExpressionOfCastPtrToType( pBasetype->GetType(), pBufVar );
    
            if ( pCCB->GetCodeGenSide() == CGSIDE_SERVER )
                {
                pExpr = new expr_assign( pVar, pExpr );
                }
            else
                {
                pExpr = new expr_post_incr( pExpr );
                pExpr = new expr_assign(
                            new expr_u_deref( pVar ),
                            new expr_u_deref( pExpr ) );
                }
    
            pExpr->Print( pStream );
            pStream->Write( ';' );
            pStream->NewLine();
    
            if ( pCCB->GetCodeGenSide() == CGSIDE_SERVER )
                {
                pStream->Write( STUB_MSG_BUFFER_VAR_NAME " += " );
    
                pExpr = new expr_sizeof( pBasetype->GetType() );

                // pExpr = new expr_b_arithmetic( OP_PLUS, pBufVar, pExpr );
                // pExpr = new expr_assign( pBufVar, pExpr );

                pExpr->Print( pStream );
                pStream->Write( ";" );
                pStream->NewLine();
                }
            }

        return;
        }

    if ( pChild->GetCGID() == ID_CG_BC_PTR )
        GenNdrTopLevelAttributeSupport( pCCB );
    
    pFormatString = pCCB->GetFormatString();

    //
    // If this is a by-value structure or union then use the mangled
    // local pointer variable to the same type.
    //
    if ( pChild->IsStruct() || pChild->IsUnion() ||
         pChild->IsXmitRepOrUserMarshal() )
        {
        if ( !( pCCB->GetCodeGenSide() == CGSIDE_CLIENT  && IsParamIn() ) )
            {
            char *  pName = new char[strlen(pParamName) + 10];

            strcpy( pName, LOCAL_NAME_POINTER_MANGLE );
            strcat( pName, pParamName );

            pParamName = pName;
            }

        //
        // If this is a regular structure or an encapsulated struct (union)
        // being returned, then zero it out.
        //
        if( (GetCGID() == ID_CG_RETURN) &&
            (pChild->IsStruct() || pChild->IsUnion()) )
            {
            Out_MemsetToZero( pCCB,
                              new expr_variable( pParamName, 0 ),
                              new expr_sizeof( pChild->GetType() ) );

            }
        }

    FormatOffset = pChild->GetFormatStringOffset();
    NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );

    //
    // For ref pointers with no funky attributes, we optimize by calling
    // the pointee's routine directly.
    //
    if ( pChild->IsPointer() && ((CG_POINTER *)pChild)->IsBasicRefPointer() )
        {
        CG_POINTER *    pPointer;

        pPointer = (CG_POINTER *) pChild;

        switch ( pPointer->GetCGID() )
            {
            case ID_CG_STRING_PTR :
                if ( ((CG_STRING_POINTER *)pPointer)->IsStringableStruct() )
                    break;

                FormatOffset = pPointer->GetFormatStringOffset() + 2;
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;

            case ID_CG_SIZE_STRING_PTR :
                if ( ((CG_STRING_POINTER *)pPointer)->IsStringableStruct() )
                    break;

                FormatOffset = pPointer->GetPointeeFormatStringOffset();
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;

            case ID_CG_STRUCT_STRING_PTR :
                break;

            default :
                FormatOffset = pPointer->GetPointeeFormatStringOffset();
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;
            }
        }

    //
    // If the param is an omitted cs_tag param, the marshalling code takes
    // care of handling the call to the tag routine to get the actual value.
    // Also, since we don't have the parameter on the stack we don't have a
    // name to pass to Unmarshall so just pass "0" (NULL)
    //
    if ( IsOmittedParam() )
        {
        PNAME pNewName = (PNAME) alloca( sizeof("0 /*  */") 
                                            + strlen(pParamName) );
        strcpy( pNewName, "0 /* ");
        strcat( pNewName, pParamName );
        strcat( pNewName, " */");
        pParamName = pNewName;
        fTakeAddress = FALSE;
        }

    Out_NdrUnmarshallCall( pCCB,
                           pNdrRoutineNames[NameIndex],
                           pParamName,
                           FormatOffset,
                           fTakeAddress,
                           fMustAllocFlag );
}

void
CG_PARAM::GenNdrBufferSizeCall( CCB * pCCB )
/*++

Routine Description :

    Outputs a parameter's ndr buffer sizing routine call.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{

    // BUG BUG, this needs to be cleaned up for NDR64
    MIDL_ASSERT( !pCommand->IsNDR64Run() );


    CG_NDR *            pChild;
    FORMAT_STRING *     pFormatString;
    PNAME               pParamName;
    ID_CG               ParamId;
    long                NameIndex;
    long                FormatOffset;
    BOOL                fTakeAddress;
    BOOL                fDereference;

    pChild = (CG_NDR *)GetChild();
    
    ParamId    = pChild->GetCGID();
    pParamName = GetResource()->GetResourceName();


    if ( IsParamPartialIgnore() &&
         ( pCCB->GetCodeGenSide() == CGSIDE_CLIENT ) )
        {
        Out_PartialIgnoreClientBufferSize( pCCB, pParamName );
        return;
        }

    //
    // Primitive handle contributes no size.
    //
    if ( (ParamId == ID_CG_PRIMITIVE_HDL) ||
         ((ParamId == ID_CG_PTR) &&
          (((CG_NDR *)pChild->GetChild())->GetCGID() == ID_CG_PRIMITIVE_HDL)) )
        return;

    //
    // For a generic handle, get the handle data type and then continue.
    //
    if ( ParamId == ID_CG_GENERIC_HDL )
        {
        pChild = (CG_NDR *)pChild->GetChild();
        ParamId = pChild->GetCGID();
        }

    if ( ParamId == ID_CG_CONTEXT_HDL ||
         ((ParamId == ID_CG_PTR) &&
          (((CG_NDR *)pChild->GetChild())->GetCGID() == ID_CG_CONTEXT_HDL)) )
        {
        ISTREAM *   pStream = pCCB->GetStream();

        pStream->WriteOnNewLine( STUB_MSG_LENGTH_VAR_NAME " += 20;" );
        pStream->NewLine();

        return;
        }

    if ( pChild->IsSimpleType() )
        {
        ISTREAM *   pStream = pCCB->GetStream();

        pStream->WriteOnNewLine( STUB_MSG_LENGTH_VAR_NAME " += 16;" );
        pStream->NewLine();

        return;
        }

    if ( pChild->IsPointerToBaseType() )
        {
        ISTREAM *   pStream = pCCB->GetStream();

        pStream->WriteOnNewLine( STUB_MSG_LENGTH_VAR_NAME " += 24;" );
        pStream->NewLine();

        return;
        }

    GenNdrTopLevelAttributeSupport( pCCB );
    
    pFormatString = pCCB->GetFormatString();

    FormatOffset = pChild->GetFormatStringOffset();
    NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
    
    //
    // If the param is a by-value struct or union then set the fTakeAddress
    // flag.
    //
    fTakeAddress =  pChild->IsStruct() || pChild->IsUnion()
                    || pChild->IsXmitRepOrUserMarshal();

    //
    // If the param is an array and we're in the server stub then we
    // must dereference it.
    //
    fDereference = (pCCB->GetCodeGenSide() == CGSIDE_SERVER) &&
                   pChild->IsArray();

    //
    // For ref pointers with no funky attributes, we optimize by calling
    // the pointee's routine directly.
    //
    if ( pChild->IsPointer() && ((CG_POINTER *)pChild)->IsBasicRefPointer() )
        {
        CG_POINTER *    pPointer;

        pPointer = (CG_POINTER *) pChild;

        switch ( pPointer->GetCGID() )
            {
            case ID_CG_STRING_PTR :
                if ( ((CG_STRING_POINTER *)pPointer)->IsStringableStruct() )
                    break;

                FormatOffset = pPointer->GetFormatStringOffset() + 2;
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;

            case ID_CG_SIZE_STRING_PTR :
                if ( ((CG_STRING_POINTER *)pPointer)->IsStringableStruct() )
                    break;

                FormatOffset = pPointer->GetPointeeFormatStringOffset();
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;

            case ID_CG_STRUCT_STRING_PTR :
                break;

            default :
                if ( ID_CG_CS_TAG == pPointer->GetChild()->GetCGID() )
                    {
                    ParamId = ID_CG_CS_TAG;
                    break;
                    }

                FormatOffset = pPointer->GetPointeeFormatStringOffset();
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;
            }
        }

    if ( ID_CG_CS_TAG == ParamId )
        {
        ISTREAM *   pStream = pCCB->GetStream();

        pStream->WriteOnNewLine( STUB_MSG_LENGTH_VAR_NAME " += 4; /* " );
        pStream->Write( pParamName );
        pStream->Write( " */" );
        pStream->NewLine();

        return;
        }

    Out_NdrBufferSizeCall( pCCB,
                           pNdrRoutineNames[NameIndex],
                           pParamName,
                           FormatOffset,
                           fTakeAddress,
                           fDereference,
                           FALSE );     // _StubMsg
}


void
GenDontCallFreeInstAssign(
    CCB *   pCCB,
    int     SetupValue
    )
/*++
    a helper routine for GenNdrFreeCall.
    Generates an assignment that sets or resets StubMsg.fDontCallFreeInst.
--*/
{
    ISTREAM * pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( STUB_MESSAGE_VAR_NAME );
    pStream->Write( ".fDontCallFreeInst = " );
    pStream->Write( SetupValue ? "1;"
                               : "0;" );
}

void
CG_PARAM::GenNdrFreeCall( CCB * pCCB )
/*++

Routine Description :

    Outputs a parameter's ndr free routine call.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{

    // BUG BUG, this needs to be cleaned up for NDR64
    MIDL_ASSERT( !pCommand->IsNDR64Run() );


    CG_PROC *           pProc;
    CG_NDR *            pChild;
    FORMAT_STRING *     pFormatString;
    PNAME               pParamName;
    long                Index;
    BOOL                fTakeAddress;
    BOOL                fDereference;

    pProc = (CG_PROC *) pCCB->GetCGNodeContext();

    //
    // If the proc uses RpcSs then don't emit any freeing code.
    //
    if ( pProc->MustInvokeRpcSSAllocate() )
        return;

    pChild = (CG_NDR *) GetChild();

    if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
        pChild = (CG_NDR *) pChild->GetChild();

    //
    // Check if we need to make a call to an NDR freeing routine for this data.
    //
    if ( pChild->ShouldFreeOffline() ||
         IsParamPartialIgnore() )
        {
        if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
            pChild = (CG_NDR *) pChild->GetChild();

        GenNdrTopLevelAttributeSupport( pCCB );
    
        pFormatString = pCCB->GetFormatString();

        Index = (long) pFormatString->GetFormatChar(
                                pChild->GetFormatStringOffset() );

        pParamName = GetResource()->GetResourceName();

        //
        // If the param is a by-value struct or union then set the fTakeAddress
        // flag.
        //
        fTakeAddress =  pChild->IsStruct() || pChild->IsUnion()
                        || pChild->IsXmitRepOrUserMarshal();

        fDereference = FALSE;

        if (  GetDontCallFreeInst() )
            GenDontCallFreeInstAssign( pCCB, 1 );

        Out_NdrFreeCall( pCCB,
                         pNdrRoutineNames[Index],
                         pParamName,
                         pChild->GetFormatStringOffset(),
                         fTakeAddress,
                         fDereference );

        if (  GetDontCallFreeInst() )
            GenDontCallFreeInstAssign( pCCB, 0 );
        }

    //
    // Now generate any needed inline freeing.
    //
    pChild->GenFreeInline( pCCB );
}

void
CG_PARAM::GenNdrTopLevelAttributeSupport(
    CCB *   pCCB,
    BOOL    fForClearOut )
/*++

Routine Description :

    Outputs the assignment(s) to the stub message MaxCount, ActualCount,
    and/or Offset fields, for support of top level conformant and/or
    varying arrays, attributed pointers, and non-encapsulated unions for
    mixed model stubs.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{
    CG_NDR *            pChild;
    ISTREAM *           pStream = pCCB->GetStream();
    expr_node *     pExpr;
    expr_node *     pSizeOrSwitchIsExpr;
    expr_node *     pFirstIsExpr;
    expr_node *     pLengthIsExpr;
    ID_CG               ParamId;

    pChild = (CG_NDR *)GetChild();
    ParamId = pChild->GetCGID();

    // Skip over pointers and generic handles.
    while ( ParamId == ID_CG_PTR || ParamId == ID_CG_GENERIC_HDL )
        {
        pChild = (CG_NDR *) pChild->GetChild();
        ParamId = pChild->GetCGID();
        }

    //
    // Multidimensional conformant/varying arrays and sized pointers of
    // sized pointers need some special handling.
    //
    if ( (pChild->IsArray() && ((CG_ARRAY *)pChild)->IsMultiConfOrVar()) ||
         (pChild->IsPointer() && ((CG_POINTER *)pChild)->IsMultiSize()) )
        {
        CSzBuffer Buffer;

        pStream->NewLine();

/*
        if ( (ParamId == ID_CG_CONF_ARRAY) ||
             (ParamId == ID_CG_CONF_VAR_ARRAY) ||
             (ParamId == ID_CG_SIZE_PTR) ||
             (ParamId == ID_CG_SIZE_LENGTH_PTR) )
*/
            {
            Buffer.Set(pChild->IsArray() ? "(unsigned long) " : "");
            Buffer.Append("_maxcount_");
            Buffer.Append(GetType()->GetSymName());

            if ( pChild->IsPointer() )
                pExpr = new expr_variable(
                                STUB_MESSAGE_VAR_NAME ".SizePtrCountArray" );
            else
                pExpr = new expr_variable(
                                STUB_MESSAGE_VAR_NAME ".MaxCount" );

            pExpr = new expr_assign( pExpr, new expr_variable( Buffer ) );
            pExpr->Print( pStream );
            pStream->Write( ';' );
            pStream->NewLine();
            }
/*
        if ( (ParamId == ID_CG_CONF_VAR_ARRAY) ||
             (ParamId == ID_CG_VAR_ARRAY) ||
             (ParamId == ID_CG_SIZE_LENGTH_PTR) )
*/
            {
            Buffer.Set(pChild->IsArray() ? "(unsigned long) " : "");
            Buffer.Append("_offset_");
            Buffer.Append(GetType()->GetSymName());

            if ( pChild->IsPointer() )
                pExpr = new expr_variable(
                            STUB_MESSAGE_VAR_NAME ".SizePtrOffsetArray" );
            else
                pExpr = new expr_variable(
                            STUB_MESSAGE_VAR_NAME ".Offset" );

            pExpr = new expr_assign( pExpr, new expr_variable( Buffer ) );
            pExpr->Print( pStream );
            pStream->Write( ';' );
            pStream->NewLine();

            Buffer.Set(pChild->IsArray() ? "(unsigned long) " : "");
            Buffer.Append("_length_");
            Buffer.Append(GetType()->GetSymName());

            if ( pChild->IsPointer() )
                pExpr = new expr_variable(
                            STUB_MESSAGE_VAR_NAME ".SizePtrLengthArray" );
            else
                pExpr = new expr_variable(
                            STUB_MESSAGE_VAR_NAME ".ActualCount" );

            pExpr = new expr_assign( pExpr, new expr_variable( Buffer ) );
            pExpr->Print( pStream );
            pStream->Write( ';' );
            pStream->NewLine();
            }

        return;
        }

    //
    // We check here if the parameter is a top level attributed array or
    // pointer, a non-encapsulated union or a pointer to a non-encapsulated
    // union.  If it isn't, then return.
    //
    switch ( ParamId )
        {
        case ID_CG_CONF_ARRAY :
        case ID_CG_CONF_VAR_ARRAY :
        case ID_CG_VAR_ARRAY :
        case ID_CG_CONF_STRING_ARRAY :
        case ID_CG_SIZE_PTR :
        case ID_CG_SIZE_LENGTH_PTR :
        case ID_CG_SIZE_STRING_PTR :
        case ID_CG_UNION :
            break;

        case ID_CG_BC_PTR :
            if ( pCCB->GetCodeGenSide() == CGSIDE_SERVER )
                return;

            {
            ISTREAM *       pStream = pCCB->GetStream();
            expr_node       *pExpr, *pSizeExpr;
            CG_BYTE_COUNT_POINTER *     pByteCount;

            pByteCount = (CG_BYTE_COUNT_POINTER *) pChild;

            pSizeExpr = MakeExpressionOfCastToTypeName( "unsigned long", 
                                                        new expr_variable(
                            pByteCount->GetByteCountParam()->GetSymName() ) );

            pExpr = new expr_assign(
                        new expr_variable( STUB_MESSAGE_VAR_NAME ".MaxCount" ),
                        pSizeExpr );

            pStream->NewLine();
            pExpr->Print( pStream );
            pStream->Write( ';' );
            pStream->NewLine();
            }

            return;

        case ID_CG_IIDIS_INTERFACE_PTR:
            {
            CG_IIDIS_INTERFACE_POINTER *  pIfPointer;
            ISTREAM *               pStream = pCCB->GetStream();

            pIfPointer = (CG_IIDIS_INTERFACE_POINTER *) pChild;

            if ( ! pIfPointer->GetIIDExpr() )
                return;

            pStream->NewLine();

            if ( pCommand->Is64BitEnv() )
                {
                // _StubMsg.MaxCount = (ULONG_PTR) ( riid );
                pStream->Write( STUB_MESSAGE_VAR_NAME
                                ".MaxCount = (ULONG_PTR) ( " );
                }
            else
                {
                // _StubMsg.MaxCount = (unsigned long) ( riid );
                pStream->Write( STUB_MESSAGE_VAR_NAME
                                ".MaxCount = (unsigned long) ( " );
                }

            pIfPointer->GetIIDExpr()->Print( pStream );
            pStream->Write( " );" );
            pStream->NewLine();
            }

            return;

        default :
            return;
        }
    
    pCCB->GetStream()->NewLine();

    switch ( pChild->GetCGID() )
        {
        case ID_CG_CONF_ARRAY :
            pSizeOrSwitchIsExpr =
                ((CG_CONFORMANT_ARRAY *)pChild)->GetSizeIsExpr();
            pFirstIsExpr = NULL;
            pLengthIsExpr = NULL;
            break;

        case ID_CG_CONF_VAR_ARRAY :
            pSizeOrSwitchIsExpr =
                ((CG_CONFORMANT_VARYING_ARRAY *)pChild)->GetSizeIsExpr();
            pFirstIsExpr =
                ((CG_CONFORMANT_VARYING_ARRAY *)pChild)->GetFirstIsExpr();
            pLengthIsExpr =
                ((CG_CONFORMANT_VARYING_ARRAY *)pChild)->GetLengthIsExpr();
            break;

        case ID_CG_VAR_ARRAY :
            pSizeOrSwitchIsExpr = NULL;
            pFirstIsExpr =
                ((CG_VARYING_ARRAY *)pChild)->GetFirstIsExpr();
            pLengthIsExpr =
                ((CG_VARYING_ARRAY *)pChild)->GetLengthIsExpr();
            break;

        case ID_CG_CONF_STRING_ARRAY :
            pSizeOrSwitchIsExpr =
                ((CG_CONFORMANT_STRING_ARRAY *)pChild)->GetSizeIsExpr();
            pFirstIsExpr = NULL;
            pLengthIsExpr = NULL;
            break;

        case ID_CG_SIZE_PTR :
            pSizeOrSwitchIsExpr =
                ((CG_SIZE_POINTER *)pChild)->GetSizeIsExpr();
            pFirstIsExpr = NULL;
            pLengthIsExpr = NULL;
            break;

        case ID_CG_SIZE_LENGTH_PTR :
            pSizeOrSwitchIsExpr =
                ((CG_SIZE_LENGTH_POINTER *)pChild)->GetSizeIsExpr();
            pFirstIsExpr =
                ((CG_SIZE_LENGTH_POINTER *)pChild)->GetFirstIsExpr();
            pLengthIsExpr =
                ((CG_SIZE_LENGTH_POINTER *)pChild)->GetLengthIsExpr();
            break;

        case ID_CG_SIZE_STRING_PTR :
            pSizeOrSwitchIsExpr =
                ((CG_SIZE_STRING_POINTER *)pChild)->GetSizeIsExpr();
            pFirstIsExpr = NULL;
            pLengthIsExpr = NULL;
            break;

        case ID_CG_UNION :
        case ID_CG_PTR :
            pSizeOrSwitchIsExpr = GetSwitchExpr();
            pFirstIsExpr = NULL;
            pLengthIsExpr = NULL;
            break;
        }

    if ( pSizeOrSwitchIsExpr )
        {
        pSizeOrSwitchIsExpr = MakeAttrExprWithNullPtrChecks(
                                                     pSizeOrSwitchIsExpr );
        pSizeOrSwitchIsExpr = MakeExpressionOfCastToTypeName( "unsigned long", 
                                                     pSizeOrSwitchIsExpr );

        pExpr = new expr_assign(
                    new expr_variable( STUB_MESSAGE_VAR_NAME ".MaxCount" ),
                    pSizeOrSwitchIsExpr );
        pExpr->Print( pStream );
        pStream->Write( ';' );
        pStream->NewLine();
        }
        
    if ( pFirstIsExpr )
        {
        //
        // For NdrClearOutParams we ignore the first_is() & length_is()
        // attributes in case these are [out] and therefore unitialized.
        //
        if ( fForClearOut )
            {
            pStream->Write( STUB_MESSAGE_VAR_NAME ".Offset = 0;" );
            pStream->NewLine();
            }
        else
            {
            pFirstIsExpr = MakeAttrExprWithNullPtrChecks( pFirstIsExpr );

            pFirstIsExpr = MakeExpressionOfCastToTypeName( "unsigned long", 
                                                            pFirstIsExpr );

            pExpr = new expr_assign(
                        new expr_variable( STUB_MESSAGE_VAR_NAME ".Offset" ),
                        pFirstIsExpr );
            pExpr->Print( pStream );
            pStream->Write( ';' );
            pStream->NewLine();
            }

        //
        // Create a LengthIsExpr if one does not already exist.
        //
        if ( ! pLengthIsExpr )
            {
            expr_node * pSize;

            if ( pChild->IsPointer() )
                {
                // Size/length pointer.
                pSize = ((CG_SIZE_LENGTH_POINTER *)pChild)->GetSizeIsExpr();
                }
            else
                {
                // Conformant varying or varying array.
                pSize = ((CG_ARRAY *)pChild)->GetSizeIsExpr();
                }

            pLengthIsExpr =
                new expr_b_arithmetic( OP_MINUS,
                                        pSize,
                                        pFirstIsExpr );
            }
        }
        
    if ( pLengthIsExpr )
        {
        //
        // For NdrClearOutParams we ignore the first_is() & length_is()
        // attributes in case these are [out] and therefore unitialized.
        //
        if ( fForClearOut )
            {
            pStream->Write( STUB_MESSAGE_VAR_NAME ".ActualCount" " = (unsigned long) " );
            pStream->Write( STUB_MESSAGE_VAR_NAME ".MaxCount;" );
            pStream->NewLine();
            }
        else
            {
            pLengthIsExpr = MakeAttrExprWithNullPtrChecks( pLengthIsExpr );

            pLengthIsExpr = MakeExpressionOfCastToTypeName( "unsigned long", 
                                                            pLengthIsExpr );

            pExpr = new expr_assign(
                        new expr_variable(STUB_MESSAGE_VAR_NAME ".ActualCount"),
                        pLengthIsExpr );
            pExpr->Print( pStream );
            pStream->Write( ";" );
            pStream->NewLine();
            }
        }
}

expr_node *
CG_PROC::GenCoreNdrSingleClientCall(
    CCB *               pCCB,
    PROC_CALL_PLATFORM  Platform )

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Creates the real expression for the ndr single client call.

 Arguments:

    Platform    -  x86, IA64, alpha, etc.
                   An explicit enum type is used to indicate platform.

 Return Value:

    None.
    
 Notes:

    On risc machines, the compiler passes the parameters in registers,
    therefore the client stub is passed the parameters in registers. The
    interpreter needs arguments on the stack. In order to force a spill of the
    parameters from the registers to the stack, we need to pass addr all the
    parameters to NdrClientCall.

        stub_proc( p1, p2, p3 )
            {
            ...
            NdrClientCall( STUB_DESC *,
                           FORMAT_STRING *,
                           &p1,
                           &p2,
                           &p3 );
            ...
            }

    On Alpha the varargs is simply weird. The code generated needs to be

        stub_proc( p1, p2, p3 )
            {
            ...
            NdrClientCall( STUB_DESC *,
                           FORMAT_STRING *,
                           vlist.a0 );
            ...
            }

----------------------------------------------------------------------------*/
{
    char                FormatStringExpr[80];
    expr_proc_call  *   pCallExpr;
    expr_node       *   pExpr;
    CG_PARAM        *   pParam;
    PNAME               pFormatName;
    OPTIM_OPTION        OptimOptions;

    OptimOptions = GetOptimizationFlags();

    //
    // Now construct the expression for the Ndr call.
    //
    
    if ( HasAsyncUUID() )
        {
        if ( pCommand->NeedsNDR64Run() )
            pCallExpr = new expr_proc_call( C_NDR64_CALL_RTN_NAME_DCOM_ASYNC );
        else
            pCallExpr = new expr_proc_call( C_NDR_CALL_RTN_NAME_DCOM_ASYNC );
        }
    else if ( HasAsyncHandle() )
        {
        if ( pCommand->NeedsNDR64Run() )
            pCallExpr = new expr_proc_call( C_NDR64_CALL_RTN_NAME_ASYNC );
        else
            pCallExpr = new expr_proc_call( C_NDR_CALL_RTN_NAME_ASYNC );
        }
    else
        {
        if ( pCommand->NeedsNDR64Run() )
            pCallExpr = new expr_proc_call ( C_NDR64_CALL_RTN_NAME );
        else
            {
            if ( OptimOptions & OPTIMIZE_INTERPRETER_V2 )
                pCallExpr = new expr_proc_call( C_NDR_CALL_RTN_NAME_V2 );
            else
                pCallExpr = new expr_proc_call( C_NDR_CALL_RTN_NAME );
            }
        }

    if ( ! pCommand->NeedsNDR64Run() )
        {
        //
        // Stub Descriptor
        //

        pExpr = new expr_variable( pCCB->GetInterfaceCG()->GetStubDescName() );
        pExpr = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr = MakeExpressionOfCastToTypeName(PSTUB_DESC_STRUCT_TYPE_NAME, pExpr);

        pCallExpr->SetParam( new expr_param( pExpr ) );

        sprintf( FormatStringExpr,
                 "(PFORMAT_STRING) &%s[%d]",
                 PROC_FORMAT_STRING_STRING_FIELD,
                 GetFormatStringOffset() );

        pFormatName = new char [strlen( FormatStringExpr) + 1];
        strcpy( pFormatName, FormatStringExpr );
        pCallExpr->SetParam( new expr_param(
                             new expr_variable( pFormatName ) ) );

        }
    else
        {
        pExpr = new expr_variable ( pCCB->GetInterfaceCG()->GetProxyInfoName() );
        pExpr = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr = MakeExpressionOfCastToTypeName(PMIDL_PROXY_INFO_TYPE_NAME, pExpr);

        pCallExpr->SetParam( new expr_param( pExpr ) );

        pExpr = new expr_constant( (long) ProcNum );

        pCallExpr->SetParam ( new expr_param ( pExpr ) );

        if ( HasComplexReturnType() && !HasAsyncHandle() )
            {
            pExpr = new expr_variable( RETURN_VALUE_VAR_NAME );
            pExpr = MakeAddressExpressionNoMatterWhat( pExpr );
            }
        else
            {
            pExpr = new expr_constant( (long) 0 );
            }

        pCallExpr->SetParam ( new expr_param ( pExpr ) );
        }

    // If this is an object interface the first param is an implicit
    // this param.
    
    if( IsObject() )
        {
        pExpr = new expr_variable("This");
        if( PROC_PLATFORM_IA64 != Platform )
            {
            pExpr = new expr_u_address( pExpr );
            }
        pExpr = MakeCastExprPtrToUChar( pExpr );
        pCallExpr->SetParam( new expr_param( pExpr ) );
        }
    
    /************************************************************************
     If this is a risc platform, then
        if there are actual parameters,
            take the address of each of them
        else
            if it is not an object interface,
                push a 0
            else
                do nothing. since we have already pushed &this.
    
    else // if this is not a risc platform
        if there are actual parameters
            take address of first.
        else
            if it is non object procedure,
                push a 0,
            else
                do nothing since for an object proc we have already pushed &this.
    ************************************************************************/
    
    if ( PROC_PLATFORM_IA64 == Platform )
    {

        ITERATOR I;
        if ( GetMembers(I))
        {
            while (ITERATOR_GETNEXT(I, pParam))
            {
                // Don't include cs_tag params when there is a tag routine
                if ( GetCSTagRoutine() && pParam->IsSomeCSTag() )
                    continue;

                // Don't push the fake parameter that was added for complex
                // return types
                if ( HasComplexReturnType() && NULL == pParam->GetSibling() )
                    continue;

                pExpr = new expr_variable(
                     pParam->GetResource()->GetResourceName());
                pCallExpr->SetParam(new expr_param(pExpr));
            }
        }
        else if ( !IsObject() )
        {
            pExpr = new expr_constant( 0L );
            pCallExpr->SetParam( new expr_param( pExpr ) );
        }

    }
    else if( !IsObject() )
        {
        pParam = (CG_PARAM *) GetChild();

        // Make sure that this is not a cs_tag parameter that is being 
        // omitted because there is a tag routine, 

        if ( GetCSTagRoutine() )
            {
            while ( pParam && pParam->IsSomeCSTag() )
                pParam = (CG_PARAM *) pParam->GetSibling();
            }

        if( pParam )
            {
            pExpr = new expr_u_address (
                                new expr_variable(
                                    pParam->GetResource()->GetResourceName()));

            pExpr = MakeCastExprPtrToUChar( pExpr );
            pCallExpr->SetParam( new expr_param( pExpr ) );
            }
        else
            {
            pExpr = new expr_constant( 0L );
            pExpr = MakeCastExprPtrToUChar( pExpr );
            pCallExpr->SetParam( new expr_param( pExpr ) );
            }
        }

    // Assign the return value if one exists.

    expr_node * pFinalExpr;
    
    if ( GetReturnType() && !HasComplexReturnType() )
        {
        if ( HasAsyncHandle() )
            {
            bool fIsErrorStatus = false;
            if ( GetReturnType()->GetChild()->GetCGID() != ID_CG_CONTEXT_HDL )
                {
                fIsErrorStatus = GetReturnType()->GetChild()->GetType()->GetBasicType()->NodeKind() == NODE_E_STATUS_T;
                }
            if ( fIsErrorStatus || GetCGID() == ID_CG_OBJECT_PROC )
                {
                pFinalExpr = new expr_assign(
                                    new expr_variable( RETURN_VALUE_VAR_NAME ),
                                    pCallExpr );
                }
            else
                {
                pFinalExpr = pCallExpr;
                }
            }
        else
            {
            pFinalExpr = new expr_assign(
                                new expr_variable( RETURN_VALUE_VAR_NAME ),
                                pCallExpr );
            }
        }
    else
        pFinalExpr = pCallExpr;
    
    return pFinalExpr;
}

void CG_PROC::SetupFormatStrings( CCB * pCCB )
{
    if (!cRefSaved++)
    {
        if(!pSavedProcFormatString)
        {
            pSavedProcFormatString = pCCB->GetProcFormatString();
            pSavedFormatString = pCCB->GetFormatString();
        }
    }
}

void CG_PROC::UnsetupFormatStrings(CCB * pCCB )
{
    if (cRefSaved)
        cRefSaved--;
    if (!cRefSaved)
    {
        pCCB->SetProcFormatString(pSavedProcFormatString);
        pCCB->SetFormatString(pSavedFormatString);
    }
}


// --------------------------------------------------
// Routine used for generation of NT 3.5 and NT 3.51
// procedure format strings.
// --------------------------------------------------
void
CG_PROC::GenNdrFormatV1( CCB * pCCB )
/*++

Routine Description :

    Generates the procedure format strings usable on NT 3.5 and
    NT 3.51 systems.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{
    CG_ITERATOR         Iterator;
    CG_PARAM *          pParam;
    FORMAT_STRING *     pProcFormatString;
    CG_NDR *            pOldCGNodeContext;
    short               ParamNum;


    SetupFormatStrings(pCCB);
    
    if ( GetFormatStringOffset() != -1 )
    {
        UnsetupFormatStrings(pCCB);
        return;
    }

    pCCB->SetInObjectInterface( IsObject() );

    pOldCGNodeContext = pCCB->SetCGNodeContext( this );

    //
    // If this procedure uses an explicit handle then set the
    // NdrBindDescriptionOffset to 0 so that it will not try to output it's
    // description when given the GenNdrParamOffLine method in the loop below.
    // It's description must be part of the procedure description.
    //
    if ( GetHandleUsage() == HU_EXPLICIT )
        {
        CG_HANDLE * pHandle = GetHandleClassPtr();

        pHandle->SetNdrBindDescriptionOffset( 0 );

        if ( pHandle->GetCGID() == ID_CG_CONTEXT_HDL )
            {
            // The context handle directs the call.
            ((CG_CONTEXT_HANDLE *)pHandle)->SetCannotBeNull();
            }
        }

    GetMembers( Iterator );

    ParamNum = 0;

    //
    // Generate the offline portion of the format string for all of the params.
    //
    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;

        if (pParam->IsAsyncHandleParam())
            continue;

        pParam->SetParamNumber( ParamNum++ );

        pChild = (CG_NDR *) pParam->GetChild();

        pCCB->SetCurrentParam( (CG_PARAM *) pParam );
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pParam );

        pChild->GenNdrParamOffline( pCCB );

        pCCB->SetCurrentParam( 0 );
        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    //
    // Generate the format string for the return type if needed.
    //
    if ( GetReturnType() )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;

        GetReturnType()->SetParamNumber( ParamNum );
        
        pChild = (CG_NDR *) GetReturnType()->GetChild();

        pCCB->SetCurrentParam( GetReturnType() );
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( GetReturnType() );

        pChild->GenNdrParamOffline( pCCB );

        pCCB->SetCurrentParam( 0 );
        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    pProcFormatString = pCCB->GetProcFormatString();

    SetFormatStringOffset( pProcFormatString->GetCurrentOffset() );

    //
    // Generate procedure description stuff for the interpreter if needed.
    //
    if ( (pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER)
         ||  HasAPicklingAttribute() )
        GenNdrFormatProcInfo( pCCB );

    ITERATOR_INIT( Iterator );

    SetFormatStringParamStart( pProcFormatString->GetCurrentOffset() );

    //
    // Now generate the param info at the end of the format string.
    //
    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;

        if ( pParam->IsExtraStatusParam() || pParam->IsAsyncHandleParam() )
            continue;

        pChild = (CG_NDR *) pParam->GetChild();

        if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
            pChild = (CG_NDR *) pChild->GetChild();

        //
        // Ouput the param directional attribute.
        //

        if ( ! pParam->IsParamOut() )
            {
            if ( pParam->GetDontCallFreeInst() )
                pProcFormatString->PushFormatChar( FC_IN_PARAM_NO_FREE_INST );
            else
                if ( pChild->IsSimpleType() ||
                     pChild->GetCGID() == ID_CG_PRIMITIVE_HDL )
                    pProcFormatString->PushFormatChar( FC_IN_PARAM_BASETYPE );
                else
                    pProcFormatString->PushFormatChar( FC_IN_PARAM );
            }
        else
            {
            if ( pParam->IsParamPartialIgnore() )
               {
               pProcFormatString->PushFormatChar( FC_PARTIAL_IGNORE_PARAM );
               }

            else 
               {
               if ( ! pParam->IsParamIn() )
                   pProcFormatString->PushFormatChar( FC_OUT_PARAM );

               if ( pParam->IsParamIn() && pParam->IsParamOut() )
                   pProcFormatString->PushFormatChar( FC_IN_OUT_PARAM );
               }
            }
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pParam );

        pChild->GenNdrParamDescriptionOld( pCCB );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    if ( GetReturnType() )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;
        
        pChild = (CG_NDR *) GetReturnType()->GetChild();

        if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
            pChild = (CG_NDR *) pChild->GetChild();

        if ( pChild->IsSimpleType() )
            pProcFormatString->PushFormatChar( FC_RETURN_PARAM_BASETYPE );
        else
            pProcFormatString->PushFormatChar( FC_RETURN_PARAM );

        pOldPlaceholder = pCCB->SetLastPlaceholderClass( GetReturnType() );

        pChild->GenNdrParamDescriptionOld( pCCB );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }
    else
        {
        pProcFormatString->PushFormatChar( FC_END );
        pProcFormatString->PushFormatChar( FC_PAD );
        }

    pCCB->SetCGNodeContext( pOldCGNodeContext );

    pCCB->SetInObjectInterface( FALSE );

    SetFormatStringEndOffset( pProcFormatString->GetCurrentOffset() );

    // save delta, in case the routine is optimized
    short   usParamStartDelta   = (short) ( GetFormatStringParamStart() -
                                            GetFormatStringOffset() );

    pProcFormatString->OptimizeFragment( this );

    // Set param start!!!
    SetFormatStringParamStart( GetFormatStringOffset() + usParamStartDelta );
    UnsetupFormatStrings(pCCB);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\pipendr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1995-1999 Microsoft Corporation

 Module Name:

    pipendr.cxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    pipe types.

 Notes:

 History:

    SteveBl   Dec-1995        Created.
    
 ----------------------------------------------------------------------------*/

#include "becls.hxx"

extern CMD_ARG * pCommand;

#pragma hdrstop

void
CG_PIPE::GenNdrFormat( CCB * pCCB )
/*++
    The format string is:

        FC_PIPE     
        flags & alignment<1>        // pointer flags on the higher nibble
        index to type desc<2>       // the usual
        memory size<2>              
        buffer size<2>              // wire size, essential

    If either memory size or buffer size > 64k then 
    the FC_BIG_PIPE flag is set and the following format string is used:

        FC_PIPE     
        flags & alignment<1>        
        index to type desc<2>       
        memory size<4>          
        buffer size<4>          
        
--*/
{
    if ( GetFormatStringOffset() != -1 ) 
        return;

    pCommand->GetNdrVersionControl().SetHasRawPipes();

    FORMAT_STRING * pFormatString;
    CG_NDR *        pChild;
    long            ChildOffset;

    // Format offset

    pFormatString = pCCB->GetFormatString();

    pChild = (CG_NDR *) GetChild();

    MIDL_ASSERT( pChild );

    // Do this in case the child is a simple type.
    ChildOffset = pFormatString->GetCurrentOffset();

    pChild->GenNdrFormat( pCCB );

    // Again, do this in case the child is a simple type.
    pFormatString->Align();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    // Real stuff now

    pFormatString->PushFormatChar( FC_PIPE );

    // Compute the memory size and buffer size.
    // Account for alignment

    unsigned long uMemorySize         = pChild->GetMemorySize();
    
    unsigned long uBufferSize = pChild->HasAFixedBufferSize() 
                                           ? pChild->GetWireSize() 
                                           : 0;

    // Now the flag byte.
    
    unsigned char FlagByte = unsigned char(pChild->GetWireAlignment() - 1);

    if (uMemorySize > 0xffff || uBufferSize > 0xffff)
        FlagByte |= FC_BIG_PIPE;

    if ( IsObjectPipe() )
        FlagByte |= FC_OBJECT_PIPE;

    if ( GetRangeAttribute() )
        {
        FlagByte |= FC_PIPE_HAS_RANGE;
        }

    pFormatString->PushByte( FlagByte );

    // Now the index to the type desc

    if ( pChild->IsSimpleType() )
        {
        pFormatString->PushShortOffset(
                           ChildOffset - pFormatString->GetCurrentOffset() );
        }
    else
        {
        pFormatString->PushShortOffset(
                           pChild->GetFormatStringOffset() - 
                             pFormatString->GetCurrentOffset() );
        }

    // Now push the memory size and buffer size.

    if (FlagByte & FC_BIG_PIPE)
    {
        pFormatString->PushLong( uMemorySize);
        pFormatString->PushLong( uBufferSize);
    }
    else
    {
        pFormatString->PushShort( (short) uMemorySize);
        pFormatString->PushShort( (short) uBufferSize);
    }
    if ( GetRangeAttribute() )
        {
        // RKK64: TBD support for a range check on hyper.
        pFormatString->PushLong( (ulong) GetRangeAttribute()->GetMinExpr()->GetValue() );  // min.
        pFormatString->PushLong( (ulong) GetRangeAttribute()->GetMaxExpr()->GetValue() );  // max.
        }

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
    pFormatString->OptimizeFragment( this );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\pungent.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

	pungent.cxx

 Abstract:

	Implementations of the pointer cg class unmarshalling methods.

 Notes:

	The pointer unmarshalling is a bit tricky, so put into another file.

 History:

 	Dec-10-1993		VibhasC		Created

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

//
// This method is also supposed to init any embedded pointers.
//

CG_STATUS
CG_POINTER::GenAllocateForUnMarshall(
	CCB		*	pCCB )
	{

	if( IsRef() )
		{
		Out_If_IfAllocRef(pCCB,
			 	   		pCCB->GetDestExpression(),
			 	   		pCCB->GetSourceExpression(),
		     	   //		FinalSizeExpression( pCCB )
		     	   		new expr_constant( 4L )
		   		  		);
		}
	else
		{
		Out_If_IfAlloc(pCCB,
			 	   		pCCB->GetDestExpression(),
			 	   		pCCB->GetSourceExpression(),
		     	   //		FinalSizeExpression( pCCB )
		     	   		new expr_constant( 4L )
		   		  		);
		}
	
	Out_Assign( pCCB,
				MakeDereferentExpressionIfNecessary(pCCB->GetDestExpression()),
				new expr_constant( 0L ) );

	Out_Endif( pCCB );
	return CG_OK;
	}

void
CG_POINTER::PointerChecks(
	CCB		*	pCCB )
	{
	short	CILevel = pCCB->GetCurrentIndirectionLevel();
	short	CELevel	= pCCB->GetCurrentEmbeddingLevel();
	BOOL	fClientSideTopLevelPtr = FALSE;

	if( !IsRef() )
		{
		if( (pCCB->GetCodeGenSide() == CGSIDE_CLIENT ) && (CILevel == 0) &&
			!pCCB->IsReturnContext()
		  )
		  fClientSideTopLevelPtr = TRUE;

		if( fClientSideTopLevelPtr )
			{
			Out_Comment( pCCB, "(Check TopLevelPtrInBufferOnly )" );
			Out_TLUPDecisionBufferOnly( pCCB,
										pCCB->GetPtrToPtrInBuffer(),
										MakeAddressOfPointer( pCCB->GetDestExpression() ) );
			}
		else if( CELevel == 0 )
			{
			Out_Comment( pCCB, "if( CheckTopLevelPtrInBufferAndMem )" );
			Out_TLUPDecision( pCCB,
							  pCCB->GetPtrToPtrInBuffer(),
							  MakeAddressOfPointer(pCCB->GetDestExpression()));
			}
		else
			{
			Out_UPDecision( pCCB,
							  pCCB->GetPtrToPtrInBuffer(),
							  MakeAddressOfPointer(pCCB->GetDestExpression()));
			}
		}
	}

void
CG_POINTER::EndPointerChecks(
	CCB		*	pCCB )
	{

	// If it is a ref pointer, no checks were made in the first place.

	if( !IsRef() )
		Out_Endif( pCCB );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\ptrndr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1993-2000 Microsoft Corporation

 Module Name:

    ptrndr.hxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    pointer types, and the new NDR marshalling and unmarshalling calls.

 Notes:


 History:

    DKays     Oct-1993     Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

static long StringToHex( char * str );
extern CMD_ARG          *   pCommand;
#define OUT_CORRELATION_DESC( x, y )    (x)->PushCorrelationFlagsShort(y)

BOOL
CG_POINTER::IsPointerToBaseType()
{
    BOOL fIsPointerToBaseType = FALSE;
    CG_NDR * pChild;

    if(GetCGID() == ID_CG_PTR)
        {
        pChild = (CG_NDR *)GetChild();

        if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
            pChild = (CG_NDR *)pChild->GetChild();

        if ( pChild->IsSimpleType() )
            fIsPointerToBaseType = TRUE;
        }

    return fIsPointerToBaseType;
}

BOOL
CG_POINTER::IsPointerToPointer()
{
    BOOL fIsPointerToPointer = FALSE;
    CG_NDR * pChild;

    if(GetCGID() == ID_CG_PTR)
        {
        pChild = (CG_NDR *)GetChild();

        if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
            pChild = (CG_NDR *)pChild->GetChild();

        if (pChild->IsPointer())
            fIsPointerToPointer = TRUE;
        }

    return fIsPointerToPointer;
}

BOOL
CG_POINTER::IsBasicRefPointer()
{
    short   Attributes;

    if ( ( IsInterfacePointer() ) ||
         (GetCGID() == ID_CG_BC_PTR) ||
         (GetCGID() == ID_CG_STRUCT_STRING_PTR) ||
         (GetPtrType() != PTR_REF) ||
         IsPointerToBaseType() )
        return FALSE;

    if ( ((GetCGID() == ID_CG_STRING_PTR) ||
          (GetCGID() == ID_CG_SIZE_STRING_PTR)) &&
         ((CG_STRING_POINTER *)this)->IsStringableStruct() )
        return FALSE;

    Attributes = GetAllocateDetails();

    if ( IsPointerToPointer() ||
         IS_ALLOCATE(Attributes, ALLOCATE_ALL_NODES) ||
         IS_ALLOCATE(Attributes, ALLOCATE_DONT_FREE) )
        return FALSE;

    return TRUE;
}

BOOL
CG_POINTER::IsMultiSize()
/*
    Count the sized pointers below a pointer.
    At least 2 are needed to come up with TRUE.
       size_is(a) and size_is(,b) should give false
       size_is(a,b) and size_is(,a,b) should give true
*/
{
    return (SizedDimensions() > 1);
}

long
CG_POINTER::SizedDimensions()
{
    CG_NDR *    pNdr;
    long        Dim;
    bool        SeenOne = false;

    // Accept (non-sized) pointers before a sized pointer but not after.
    // Checking for pointer breaks a recursion as well.

    Dim = 0;
    pNdr = this;

    while ( pNdr  &&  pNdr->IsPointer() )
        {
        if ( (pNdr->GetCGID() == ID_CG_SIZE_PTR) ||
             (pNdr->GetCGID() == ID_CG_SIZE_LENGTH_PTR) ||
             (pNdr->GetCGID() == ID_CG_SIZE_STRING_PTR) )
            {
            Dim++;
            SeenOne = true;
            }
        else
            {
            if ( SeenOne )
                break;
            }
        pNdr = (CG_NDR *) pNdr->GetChild();
        }

    return Dim;
}

long
CG_POINTER::FixedBufferSize( CCB * pCCB )
{
    long    BufSize;

    //
    // Must give up on string or sized pointers.
    //
    if ( GetCGID() != ID_CG_PTR )
        return -1;

    BufSize = ((CG_NDR *)GetChild())->FixedBufferSize( pCCB );

    if ( BufSize == -1 )
        return -1;

    BufSize += ( MAX_WIRE_ALIGNMENT + SIZEOF_WIRE_PTR());

    return BufSize;
}

BOOL
CG_POINTER::InterpreterAllocatesOnStack(
    CCB *       pCCB,
    CG_PARAM *  pMyParam,
    long *      pAllocationSize )
{
    CG_NDR *    pNdr;
    long        OutSize;

    if ( ! pMyParam )
        return FALSE;

    pNdr = (CG_NDR *) GetChild();

    // 
    // [cs_tag] params that are omitted because of a tag routine can't be on
    // the allocated on the stack because they don't exist!
    //
    if ( pNdr->GetCGID() == ID_CG_CS_TAG )
        {
        CG_PROC *pProc = (CG_PROC *) pCCB->GetCGNodeContext();

        if ( pProc->GetCSTagRoutine() )
            {
            *pAllocationSize = 0;
            return FALSE;
            }
        }

    if ( pNdr->GetCGID() == ID_CG_GENERIC_HDL )
        pNdr = (CG_NDR *) pNdr->GetChild();

    if ( pNdr->GetCGID() == ID_CG_CONTEXT_HDL )
        {
        //
        // These get the "allocated on stack" attribute but a size of 0 since
        // they are allocated by calling NDRSContextUnmarshall.
        //
        *pAllocationSize = 0;
        return TRUE;
        }

    //
    // Make sure this pointer is a top level parameter and doesn't have
    // any allocate attributes.
    //
    if ( (pMyParam->GetCGID() == ID_CG_RETURN) ||
         (pMyParam->GetChild() != this) ||
         pMyParam->IsForceAllocate()    ||
         IS_ALLOCATE( GetAllocateDetails(), ALLOCATE_ALL_NODES ) ||
         IS_ALLOCATE( GetAllocateDetails(), ALLOCATE_DONT_FREE ) )
        return FALSE;

    OutSize = pCCB->GetInterpreterOutSize();

    //
    // Watch for [out] only ref to ref pointers as they should be
    // handled by NdrOutInit in the new interpreter, not on stack.
    //

    if ( ! pMyParam->IsParamIn()  &&  IsRef()  &&
         IsPointerToPointer()  &&  ((CG_POINTER *)pNdr)->IsRef() )
        return FALSE;

    //
    // Look for pointer to pointer, [out] only pointer to base type, or
    // pointer to enum16 of any direction.
    //
    if ( IsPointerToPointer() ||
         (IsPointerToBaseType() && ! pMyParam->IsParamIn()) ||
         (IsPointerToBaseType() &&
          (((CG_BASETYPE *)pNdr)->GetFormatChar() == FC_ENUM16) &&
          pMyParam->IsParamIn()) )
        {
        if ( (OutSize + 8) <= MAX_INTERPRETER_OUT_SIZE )
            {
            *pAllocationSize = 8;
            pCCB->SetInterpreterOutSize( pCCB->GetInterpreterOutSize() + 8 );
            return TRUE;
            }
        }

    //
    // Finished with [in], [in,out] cases now.
    //
    if ( pMyParam->IsParamIn() )
        return FALSE;

    //
    // This covers [out] pointers to structs and unions.  We don't allow
    // any one parameter to eat up too much of the total stack space
    // the interpreter has set aside for this optimization.
    //
    if ( pNdr->GetMemorySize() <= MAX_INTERPRETER_PARAM_OUT_SIZE )
        {
        OutSize += (pNdr->GetMemorySize() + 7) & ~0x7;

        if ( OutSize <= MAX_INTERPRETER_OUT_SIZE )
            {
            *pAllocationSize = (pNdr->GetMemorySize() + 7) & ~0x7;
            pCCB->SetInterpreterOutSize(
                        pCCB->GetInterpreterOutSize() + *pAllocationSize );
            return TRUE;
            }
        }

    return FALSE;
}

void
CG_POINTER::GetTypeAndFlags( CCB *pCCB, NDR64_POINTER_FORMAT *format )
{
    CG_PARAM *          pParam;
    short               Attributes;

    pParam = pCCB->GetCurrentParam();

    BOOL IsNDR64 = pCommand->IsNDR64Run();

    //
    // Set the pointer type.
    //
    switch ( GetPtrType() )
        {
        case PTR_REF :
            format->FormatCode = (NDR64_FORMAT_CHAR)(IsNDR64 ? FC64_RP : FC_RP);
            break;

        case PTR_UNIQUE :
            //
            // Check if this is a unique pointer in an OLE interface, but
            // is not the top most pointer.
            //
            if ( pCCB->IsInObjectInterface() &&
                 pParam->IsParamOut() &&
                 pParam->GetChild() != this )
                {
                format->FormatCode = (NDR64_FORMAT_CHAR)(IsNDR64 ? FC64_OP : FC_OP);
                }
            else
                {
                format->FormatCode = (NDR64_FORMAT_CHAR)(IsNDR64 ? FC64_UP : FC_UP);
                }

            break;

        case PTR_FULL :
            format->FormatCode = (NDR64_FORMAT_CHAR)(IsNDR64 ? FC64_FP : FC_FP);
            break;
        }

    //
    // Now the attributes.
    //
    format->Flags = 0;

    Attributes = GetAllocateDetails();

    if ( IS_ALLOCATE(Attributes, ALLOCATE_ALL_NODES) )
        format->Flags |= FC_ALLOCATE_ALL_NODES;
    
    if ( IS_ALLOCATE(Attributes, ALLOCATE_DONT_FREE) )
        format->Flags |= FC_DONT_FREE;

    if ( GetCGID() == ID_CG_PTR )
        {
        //
        // Check if we are allocated on the stack by the stub.  Currently this
        // only works for top level pointers.
        //
        if ( ! ShouldPointerFree() &&
             ! (pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER) )
            {
            format->Flags |= FC_ALLOCED_ON_STACK;
            }

        //
        // For the interpreter we set the alloced on stack attribute for
        // those [out] pointers which we will be able to "allocate" on the
        // server interpreter's stack.  We also do this for [in,out] double
        // pointers.
        // The version 1 interpreter simply looks for pointers to context
        // handles.
        //
        if ( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER )
            {
            if ( ! (pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER_V2) )
                {
                if ( ((CG_NDR *)GetChild())->GetCGID() == ID_CG_CONTEXT_HDL )
                    format->Flags |= FC_ALLOCED_ON_STACK;
                }
            else
                {
                long    OutSize;

                if ( InterpreterAllocatesOnStack( pCCB, pParam, &OutSize ) )
                    format->Flags |= FC_ALLOCED_ON_STACK;
                }
            }
        }

    //
    // Check for a pointer to simple type, non-sized string, or pointer to
    // pointer.
    //
    if ( IsPointerToBaseType() || (GetCGID() == ID_CG_STRING_PTR) )
        format->Flags |= FC_SIMPLE_POINTER;

    if ( IsPointerToPointer() )
        format->Flags |= FC_POINTER_DEREF;

    SetFormatAttr( format->Flags );
}


void
CG_POINTER::GenNdrPointerType( CCB * pCCB )
/*++

Routine Description :

    Generates the first two bytes of a pointer's format string description.

Arguments :

    pCCB        - pointer to the code control block.

Return:

    Returns FALSE if the format string for the pointer type has already been
    generated, otherwise returns TRUE.

 --*/
{
    NDR64_POINTER_FORMAT    format;

    GetTypeAndFlags( pCCB, &format );

    pCCB->GetFormatString()->PushPointerFormatChar( (unsigned char) format.FormatCode );
    pCCB->GetFormatString()->PushByte( format.Flags );
}

void
CG_POINTER::RegisterRecPointerForFixup( 
    CCB * pCCB,
    long  OffsetAt )
/*++
    Register a simple pointer for fixup.
    Don't register qualified pointers, byte pointers etc.
--*/
{
    // This routine should be called only for ID_CG_PTR pointers, but check
    // just in case.

    if ( GetCGID() == ID_CG_PTR )
        {
        pCCB->RegisterRecPointerForFixup( (CG_NDR *) GetChild(), OffsetAt );
        }
} 


void
CG_POINTER::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a pointer to anything.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{

    FORMAT_STRING *     pFormatString = pCCB->GetFormatString();
    long                StartOffset   = pFormatString->GetCurrentOffset();
    
    if ( GetFormatStringOffset() != -1 )
        return;

    SetFormatStringOffset( StartOffset );
    SetFormatStringEndOffset( StartOffset + 4 );

    if ( GenNdrFormatAlways( pCCB ) == 0 )
        {
        // Don't optimize out when the pointee hasn't been generated.
        return;
        }

    // here, we assume all pointers generate 4 bytes
    pFormatString->OptimizeFragment( this );

}

long
CG_POINTER::GenNdrFormatAlways( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a pointer to anything.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING *     pFormatString;
    long                Offset;

    pFormatString = pCCB->GetFormatString();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    GenNdrPointerType( pCCB );

    //
    // If it's an unattributed pointer to a simple type then the format
    // string is optimized.
    //
    if ( IsPointerToBaseType() )
        {
        GenNdrFormatPointee( pCCB );

        // True simple types are represented as 1 byte (e.g. FC_LONG) and thus
        // subsequent stuff needs to be aligned.  Ranges (which are also 
        // considered simpe types) get a more standard, already aligned
        // representation

        if ( pFormatString->GetCurrentOffset() & 1 )
            pFormatString->PushFormatChar( FC_PAD );

        // return something non-zero to mark it ok for optimizing out.
        return GetFormatStringOffset();
        }

    // Get the current offset.
    Offset = pFormatString->GetCurrentOffset();

    // Push a short for the offset to be filled in later.
    pFormatString->PushShortOffset( 0 );

    // Generate the pointee's format string.
    GenNdrFormatPointee( pCCB );

    // Now fill in the offset field correctly.  
    // Register for fixup if the offset isn't known yet. Note that we cannot
    // use RegisterComplexEmbeddedForFixups because it uses a relative offset.

    if ( 0 == GetPointeeFormatStringOffset() )
        RegisterRecPointerForFixup( pCCB, GetFormatStringOffset() + 2 );
    
    pFormatString->PushShortOffset( GetPointeeFormatStringOffset() - Offset,
                                    Offset );

    return GetPointeeFormatStringOffset();
}

void
CG_POINTER::GenNdrParamOffline( CCB * pCCB )
{
    GenNdrFormat( pCCB );
}

void
CG_POINTER::GenNdrFormatPointee( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for the pointee of an
    unattributed pointer to anything.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    CG_NDR *    pChild;

    pChild = (CG_NDR *)GetChild();

    if (pChild->IsProc())
    {
        MIDL_ASSERT(0);
    } 
    else
    {
        //
        // For unattributed pointers (no size or length), this is simply a
        // call to the child's GenNdrFormat method.
        //
        pChild->GenNdrFormat( pCCB );

        SetPointeeFormatStringOffset( pChild->GetFormatStringOffset() );
    }
}

BOOL
CG_POINTER::ShouldFreeOffline()
{
    CG_NDR *    pNdr;

    //
    // The order here is very, very important.
    //

    if ( IsAllocateDontFree() )
        return FALSE;

    pNdr = (CG_NDR *) GetChild();

    //
    // Skip past generic handle nodes.
    //
    if ( pNdr->GetCGID() == ID_CG_GENERIC_HDL )
        pNdr = (CG_NDR *) pNdr->GetChild();

    //
    // Check for handles.
    //
    if ( (pNdr->GetCGID() == ID_CG_CONTEXT_HDL) ||
         (pNdr->GetCGID() == ID_CG_PRIMITIVE_HDL) )
        return FALSE;

    //
    // Offline full pointers.
    //
    if ( GetPtrType() == PTR_FULL )
        return TRUE;

    switch ( GetCGID() )
        {
        case ID_CG_PTR :
        case ID_CG_SIZE_PTR :
            break;

        case ID_CG_STRING_PTR :
        case ID_CG_STRUCT_STRING_PTR :
            return FALSE;

        case ID_CG_SIZE_LENGTH_PTR :
        case ID_CG_LENGTH_PTR :
        case ID_CG_SIZE_STRING_PTR :
        case ID_CG_BC_PTR :
            return TRUE;

        default :
            MIDL_ASSERT(0);
        }

    if ( pNdr->IsSimpleType() )
        return FALSE;

    if ( pNdr->IsStruct() )
        return ((CG_STRUCT *)pNdr)->ShouldFreeOffline();

    return TRUE;
}

void
CG_POINTER::GenFreeInline( CCB * pCCB )
{
    CG_PARAM *  pParam;
    CG_NDR *    pNdr;
    BOOL        fFree;

    if ( ShouldFreeOffline() || IsAllocateDontFree() )
        return;

    //
    // We use the buffer for these since they have to be [in] or [in,out].
    //
    if ( GetCGID() == ID_CG_STRING_PTR )
        return;

    fFree = FALSE;

    pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    pNdr = (CG_NDR *) GetChild();

    //
    // Skip past generic handle nodes.
    //
    if ( pNdr->GetCGID() == ID_CG_GENERIC_HDL )
        pNdr = (CG_NDR *) pNdr->GetChild();

    //
    // Check for handles.
    //
    if ( (pNdr->GetCGID() == ID_CG_CONTEXT_HDL) ||
         (pNdr->GetCGID() == ID_CG_PRIMITIVE_HDL) )
        return;

    //
    // Free a pointer to simple type only if it's a pointer to enum16 or int3264.
    //
    if ( pNdr->IsSimpleType() )
        fFree = ((pNdr->GetCGID() == ID_CG_ENUM) &&  !((CG_ENUM *)pNdr)->IsEnumLong()) 
                ||pNdr->GetCGID() == ID_CG_INT3264;

    //
    // Out only pointer is freed if it wasn't allocated on the server's stack.
    // We overwrite any previous freeing descision.
    //
    if ( ! pParam->IsParamIn() )
        fFree = ShouldPointerFree();

    if ( fFree )
        {
        //
        // Always check if the pointer is not null before freeing.
        //
        Out_FreeParamInline( pCCB );
        }
}

void CG_SIZE_POINTER::GenNdrFormatPointee( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for the pointee of an
    sized pointer to anything.
    Since a sized pointer is really the same as a pointer to a conformant
    array in Ndr terms, we just create a CG_CONFORMANT_ARRAY class on the
    fly and tell it to generate it's code.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    CG_CONFORMANT_ARRAY *   pConformantArray;
    CG_QUALIFIED_POINTER *  pOldSizePtr;

    if ( GetPointeeFormatStringOffset() != -1 )
        return;

#if 0
    //
    // This fixes the case below but causes regressions in ds bvt's.  Pull it
    // for now.
    //

    if ( GetPointee() && GetPointee()->GetFormatStringOffset() != -1 )
    {
        // This happens when the sized pointer is recursively defined.
        // e.g. struct f {long s; [size_is(s)] struct f *p;};

        SetPointeeFormatStringOffset( GetPointee()->GetFormatStringOffset() );
        return;
    }
#endif

    if ( IsMultiSize() )
        {
        CG_NDR * pChild = (CG_NDR *) GetChild();

        SetIsInMultiSized( TRUE );

        if ( (pChild->GetCGID() == ID_CG_SIZE_PTR) ||
             (pChild->GetCGID() == ID_CG_SIZE_LENGTH_PTR) ||
             (pChild->GetCGID() == ID_CG_SIZE_STRING_PTR) )
            {
            ((CG_QUALIFIED_POINTER *)pChild)->SetIsInMultiSized( TRUE );
            ((CG_QUALIFIED_POINTER *)pChild)->SetDimension(GetDimension() + 1);
            }
        }

    pOldSizePtr = pCCB->GetCurrentSizePointer();
    pCCB->SetCurrentSizePointer( this );

    pConformantArray = new CG_CONFORMANT_ARRAY( this );

    SetPointee( pConformantArray );

    pConformantArray->SetPtrType( PTR_REF );

    pConformantArray->SetChild( GetChild() );

    pConformantArray->SetIsInMultiDim( IsInMultiSized() );

    if ( IsInMultiSized() && !pCCB->GetCGNodeContext()->IsProc() )
        {
        pConformantArray->ForceComplex();
        }

    pConformantArray->SetFormatStringOffset( -1 );

    pConformantArray->GenNdrFormat( pCCB );

    SetPointeeFormatStringOffset( pConformantArray->GetFormatStringOffset() );

    pCCB->SetCurrentSizePointer( pOldSizePtr );
}

void CG_SIZE_LENGTH_POINTER::GenNdrFormatPointee( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for the pointee of a
    size-length pointer to anything.
    Since a size-length pointer is really the same as a pointer to a conformant
    varying array in Ndr terms, we just create a CG_CONFORMANT_VARYING_ARRAY
    class on the fly and tell it to generate it's code.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    CG_CONFORMANT_VARYING_ARRAY *   pConfVaryArray;
    CG_QUALIFIED_POINTER *          pOldSizePtr;

    if ( GetPointeeFormatStringOffset() != -1 )
        return;

    if ( IsMultiSize() )
        {
        CG_NDR * pChild = (CG_NDR *) GetChild();

        SetIsInMultiSized( TRUE );

        if ( (pChild->GetCGID() == ID_CG_SIZE_PTR) ||
             (pChild->GetCGID() == ID_CG_SIZE_LENGTH_PTR) ||
             (pChild->GetCGID() == ID_CG_SIZE_STRING_PTR) )
            {
            ((CG_QUALIFIED_POINTER *)pChild)->SetIsInMultiSized( TRUE );
            ((CG_QUALIFIED_POINTER *)pChild)->SetDimension(GetDimension() + 1);
            }
        }

    pOldSizePtr = pCCB->GetCurrentSizePointer();
    pCCB->SetCurrentSizePointer( this );

    pConfVaryArray = new CG_CONFORMANT_VARYING_ARRAY( this );

    SetPointee( pConfVaryArray );

    pConfVaryArray->SetPtrType( PTR_REF );

    pConfVaryArray->SetChild( GetChild() );

    pConfVaryArray->SetIsInMultiDim( IsInMultiSized() );

    if ( IsInMultiSized() && !pCCB->GetCGNodeContext()->IsProc() )
        {
        pConfVaryArray->ForceComplex();
        }

    pConfVaryArray->SetFormatStringOffset( -1 );

    pConfVaryArray->GenNdrFormat( pCCB );

    SetPointeeFormatStringOffset( pConfVaryArray->GetFormatStringOffset() );

    pCCB->SetCurrentSizePointer( pOldSizePtr );
}

// --------------------------------------------------------------------------
// Strings
// --------------------------------------------------------------------------

void
CG_STRING_POINTER::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a string pointer.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING * pFormatString = pCCB->GetFormatString();
    long            StartOffset   = pFormatString->GetCurrentOffset();
    
    if ( GetFormatStringOffset() != -1 )
        return;

    SetFormatStringOffset( StartOffset );
    SetFormatStringEndOffset( StartOffset + 4 );

    if ( GenNdrFormatAlways( pCCB ) == 0 )
        {
        // Don't optimize out if the pointee wasn't generated yet.
        return;
        }

    // here, we assume all pointers generate 4 bytes
    pFormatString->OptimizeFragment( this );
}

long
CG_STRING_POINTER::GenNdrFormatAlways( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a string pointer.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    GenNdrPointerType( pCCB );

    if ( IsStringableStruct() )
        {
        FORMAT_STRING * pFormatString;
        long            Offset;

        pFormatString = pCCB->GetFormatString();

        //
        // For stringable struct's we must emit the offset to the pointee
        // description.  Regular string pointers have the actual description
        // immediately following.
        //

        Offset = pFormatString->GetCurrentOffset();
        pFormatString->PushShortOffset( 0 );

        GenNdrFormatPointee( pCCB );

        pFormatString->PushShortOffset( GetPointeeFormatStringOffset() - Offset,
                                        Offset );

        return GetPointeeFormatStringOffset();
        }

    GenNdrFormatPointee( pCCB );

    pCCB->GetFormatString()->PushFormatChar( FC_PAD );

    return GetPointeeFormatStringOffset();
}

void
CG_STRING_POINTER::GenNdrFormatPointee( CCB * pCCB )
/*++

Routine Description :

    Generate the format string of the actual string type without the
    pointer attributes.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING * pFormatString;

    pFormatString = pCCB->GetFormatString();

    //
    // Check for stringable struct.
    //
    if ( IsStringableStruct() )
        {
        if ( GetPointeeFormatStringOffset() != -1 )
            return;

        SetPointeeFormatStringOffset( pFormatString->GetCurrentOffset() );

        pFormatString->PushFormatChar( FC_C_SSTRING );
        pFormatString->PushByte( ((CG_NDR *)GetChild())->GetWireSize() );

        return;
        }

    //
    // Always generate the format string.  The description of a non-sized
    // string pointer is not shared.
    //

    switch ( ((CG_BASETYPE *)GetChild())->GetFormatChar() )
        {
        case FC_CHAR :
        case FC_BYTE :
            pFormatString->PushFormatChar( FC_C_CSTRING );
            break;
        case FC_WCHAR :
            pFormatString->PushFormatChar( FC_C_WSTRING );
            break;
        default :
            MIDL_ASSERT(0);
        }
}

void
CG_SIZE_STRING_POINTER::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a sized string pointer.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING * pFormatString = pCCB->GetFormatString();
    long            StartOffset   = pFormatString->GetCurrentOffset();
    
    if ( GetFormatStringOffset() != -1 )
        return;

    SetFormatStringOffset( StartOffset );
    SetFormatStringEndOffset( StartOffset + 4 );

    if ( GenNdrFormatAlways( pCCB ) == 0 )
        {
        // Don't optimize out if the pointee wasn't generated yet.
        return;
        }

    // here, we assume all pointers generate 4 bytes
    pFormatString->OptimizeFragment( this );
}

long
CG_SIZE_STRING_POINTER::GenNdrFormatAlways( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a sized string pointer.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING *     pFormatString;
    long                Offset;

    pFormatString = pCCB->GetFormatString();

    GenNdrPointerType( pCCB );

    // Get the current offset.
    Offset = pFormatString->GetCurrentOffset();

    // Push a short for the offset to be filled in later.
    pFormatString->PushShortOffset( 0 );

    // Generate the pointee's format string.
    GenNdrFormatPointee( pCCB );

    // Now fill in the offset field correctly.
    pFormatString->PushShortOffset( GetPointeeFormatStringOffset() - Offset,
                                    Offset );

    return GetPointeeFormatStringOffset();
}

void
CG_SIZE_STRING_POINTER::GenNdrFormatPointee( CCB * pCCB )
/*++

Routine Description :

    Generate the format string of the actual string type without the
    pointer attributes.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING *         pFormatString;
    CG_QUALIFIED_POINTER *  pOldSizePtr;

    if ( GetPointeeFormatStringOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    SetPointeeFormatStringOffset( pFormatString->GetCurrentOffset() );

    pOldSizePtr = pCCB->GetCurrentSizePointer();
    pCCB->SetCurrentSizePointer( this );

    //
    // Check for stringable struct.
    //
    if ( IsStringableStruct() )
        {
        pFormatString->PushFormatChar( FC_C_SSTRING );
        pFormatString->PushByte( ((CG_NDR *)GetChild())->GetWireSize() );
        pFormatString->PushFormatChar( FC_STRING_SIZED );
        pFormatString->PushFormatChar( FC_PAD );

        GenFormatStringConformanceDescription( pCCB, TRUE, IsInMultiSized() );

        pCCB->SetCurrentSizePointer( pOldSizePtr );
        return;
        }

    switch ( ((CG_BASETYPE *)GetChild())->GetFormatChar() )
        {
        case FC_CHAR :
        case FC_BYTE :
            pFormatString->PushFormatChar( FC_C_CSTRING );
            break;
        case FC_WCHAR :
            pFormatString->PushFormatChar( FC_C_WSTRING );
            break;
        default :
            MIDL_ASSERT(0);
        }

    pFormatString->PushFormatChar( FC_STRING_SIZED );

    //
    // Set the IsPointer parameter to TRUE.
    //
    GenFormatStringConformanceDescription( pCCB, TRUE, IsInMultiSized() );

    pCCB->SetCurrentSizePointer( pOldSizePtr );
}

void
CG_BYTE_COUNT_POINTER::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a byte count pointer.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    CG_ITERATOR         Iterator;
    FORMAT_STRING *     pFormatString;
    CG_PROC *           pProc;
    CG_PARAM *          pParam;
    CG_NDR *            pChild;
    unsigned short      uConfFlags = 0;

    if ( GetFormatStringOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    pChild = (CG_NDR *) GetChild();

    if ( ! pChild->IsSimpleType() || pChild->GetRangeAttribute() )
        pChild->GenNdrFormat( pCCB );

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    pFormatString->PushFormatChar( FC_BYTE_COUNT_POINTER );

    if ( pChild->IsSimpleType() && !pChild->GetRangeAttribute() )
        pChild->GenNdrFormat( pCCB );
    else
        pFormatString->PushFormatChar( FC_PAD );

    pProc = (CG_PROC *) pCCB->GetCGNodeContext();

    pProc->GetMembers( Iterator );

    bool      fThisIsFirst = false;

    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        if ( GetByteCountParam() == pParam->GetType() )
            {
            break;
            }
        if ( pParam->GetChild() == this )
            {
            fThisIsFirst = true;
            }
        }

    uConfFlags |= fThisIsFirst ? 0 : FC_EARLY_CORRELATION;

    MIDL_ASSERT( ((CG_NDR *)pParam->GetChild())->IsSimpleType() );

    CG_BASETYPE *   pCount = (CG_BASETYPE *) pParam->GetChild();
    unsigned char   Type;

    Type = (unsigned char) pCount->GetFormatChar();
    Type |= FC_TOP_LEVEL_CONFORMANCE;

    // Byte count description, just do it here.
    pFormatString->PushByte( Type );
    pFormatString->PushByte( 0 );
    pFormatString->PushShortStackOffset(
                        pParam->GetStackOffset( pCCB, I386_STACK_SIZING ) );

    if ( pCommand->IsSwitchDefined( SWITCH_ROBUST ) ) 
        {
        OUT_CORRELATION_DESC( pFormatString, uConfFlags );
        }
    if ( !pChild->IsSimpleType() || pChild->GetRangeAttribute() )
        {
        pFormatString->PushShortOffset( pChild->GetFormatStringOffset() -
                                          pFormatString->GetCurrentOffset() );
        }
}

void
CG_INTERFACE_POINTER::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for an interface pointer.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING *     pFormatString;

    if ( GetFormatStringOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    //
    // There are two cases, the constant UUID and the [iid_is] expression.
    //
    // In the normal case, we will get the 16 byte UUID from the [uuid]
    // attribute on the interface node.  The 16 byte UUID is written to the
    // format string.  Note that the UUID in the format string is not aligned
    // in memory.  The UUID must be copied to a local structure before being
    // used.
    //

    // Get the interface node.
    pFormatString->PushFormatChar( FC_IP );

    //
    // Else handle a constant iid interface pointer.
    //

    MIDL_ASSERT( GetTheInterface()->NodeKind() == NODE_INTERFACE );

    pFormatString->PushFormatChar( FC_CONSTANT_IID );

    GenNdrFormatForGuid( pCCB );

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
    pFormatString->OptimizeFragment( this );

}

void
CG_INTERFACE_POINTER::GenNdrFormatForGuid( CCB * pCCB )
{
    node_interface  *pInterface    = GetTheInterface();
    FORMAT_STRING   *pFormatString = pCCB->GetFormatString();
    node_guid       *pGuid;
    char            *p1, *p2, *p3, *p4, *p5;

    // Get the [uuid] from the interface node.
    pGuid = (node_guid *)pInterface->GetAttribute( ATTR_GUID );

    MIDL_ASSERT( pGuid && "No UUID for interface pointer" );

    pGuid->GetStrs( &p1, &p2, &p3, &p4, &p5 );

    pFormatString->PushLong( StringToHex( p1 ) );
    pFormatString->PushShort( StringToHex( p2 ) );
    pFormatString->PushShort( StringToHex( p3 ) );

    char    Buffer[20];
    char    String[4];
    int     i;

    strcpy( Buffer, p4 );
    strcat( Buffer, p5 );

    for ( i = 0; i < 16; i += 2 )
        {
        String[0] = Buffer[i];
        String[1] = Buffer[i+1];
        String[2] = '\0';

        pFormatString->PushByte( StringToHex( String ) );
        }
}

long
CG_INTERFACE_POINTER::GenNdrFormatAlways( CCB * pCCB )
{
    long    OldOffset;

    OldOffset = GetFormatStringOffset();

    SetFormatStringOffset( -1 );

    GenNdrFormat( pCCB );

    SetFormatStringOffset( OldOffset );

    // The Always methods return the offset to pointee to watch for 0.
    // This does not apply to intf pointer, so just return the current offset.
    //
    return GetFormatStringOffset();
}

void
CG_IIDIS_INTERFACE_POINTER::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for an interface pointer.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING *     pFormatString;

    if ( GetFormatStringOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    //
    // There are two cases, the constant UUID and the [iid_is] expression.
    //
    // In the normal case, we will get the 16 byte UUID from the [uuid]
    // attribute on the interface node.  The 16 byte UUID is written to the
    // format string.  Note that the UUID in the format string is not aligned
    // in memory.  The UUID must be copied to a local structure before being
    // used.
    //

    // Get the interface node.
    pFormatString->PushFormatChar( FC_IP );

    MIDL_ASSERT( GetIIDExpr() );

        //
        // Interface pointer has [iid_is] applied to it.
        //
        pFormatString->PushFormatChar( FC_PAD );
        
        GenNdrFormatAttributeDescription( pCCB,
                                          0,
                                          GetIIDExpr(),
                                          TRUE,
                                          FALSE,
                                          FALSE,
                                          FALSE,
                                          pCommand->IsSwitchDefined( SWITCH_ROBUST ),
                                          FC_IID_CORRELATION
                                          );
        return;

}

long
CG_IIDIS_INTERFACE_POINTER::GenNdrFormatAlways( CCB * pCCB )
{
    long    OldOffset;

    OldOffset = GetFormatStringOffset();

    SetFormatStringOffset( -1 );

    GenNdrFormat( pCCB );

    SetFormatStringOffset( OldOffset );

    // The Always methods return the offset to pointee to watch for 0.
    // This does not apply to intf pointer, so just return the current offset.
    //
    return GetFormatStringOffset();
}

static long
StringToHex( char * str )
{
    long    l;

    l = 0;

    for ( ; *str ; str++ )
        {
        l *= 16;

        if ( ('0' <= *str) && (*str <= '9') )
            {
            l += *str - '0';
            continue;
            }

        if ( ('a' <= *str) && (*str <= 'f') )
            {
            l += 10 + *str - 'a';
            continue;
            }

        if ( ('A' <= *str) && (*str <= 'F') )
            {
            l += 10 + *str - 'A';
            continue;
            }

        MIDL_ASSERT(0);
        }

    return l;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\procgen.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

    procgen.cxx

 Abstract:

    code generation for procedures.


 Notes:


 History:

    Aug-15-1993     VibhasC     Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

/****************************************************************************
 *  externs
 ***************************************************************************/
extern  CMD_ARG             *   pCommand;
void GenCorrInit( CCB* );
void GenCorrPassFree( CCB*, char* );

/****************************************************************************/

CG_STATUS
CG_PROC::GenClientStub(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate client stub.

 Arguments:

    pCCB    - pointer to code generation control block.


 Return Value:

    A status of the code generation.

 Notes:

    Set up local variables, parameters etc.
    Perform buffer size and marshalling analysis.
    Generate the stub.


    The strategy for binding is now different than the old stubs. The actual
    binding is performed AFTER the sizing is performed, right at the first
    get buffer call. This allows us to combine the message init and the call
    to get buffer and binding into one single call to an ndr routine.
    Significant code / time savings.
----------------------------------------------------------------------------*/
{
    ANALYSIS_INFO   Analysis;
    BOOL            fHasExceptionHandler = FALSE;
    ISTREAM *   pStream = pCCB->GetStream();

    // [nocode] procs get no client side stub; although they do get a
    // server side stub
    if ( IsNoCode() )
        return CG_OK;

    // call_as procs need additional prototypes
    if ( pCallAsName )
        pCCB->RegisterCallAsRoutine( (node_proc *)GetType() );

    //
    // Set the CCB code generation side.
    //
    pCCB->SetCodeGenSide( CGSIDE_CLIENT );
    pCCB->SetCodeGenPhase( CGPHASE_MARSHALL );

    //
    // Change to -Os if needed because of number of param and/or stack size.
    //
    (void) MustUseSingleEngineCall( pCCB );
    pCCB->SetOptimOption( GetOptimizationFlags() );

    Analysis.SetCurrentSide( C_SIDE );
    Analysis.SetOptimOption( pCCB->GetOptimOption() );
    Analysis.SetMode( pCCB->GetMode() );
    Analysis.SetRpcSSSwitchSet( (unsigned long)pCCB->IsRpcSSSwitchSet() );

    // Declare pre-allocated resources. All params are registered as resources,
    // The standard local variables : an rpc message and the stub message are
    // also set up local variables.

    C_PreAllocateResources( &Analysis );

    // Set current phase. Perform buffer size, binding and marshalling analysis.
    // The binding analysis usually sets up resources needed for binding.

    Analysis.SetCurrentPhase( ANA_PHASE_CLIENT_MARSHALL );

    C_BindingAnalysis( &Analysis );
    MarshallAnalysis( &Analysis );

    // Perform analysis to check if anything needs to be done for ref
    // pointer checks. This is especially needed for arrays of ref pointers
    // where we need to declare indexes for each array dimension.

    RefCheckAnalysis( &Analysis );

    // Perform the unmarshalling analysis. This allows the cg nodes to set
    // up for unmarshall, figure out local variables needed if any.

    Analysis.SetCurrentPhase( ANA_PHASE_CLIENT_UNMARSHALL );
    UnMarshallAnalysis( &Analysis );

    // Perform the Out Local analysis even on the client side, so the engine
    // format string generation will get information if the pointer is
    // allocated on stack. One the client side  this call will NOT actually
    // allocate a resource.

    S_OutLocalAnalysis( &Analysis );

    // Perform this analysis on the client side so the format string is
    // correct for server. It is needed for -Oi RpcSs flag generation.

    RpcSsPackageAnalysis( &Analysis );

    // Find out which alloc and free routines should be put in the stub
    // descriptor.

    PNAME AllocRoutineName, FreeRoutineName;

    GetCorrectAllocFreeRoutines( pCCB,
                                 FALSE,  //client
                                 & AllocRoutineName,
                                 & FreeRoutineName );


    // Init the code gen. controller block for a new procedure. The resource
    // dictionary data base is handed over to the code generation controller
    // for use.

    pCCB->InitForNewProc(
                         GetProcNum(),
                         (RPC_FLAGS) 0,                 // rpc flags
                         AllocRoutineName,
                         FreeRoutineName,
                         Analysis.GetResDictDatabase()  // resource dict.
                        );

    // If the single engine call is to be used, send message to the ndr
    // code generator.

    if ( MustUseSingleEngineCall( pCCB ) )
        {
        if ( IsObject() )
            {
            //
            // Non-call_as object proxies are now stubless.
            //

            if (((CG_OBJECT_PROC *)this)->IsStublessProxy())
                return CG_OK;

            ((CG_OBJECT_PROC *)this)->Out_ProxyFunctionPrototype(pCCB,0);
            pStream->WriteOnNewLine( "{" );
            pStream->NewLine();
            }
        else
            {
            // Generate the function header.
            Out_ClientProcedureProlog( pCCB, GetType() );

            Out_IndentInc( pCCB );
            pStream->NewLine();
            }

        GenNdrSingleClientCall( pCCB );

        Out_IndentDec( pCCB );
        Out_ProcClosingBrace( pCCB );

        // All done.
        return CG_OK;
        }

    pCCB->SetCGNodeContext( this );

    MIDL_ASSERT( pCommand->IsNDRRun() || pCommand->IsNDR64Run() );

    //
    // Always create the format string for the proc.
    //
    if ( pCommand->IsNDRRun() )
        {
        GenNdrFormat( pCCB );        
        }
    else 
        {
        pCCB->GetNdr64Format()->Generate( this );
        }

    // Generate the prolog, the sizing code. Then once the length has been
    // calculated, go ahead and perform the binding using our ndr routines.
    // The call to the ndr routine returns a buffer pointer ready for
    // marshalling.

    C_GenProlog( pCCB );

    if ( ( fHasExceptionHandler = ( HasStatuses() || IsObject() ) ) == TRUE )
        {
        Out_RpcTryExcept( pCCB );
        }

    if ( HasFullPtr() )
        Out_FullPointerInit( pCCB );

    // Generate the null ref check code.
    // For object interfaces we need to generate a call to initialize proxy
    // first as we won't be able to walk parameters later for cleanup.
    // For raw interfaces we don't ned to move initialization call
    // as we don't have the walk problem.

    if ( IsObject() )
        C_GenBind( pCCB );

    if( pCCB->MustCheckRef() )
        GenRefChecks( pCCB );

    Out_RpcTryFinally( pCCB);

    if ( !IsObject() )
        C_GenBind( pCCB );

    // generate NdrCorrelationInitialize( _StubMsg, _NdrCorrCache, _NdrCorrCacheSize, _NdrCorrFlags );
    // normally, /deny causes a switch to /Oicf. This code will be executed when a 
    // a switch to from /Os to /Oicf is not posible
    if ( fHasDeny )
        {
        GenCorrInit( pCCB );
        }

    // If the rpc ss package is to be enabled, do so.
    // It would need to be enabled explicitely on the client side when
    // in non-osf mode, with the attribute on the operation AND
    //      - the routine is a callback,
    //      - the routine is not a callback and the interface doesn't
    //        have the attribute (if it does, we optimized via stub descr.)

    if( pCCB->GetMode()  &&  MustInvokeRpcSSAllocate()
        &&
        ( GetCGID() == ID_CG_CALLBACK_PROC  ||
          GetCGID() != ID_CG_CALLBACK_PROC  &&
                                    ! pCCB->GetInterfaceCG()->IsAllRpcSS())
        )
        {
        Out_RpcSSSetClientToOsf( pCCB );
        }

    GenSizing( pCCB );

    GenMarshall( pCCB );

    // Generate the send receive.

    C_GenSendReceive( pCCB );

    // Before Win2000 Ndr<whatetver>SendReceive didn't set the BufferStart
    // and BufferEnd fields.  Do it now.

    pStream->WriteOnNewLine( "_StubMsg.BufferStart = (unsigned char *) _RpcMessage.Buffer; ");
    pStream->WriteOnNewLine( "_StubMsg.BufferEnd   = _StubMsg.BufferStart + _RpcMessage.BufferLength;" );
    pStream->NewLine();
    
    pCCB->SetCodeGenPhase( CGPHASE_UNMARSHALL );
    GenUnMarshall( pCCB );

    // generate NdrCorrelationPass( _StubMsg );
    // normally, /deny causes a switch to /Oicf. This code will be executed when a 
    // a switch to from /Os to /Oicf is not posible
    if ( fHasDeny )
        {
        GenCorrPassFree( pCCB, CSTUB_CORR_PASS_RTN_NAME );
        }

    Out_RpcFinally( pCCB );
    if ( fHasDeny )
        {
        GenCorrPassFree( pCCB, CSTUB_CORR_FREE_RTN_NAME );
        }
    if ( HasFullPtr() )
        Out_FullPointerFree( pCCB );
    C_GenFreeBuffer( pCCB );
    C_GenUnBind( pCCB );
    Out_RpcEndFinally( pCCB );

    if( fHasExceptionHandler )
        {

        if(IsObject())
            {
            ISTREAM * pStream = pCCB->GetStream();

            pStream->NewLine();
            pStream->Write('}');
            pStream->IndentDec();
            pStream->NewLine();
            pStream->Write( "RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)" );
            pStream->IndentInc();
            pStream->NewLine();
            pStream->Write( '{' );
            }
        else
            {
            Out_RpcExcept( pCCB, "1" );
            }

        if(ReturnsHRESULT())
            {
            C_GenClearOutParams( pCCB );
            C_GenMapHRESULT( pCCB );
            }
        else if( HasStatuses() )
            {
            C_GenMapCommAndFaultStatus( pCCB );
            }
        else
            {
            Out_RaiseException( pCCB, "RpcExceptionCode()" );
            }

        Out_RpcEndExcept( pCCB );
        }
    // All done, emit the final closed curly and we're done.
    GenEpilog( pCCB );

    return CG_OK;
}

CG_STATUS
CG_PROC::C_GenMapCommAndFaultStatus(
    CCB     *   pCCB )
    {
    CG_NDR  *   pTemp   = 0;
    CG_NDR  *   pComm   = 0;
    CG_NDR  *   pFault  = 0;
    CG_NDR  *   pRT;
    int         i = 0;
    expr_node   *   pCommExpr;
    expr_node   *   pFaultExpr;
    BOOL        fReturnHasStatus = FALSE;

    ITERATOR    I;

    GetMembers( I );

    if ( (pRT = GetReturnType()) != 0 && (fReturnHasStatus = pRT->HasStatuses() ) == TRUE )
        ITERATOR_INSERT( I, pRT );

    while( ITERATOR_GETNEXT(I, pTemp ) && (i < 2) )
        {
        if( pTemp->HasStatuses() )
            {
            if( pTemp->GetStatuses() == STATUS_COMM )
                pComm = pTemp;
            if( pTemp->GetStatuses() == STATUS_FAULT )
                pFault = pTemp;
            if( pTemp->GetStatuses() == STATUS_BOTH )
                {
                pComm = pFault = pTemp;
                break;
                }
            }
        }

    if( pComm )
        {
        if( pComm == pRT )
            pCommExpr = MakeAddressExpressionNoMatterWhat( pRT->GetResource() );
        else
            pCommExpr = pComm->GetResource();
        }
    else
        pCommExpr = new expr_constant(0L);

    if( pFault )
        {
        if( pFault == pRT )
            pFaultExpr = MakeAddressExpressionNoMatterWhat(pRT->GetResource());
        else
            pFaultExpr = pFault->GetResource();
        }
    else
        pFaultExpr = new expr_constant(0L);

    Out_CallNdrMapCommAndFaultStatus( pCCB,
                                      MakeAddressExpressionNoMatterWhat(
                                             pCCB->GetStandardResource(
                                                 ST_RES_STUB_MESSAGE_VARIABLE)),
                                      GetStatusResource(),
                                      pCommExpr,
                                      pFaultExpr );
    return CG_OK;
    }

CG_STATUS
CG_PROC::C_GenClearOutParams(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code to clear out params in the case of exceptions.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    CG_OK
    
 Notes:

    Generate a call to a varargs function which will take a stub message, a
    format string offset and a list of all output parameters.
----------------------------------------------------------------------------*/
{
    ITERATOR    I;
    expr_proc_call *   pProc;
    expr_node       *   pExpr;
    short               Count;
    CG_PARAM        *   pParam;
    ISTREAM         *   pStream = pCCB->GetStream();

    // The first parameter is the stub message.

    Count =  GetOutParamList( I );

    // For each of the output parameters, call the ndr clear out parameters
    // procedure.

    ITERATOR_INIT( I );

    while( ITERATOR_GETNEXT( I, pParam ) )
        {
        pParam->GenNdrTopLevelAttributeSupport( pCCB, TRUE );

        // Create a call to the procedure.

        pProc   = new expr_proc_call( C_NDR_CLEAR_OUT_PARAMS_RTN_NAME );

        // First param is the address of the stub message.

        pExpr   = pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
        pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr   = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME,
                                                  pExpr );
        pProc->SetParam( pExpr );


        // Second param is the  format string offset of the first out parameter.
        // Emitted as &__MIDL_FormatString[ ?? ]


        pExpr   = Make_1_ArrayExpressionFromVarName(
                                 FORMAT_STRING_STRING_FIELD,
                                 ((CG_NDR *)(pParam->GetChild()))->GetFormatStringOffset() );
        pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr   = MakeExpressionOfCastToTypeName(
                                             PFORMAT_STRING_TYPE_NAME,
                                             pExpr);

        pProc->SetParam( pExpr );

        // The last param is the [out] parameter itself.

        pProc->SetParam( MakeCastExprPtrToVoid(pParam->GetResource()) );

        pStream->NewLine();
        pProc->PrintCall( pStream, 0, 0 );
        }

    return CG_OK;

}

CG_STATUS
CG_PROC::C_GenMapHRESULT(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generates code to map exceptions into HRESULT return values.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("_RetVal = NdrProxyErrorHandler(RpcExceptionCode());");
    return CG_OK;
}


CG_STATUS
CG_PROC::C_GenProlog(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the procedure prolog for the stub procedure.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise

 Notes:

    Increment the stream indentation at the end of the prolog.
    Although we register params as param resources, we dont generate the
    procedure signature using the PrintType/Decl facility.
----------------------------------------------------------------------------*/
{

    ITERATOR        I;
    ITERATOR        T;

    // Output the bare procedure declaration

    Out_ClientProcedureProlog( pCCB, GetType() );

    // Generate declarations for pre-allocated and analyser-determined locals.

    pCCB->GetListOfLocalResources( I );
    Out_ClientLocalVariables( pCCB, I );

    pCCB->GetListOfTransientResources( T );
    Out_ClientLocalVariables( pCCB, T );

    // Increment the indentation of the output stream. Reset at epilog time.

    Out_IndentInc( pCCB );

    //
    // This is where we output additional variable declarations to handle
    // multidimensional conformant/varying arrays.
    //

    CG_ITERATOR Iterator;
    ISTREAM *   pStream;
    CG_PARAM *  pParam;
    CG_NDR *    pNdr;

    pStream = pCCB->GetStream();

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        pNdr = (CG_NDR *) pParam->GetChild();

        if ( (pNdr->IsArray() && ((CG_ARRAY *)pNdr)->IsMultiConfOrVar()) ||
             (pNdr->IsPointer() && ((CG_POINTER *)pNdr)->IsMultiSize()) )
            Out_MultiDimVars( pCCB, pParam );
        }
    Iterator.Init();
    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        pNdr = (CG_NDR *) pParam->GetChild();

        if ( (pNdr->IsArray() && ((CG_ARRAY *)pNdr)->IsMultiConfOrVar()) ||
             (pNdr->IsPointer() && ((CG_POINTER *)pNdr)->IsMultiSize()) )
            Out_MultiDimVarsInit( pCCB, pParam );
        }

    return CG_OK;
}

CG_STATUS
CG_PROC::C_GenBind(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code to bind to server.

 Arguments:

    pCCB    - A pointer to the code generation controller block.
    pAna    - A pointer to the analysis information.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

    The binding process is a part of the stub message initialization. The
    stub initializing routine takes the actual binding as a parameter. The
    binding therefore is done as part of the call to this init routine. This
    routine also calls rpc get buffer. This is a change from the erstwhile
    stub generation when binding was done first before the size pass. With
    this call which takes the length as a parameter which means that now we
    will do the sizing pass before the binding pass.

    In case of auto handles, the call is a slightly different one.

    Also, we need to assign to the local buffer pointer variable only if there
    is at least one param that is shipped.

----------------------------------------------------------------------------*/
{
    ITERATOR            BindingParamList;
    expr_node       *   pExpr;
    expr_node       *   pExprStubMsg;
    BOOL                fCallBack = (GetCGID() == ID_CG_CALLBACK_PROC);

    //
    // collect standard arguments to the init procedure.
    //

    // The rpc message variable.

    pExpr   = pCCB->GetStandardResource( ST_RES_RPC_MESSAGE_VARIABLE );
    pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
    pExpr   = MakeExpressionOfCastToTypeName( PRPC_MESSAGE_TYPE_NAME, pExpr );

    ITERATOR_INSERT(
                    BindingParamList,
                    pExpr
                   );

    // The stub message variable.

    pExpr   = pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE);
    pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
    pExpr   = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME, pExpr );
    pExprStubMsg = pExpr;
    ITERATOR_INSERT(
                    BindingParamList,
                    pExpr
                   );

    // The stub descriptor structure variable. This is not allocated as
    // a resource explicitly.

    pExpr   = new RESOURCE( pCCB->GetInterfaceCG()->GetStubDescName(),
                            (node_skl *)0 );

    pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
    pExpr   = MakeExpressionOfCastToTypeName( PSTUB_DESC_STRUCT_TYPE_NAME,
                                              pExpr );

    ITERATOR_INSERT( BindingParamList, pExpr );

    //
    // Proc num.
    //
    ITERATOR_INSERT( BindingParamList,
                     new expr_constant( (long) GetProcNum() ) );

    // This call doesn't do much nowadays except for generating
    // the initialize call and rpc flags assignment and so could
    // be eliminated.

    Out_HandleInitialize( pCCB,
                          BindingParamList,
                          0,
                          IsAutoHandle(),
                          (unsigned short) GetOperationBits()
                        );

    // Generate an explicit binding call depending upon the handle or callback.
    if( fCallBack )
        {
        pExpr   = new expr_proc_call( CALLBACK_HANDLE_RTN_NAME );
        pExpr   = new expr_assign( GetBindingResource(), pExpr );
        }
    else
        {
        pExpr   = GenBindOrUnBindExpression( pCCB,
                                             TRUE   // call to bind.
                                           );
        }

    // Emit the handle init expression.

    if( IsContextHandle() )
        {

        // Special for context handles:
        // The bind expression will contain only the context handle expression,
        // and not the assignment to the binding handle variable. This is to
        // be done right here. This is because some special code has to be
        // generated for context handles for error checking.

        // if the context handle param is [in] generate code of the form:
        //  if( Context_Handle != 0 )
        //      {
        //      _Handle = NdrContextBinding( Context_Handle );
        //      }
        //  else
        //      {
        //      RpcRaiseException( RPC_X_SS_IN_NULL_CONTEXT );
        //      }
        //
        // if the context handle is [in, out] then generate code of the form:
        //  if( Context_Handle != 0 )
        //      {
        //      Handle = NdrContextBinding( Context_Handle );
        //      }
        //  else
        //      {
        //      _Handle = 0;
        //      }

        // Note: The case of [out] context handle will never come here since
        // this context handle is not a binding handle, and hence will be
        // handled elsewhere.
        //

        ITERATOR    I;
        BOOL        fIn     = (SearchForBindingParam())->IsParamIn();
        BOOL        fInOut  = ((SearchForBindingParam())->IsParamOut()
                                &&
                                fIn );

        // For now assume we always have error checking on. When we get -error
        // none implemented on procs, we can set it based on that.

        BOOL        fErrorCheckReqd = pCCB->MustCheckRef();
        expr_node   *   pAss;
        expr_node   *   pContextParam   =  ((CG_NDR *)SearchForBindingParam())->
                                                GenBindOrUnBindExpression(
                                                                pCCB, TRUE );


        pExpr   =  pContextParam;
        pExpr   = MakeExpressionOfCastToTypeName( CTXT_HDL_C_CONTEXT_TYPE_NAME,
                                                pExpr
                                              );

        ITERATOR_INSERT( I, pExpr );

        pExpr   = MakeProcCallOutOfParamExprList( CTXT_HDL_BIND_RTN_NAME,
                                                  (node_skl *)0,
                                                  I
                                                );
        pAss= new expr_assign(GetBindingResource(), pExpr);

        if( !fErrorCheckReqd )
            {
            pCCB->GetStream()->NewLine();
            pAss->PrintCall( pCCB->GetStream(), 0, 0 );
            pCCB->GetStream()->Write(';');
            pCCB->GetStream()->NewLine();
            }
        else
            {
            Out_If( pCCB, new expr_relational(OP_NOT_EQUAL,
                                               pContextParam,
                                               new expr_constant(0L) ) );
            pCCB->GetStream()->NewLine();
            pAss->PrintCall( pCCB->GetStream(), 0, 0 );
            pCCB->GetStream()->Write(';');
            pCCB->GetStream()->NewLine();
            Out_Endif( pCCB );

            if( !fInOut )
                {
                Out_Else( pCCB );
                Out_RaiseException( pCCB, "RPC_X_SS_IN_NULL_CONTEXT" );
                Out_Endif( pCCB );
                }
            }
        }
    else if( pExpr )
        {
        pCCB->GetStream()->NewLine();
        pExpr->PrintCall( pCCB->GetStream(), 0, 0 );
        pCCB->GetStream()->Write(';');
        pCCB->GetStream()->NewLine();

        if ( IsGenericHandle() )
            {
            // For generic handles generate a check that the handle
            // is not null after calling user's bind routine.

            Out_If( pCCB, new expr_relational( OP_EQUAL,
                                               GetBindingResource(),
                                               new expr_constant(0L) ) );
            Out_RaiseException( pCCB, "RPC_S_INVALID_BINDING" );
            Out_Endif( pCCB );
            }
        }


    return CG_OK;
}

CG_STATUS
CG_PROC::C_GenSendReceive(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code to call the rpc runtime sendreceive.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

     We will always call an ndr routine for the sendreceive call. This
     is so that we can unify the buffer length updating in that one call.
     The only difference is for Auto handles when we will have to call this
     with an additional parameter.
----------------------------------------------------------------------------*/
{
    PNAME               pProcName;
    expr_proc_call  *   pProc;
    expr_node       *   pExpr;
    expr_node       *   pStubMsgExpr    = pCCB->GetStandardResource(
                                            ST_RES_STUB_MESSAGE_VARIABLE );
    ITERATOR            ParamsList;

    //
    // Check if we're targeting the ndr engine.
    //
    if ( pCCB->GetOptimOption() & OPTIMIZE_SIZE )
        {
        if ( IsAutoHandle() )
            Out_NdrNsSendReceive( pCCB );
        else
            Out_NdrSendReceive( pCCB );

        return CG_OK;
        }

    // update the param list with a pointer to the stub message.

    pStubMsgExpr    = MakeAddressExpressionNoMatterWhat( pStubMsgExpr );

    ITERATOR_INSERT( ParamsList, pStubMsgExpr );

    // In case of auto handles, an additional param is reqd, viz the
    // address of the auto handle variable.

    if( IsAutoHandle() )
        {
        pExpr   = pCCB->GetStandardResource( ST_RES_AUTO_BH_VARIABLE );
        pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
        ITERATOR_INSERT( ParamsList, pExpr );
        pProcName   = AUTO_SR_NDR_RTN_NAME;
        }
    else
        {
        pProcName   = NORMAL_SR_NDR_RTN_NAME;
        }

    ITERATOR_INSERT( ParamsList,
                     new expr_variable(  STUB_MSG_BUFFER_VAR_NAME ) );

    // generate the procedure call expression.

    pProc = MakeProcCallOutOfParamExprList( pProcName,
                                            (node_skl *)0,
                                            ParamsList
                                          );

    pCCB->GetStream()->NewLine();
    pProc->PrintCall( pCCB->GetStream(), 0, 0 );

    return CG_OK;
}

CG_STATUS
CG_PROC::C_GenUnBind(
    CCB         *   pCCB)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code to unbind from server.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

    Dont make unbind calls if not a generic handle.
----------------------------------------------------------------------------*/
{

    if( IsGenericHandle() )
        {
        ISTREAM         *   pStream = pCCB->GetStream();

        expr_proc_call  *   pUnBindCall =
                    (expr_proc_call *)GenBindOrUnBindExpression( pCCB, FALSE );

        pStream->NewLine();
        Out_If( pCCB, GetBindingResource() );
        pStream->NewLine();

        pUnBindCall->PrintCall( pStream, 0, 0 );

        Out_Endif( pCCB );
        }
    return CG_OK;
}

CG_STATUS
CG_PROC::C_GenFreeBuffer(
    CCB             *   pCCB)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code to call runtime to free the rpc buffer.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

    The analyser will supply the binding information.

----------------------------------------------------------------------------*/
{
    if ( pCCB->GetOptimOption() & OPTIMIZE_SIZE )
        {
        Out_NdrFreeBuffer( pCCB );
        return CG_OK;
        }

    Out_NormalFreeBuffer( pCCB );
    return CG_OK;
}

CG_STATUS
CG_PROC::GenServerStub(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side unmarshalling stub.

 Arguments:

    pCCB    - A pointer to the code generation block.

 Return Value:

    CG_OK   if all is well
    error   otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    ANALYSIS_INFO           Analysis;
    DISPATCH_TABLE_FLAGS    Dtf;
    BOOL                    fEmitCheckStubData;

    // call_as procs need additional prototypes
    if ( pCallAsName )
        pCCB->RegisterCallAsRoutine( (node_proc *)GetType() );

    BOOL fPicklingProcOrType =  GetCGID() == ID_CG_ENCODE_PROC ||
                                GetCGID() == ID_CG_TYPE_ENCODE_PROC;

    //
    // Set the CCB code generation side.
    //
    pCCB->SetCodeGenSide( CGSIDE_SERVER );
    pCCB->SetCodeGenPhase( CGPHASE_UNMARSHALL );
    pCCB->SetOptimOption( GetOptimizationFlags() );


    Analysis.SetCurrentSide( S_SIDE );
    Analysis.SetOptimOption( pCCB->GetOptimOption() );

    // Set the analysis phase to the correct one.

    Analysis.SetCurrentPhase( ANA_PHASE_SERVER_UNMARSHALL );

    //
    // Change to -Os if needed because of number of param and/or stack size.
    //
    (void) MustUseSingleEngineCall( pCCB );
    Analysis.SetOptimOption( pCCB->GetOptimOption() );

    Analysis.SetMode( pCCB->GetMode() );
    Analysis.SetRpcSSSwitchSet( (unsigned long)pCCB->IsRpcSSSwitchSet() );


    // Preallocate param and local resources if needed. We do need at least
    // one param resource - the rpc message pointer.

    S_PreAllocateResources( &Analysis );

    // The unmarshall analysis figures out the local variables needed,
    // and their allocation type. This helps the code generator select the
    // most optimal instruction. This is performed only for [in] and [in,out]
    // params.

    UnMarshallAnalysis( &Analysis );


    // Perform the initialization analysis for the server side locals if
    // allocated for the [out] ONLY parameters.

    S_OutLocalAnalysis( &Analysis );

    // Perform this analysis so the format string is correct for server.
    // It is needed for -Oi RpcSs flag generation.

    RpcSsPackageAnalysis( &Analysis );

    // Perform InLocalAnalysis to allocate any in params( for now arrays of
    // ref pointers only) on the server side stub stack.

    InLocalAnalysis( &Analysis );

    // Perform the size analysis for the marshalling part of the stub.

    Analysis.SetCurrentPhase( ANA_PHASE_SERVER_MARSHALL );

    MarshallAnalysis( &Analysis );


    // Generate the unmarshalling code. Register this procedure with the
    // dispatch table. Copy the resource dictionary from the analysis phase
    // to be used during the code gen phase.

    char * AllocRoutineName, * FreeRoutineName;

    GetCorrectAllocFreeRoutines( pCCB,
                                 TRUE, //client
                                 &AllocRoutineName,
                                 &FreeRoutineName );


    pCCB->InitForNewProc(
                GetProcNum(),                   // procedure number
                (RPC_FLAGS)0,                   // flags, datagram etc
                (PNAME) AllocRoutineName,
                (PNAME) FreeRoutineName,
                Analysis.GetResDictDatabase()   // copy the resource database
                );

    if( HasNotify() || HasNotifyFlag() )
        GetNotifyTableOffset( pCCB );

    // Register the procedure for the dispatch table.
    // If this proc is interpreted, then the dispatch table has an
    // entry which specifies the NdrServerCall rather than the proc name itself.

    if( GetOptimizationFlags() & OPTIMIZE_INTERPRETER )
        {
        Dtf = DTF_INTERPRETER;
        }
    else
        {
        Dtf = DTF_NONE;
        }

    if ( GetCGID() == ID_CG_ENCODE_PROC )
        Dtf = (DISPATCH_TABLE_FLAGS) (Dtf | DTF_PICKLING_PROC);

    if ( GetCGID() != ID_CG_TYPE_ENCODE_PROC )
        pCCB->GetInterfaceCG()->RegisterProcedure( GetType(), Dtf );

    if ( ! fPicklingProcOrType )
        {
        if ( MustUseSingleEngineCall( pCCB ) )
            {
            if ( UseOldInterpreterMode( pCCB ) )
                {
                GenNdrOldInterpretedServerStub( pCCB );
                }

            if ( NeedsServerThunk( pCCB, CGSIDE_SERVER ) )
                {
                GenNdrThunkInterpretedServerStub( pCCB );
                }

            //
            // This will only do something for a [callback] proc when we're
            // called while generating the client side.
            //       
            MIDL_ASSERT( pCommand->IsNDRRun() || pCommand->IsNDR64Run() );

            if ( pCommand->IsNDRRun() )
               {
               GenNdrFormat( pCCB );        
               }
            else 
               {
               pCCB->GetNdr64Format()->Generate( this );
               }

            return CG_OK;
            }
        }

    pCCB->SetCGNodeContext( this );

    //
    // Always create the format string for the proc.
    //

    if ( pCommand->IsNDRRun() )
        {
        GenNdrFormat( pCCB );        
        }
    else 
        {
        pCCB->GetNdr64Format()->Generate( this );
        }

    // Dont generate the stub itself for pickling.

    if ( fPicklingProcOrType )
        return( CG_OK );

    // Generate the server side procedure prolog. This generates only the
    // server side proc signature, the locals needed and the stub descriptor
    // structure.

    // This also generates the call to server initialize routine.
    // Note, that it is out of RpcTryFinally, but this is ok as
    // we shouldn't attempt to free parameters (they haven't been
    // unmarshaled yet.

    S_GenProlog( pCCB );
    S_GenInitTopLevelStuff( pCCB );

    S_GenInitInLocals( pCCB );

    // Initialize the local variables allocated on the server side if necessary.
    // Also make the initialization call for the server side stub message which
    // updates the buffer pointer.

    // Generate the unmarshalling code.
    Out_RpcTryFinally( pCCB );

    // If the user specifies the -error stub_data to check server unmarshall
    // errors, we need to enclose the unmarshall in a try except, and in the
    // except clause, raise a bad stub data exception.

    fEmitCheckStubData  = pCCB->IsMustCheckStubDataSpecified() && !IsObject();

    if( fEmitCheckStubData )
        {
        Out_RpcTryExcept( pCCB );
        }

    if ( HasFullPtr() )
        Out_FullPointerInit( pCCB );

    // generate NdrCorrelationInitialize( _StubMsg, _NdrCorrCache, _NdrCorrCacheSize, _NdrCorrFlags );
    // normally, /deny causes a switch to /Oicf. This code will be executed when a 
    // a switch to from /Os to /Oicf is not posible
    if ( fHasDeny )
        {
        GenCorrInit( pCCB );
        }

    GenUnMarshall( pCCB );

    // generate NdrCorrelationUninitialize( _StubMsg );
    // normally, /deny causes a switch to /Oicf. This code will be executed when a 
    // a switch to from /Os to /Oicf is not posible
    if ( fHasDeny )
        {
        GenCorrPassFree( pCCB, CSTUB_CORR_PASS_RTN_NAME );
        }

    // If the check for bad stub data must be made, then generate a
    // Rpcexcept() to catch some exceptions here, and re-raise a bad
    // stub data exception for them.
    // Other exceptions would propagate unchanged.

    if( fEmitCheckStubData )
        {
        Out_CheckUnMarshallPastBufferEnd( pCCB );
        Out_RpcExcept( pCCB, "RPC_BAD_STUB_DATA_EXCEPTION_FILTER" );
        Out_RaiseException( pCCB, "RPC_X_BAD_STUB_DATA" );
        Out_RpcEndExcept( pCCB );
        }

    S_GenInitOutLocals( pCCB );

    // Generate the call to the actual manager procedure.

    S_GenCallManager( pCCB );

    S_GenInitMarshall( pCCB );

    pCCB->SetCodeGenPhase( CGPHASE_MARSHALL );

    GenSizing( pCCB );

    // Generate the server side marshall initialization.

    // Marshall the outs and return value.

    GenMarshall( pCCB );

    Out_RpcFinally( pCCB );
    if ( fHasDeny )
        {
        GenCorrPassFree( pCCB, CSTUB_CORR_FREE_RTN_NAME );
        }

    // When notify is used, guard also against an exception in freeing.
    if( HasNotify() || HasNotifyFlag() )
        {
        Out_RpcTryFinally( pCCB );
        }

    // Free anything that needs freeing.

    GenFree( pCCB );

    if( MustInvokeRpcSSAllocate())
        {
        Out_RpcSSDisableAllocate( pCCB );
        }

    if ( HasFullPtr() )
        Out_FullPointerFree( pCCB );

    // If this is a notify procedure, generate the call to the notify procedure.

    if( HasNotify() || HasNotifyFlag() )
        {
        Out_RpcFinally( pCCB );
        GenNotify( pCCB , HasNotifyFlag() );
        Out_RpcEndFinally( pCCB );
        }

    Out_RpcEndFinally( pCCB );

    // For now, just return.

    GenEpilog( pCCB );

    return CG_OK;
}

CG_STATUS
CG_PROC::S_GenInitMarshall(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side marshall init.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well,
    error   otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR Iterator;
    ISTREAM *   pStream;
    CG_PARAM *  pParam;
    CG_NDR *    pNdr;

    //
    // We have to fill in the arrays that we use for handling multidimensional
    // arrays.
    //

    pStream = pCCB->GetStream();

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        pNdr = (CG_NDR *) pParam->GetChild();

        if ( (pNdr->IsArray() && ((CG_ARRAY *)pNdr)->IsMultiConfOrVar()) ||
             (pNdr->IsPointer() && ((CG_POINTER *)pNdr)->IsMultiSize()) )
            Out_MultiDimVarsInit( pCCB, pParam );
        }

    return CG_OK;
}

CG_STATUS
CG_PROC::S_GenInitOutLocals(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the initialization of the local variables.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well,
    error   otherwise.

 Notes:

    This method performs initalization of local variables on the server side.
    Local variables may be declared in the server stub for [out] params, and
    for in parameters which cannot reuse the buffer.

    This method will also perform the stub descriptor structure initialization.
    This method will also perform the server side stub message init.
----------------------------------------------------------------------------*/
{
    CG_ITERATOR     Iter;
    CG_PARAM    *   pParam;

    if( GetMembers( Iter ) )
        {
        while( ITERATOR_GETNEXT( Iter, pParam ) )
            {
            pParam->S_GenInitOutLocals( pCCB );
            }
        }

    //
    // We have to catch initialization of returns of pointers to context
    // handles here.
    //
    if ( GetReturnType() )
        {
        GetReturnType()->S_GenInitOutLocals( pCCB );
        }

    return CG_OK;
}

CG_STATUS
CG_PROC::S_GenCallManager(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a call to the manager routine.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   otherwise.

 Notes:

    Make a procedure node with all the parameters that need to be passed to
    the manager code. The actual expression that needs to be passed to the
    actual manager code is set up during earlier passes. This is called the
    result expression.

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         I;
    PNAME               pName;
    expr_proc_call  *   pProc;
    CG_PARAM        *   pParam;
    expr_node       *   pExpr;
    expr_node       *   pReturnExpr = 0;
    CG_RETURN       *   pRT;
    char            *   pSStubPrefix    = NULL;

    pSStubPrefix = pCommand->GetUserPrefix( PREFIX_SERVER_MGR );

    if ( GetCallAsName() )
        pName   = (PNAME ) GenMangledCallAsName( pCCB );
    else if ( pSStubPrefix )
        {
        pName   = new char[ strlen(pSStubPrefix) + strlen(GetType()->GetSymName()) + 1];
        strcpy( pName, pSStubPrefix );
        strcat( pName, GetType()->GetSymName() );
        }
    else
        pName   = (PNAME ) GetType()->GetSymName();

    pProc   = new expr_proc_call( pName );

    GetMembers( I );

    while( ITERATOR_GETNEXT( I, pParam ) )
        {
        if ( pParam->IsOmittedParam() )
            continue;

        if ( ( pExpr = pParam->GetFinalExpression() ) != 0 )
            {
            CG_NDR * pChild = (CG_NDR *)pParam->GetChild();

            //
            // We have to dereference arrays because of how they are defined
            // in the stub.
            //
            if ( pChild->IsArray() )
                {
                pExpr = new expr_u_deref( pExpr );
                }
            else if( (pChild->GetCGID() == ID_CG_GENERIC_HDL ) &&
                     (((CG_NDR *)pChild->GetChild())->IsArray() )
                   )
                {
                pExpr = new expr_u_deref( pExpr );
                }

            //
            // Context handle param is handled differently.
            //
            if ( (pChild->GetCGID() == ID_CG_CONTEXT_HDL) ||
                 ((pChild->GetCGID() == ID_CG_PTR) &&
                  (((CG_NDR *)pChild->GetChild())->GetCGID() ==
                     ID_CG_CONTEXT_HDL)) )
                {
                expr_proc_call *    pCall;

                pCall = new expr_proc_call( "NDRSContextValue" );
                pCall->SetParam(
                    new expr_param(
                    new expr_variable(
                            pParam->GetResource()->GetResourceName() )) );

                expr_node * pFinal;

                if ( pChild->GetCGID() == ID_CG_CONTEXT_HDL )
                    pFinal = new expr_u_deref(pCall);
                else
                    pFinal = pCall;

                //
                // Dereference a plain context handle.
                //
                pExpr = new expr_cast( pParam->GetType()->GetChild(),
                                        pFinal );
                }

            pProc->SetParam( new expr_param( pExpr ) );
            }
        }

    if ( ( pRT = GetReturnType() ) != 0 )
        {
        pReturnExpr = pRT->GetFinalExpression();
        }

    if ( HasNotifyFlag() )
        {
        // Assign TRUE to the notify flag variable.

        expr_node * pNotifyFlag;
        expr_node * pAssignExpr;

        ISTREAM *   pStream = pCCB->GetStream();

        pNotifyFlag = new expr_variable( NOTIFY_FLAG_VAR_NAME );
        pAssignExpr = new expr_assign( pNotifyFlag,
                                       new expr_variable( "TRUE" ) );
        pStream->NewLine();
        pAssignExpr->Print( pStream );
        pStream->Write( ';' );
        pStream->NewLine();
        }

    Out_CallManager( pCCB,
                     pProc,
                     pReturnExpr,
                     (GetCGID() == ID_CG_CALLBACK_PROC)
                   );

    return CG_OK;

}
CG_STATUS
CG_PROC::S_GenInitTopLevelStuff(
    CCB *   pCCB )
    {
    CG_ITERATOR Iter;
    CG_NDR  *   pParam;

    if( GetMembers( Iter ) )
        {
        while( ITERATOR_GETNEXT( Iter, pParam ) )
            {
            pParam->S_GenInitTopLevelStuff( pCCB );
            }
        }

    if ( GetReturnType() )
        GetReturnType()->S_GenInitTopLevelStuff( pCCB );

    return CG_OK;
    }

CG_STATUS
CG_PROC::S_GenProlog(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side stub prolog.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

    Print out the signature, locals, the stub descriptor if needed and the
    adjust indent in anticipation of code.
----------------------------------------------------------------------------*/
{

    ITERATOR    LocalsList;
    ITERATOR    ParamsList;
    ITERATOR    TransientList;

    // Collect all the params and locals into lists ready to print.

    pCCB->GetListOfLocalResources( LocalsList );
    pCCB->GetListOfParamResources( ParamsList );
    pCCB->GetListOfTransientResources( TransientList );

    //
    // Print out the procedure signature and the local variables.
    //
    Out_ServerProcedureProlog( pCCB,
                               GetType(),
                               LocalsList,
                               ParamsList,
                               TransientList
                             );

    //
    // Done for interpretation op.  No indent needed either.
    //
    if ( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER )
        return CG_OK;

    //
    // This is where we output additional variable declarations to handle
    // multidimensional conformant/varying arrays.
    //

    CG_ITERATOR Iterator;
    ISTREAM *   pStream;
    CG_PARAM *  pParam;
    CG_NDR *    pNdr;

    pStream = pCCB->GetStream();

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        pNdr = (CG_NDR *) pParam->GetChild();

        if ( (pNdr->IsArray() && ((CG_ARRAY *)pNdr)->IsMultiConfOrVar()) ||
             (pNdr->IsPointer() && ((CG_POINTER *)pNdr)->IsMultiSize()) )
            Out_MultiDimVars( pCCB, pParam );
        }

    pStream->NewLine();

    // Removes warning if we don't use the _Status variable.
    pStream->Write( "((void)(" RPC_STATUS_VAR_NAME "));" );
    pStream->NewLine();

    if ( HasNotifyFlag() )
        {
        // Assign FALSE to the notify flag variable.

        expr_node * pNotifyFlag;
        expr_node * pAssignExpr;

        pNotifyFlag = new expr_variable( NOTIFY_FLAG_VAR_NAME );
        pAssignExpr = new expr_assign( pNotifyFlag,
                                       new expr_variable( "FALSE" ) );
        pStream->NewLine();
        pAssignExpr->Print( pStream );
        pStream->Write( ';' );
        pStream->NewLine();
        }

    //
    // Call the NdrServerInitialize routine.
    //

    expr_proc_call  *   pCall;

    pCall = new expr_proc_call( SSTUB_INIT_RTN_NAME );

    pCall->SetParam( new expr_param (
                     new expr_variable( PRPC_MESSAGE_VAR_NAME ) ) );

    pCall->SetParam( new expr_param (
                     new expr_u_address (
                     new expr_variable( STUB_MESSAGE_VAR_NAME ) ) ) );

    pCall->SetParam( new expr_param (
                     new expr_u_address (
                     new expr_variable(
                          pCCB->GetInterfaceCG()->GetStubDescName() ) ) ) );

    pCall->PrintCall( pCCB->GetStream(), 0, 0 );
    pStream->NewLine();

    // if the rpc ss package is to be enabled, do so.

    if( MustInvokeRpcSSAllocate() )
        {
        Out_RpcSSEnableAllocate( pCCB );
        }

    return CG_OK;
}

CG_STATUS
CG_PROC::GenUnMarshall(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the unmarshalling code for the server side stub.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well,
    error   Otherwise.

 Notes:


    The new server stubs will contain an ndr transformation phase which will
    convert, in-situ, any incoming buffer that needs ndr transformations like
    big-little endian conversions, char / float transformations etc.

    Therefore the first thing the server stub does is to tranform the data into
    the correct format and then the rest of the stub can proceed as if the
    data came in little endian format.

    Currently we will use the engine to tranform the data.
----------------------------------------------------------------------------*/
{
    CG_ITERATOR         Iterator;
    ITERATOR            ParamList;
    CG_RETURN       *   pRT;
    CGSIDE              Side;
    BOOL                fReturnNeedsUnMarshall  = FALSE;
    long                ParamTotal;

    GetMembers( Iterator );

    ParamTotal = ITERATOR_GETCOUNT( Iterator );

    if ( GetReturnType() )
        ParamTotal++;

    pCCB->SetCodeGenPhase( CGPHASE_UNMARSHALL );

    // Generate a call to tranform the data into the proper endianness.

    S_XFormToProperFormat( pCCB );

    // For all [in] params, generate the unmarshalling code.

    if( (Side = pCCB->GetCodeGenSide()) == CGSIDE_CLIENT )
        GetOutParamList( ParamList );
    else
        GetInParamList( ParamList );

    if ( (Side == CGSIDE_CLIENT) && (pRT = GetReturnType()) != 0 )
        fReturnNeedsUnMarshall = TRUE;

    //
    // Output the call to check for and perform endian or other transformations
    // if needed.
    //
    if ( fReturnNeedsUnMarshall || ParamList.GetCount() )
        Out_NdrConvert( pCCB,
                        GetFormatStringParamStart(),
                        ParamTotal,
                        GetOptimizationFlags() );

    if( ITERATOR_GETCOUNT( ParamList ) )
        {
        CG_PARAM    *   pParam;
        CG_PARAM    *   pS;

        ITERATOR_INIT( ParamList );

        while( ITERATOR_GETNEXT( ParamList, pParam ) )
            {
            // The extra fault/comm status param doesn't go on wire.

            pS = (CG_PARAM *)ITERATOR_PEEKTHIS( ParamList );

            pParam->GenUnMarshall( pCCB );
            }
        }

    // For the client side, generate the unmarshall call if there is a return
    // value.

    if( fReturnNeedsUnMarshall )
        {
        pRT->GenUnMarshall( pCCB );
        }

    return CG_OK;
}


CG_STATUS
CG_PROC::GenFree(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generates freeing code.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         ParamList;
    CGSIDE              Side;
    CG_RETURN       *   pRT;
    BOOL                fReturnNeedsFree    = FALSE;

    if( (Side = pCCB->GetCodeGenSide()) == CGSIDE_CLIENT )
        return CG_OK;

    // Else it's the server side

    GetMembers( ParamList );

    if ( ( pRT = GetReturnType() ) != 0 )
        fReturnNeedsFree = TRUE;

    if( ITERATOR_GETCOUNT( ParamList ) )
        {
        CG_PARAM    *   pParam;

        ITERATOR_INIT( ParamList );

        while( ITERATOR_GETNEXT( ParamList, pParam ) )
            {
            pParam->GenFree( pCCB );
            }
        }

    //
    // Size the return value on the server side if needed.
    //
    if( fReturnNeedsFree )
        {
        pRT->GenFree( pCCB );
        }

    return CG_OK;
}

CG_STATUS
CG_PROC::GenNotify(
    CCB *   pCCB,
    BOOL    fHasFlag )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the notify call for the procedure.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

 Notes:

    We need to generate a call to foo_notify with all parameters, exactly
    the same as the original procedure. The return value is a void.
----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();

    // Create an expression for the call to the notify procedure. The name
    // of the notify procedure is the procname suffixed by _notify.

    CSzBuffer   ProcName;

    ProcName.Set( GetType()->GetSymName() );
    ProcName.Append( (fHasFlag ? NOTIFY_FLAG_SUFFIX
                               : NOTIFY_SUFFIX) );

    expr_proc_call   ProcExpr( ProcName.GetData(), 0 );
    expr_variable *  pVarNode;
    expr_param    *  pFlagParam;

    if ( fHasFlag )
        {
        pVarNode   = new expr_variable( NOTIFY_FLAG_VAR_NAME );
        pFlagParam = new expr_param( pVarNode );

        ProcExpr.SetParam( pFlagParam );
        }

    // The call expression has been made. Emit it.

    pStream->NewLine();
    ProcExpr.PrintCall( pStream, 0, 0 );
    pStream->NewLine();

    // Clean up.

    if ( fHasFlag )
        {
        delete pVarNode;
        delete pFlagParam;
        }

    return CG_OK;
}


CG_STATUS
CG_PROC::GenEpilog(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side epilog for the procedure.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

 Notes:

    Decrement the indent back to the initial, and emit the closing brace.
----------------------------------------------------------------------------*/
{
    if( (pCCB->GetCodeGenSide() == CGSIDE_CLIENT) && GetReturnType() )
        {
        expr_node * pExpr = new expr_variable( RETURN_VALUE_VAR_NAME );
        pCCB->GetStream()->NewLine();
        pCCB->GetStream()->Write( "return " );
        pExpr->Print( pCCB->GetStream() );
        pCCB->GetStream()->Write( ';' );
        }

    if ( (pCCB->GetCodeGenSide() == CGSIDE_SERVER) )
        {
        ISTREAM * pStream = pCCB->GetStream();

        pStream->Write( PRPC_MESSAGE_VAR_NAME "->BufferLength = " );
        pStream->NewLine();
        pStream->Spaces( STANDARD_STUB_TAB );
        pStream->Write( "(unsigned int)(" STUB_MESSAGE_VAR_NAME ".Buffer - ");
        pStream->Write( "(unsigned char *)" PRPC_MESSAGE_VAR_NAME "->Buffer);" );
        pStream->NewLine();
        }

    Out_IndentDec( pCCB );
    Out_ProcClosingBrace( pCCB );
    return CG_OK;
}


CG_STATUS
CG_PROC::GenSizing(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate sizing code.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR            ParamList;
    CGSIDE              Side;
    CG_RETURN       *   pRT;
    BOOL                fReturnNeedsSizing  = FALSE;
    short               ParamCount = 0;

    pCCB->GetStream()->NewLine();


    if( (Side = pCCB->GetCodeGenSide()) == CGSIDE_CLIENT )
        ParamCount = GetInParamList( ParamList );
    else
        ParamCount = GetOutParamList( ParamList );

    if ( (Side == CGSIDE_SERVER) && (pRT = GetReturnType()) != 0 )
        fReturnNeedsSizing = TRUE;

    // On the server side if there are no out params and no returns, dont
    // generate code for sizing and get buffer at all !

    if( (Side == CGSIDE_SERVER) && (ParamCount == 0) && !fReturnNeedsSizing )
        {
        return CG_OK;
        }


    //
    // Analyze all the parameters and compute the constant buffer.
    // 

    long ConstantBufferSize = 0;

    if( ITERATOR_GETCOUNT( ParamList ) )
        {
        CG_PARAM    *   pParam;

        ITERATOR_INIT( ParamList );

        while( ITERATOR_GETNEXT( ParamList, pParam ) )
            {
            long ParamBufferSize = pParam->FixedBufferSize( pCCB );
            pParam->SetFixedBufferSize( ParamBufferSize );

            if (-1 != ParamBufferSize)
                ConstantBufferSize += ParamBufferSize;
            }
        }

    //
    // Size the return value on the server side if needed.
    //
    if( fReturnNeedsSizing )
        {
        long ReturnBufferSize = pRT->FixedBufferSize( pCCB );
        pRT->SetFixedBufferSize( ReturnBufferSize );
        
        if (-1 != ReturnBufferSize)
            ConstantBufferSize += ReturnBufferSize;
        }

    //
    // Init the length variable to 0.
    //

    Out_Assign( pCCB,
                new expr_variable ( STUB_MSG_LENGTH_VAR_NAME, 0 ),
                new expr_constant( ConstantBufferSize )
              );


    if( ITERATOR_GETCOUNT( ParamList ) )
        {
        CG_PARAM    *   pParam;

        ITERATOR_INIT( ParamList );

        while( ITERATOR_GETNEXT( ParamList, pParam ) )
            {
            if (pParam->GetFixedBufferSize() == -1)
                pParam->GenSizing( pCCB );
            }
        }

    //
    // Size the return value on the server side if needed.
    //
    if( fReturnNeedsSizing )
        {
        if (pRT->GetFixedBufferSize() == -1)
            pRT->GenSizing( pCCB );
        }

    GenGetBuffer( pCCB );

    return CG_OK;
}


CG_STATUS
CG_PROC::GenGetBuffer(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get the message buffer.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    if ( IsAutoHandle() && (pCCB->GetCodeGenSide() == CGSIDE_CLIENT) )
        Out_NdrNsGetBuffer( pCCB );
    else
        Out_NdrGetBuffer( pCCB );

    return CG_OK;
}


CG_STATUS
CG_PROC::GenMarshall(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Server side procedure to marshall out params.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:


----------------------------------------------------------------------------*/
{
    ITERATOR            ParamList;
    CGSIDE              Side;
    CG_RETURN       *   pRT;
    BOOL                fReturnNeedsMarshall    = FALSE;

    pCCB->SetCodeGenPhase( CGPHASE_MARSHALL );

    // Generate a call to tranform the data into the proper endianness.

    S_XFormToProperFormat( pCCB );

    // For all [in] params, generate the unmarshalling code.

    if( (Side = pCCB->GetCodeGenSide()) == CGSIDE_CLIENT )
        GetInParamList( ParamList );
    else
        GetOutParamList( ParamList );

    if ( (Side == CGSIDE_SERVER) && (pRT = GetReturnType()) != 0 )
        fReturnNeedsMarshall = TRUE;

    if( ITERATOR_GETCOUNT( ParamList ) )
        {
        CG_PARAM    *   pParam;
        CG_PARAM    *   pS;

        ITERATOR_INIT( ParamList );

        while( ITERATOR_GETNEXT( ParamList, pParam ) )
            {
            // IsExtraParam

            pS = (CG_PARAM *)ITERATOR_PEEKTHIS( ParamList );
            pParam->GenMarshall( pCCB );
            }
        }

    // For the server side, generate the marshall call if there is a return
    // value.

    if( fReturnNeedsMarshall )
        {
        pRT->GenMarshall( pCCB );
        }

    return CG_OK;
}

CG_STATUS
CG_PROC::GenRefChecks(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate ref checks for a procedure.

 Arguments:

    pCCB    - The code gen block.

 Return Value:

    CG_OK

 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         ParamList;
    CGSIDE              Side;

    // On the client side, perform ref checks for every pointer parameter.
    // On the server side, dont perform any checks at all. If it is a top
    // level ref, the stub allocates the pointee on the stack or in memory.
    // if the allocation fails, the engine will always raise an exception.
    // For embedded pointers, the engine checks anyhow.
    //
    // If the parameter is a cs tag (e.g. [cs_stag]), and the proc has 
    // a tag setting routine, the param will be allocated as a local variable
    // so we don't need to check them.

    if( (Side = pCCB->GetCodeGenSide()) == CGSIDE_CLIENT )
        {
        GetMembers( ParamList );

        if( ITERATOR_GETCOUNT( ParamList ) )
            {
            CG_PARAM    *   pParam;
    
            ITERATOR_INIT( ParamList );
    
            while( ITERATOR_GETNEXT( ParamList, pParam ) )
                {
                if( ( pCCB->GetOptimOption() & OPTIMIZE_SIZE )
                    && ( NULL == GetCSTagRoutine() || !pParam->IsSomeCSTag() ) )
                    {
                    pParam->GenRefChecks( pCCB );
                    }
                }
            }
        }
    return CG_OK;
}

CG_STATUS
CG_PROC::S_GenInitInLocals(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate in local initialization for the procedure.

 Arguments:

    pCCB    - The code gen block.

 Return Value:

    CG_OK

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR            ParamList;

    GetInParamList( ParamList );

    if( ITERATOR_GETCOUNT( ParamList ) )
        {
        CG_PARAM    *   pParam;

        ITERATOR_INIT( ParamList );

        while( ITERATOR_GETNEXT( ParamList, pParam ) )
            {
            pParam->S_GenInitInLocals( pCCB );
            }
        }

    return CG_OK;
}

/***************************************************************************
 * parameter code generation class implementation.
 ***************************************************************************/
CG_STATUS
CG_PARAM::S_GenInitInLocals(
    CCB *   pCCB )
    {
    pCCB->SetMemoryAllocDone();
    pCCB->ResetRefAllocDone();
    pCCB->SetSourceExpression( GetResource() );
    pCCB->SetLastPlaceholderClass(this);
    ((CG_NDR *)GetChild())->S_GenInitInLocals( pCCB );
    return CG_OK;
    }

CG_STATUS
CG_PARAM::S_GenInitOutLocals(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate local initialization for the parameters.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    
    if ( IsParamPartialIgnore() )
        {

        // Evaluate toplevel size_is.  Ignore first_is and length_is since
        // the entire data needs to be allocated and cleared.

        GenNdrTopLevelAttributeSupport( pCCB, TRUE );

        char *pParamName = GetResource()->GetResourceName();
        long FormatOffset = dynamic_cast<CG_NDR*>(GetChild())->GetFormatStringOffset();

        Out_PartialIgnoreServerInitialize( pCCB,
                                           pParamName,
                                           FormatOffset );
        return CG_OK;
        }

    else if( IsParamOut() && !IsParamIn() )
        {
        pCCB->SetMemoryAllocDone();
        pCCB->ResetRefAllocDone();
        pCCB->SetSourceExpression( GetResource() );
        pCCB->SetLastPlaceholderClass(this);
        ((CG_NDR *)GetChild())->S_GenInitOutLocals( pCCB );
        SetFinalExpression( GetResource() );
        }
    return CG_OK;
}

CG_STATUS
CG_PARAM::S_GenInitTopLevelStuff(
    CCB     *   pCCB )
    {
    ISTREAM *   pStream;
    CG_NDR *    pChild;
    ID_CG       ChildID;

    pStream = pCCB->GetStream();

    pChild = (CG_NDR *)GetChild();
    ChildID = pChild->GetCGID();

    if ( ChildID == ID_CG_GENERIC_HDL )
        {
        pChild = (CG_NDR *)pChild->GetChild();
        ChildID = pChild->GetCGID();
        }

    //
    // Initialize all [in] pointer and array params, and handle by-value
    // structures and unions.
    //
    if ( pChild->IsArray() || pChild->IsSimpleType() )
        {
        expr_node * pParam;
        expr_node *     pExpr;

        pParam = new expr_variable( GetResource()->GetResourceName() );
        pExpr = new expr_assign( pParam,
                                  new expr_constant( (long) 0 ) );

        pStream->NewLine();
        pExpr->Print( pStream );
        pStream->Write( ';' );
        }

    if ( pChild->IsPointer() )
        {
        // const type* ptr or type* const ptr
        // get initialized as (type*) ptr = 0;
        expr_node*  pParam;
        expr_node*  pExpr;
        expr_node*  pLHS;

        pParam = new expr_variable( GetResource()->GetResourceName() );

        node_skl*   pType = GetChild()->GetType();
        if ( pType != 0 && pType->NodeKind() != NODE_INTERFACE_REFERENCE )
            {
            expr_cast*  pCast = new expr_cast( pType, pParam );
            pCast->SetEmitModifiers( false );
            pLHS = pCast;
            }
        else
            {
            pLHS = pParam;
            }

        pExpr = new expr_assign( pLHS, new expr_constant( (long) 0 ) );
        pStream->NewLine();
        pExpr->Print( pStream );
        pStream->Write( ';' );
        }

    //
    // If this is a by-value structure or union then we allocate a
    // local which is a pointer to the same type.
    //
    if ( pChild->IsStruct() || pChild->IsUnion()  ||
         pChild->IsXmitRepOrUserMarshal() )
        {
        expr_node * pParam;
        expr_node * pPointer;
        expr_node *     pExpr;
        char *          pPointerName;
        char *          pPlainName = GetResource()->GetResourceName();

        pPointerName = new char[strlen( pPlainName ) + 10];

        strcpy( pPointerName, LOCAL_NAME_POINTER_MANGLE);
        strcat( pPointerName, pPlainName);

        pParam = new expr_u_address (
                 new expr_variable( pPlainName ) );

        pPointer = new expr_variable( pPointerName );

        pExpr = new expr_assign( pPointer, pParam );

        pStream->NewLine();
        pExpr->Print( pStream );
        pStream->Write( ';' );

        //
        // Memset [in], [in,out] by-value structs & unions in case we catch
        // an exception before we finish unmarshalling them.  If they have
        // embedded pointers they must be zeroed before freeing.
        //
        if ( IsParamIn() &&
             (pChild->IsStruct() || pChild->IsUnion()) )
            {
            Out_MemsetToZero( pCCB,
                              pPointer,
                              new expr_sizeof( pChild->GetType() ) );
            }

        // If there is a transmit_as etc, init the ptr to 0.

        switch( ChildID )
            {
            case ID_CG_TRANSMIT_AS:
                {
                expr_proc_call * pProc = new expr_proc_call( MIDL_MEMSET_RTN_NAME );
                pProc->SetParam( new expr_param( pPointer ) );
                pProc->SetParam( new expr_param( new expr_constant( 0L ) ) );
                pProc->SetParam(
                     new expr_param(
                       new expr_sizeof(
                        ((CG_TRANSMIT_AS *)pChild)->GetPresentedType())));
                pCCB->GetStream()->NewLine();
                pProc->PrintCall( pCCB->GetStream(), 0, 0 );
                break;
                }
            case ID_CG_REPRESENT_AS:
                {
                node_skl    *   pNode = new node_def(
                            ((CG_REPRESENT_AS *)pChild)->GetRepAsTypeName() );
                expr_proc_call * pProc = new expr_proc_call( MIDL_MEMSET_RTN_NAME  );
                pProc->SetParam( new expr_param( pPointer ) );
                pProc->SetParam( new expr_param( new expr_constant( 0L ) ) );
                pProc->SetParam( new expr_param( new expr_sizeof( pNode ) ) );
                pCCB->GetStream()->NewLine();
                pProc->PrintCall( pCCB->GetStream(), 0, 0 );
                break;
                }
            case ID_CG_USER_MARSHAL:
                {
                node_skl    *   pNode = new node_def(
                            ((CG_REPRESENT_AS *)pChild)->GetRepAsTypeName() );
                expr_proc_call * pProc = new expr_proc_call( MIDL_MEMSET_RTN_NAME  );
                pProc->SetParam( new expr_param( pPointer ) );
                pProc->SetParam( new expr_param( new expr_constant( 0L ) ) );
                pProc->SetParam( new expr_param( new expr_sizeof( pNode ) ) );
                pCCB->GetStream()->NewLine();
                pProc->PrintCall( pCCB->GetStream(), 0, 0 );
                break;
                }
            default:
                break;
            }
        }

    if ( ChildID == ID_CG_PRIMITIVE_HDL )
        {
        pStream->NewLine();
        pStream->Write( GetType()->GetSymName() );
        pStream->Write( " = " PRPC_MESSAGE_VAR_NAME "->Handle;" );
        }

    return CG_OK;
    }

CG_STATUS
CG_PARAM::GenMarshall(
    CCB     *   pCCB )
{
    CG_STATUS   Status;
    CG_NDR *    pOldPlaceholder;

    // The fault/comm additional parameter doesn't go on wire.

    if ( IsExtraStatusParam() )
        return CG_OK;

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    GenNdrMarshallCall( pCCB );
    Status = CG_OK;

    pCCB->SetLastPlaceholderClass( pOldPlaceholder );
    return CG_OK;
}

CG_STATUS
CG_PARAM::GenUnMarshall(
    CCB     *   pCCB )
{
    CG_STATUS       Status;
    CG_NDR      *   pOldPlaceholder;
    CG_NDR      *   pC  = (CG_NDR *)GetChild();
    BOOL            fPtrToContext = FALSE;
    expr_node   *   pFinalExpr  = GetResource();

    // The fault/comm additional parameter doesn't go on wire...
    // However, we need to generate an assignment in its place.

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    if ( pC->GetCGID() == ID_CG_CONTEXT_HDL ||
        ( (fPtrToContext = ( pC->GetChild()) != 0 && pC->GetChild()->GetCGID() == ID_CG_CONTEXT_HDL ) ) == TRUE )
        {
        expr_node      *    pExpr;
        expr_proc_call *    pProc = new expr_proc_call( "NDRSContextValue" );
        CG_CONTEXT_HANDLE * pCtxtHandle;

        pProc->SetParam( new expr_param( GetResource() ) );

        if( fPtrToContext )
            {
            pExpr   = new expr_u_deref( pProc );
            pCtxtHandle = (CG_CONTEXT_HANDLE *)pC->GetChild();
            }
        else
            {
            pExpr   = pProc;
            pCtxtHandle = (CG_CONTEXT_HANDLE *)pC;
            }

        pExpr   = new expr_cast( GetType()->GetChild(), pExpr );
        pFinalExpr = pExpr;

        // Register the context handle for a rundown.

        if( pCtxtHandle->GetHandleType()->NodeKind() == NODE_DEF )
            pCCB->RegisterContextHandleType( pCtxtHandle->GetHandleType() );
        }


    GenNdrUnmarshallCall( pCCB );
    SetFinalExpression( pFinalExpr );
    Status = CG_OK;
	
    pCCB->SetLastPlaceholderClass( pOldPlaceholder );

    return Status;
}


CG_STATUS
CG_PARAM::GenSizing(
    CCB *       pCCB )
{
    CG_STATUS   Status;
    CG_NDR *    pOldPlaceholder;

    // The fault/comm additional parameter doesn't go on wire.

    if ( IsExtraStatusParam() || IsAsyncHandleParam() )
        return CG_OK;

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    GenNdrBufferSizeCall( pCCB );
		
    Status = CG_OK;
		
    pCCB->SetLastPlaceholderClass( pOldPlaceholder );
    return CG_OK;
}

CG_STATUS
CG_PARAM::GenFree(
    CCB     *   pCCB )
{
    CG_NDR *    pOldPlaceholder;

    if ( IsExtraStatusParam() )
        return CG_OK;

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    GenNdrFreeCall( pCCB );

    pCCB->SetLastPlaceholderClass( pOldPlaceholder );

    return CG_OK;
}
CG_STATUS
CG_PARAM::GenRefChecks(
    CCB     *   pCCB )
{
    pCCB->ResetEmbeddingLevel();
    pCCB->ResetIndirectionLevel();
    pCCB->ResetReturnContext();
    pCCB->ResetRefAllocDone();
    pCCB->SetPrefix(0);
    pCCB->SetSourceExpression( GetResource() );
    ((CG_NDR *)GetChild())->GenRefChecks( pCCB );

    return CG_OK;
}

/*****************************************************************************
    CG_RETURN procedures.
 *****************************************************************************/
CG_STATUS
CG_RETURN::GenMarshall(
    CCB     *   pCCB )
{
    CG_NDR *    pOldPlaceholder;

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    GenNdrMarshallCall( pCCB );
    pCCB->SetLastPlaceholderClass( pOldPlaceholder );
    return CG_OK;

}

CG_STATUS
CG_RETURN::GenSizing(
    CCB *   pCCB )
    {
    CG_NDR *    pOldPlaceholder;

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    pCCB->SetSourceExpression( GetResource() );

  	GenNdrBufferSizeCall( pCCB );
		
    pCCB->SetLastPlaceholderClass( pOldPlaceholder );
    return CG_OK;
    }

CG_STATUS
CG_RETURN::GenUnMarshall(
    CCB     *   pCCB )
{
    CG_NDR *    pOldPlaceholder;

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    ISTREAM * pStream;
    
    pStream = pCCB->GetStream();

    //
    // Initialize a pointer return type to 0.
    //
    if ( GetChild()->IsPointer() )
        {
  	pStream->NewLine();
  	pStream->Write( RETURN_VALUE_VAR_NAME );
  	pStream->Write( " = 0;" );
  	}

    //
    // Initialize a struct or union return value.
    //
    if ( GetChild()->IsStruct() || GetChild()->IsUnion() ||
         ((CG_NDR *)GetChild())->IsXmitRepOrUserMarshal() )
  	{
  	pStream->NewLine();
  	pStream->Write( LOCAL_NAME_POINTER_MANGLE RETURN_VALUE_VAR_NAME );
  	pStream->Write( " = " );
  	pStream->Write( "(void *) &" RETURN_VALUE_VAR_NAME );
  	pStream->Write( ';' );
  	}

    GenNdrUnmarshallCall( pCCB );
    pCCB->SetLastPlaceholderClass( pOldPlaceholder );
    return CG_OK;

}

CG_STATUS
CG_RETURN::S_GenInitOutLocals(
    CCB     *   pCCB )
{
    CG_NDR * pNdr;

    pNdr = (CG_NDR *) GetChild();

    //
    // The only return type we ever have to initialize is a context handle.
    // A pointer to a context handle as a return type is forbidden.
    //
    if ( pNdr->GetCGID() == ID_CG_CONTEXT_HDL )
        {
        pCCB->SetLastPlaceholderClass(this);
        pNdr->S_GenInitOutLocals( pCCB );
        }

    return CG_OK;
}

CG_STATUS
CG_RETURN::S_GenInitTopLevelStuff(
    CCB     *   pCCB )
{
    CG_NDR *    pChild;
    expr_node * pExpr;

    pChild = (CG_NDR *) GetChild();

    pExpr = new expr_u_address (
            new expr_variable( RETURN_VALUE_VAR_NAME ) );

    if ( pChild->IsStruct() || pChild->IsUnion() )
        {
        Out_MemsetToZero( pCCB,
                          pExpr,
                          new expr_sizeof( pChild->GetType() ) );
        }

    return CG_OK;
}

CG_STATUS
CG_RETURN::GenFree(
    CCB *   pCCB )
    {
    CG_NDR *    pOldPlaceholder;
    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    GenNdrFreeCall( pCCB );

    pCCB->SetLastPlaceholderClass( pOldPlaceholder );
    return CG_OK;
    }

expr_node *
CG_RETURN::GetFinalExpression()
    {
    expr_node * pReturnExpr;
    BOOL         fPtrToContext  = FALSE;
    CG_NDR  *    pC = (CG_NDR *)GetChild();

    if( pC->GetCGID() == ID_CG_CONTEXT_HDL ||
        ( (fPtrToContext = ( pC->GetChild()) != 0 &&
                 pC->GetChild()->GetCGID() == ID_CG_CONTEXT_HDL ) ) == TRUE )
        {
        expr_node       *   pExpr;
        expr_proc_call * pProc      = new expr_proc_call( "NDRSContextValue" );

        pProc->SetParam( new expr_param( GetResource() ) );

        // cast the proc call to this type.

        pExpr   = MakeDerefExpressionOfCastPtrToType( GetType(), pProc );

        pReturnExpr = pExpr;
        }
    else
        pReturnExpr = GetResource();

    return pReturnExpr;
    }

CG_STATUS
CG_CALLBACK_PROC::GenClientStub( CCB * pCCB )
    {
    CGSIDE  Side = pCCB->GetCodeGenSide();

    pCCB->GetInterfaceCG()->SetDispatchTBLPtrForCallback();
    pCCB->SetInCallback();
    CG_PROC::GenServerStub( pCCB );
    pCCB->ClearInCallback();
    pCCB->GetInterfaceCG()->RestoreDispatchTBLPtr();

    pCCB->SetCodeGenSide( Side );
    return CG_OK;
    }

CG_STATUS
CG_CALLBACK_PROC::GenServerStub( CCB * pCCB )
    {
    CGSIDE  Side = pCCB->GetCodeGenSide();

    pCCB->GetInterfaceCG()->SetDispatchTBLPtrForCallback();
    pCCB->SetInCallback();
    CG_PROC::GenClientStub( pCCB );
    pCCB->ClearInCallback();
    pCCB->GetInterfaceCG()->RestoreDispatchTBLPtr();
    pCCB->SetCodeGenSide( Side );
    return CG_OK;
    }

void
CG_PROC::GetCorrectAllocFreeRoutines(
    CCB *   pCCB,
    BOOL    fServer,
    char ** ppAllocName,
    char ** ppFreeName )
/*++
    Finds out correct Alloc and Free routine names, depending on the mode
    (osf vs. msft) and need to enable memory management.

    In object mode:
        use NdrOleAllocate, NdrOleFree

    In ms_ext mode and c-ext:
        unless forced to enable allocate, use MIDL_user_*

    In osf mode:
        client always uses NdrRpcSsClient*
        server use a default allocator or RpcSsAllocate.

++*/
{
    *ppAllocName = (char *) DEFAULT_ALLOC_RTN_NAME;      // MIDL_user_allocate
    *ppFreeName  = (char *) DEFAULT_FREE_RTN_NAME;       // MIDL_user_free

    if ( IsObject() )
        {
        *ppAllocName = (char *) OLE_ALLOC_RTN_NAME;      // NdrOleAllocate
        *ppFreeName  = (char *) OLE_FREE_RTN_NAME;       // NdrOleFree
        }
    else if ( MustInvokeRpcSSAllocate() )
        {
        // This means: msft mode - only when forced to enable
        //             osf  mode - when there is a need or forced to.

        if ( fServer )
            {
            *ppAllocName = (char *) RPC_SS_SERVER_ALLOCATE_RTN_NAME;
            *ppFreeName  = (char *) RPC_SS_SERVER_FREE_RTN_NAME;
            }
        else
            {
            *ppAllocName = (char *) RPC_SM_CLIENT_ALLOCATE_RTN_NAME;
            *ppFreeName  = (char *) RPC_SM_CLIENT_FREE_RTN_NAME;
            }
        }
    else
    if ( pCCB->GetMode() == 0 )
        {
        // osf, without having to enable memory manager

        if ( fServer )
            {
            *ppAllocName = (char *) DEFAULT_ALLOC_OSF_RTN_NAME;
            *ppFreeName  = (char *) DEFAULT_FREE_OSF_RTN_NAME;
            }
        else
            {
            *ppAllocName = (char *) RPC_SM_CLIENT_ALLOCATE_RTN_NAME;
            *ppFreeName  = (char *) RPC_SM_CLIENT_FREE_RTN_NAME;
            }
        }
}

void
GenCorrInit (
            CCB*    pCCB
            )
    {
    ISTREAM*    pStream         = pCCB->GetStream();
    ITERATOR    ParamList;

    // _StubMsg
    expr_node*  pExpr = pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
    pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
    pExpr   = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME, pExpr );
    ITERATOR_INSERT( ParamList, pExpr );

    // _Cache
    pExpr  = pCCB->GetLocalResource( NDR_CORR_CACHE_VAR_NAME );
    ITERATOR_INSERT( ParamList, pExpr );
    
    // _CacheSize
    unsigned long ulSize = NDR_CORR_CACHE_SIZE * sizeof( unsigned long );
    pExpr = new expr_constant( ulSize );
    ITERATOR_INSERT( ParamList, pExpr );

    // _Flags
    pExpr = new expr_constant( unsigned long( 0 ) );
    ITERATOR_INSERT( ParamList, pExpr );

    expr_proc_call* pProcCall = MakeProcCallOutOfParamExprList  (
                                                                CSTUB_CORR_INIT_RTN_NAME,
                                                                0,
                                                                ParamList
                                                                );
    pStream->NewLine();
    pProcCall->PrintCall( pStream, 0, 0 );
    pStream->NewLine();
    }

void
GenCorrPassFree (
                CCB*    pCCB,
                char*   szRtn
                )
    {
    ISTREAM*    pStream     = pCCB->GetStream();
    expr_node*  pExpr = pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );

    pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
    pExpr   = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME, pExpr );

    ITERATOR    ParamList;
    ITERATOR_INSERT( ParamList, pExpr );

    expr_proc_call* pProcCall = MakeProcCallOutOfParamExprList  (
                                                                szRtn,
                                                                0,
                                                                ParamList
                                                                );
    pStream->NewLine();
    pProcCall->PrintCall( pStream, 0, 0 );
    pStream->NewLine();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\ptrgen.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

	ptrgen.cxx

 Abstract:

	Implementations of the pointer cg class methods.

 Notes:


 History:

 	Oct-10-1993		VibhasC		Created

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

CG_STATUS
CG_POINTER::S_GenInitOutLocals(
	CCB		*	pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Generate code for initialization of server side local variables.

 Arguments:

	pCCB	- A Ptr to the code gen controller block.

 Return Value:

 Notes:

	The source expression field of the ccb has the final presented expression.
----------------------------------------------------------------------------*/
{
	expr_node	*	pExpr;

	if( pCCB->IsRefAllocDone() )
		{
		pExpr = MakeAddressExpressionNoMatterWhat( GetResource() );
		Out_Assign( pCCB, pCCB->GetSourceExpression(), pExpr );
		pExpr = pCCB->SetSourceExpression( GetResource() );
		Out_Assign( pCCB, GetResource(), new expr_constant( 0L ) );
		}
	else
		pExpr = pCCB->GetSourceExpression();

	if( IsRef() && !IsQualifiedPointer() )
		{
		pCCB->ResetMemoryAllocDone();
		pCCB->SetRefAllocDone();
		((CG_NDR *)GetChild())->S_GenInitOutLocals( pCCB );
		}

	// If it is a byte count pointer, allocate the bytes specified as the
	// byte count param.

	// else if it is an out sized etc pointer, then must allocate.

	if( GetCGID() == ID_CG_BC_PTR )
		{
		PNAME	pName = ((CG_BYTE_COUNT_POINTER *)this)->GetByteCountParam()->GetSymName();

		expr_node * pByteCountExpr = new expr_variable( pName );

		Out_Alloc(pCCB,
				  pExpr,
				  0,
				  pByteCountExpr );

		}
	else if( IsQualifiedPointer() && !(GetCGID() == ID_CG_STRING_PTR) && IsRef() )
		{
		expr_node * pElementExpr;
		expr_node * pFinalExpr;
		expr_node * pCheckExpr;
		BOOL        fIsSigned;

		// Fool the presented expression to beleive it is marshalling, so that
		// it generates the correct expression.

		CGPHASE	Ph = pCCB->GetCodeGenPhase();
		pCCB->SetCodeGenPhase( CGPHASE_MARSHALL );

		// The proper size of the allocation is size times the element size.

		pElementExpr = new expr_constant(
						 (long) (((CG_NDR *)GetChild())->GetMemorySize()) );

		pFinalExpr = FinalSizeExpression( pCCB );

		fIsSigned = !((node_base_type *)pFinalExpr->GetType()->GetBasicType())->IsUnsigned();

		pFinalExpr = new expr_op_binary( OP_STAR,
										  pFinalExpr,
										  pElementExpr );
										  
		// Allocate the proper size.
		// If the size expression is signed and the value is less than 0, we
		// need to raise an exception.

		if( pCCB->MustCheckBounds() && fIsSigned )
		    {
		    pCheckExpr = new expr_op_binary( OP_LESS,
		                                     pFinalExpr,
		                                     new expr_constant(0L));
		    Out_If( pCCB, pCheckExpr);
		    Out_RaiseException( pCCB, "RPC_X_INVALID_BOUND" );
		    Out_Endif( pCCB );
		    }

		Out_Alloc(pCCB,
				  pExpr,
				  0,
				  pFinalExpr );

		pCCB->SetCodeGenPhase( Ph );
		}
	return CG_OK;
}

CG_STATUS
CG_STRING_POINTER::GenConfVarianceEtcUnMarshall( CCB* )
	{
	return CG_OK;
	}

/*****************************************************************************
 	utility functions
 *****************************************************************************/
expr_node *
CG_POINTER::GenBindOrUnBindExpression(
	CCB	*	pCCB,
	BOOL	 )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Generate the final binding expression.

 Arguments:

 	pCCB	- Ptr to Code gen controller block.
 	fBind	- Indicates a bind or unbind code gen.

 Return Value:

 Notes:

----------------------------------------------------------------------------*/
{
	MIDL_ASSERT( pCCB->GetSourceExpression() );
	return new expr_u_deref( pCCB->GetSourceExpression() );
}

CG_STATUS
CG_POINTER::GenRefChecks(
	CCB		*	pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:
 	
 	Generate ref checks for a pointer.

 Arguments:

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
{
	expr_node * pSrc = pCCB->GetSourceExpression();

	if( IsRef() )
		{
		if( pCCB->IsRefAllocDone() )
			pSrc = pCCB->SetSourceExpression(
			 	MakeDereferentExpressionIfNecessary(
					 pCCB->GetSourceExpression()));

		// using the source expression, check for null ref pointers.

		Out_If( pCCB, new expr_u_not( pSrc ) );
		Out_RaiseException( pCCB,  "RPC_X_NULL_REF_POINTER" );
		Out_Endif( pCCB );

		pCCB->SetRefAllocDone();
		pCCB->ResetMemoryAllocDone();
		((CG_NDR *)GetChild())->GenRefChecks( pCCB );
		}

	return CG_OK;
}
CG_STATUS
CG_POINTER::S_GenInitInLocals(
	CCB		*	pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:
 	
 	Perform in local init code generation. This method does nothing for 
 	pointers. Ref pointers are supposed to pass this message to their
 	children after setting the appropriate source expressions.

 Arguments:

	pCCB	- The code gen block.

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
{
	expr_node * pSrc = pCCB->GetSourceExpression();

	if( IsRef() )
		{
		if( pCCB->IsRefAllocDone() )
			pSrc = pCCB->SetSourceExpression(
			 	MakeDereferentExpressionIfNecessary(
					 pCCB->GetSourceExpression()));

		((CG_NDR *)GetChild())->S_GenInitInLocals( pCCB );
		}

	return CG_OK;
}

expr_node *
CG_POINTER::FinalSizeExpression(
	CCB		*	pCCB )
	{
	return PresentedSizeExpression( pCCB );
	}
expr_node *
CG_POINTER::FinalFirstExpression(
	CCB		*	pCCB )
	{
	return PresentedFirstExpression( pCCB );
	}
expr_node *
CG_POINTER::FinalLengthExpression(
	CCB		*	pCCB )
	{
	return PresentedLengthExpression( pCCB );
	}

expr_node *
CG_STRING_POINTER::PresentedSizeExpression(
	 CCB * pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetSizeResource();
		}
	else
		{
		return PresentedLengthExpression( pCCB );
		}
	}
expr_node *
CG_STRING_POINTER::PresentedLengthExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL ) 
		{
		return GetLengthResource();
		}
	else if((pCCB->GetCodeGenPhase() == CGPHASE_MARSHALL ) && !IsUsedInArray())
		{
		return GetLengthResource();
		}
	else
		{
		unsigned short Size	= (unsigned short )((CG_NDR *)GetChild())->GetMemorySize();
		expr_proc_call	*	pProc;
		PNAME				pName;
		expr_node		*	pExpr;

		if( Size == 1 )
			{
			pName	= "strlen";
			}
		else if( Size == 2)
			{
			pName	= "MIDL_wchar_strlen";
			}
		else
			pName = "MIDL_NChar_strlen";
	
		pProc	= new expr_proc_call( pName );
		pProc->SetParam( new expr_param( pCCB->GetSourceExpression() ));
		pExpr	= new expr_b_arithmetic( OP_PLUS,
									  	pProc,
									  	new expr_constant( 1L ));

		return pExpr;
		}
	}


expr_node *
CG_SIZE_STRING_POINTER::PresentedSizeExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetSizeResource();
		}
	else
		{
		return GetSizeIsExpr();
		}
	}

expr_node *
CG_SIZE_POINTER::PresentedSizeExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetSizeResource();
		}
	else
		{
		return GetSizeIsExpr();
		}
	}
expr_node *
CG_LENGTH_POINTER::PresentedLengthExpression(
	CCB		*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetLengthResource();
		}
	else
		{
		return GetLengthIsExpr();
		}
	}
expr_node *
CG_LENGTH_POINTER::PresentedFirstExpression(
	CCB		*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetFirstResource();
		}
	else
		{
		return GetFirstIsExpr();
		}
	}
expr_node *
CG_SIZE_LENGTH_POINTER::PresentedSizeExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetSizeResource();
		}
	else
		{
		return GetSizeIsExpr();
		}
	}
expr_node *
CG_SIZE_LENGTH_POINTER::PresentedLengthExpression(
	CCB		*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetLengthResource();
		}
	else
		{
		return GetLengthIsExpr();
		}
	}
expr_node *
CG_SIZE_LENGTH_POINTER::PresentedFirstExpression(
	CCB		*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetFirstResource();
		}
	else
		{
		return GetFirstIsExpr();
		}
	}

CG_STATUS
CG_IIDIS_INTERFACE_POINTER::S_GenInitOutLocals(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Generate the init call for the locals.

 Arguments:

 	pCCB	- The ptr to code gen block.
	
 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
	expr_node	*	pExpr;

	if( !pCCB->IsRefAllocDone() )
		{
		pExpr	= new expr_sizeof( GetType() );
		Out_Alloc( pCCB, pCCB->GetSourceExpression(), 0, pExpr );
		}
	else
		{
		pExpr = MakeAddressExpressionNoMatterWhat( GetResource() );
		Out_Assign( pCCB, pCCB->GetSourceExpression(), pExpr );
		pExpr = pCCB->SetSourceExpression( GetResource() );
		Out_Assign( pCCB, GetResource(), new expr_constant( 0L ) );
		}

	return CG_OK;
}


CG_STATUS
CG_INTERFACE_POINTER::S_GenInitOutLocals(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Generate the init call for the locals.

 Arguments:

 	pCCB	- The ptr to code gen block.
	
 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
	expr_node	*	pExpr;

	if( !pCCB->IsRefAllocDone() )
		{
		pExpr	= new expr_sizeof( GetType() );
		Out_Alloc( pCCB, pCCB->GetSourceExpression(), 0, pExpr );
		}
	else
		{
		pExpr = MakeAddressExpressionNoMatterWhat( GetResource() );
		Out_Assign( pCCB, pCCB->GetSourceExpression(), pExpr );
		pExpr = pCCB->SetSourceExpression( GetResource() );
		Out_Assign( pCCB, GetResource(), new expr_constant( 0L ) );
		}

	return CG_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\resdict.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	resdict.cxx

 Abstract:

	resource dictionary class implementations, if needed.

 Notes:


 History:

 	VibhasC		Aug-08-1993		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

short
RESOURCE_DICT::GetListOfResources(
	ITERATOR&	ListIter )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Get a list of resources into the specified iterator.

 Arguments:
	
	ListIter	- A reference to the iterator class where the list is
				  accumulated.

 Return Value:
	
	A count of the number of resources.

 Notes:

----------------------------------------------------------------------------*/
{
	RESOURCE	*	pR;
	Dict_Status		Status;
	short			Count	= 0;
	
	//
	// Get to the top of the dictionary.
	//

	Status = Dict_Next( (pUserType) 0 );

	//
	// Iterate till the entire dictionary is done.
	//

	while( SUCCESS == Status )
		{
		pR	= (RESOURCE *)Dict_Curr_Item();
		ITERATOR_INSERT( ListIter, pR );
		Count++;
		Status = Dict_Next( pR );
		}

	return Count;
}

void
RESOURCE_DICT::Clear()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Clear the dictionary of all resources allocated.

 Arguments:

 	None.
	
 Return Value:
	
	None.

 Notes:

----------------------------------------------------------------------------*/
{

	Dict_Status		Status;
	RESOURCE	*	pResource;

	//
	// The way to delete all elements is to get to the top and then
	// do a get next, delete each one.
	//

	//
	// Note: Dict_Next() has a default parameter of null. This returns the
	// first record in the dictionary.
	//

	Status = Dict_Next();

	while( SUCCESS == Status )
		{
		pResource = (RESOURCE *)Dict_Curr_Item();
		Status = Dict_Delete( (pUserType *) &pResource );
		delete pResource;
		}

}

RESOURCE *
RESOURCE_DICT::Insert(
	PNAME			pResourceName,
	node_skl	*	pType )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Insert a resource in the dictionary.

 Arguments:
	
	pName	- Name of the resource being inserted.

 Return Value:
	
 	The resource which was created and inserted.

 Notes:

	Search for the resource, if it already exists, dont insert. This
	may really be an overkill for the code generator, since the code
	generator usually knows when to insert a resource. If necessary
	we can remove this.
	
----------------------------------------------------------------------------*/
{

	RESOURCE	*	pResource;
	RESOURCE		DummyResource( pResourceName, (node_skl *)0 );
	Dict_Status		Status	= Dict_Find( &DummyResource );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:

			pResource = new RESOURCE( pResourceName, pType );
			Dict_Insert( (pUserType) pResource );
			return pResource;
		default:
			return (RESOURCE *)Dict_Curr_Item();
		}
}

RESOURCE *
RESOURCE_DICT::Search(
	PNAME				pResourceName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Search for a resource in the dictionary.

 Arguments:
	
	pResourceName	- Name of the resource being searched for.

 Return Value:
	
	A		pointer to the resource expression if found.
	NULL	otherwise.
 Notes:

----------------------------------------------------------------------------*/
{
	//
	// In order to search, we must create a dummy resource to compare
	// against.
	//
	RESOURCE	DummyResource( pResourceName, (node_skl *)0 );
	Dict_Status		Status;

	//
	// Search.
	//

	Status	= Dict_Find( &DummyResource );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:
			return (RESOURCE *)0;
		default:
			return (RESOURCE *)Dict_Curr_Item();
		}
}

SSIZE_T
RESOURCE_DICT::Compare(
	 void * p1,
	 void * p2 )
	{
	RESOURCE 	*	pRes1	= (RESOURCE *)p1;
	RESOURCE	*	pRes2 	= (RESOURCE *)p2;

	p1 = pRes1->GetResourceName();
	p2 = pRes2->GetResourceName();

	return strcmp((const char *)p1, (const char *)p2);
	}

void
PrintResourceKey( void * p )
	{
	((void)(p));
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\resmgr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	resmgr.cxx

 Abstract:

	Stub and auxillary routine resource management helper routines.

 Notes:

	This file has a dependency on the type graph implementation.

 History:

	Sep-15-1993		VibhasC		Created.
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

void GenNdrCorrRes( ANALYSIS_INFO*  pAna );

void
CG_PROC::C_PreAllocateResources(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Pre-allocate stub resources like local variables, parameter variables
	etc for the client side stub.

 Arguments:

 	pAna	- A pointer to the analysis block.
	
 Return Value:
	
	None.

 Notes:

 	1. All parameters are declared as resources for the client stub.
 	2. Standard client side resources like the stub message, rpc message
 	   status etc are local resources.
 	
----------------------------------------------------------------------------*/
{
	node_id	*	pRpcMessageType	= new node_id( RPC_MESSAGE_VAR_NAME );
	node_id	*	pStubMessageType= new node_id( STUB_MESSAGE_VAR_NAME );
	node_id	*	pStatus			= new node_id( RPC_STATUS_VAR_NAME );
	CG_ITERATOR	ParamList;

	// Set up local copies of the stub message and the rpc message.

	pRpcMessageType->SetBasicType( (node_skl *)
									new node_def (RPC_MESSAGE_TYPE_NAME) );
	pRpcMessageType->SetEdgeType( EDGE_USE );
	pAna->AddLocalResource( RPC_MESSAGE_VAR_NAME,
						    (node_skl *) pRpcMessageType
						  );

	pStubMessageType->SetBasicType( (node_skl *)
									new node_def (STUB_MESSAGE_TYPE_NAME) );

	pStubMessageType->SetEdgeType( EDGE_USE );
	pAna->AddLocalResource( STUB_MESSAGE_VAR_NAME,
							(node_skl *) pStubMessageType
						  );

	if( HasStatuses() )
		{
		pStatus			= new node_id( RPC_STATUS_VAR_NAME );
		pStatus->SetBasicType( (node_skl *)
									new node_def (RPC_STATUS_TYPE_NAME) );

		pStatus->SetEdgeType( EDGE_USE );
		SetStatusResource( pAna->AddLocalResource( RPC_STATUS_VAR_NAME,
												(node_skl *) pStatus
						  						));
		}

    // resource for cache
    // /deny causes a switch to /Oicf. This code will not be executed
    if ( fHasDeny )
        {
        GenNdrCorrRes( pAna );
        }

	// Add all params as param resources only if necessary (at least one param).

	if( GetMembers( ParamList ) )
		{
		CG_PARAM	*	pParam;
		node_skl	*	pType;

		ITERATOR_INIT( ParamList );

		while( ITERATOR_GETNEXT( ParamList, pParam ) )
			{
			pType		= pParam->GetType();
			pAna->AddParamResource( (PNAME) pType->GetSymName(),
									pType->GetChild() //Yes not getbasictype()
								  );
			}
		}

    //
    // Check for a structure or union return type.  If one exists we must
	// allocate a local pointer with a munged name for the eventual 
	// Ndr unmarshall call.
    //
    CG_RETURN * pReturn;

	if ( (pReturn = GetReturnType()) == 0 )
		return;

    //
    // If this is a by-value structure or union then we allocate a
    // local which is a pointer to the same type.
    //
    if ( ((CG_NDR *)pReturn->GetChild())->IsStruct() ||
         ((CG_NDR *)pReturn->GetChild())->IsUnion()  ||
         ((CG_NDR *)pReturn->GetChild())->IsXmitRepOrUserMarshal() )
        {
        node_id *   pLocalType;
		char *		pName;

		pName = LOCAL_NAME_POINTER_MANGLE  RETURN_VALUE_VAR_NAME;

        pLocalType = MakePtrIDNodeFromTypeName( pName, "void", 0 );

        pAna->AddLocalResource( pName,
                                (node_skl *) pLocalType );
        }
}

void
CG_PROC::S_PreAllocateResources(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Pre-allocate variables that are needed on the server side.

 Arguments:

 	pAna			- A pointer to the analysis block.
	
 Return Value:
	
	None.

 Notes:

 	1. The rpc message is a parameter resource allocated on the server side.
 	2. All other local variables, are decided during/after the analysis phase.
 	
----------------------------------------------------------------------------*/
{
	node_id	*	pStubMessageType= new node_id( STUB_MESSAGE_VAR_NAME );
	node_param	*	pRpcMessageType	= new node_param();
    node_param  *   pDWordType      = new node_param();
	CG_ITERATOR	ParamList;

	// The local copy of the rpc message pointer.

	pRpcMessageType->SetSymName( PRPC_MESSAGE_VAR_NAME );
	pRpcMessageType->SetBasicType( (node_skl *)
									new node_def (PRPC_MESSAGE_TYPE_NAME) );
	pRpcMessageType->SetEdgeType( EDGE_USE );

	pAna->AddParamResource( PRPC_MESSAGE_VAR_NAME,
						    (node_skl *) pRpcMessageType
						  );

    // For object procs , one more param after the rpc message.

    if( IsObject() )
        {
        // DWORD * pDwPhase parameter

        pDWordType->SetSymName( "_pdwStubPhase" );
        pDWordType->SetBasicType( (node_skl *)new node_def( "DWORD *" ) );
        pDWordType->SetEdgeType( EDGE_USE );
        pAna->AddParamResource( "_pdwStubPhase", pDWordType );
        }

	// Add the stub message local variable.

	pStubMessageType->SetBasicType( (node_skl *)
									new node_def (STUB_MESSAGE_TYPE_NAME) );

	pStubMessageType->SetEdgeType( EDGE_USE );
	pAna->AddLocalResource( STUB_MESSAGE_VAR_NAME,
							(node_skl *) pStubMessageType
						  );

    if ( HasNotifyFlag() )
        {
        node_id * pNotifyFlag = new node_id( NOTIFY_FLAG_VAR_NAME );

        pNotifyFlag->SetBasicType( (node_skl *) new node_def( "boolean" ));
        pNotifyFlag->SetEdgeType( EDGE_USE );

        pAna->AddLocalResource( NOTIFY_FLAG_VAR_NAME,
                                (node_skl *) pNotifyFlag );
        }

    // resource for cache
    // /deny causes a switch to /Oicf. This code will not be executed
    if ( fHasDeny )
        {
        GenNdrCorrRes( pAna );
        }

    //
    // Check for by-value [in] structures and unions.  We must allocate 
    // a local which is a pointer to the same type for these.
    //
    // Also check for arrays so I can put a hack in until we get their
    // allocation figured out.
    //

	if( GetMembers( ParamList ) )
		{
		CG_PARAM	*	pParam;
		node_skl	*	pType;

		while( ITERATOR_GETNEXT( ParamList, pParam ) )
			{
			pType = pParam->GetType();

            CG_NDR * pChild = (CG_NDR *)pParam->GetChild();
            ID_CG ChildID = pChild->GetCGID();

            if ( ChildID == ID_CG_GENERIC_HDL )
                {
                pChild = (CG_NDR *)pChild->GetChild();
                ChildID = pChild->GetCGID();
                }

            //
            // If this is a by-value structure or union then we allocate a
            // local which is a pointer to the same type.
            //
			if ( pChild->IsStruct() || pChild->IsUnion()  ||
                 pChild->IsXmitRepOrUserMarshal()  )
				{
				char *		pName;
				node_id *	pLocalType;
				char *		pPlainName = pType->GetSymName();

				pName = new char[strlen( pPlainName ) + 10];

				strcpy( pName, LOCAL_NAME_POINTER_MANGLE );
				strcat( pName, (PNAME) pPlainName );

                pLocalType = MakePtrIDNodeFromTypeName( pName,
                                                        "void",
                                                        0 );
				pAna->AddLocalResource( pName,
										(node_skl *) pLocalType );
				}
			}
		}
}
/****************************************************************************
 utility fns
 ****************************************************************************/
node_id *
MakeIDNode(
    PNAME       pName,
    node_skl *  pType,
    expr_node * pExpr )
	{
	node_id * pID = new node_id( (char *)pName );
	pID->SetBasicType( pType );
	pID->SetEdgeType( EDGE_USE );
    pID->SetExpr( pExpr );
	return pID;
	}

node_id *
MakePtrIDNode(
	PNAME	pName,
    node_skl *  pType,
    expr_node * pExpr )
	{
	node_id * pID = new node_id( (char *)pName );
	node_pointer * pP = new node_pointer();
	pP->SetBasicType( pType );
	pP->SetEdgeType( EDGE_USE );
	pID->SetBasicType( pP );
	pID->SetEdgeType( EDGE_USE );
    pID->SetExpr( pExpr );
	return pID;
	}

node_id *
MakePtrIDNodeWithCastedExpr(
	PNAME	pName,
    node_skl *  pType,
    expr_node * pExpr )
	{
	node_id * pID = new node_id( (char *)pName );
	node_pointer * pP = new node_pointer();
	pP->SetBasicType( pType );
	pP->SetEdgeType( EDGE_USE );
	pID->SetBasicType( pP );
	pID->SetEdgeType( EDGE_USE );
    expr_cast * pCast = new expr_cast( pP, pExpr );
    pID->SetExpr( pCast );
	return pID;
	}

node_id *
MakeIDNodeFromTypeName(
	PNAME	pName,
	PNAME	pTypeName,
    expr_node * pExpr )
	{
	node_id	*	pID	= new node_id( pName );
	node_def * pDef = new node_def(pTypeName);
	pID->SetBasicType( pDef );
	pID->SetEdgeType( EDGE_USE );
    pID->SetExpr( pExpr );
	return pID;
	}

node_id *
MakePtrIDNodeFromTypeName(
	PNAME	pName,
	PNAME	pTypeName,
    expr_node * pExpr )
	{
	node_id	*	pID	= new node_id( pName );
	node_def * pDef = new node_def(pTypeName);
	node_pointer * pPtr = new node_pointer();
	pPtr->SetBasicType( pDef );
	pPtr->SetEdgeType( EDGE_USE );
	pID->SetBasicType( pPtr );
	pID->SetEdgeType( EDGE_USE );
    pID->SetExpr( pExpr );
	return pID;
	}

node_id *
MakePtrIDNodeFromTypeNameWithCastedExpr(
	PNAME	pName,
	PNAME	pTypeName,
    expr_node * pExpr )
	{
	node_id	*	pID	= new node_id( pName );
	node_def * pDef = new node_def(pTypeName);
	node_pointer * pPtr = new node_pointer();
	pPtr->SetBasicType( pDef );
	pPtr->SetEdgeType( EDGE_USE );
	pID->SetBasicType( pPtr );
	pID->SetEdgeType( EDGE_USE );
    expr_cast * pCast = new expr_cast( pPtr, pExpr );
    pID->SetExpr( pCast );
	return pID;
	}

node_param *
MakeParamNode(
	PNAME	pName,
	node_skl * pType )
	{
	node_param * pID = new node_param();
	pID->SetSymName( pName );
	pID->SetBasicType( pType );
	pID->SetEdgeType( EDGE_USE );
	return pID;
	}

node_param *
MakePtrParamNode(
	PNAME	pName,
	node_skl * pType )
	{
	node_param * pID = new node_param( );
	node_pointer * pP = new node_pointer();
	pID->SetSymName( pName );
	pP->SetBasicType( pType );
	pP->SetEdgeType( EDGE_USE );
	pID->SetBasicType( pP );
	pID->SetEdgeType( EDGE_USE );

	return pID;
	}
node_param *
MakeParamNodeFromTypeName(
	PNAME	pName,
	PNAME	pTypeName )
	{
	node_param	*	pID	= new node_param();
	node_def * pDef = new node_def(pTypeName);
	pID->SetSymName( pName );
	pID->SetBasicType( pDef );
	pID->SetEdgeType( EDGE_USE );
	return pID;
	}
node_param *
MakePtrParamNodeFromTypeName(
	PNAME	pName,
	PNAME	pTypeName )
	{
	node_param	*	pID	= new node_param();
	node_def * pDef = new node_def(pTypeName);
	node_pointer * pPtr = new node_pointer();
	pID->SetSymName( pName );
	pPtr->SetBasicType( pDef );
	pPtr->SetEdgeType( EDGE_USE );
	pID->SetBasicType( pPtr );
	pID->SetEdgeType( EDGE_USE );
	return pID;
	}

node_proc *	MakeProcNodeWithNewName( 
	PNAME 			pName,
	node_proc *		pProc )
	{
	node_proc	*	pNewProc	= new node_proc( pProc );

	pNewProc->SetSymName( pName );
	return pNewProc;
	}

void
GenNdrCorrRes   (
                ANALYSIS_INFO*  pAna
                )
    {
    node_id*        pCacheType  = new node_id( NDR_CORR_CACHE_VAR_NAME );
    expr_node*      pExpr       = new expr_constant( unsigned long( NDR_CORR_CACHE_SIZE ) );
    node_array*     pArray      = new node_array( 0, pExpr );
    node_base_type* pBaseType   = new node_base_type( NODE_LONG, ATTR_UNSIGNED );

    pBaseType->SetSymName( "long" );
    pArray->SetBasicType( pBaseType );
    pArray->SetEdgeType( EDGE_USE );
    pCacheType->SetBasicType( pArray );
    pCacheType->SetEdgeType( EDGE_USE );

    pAna->AddLocalResource( NDR_CORR_CACHE_VAR_NAME, pCacheType );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\sdesc.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	sdesc.cxx

 Abstract:

	stub descriptor manager implementation.

 Notes:


 History:

 	Nov-02-1993		VibhasC		Created

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

SDESC *
SDESCMGR::Register(
	PNAME		AllocRtnName,
	PNAME		FreeRtnName,
	PNAME		RundownRtnName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	The constructor.

 Arguments:
	
	AllocRtnName	- The allocator rtn name.
	FreeRtnName		- Free rtn name
	InterfaceName	- interface name without any mangling.
	RundownRtnName	- The context handle rundown in case necessary.

 Return Value:
	
	NA

 Notes:

	Make an entry into the dictionary if it does not exist.
----------------------------------------------------------------------------*/
{
	SDESC		NewDesc;
	SDESC	*	pNewDesc;
	Dict_Status	Status;

	NewDesc.AllocRtnName	= AllocRtnName;
	NewDesc.FreeRtnName		= FreeRtnName;
	NewDesc.RundownRtnName	= RundownRtnName;

	Status	= Dict_Find( &NewDesc );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:

			pNewDesc	= new SDESC;
			pNewDesc->AllocRtnName		= AllocRtnName;
			pNewDesc->FreeRtnName		= FreeRtnName;
			pNewDesc->RundownRtnName	= RundownRtnName;
			pNewDesc->ResetEmitted();

			Dict_Insert( (pUserType)pNewDesc );
			return pNewDesc;

		default:
			return (SDESC *)Dict_Curr_Item();

		}
}

SSIZE_T
SDESCMGR::Compare(
	pUserType	pFirst,
	pUserType	pSecond )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Compare stub descriptors.

 Arguments:

 	pFirst	- A pointer to the first stub descriptor.
 	pSecond	- A pointer to the second stub descriptor.
	
 Return Value:
	
 Notes:

	WE MAKE AN ASSUMPTION THAT THE ALLOC AND FREE AND RUNDOWN ROUTINE NAMES
	WILL NEVER BE NULL POINTERS. IF NOTHING, THEY MUST POINT TO NULL STRINGS
----------------------------------------------------------------------------*/
{
	SDESC	*	p1	= (SDESC *)pFirst;
	SDESC	*	p2	= (SDESC *)pSecond;
	int			Result;

	if( (Result = strcmp( (const char *)p1->AllocRtnName,
						 (const char *)p2->AllocRtnName ) ) == 0 )
		{
		if( (Result = strcmp( (const char *)p1->FreeRtnName,
						 	  (const char *)p2->FreeRtnName ) ) == 0 )
			{
			Result = strcmp( (const char *)p1->RundownRtnName,
						 	 (const char *)p2->RundownRtnName ); 
			}
		}

	return Result;
}
void
PrintSDesc( void * ) { }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\stgen.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	stgen.cxx

 Abstract:

	structure marshalling / unmarshalling stuff.

 Notes:


 History:

 	Dec-15-1993		VibhasC		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

CG_STATUS
CG_COMP::S_GenInitOutLocals(
	CCB		*	pCCB )
	{

	char Buffer[ 256 ];
	RESOURCE * pResource;
	PNAME		p;
	CG_NDR	*	pLPC = pCCB->GetLastPlaceholderClass();

	sprintf( Buffer, "%s", pLPC->GetType()->GetSymName() );

	p = pCCB->GenTRNameOffLastParam( Buffer );

	pResource = pCCB->GetLocalResource( p );

	// There is a pointer for the top level structure.

	Out_Assign( pCCB,
				pCCB->GetSourceExpression(),
				MakeAddressExpressionNoMatterWhat( pResource )
			  );

	// Go zero out the pointers in the structure, for now.

	if( HasPointer() )
		{
		ITERATOR	I;
		CG_FIELD	*	pCG;
		expr_node	*	pSrc = pCCB->GetSourceExpression();

		// Get all the members in the struct which contain pointers. If the
		// structure has been unrolled by the format string generator, the 
		// print prefix contains the proper prefixed part of the unrolled path,
		// we just have to add the field name to it.

		GetPointerMembers( I );

		while( ITERATOR_GETNEXT( I, pCG ) )
			{
			char * pVarName =
                     new char[ strlen( ((CG_FIELD *)pCG)->GetPrintPrefix())+
                               strlen( pCG->GetType()->GetSymName())       +
                               1
                             ];

			strcpy( pVarName, ((CG_FIELD *)pCG)->GetPrintPrefix() );
            strcat( pVarName, pCG->GetType()->GetSymName() );

			expr_node * pExpr = new expr_pointsto(
											 pSrc,
											 new expr_variable( pVarName, 0 ));
			expr_node * pAss = new expr_assign(pExpr, new expr_constant(0L));

			pCCB->GetStream()->NewLine();
			pAss->PrintCall( pCCB->GetStream(), 0, 0 );
			pCCB->GetStream()->Write(';');

			// this memory area is no longer useful.
			delete pVarName;
			}


		}

	return CG_OK;
	}

short
CG_COMP::GetPointerMembers(
	ITERATOR&	I )
	{
	CG_ITERATOR	M;
	CG_FIELD	*	pField;
	short		Count = 0;

	if( HasPointer() )
		{
		GetMembers( M );

		while( ITERATOR_GETNEXT( M, pField ) )
			{
			if( pField->GetChild()->IsPointer() )
				{
				ITERATOR_INSERT( I, pField );
				Count++;
				}
			}
		}
	return Count;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\stcls.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    stcls.cxx

 Abstract:

    Implementation of offline methods for the structure code generation
    classes.

 Notes:

 History:

    Oct-1993	DKays		Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

CG_ARRAY *
CG_CONFORMANT_STRUCT::GetConformantArray()
/*++

Routine Description :

	Gets the conformant (varying/string) class pointer for a conformant
	structure.

Arguments :

	None.

 --*/
{
	CG_NDR *	pConf;
	
	if ( ! pConfFld )
		return 0;

	pConf = (CG_NDR *) pConfFld->GetChild();

	for (;;) 
		{
		if ( pConf->GetCGID() == ID_CG_CONF_ARRAY ||
			 pConf->GetCGID() == ID_CG_CONF_VAR_ARRAY ||
			 pConf->GetCGID() == ID_CG_CONF_STRING_ARRAY )
			break;

        if ( pConf->IsXmitRepOrUserMarshal() )
            {
            pConf = (CG_NDR *)pConf->GetChild();
            continue;
            }

		// else
		pConf = (CG_NDR *) 
				((CG_CONFORMANT_STRUCT *)pConf)->GetConformantField();
		pConf = (CG_NDR *) pConf->GetChild();
		}

	return (CG_ARRAY *) pConf;
}

BOOL
CG_COMPLEX_STRUCT::WarnAboutEmbeddedComplexStruct()
/*
    The only reason we have this method is to help with an engine bug.
    The bug is that for complex structs (FC_BOGUS_STRUCT code) that have an
    embedded conformant struct, the engine marshals incorrect wire format.

    Hence this method checks if the complex struct has an open array at the end,
    and if so, checks if the last member is another type of struct.
*/
{
    BOOL    HasIt = FALSE;
    
    if ( GetConformantArray() )
        {
        //
        // Get the last field.
        //
    	CG_ITERATOR	Iterator;
    	CG_FIELD *	pField;
        CG_NDR *    pNdr;

    	GetMembers( Iterator );

        while ( ITERATOR_GETNEXT( Iterator, pField ) )
        	;
        
        pNdr = (CG_NDR *) pField->GetChild();
        
        if ( pNdr->IsStruct() )
            {
            HasIt = TRUE;

            char * pSymName, * pEmbeddedName, * pNameContext;

            pSymName      = GetSymName()       ? GetSymName()       : "?";
            pEmbeddedName = pNdr->GetSymName() ? pNdr->GetSymName() : "?";

            size_t len = strlen( pSymName ) + strlen( pEmbeddedName ) + 20;

            pNameContext = new char[ len ];
            strcpy( pNameContext, pSymName );
            strcat( pNameContext, " embedding " );
            strcat( pNameContext, pEmbeddedName );

            if ( !pCommand->Is64BitEnv() )
                RpcError(NULL, 0, EMBEDDED_OPEN_STRUCT, pNameContext );
            }
        }

    return HasIt;
}

CG_FIELD *
CG_STRUCT::GetFinalField()
{
	CG_ITERATOR	Iterator;
	CG_FIELD *	pField;
    CG_NDR *    pNdr;

	GetMembers( Iterator );

	//
	// Get the last field.
	//
	while ( ITERATOR_GETNEXT( Iterator, pField ) )
		;

    pNdr = (CG_NDR *) pField->GetChild();

    if ( pNdr->IsStruct() )
        pField = ((CG_STRUCT *)pNdr)->GetFinalField();

    return pField;
}

CG_FIELD *
CG_STRUCT::GetArrayField( CG_ARRAY * pArray )
{
      CG_ITERATOR        Iterator;
      CG_FIELD *      pField;
    CG_NDR *    pNdr;

      GetMembers( Iterator );

      while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        pNdr = (CG_NDR *) pField->GetChild();

        if ( pNdr == pArray )
            return pField;

        //
        // Search inside of other structs only.
        //
        if ( pNdr->IsStruct() )
            {
            if ( (pField = ((CG_STRUCT *)pNdr)->GetArrayField(pArray)) != 0 )
                return pField;
            }
        }

    // Didn't find it.
    return 0;
}

BOOL
CG_STRUCT::IsHardStruct()
{
    // REVIEW: The previous comment implied that we we're going to do something
    //         else "after the PPC update".  Is this still relevant?
    //         -- MikeW 16-Jul-99

    return FALSE;
}

BOOL
CG_STRUCT::IsHardStructOld()
{
	CG_ITERATOR	Iterator;
	CG_FIELD *	pField;
	CG_FIELD *	pPrevField;

    //
    // Cannot have a conformant array of any kind.
    //
    if ( (GetCGID() == ID_CG_CONF_STRUCT) ||
         (GetCGID() == ID_CG_CONF_VAR_STRUCT) )
        return FALSE;

    // 
    // Cannot have pointers.
    //
    if ( HasPointer() ) 
        return FALSE;

    //
    // Can't have more than one enum16.
    //
    if ( GetNumberOfEnum16s() > 1 )
        return FALSE;

    //
    // Can't have padding in the middle of the struct that differs in 
    // memory and on the wire.
    //
	GetMembers( Iterator );

    pPrevField = 0;

	//
	// Get the last field.
	//
	while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        if ( pField->GetSibling() )
		    pPrevField = pField;
        }

    //
    // Check if the last field in the struct has a different memory and wire
    // offset.  However, if there is a single union as the last field then 
    // we have to check the second to last fields's mem and wire offsets 
    // instead since a union's field's wire offsets are not accurate.
    //
    if ( pField->GetChild()->IsUnion() && pPrevField )
        pField = pPrevField;

    // This is complex.
	if ( pField->GetMemOffset() != pField->GetWireOffset() )
        return FALSE;

    //
    // Can have at most one union as the last field only.
    //
    switch ( GetNumberOfUnions() ) 
        {
        case 0 :
            break;
        case 1 : 
            //
            // The last field must be the union.
            //
            if ( ! GetFinalField()->GetChild()->IsUnion() )
                return FALSE;
            else
                return TRUE;
            break;
        default :
            return FALSE;
        }

    //
    // Now check again if we have just one enum16.
    //
    if ( GetNumberOfEnum16s() == 1 )
        return TRUE;

    // 
    // Check for end padding, which is ok for a hard struct.
    //
    if ( GetMemorySize() > GetWireSize() )
        return TRUE;

    //
    // It must be a nice struct.
    //
    return FALSE;
}

BOOL
CG_STRUCT::HasAFixedBufferSize()
{
    CG_ITERATOR	Iterator;
	CG_FIELD *	pField;
	
	GetMembers( Iterator );
    
    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        if ( !pField->HasAFixedBufferSize() )
		    return FALSE;
        }
    return TRUE;
}

BOOL
CG_STRUCT::IsComplexStruct()
{
    CG_ITERATOR	Iterator;
	CG_FIELD *	pField;
    CG_NDR *    pNdr;
    BOOL        IsConformant;

    IsConformant = (GetCGID() == ID_CG_CONF_STRUCT) ||
                   (GetCGID() == ID_CG_CONF_VAR_STRUCT);

    switch ( GetNumberOfEnum16s() ) 
        {
        case 0 :
            break;
        case 1 : 
            if ( HasPointer() || IsConformant ) 
                return TRUE;
            break;
        default :
            return TRUE;
        }

    switch ( GetNumberOfUnions() ) 
        {
        case 0 : 
            break;
        case 1 : 
            if ( ! GetFinalField()->GetChild()->IsUnion() || 
                 HasPointer() ||
                 IsConformant )
                return TRUE;
            break;
        default :
            return TRUE;
        }

    if ( (GetMemorySize() > GetWireSize()) && (HasPointer() || IsConformant) )
        return TRUE;

    GetMembers( Iterator );

    //
    // Check if there are any embedded structs or arrays which are 
    // complex.
    // On 64b platforms any pointer makes it complex as well.
    //
	while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        pNdr = (CG_NDR *) pField->GetChild();

        if ( pNdr->IsArray() && ((CG_ARRAY *)pNdr)->IsComplex() ) 
            return TRUE;
            
        if ( pNdr->IsStruct() && ((CG_STRUCT *)pNdr)->IsComplexStruct() ) 
            return TRUE;

        // struct fields with [range] on them make the struct complex.
        if ( pNdr->GetRangeAttribute() )
            return TRUE;

        //if ( pNdr->IsPointer()  &&  pCommand->Is64BitEnv() )
        //    return TRUE;

        if ( ( pField->GetWireOffset() != pField->GetMemOffset() ) ||
             ( pField->GetWireSize() != pField->GetMemorySize() ) )
            return TRUE;

        }

    return IsHardStructOld();
}

bool
CG_STRUCT::IsHomogeneous(FORMAT_CHARACTER format)
{
    CG_ITERATOR Iterator;
    CG_FIELD   *pField;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pField ))
        {
        CG_NDR *pChild = (CG_NDR *) pField->GetChild();

        if ( !pChild->IsHomogeneous( format ) )
            return false;
        }

    return true;
}

long
CG_STRUCT::GetNumberOfPointers()
{
    CG_ITERATOR		Iterator;
    CG_FIELD *      pField;
    CG_NDR *        pMember;
	long			Count;

	Count = 0;

	GetMembers(Iterator);

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
    	{
        pMember = (CG_NDR *) pField->GetChild();

        if ( pMember->IsPointer() && 
             !pMember->IsInterfacePointer() )
            Count++;

		if ( pMember->IsStruct() )
			Count += ((CG_STRUCT *)pMember)->GetNumberOfPointers();
		}

	return Count;
}

long
CG_STRUCT::GetNumberOfEnum16s()
{
    CG_ITERATOR		Iterator;
    CG_FIELD *      pField;
    CG_NDR *        pNdr;
	long			Count;
    long            Weight;

	Count = 0;

	GetMembers(Iterator);

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
    	{
        pNdr = (CG_NDR *) pField->GetChild();

        //
        // If an array contains a enum16 we count it as 100 enum16s, since
        // this routine is only interested in small enum16 counts.
        //
        if ( pNdr->IsArray() )
            {
            pNdr = (CG_NDR *) pNdr->GetChild();

            while ( pNdr->IsArray() )
                pNdr = (CG_NDR *) pNdr->GetChild();

            Weight = 100;
            }
        else
            Weight = 1;

        if ( pNdr->IsSimpleType() && 
             (((CG_BASETYPE *)pNdr)->GetFormatChar() == FC_ENUM16) )
            Count += Weight;

		if ( pNdr->IsStruct() )
			Count += Weight * ((CG_STRUCT *)pNdr)->GetNumberOfEnum16s();
		}

	return Count;
}

long
CG_STRUCT::GetNumberOfUnions()
{
    CG_ITERATOR		Iterator;
    CG_FIELD *      pField;
    CG_NDR *        pNdr;
	long			Count;
    long            Weight;

	Count = 0;

	GetMembers(Iterator);

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
    	{
        pNdr = (CG_NDR *) pField->GetChild();

        //
        // If an array contains a union we count it as 100 unions, since
        // this routine is only interested in small union counts.
        //
        if ( pNdr->IsArray() )
            {
            pNdr = (CG_NDR *) pNdr->GetChild();

            while ( pNdr->IsArray() )
                pNdr = (CG_NDR *) pNdr->GetChild();

            Weight = 100;
            }
        else
            Weight = 1;

        if ( (pNdr->GetCGID() == ID_CG_UNION) ||
             (pNdr->GetCGID() == ID_CG_ENCAP_STRUCT) ) 
            Count += Weight;

		if ( pNdr->IsStruct() )
			Count += Weight * ((CG_STRUCT *)pNdr)->GetNumberOfUnions();
		}

	return Count;
}

long
CG_STRUCT::GetEnum16Offset()
{
    CG_ITERATOR	Iterator;
    CG_FIELD *  pField;
    CG_NDR *    pNdr;

    MIDL_ASSERT( GetNumberOfEnum16s() == 1 );

    GetMembers( Iterator );

    //
    // Search for the enum.  
    //
    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        pNdr = (CG_NDR *) pField->GetChild();

        if ( pNdr->IsSimpleType() && 
             (((CG_BASETYPE *)pNdr)->GetFormatChar() == FC_ENUM16) )
            return pField->GetMemOffset();

        if ( pNdr->IsStruct() && 
             (((CG_STRUCT *)pNdr)->GetNumberOfEnum16s() == 1) )
            return pField->GetMemOffset() + 
                   ((CG_STRUCT *)pNdr)->GetEnum16Offset();
        }

    // Never get here.
    return 0;
}

void
CloneForUnrolling(
    CG_NDR * pParent,
    CG_NDR * pNdr )
/*
    This routine will clone pNdr and overwrite the original child at
    the parent if needed.
    It is assumed the parent has been cloned, too.
*/
{
    CG_POINTER *    pNewPointer;

    pNewPointer = 0;

    if ( pNdr->IsPointer() )
        {
        switch ( pNdr->GetCGID() ) 
            {
            case ID_CG_PTR :
                pNewPointer = new CG_POINTER( 
                                   (CG_POINTER *) pNdr );
                break;
            case ID_CG_BC_PTR :
                pNewPointer = new CG_BYTE_COUNT_POINTER( 
                                   (CG_BYTE_COUNT_POINTER *) pNdr );
                break;
            case ID_CG_STRING_PTR :
            case ID_CG_STRUCT_STRING_PTR :
                pNewPointer = new CG_STRING_POINTER( 
                                   (CG_STRING_POINTER *) pNdr );
                break;
            case ID_CG_SIZE_PTR :
                pNewPointer = new CG_SIZE_POINTER( 
                                   (CG_SIZE_POINTER *) pNdr );
                break;
            case ID_CG_LENGTH_PTR :
                pNewPointer = new CG_LENGTH_POINTER( 
                                (CG_LENGTH_POINTER *) pNdr );
                break;
            case ID_CG_SIZE_LENGTH_PTR :
                pNewPointer = new CG_SIZE_LENGTH_POINTER( 
                                (CG_SIZE_LENGTH_POINTER *) pNdr );
                break;
            case ID_CG_SIZE_STRING_PTR :
                pNewPointer = new CG_SIZE_STRING_POINTER( 
                                (CG_SIZE_STRING_POINTER *) pNdr );
                break;
            case ID_CG_INTERFACE_PTR :
                pNewPointer = new CG_INTERFACE_POINTER( 
                                   (CG_INTERFACE_POINTER *) pNdr );
                break;
            case ID_CG_IIDIS_INTERFACE_PTR :
                pNewPointer = new CG_IIDIS_INTERFACE_POINTER( 
                                   (CG_IIDIS_INTERFACE_POINTER *) pNdr );
                break;
            default :
                break;
            }

        if ( pNewPointer )
            {
            //
            // We have to re-set the new pointer's format string offset and 
            // pointee format string offset to -1 so that we get a new 
            // description!!!
            //
    
            if ( pNewPointer )
    
            pNewPointer->SetFormatStringOffset( -1 );
            pNewPointer->SetPointeeFormatStringOffset( -1 );
        
            pParent->SetChild( pNewPointer );
    
            if ( pNdr->GetChild() )
                CloneForUnrolling( pNewPointer, (CG_NDR*) pNdr->GetChild() );
            }
        }
}


void
CG_STRUCT::Unroll()
{
	ITERATOR		Iterator;
	CG_FIELD *		pPrevField;
	CG_FIELD *		pField;
	CG_NDR *		pNdr;
	CG_STRUCT *		pStruct;
	
	GetMembers( Iterator );

	pPrevField = 0;

	while ( ITERATOR_GETNEXT(Iterator,pField) )
		{
		pNdr = (CG_NDR *) pField->GetChild();

		if ( pNdr->IsStruct() && ((CG_STRUCT *)pNdr)->HasSizedPointer() )
			pStruct = (CG_STRUCT *) pNdr;
		else
			{
			pPrevField = pField;
			continue;
			}

		//
		// First force the embeded struct to unroll if needed.
		//
		pStruct->Unroll();

		ITERATOR	IteratorEmbeded;
		CG_FIELD *	pFieldNew;
		CG_FIELD *	pFieldEmbeded;
		CG_FIELD *	pFieldList;
		long		MemOffsetStart;
		long		WireOffsetStart;

		pStruct->GetMembers( IteratorEmbeded );

		MemOffsetStart = pField->GetMemOffset();
		WireOffsetStart = pField->GetWireOffset();

		// Get previous field node.
		pFieldList = pPrevField;

		// Remove current struct field node from the list.
		if ( pFieldList ) 
			pFieldList->SetSibling( pField->GetSibling() );
		else
			this->SetChild( pField->GetSibling() );

		// To be safe.
		pField->SetSibling( 0 );

        while ( ITERATOR_GETNEXT(IteratorEmbeded,pFieldEmbeded) )
            {
            pFieldNew = (CG_FIELD *) pFieldEmbeded->Clone();

            pNdr = (CG_NDR *) pFieldEmbeded->GetChild();

            CloneForUnrolling( pFieldNew, pNdr );

            //
            // Set the new field's memory and wire offset.
            //
            pFieldNew->SetMemOffset( pFieldEmbeded->GetMemOffset() + 
                                       MemOffsetStart );
            pFieldNew->SetWireOffset( pFieldEmbeded->GetWireOffset() + 
                                        WireOffsetStart );

            //    
            // Now add the imbeded struct's field name to the PrintPrefix of 
            // the new unrolled field.  We ask the imbeded struct's field 
            // for it's name.
            //
            pFieldNew->AddPrintPrefix( pField->GetType()->GetSymName() );

            if ( pFieldList )
                {
                pFieldNew->SetSibling( pFieldList->GetSibling() );
                pFieldList->SetSibling( pFieldNew );
                }
            else
                {
                pFieldNew->SetSibling( this->GetChild() );
                this->SetChild( pFieldNew );
                }

            pFieldList = pFieldNew;
            }

		//
		// Set pPrevField equal to the last field node that we entered into
		// the list.  The outermost Iterator only knows about fields that 
		// started in the struct's field list, so the last field node we
		// added will have a sibling equal to the next field node we'll get
		// from the outer iterator.
		//
		pPrevField = pFieldNew;
		}
}

BOOL
CG_STRUCT::HasSizedPointer()
{
	CG_ITERATOR	Iterator;
	CG_FIELD *	pField;
	CG_NDR *	pNdr;
	
	GetMembers( Iterator );

	while ( ITERATOR_GETNEXT(Iterator,pField) )
		{
		pNdr = (CG_NDR *) pField->GetChild();

        if ( pNdr->IsStruct() && ((CG_STRUCT *)pNdr)->HasSizedPointer() )
            return TRUE;

		if ( (pNdr->GetCGID() == ID_CG_SIZE_PTR) ||
			 (pNdr->GetCGID() == ID_CG_SIZE_LENGTH_PTR) ||
			 (pNdr->GetCGID() == ID_CG_SIZE_STRING_PTR) )
			return TRUE;
		}

	return FALSE;
}

BOOL                    
CG_ENCAPSULATED_STRUCT::ShouldFreeOffline()
{
    CG_UNION * pUnion;

    pUnion = (CG_UNION *) GetChild()->GetSibling()->GetChild();

    return pUnion->HasPointer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\stndr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1993-1999 Microsoft Corporation

 Module Name:

    stndr.hxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    structure types, and the new NDR marshalling and unmarshalling calls.

 Notes:


 History:

    DKays     Oct-1993     Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

void
CG_STRUCT::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a simple, conformant,
    or conformant varying structure.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING *     pFormatString;
    CG_NDR *            pOldCGNodeContext;
    CG_NDR *            pConformantArray;

    if ( GetFormatStringOffset() != -1 )
        return;

    //
    // Check if this structure is "complex".
    //
    if ( IsComplexStruct() )
        {
        GenNdrFormatComplex( pCCB );
        return;
        }

    //
    // Check if the structure is "hard".
    //
    if ( IsHardStruct() )
        {
        GenNdrFormatHard( pCCB );
        return;
        }

    Unroll();

    //
    // Temporarily set the format string offset to 0 in case this structure
    // has pointers to it's own type.
    //
    SetFormatStringOffset( 0 );
    SetInitialOffset(      0 );

    CG_FIELD *pOldRegionField = NULL;
#if defined(NDR64_ON_DCE_HACK)
    if ( NULL != dynamic_cast<CG_REGION*>( this ) )
        {
        pOldRegionField = pCCB->StartRegion();
        }
    else
#endif
    pOldCGNodeContext = pCCB->SetCGNodeContext( this );

    pFormatString = pCCB->GetFormatString();


    //
    // Search the fields of the structure for embedded structures and generate
    // the format string for these.
    //
    CG_ITERATOR     Iterator;
    CG_FIELD *      pField;
    CG_NDR *        pMember;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        CG_NDR * pOldPlaceholder;

        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pField );

        pMember = (CG_NDR *) pField->GetChild();

        //
        // If there is a structure or array member then generate
        // it's format string.  We don't have to check for a union, because
        // that will make the struct CG_COMPLEX_STRUCT.
        //
        if ( pMember->IsStruct() || pMember->IsArray() )
            pMember->GenNdrFormat( pCCB );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    //
    // If this is a conformant (varying) struct then generate the array's
    // description.
    //
    if ( GetCGID() == ID_CG_CONF_STRUCT ||
         GetCGID() == ID_CG_CONF_VAR_STRUCT )
        {
        CG_NDR * pOldPlaceholder;

        pOldPlaceholder =
            pCCB->SetLastPlaceholderClass(
              (CG_NDR *) ((CG_CONFORMANT_STRUCT *)this)->GetConformantField() );

        // Get the conformant array CG class.
        pConformantArray = (CG_NDR *)
                           ((CG_CONFORMANT_STRUCT *)this)->GetConformantArray();

        // Generate the format string for the array.
        pConformantArray->GenNdrFormat( pCCB );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    //
    // If there are pointers in the structure then before you can start
    // generating the format string for the structure, you must generate
    // the format string for all of the pointees.
    //
    if ( HasPointer() )
        {
        GenNdrStructurePointees( pCCB );
        }

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );
    SetInitialOffset(      pFormatString->GetCurrentOffset() );


    switch ( GetCGID() )
        {
        case ID_CG_STRUCT :
            pFormatString->PushFormatChar( HasPointer() ?
                                           FC_PSTRUCT : FC_STRUCT );
            break;

        case ID_CG_CONF_STRUCT :
            pFormatString->PushFormatChar( HasPointer() ?
                                           FC_CPSTRUCT : FC_CSTRUCT );
            break;

        case ID_CG_CONF_VAR_STRUCT :
            pFormatString->PushFormatChar( FC_CVSTRUCT );
            break;
        }

    // Set the alignment.
    pFormatString->PushByte( GetWireAlignment() - 1 );

    // Set the structure memory size.
    pFormatString->PushShort( (short)GetMemorySize() );

    //
    // If this is a conformant array then push the offset to the conformant
    // array's description.
    //
    if ( GetCGID() == ID_CG_CONF_STRUCT ||
         GetCGID() == ID_CG_CONF_VAR_STRUCT )
        {
        // Set the offset to the array description.
        pFormatString->PushShortOffset( pConformantArray->GetFormatStringOffset() -
                                          pFormatString->GetCurrentOffset() );
        }

    // Generate the pointer layout if needed.
    if ( HasPointer() )
        {
        GenNdrStructurePointerLayout( pCCB, FALSE, FALSE );
        }

    // Now generate the layout.
    GenNdrStructureLayout( pCCB );

    //
    // Now we have to fix up the offset for any recursive pointer to this
    // structure.
    //
    GenNdrPointerFixUp( pCCB, this );

#if defined(NDR64_ON_DCE_HACK)
    if ( NULL != dynamic_cast<CG_REGION*>( this ) )
        {
        pCCB->EndRegion(pOldRegionField);
        }
    else
#endif
    pCCB->SetCGNodeContext( pOldCGNodeContext );

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
    pFormatString->OptimizeFragment( this );
    SetInitialOffset( GetFormatStringOffset() );

    FixupEmbeddedComplex( pCCB );

    if ( GetDuplicatingComplex() )
        GetDuplicatingComplex()->FixupEmbeddedComplex( pCCB );
}

void
CG_STRUCT::GenNdrFormatHard( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a packed structure.  The
    description has the same format as for a complex struct.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING * pFormatString;
    CG_NDR *        pOldCGNodeContext;
    CG_NDR *        pUnion;
    CG_FIELD *      pFinalField;
    long            CopySize;
    long            MemoryIncrement;

    if ( GetFormatStringOffset() != -1 )
        return;

    //
    // Temporarily set the format string offset to 0 in case this structure
    // has pointers to it's own type.
    //
    SetFormatStringOffset( 0 );
    SetInitialOffset(      0 );

    pOldCGNodeContext = pCCB->SetCGNodeContext( this );

    pFormatString = pCCB->GetFormatString();

    //
    // Search the fields of the structure for embedded structures and generate
    // the format string for these.
    //
    CG_ITERATOR     Iterator;
    CG_FIELD *      pField;
    CG_NDR *        pMember;
    CG_NDR *        pOldPlaceholder;

    GetMembers( Iterator );

    pOldPlaceholder = pCCB->GetLastPlaceholderClass();

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        pMember = (CG_NDR *) pField->GetChild();

        //
        // If there is an embedded structure, array, or union then generate
        // it's format string.
        //
        if ( pMember->IsStruct() || pMember->IsArray() || pMember->IsUnion() )
            {
            pCCB->SetLastPlaceholderClass( pField );
            pMember->GenNdrFormat( pCCB );
            }
        }

    pCCB->SetLastPlaceholderClass( pOldPlaceholder );

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );
    SetInitialOffset(      pFormatString->GetCurrentOffset() );

    pFinalField = GetFinalField();

    //
    // See if we have a union.
    //
    if ( pFinalField->GetChild()->IsUnion() )
        pUnion = (CG_NDR *) pFinalField->GetChild();
    else
        pUnion = 0;

    //
    // Determine the copy size and memory increment for the copy.
    //
    if ( pUnion )
        {
        CG_STRUCT * pStruct;

        pStruct = this;
        CopySize = 0;

        for ( ;; )
            {
            pStruct->GetMembers( Iterator );

            while ( ITERATOR_GETNEXT( Iterator, pField ) )
                ;

            CopySize += pField->GetWireOffset();

            pMember = (CG_NDR *) pField->GetChild();

            if ( pMember->IsStruct() )
                {
                pStruct = (CG_STRUCT *) pMember;
                continue;
                }
            else
                break;
            }

        MemoryIncrement = GetMemorySize() - pUnion->GetMemorySize();
        }
    else
        {
        CopySize = GetWireSize();
        MemoryIncrement = GetMemorySize();
        }

    //
    // Format string generation.
    //

    pFormatString->PushFormatChar( FC_HARD_STRUCT );

    // The alignment.
    pFormatString->PushByte( GetWireAlignment() - 1 );

    // The structure's memory size.
    pFormatString->PushShort( (short)GetMemorySize() );

    // Reserved for future use.
    pFormatString->PushLong( 0 );

    //
    // Offset to enum in struct.
    //
    if ( GetNumberOfEnum16s() == 1 )
        pFormatString->PushShort( GetEnum16Offset() );
    else
        pFormatString->PushShort( (short) -1 );

    //
    // Copy size and memory increment.
    //
    pFormatString->PushShort( CopySize );
    pFormatString->PushShort( MemoryIncrement );

    //
    // Offset to union's format string description.
    //
    if ( pUnion )
        {
        pOldPlaceholder = pCCB->GetLastPlaceholderClass();
        pCCB->SetLastPlaceholderClass( pFinalField );

        pFormatString->PushShort( (short)
                                  (pUnion->GetFormatStringOffset() -
                                   pFormatString->GetCurrentOffset()) );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }
    else
        pFormatString->PushShort( (short) 0 );

    // Now generate the layout.
    GenNdrStructureLayout( pCCB );

    //
    // Now we have to fix up the offset for any recursive pointer to this
    // structure.
    //
    GenNdrPointerFixUp( pCCB, this );

    pCCB->SetCGNodeContext( pOldCGNodeContext );

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
    pFormatString->OptimizeFragment( this );
    SetInitialOffset( GetFormatStringOffset() );

    FixupEmbeddedComplex( pCCB );
}

void
CG_STRUCT::GenNdrFormatComplex( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a packed structure.  The
    description has the same format as for a complex struct.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    CG_CLASS *          pConfField;
    CG_COMPLEX_STRUCT * pComplex;

    if ( (GetCGID() == ID_CG_CONF_STRUCT) ||
         (GetCGID() == ID_CG_CONF_VAR_STRUCT) )
        pConfField = ((CG_CONFORMANT_STRUCT *)this)->GetConformantField();
    else
        pConfField = 0;

    //
    // Do the old duplication trick.
    //
    pComplex = new CG_COMPLEX_STRUCT( this, pConfField );

    SetDuplicatingComplex( pComplex );

    //
    // Now temporarily set our format string offset to 0 to handle recursive
    // definitions.
    //
    SetFormatStringOffset( 0 );
    SetInitialOffset(      0 );
                        
    //
    // This call will set our format string offset correctly.
    //
    pComplex->GenNdrFormat( pCCB );

    // Don't delete since the expression evaluator might need this.
    // delete( pComplex );
}


bool IsEnum16UnionAlignBug( CG_STRUCT *pStruct ) 
{

    // Comment from old hack wacked on stub.
    // The NT 3.50 stubs had a problem with union alignment that affects
    // structs with 16b enum and a union as the only other thing.
    // The old, incorrect alignment was 2 (code 1), the correct alignment is 4 (code 3).
    // All the compilers since NT 3.51, i.e. MIDL 2.0.102 generate correct code,
    // however we needed to introduce the wrong alignment into newly compiled stubs
    // to get interoperability with the released dhcp client and server binaries.
    
    if ( 4 != pStruct->GetWireAlignment())
        return false;

    CG_ITERATOR StructElements;
    pStruct->GetMembers( StructElements );

    ITERATOR_INIT( StructElements );
    size_t Elements = ITERATOR_GETCOUNT( StructElements );

    if ( 2 != Elements )
        return false;

    ITERATOR_INIT( StructElements );
    
    CG_FIELD *pField1 = NULL;
    ITERATOR_GETNEXT( StructElements, pField1 );
    MIDL_ASSERT( NULL != pField1);

    // Is the first field a enum16?
    CG_ENUM *pEnum = dynamic_cast<CG_ENUM*>( pField1->GetChild() );
    if ( ( NULL == pEnum ) || pEnum->IsEnumLong() )
        return false;

    // Is the second field a union
    CG_FIELD *pField2 = NULL;
    ITERATOR_GETNEXT( StructElements, pField2 );
    MIDL_ASSERT( NULL != pField2 );

    if ( ! pField2->GetChild()->IsUnion())
        return false;

    // Ok. We have a 2 field structure were the first field is an enum16 and the second field is
    // and union.
    return true;
}



void
CG_COMPLEX_STRUCT::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a complex structure.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING *     pFormatString;
    CG_NDR *            pOldCGNodeContext;
    CG_NDR *            pConformantArray;
    long                PointerLayoutOffset;

    if ( GetFormatStringOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    //
    // Temporarily set the format string offset to 0 in case this structure
    // has pointers to it's own type.
    //
    SetFormatStringOffset( 0 );
    SetInitialOffset(      0 );

    pOldCGNodeContext = pCCB->SetCGNodeContext( this );

    //
    // Search the fields of the structure for imbeded structures, arrays, and
    // and unions and generate the format string for these.
    //
    CG_ITERATOR     Iterator;
    CG_FIELD *      pField;
    CG_NDR *        pMember;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        pMember = (CG_NDR *) pField->GetChild();

        //
        // If the field is anything other than a base type or a
        // non-interface pointer then generate it's description.
        //
        if ( ! pMember->IsSimpleType() &&
             ! ( pMember->IsPointer() &&
                 !pMember->IsInterfacePointer() ) &&
             (pMember->GetCGID() != ID_CG_IGN_PTR) ||
             pMember->GetRangeAttribute() )
            {
            CG_NDR * pOldPlaceholder;

            pOldPlaceholder = pCCB->SetLastPlaceholderClass( pField );

            pMember->GenNdrFormat( pCCB );

            pCCB->SetLastPlaceholderClass( pOldPlaceholder );
            }
        }

    // Generate pointee format strings.
    GenNdrStructurePointees( pCCB );

    // Generate conformant array description.
    if ( ( pConformantArray = (CG_NDR *) GetConformantArray() ) != 0 )
        {
        CG_NDR * pOldPlaceholder;

        pOldPlaceholder = pCCB->SetLastPlaceholderClass(
                                (CG_NDR *) GetConformantField() );

        pConformantArray->GenNdrFormat( pCCB );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    // Now set the struct's format string offset.
    SetFormatStringOffset( pFormatString->GetCurrentOffset() );
    SetInitialOffset(      pFormatString->GetCurrentOffset() );

    //
    // Set the duplicated struct's format string offset if we were duplicated.
    //
    if ( GetDuplicatedStruct() )
        {
        GetDuplicatedStruct()->SetFormatStringOffset( GetFormatStringOffset() );
        GetDuplicatedStruct()->SetInitialOffset(      GetFormatStringOffset() );
        }

    pFormatString->PushFormatChar( FC_BOGUS_STRUCT );

    WarnAboutEmbeddedComplexStruct();

    //
    // Set the wire alignment.
    //
    if ( pCommand->WireCompat( WIRE_COMPAT_ENUM16UNIONALIGN ) &&
         IsEnum16UnionAlignBug(this) )
        {

        // Comment from old hack wacked on stub.
        // The NT 3.50 stubs had a problem with union alignment that affects
        // structs with 16b enum and a union as the only other thing.
        // The old, incorrect alignment was 2 (code 1), the correct alignment is 4 (code 3).
        // All the compilers since NT 3.51, i.e. MIDL 2.0.102 generate correct code,
        // however we needed to introduce the wrong alignment into newly compiled stubs
        // to get interoperability with the released dhcp client and server binaries.

        pFormatString->AddComment( pFormatString->GetCurrentOffset(), "/* 3 */ /* enum16unionalign Bug Compatibility */" );  
        pFormatString->PushByte( 1 );

        }
    else
        pFormatString->PushByte( GetWireAlignment() - 1 );

    // Set the structure memory size.
    pFormatString->PushShort( (short)GetMemorySize() );

    // Array description.
    if ( pConformantArray )
        pFormatString->PushShortOffset( pConformantArray->GetFormatStringOffset() -
                                          pFormatString->GetCurrentOffset() );
    else
        pFormatString->PushShort( (short) 0 );

    //
    // Remember where the offset_to_pointer_layout<> field will go and push
    // some space for it.
    //
    PointerLayoutOffset = pFormatString->GetCurrentOffset();

    pFormatString->PushShortOffset( 0 );

    // Now generate the structure's layout.
    GenNdrStructureLayout( pCCB );

    //
    // Now see if we have any plain pointer fields and if so generate a
    // pointer layout.  We can't use the HasAtLeastOnePointer() method
    // because this tells us TRUE if we have any embedded arrays, structs,
    // or unions which have pointers.  For complex structs we're only
    // interested in actual pointer fields.
    //
    GetMembers( Iterator );

    //
    // Fill in the offset_to_pointer_layout<2> field and generate a
    // pointer_layout<> if we have any pointer fields.  Interface pointers
    // do not reside in the pointer layout.
    //
    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        if ( pField->GetChild()->IsPointer() &&
             !pField->IsInterfacePointer() )
            {
            // This is an internal offset within the struct descriptor, namely
            // to the pointer layout field, not the offset to a type.

            // Surprisingly, this code may produce an offset to an array etc.
            // Hence, we push an offset to be backward compatible.

            pFormatString->PushShortOffset(
                pFormatString->GetCurrentOffset() - PointerLayoutOffset,
                PointerLayoutOffset );

            GenNdrStructurePointerLayout( pCCB );

            break;
            }

    pFormatString->Align();

    //
    // Now we have to fix up the offset for any recursive pointer to this
    // structure.
    //
    GenNdrPointerFixUp( pCCB, GetDuplicatedStruct() ? GetDuplicatedStruct() : this );

    pCCB->SetCGNodeContext( pOldCGNodeContext );

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
    pFormatString->OptimizeFragment( this );
    SetInitialOffset(      GetFormatStringOffset() );
    if ( GetDuplicatedStruct() )
        GetDuplicatedStruct()->SetFormatStringOffset( GetFormatStringOffset() );

    FixupEmbeddedComplex( pCCB );
    if ( GetDuplicatedStruct() )
        GetDuplicatedStruct()->FixupEmbeddedComplex( pCCB );

    // There is no call to the string optimizer here. If we wanted to put it in,
    // the code should check if the optimization is possible or not by checking the
    // result of GenNdrEmbeddedPointers via GenNdrStructurePointerLayout call.
}

void
CG_COMPLEX_STRUCT::GenNdrStructurePointerLayout( CCB * pCCB )
/*++

Routine Description :

    Generates the format string pointer layout section for a complex
    structure.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    CG_ITERATOR         Iterator;
    CG_FIELD *          pField;
    CG_NDR *            pMember;

    GetMembers( Iterator );

    while( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        CG_NDR *    pOldPlaceholder;
        
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pField );

        pMember = (CG_NDR *) pField->GetChild();

        if ( pMember->IsPointer() &&
             !pMember->IsInterfacePointer())
            {
            CG_POINTER *        pPointer;

            pPointer = (CG_POINTER *) pMember;

            // The pointer description.
            pPointer->GenNdrFormatEmbedded( pCCB );
            }

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        } // while
}

//---------------------------------------------------------------------------
// Methods shared by all or most structure classes.
//---------------------------------------------------------------------------

void
CG_STRUCT::GenNdrStructurePointerLayout( CCB *  pCCB,
                                         BOOL   fNoPP,
                                         BOOL   fNoType )
/*++

Routine Description :

    Generates the format string pointer layout section for a structure.
    This is the default routine for this used by the structure classes.
    Only CG_COMPLEX_STRUCT redefines this virtual method.

Arguments :

    pCCB        - pointer to the code control block.
    fNoPP       - TRUE if no FC_PP or FC_END should be emitted
    fNoType     - TRUE only the bare offset and description should be emitted
                  for each pointer

 --*/
{
    CG_ITERATOR         Iterator;
    FORMAT_STRING *     pFormatString;
    CG_FIELD *          pField;
    CG_NDR *            pMember;
    long                ImbedingMemSize;
    long                ImbedingBufSize;

    pFormatString = pCCB->GetFormatString();

    // Get/Save the current imbeding sizes.
    ImbedingMemSize = pCCB->GetImbedingMemSize();
    ImbedingBufSize = pCCB->GetImbedingBufSize();

    if ( ! fNoPP )
        {
        pFormatString->PushFormatChar( FC_PP );
        pFormatString->PushFormatChar( FC_PAD );
        }

    GetMembers( Iterator );

    while( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        CG_NDR *    pOldPlaceholder;
        
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pField );

        pMember = (CG_NDR *) pField->GetChild();

        if ( pMember->IsPointer() &&
             !pMember->IsInterfacePointer() )
            {
            CG_POINTER *        pPointer;

            pPointer = (CG_POINTER *) pMember;

            // Push the instance type.
            if ( ! fNoType )
                {
                pFormatString->PushFormatChar( FC_NO_REPEAT );
                pFormatString->PushFormatChar( FC_PAD );
                }

            pFormatString->PushShort( (short)
                            (ImbedingMemSize + pField->GetMemOffset()));
            pFormatString->PushShort( (short)
                            (ImbedingBufSize + pField->GetWireOffset()));

            // The actual pointer description.
            pPointer->GenNdrFormatEmbedded( pCCB );
            }

        //
        // Generate pointer descriptions for all embedded arrays and structs.
        // We don't have to check for unions because that will make the struct
        // complex.
        //
        if ( pMember->IsArray() )
            {
            CG_NDR * pNdr = (CG_NDR *) pMember->GetChild();

            //
            // For arrays we set the imbeded memory size equal to the
            // size of the whole imbededing structure.
            //
            pCCB->SetImbedingMemSize( ImbedingMemSize + GetMemorySize() );
            pCCB->SetImbedingBufSize( ImbedingBufSize + GetWireSize() );

            if ( (pNdr->IsPointer() && 
                  !pNdr->IsInterfacePointer() )
                 ||
                 ( pNdr->IsStruct() && ((CG_COMP *)pNdr)->HasPointer() )  )
                ((CG_ARRAY *)pMember)->GenNdrFormatArrayPointerLayout( pCCB,
                                                                       TRUE );
            }

        if ( pMember->IsStruct() )
            if ( ((CG_STRUCT *)pMember)->HasPointer() )
                {
                //
                // For embedded structs we add the embedded struct's offset to
                // the value of the current embeddeding size.
                //
                pCCB->SetImbedingMemSize( ImbedingMemSize +
                                          pField->GetMemOffset() );
                pCCB->SetImbedingBufSize( ImbedingBufSize +
                                          pField->GetWireOffset() );

                ((CG_STRUCT *)pMember)->GenNdrStructurePointerLayout( pCCB,
                                                                      TRUE,
                                                                      fNoType );
                }

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        } // while

    if ( ! fNoPP )
        pFormatString->PushFormatChar( FC_END );

    // Re-set the old imbeding sizes.
    pCCB->SetImbedingMemSize( ImbedingMemSize );
    pCCB->SetImbedingBufSize( ImbedingBufSize );

    // There is no call to the string optimizer here. If we wanted to put it in,
    // the code should check if the optimization is possible or not by checking the 
    // result of GenNdrEmbeddedPointers via GenNdrStructurePointerLayout call.
}


CG_FIELD *
CG_STRUCT::GetPreviousField( CG_FIELD * pMarkerField )
/*++

Routine description:

    Finds the field immediately preceding the given field.

Argument:

    pMarkerField  -   the given field

Returns:

    The preceding field or NULL if the given field is the first one.
--*/
{
    CG_ITERATOR         Iterator;
    CG_FIELD            *pField, *pPreviousField = 0;

    GetMembers( Iterator );
    while( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        if ( pField == pMarkerField )
            return( pPreviousField );

        pPreviousField = pField;
        }
    return( 0 );
}


void
CG_STRUCT::GenStructureMemPad( CCB * pCCB, unsigned long MemPad )
/*++

Routine Description :

    Generates the format string for memory padding in a structure layout.

Arguments :

    pCCB        - pointer to the code control block.
    MemPad      - Amount of required padding.
    
 --*/
{
   FORMAT_STRING * pFormatString = pCCB->GetFormatString();
   MIDL_ASSERT( MemPad < 0xFFFF ); // structures must be less then 64k

   switch( MemPad)
       {
       case 0:
           return; // No padding needed
       case 1:
           pFormatString->PushFormatChar( FC_STRUCTPAD1 );
           return;
       case 2:
           pFormatString->PushFormatChar( FC_STRUCTPAD2 );
           return;
       case 3:
           pFormatString->PushFormatChar( FC_STRUCTPAD3 );
           return;
       case 4:
           pFormatString->PushFormatChar( FC_STRUCTPAD4 );
           return;
       case 5:
           pFormatString->PushFormatChar( FC_STRUCTPAD5 );
           return;
       case 6:
           pFormatString->PushFormatChar( FC_STRUCTPAD6 );
           return;
       case 7:
           pFormatString->PushFormatChar( FC_STRUCTPAD7 );
           return;
       default:

           // NDR60 Feature

           // Pad an arbitrary amount
           // FC_STRUCTPADN 0 <unsigned short>
           pFormatString->Align();
           pFormatString->PushFormatChar( FC_STRUCTPADN );
           pFormatString->PushFormatChar( FC_ZERO );
           pFormatString->PushShort( (short)MemPad );

           pCommand->GetNdrVersionControl().SetHasStructPadN();
       }

}

void
CG_STRUCT::GenNdrStructureLayout( CCB * pCCB )
/*++

Routine Description :

    Generates the format string layout section for a structure.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING * pFormatString = pCCB->GetFormatString();

    CG_NDR * pOldPlaceholder = pCCB->GetLastPlaceholderClass();

    CG_ITERATOR         Iterator;
    GetMembers( Iterator );

    CG_FIELD *    pField;
    CG_FIELD *    pPrevField = NULL;
    unsigned long BufferOffset = 0;
    bool          fSawUnknownRepAs = false;

    while( ITERATOR_GETNEXT( Iterator, pField ) ) 
        {
        if ( fSawUnknownRepAs && !pField->HasEmbeddedUnknownRepAs() )
            {
            switch ( pField->GetMemoryAlignment() )
                {
                case 2: pFormatString->PushFormatChar( FC_ALIGNM2 ); break;
                case 4: pFormatString->PushFormatChar( FC_ALIGNM4 ); break;
                case 8: pFormatString->PushFormatChar( FC_ALIGNM8 ); break;
                }        
            }
        else if ( !fSawUnknownRepAs && !pField->HasEmbeddedUnknownRepAs() )
            {
            unsigned long MemPad = pField->GetMemOffset() - BufferOffset;

            GenStructureMemPad( pCCB, MemPad );

            BufferOffset += MemPad;
            }

        pCCB->SetLastPlaceholderClass( pField );
        
        CG_NDR *pMember = (CG_NDR *) pField->GetChild();
        
        while ( pMember->GetCGID() == ID_CG_TYPEDEF )
            {
            pMember = ( CG_NDR* )pMember->GetChild();
            }
        
        // The ending conformat array is not included in the
        // size of the structure.
        // Note that this must be the last field.
        if ( pMember->GetCGID() == ID_CG_CONF_ARRAY ||
             pMember->GetCGID() == ID_CG_CONF_VAR_ARRAY ||
             pMember->GetCGID() == ID_CG_CONF_STRING_ARRAY )
            {
            break;
            }

        // Generate an embedded complex for embedded things.
        if ( pMember->IsStruct() ||
             pMember->IsUnion() ||
             pMember->IsArray() ||
             pMember->IsXmitRepOrUserMarshal() ||
             pMember->GetRangeAttribute() ||
             pMember->IsInterfacePointer() )
            {
            pFormatString->PushFormatChar( FC_EMBEDDED_COMPLEX );

            if ( pField->HasEmbeddedUnknownRepAs() )
                {
                pCCB->GetRepAsPadExprDict()->Register(
                            pFormatString->GetCurrentOffset(),
                            GetType(),
                            pField->GetType()->GetSymName(),
                            pPrevField ? pPrevField->GetType() : 0 );

                pFormatString->PushByteWithPadMacro();
                fSawUnknownRepAs = true;
                }
            else
                {
                pFormatString->PushByte( 0 ); //Padding is generated independently
                }

            if ( pMember->GetFormatStringOffset() == -1 ||
                 pMember->GetFormatStringOffset() == 0 )
                {
                RegisterComplexEmbeddedForFixup(
                    pMember,
                    pFormatString->GetCurrentOffset() - GetInitialOffset() );
                }

            pFormatString->PushShortOffset( pMember->GetFormatStringOffset() -
                                              pFormatString->GetCurrentOffset() );
            }

        else if (pMember->IsPointer() ||
                 ( pMember->GetCGID() == ID_CG_IGN_PTR ) )
            {
            if ( pMember->IsPointer() )
                {
                if ( GetCGID() == ID_CG_COMPLEX_STRUCT )
                    pFormatString->PushFormatChar( FC_POINTER );
                else
                    {
                    pFormatString->PushFormatChar( FC_LONG );
#if !defined(NDR64_ON_DCE_HACK )
                    MIDL_ASSERT( ! pCommand->Is64BitEnv() );
#endif
                    }
                }
            else
                pFormatString->PushFormatChar( FC_IGNORE );

            }
#if defined( NDR64_ON_DCE_HACK )
        else if ( NULL != dynamic_cast<CG_PAD*>( pMember ) )
            {
            pFormatString->PushFormatChar( FC_BUFFER_ALIGN );
            pFormatString->PushByte( pMember->GetWireAlignment() - 1);
            }
#endif
        else 
            {
            //
            // Must be a CG_BASETYPE if we get here.
            //
            FORMAT_CHARACTER FormatChar = ((CG_BASETYPE *)pMember)->GetFormatChar();
            pFormatString->PushFormatChar( FormatChar );
            }

        BufferOffset += pField->GetMemorySize();
        pPrevField = pField;
        }

    // Account for padding at the end of the structure.

    MIDL_ASSERT( GetMemorySize() >= BufferOffset );

    unsigned long EndingPad = GetMemorySize() - BufferOffset;

    // End padding is only allow on complex struct.
    MIDL_ASSERT( EndingPad  ? ( (GetCGID() == ID_CG_COMPLEX_STRUCT) ||
                                IsComplexStruct() || IsHardStruct() )
                            : true ); 

    GenStructureMemPad( pCCB, EndingPad );          

    //
    // If the format string is on a short boundary right now then push
    // a format character so that the format string will be properly aligned
    // following the FC_END.
    //
    if ( ! (pFormatString->GetCurrentOffset() % 2) )
        pFormatString->PushFormatChar( FC_PAD );

    pFormatString->PushFormatChar( FC_END );

    pCCB->SetLastPlaceholderClass( pOldPlaceholder );

}

void
CG_STRUCT::GenNdrStructurePointees( CCB * pCCB )
{
    CG_ITERATOR         Iterator;
    FORMAT_STRING *     pFormatString;
    CG_FIELD *          pField;
    CG_NDR *            pMember;

    pFormatString = pCCB->GetFormatString();

    GetMembers( Iterator );

    //
    // We only have to check for pointer fields here, because if the structure
    // has a struct or array field which has pointers, this will be handled
    // when we generate their format strings.
    //
    while( ITERATOR_GETNEXT( Iterator, pField ) )
        {   
        pMember = (CG_NDR *) pField->GetChild();

        if ( pMember->IsPointer() &&
             !pMember->IsInterfacePointer() )
            {
            CG_NDR * pOldPlaceholder;

            pOldPlaceholder = pCCB->SetLastPlaceholderClass( pField );

            //
            // Skip over an unattributed pointer to a simple type or string.
            //
            if ( ( pMember->GetCGID() == ID_CG_PTR &&
                   ((CG_NDR *)pMember->GetChild())->IsSimpleType() ) ||
                 ( pMember->GetCGID() == ID_CG_STRING_PTR ) )
                {
                pCCB->SetLastPlaceholderClass( pOldPlaceholder );
                continue;
                }

            ((CG_POINTER *)pMember)->GenNdrFormatPointee( pCCB );

            pCCB->SetLastPlaceholderClass( pOldPlaceholder );
            }
        }
}

BOOL
CG_STRUCT::ShouldFreeOffline()
{
    return ( (GetCGID() == ID_CG_COMPLEX_STRUCT) ||
             (GetCGID() == ID_CG_CONF_VAR_STRUCT) ||
             HasPointer() ||
             IsComplexStruct() ||
             IsHardStruct() );
}

void
CG_STRUCT::GenFreeInline( CCB* )
{
}

void
CG_NDR::GenNdrPointerFixUp( CCB * pCCB, CG_STRUCT * pStruct )
{
    CG_ITERATOR     Iterator;
    CG_NDR *        pMember;
    CG_NDR *        pNdr;
    long            Offset;

    if ( ! IsStruct() && ! IsArray()  &&  ! IsUnion() )
        return;

    if ( IsInFixUp() )
        return;

    SetFixUpLock( TRUE );

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pMember ) )
        {
        if ( IsStruct() )
            {
            pNdr = (CG_NDR *) pMember->GetChild();
            }
        else if ( IsUnion() )
            {
            // member of union is a case, then case->field->ndr

            if ( pMember->GetChild() &&  pMember->GetChild()->GetChild() )
                pNdr = (CG_NDR *) pMember->GetChild()->GetChild();
            else
                continue;
            }
        else // IsArray()
            {
            pNdr = pMember;

            //
            // See if the array's element is the structure we're looking for.
            //
            if ( pNdr == pStruct )
                {
                Offset = ((CG_ARRAY *)this)->GetElementDescriptionOffset() + 2;
                pCCB->GetFormatString()->PushShortOffset(
                        pStruct->GetFormatStringOffset() - Offset,
                        Offset );
                }
            }

        if (pNdr->GetCGID() == ID_CG_TYPEDEF )
            pNdr = (CG_NDR *)pNdr->GetChild();

        if ( (pNdr->GetCGID() == ID_CG_PTR) ||
             (pNdr->GetCGID() == ID_CG_SIZE_PTR) ||
             (pNdr->GetCGID() == ID_CG_SIZE_LENGTH_PTR) )
            {
            CG_POINTER * pPointer = (CG_POINTER *) pNdr;

            //
            // Check if we're ready for this guy yet.
            //
            if ( pPointer->GetFormatStringOffset() == -1 )
                continue;

            // Get the pointee.
            switch ( pPointer->GetCGID() )
                {
                case ID_CG_PTR :
                    pNdr = (CG_NDR *) pPointer->GetChild();
                    break;
                case ID_CG_SIZE_PTR :
                    pNdr = ((CG_SIZE_POINTER *)pPointer)->GetPointee();
                    break;
                case ID_CG_SIZE_LENGTH_PTR :
                    pNdr = ((CG_SIZE_LENGTH_POINTER *)pPointer)->GetPointee();
                    break;
                }
        
            //
            // If the pointer's pointee is the struct we're checking for,
            // then patch up the pointer's offset_to_description<2> field.
            //
            if ( pNdr == pStruct )
                {
                long    PointerOffset;

                //
                // Get the offset in the format string where the
                // offset_to_description<2> field of the pointer is.
                //
                PointerOffset = pPointer->GetFormatStringOffset() + 2;
/*
                printf( "    **MIDL_fixup: Non-Reg Actually fixing %s at %d with %d (%d)\n", 
                        pNdr->GetSymName(),
                        PointerOffset, 
                        pNdr->GetFormatStringOffset() - PointerOffset,                      
                        pNdr->GetFormatStringOffset() );
*/
                pCCB->GetFormatString()->PushShortOffset(
                        pStruct->GetFormatStringOffset() - PointerOffset,
                        PointerOffset );
                
                continue;
                }
            }

        //
        // This can happen sometimes because of structs which are promoted
        // to complex because of padding.
        //
        if ( pNdr == this )
            continue;

        //
        // Continue the chase if necessary.
        //
        if ( pNdr->IsStruct() || pNdr->IsUnion() || pNdr->IsArray() )
            pNdr->GenNdrPointerFixUp( pCCB, pStruct );
        }

    SetFixUpLock( FALSE );
}


void
CG_NDR::RegisterComplexEmbeddedForFixup(
    CG_NDR *    pEmbeddedComplex,
    long        RelativeOffset )
{
    if ( GetInitialOffset() == -1 )
        printf( "  Internal compiler problem with recursive embeddings\n" );

    MIDL_ASSERT( GetInitialOffset() != -1 );

    if ( pEmbeddedComplexFixupRegistry == NULL )
        {
        pEmbeddedComplexFixupRegistry = new TREGISTRY;
        }

//    printf( "MIDL_fixup: RegisterComplex %s\n", pEmbeddedComplex->GetSymName());

    EMB_COMPLEX_FIXUP * pFixup = new EMB_COMPLEX_FIXUP;

    pFixup->pEmbeddedNdr   = pEmbeddedComplex;
    pFixup->RelativeOffset = RelativeOffset;

    pEmbeddedComplexFixupRegistry->Register( (node_skl *)pFixup );
}


void
CG_NDR::FixupEmbeddedComplex(
    CCB * pCCB )
{
    if ( IsInComplexFixup() )
        return;

    SetComplexFixupLock( TRUE );

    // Go down first
    CG_ITERATOR     Iterator;
    CG_NDR *        pField;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        pField->FixupEmbeddedComplex( pCCB );

    // Now fix up this level description.

    if ( GetEmbeddedComplexFixupRegistry() )
        {
        ITERATOR            FixupList;
        EMB_COMPLEX_FIXUP * pFixup;
        long                FixAtOffset;
        FORMAT_STRING *     pFormatString =  pCCB->GetFormatString();
    
        GetListOfEmbeddedComplex( FixupList );
    
        while ( ITERATOR_GETNEXT( FixupList, pFixup ) )
            {
            FixAtOffset = GetFormatStringOffset() + pFixup->RelativeOffset;
    
            pFormatString->PushShortOffset(
                pFixup->pEmbeddedNdr->GetFormatStringOffset() - FixAtOffset,
                FixAtOffset );
/*
            printf( "    MIDL_fixup: Reg-Cmplx Actually fixing at %d with %d\n", 
                    FixAtOffset, 
                    pFixup->pEmbeddedNdr->GetFormatStringOffset() - FixAtOffset );
*/
            }
        }

    // Due to duplication, the list may be at the duplicating node.
        
    if ( IsStruct() )
        {
        CG_COMPLEX_STRUCT * pDuping = ((CG_STRUCT *)this)->GetDuplicatingComplex();
        if ( pDuping )
            pDuping->FixupEmbeddedComplex( pCCB );
        }

    SetComplexFixupLock( FALSE );
}

// All these different ways of fixing recursive pointers need to be cleaned up.
// The RecPointer registry seems to be the best solution in that it fixes 
// the pointers once per compilation while complex embed fixup calls walk the 
// tree several times recursively.
// Also, the reason the below registry is different from previously introduced 
// EmbeddedComplex fixup registry is that the emb cplx fixup registry uses 
// a relative pointer when fixing up while the bug we are trying to address now
// affects standalone pointers where absolute offset is appropriate.
// The basic scheme with "struct _S**" field shows up in VARIANT and LPSAFEARRAY.
// Rkk, May, 1999.

void
CCB::RegisterRecPointerForFixup(
    CG_NDR *    pNdr,
    long        AbsoluteOffset )
{
    if ( pRecPointerFixupRegistry == NULL )
        {
        pRecPointerFixupRegistry = new TREGISTRY;
        }

    POINTER_FIXUP * pFixup = new POINTER_FIXUP;

//    printf( "MIDL_fixup: Registering for %s at %d\n", pNdr->GetSymName(), AbsoluteOffset);

    pFixup->pNdr           = pNdr;
    pFixup->AbsoluteOffset = AbsoluteOffset;
    pFixup->fFixed         = false; 
    pRecPointerFixupRegistry->Register( (node_skl *)pFixup );
}


void
CCB::FixupRecPointers()
{
    if ( GetRecPointerFixupRegistry() )
        {
        ITERATOR            FixupList;
        POINTER_FIXUP *     pFixup;
        long                FixAtOffset;
        FORMAT_STRING *     pFormatString = GetFormatString();
    
        GetListOfRecPointerFixups( FixupList );
    
        while ( ITERATOR_GETNEXT( FixupList, pFixup ) )
            {
            FixAtOffset = pFixup->AbsoluteOffset;
    
            if ( ! pFixup->fFixed )
                {
                long Recorded = pFormatString->GetFormatShort(FixAtOffset) + FixAtOffset;
                long NdrOffset = pFixup->pNdr->GetFormatStringOffset();

                if (  0 == Recorded  &&   0 != NdrOffset  ||
                     -1 == Recorded  &&  -1 != NdrOffset  )
                    {
/*                    
                    printf( "    MIDL_fixup: Actually fixing %s at %d with %d (%d)\n", 
                            pFixup->pNdr->GetSymName(),
                            FixAtOffset, 
                            NdrOffset - FixAtOffset,
                            NdrOffset );
*/
                    pFormatString->PushShortOffset( NdrOffset - FixAtOffset,
                                                    FixAtOffset );

                    pFixup->fFixed = true;
                    }
/*
                else if ( 0 != Recorded  &&  -1 != Recorded )
                    {
                    printf( "     MIDL_fixup: %s at %d was already fixed to %d (%d)\n",
                            pFixup->pNdr->GetSymName(),
                            FixAtOffset, 
                            NdrOffset - FixAtOffset,
                            NdrOffset );

                    pFixup->fFixed = true;
                    }
                else
                    {
                    printf( "     MIDL_fixup: %s at %d has not been fixed to %d (%d)\n",
                            pFixup->pNdr->GetSymName(),
                            FixAtOffset, 
                            NdrOffset - FixAtOffset,
                            NdrOffset );
                    }
*/
                } // if ! fixed
            } // while
        }
}

long
CG_STRUCT::FixedBufferSize( CCB * pCCB )
{
    CG_ITERATOR Iterator;
    CG_FIELD *  pField;
    CG_NDR *    pNdr;
    CG_NDR *    pOldPlaceholder;
    long        TotalBufferSize;
    long        BufSize;

    //
    // Check for recursion.
    //
    if ( IsInFixedBufferSize() )
        return -1;

    if ( (GetCGID() == ID_CG_CONF_STRUCT) ||
         (GetCGID() == ID_CG_CONF_VAR_STRUCT) ||
         (GetCGID() == ID_CG_COMPLEX_STRUCT) ||
         IsComplexStruct() )
        return -1;

    if ( IsHardStruct() )
        {
        if ( GetNumberOfUnions() == 0 )
            return MAX_WIRE_ALIGNMENT + GetWireSize();
        else
            return -1;
        }

    SetInFixedBufferSize( TRUE );

    MIDL_ASSERT( GetCGID() == ID_CG_STRUCT );

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    GetMembers( Iterator );

    TotalBufferSize = MAX_WIRE_ALIGNMENT + GetWireSize();

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        pNdr = (CG_NDR *) pField->GetChild();

        // skip these nodes to get to the transmitted element type.
    
        if ( pNdr->IsXmitRepOrUserMarshal() )
            pNdr = (CG_NDR *)pNdr->GetChild();

        if ( pNdr->IsStruct() || pNdr->IsArray() || pNdr->IsPointer() )
            {
            BufSize = pNdr->FixedBufferSize( pCCB );

            if ( BufSize == -1 )
                {
                SetInFixedBufferSize( FALSE );
                return -1;
                }

            //
            // First subtract the basic size of this thing from the struct's
            // size and then add back the value it returned.
            //
            TotalBufferSize -= pNdr->GetWireSize();
            TotalBufferSize += BufSize;
            }
        }

    pCCB->SetLastPlaceholderClass( pOldPlaceholder );

    SetInFixedBufferSize( FALSE );

    // Success!
    return TotalBufferSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\szbuffer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       szbuffer.cxx
//
//  Contents:   simple class for a string buffer that dynamically reallocates
//              space for itself as necessary
//
//  Classes:    CSzBuffer
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

#include "becls.hxx"
#pragma hdrstop
#include "szbuffer.h"

#define INCREMENT_BUFFER 256
#define INITIAL_BUFFER (INCREMENT_BUFFER * 2);

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::CSzBuffer
//
//  Synopsis:   constructor
//
//  Arguments:  [sz] - data for initial string (may be NULL)
//
//  History:    4-22-96   stevebl   Created
//
//  Notes:      Throughout this class the actual size of the buffer allocated
//              is determined by the formula
//                  INITIAL_BUFFER + INCREMENT_BUFFER * n
//              where n is calculated to give the value closest to (but not
//              less than) the number of bytes required.
//              The allocated buffer is never shrunk, only grown as needed.
//              This keeps allocations and memory moves to a minimum.
//
//----------------------------------------------------------------------------

CSzBuffer::CSzBuffer(const char * sz)
{
    if (sz)
    {
        cchLength = (int) strlen(sz);
        cchBufSize = INITIAL_BUFFER;
        while ((cchLength + 1) > cchBufSize)
            cchBufSize += INCREMENT_BUFFER;
        szData = new char[cchBufSize];
        strcpy(szData,sz);
    }
    else
    {
        cchLength = 0;
        cchBufSize = INITIAL_BUFFER;
        szData = new char[cchBufSize];
        szData[0] = 0;
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::CSzBuffer
//
//  Synopsis:   default constructor
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

CSzBuffer::CSzBuffer()
{
    cchLength = 0;
    cchBufSize = INITIAL_BUFFER;
    szData = new char[cchBufSize];
    szData[0] = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::~CSzBuffer
//
//  Synopsis:   destructor
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

CSzBuffer::~CSzBuffer()
{
    delete [] szData;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::Set
//
//  Synopsis:   resets buffer and (optionally) initializes it
//
//  Arguments:  [sz] - data for initial string (may be NULL)
//
//  Returns:    nothing
//
//  History:    4-22-96   stevebl   Created
//
//  Notes:      as mentioned above, the size of the actual buffer does not
//              shrink
//
//----------------------------------------------------------------------------

void CSzBuffer::Set(const char * sz)
{
    cchLength = 0;
    szData[0] = 0;
    Append(sz);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::Append
//
//  Synopsis:   adds data to the end of the buffer
//
//  Arguments:  [sz] - string data to add
//
//  Returns:    nothing
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

void CSzBuffer::Append(const char * sz)
{
    if (sz)
    {
        int cchLenSz = (int) strlen(sz);
        int cchNew = cchLenSz + cchLength;
        if ((cchNew + 1) > cchBufSize)
        {
            while ((cchNew + 1) > cchBufSize)
                cchBufSize += INCREMENT_BUFFER;
            char * szNew = new char[cchBufSize];
            strcpy(szNew,szData);
            delete [] szData;
            szData=szNew;
        }
        strcpy(&szData[cchLength], sz);
        cchLength = cchNew;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::Prepend
//
//  Synopsis:   adds data to the front of the buffer
//
//  Arguments:  [sz] - string to add
//
//  Returns:    nothing
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

void CSzBuffer::Prepend(const char * sz)
{
    if (sz)
    {
        int cchLenSz = (int) strlen(sz);
        int cchNew = cchLenSz + cchLength;
        if ((cchNew + 1) > cchBufSize)
        {
            while ((cchNew + 1) > cchBufSize)
                cchBufSize += INCREMENT_BUFFER;
            char * szNew = new char[cchBufSize];
            strcpy(szNew,szData);
            delete [] szData;
            szData=szNew;
        }
        memmove(&szData[cchLenSz], szData, cchLength);
        memmove(szData, sz, cchLenSz);
        szData[ cchNew ] = 0;
        cchLength = cchNew;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::Append
//
//  Synopsis:   adds a decimal integer to the end of the buffer
//
//  Arguments:  [l] - value of integer to add
//
//  Returns:    nothing
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

void CSzBuffer::Append(const long l)
{
    char sz[50];
    sprintf(sz, "%d", l);
    Append(sz);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::Prepend
//
//  Synopsis:   adds a decimal integer to the front of the buffer
//
//  Arguments:  [l] - value of integer to add
//
//  Returns:    nothing
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

void CSzBuffer::Prepend(const long l)
{
    char sz[50];
    sprintf(sz, "%d", l);
    Prepend(sz);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::GetData
//
//  Returns:    pointer to the string in the buffer
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

char * CSzBuffer::GetData()
{
    return szData;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::GetLength
//
//  Returns:    length (in chars) of the string in the buffer
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

int CSzBuffer::GetLength()
{
    return cchLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\treg.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	treg.cxx

 Abstract:

	This file implements the type registry for header file generation.

 Notes:

 History:

	Oc-23-1993		VibhasC		Created.
 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 )

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop


node_skl *
TREGISTRY::IsRegistered(
	node_skl	*	pType )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Register a type with the type registry.

 Arguments:

 	pType	- A pointer to the type being registered.
	
 Return Value:

 	The node that gets registered.
	
 Notes:

----------------------------------------------------------------------------*/
{
	Dict_Status	Status	= Dict_Find( pType );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:
			return (node_skl *)0;
		default:
			return (node_skl *)Dict_Curr_Item();
		}
}

node_skl *
TREGISTRY::Register(
	node_skl	*	pType )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Register a type with the dictionary.

 Arguments:
	
 	pType	- A pointer to the type node.

 Return Value:

 	The final inserted type.
	
 Notes:

----------------------------------------------------------------------------*/
{
	if( !IsRegistered( pType ) )
		{
		Dict_Insert( (pUserType) pType );
		return pType;
		}
	return (node_skl *)pType;
}

short
TREGISTRY::GetListOfTypes(
	ITERATOR&	ListIter )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Get the list of types in this registry.

 Arguments:

 	ListIter	- A pre- constructed iterator where the list of types is
 				  returned.
	
 Return Value:

 	The count of the number of items.
	
 Notes:

----------------------------------------------------------------------------*/
{
	node_skl	*	pN;
	Dict_Status		Status;
	short			Count = 0;

	// Get to the top of the dictionary.

	Status	= Dict_Next( (pUserType)0 );

	// make sure we start with a clean iterator
	ITERATOR_DISCARD( ListIter );

	// Iterate till the entire dictionary is looked at.

	while( SUCCESS == Status )
		{
		pN	= (node_skl *)Dict_Curr_Item();
		ITERATOR_INSERT( ListIter, pN );
		Count++;
		Status = Dict_Next( (pUserType)pN );
		}

	return Count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\typegen.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	typegen.cxx

 Abstract:

	transmit_as etc routine.

 Notes:


 History:

 	Dec-08-1993		VibhasC		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/


CG_STATUS
CG_TRANSMIT_AS::S_GenInitOutLocals(
	CCB	*	pCCB )
	{
	expr_node	*	pExpr;

	pExpr = MakeAddressExpressionNoMatterWhat( GetResource() );
	Out_Assign( pCCB, pCCB->GetSourceExpression(), pExpr );
	expr_node	*	pSrc = pCCB->GetSourceExpression();
	expr_proc_call * pProc = new expr_proc_call( MIDL_MEMSET_RTN_NAME );
	pProc->SetParam( new expr_param( pSrc ) );
	pProc->SetParam( new expr_param( new expr_constant( 0L ) ) );
	pProc->SetParam( new expr_param( new expr_sizeof( GetPresentedType())));
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	return CG_OK;
	}

/*****************************************************************************
 REPRESENT_AS routines
 *****************************************************************************/
CG_STATUS
CG_REPRESENT_AS::S_GenInitOutLocals(
	CCB	*	pCCB )
	{
	expr_node	*	pExpr;
	node_skl	*	pNode = new node_def( GetRepAsTypeName() );

	pExpr = MakeAddressExpressionNoMatterWhat( GetResource() );
	Out_Assign( pCCB, pCCB->GetSourceExpression(), pExpr );
	expr_node	*	pSrc = pCCB->GetSourceExpression();
	expr_proc_call * pProc = new expr_proc_call( MIDL_MEMSET_RTN_NAME );
	pProc->SetParam( new expr_param( pSrc ) );
	pProc->SetParam( new expr_param( new expr_constant( 0L ) ) );
	pProc->SetParam( new expr_param( new expr_sizeof( pNode ) ) );
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	return CG_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\typendr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1993-1999 Microsoft Corporation

 Module Name:

    typendr.cxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    transmit_as and represent_as types.

 Notes:

 History:

    DKays     Jan-1994        Created.
    RyszardK  Jan-07-1994     Added transmit_as and represent as routines.
    RyszardK  Jan-17-1995     Added support for user_marshal.

 ----------------------------------------------------------------------------*/

#include "becls.hxx"

extern CMD_ARG * pCommand;
#pragma hdrstop


//+--------------------------------------------------------------------------
//
//  Method:     CG_TYPEDEF::GenXmitOrRepAsQuintuple
//
//  Synopsis:   Register this type so that we can generate the callback
//              routines for it later.
//
//  Returns:    The index of the this type in the table of callback routine
//              sets
//
//  Notes:      If the type is already registered, just return the previous
//              index.
//
//  REVIEW:     "Gen" is not really correct since we don't generate anything.
//              Since this is now a method instead of a stand alone function
//              we should be able to get rid of the fXmit parameter.
//              Consider adding a common ancestor class for transmit_as /
//              represent_as as a better place to put this method.
//
//---------------------------------------------------------------------------

unsigned short
CG_TYPEDEF::GenXmitOrRepAsQuintuple(
    CCB *       pCCB,
    BOOL        fXmit,
    CG_NDR *    pXmitNode,
    char *      pPresentedTypeName,
    node_skl *  pTypeForPrototype )
{
    unsigned short    Index;

    // Register the routine to be generated for future use.

    XMIT_AS_CONTEXT * pTransmitAsContext = new XMIT_AS_CONTEXT;

    pTransmitAsContext->fXmit     = fXmit;
    pTransmitAsContext->pXmitNode = pXmitNode;
    pTransmitAsContext->pTypeName = pPresentedTypeName;

    BOOL  Added = pCCB->GetQuintupleDictionary()->Add( pTransmitAsContext );

    Index = pTransmitAsContext->Index;

    if ( Added )
        {
        // We haven't serviced this type yet.
          // Register with the ccb so that the prototypes can be emitted later

        if ( fXmit )
            pCCB->RegisterPresentedType( pTypeForPrototype );
        else
            pCCB->RegisterRepAsWireType( pTypeForPrototype );

        // Register the transmit_as contex to be able to generate
        // the helper routines.

        pCCB->RegisterQuintuple( pTransmitAsContext );
        }
    else
        delete pTransmitAsContext;

    return Index;
}


// ========================================================================
//       Transmit As
// ========================================================================

void
GenXmitOrRepAsNdrFormat(
    CCB *       pCCB,
    BOOL        fXmit,
    CG_TYPEDEF *pXmitNode,
    char *      pPresentedTypeName,
    node_skl *  pPresentedType,
    node_skl *  pTransmittedType )
{
    FORMAT_STRING *    pFormatString;
    CG_NDR *        pChild;
    unsigned short  Index;
    long            ChildOffset;
    
    pFormatString = pCCB->GetFormatString();

    pChild = (CG_NDR *) pXmitNode->GetChild();

    // Do this in case the child is a simple type.
    ChildOffset = pFormatString->GetCurrentOffset();

    pChild->GenNdrFormat( pCCB );

    // Again, do this in case the child is a simple type.
    pFormatString->Align();

    pXmitNode->SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    Index = pXmitNode->GenXmitOrRepAsQuintuple( pCCB,
                                     fXmit,
                                     pXmitNode,
                                     pPresentedTypeName,
                                     (fXmit ? pPresentedType
                                            : pTransmittedType) );

    pFormatString->PushFormatChar( fXmit ? FC_TRANSMIT_AS
                                         : FC_REPRESENT_AS );

    // Now the flag byte. Lower nibble keeps xmitted type alignment.
    // The upper one has the flag for -Oi when presented type is an array.

    unsigned char
    FlagByte = unsigned char( pChild->GetWireAlignment() - 1 );

    if ( pPresentedType )
        {
        if ( pPresentedType->GetBasicType()->NodeKind() == NODE_ARRAY )
            FlagByte |= PRESENTED_TYPE_IS_ARRAY;
        else
            {
            if ( pXmitNode->GetMemoryAlignment() == 4 )
                FlagByte |= PRESENTED_TYPE_ALIGN_4;
            if ( pXmitNode->GetMemoryAlignment() == 8 )
                FlagByte |= PRESENTED_TYPE_ALIGN_8;
            }
        }

    pFormatString->PushByte( FlagByte );
    pFormatString->PushShort( (short) Index );

    // Now the presented type memory size and transmitted type bufsize.

    if ( pPresentedType )
        pFormatString->PushShort( (short)pPresentedType->GetSize( ) );
    else
        {
        // unknown rep as type - will have to generate a sizing macro

        pCCB->GetRepAsSizeDict()->Register( pFormatString->GetCurrentOffset(),
                                            pPresentedTypeName );
        pFormatString->PushShortWithSizeMacro();
        }

    if ( pChild->HasAFixedBufferSize() )
        pFormatString->PushShort( (short) pChild->GetWireSize() );
    else
        pFormatString->PushShort( (short) 0 );

    if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
        pChild = (CG_NDR *)pChild->GetChild();

    if ( pChild->IsSimpleType() )
        {
        pFormatString->PushShortOffset(
                     ChildOffset - pFormatString->GetCurrentOffset() );
        }
    else
        {
        pFormatString->PushShortOffset(
                           pChild->GetFormatStringOffset() - 
                             pFormatString->GetCurrentOffset() );
        }

    pXmitNode->SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
    pFormatString->OptimizeFragment( pXmitNode );
}

void
CG_TRANSMIT_AS::GenNdrFormat( CCB * pCCB )
/*++
    The format string is now:

        FC_TRANSMIT_AS
        Oi array flag/alignment<1>
        quintuple index<2>
        pres type mem size<2>
        tran type buf size<2>
        <<offset>>
--*/
{
    if ( GetFormatStringOffset() != -1 ) 
        return;

    GenXmitOrRepAsNdrFormat( pCCB,
                             TRUE,      // transmit as
                             this,
                             GetPresentedType()->GetSymName(),
                             GetPresentedType(),
                             GetTransmittedType() );
}

long                    
CG_TRANSMIT_AS::GetStackSize()
{
    if ( pPresentedType->GetBasicType()->NodeKind() == NODE_ARRAY )
        return SIZEOF_MEM_PTR();
    else
        return GetMemorySize();
}

//========================================================================
//      Represent_as
//========================================================================

void
CG_REPRESENT_AS::GenNdrFormat( CCB * pCCB )
/*++
    The format string is now:

        FC_REPRESENT_AS
        Oi array flag/alignment<1>
        quintuple index<2>
        pres type mem size<2>
        tran type buf size<2>
        <<offset>>
--*/
{
    if ( GetFormatStringOffset() != -1 ) 
        return;

    GenXmitOrRepAsNdrFormat( pCCB,
                             FALSE,      // represent as
                             this,
                             GetRepAsTypeName(),
                             GetRepAsType(),
                             GetTransmittedType() );
}

long
CG_REPRESENT_AS::GetStackSize()
{
    //
    // A null representation type is ok here.  Unknown rep-as is not allowed
    // in the interpreter, so we just return 0 since the stack size will 
    // never actually be used for an -Os stub.
    //
    if ( ! pRepresentationType )
        return 0;

    if ( pRepresentationType->GetBasicType()->NodeKind() == NODE_ARRAY )
        return SIZEOF_MEM_PTR();
    else
        return GetMemorySize();
}

void
CG_REPRESENT_AS::GenNdrParamDescription( CCB * pCCB )
{
    // REVIEW: Why is this here?  The CG_NDR version would have been called
    //         if we hadn't overridden it.

    CG_NDR::GenNdrParamDescription( pCCB );

    // BUGBUG : Stack offsets of parameters after this guy are in trouble.
}

void
CG_REPRESENT_AS::GenNdrParamDescriptionOld( CCB * pCCB )
{
    FORMAT_STRING * pProcFormatString;

    if ( GetRepAsType() )
        {
        CG_NDR::GenNdrParamDescriptionOld( pCCB );
        return;
        }

    pProcFormatString = pCCB->GetProcFormatString();

    pProcFormatString->PushUnknownStackSize( GetRepAsTypeName() );

    pProcFormatString->PushShortTypeOffset( GetFormatStringOffset() );
}

void
CG_USER_MARSHAL::GenNdrFormat( CCB * pCCB )
/*++
    The format string is now:

        FC_USER_MARSHAL
        flags/alignment<1>
        quadruple index<2>
        pres type mem size<2>
        xmit type wire size<2>
        Offset to wire desc<2>
--*/
{
    if ( GetFormatStringOffset() != -1 ) 
        return;

    pCommand->GetNdrVersionControl().SetHasUserMarshal();

    FORMAT_STRING * pFormatString;
    CG_NDR *        pChild;
    long            ChildOffset;

    // Format offset

    pFormatString = pCCB->GetFormatString();

    pChild = (CG_NDR *) GetChild();

    MIDL_ASSERT( pChild );

    // Do this in case the child is a simple type.
    ChildOffset = pFormatString->GetCurrentOffset();

    pChild->GenNdrFormat( pCCB );

    // Again, do this in case the child is a simple type.
    pFormatString->Align();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    // Real stuff now

    pFormatString->PushFormatChar( FC_USER_MARSHAL );

    // Now the flag byte.
    // Top 2 bits convey the pointer info:
    //     0 - not a pointer
    //     1 - a ref
    //     2 - a unique

    unsigned char
    FlagByte = unsigned char( pChild->GetWireAlignment() - 1 );

    if ( pChild->IsPointer() )
        {
        CG_POINTER * pPtr = (CG_POINTER *)pChild;
        MIDL_ASSERT( ! pPtr->IsFull() );

        if ( pPtr->IsUnique() )
            FlagByte |= USER_MARSHAL_UNIQUE;
        else if ( pPtr->IsRef() )
            FlagByte |= USER_MARSHAL_REF;
        }

    pFormatString->PushByte( FlagByte );

    // Register the routine to be generated for future use.

    USER_MARSHAL_CONTEXT * pUserMarshalContext = new USER_MARSHAL_CONTEXT;

    pUserMarshalContext->pTypeName = GetRepAsTypeName();
    pUserMarshalContext->pType     = GetRepAsType();

    BOOL  Added = pCCB->GetQuadrupleDictionary()->Add( pUserMarshalContext );

    unsigned short Index = pUserMarshalContext->Index;

    pFormatString->PushShort( (short) Index );

    if ( ! Added )
        delete pUserMarshalContext;

    // Now the presented type memory size and transmitted type bufsize.

    if ( GetRepAsType() )
        pFormatString->PushShort( (short) GetRepAsType()->GetSize( ) );
    else
        {
        // Unknown user_marshall type - will have to generate a sizing macro
        // As represent_as and user_marshal are mutually exclusive,
        // we can use rep_as size dictionary.

        pCCB->GetRepAsSizeDict()->Register( pFormatString->GetCurrentOffset(),
                                            GetRepAsTypeName() );
        pFormatString->PushShortWithSizeMacro();
        }

    if ( pChild->HasAFixedBufferSize() )
        pFormatString->PushShort( (short) pChild->GetWireSize() );
    else
        pFormatString->PushShort( (short) 0 );

    if ( pChild->IsSimpleType() )
        {
        pFormatString->PushShortOffset(
                    ChildOffset - pFormatString->GetCurrentOffset() );
        }
    else
        {
        pFormatString->PushShortOffset(
                          pChild->GetFormatStringOffset() - 
                            pFormatString->GetCurrentOffset() );
        }

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
    pFormatString->OptimizeFragment( this );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\unionndr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1993-1999 Microsoft Corporation

 Module Name:

    unionndr.hxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    unions, and the new NDR marshalling and unmarshalling calls.

 Notes:


 History:

    DKays     Nov-1993     Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

void
CG_ENCAPSULATED_STRUCT::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string for an encapsulated union.

Arguments :

    pCCB    - pointer to the code control block

Return :
    
    None.

--*/
{
    FORMAT_STRING *     pFormatString;
    CG_BASETYPE *       pSwitchIsNode;
    CG_UNION *          pUnion;
    unsigned long       SwitchType;

    if ( GetFormatStringOffset() != -1 ) 
        return;

    pFormatString = pCCB->GetFormatString();

    //
    // The child of the struct's first field node is the switch_is node.
    //
    pSwitchIsNode = (CG_BASETYPE *) GetChild()->GetChild();

    //
    // The child of the struct's second field node is the union node.
    //
    pUnion = (CG_UNION *) GetChild()->GetSibling()->GetChild();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    pFormatString->PushFormatChar( FC_ENCAPSULATED_UNION );

    //
    // The switch type field in the format string has the size of the switch_is
    // field (including any needed pading) in the upper four bits and the 
    // actual switch_is type in the lower four bits.
    //

    //
    // Get the amount to increment the memory pointer to the encapsulated
    // union's struct to get to the actual union.  This is the total struct
    // size minus the union's size (this may not simply be the size of the
    // switch_is member because of possible padding).
    //
    CG_FIELD *  pSwitchField;
    CG_FIELD *  pUnionField;

    pSwitchField = (CG_FIELD *) GetChild();
    pUnionField = (CG_FIELD *) pSwitchField->GetSibling();

    //
    // Set the memory increment part of the SwitchType field.
    //
    SwitchType = ( pUnionField->GetMemOffset() - pSwitchField->GetMemOffset() )
                 << 4;

    if ( pSwitchIsNode->GetFormatChar() == FC_ENUM16 ) 
        SwitchType |= FC_ENUM16;
    else
        SwitchType |= pSwitchIsNode->GetSignedFormatChar();

    pFormatString->PushByte( SwitchType );

    pUnion->GenNdrSizeAndArmDescriptions( pCCB );

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
//  SetFormatStringOffset( pFormatString->OptimizeFragment( this ) );

}

void
CG_UNION::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string for a non-encapsulated union.

Arguments :

    pCCB    - pointer to the code control block

Return :
    
    None.

--*/
{
    FORMAT_STRING *     pFormatString;
    long                Offset;

    SetCCB( pCCB );

    if ( GetFormatStringOffset() != -1 ) 
        return;

    pFormatString = pCCB->GetFormatString();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    pFormatString->PushFormatChar( FC_NON_ENCAPSULATED_UNION );

    if ( ((CG_BASETYPE *)pCGSwitchType)->GetFormatChar() == FC_ENUM16 ) 
        pFormatString->PushFormatChar( FC_ENUM16 );
    else
        {
        FORMAT_CHARACTER SwitchTypeFc;

        // Note that we take the signed format character this time.

        SwitchTypeFc = ((CG_BASETYPE *)pCGSwitchType)->GetSignedFormatChar();

#if defined(TARGET_RKK)
        if ( pCommand->GetTargetSystem() == NT35  &&
             SwitchTypeFc == FC_USMALL )
            {
            // The NT 807 NDR engine doesn't know about usmall.

            pFormatString->PushFormatChar( FC_BYTE );
            pFormatString->PushFormatChar( FC_SMALL );
            }
        else
#endif

        pFormatString->PushFormatChar( SwitchTypeFc );
        }

    GenNdrSwitchIsDescription( pCCB );

    Offset = pFormatString->GetCurrentOffset();

    pFormatString->PushShortOffset( 0 );

    GenNdrSizeAndArmDescriptions( pCCB );

    pFormatString->PushShortOffset( GetNdrSizeAndArmDescriptionOffset() - Offset,
                                    Offset );

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
//  SetFormatStringOffset( pFormatString->OptimizeFragment( this ) );

}

void
CG_UNION::GenNdrFormatArms( CCB * pCCB )
/*++

Routine Description :

    Generates the format string for the arms of an encapsulated or a
    non-encapsulated union.

Arguments :

    pCCB    - pointer to the code control block

Return :
    
    None.

--*/
{
    CG_ITERATOR Iterator;
    CG_CASE *   pCase;
    CG_NDR *    pNdr;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pCase ) )
        {
        if ( ! pCase->GetChild() ) 
            continue;

        //
        // The child of the CG_CASE is a CG_FIELD.   
        // The child of the CG_FIELD is the actual NDR entity.
        //
        pNdr = (CG_NDR *) pCase->GetChild()->GetChild();

        if ( ! pNdr ) 
            continue;

        if ( pNdr && ( ! pNdr->IsSimpleType() || pNdr->GetRangeAttribute() ) ) 
            pNdr->GenNdrFormat( pCCB );
        }
}

void
CG_UNION::GenNdrSizeAndArmDescriptions( CCB * pCCB )
/*++

Routine Description :

    Generates the memory size and arm description portion of the format 
    string for an encapsulated or a non-encapsulated union.

Arguments :

    pCCB    - pointer to the code control block

Return :
    
    None.

--*/
{
    FORMAT_STRING *     pFormatString;
    unsigned short      UnionArms;
    long                FormatOffset;

    if ( GetNdrSizeAndArmDescriptionOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    SetNdrSizeAndArmDescriptionOffset( pFormatString->GetCurrentOffset() );

#ifdef DUMP_UNION_INFO

    FILE * fUnionLog = NULL;

    fUnionLog = fopen("c:\\unioninfo.log", "a+t");

    if (fUnionLog) 
        {
        char *pName = GetSymName();
        unsigned long UnionArms = GetNumberOfArms();
        char *pUnionKind = NULL;
        unsigned long UnionFlavor = GetUnionFlavor();
        char *pFileName = "Unknown";
        char *pEnv = pCommand->Is64BitEnv() ? ("64") : ("32");
 
        switch(UnionFlavor)
        {
            case UNION_UNKNOWN:
                pUnionKind = "Union_Unknown";
                break;
            case UNION_ENCAP:
                pUnionKind = "Union_Encap";
                break;
            case UNION_NONENCAP_DCE:
                pUnionKind = "Union_NonEncap_DCE";
                break;
            case UNION_NONENCAP_MS:
                pUnionKind = "Union_NonEncap_MS";
                break;
            default: 
                pUnionKind = "Unknown";
                break;         
        }

        node_file * pFile = GetType()->GetDefiningFile();
        if (pFile && pFile->GetSymName())
           pFileName = pFile->GetSymName();
 
        fprintf(fUnionLog, "* %s FileName: %s, Symbol: %s, Kind %u(%s), Arms: %u \n",
                pEnv, pFileName, pName, UnionFlavor, pUnionKind, UnionArms); 
        }

#endif

    //
    // Set aside the space for the union's description.  Then we generate
    // the format string description for all the union's arms, and then 
    // we go back and patch up the the union's description to have the 
    // proper offsets.  This must be done to handle self referencing union
    // types.
    //

    // Memory size.
    pFormatString->PushShort( (short) GetMemorySize() );

    //
    // union_arms<2> 
    //
    UnionArms = (unsigned short) GetNumberOfArms();

    if ( GetUnionFlavor() == UNION_NONENCAP_MS )
        {
        // 
        // Microsoft union support.
        // Set the upper four bits of the union_arm<2> field with the 
        // the alignment of the largest aligned union arm.
        //
        UnionArms |= (GetWireAlignment() - 1) << 12;
        }

    pFormatString->PushShort( (short) UnionArms );

    // Get union arms again since we may have just munged it.
    UnionArms = (short) GetNumberOfArms();

    // The arms.
    for ( ; UnionArms-- > 0; ) 
        {
        pFormatString->PushLong( 0 );
        pFormatString->PushShortOffset( 0 );
        }

    // default_arm_description<2>
    pFormatString->PushShortOffset( 0 );

    //
    // Generate the format string descriptions of the arms.
    //
    GenNdrFormatArms( pCCB );

    // Find out where the arms' descriptions begin.
    FormatOffset = GetNdrSizeAndArmDescriptionOffset() + 4;

    CG_ITERATOR         Iterator;
    CG_CASE *           pCase;
    CG_NDR *            pNdr;
    CG_NDR *            pNdrDefaultCase;
    BOOL                DefaultCaseFound;
    
    GetMembers( Iterator );

    pNdrDefaultCase = NULL;
    DefaultCaseFound = FALSE;

    while ( ITERATOR_GETNEXT( Iterator, pCase ) )
        {
        //
        // Check for the default case first.
        //
        if ( pCase->GetCGID() == ID_CG_DEFAULT_CASE )
            {
            pNdrDefaultCase = pCase->GetChild() ? 
                              (CG_NDR *) pCase->GetChild()->GetChild() : 0;

            DefaultCaseFound = TRUE;

#ifdef DUMP_UNION_INFO
  
            if (fUnionLog)
               {
               fprintf(fUnionLog, "DEFAULT\n"); 
               }
#endif

            continue;
            }

        //
        // Fill in the arm's case value.
        //
        if (NULL == pCase->GetExpr())
            {
            RpcError(NULL, 0, NO_CASE_EXPR, GetSymName());
            exit(NO_CASE_EXPR);
            }

#ifdef DUMP_UNION_INFO

        if (fUnionLog)
           fprintf(fUnionLog, "%d \n", (long)pCase->GetExpr()->GetValue());

#endif

        pFormatString->PushLong( (long)pCase->GetExpr()->GetValue(), FormatOffset );
        FormatOffset += 4;

        //
        // Check for a non-default case with an empty (;) arm.
        //
        if ( ! pCase->GetChild() || ! pCase->GetChild()->GetChild() )
            {
            //
            // Increment the FormatOffset past the arm description, which 
            // simply remains zero.
            //
            FormatOffset += 2;
            continue;
            }

        //
        // Else it's a regular case with a valid arm.
        //

        pNdr = (CG_NDR *) pCase->GetChild()->GetChild();

        // Emit a short with type or offset representation.
        // For simple types we push <0x80><type>, for others we push offset<2>.
        // The engine checks if the first byte is 0x80 to decide how it should
        // treat the short, hence the offset range is from 0x8100 to 7fff, i.e.
        // the offset of 0x80xx is invalid.

        if ( pNdr && pNdr->IsSimpleType() )
            {
            short   s;
            //
            // The offset in this case is the actual format character for 
            // the base type, but with a 1 in the upper bit of the short, to 
            // make it look negative.
            //
            s = (short) ((CG_BASETYPE *)pNdr)->GetFormatChar();
            s |= MAGIC_UNION_SHORT;

            pFormatString->PushMagicUnionShort( s, FormatOffset );
            }
        else
            {
            //
            // The offset pushed here is the usual relative offset, except
            // as explained above, it has to be >= 0x8100.
            //
            pFormatString->PushShortOffset( pNdr->GetFormatStringOffset() - 
                                            FormatOffset,
                                            FormatOffset );
            }

        FormatOffset += 2;
        }

    //
    // Finally, handle the default case.
    //
    if ( ! DefaultCaseFound )
        {
        // We push an offset here for easier stub reading as this is an offset.. 
        // However, this would prevent union optimization if we switched it on,
        // so at that stage an FS_ marker is needed to generate a comment.
        //
        pFormatString->PushShortOffset( -1, FormatOffset );
        }
    else
        {
        if ( ! pNdrDefaultCase )
            pFormatString->PushShortOffset( 0, FormatOffset );
        else
            {
            if ( pNdrDefaultCase->IsSimpleType() )
                {
                short s;
                s = (short) ((CG_BASETYPE *)pNdrDefaultCase)->GetFormatChar(); 
                s |= MAGIC_UNION_SHORT;
                pFormatString->PushMagicUnionShort( s, FormatOffset );
                }
            else
                pFormatString->PushShortOffset(
                    pNdrDefaultCase->GetFormatStringOffset() - FormatOffset,
                    FormatOffset );
            }
        }

#ifdef DUMP_UNION_INFO
    if (fUnionLog)
    {
        fprintf(fUnionLog, "+\n");
        fprintf(fUnionLog, "\n");
        fclose(fUnionLog);
    }
#endif

}

BOOL 
CG_UNION::CanUseBuffer()
{
    CG_ITERATOR Iterator;
    CG_CASE *   pCase;
    CG_NDR *    pNdr;
    unsigned long Size;
    long        Align;
    long        TempBufAlign;

    //
    // We will be very strict, since there is not much room for 
    // leeway.  Only return TRUE if all arms have the same size, the same
    // wire alignment, and matching wire/memory alignments & sizes.
    //
    // The real scenario we're after is a union with all pointer arms or
    // longs.  This is fairly common in NT.
    //

    GetMembers( Iterator );

    Size = 0;
    Align = 0;
    
    while ( ITERATOR_GETNEXT( Iterator, pCase ) )
        {
        if ( ! pCase->GetChild() || 
             (pNdr = (CG_NDR *) pCase->GetChild()->GetChild()) == 0 )
            continue;

        TempBufAlign = pNdr->GetWireAlignment();
        
        if ( (pNdr->GetWireSize() != pNdr->GetMemorySize()) ||
             (pNdr->GetMemoryAlignment() != TempBufAlign) )
            return FALSE;

        if ( ! Size ) 
            {
            Size = pNdr->GetWireSize();
            Align = TempBufAlign;
            continue;
            }
            
        if ( (Size != pNdr->GetWireSize()) || (Align != TempBufAlign) )
            return FALSE;
        }

    return TRUE;
}

void
CG_UNION::GenNdrSwitchIsDescription( CCB *  pCCB )
/*++

Routine Description :

    This routine generates the switch_type<1> and switch_is_description<4>
    field for a non-encapsulated union.

Arguments :

    pCCB    - pointer to the code control block

Return :
    
    None.

--*/
{
    CG_NDR *            pParamOrField;
    CG_FIELD *          pField;
    expr_node *     pSwitchExpr;
    BOOL                IsPointer;

    pParamOrField = pCCB->GetLastPlaceholderClass();

    //
    // Get the switch is expression.
    //
    switch ( pParamOrField->GetCGID() )
        {
        case ID_CG_PARAM :
            pSwitchExpr = ((CG_PARAM *)pParamOrField)->GetSwitchExpr();

            // If it's top level param then this flag doesn't matter.
            IsPointer = FALSE;

            break;

        case ID_CG_FIELD :
            pField = (CG_FIELD *) pParamOrField;

            pSwitchExpr = pField->GetSwitchExpr();
    
            // Check if the field is actually a pointer to a union.
            IsPointer = ((CG_NDR *)pField->GetChild())->IsPointer();
                
            break;

        default :
            MIDL_ASSERT(0);
        }

    GenNdrFormatAttributeDescription( pCCB,
                                      NULL,
                                      pSwitchExpr,
                                      IsPointer,
                                      TRUE,
                                      FALSE,
                                      FALSE,
                                      pCommand->IsSwitchDefined( SWITCH_ROBUST ) );
}

void                    
CG_UNION::SetFormatStringOffset( long Offset )
{
    CCB *       pCCB;
    CG_NDR *    pParamOrFieldNode;

    pCCB = GetCCB();

    pParamOrFieldNode = pCCB->GetLastPlaceholderClass();

    if ( pParamOrFieldNode->GetCGID() == ID_CG_PARAM )
        ((CG_PARAM *)pParamOrFieldNode)->SetUnionFormatStringOffset( Offset );
    else
        ((CG_FIELD *)pParamOrFieldNode)->SetUnionFormatStringOffset( Offset );
}

long                    
CG_UNION::GetFormatStringOffset()
{
    CCB *       pCCB;
    CG_NDR *    pParamOrFieldNode;

    pCCB = GetCCB();

    pParamOrFieldNode = pCCB->GetLastPlaceholderClass();

    if ( pParamOrFieldNode->GetCGID() == ID_CG_PARAM )
        return ((CG_PARAM *)pParamOrFieldNode)->GetUnionFormatStringOffset();
    else
        return ((CG_FIELD *)pParamOrFieldNode)->GetUnionFormatStringOffset();
}

void
CG_ENCAPSULATED_STRUCT::GenNdrPointerFixUp( CCB *       pCCB,
                                            CG_STRUCT * pStruct )
{
    //
    // For an encapsulated struct, call this method on the actual union. 
    // Remember that the encap struct's child is a CG_FIELD whose sibling's
    // child will be the actual union.
    //
    ((CG_UNION*)(GetChild()->GetSibling()->GetChild()))->
        GenNdrPointerFixUp( pCCB, pStruct );
}

void
CG_UNION::GenNdrPointerFixUp( CCB *       pCCB,
                              CG_STRUCT * pStruct )
{
    CG_ITERATOR     Iterator;
    CG_NDR *        pMember;
    CG_NDR *        pNdr;
    long            OffsetOffset;

    if ( IsInFixUp() )
        return;

    SetFixUpLock( TRUE );

    OffsetOffset = GetNdrSizeAndArmDescriptionOffset() + 4;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pMember ) )
        {
        if ( ! pMember->GetChild() ||
             ! pMember->GetChild()->GetChild() )
            {
            OffsetOffset += 6;
            continue;
            }

        //
        // Child of the case is a CG_FIELD - get it's child to get the 
        // actual Ndr entity.
        //
        pNdr = (CG_NDR *) pMember->GetChild()->GetChild();

        if ( pNdr == pStruct )
            {
            //
            // Patch up the offset.
            //
            OffsetOffset += 4;

            pCCB->GetFormatString()->PushShortOffset(
                        pStruct->GetFormatStringOffset() - OffsetOffset,
                        OffsetOffset );

            OffsetOffset += 2;
            continue;
            }

        if ( (pNdr->GetCGID() == ID_CG_PTR) ||
             (pNdr->GetCGID() == ID_CG_SIZE_PTR) ||
             (pNdr->GetCGID() == ID_CG_SIZE_LENGTH_PTR) )
            {
            CG_POINTER * pPointer = (CG_POINTER *) pNdr;

            //
            // Check if we're ready for this guy yet.
            //
            if ( pPointer->GetFormatStringOffset() == -1 ) 
                continue;

            // Get the pointee.
            pNdr = (CG_NDR *) pNdr->GetChild();

            //
            // If the pointer's pointee is the struct we're checking for,
            // then patch up the pointer's offset_to_description<2> field.
            //
            if ( pNdr == pStruct )
                {
                long    PointerOffset;

                //
                // Get the offset in the format string where the
                // offset_to_description<2> field of the pointer is.
                //
                PointerOffset = pPointer->GetFormatStringOffset() + 2;

                pCCB->GetFormatString()->PushShortOffset(
                        pStruct->GetFormatStringOffset() - PointerOffset,
                        PointerOffset );

                OffsetOffset += 6;
                continue;
                }
            }

        //
        // Continue the chase if necessary.
        //
        if ( pNdr->IsStruct() || pNdr->IsUnion() || pNdr->IsArray() )
            pNdr->GenNdrPointerFixUp( pCCB, pStruct );

        OffsetOffset += 6;
        }

    SetFixUpLock( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\codegen\uniongen.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	uniongen.cxx

 Abstract:

	union base in-line stuff.

 Notes:


 History:

	Jan-06-1994		VibhasC		Created
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/


CG_STATUS
CG_UNION::S_GenInitOutLocals(
	CCB		*	pCCB )
	{
	char Buffer[ 256 ];
	RESOURCE * pResource;
	PNAME		p;
	CG_NDR	*	pLPC = pCCB->GetLastPlaceholderClass();

	sprintf( Buffer, "%s", pLPC->GetType()->GetSymName() );

	p = pCCB->GenTRNameOffLastParam( Buffer );

	pResource = pCCB->GetLocalResource( p );

	// There is a pointer for the top level structure.

	Out_Assign( pCCB,
				pCCB->GetSourceExpression(),
				MakeAddressExpressionNoMatterWhat( pResource )
			  );

	if( HasPointer() )
		{
		expr_node	*	pSrc = pCCB->GetSourceExpression();

		// BUGBUG: Embedded structure are not inited yet!!
		// It is enough to emit code to set just the first pointer field to
		// 0. Guess why ?. Base type fields need not be set to 0.

		expr_proc_call * pProc = new expr_proc_call( MIDL_MEMSET_RTN_NAME );
		pProc->SetParam( new expr_param( pSrc ) );
		pProc->SetParam( new expr_param( new expr_constant( 0L ) ) );
		pProc->SetParam( new expr_param( new expr_sizeof( GetType())));
		pCCB->GetStream()->NewLine();
		pProc->PrintCall( pCCB->GetStream(), 0, 0 );
		}

	return CG_OK;
	}

short
CG_UNION::GetPointerMembers(
	ITERATOR&	I )
	{
	CG_ITERATOR	M;
	CG_CASE	*	pCase;
	short		Count = 0;

	if( HasPointer() )
		{
		GetMembers( M );

		while( ITERATOR_GETNEXT( M, pCase ) )
			{
			CG_FIELD	*	pField = (CG_FIELD *)pCase->GetChild();

			if((pCase->FLastCase()||(pCase->GetCGID() == ID_CG_DEFAULT_CASE))&&
			    pField && (pField->GetChild()) &&
			    pField->GetChild()->IsPointer() )
				{
				ITERATOR_INSERT( I, pField );
				Count++;
				}
			}
		}
	return Count;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\common\debug.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    debug.cxx

 Abstract:

    assert and debugging routines

 Notes:


 Author:

    mzoran Feb-25-2000     Created.

 Notes:


 ----------------------------------------------------------------------------*/

 
#if defined(MIDL_ENABLE_ASSERTS)

#include "stdio.h"
#include "common.hxx"
#include "errors.hxx"

#include "windows.h"


#pragma warning(disable: 4702)      // unreachable code


int DisplayAssertMsg(char *pFileName, int LineNumber, char *pExpr )
{
    printf( "\nmidl : error MIDL%d : internal compiler problem -",
            I_ERR_UNEXPECTED_INTERNAL_PROBLEM );
    printf( " See documentation for suggestions on how to find a workaround.\n" );
    printf( "midl: Assertion failed: %s, file %s, line %d\n", pExpr, pFileName, LineNumber );

#if DBG
    if ( IsDebuggerPresent() )
        DebugBreak();
#endif

    exit( I_ERR_UNEXPECTED_INTERNAL_PROBLEM );

    // We return int because this fuction is called from the ternary operator
    // but it actually never returns because of the exit above.  Because it
    // returns int we can't use __declspec(noreturn).  Warnings about this 
    // unreachable return statement are supressed via pragma above.

    return I_ERR_UNEXPECTED_INTERNAL_PROBLEM;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\common\errdb.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

/****************************************************************************
 ZZZ	- error in all cases
 AZZ	- no error when : app_config
 AZM	- no error when : app_config + ms_ext
 ACZ	- no error when : app_config + c_ext
 ACM	- no error when : app_config + c_ext + ms_ext
 ZCZ	- no error when : c_ext
 ZCM	- no error when : c_ext + ms_ext
 ZZM	- no error when : ms_ext

 Therefore: The following are the configurations

 -ms_ext on:	 ZZM | ZCM | ACM | AZM
 ----------
 -c_ext on:		ZCM | ZCZ | ACM | ACZ
 ----------

 -ms_ext or -c_ext on:	ZZM | ZCM | ACM | AZM | ZCZ | ACZ 
 --------------------

 -app_config on : 	AZZ | AZM | ACZ | ACM
 ----------------
 ****************************************************************************/

#include "errors.hxx"

#define ERR_ALWAYS				( ZZZ )
#define MS_EXT_SET				( ZZM | ZCM | ACM | AZM )
#define C_EXT_SET				( ZCM | ZCZ | ACM | ACZ )
#define MS_OR_C_EXT_SET			( MS_EXT_SET | C_EXT_SET )
#define APP_CONFIG_SET			( AZZ | AZM | ACZ | ACM )

typedef struct errdb
	{
    unsigned int            inApplicableEnviron;

#ifdef RPCDEBUG
	unsigned	short	TestValue;
#endif // RPCDEBUG

	E_MASK					ErrMask;
	const char	*			pError;

	} ERRDB;

const ERRDB	ErrorDataBase[]	= {

 {
0, CHECK_ERR( NO_INPUT_FILE) 
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"missing source-file name"
}

,{
0, CHECK_ERR( INPUT_OPEN)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"cannot open input file"
}

,{
0, CHECK_ERR( INPUT_READ)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"error while reading input file"
}

,{
0, CHECK_ERR( PREPROCESSOR_ERROR)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"error returned by the C preprocessor"
}

,{
0, CHECK_ERR( PREPROCESSOR_EXEC)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"cannot execute C preprocessor"
}

,{
0, CHECK_ERR( NO_PREPROCESSOR)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"cannot find C preprocessor"
}

,{
0, CHECK_ERR( PREPROCESSOR_INVALID )
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"invalid C preprocessor executable"
}

,{
0, CHECK_ERR( SWITCH_REDEFINED)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_WARN, 1 )
,"switch specified more than once on command line :"
}

,{
0, CHECK_ERR( UNKNOWN_SWITCH)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_WARN, NOWARN )
,"unknown switch"
}

,{
0, CHECK_ERR( UNKNOWN_ARGUMENT)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_WARN, 1 )
,"unknown argument ignored"
}

,{
0, CHECK_ERR( UNIMPLEMENTED_SWITCH)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_WARN, 1 )
,"switch not implemented"
}

,{
0, CHECK_ERR( MISSING_ARG)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"argument(s) missing for switch"
}

,{
0, CHECK_ERR( ILLEGAL_ARGUMENT)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"argument illegal for switch /"
}

,{
0, CHECK_ERR( BAD_SWITCH_SYNTAX)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"illegal syntax for switch"
}

,{
0, CHECK_ERR( NO_CPP_OVERRIDES)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_WARN, 1 )
,"/no_cpp overrides /cpp_cmd and /cpp_opt"
}

,{
0, CHECK_ERR( NO_WARN_OVERRIDES)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_WARN, 1 )
,"/W0 or /no_warn overrides warning-level switch"
}

,{
0, CHECK_ERR( INTERMEDIATE_FILE_CREATE)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"cannot create intermediate file"
}

,{
0, CHECK_ERR( UNUSED_ERROR_CODE1 )       // was SERVER_AUX_FILE_NOT_SPECIFIED        
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"Unused error message" 
}

,{
0, CHECK_ERR( OUT_OF_SYSTEM_FILE_HANDLES)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"out of system file handles"
}

,{
0, CHECK_ERR( UNUSED_ERROR_CODE2 )        // was BOTH_CSWTCH_SSWTCH
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"Unused error message"
}

,{
0, CHECK_ERR( CANNOT_OPEN_RESP_FILE)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"cannot open response file"
}

,{
0, CHECK_ERR( ILLEGAL_CHAR_IN_RESP_FILE)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"illegal character(s) found in response file"
}

,{
0, CHECK_ERR( MISMATCHED_PREFIX_PAIR)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"mismatch in argument pair for switch"
}

,{
0, CHECK_ERR( NESTED_RESP_FILE)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"nested invocation of response files is illegal"
}


,{
0, CHECK_ERR( ABSTRACT_DECL )
  MAKE_E_MASK( C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"must specify /c_ext for abstract declarators" 
}

,{
0, CHECK_ERR( ACTUAL_DECLARATION )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"instantiation of data is illegal; you must use \"extern\" or \"static\""
}

,{
0, CHECK_ERR( C_STACK_OVERFLOW)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"compiler stack overflow"
}

,{
0, CHECK_ERR( DUPLICATE_DEFINITION)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"redefinition"
}

,{
0, CHECK_ERR( NO_HANDLE_DEFINED_FOR_PROC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
,"[auto_handle] binding will be used"
}

,{
0, CHECK_ERR( OUT_OF_MEMORY) 
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"out of memory"
}

,{
0, CHECK_ERR( RECURSIVE_DEF)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"recursive definition"
}

,{
0, CHECK_ERR( REDUNDANT_IMPORT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
,"import ignored; file already imported :"
}

,{
0, CHECK_ERR( SPARSE_ENUM )
  MAKE_E_MASK( MS_OR_C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"sparse enums require /c_ext or /ms_ext"
}

,{
0, CHECK_ERR( UNDEFINED_SYMBOL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"undefined symbol"
}

,{
0, CHECK_ERR( UNDEFINED_TYPE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"type used in ACF file not defined in IDL file"
}

,{
0, CHECK_ERR( UNRESOLVED_TYPE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"unresolved type declaration"
}

,{
0, CHECK_ERR( WCHAR_CONSTANT_NOT_OSF )
  MAKE_E_MASK( MS_OR_C_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"use of wide-character constants requires /ms_ext or /c_ext"
}

,{
0, CHECK_ERR( WCHAR_STRING_NOT_OSF )
  MAKE_E_MASK( MS_OR_C_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"use of wide character strings requires /ms_ext or /c_ext"
}

,{
0, CHECK_ERR( WCHAR_T_ILLEGAL)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"inconsistent redefinition of type wchar_t"
}

,{
0, CHECK_ERR( TYPELIB_NOT_LOADED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"failed to load tlb in importlib:"
} 

,{
0, CHECK_ERR( TWO_LIBRARIES )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"two library blocks"
}

,{
0, CHECK_ERR( NO_IDISPATCH )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"the dispinterface statement requires a definition for IDispatch"
}

,{
0, CHECK_ERR( ERR_TYPELIB )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"error accessing type library"
}

,{
0, CHECK_ERR( ERR_TYPEINFO )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"error accessing type info"
}

,{
0, CHECK_ERR( ERR_TYPELIB_GENERATION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"error generating type library"
}

,{
0, CHECK_ERR( DUPLICATE_IID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"duplicate id"
}

,{
0, CHECK_ERR( BAD_ENTRY_VALUE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"illegal or missing value for entry attribute"
}

,{
0, CHECK_ERR( ASSUMING_CHAR)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 5 )
,"error recovery assumes"
}

,{
0, CHECK_ERR( DISCARDING_CHAR)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 5 )
,"error recovery discards"
}

,{
0, CHECK_ERR( BENIGN_SYNTAX_ERROR)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"syntax error"
}

,{
0, CHECK_ERR( SYNTAX_ERROR)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"cannot recover from earlier syntax errors; aborting compilation"
}

,{
0, CHECK_ERR( UNKNOWN_PRAGMA_OPTION)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"unknown pragma option"
}

,{
0, CHECK_ERR( UNIMPLEMENTED_FEATURE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"feature not implemented"
}

,{
0, CHECK_ERR( UNIMPLEMENTED_TYPE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"type not implemented"
}

,{
0, CHECK_ERR( EXPR_DEREF_ON_NON_POINTER)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"non-pointer used in a dereference operation"
}

,{
0, CHECK_ERR( EXPR_DIV_BY_ZERO)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"expression has a divide by zero"
}

,{
0, CHECK_ERR( EXPR_INCOMPATIBLE_TYPES)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"expression uses incompatible types"
}

,{
0, CHECK_ERR( EXPR_INDEXING_NON_ARRAY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"non-array expression uses index operator"
}

,{
0, CHECK_ERR( EXPR_LHS_NON_COMPOSITE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"left-hand side of expression does not evaluate to struct/union/enum"
}

,{
0, CHECK_ERR( EXPR_NOT_CONSTANT)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"constant expression expected"
}

,{
0, CHECK_ERR( EXPR_NOT_EVALUATABLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"expression cannot be evaluated at compile time"
}

,{
0, CHECK_ERR( EXPR_NOT_IMPLEMENTED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"expression not implemented"
}

,{
0, CHECK_ERR( NO_PTR_DEFAULT_ON_INTERFACE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"no [pointer_default] attribute specified, assuming [unique] for all unattributed pointers"
}

,{
ENV_WIN64, CHECK_ERR( NOT_OLEAUTOMATION_INTERFACE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 4 )
,"interface is not automation marshaling conformant, requires Windows NT 4.0 SP4 or greater"
}

,{
0, CHECK_ERR( DERIVES_FROM_PTR_TO_CONF )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[out] only parameter cannot be a pointer to an open structure"
}

,{
0, CHECK_ERR( DERIVES_FROM_UNSIZED_STRING )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[out] only parameter cannot be an unsized string"
}

,{
0, CHECK_ERR( NON_PTR_OUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[out] parameter is not a pointer"
}

,{
0, CHECK_ERR( OPEN_STRUCT_AS_PARAM)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"open structure cannot be a parameter"
}

,{
0, CHECK_ERR( OUT_CONTEXT_GENERIC_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[out] context handle/generic handle must be specified as a pointer to that handle type"
}

,{
0, CHECK_ERR( CTXT_HDL_TRANSMIT_AS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"context handle must not derive from a type that has the [transmit_as] attribute"
}

,{
0, CHECK_ERR( PARAM_IS_ELIPSIS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"cannot specify a variable number of arguments to a remote procedure"
}

,{
0, CHECK_ERR( VOID_PARAM_WITH_NAME)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"named parameter cannot be \"void\""
}

,{
0, CHECK_ERR( DERIVES_FROM_COCLASS_OR_MODULE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter derives from \"module\""
}

,{
0, CHECK_ERR( HANDLE_NOT_FIRST )
  MAKE_E_MASK( MS_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"only the first parameter can be a binding handle; you must specify the /ms_ext switch"
}

,{
0, CHECK_ERR( PROC_PARAM_COMM_STATUS)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"cannot use [comm_status] on both a parameter and a return type"
}

,{
0, CHECK_ERR( LOCAL_ATTR_ON_PROC)
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"[local] attribute on a procedure requires /ms_ext"
}

,{
0, CHECK_ERR( ILLEGAL_USE_OF_PROPERTY_ATTRIBUTE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"property attributes may only be used with procedures"
}

,{
0, CHECK_ERR( MULTIPLE_PROPERTY_ATTRIBUTES )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"a procedure may not have more than one property attribute"
}

,{
0, CHECK_ERR( ILLEGAL_COMBINATION_OF_ATTRIBUTES )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"the procedure has an illegal combination of operation attributes"
}

,{
0, CHECK_ERR( CONFORMANT_ARRAY_NOT_LAST)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"field deriving from a conformant array must be the last member of the structure"
}

,{
0, CHECK_ERR( DUPLICATE_CASE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"duplicate [case] label"
}

,{
0, CHECK_ERR( NO_UNION_DEFAULT)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"no [default] case specified for discriminated union"
}

,{
0, CHECK_ERR( ATTRIBUTE_ID_UNRESOLVED)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"attribute expression cannot be resolved"
}

,{
0, CHECK_ERR( ATTR_MUST_BE_INT)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"attribute expression must be of integral type; no support for 64b expressions"
}

,{
0, CHECK_ERR( BYTE_COUNT_INVALID)
  MAKE_E_MASK( MS_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"[byte_count] requires /ms_ext"
}
,{
0, CHECK_ERR( BYTE_COUNT_NOT_OUT_PTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[byte_count] can be applied only to out parameters of pointer type"
}

,{
0, CHECK_ERR( BYTE_COUNT_ON_CONF )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[byte_count] cannot be specified on a pointer to a conformant array or structure"
}

,{
0, CHECK_ERR( BYTE_COUNT_PARAM_NOT_IN )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter specifying the byte count is not [in] only or byte count parameter is not [out] only"
}

,{
0, CHECK_ERR( BYTE_COUNT_PARAM_NOT_INTEGRAL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter specifying the byte count is not an integral type"
}

,{
0, CHECK_ERR( BYTE_COUNT_WITH_SIZE_ATTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"[byte_count] cannot be specified on a parameter with size attributes"
}

,{
0, CHECK_ERR( CASE_EXPR_NOT_CONST)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[case] expression is not constant"
}

,{
0, CHECK_ERR( CASE_EXPR_NOT_INT)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[case] expression is not of integral type"
}

,{
0, CHECK_ERR( CONTEXT_HANDLE_VOID_PTR )
  MAKE_E_MASK( MS_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"specifying [context_handle] on a type other than void * requires /ms_ext"
}

,{
0, CHECK_ERR( ERROR_STATUS_T_REPEATED)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"cannot specify more than one parameter with each of comm_status/fault_status"
}

,{
0, CHECK_ERR( E_STAT_T_MUST_BE_PTR_TO_E )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"comm_status/fault_status parameter must be an [out] only pointer parameter"
}

,{
0, CHECK_ERR( ENDPOINT_SYNTAX)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"endpoint syntax error"
}

,{
0, CHECK_ERR( INAPPLICABLE_ATTRIBUTE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"inapplicable attribute"
}

,{
0, CHECK_ERR( ALLOCATE_INVALID)
  MAKE_E_MASK( MS_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"[allocate] requires /ms_ext"
}

,{
0, CHECK_ERR( INVALID_ALLOCATE_MODE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"invalid [allocate] mode"
}

,{
0, CHECK_ERR( INVALID_SIZE_ATTR_ON_STRING)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"length attributes cannot be applied with string attribute"
}

,{
0, CHECK_ERR( LAST_AND_LENGTH)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[last_is] and [length_is] cannot be specified at the same time"
}

,{
0, CHECK_ERR( MAX_AND_SIZE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[max_is] and [size_is] cannot be specified at the same time"
}

,{
0, CHECK_ERR( NO_SWITCH_IS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"no [switch_is] attribute specified at use of union"
}

,{
0, CHECK_ERR( NO_UUID_SPECIFIED)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"no [uuid] specified"
}

,{
0, CHECK_ERR( UUID_LOCAL_BOTH_SPECIFIED)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
,"[uuid] ignored on [local] interface"
}

,{
0, CHECK_ERR( SIZE_LENGTH_TYPE_MISMATCH )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"type mismatch between length and size attribute expressions"
}

,{
0, CHECK_ERR( STRING_NOT_ON_BYTE_CHAR)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[string] attribute must be specified \"byte\" \"char\" or \"wchar_t\" array or pointer"
}

,{
0, CHECK_ERR( SWITCH_TYPE_MISMATCH )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"mismatch between the type of the [switch_is] expression and the switch type of the union"
}

,{
0, CHECK_ERR( TRANSMIT_AS_CTXT_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[transmit_as] must not be applied to a type that derives from a context handle"
}

,{
0, CHECK_ERR( TRANSMIT_AS_NON_RPCABLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[transmit_as] must specify a transmissible type"
}

,{
0, CHECK_ERR( TRANSMIT_AS_POINTER )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"transmitted type for [transmit_as] and [reprsent_as] must not be a pointer or derive from a pointer"
}

,{
0, CHECK_ERR( TRANSMIT_TYPE_CONF )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"presented type for [transmit_as] and [represent_as] must not derive from a conformant/varying array or a conformant/varying structure"
}
 
,{
0, CHECK_ERR( UUID_FORMAT)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[uuid] format is incorrect"
}

,{
0, CHECK_ERR( UUID_NOT_HEX)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"uuid is not a hex number"
}

,{
0, CHECK_ERR( OPTIONAL_PARAMS_MUST_BE_LAST)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"optional parameters must come after required parameters"
}

,{
0, CHECK_ERR( DLLNAME_REQUIRED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[dllname] required when [entry] is used:"
}

,{
0, CHECK_ERR( INVALID_USE_OF_BINDABLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[bindable] is invalid without [propget], [propput], or [propputref]"
}

,{
0, CHECK_ERR( INVALID_USE_OF_PROPPUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"procedures with [propput] or [propputref] must have at least one parameter"
}

,{
0, CHECK_ERR( DISPATCH_ID_REQUIRED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[id] attribute is required"
}

,{
0, CHECK_ERR( ACF_INTERFACE_MISMATCH)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"interface name specified in the ACF file does not match that specified in the IDL file"
}

,{
0, CHECK_ERR( DUPLICATE_ATTR)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"duplicated attribute"
}

,{
0, CHECK_ERR( INVALID_COMM_STATUS_PARAM )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter with [comm_status] or [fault_status] attribute must be a pointer to type error_status_t"
}

,{
0, CHECK_ERR( LOCAL_PROC_IN_ACF)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"a [local] procedure cannot be specified in ACF file"
}

,{
0, CHECK_ERR( TYPE_HAS_NO_HANDLE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"specified type is not defined as a handle"
}

,{
0, CHECK_ERR( UNDEFINED_PROC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"procedure undefined"
}

,{
0, CHECK_ERR( UNDEF_PARAM_IN_IDL)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"this parameter does not exist in the IDL file"
}

,{
0, CHECK_ERR( ARRAY_BOUNDS_CONSTRUCT_BAD )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"this array bounds construct is not supported"
}

,{
0, CHECK_ERR( ILLEGAL_ARRAY_BOUNDS)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"array bound specification is illegal"
}

,{
0, CHECK_ERR( ILLEGAL_CONFORMANT_ARRAY)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"pointer to a conformant array or an array that contains a conformant array is not supported"
}

,{
0, CHECK_ERR( UNSIZED_ARRAY)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"pointee / array does not derive any size"
}

,{
0, CHECK_ERR( NOT_FIXED_ARRAY)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"only fixed arrays and SAFEARRAYs are legal in a type library"
}

,{
0, CHECK_ERR( SAFEARRAY_USE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"SAFEARRAYs are only legal inside a library block"
}

,{
0, CHECK_ERR( CHAR_CONST_NOT_TERMINATED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"badly formed character constant"
}

,{
0, CHECK_ERR( EOF_IN_COMMENT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"end of file found in comment"
}

,{
0, CHECK_ERR( EOF_IN_STRING )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"end of file found in string"
}

,{
0, CHECK_ERR( ID_TRUNCATED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 4 )
,"identifier length exceeds 31 characters"
}

,{
0, CHECK_ERR( NEWLINE_IN_STRING )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"end of line found in string"
}

,{
0, CHECK_ERR( STRING_TOO_LONG )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"string constant exceeds limit of 255 characters"
}

,{
0, CHECK_ERR( IDENTIFIER_TOO_LONG )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"identifier exceeds limit of 255 characters and has been truncated"
}

,{
0, CHECK_ERR( CONSTANT_TOO_BIG )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"constant too big"
}

,{
0, CHECK_ERR( ERROR_PARSING_NUMERICAL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"numerical parsing error"
}

,{
0, CHECK_ERR( ERROR_OPENING_FILE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"error in opening file"
}

,{
0, CHECK_ERR( ERR_BIND )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"error binding to function"
}

,{
0, CHECK_ERR( ERR_INIT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"error initializing OLE"
}

,{
0, CHECK_ERR( ERR_LOAD )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"error loading library"
}

,{
0, CHECK_ERR( UNIQUE_FULL_PTR_OUT_ONLY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[out] only parameter must not derive from a top-level [unique] or [ptr] pointer/array"
}

,{
0, CHECK_ERR( BAD_ATTR_NON_RPC_UNION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"attribute is not applicable to this non-rpcable union"
}

,{
0, CHECK_ERR( SIZE_SPECIFIER_CANT_BE_OUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"expression used for a size attribute must not derive from an [out] only parameter"
}

,{
0, CHECK_ERR( LENGTH_SPECIFIER_CANT_BE_OUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"expression used for a length attribute for an [in] parameter cannot derive from an [out] only parameter"
}

,{
0, CHECK_ERR( BAD_CON_INT )
  MAKE_E_MASK( C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"use of \"int\" needs /c_ext"
}

,{
0, CHECK_ERR( BAD_CON_FIELD_VOID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"struct/union field must not be \"void\""
}

,{
0, CHECK_ERR( BAD_CON_ARRAY_VOID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"array element must not be \"void\""
}

,{
0, CHECK_ERR( BAD_CON_MSC_CDECL )
  MAKE_E_MASK( C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"use of type qualifiers and/or modifiers needs /c_ext"
}

,{
0, CHECK_ERR( BAD_CON_FIELD_FUNC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"struct/union field must not derive from a function"
}

,{
0, CHECK_ERR( BAD_CON_ARRAY_FUNC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"array element must not be a function"
}

,{
0, CHECK_ERR( BAD_CON_PARAM_FUNC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter must not be a function"
}

,{
0, CHECK_ERR( BAD_CON_BIT_FIELDS )
  MAKE_E_MASK( C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"struct/union with bit fields needs /c_ext"
}

,{
0, CHECK_ERR( BAD_CON_BIT_FIELD_NON_ANSI)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 4 )
,"bit field specification on a type other that \"int\" is a non-ANSI-compatible extension"
}

,{
0, CHECK_ERR( BAD_CON_BIT_FIELD_NOT_INTEGRAL)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"bit field specification can be applied only to simple, integral types"
}

,{
0, CHECK_ERR( BAD_CON_CTXT_HDL_FIELD )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"struct/union field must not derive from handle_t or a context_handle"
}

,{
0, CHECK_ERR( BAD_CON_CTXT_HDL_ARRAY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"array element must not derive from handle_t or a context-handle"
}

,{
0, CHECK_ERR( BAD_CON_NON_RPC_UNION )
  MAKE_E_MASK( C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"this specification of union needs /c_ext"
}

,{
ENV_WIN64, CHECK_ERR( NON_RPC_PARAM_INT )
  MAKE_E_MASK( MS_OR_C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"parameter deriving from an \"int\" must have size specifier \"small\", \"short\", or \"long\" with the \"int\""
}

,{
0, CHECK_ERR( NON_RPC_PARAM_VOID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"type of the parameter cannot derive from void or void *"
}

,{
0, CHECK_ERR( NON_RPC_PARAM_BIT_FIELDS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter deriving from a struct/union containing bit fields is not supported"
}

,{
0, CHECK_ERR( NON_RPC_PARAM_CDECL )
  MAKE_E_MASK( C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"use of a parameter deriving from a type containing type-modifiers/type-qualifiers needs /c_ext"
}

,{
0, CHECK_ERR( NON_RPC_PARAM_FUNC_PTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter must not derive from a pointer to a function"
}

,{
0, CHECK_ERR( NON_RPC_UNION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter must not derive from a non-rpcable union"
}

,{
0, CHECK_ERR( NON_RPC_RTYPE_INT )
  MAKE_E_MASK( MS_OR_C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"return type derives from an \"int\". You must use size specifiers with the \"int\""
}

,{
0, CHECK_ERR( NON_RPC_RTYPE_VOID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"return type must not derive from a void pointer"
}

,{
0, CHECK_ERR( NON_RPC_RTYPE_BIT_FIELDS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"return type must not derive from a struct/union containing bit-fields"
}

,{
0, CHECK_ERR( NON_RPC_RTYPE_UNION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"return type must not derive from a non-rpcable union"
}

,{
0, CHECK_ERR( NON_RPC_RTYPE_FUNC_PTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"return type must not derive from a pointer to a function"
}

,{
0, CHECK_ERR( COMPOUND_INITS_NOT_SUPPORTED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"compound initializers are not supported"
}

,{
0, CHECK_ERR( ACF_IN_IDL_NEEDS_APP_CONFIG )
  MAKE_E_MASK( APP_CONFIG_SET , C_MSG, CLASS_ERROR, NOWARN )
,"ACF attributes in the IDL file need the /app_config switch"
}

,{
0, CHECK_ERR( SINGLE_LINE_COMMENT )
  MAKE_E_MASK( MS_OR_C_EXT_SET , C_MSG, CLASS_WARN, 1 )
,"single line comment needs /ms_ext or /c_ext"
}

,{
0, CHECK_ERR( VERSION_FORMAT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[version] format is incorrect"
}

,{
0, CHECK_ERR( SIGNED_ILLEGAL )
  MAKE_E_MASK( MS_OR_C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"\"signed\" needs /ms_ext or /c_ext"
}

,{
0, CHECK_ERR( ASSIGNMENT_TYPE_MISMATCH )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"mismatch in assignment type"
}

,{
0, CHECK_ERR( ILLEGAL_OSF_MODE_DECL )
  MAKE_E_MASK( MS_OR_C_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"declaration must be of the form: const <type><declarator> = <initializing expression> "
}

,{
0, CHECK_ERR( OSF_DECL_NEEDS_CONST )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"declaration must have \"const\""
}

,{
0, CHECK_ERR( COMP_DEF_IN_PARAM_LIST )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"struct/union/enum must not be defined in a parameter type specification"
}

,{
0, CHECK_ERR( ALLOCATE_NOT_ON_PTR_TYPE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[allocate] attribute must be applied only on non-void pointer types"
}

,{
0, CHECK_ERR( ARRAY_OF_UNIONS_ILLEGAL )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"array or equivalent pointer construct cannot derive from a non-encapsulated union"
}

,{
0, CHECK_ERR( BAD_CON_E_STAT_T_FIELD )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field must not derive from an error_status_t type"
}

,{
0, CHECK_ERR( CASE_LABELS_MISSING_IN_UNION )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"union has at least one arm without a case label"
}

,{
0, CHECK_ERR( BAD_CON_PARAM_RT_IGNORE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"parameter or return type must not derive from a type that has [ignore] applied to it"
}

,{
0, CHECK_ERR( MORE_THAN_ONE_PTR_ATTR )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"pointer already has a pointer-attribute applied to it"
}

,{
0, CHECK_ERR( RECURSION_THRU_REF )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field/parameter must not derive from a structure that is recursive through a ref pointer"
}

,{
0, CHECK_ERR( BAD_CON_FIELD_VOID_PTR )
  MAKE_E_MASK( C_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"use of field deriving from a void pointer needs /c_ext"
}

,{
0, CHECK_ERR( INVALID_OSF_ATTRIBUTE )
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"use of this attribute needs /ms_ext"
}

,{
ENV_WIN64, CHECK_ERR( INVALID_NEWTLB_ATTRIBUTE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"this attribute only allowed with new format type libraries"
}

,{
0, CHECK_ERR( WCHAR_T_INVALID_OSF )
  MAKE_E_MASK( MS_OR_C_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"use of wchar_t needs /ms_ext or /c_ext"
}

,{
0, CHECK_ERR( BAD_CON_UNNAMED_FIELD )
  MAKE_E_MASK( MS_OR_C_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"unnamed fields need /ms_ext or /c_ext"
}

,{
0, CHECK_ERR( BAD_CON_UNNAMED_FIELD_NO_STRUCT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"unnamed fields can derive only from struct/union types"
}

,{
0, CHECK_ERR( BAD_CON_UNION_FIELD_CONF )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field of a union cannot derive from a conformant/varying array or its pointer equivalent"
}

,{
0, CHECK_ERR( PTR_WITH_NO_DEFAULT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"no [pointer_default] attribute specified, assuming [ptr] for all unattributed pointers in interface"
}

,{
0, CHECK_ERR( RHS_OF_ASSIGN_NOT_CONST )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"initializing expression must resolve to a constant expression"
}

,{
0, CHECK_ERR( SWITCH_IS_TYPE_IS_WRONG )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"attribute expression must be of type integer, char, boolean or enum"
}

,{
0, CHECK_ERR( ILLEGAL_CONSTANT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"illegal constant"
}

,{
0, CHECK_ERR( IGNORE_UNIMPLEMENTED_ATTRIBUTE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"attribute not implemented; ignored"
}

,{
0, CHECK_ERR( BAD_CON_REF_RT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"return type must not derive from a [ref] pointer"
}

,{
0, CHECK_ERR( ATTRIBUTE_ID_MUST_BE_VAR )
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"attribute expression must be a variable name or a pointer dereference expression in this mode. You must specify the /ms_ext switch"
}

,{
0, CHECK_ERR( RECURSIVE_UNION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter must not derive from a recursive non-encapsulated union"
}

,{
0, CHECK_ERR( BINDING_HANDLE_IS_OUT_ONLY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"binding-handle parameter cannot be [out] only"
}

,{
0, CHECK_ERR( PTR_TO_HDL_UNIQUE_OR_FULL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"pointer to a handle cannot be [unique] or [ptr]"
}

,{
0, CHECK_ERR( HANDLE_T_NO_TRANSMIT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter that is not a binding handle must not derive from handle_t"
}

,{
0, CHECK_ERR( UNEXPECTED_END_OF_FILE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"unexpected end of file found"
}

,{
0, CHECK_ERR( HANDLE_T_XMIT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"type deriving from handle_t must not have [transmit_as] applied to it"
}

,{
0, CHECK_ERR( CTXT_HDL_GENERIC_HDL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[context_handle] must not be applied to a type that has [handle] applied to it"
}

,{
0, CHECK_ERR( GENERIC_HDL_VOID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[handle] must not be specified on a type deriving from void or void *"
}

,{
0, CHECK_ERR( NO_EXPLICIT_IN_OUT_ON_PARAM )
  MAKE_E_MASK( MS_OR_C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"parameter must have either [in], [out] or [in,out] in this mode. You must specify /ms_ext or /c_ext"
}

,{
0, CHECK_ERR( TRANSMIT_AS_VOID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"transmitted type may not derive from \"void\" for [transmit_as], [represent_as], [wire_marshal], [user_marshal]."
}

,{
0, CHECK_ERR( VOID_NON_FIRST_PARAM )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"\"void\" must be specified on the first and only parameter specification"
}

,{
0, CHECK_ERR( SWITCH_IS_ON_NON_UNION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[switch_is] must be specified only on a type deriving from a non-encapsulated union"
}

,{
0, CHECK_ERR( STRINGABLE_STRUCT_NOT_SUPPORTED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"stringable structures are not implemented in this version"
}

,{
0, CHECK_ERR( SWITCH_TYPE_TYPE_BAD )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"switch type can only be integral, char, boolean or enum"
}

,{
0, CHECK_ERR( GENERIC_HDL_HANDLE_T )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[handle] must not be specified on a type deriving from handle_t"
}

,{
0, CHECK_ERR( HANDLE_T_CANNOT_BE_OUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter deriving from handle_t must not be an [out] parameter"
}

,{
0, CHECK_ERR( SIZE_LENGTH_SW_UNIQUE_OR_FULL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
,"attribute expression derives from [unique] or [ptr] pointer dereference"
}

,{
0, CHECK_ERR( CPP_QUOTE_NOT_OSF )
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"\"cpp_quote\" requires /ms_ext"
}

,{
0, CHECK_ERR( QUOTED_UUID_NOT_OSF )
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"quoted uuid requires /ms_ext"
}

,{
0, CHECK_ERR( RETURN_OF_UNIONS_ILLEGAL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"return type cannot derive from a non-encapsulated union"
}

,{
0, CHECK_ERR( RETURN_OF_CONF_STRUCT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"return type cannot derive from a conformant structure"
}

,{
0, CHECK_ERR( XMIT_AS_GENERIC_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[transmit_as] must not be applied to a type deriving from a generic handle"
}

,{
0, CHECK_ERR( GENERIC_HANDLE_XMIT_AS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[handle] must not be applied to a type that has [transmit_as] applied to it"
}

,{
0, CHECK_ERR( INVALID_CONST_TYPE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"type specified for the const declaration is invalid"
}

,{
0, CHECK_ERR( INVALID_SIZEOF_OPERAND )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"operand to the sizeof operator is not supported"
}

,{
0, CHECK_ERR( NAME_ALREADY_USED )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"this name already used as a const identifier name"
}

,{
0, CHECK_ERR( ERROR_STATUS_T_ILLEGAL )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"inconsistent redefinition of type error_status_t"
}

,{
0, CHECK_ERR( CASE_VALUE_OUT_OF_RANGE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"[case] value out of range of switch type"
}

,{
0, CHECK_ERR( WCHAR_T_NEEDS_MS_EXT_TO_RPC )
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"parameter deriving from wchar_t needs /ms_ext"
}

,{
0, CHECK_ERR( INTERFACE_ONLY_CALLBACKS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"this interface has only callbacks"
}

,{
0, CHECK_ERR( REDUNDANT_ATTRIBUTE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"redundantly specified attribute; ignored"
}

,{
0, CHECK_ERR( CTXT_HANDLE_USED_AS_IMPLICIT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"context handle type used for an implicit handle"
}

,{
0, CHECK_ERR( CONFLICTING_ALLOCATE_OPTIONS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"conflicting options specified for [allocate]"
}

,{
0, CHECK_ERR( ERROR_WRITING_FILE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"error while writing to file"
}

,{
0, CHECK_ERR( NO_SWITCH_TYPE_AT_DEF )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"no switch type found at definition of union, using the [switch_is] type"
}

,{
0, CHECK_ERR( ERRORS_PASS1_NO_PASS2 )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"semantic check incomplete due to previous errors"
}

,{
0, CHECK_ERR( HANDLES_WITH_CALLBACK )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"handle parameter or return type is not supported on a [callback] procedure"
}

,{
0, CHECK_ERR( PTR_NOT_FULLY_IMPLEMENTED )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"[ptr] does not support aliasing in this version"
}

,{
0, CHECK_ERR( PARAM_ALREADY_CTXT_HDL )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"parameter already defined as a context handle"
}

,{
0, CHECK_ERR( CTXT_HDL_HANDLE_T )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[context_handle] must not derive from handle_t"
}

,{
0, CHECK_ERR( ARRAY_SIZE_EXCEEDS_64K )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"array size exceeds 65536 bytes"
}

,{
0, CHECK_ERR( STRUCT_SIZE_EXCEEDS_64K )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"struct size exceeds 65536 bytes"
}

,{
0, CHECK_ERR( NE_UNION_FIELD_NE_UNION )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field of a non-encapsulated union cannot be another non-encapsulated union"
}

,{
0, CHECK_ERR( PTR_ATTRS_ON_EMBEDDED_ARRAY )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"pointer attribute(s) applied on an embedded array; ignored"
}

,{
0, CHECK_ERR( ALLOCATE_ON_TRANSMIT_AS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[allocate] is illegal on either the transmitted or presented type for [transmit_as], [represent_as], [wire_marshal], or [user_marshal]."
}

,{
0, CHECK_ERR( SWITCH_TYPE_REQD_THIS_IMP_MODE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[switch_type] must be specified in this import mode"
}

,{
0, CHECK_ERR( IMPLICIT_HDL_ASSUMED_GENERIC )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"[implicit_handle] type undefined; assuming generic handle"
}

,{
0, CHECK_ERR( E_STAT_T_ARRAY_ELEMENT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"array element must not derive from error_status_t"
}

,{
0, CHECK_ERR( ALLOCATE_ON_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[allocate] illegal on a type deriving from a primitive/generic/context handle"
}

,{
0, CHECK_ERR( TRANSMIT_AS_ON_E_STAT_T )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"transmitted or presented type must not derive from error_status_t"
}

,{
0, CHECK_ERR( IGNORE_ON_DISCRIMINANT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"discriminant of a union must not derive from a field with [ignore] applied to it"
}

,{
0, CHECK_ERR( NOCODE_WITH_SERVER_STUBS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 4 )
,"[nocode] ignored for server side since \"/server none\" not specified"
}

,{
0, CHECK_ERR( NO_REMOTE_PROCS_NO_STUBS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"no remote procedures specified in non-[local] interface; no client/server stubs will be generated"
}

,{
0, CHECK_ERR( TWO_DEFAULT_CASES )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"too many default cases specified for encapsulated union"
}

,{
0, CHECK_ERR( TWO_DEFAULT_INTERFACES )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"too many default interfaces specified for coclass"
}

,{
0, CHECK_ERR( DEFAULTVTABLE_REQUIRES_SOURCE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"items with [defaultvtable] must also have [source]"
}

,{
0, CHECK_ERR( UNION_NO_FIELDS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"union specification with no fields is illegal"
}

,{
0, CHECK_ERR( VALUE_OUT_OF_RANGE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"value out of range"
}

,{
0, CHECK_ERR( CTXT_HDL_NON_PTR )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[context_handle] must be applied on a pointer type"
}

,{
0, CHECK_ERR( NON_RPC_RTYPE_HANDLE_T )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"return type must not derive from handle_t"
}

,{
0, CHECK_ERR( GEN_HDL_CTXT_HDL )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[handle] must not be applied to a type deriving from a context handle"
}

,{
ENV_WIN64, CHECK_ERR( NON_RPC_FIELD_INT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field deriving from an \"int\" must have size specifier \"small\", \"short\", or \"long\" with the \"int\""
}

,{
0, CHECK_ERR( NON_RPC_FIELD_PTR_TO_VOID )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field must not derive from a void or void *"
}

,{
0, CHECK_ERR( NON_RPC_FIELD_BIT_FIELDS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field must not derive from a struct containing bit-fields"
}

,{
0, CHECK_ERR( NON_RPC_FIELD_NON_RPC_UNION )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field must not derive from a non-rpcable union"
}

,{
0, CHECK_ERR( NON_RPC_FIELD_FUNC_PTR )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field must not derive from a pointer to a function"
}

,{
0, CHECK_ERR( PROC_PARAM_FAULT_STATUS)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"cannot use [fault_status] on both a parameter and a return type"
}

,{
0, CHECK_ERR( NON_OI_BIG_RETURN )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"return type too complicated for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( NON_OI_BIG_GEN_HDL )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"generic handle type too large for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( ALLOCATE_IN_OUT_PTR )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 4 )
,"[allocate(all_nodes)] on an [in,out] parameter may orphan the original memory"
}

,{
0, CHECK_ERR( REF_PTR_IN_UNION)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"cannot have a [ref] pointer as a union arm"
}

,{
0, CHECK_ERR( NON_OI_CTXT_HDL )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"return of context handles not supported for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( NON_OI_ERR_STATS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"use of the extra [comm_status] or [fault_status] parameter not supported for /Oi* modes, using /Os"
}

,{
0, CHECK_ERR( NON_OI_UNK_REP_AS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"use of an unknown type for [represent_as] or [user_marshal] not supported for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( NON_OI_XXX_AS_ON_RETURN )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"array types with [transmit_as] or [represent_as] not supported on return type for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( NON_OI_XXX_AS_BY_VALUE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"array types with [transmit_as] or [represent_as] not supported pass-by-value for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( CALLBACK_NOT_OSF )
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"[callback] requires /ms_ext"
}

,{
0, CHECK_ERR( CIRCULAR_INTERFACE_DEPENDENCY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"circular interface dependency"
}

,{
0, CHECK_ERR( NOT_VALID_AS_BASE_INTF )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"only IUnknown may be used as the root interface"
}

,{
0, CHECK_ERR( IID_IS_NON_POINTER )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[IID_IS] may only be applied to pointers to interfaces"
}

,{
0, CHECK_ERR( INTF_NON_POINTER )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"interfaces may only be used in pointer-to-interface constructs"
}

,{
0, CHECK_ERR( PTR_INTF_NO_GUID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"interface pointers must have a UUID/IID"
}

,{
0, CHECK_ERR( OUTSIDE_OF_INTERFACE )
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"definitions and declarations outside of interface body requires /ms_ext"
}

,{
0, CHECK_ERR( MULTIPLE_INTF_NON_OSF )
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"multiple interfaces in one file requires /ms_ext"
}

,{
0, CHECK_ERR( CONFLICTING_INTF_HANDLES )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"only one of [implicit_handle], [auto_handle], or [explicit_handle] allowed"
}

,{
0, CHECK_ERR( IMPLICIT_HANDLE_NON_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[implicit_handle] references a type which is not a handle"
}

,{
0, CHECK_ERR( OBJECT_PROC_MUST_BE_WIN32 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[object] procs may only be used with \"/env win32\""
}

,{
ENV_WIN64, CHECK_ERR( _OBSOLETE_NON_OI_16BIT_CALLBACK )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,""
//,"[callback] with -env dos/win16 not supported for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( NON_OI_TOPLEVEL_FLOAT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"float/double not supported as top-level parameter for /Oi mode, using /Os"
}

,{
0, CHECK_ERR( CTXT_HDL_MUST_BE_DIRECT_RETURN )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"pointers to context handles may not be used as return values"
}

,{
0, CHECK_ERR( OBJECT_PROC_NON_HRESULT_RETURN )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"procedures in an object interface must return an HRESULT"
}

,{
0, CHECK_ERR( DUPLICATE_UUID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"duplicate UUID. Same as"
}

,{
0, CHECK_ERR( ILLEGAL_INTERFACE_DERIVATION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"[object] interfaces must derive from another [object] interface such as IUnknown"
}

,{
0, CHECK_ERR( ILLEGAL_BASE_INTERFACE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"(async) interface must derive from another (async) interface"
}

,{
0, CHECK_ERR( IID_IS_EXPR_NON_POINTER )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[IID_IS] expression must be a pointer to IID structure"
}

,{
0, CHECK_ERR( CALL_AS_NON_LOCAL_PROC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[call_as] type must be a [local] procedure"
}

,{
0, CHECK_ERR( CALL_AS_UNSPEC_IN_OBJECT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"undefined [call_as] must not be used in an object interface"
}

,{
0, CHECK_ERR( ENCODE_AUTO_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[auto_handle] may not be used with [encode] or [decode]"
}

,{
0, CHECK_ERR( RPC_PROC_IN_ENCODE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"normal procs are not allowed in an interface with [encode] or [decode]"
}

,{
0, CHECK_ERR( ENCODE_CONF_OR_VAR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"top-level conformance or variance not allowed with [encode] or [decode]"
}

,{
0, CHECK_ERR( CONST_ON_OUT_PARAM )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"[out] parameters may not have \"const\""
}

,{
0, CHECK_ERR( CONST_ON_RETVAL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"return values may not have \"const\""
}

,{
0, CHECK_ERR( INVALID_USE_OF_RETVAL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"invalid use of \"retval\" attribute"
}

,{
0, CHECK_ERR( MULTIPLE_CALLING_CONVENTIONS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"multiple calling conventions illegal"
}

,{
0, CHECK_ERR( INAPPROPRIATE_ON_OBJECT_PROC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"attribute illegal on [object] procedure"
}

,{
0, CHECK_ERR( NON_INTF_PTR_PTR_OUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[out] interface pointers must use double indirection"
}

,{
0, CHECK_ERR( CALL_AS_USED_MULTIPLE_TIMES )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"procedure used twice as the caller in [call_as]"
}

,{
0, CHECK_ERR( OBJECT_CALL_AS_LOCAL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"[call_as] target must have [local] in an object interface"
}

,{
0, CHECK_ERR( CODE_NOCODE_CONFLICT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"[code] and [nocode] may not be used together"
}

,{
0, CHECK_ERR( MAYBE_NO_OUT_RETVALS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"procedures with [maybe] or [message] attributes may not [out] params or, "
 "return values must be of type HRESULT or error_status_t"
}

,{
0, CHECK_ERR( FUNC_NON_POINTER )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"pointer to function must be used"
}

,{
0, CHECK_ERR( FUNC_NON_RPC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"functions may not be passed in an RPC operation"
}

,{
0, CHECK_ERR( NON_OI_RETVAL_64BIT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"hyper/double not supported as return value for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( MISMATCHED_PRAGMA_POP )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"#pragma pack( pop ) without matching #pragma pack( push )"
}

,{
0, CHECK_ERR( WRONG_TYPE_IN_STRING_STRUCT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"stringable structure fields must be byte/char/wchar_t"
}

,{
0, CHECK_ERR( NON_OI_NOTIFY )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"[notify] not supported for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( HANDLES_WITH_OBJECT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"handle parameter or return type is not supported on a procedure in an [object] interface"
}

,{
0, CHECK_ERR( NON_ANSI_MULTI_CONF_ARRAY )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"ANSI C only allows the leftmost array bound to be unspecified"
}

,{
0, CHECK_ERR( NON_OI_UNION_PARM )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"by-value union parameters not supported for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( OBJECT_WITH_VERSION )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"[version] attribute is ignored on an [object] interface"
}

,{
0, CHECK_ERR( SIZING_ON_FIXED_ARRAYS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[size_is] or [max_is] attribute is invalid on a fixed array"
}

,{
0, CHECK_ERR( PICKLING_INVALID_IN_OBJECT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[encode] or [decode] are invalid in an [object] interface"
}

,{
0, CHECK_ERR( TYPE_PICKLING_INVALID_IN_OSF )
  MAKE_E_MASK( MS_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"[encode] or [decode] on a type requires /ms_ext"
}

,{
ENV_WIN64, CHECK_ERR( _OBSOLETE_INT_NOT_SUPPORTED_ON_INT16 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,""
//,"\"int\" not supported on /env win16 or /env dos"
}

,{
0, CHECK_ERR( BSTRING_NOT_ON_PLAIN_PTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[bstring] may only be applied to a pointer to \"char\" or \"wchar_t\""
}

,{
0, CHECK_ERR( INVALID_ON_OBJECT_PROC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"attribute invalid on a proc in an [object] interface :"
}

,{
0, CHECK_ERR( INVALID_ON_OBJECT_INTF )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"attribute invalid on an [object] interface :"
}

,{
ENV_WIN64, CHECK_ERR( STACK_TOO_BIG )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
,"too many parameters or stack too big for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( NO_ATTRS_ON_ACF_TYPEDEF )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
,"no attributes on ACF file typedef, so no effect"
}

,{
0, CHECK_ERR( NON_OI_WRONG_CALL_CONV )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"calling conventions other than __stdcall or __cdecl not supported for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( TOO_MANY_DELEGATED_PROCS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"too many delegation methods in the interface, requires Windows 2000 or greater "
}

,{
ENV_WIN64, CHECK_ERR( _OBSOLETE_NO_MAC_AUTO_HANDLES )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,""
//,"auto handles not supported with -env mac or -env powermac"
}

,{
0, CHECK_ERR( ILLEGAL_IN_MKTYPLIB_MODE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"statements outside library block are illegal in mktyplib compatability mode"
}

,{
0, CHECK_ERR( ILLEGAL_USE_OF_MKTYPLIB_SYNTAX)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"illegal syntax unless using mktyplib compatibility mode"
}

,{
0, CHECK_ERR( ILLEGAL_SU_DEFINITION)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"illegal definition, must use typedef in mktyplib compatibility mode"
}

,{
0, CHECK_ERR( INTF_EXPLICIT_PTR_ATTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"explicit pointer attribute [ptr] [ref] ignored for interface pointers"
}

,{
ENV_WIN64, CHECK_ERR( _OBSOLETE_NO_OI_ON_MPPC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,""
//,"Oi modes not implemented for PowerMac, switching to Os"
}

,{
0, CHECK_ERR( ILLEGAL_EXPRESSION_TYPE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"illegal expression type used in attribute"
}

,{
0, CHECK_ERR( ILLEGAL_PIPE_TYPE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"illegal type used in pipe"
}

,{
0, CHECK_ERR( REQUIRES_OI2 )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"procedure uses pipes, using /Oicf"
}

,{
0, CHECK_ERR( ASYNC_REQUIRES_OI2 )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"procedure has an attribute that requires use of /Oicf, switching modes"
}

,{
0, CHECK_ERR( CONFLICTING_OPTIMIZATION_REQUIREMENTS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"conflicting optimization requirements, cannot optimize"
}

,{
0, CHECK_ERR( ILLEGAL_PIPE_EMBEDDING )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"pipes cannot be array elements, or members of structures or unions"
}

,{
0, CHECK_ERR( ILLEGAL_PIPE_CONTEXT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"invalid pipe usage"
}

,{
0, CHECK_ERR( CMD_REQUIRES_I2 )
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"feature requires the advanced interpreted optimization option, use -Oicf :"
}

,{
0, CHECK_ERR( REQUIRES_I2 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 3 )
,"feature requires the advanced interpreted optimization option, use -Oicf :"
}

// The following 4 errors aren't used but sit here to get 
// the MSDN error numbers correct.

,{
0, CHECK_ERR( CMD_REQUIRES_NT40 )
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"feature invalid for the specified target system, use -target NT40 :"
}

,{
0, CHECK_ERR( CMD_REQUIRES_NT351 )
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"feature invalid for the specified target system, use -target NT351 :"
}

,{
0, CHECK_ERR( REQUIRES_NT40 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"feature invalid for the specified target system, use -target NT40"
}

,{
0, CHECK_ERR( REQUIRES_NT351 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"feature invalid for the specified target system, use -target NT351"
}

,{
0, CHECK_ERR( CMD_OI1_PHASED_OUT )
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_WARN, 1 )
,"the optimization option is being phased out, use -Oicf :"
}

,{
0, CHECK_ERR( CMD_OI2_OBSOLETE )
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_WARN, 1 )
,"the optimization option is being phased out, use -Oicf :"
}

,{
0, CHECK_ERR( OI1_PHASED_OUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"the optimization option is being phased out, use -ic "
}

,{
0, CHECK_ERR( OI2_OBSOLETE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"the optimization option is being phased out, use -icf"
}

,{
0, CHECK_ERR( ODL_OLD_NEW_OBSOLETE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"the -old and -new switches are obsolete, use -oldtlb and -newtlb"
}

,{
0, CHECK_ERR( ILLEGAL_ARG_VALUE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"illegal argument value"
}

,{
0, CHECK_ERR( CONSTANT_TYPE_MISMATCH )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"illegal expression type in constant"
}

,{
0, CHECK_ERR( ENUM_TYPE_MISMATCH )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"illegal expression type in enum"
}

,{
0, CHECK_ERR( UNSATISFIED_FORWARD )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"unsatisfied forward declaration"
}

,{
0, CHECK_ERR( CONTRADICTORY_SWITCHES )
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"switches are contradictory "
}

,{
0, CHECK_ERR( NO_SWITCH_IS_HOOKOLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"MIDL cannot generate HOOKOLE information for the non-rpcable union"
}

,{
0, CHECK_ERR( NO_CASE_EXPR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"no case expression found for union"
}

,{
0, CHECK_ERR( USER_MARSHAL_IN_OI )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[user_marshal] and [wire_marshal] not supported with -Oi and -Oic flags, use -Os or -Oicf"
}

,{
0, CHECK_ERR( PIPES_WITH_PICKLING )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"pipes can't be used with data serialization, i.e. [encode] and/or [decode]"
}

,{
0, CHECK_ERR( PIPE_INTF_PTR_PTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"all pipe interface pointers must use single indirection"
}

,{
0, CHECK_ERR( IID_WITH_PIPE_INTF_PTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[iid_is()] cannot be used with a pipe interface pointer"
}

,{
0, CHECK_ERR( INVALID_LOCALE_ID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"invalid or inapplicable -lcid switch: "
}

,{
0, CHECK_ERR( CONFLICTING_LCID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, NOWARN )
,"the specified lcid is different from previous specification"
}

,{
0, CHECK_ERR( ILLEGAL_IMPORTLIB )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"importlib is not allowed outside of a library block"
}

,{
0, CHECK_ERR( INVALID_FLOAT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"invalid floating point value"
}

,{
0, CHECK_ERR( INVALID_MEMBER )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"invalid member"
}

,{
0, CHECK_ERR( POSSIBLE_INVALID_MEMBER )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, NOWARN )
,"possible invalid member"
}

,{
0, CHECK_ERR( INTERFACE_PIPE_TYPE_MISMATCH )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"mismatch in pipe and interface types"
}

,{
0, CHECK_ERR( PIPE_INCOMPATIBLE_PARAMS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"string, varying array, conformant array and full pointer parameters are\n"
"incompatible with pipe parameters"
}

,{
0, CHECK_ERR( ASYNC_NOT_IN )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter must be in"
}

,{
0, CHECK_ERR( OBJECT_ASYNC_NOT_DOUBLE_PTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter type of an [async] object must be a double pointer to an interface"
}

,{
0, CHECK_ERR( ASYNC_INCORRECT_TYPE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"incorrect async handle type"
}

,{
0, CHECK_ERR( INTERNAL_SWITCH_USED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, NOWARN )
,"the \"internal\" switch enables unsupported features, use with caution"
}

,{
0, CHECK_ERR( ASYNC_INCORRECT_BINDING_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"async procedures cannot use auto handle"
}

,{
0, CHECK_ERR( ASYNC_INCORRECT_ERROR_STATUS_T )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"error_status_t should have both [comm_status] and [fault_status]"
}

,{
0, CHECK_ERR( NO_LIBRARY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"this construct is only allowed within a library block"
}

,{
0, CHECK_ERR( INVALID_TYPE_REDEFINITION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"invalid type redefinition"
}

,{
0, CHECK_ERR( NOT_VARARG_COMPATIBLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"procedures with [vararg] attribute must have a SAFEARRAY(VARIANT) parameter; param order is [vararg], [lcid], [retval]"
}

,{
ENV_WIN64, CHECK_ERR( TOO_MANY_PROCS_FOR_NT4 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"too many methods in the interface, requires Windows NT 4.0 SP3 or greater"
}

,{
ENV_WIN64, CHECK_ERR( TOO_MANY_PROCS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"too many methods in the interface, requires Windows 2000 or greater"
}

,{
0, CHECK_ERR( OBSOLETE_SWITCH )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"switch is being phased out"
}

,{
0, CHECK_ERR( CANNOT_INHERIT_IADVISESINK )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"cannot derive from IAdviseSink, IAdviseSink2 or IAdviseSinkEx"
}

,{
0, CHECK_ERR( DEFAULTVALUE_NOT_ALLOWED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"cannot assign a default value"
}

,{
ENV_WIN64, CHECK_ERR( _OBSOLETE_INVALID_TLB_ENV )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,""
//,"type library generation for DOS/Win16/MAC is not supported"
}

,{
0, CHECK_ERR( WARN_TYPELIB_GENERATION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"error generating type library, ignored"
}

,{
ENV_WIN64, CHECK_ERR( OI_STACK_SIZE_EXCEEDED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
,"exceeded stack size for /Oi, using /Os"
}

,{
0, CHECK_ERR( ROBUST_REQUIRES_OICF )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"use of /robust requires /Oicf, switching modes"
}

,{
0, CHECK_ERR( INCORRECT_RANGE_DEFN )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"incorrect range specified"
}

,{
0, CHECK_ERR( ASYNC_INVALID_IN_OUT_PARAM_COMBO )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"invalid combination of [in] only and [out] parameters for [async_uuid] interface"
}

,{
ENV_WIN64, CHECK_ERR( _OBSOLETE_PLATFORM_NOT_SUPPORTED )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,""
//,"DOS, Win16 and MAC platforms are not supported with /robust"
}

,{
0, CHECK_ERR( OIC_SUPPORT_PHASED_OUT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"support for NT 3.51 style stubless proxies for object interfaces will be phased out; use /Oicf: "
}

,{
0, CHECK_ERR( ROBUST_PICKLING_NO_OICF )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[encode] or [decode] with /robust requires /Oicf"
}
,{
0, CHECK_ERR( _OBSOLETE_OS_SUPPORT_PHASING_OUT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,""
//,"support for DOS, Win16 and MAC platforms is being phased out."
}

,{
0, CHECK_ERR( CONFLICTING_ATTRIBUTES )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"conflicting attributes specified"
}

,{
0, CHECK_ERR( NO_CONTEXT_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[serialize], [noserialize] can be applied to context_handles"
}

,{
0, CHECK_ERR( FORMAT_STRING_LIMITS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"the compiler reached a limit for a format string representation. See documentation for advice."
}

,{
0, CHECK_ERR( EMBEDDED_OPEN_STRUCT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"wire format may be incorrect, you may need to use -ms_conf_struct, see documentation for advice:"
}

,{
0, CHECK_ERR( STACK_SIZE_TOO_BIG )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"a stack size or an offset bigger than 64k limit. See documentation for advice."
}

,{
0, CHECK_ERR( WIN64_INTERPRETED )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 3 )
,"an interpreter mode forced for 64b platform"
}

,{
0, CHECK_ERR( ARRAY_ELEMENT_TOO_BIG )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"The array element size is bigger than 64k limit."
}

,{
0, CHECK_ERR( INVALID_USE_OF_LCID )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"there can be only one [lcid] parameter in a method, and it should be last or, second to last if last parameter has [retval]"
}

,{
0, CHECK_ERR( PRAGMA_SYNTAX_ERROR )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"incorrect syntax for midl_pragma"
}

,{
0, CHECK_ERR( INVALID_MODE_FOR_INT3264 )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"__int3264 is not supported in /osf mode"
}

,{
0, CHECK_ERR( UNSATISFIED_HREF )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"unresolved symbol in type library"
}

,{
0, CHECK_ERR( ASYNC_PIPE_BY_REF )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"async pipes cannot be passed by value"
}

,{
0, CHECK_ERR( STACK_FRAME_SIZE_EXCEEDED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter offset exceed 64k limit for interpreted procedures"
}

,{
0, CHECK_ERR( INVALID_ARRAY_ELEMENT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"invalid array element"
}

,{
0, CHECK_ERR( DISPINTERFACE_MEMBERS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"dispinterface members must be methods, properties or interface"
}

,{
0, CHECK_ERR( LOCAL_NO_CALL_AS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 4 )
,"[local] procedure without [call_as]"
}

,{
0, CHECK_ERR( MULTI_DIM_VECTOR )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"multi dimensional vector, switching to /Oicf"
}

,{
0, CHECK_ERR( NETMON_REQUIRES_OICF )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"use of /netmon requires /Oicf"
}

,{
ENV_WIN32, CHECK_ERR( NO_SUPPORT_IN_TLB )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"type or construct not supported in a library block because oleaut32.dll support for 64b polymorphic types is missing"
}

,{
0, CHECK_ERR( NO_OLD_INTERPRETER_64B )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"old interpreter code being generated for 64b"
}

,{
0, CHECK_ERR( SWITCH_NOT_SUPPORTED_ANYMORE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"the compiler switch is not supported anymore:"
}

,{
0, CHECK_ERR( SPAWN_ERROR )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"cannot execute MIDL engine"
}


,{
0, CHECK_ERR( BAD_CMD_FILE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"invalid or corrupt intermediate compiler file :"
}

,{
0, CHECK_ERR( INAPPLICABLE_OPTIONAL_ATTRIBUTE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"for oleautomation, optional parameters should be VARIANT or VARIANT *"
}

,{
0, CHECK_ERR( DEFAULTVALUE_WITH_OPTIONAL )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"[defaultvalue] is applied to a non-VARIANT and [optional]. Please remove [optional]"
}

,{
0, CHECK_ERR( OPTIONAL_OUTSIDE_LIBRARY )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"[optional] attribute is inapplicable outside of a library block"
}

,{
0, CHECK_ERR( LCID_SHOULD_BE_LONG )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"The data type of the [lcid] parameter must be long"
}

,{
0, CHECK_ERR( INVALID_PROP_PARAMS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"procedures with [propput], [propget] or [propputref] can't have more than one required parameter after [optional] one"
}

,{
0, CHECK_ERR( COMMFAULT_PICKLING_NO_OICF )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[comm_status] or [fault_status] with pickling requires -Oicf"
}

,{
0, CHECK_ERR( INCONSIST_VERSION )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"midl driver and compiler version mismatch"
}

,{
0, CHECK_ERR( NO_INTERMEDIATE_FILE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"no intermediate file specified: use midl.exe"
}

,{
0, CHECK_ERR( FAILED_TO_GENERATE_PARAM )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"processing problem with a parameter in a procedure"
}

,{
0, CHECK_ERR( FAILED_TO_GENERATE_FIELD )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"processing problem with a field in a structure"
}

,{
0, CHECK_ERR( FORMAT_STRING_OFFSET_IS_ZERO )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"internal compiler inconsistency detected: the format string offset is invalid. See the documentation for more information."
}

,{
0, CHECK_ERR( TYPE_OFFSET_IS_ZERO )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"internal compiler inconsistency detected: the type offset is invalid. See the documentation for more information."
}

,{
0, CHECK_ERR( SAFEARRAY_NOT_SUPPORT_OUTSIDE_TLB )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
," SAFEARRAY(foo) syntax is not supported outside of the library block, use LPSAFEARRAY for proxy"
}

,{
0, CHECK_ERR( FAILED_TO_GENERATE_BIT_FIELD )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"bit fields are not supported"
}

,{
0, CHECK_ERR( PICKLING_RETVAL_FORCING_OI )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"floating point or complex return types with [decode] are not supported in -Oicf, using -Oi"
}

,{
0, CHECK_ERR( PICKLING_RETVAL_TO_COMPLEX64 )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"the return type is not supported for 64-bit when using [decode]"
}

,{
0, CHECK_ERR( WIRE_HAS_FULL_PTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"transmitted type may not contain a full pointer for either [wire_marshal] or [user_marshal]"
}

,{
0, CHECK_ERR( WIRE_NOT_DEFINED_SIZE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"transmitted type must either be a pointer or have a constant size for [wire_marshal] and [user_marshal]"
}

,{
0, CHECK_ERR( INVALID_USE_OF_PROPGET )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"procedures with [propget] must have at least one parameter or a return value"
}

,{
0, CHECK_ERR( UNABLE_TO_OPEN_CMD_FILE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"Unable to open intermediate compiler file"
}

// Errors marked with CSCHAR are relics from DCE international character
// support.  This feature was pulled because of fundamental problems with 
// the spec.

,{
0, CHECK_ERR( IN_TAG_WITHOUT_IN )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
// CSCHAR ,"parameters with [cs_drtag] or [cs_stag] must be [in] parameters"
,""
}

,{
0, CHECK_ERR( OUT_TAG_WITHOUT_OUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
// CSCHAR ,"parameters with [cs_rtag] must be [out] parameters"
,""
}

,{
0, CHECK_ERR( NO_TAGS_FOR_IN_CSTYPE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
// CSCHAR ,"use of [cs_char] on [in] parameters requires parameters with [cs_stag]"
,""
}

,{
0, CHECK_ERR( NO_TAGS_FOR_OUT_CSTYPE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
// CSCHAR ,"use of [cs_char] on [out] parameters requires parameters with [cs_drtag] and [cs_rtag]"
,""
}

,{
0, CHECK_ERR( CSCHAR_EXPR_MUST_BE_SIMPLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
// CSCHAR ,"size/length expressions for cs_char arrays must be simple variables or pointers to simple variables"
,""
}

,{
0, CHECK_ERR( SHARED_CSCHAR_EXPR_VAR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
// CSCHAR ,"size/length expressions for cs_char arrays may not share variables with other size/length expressions"
,""
}

,{
0, CHECK_ERR( MSCDECL_INVALID_ALIGN )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"The alignment specified in __declspec(align(N)) must be a power of two between 1 and 8192."
}

,{
0, CHECK_ERR( DECLSPEC_ALIGN_IN_LIBRARY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"__declspec(align(N)) is not supported in a TLB"
}

,{
0, CHECK_ERR( ENCAP_UNION_ARM_ALIGN_EXCEEDS_16 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"Encapsuled union arm alignment may not exceed 16"
}

,{
0, CHECK_ERR( ILLEGAL_MODIFIERS_BETWEEN_SEUKEYWORD_AND_BRACE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "Modifiers after the keywords \"struct\", \"union\", or \"enum\" are not supported"

}

,{
0, CHECK_ERR( TYPE_NOT_SUPPORTED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "Type is not supported"
}

,{
0, CHECK_ERR( UNSPECIFIED_EMBEDDED_REPRESENT_AS_NOT_SUPPORTED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "Embedded unspecified user_marshal/represent_as is not supported"
}

,{
0, CHECK_ERR( INVALID_PACKING_LEVEL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "The packing level must be a power of two between and including 1 and 32768"
}


,{
0, CHECK_ERR( RETURNVAL_TOO_COMPLEX_FORCE_OS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
, "Return value too complex, switching to /Os"
}

,{
0, CHECK_ERR( NO_CONFORMANT_CSCHAR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
// CSCHAR , "cs_char arrays may not be conformant"
,""
}

,{
0, CHECK_ERR( NO_MULTIDIMENSIONAL_CSCHAR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
// CSCHAR , "cs_char arrays may not be multidimensional"
,""
}

,{
0, CHECK_ERR( BYTE_COUNT_IN_NDR64 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "[byte_count] has been depreciated for ndr64"
}

,{
0, CHECK_ERR( SIZE_EXCEEDS_2GB )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "The size must be less then 2GB.  See documentation for details"
}

,{
0, CHECK_ERR( ARRAY_DIMENSIONS_EXCEEDS_255 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "The array dimensions exceeds a compiler limit of 255.  See documention for details"
}
    
,{
0, CHECK_ERR( UNSPECIFIED_REP_OR_UMRSHL_IN_NDR64 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "Unspecifed [represent_as] and [user_marshal] has been depreciated for ndr64. Define the presented type" 
}

,{
0, CHECK_ERR( ASYNC_NDR64_ONLY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
, "async interface supports NDR64 only: only do this when you are sure the interface will not use DCE transfer syntax ever. use -protocol all if you are not sure" 
}

,{
0, CHECK_ERR( UNSUPPORT_NDR64_FEATURE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "ndr64 transfer syntax is not supported in 32bit platform yet"
}

,{
0, CHECK_ERR( UNSUPPORTED_LARGE_GENERIC_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "large generic handles are not supported in the ndr64 protocol" 
}

,{
0, CHECK_ERR( OS_IN_NDR64 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "The Os optimization mode is not supported in the ndr64 protocol"
}

,{
0, CHECK_ERR( UNEXPECTED_OS_IN_NDR64 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "internal compiler inconsistency detected: Os optimization in ndr64 mode"
}

,{
0, CHECK_ERR( NDR64_ONLY_TLB )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "type library needs to be generated in DCE protocol run"
}

,{
0, CHECK_ERR( PARTIAL_IGNORE_IN_OUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "[partial_ignore] can only be applied to [in, out] parameters"
}
                                     
,{
0, CHECK_ERR( PARTIAL_IGNORE_UNIQUE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "[partial_ignore] may only be used with [unique] pointers"
}

,{
0, CHECK_ERR( PARTIAL_IGNORE_PICKLING )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "[partial_ignore] cannot be used with pickling"
}

,{
0, CHECK_ERR( PARTIAL_IGNORE_NO_OI )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
, "[partial_ignore] used in /Oi mode, switching to /Oicf mode"
}

,{
0, CHECK_ERR( PARTIAL_IGNORE_IN_TLB )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "[partial_ignore] cannot be used in a TLB"
}

,{
0, CHECK_ERR( CORRELATION_DERIVES_FROM_IGNORE_POINTER )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "correlation expressions cannot use [ignore] pointers"
}

,{
0, CHECK_ERR( OUT_ONLY_FORCEALLOCATE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
, "[force_allocate] doesn't affect [out] only parameters"
}

,{
0, CHECK_ERR( FORCEALLOCATE_ON_PIPE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
, "[force_allocate] is not applicable to pipe argument"
}

,{
0, CHECK_ERR( FORCEALLOCATE_SUPPORTED_IN_OICF_ONLY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
, "use of [force_allocate] requires /Oicf, switching modes"
}

,{
0, CHECK_ERR( INVALID_FEATURE_FOR_TARGET )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "The feature cannot be used on the target system"
}

,{
0, CHECK_ERR( SAFEARRAY_IF_OUTSIDE_LIBRARY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
, "SAFEARRAY(interface pointer) doesn't work using midl generated proxy"
}

,{
0, CHECK_ERR( OLEAUT_NO_CROSSPLATFORM_TLB )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "oleaut32.dll in build system doesn't support cross platform tlb generation"
}

,{
0, CHECK_ERR( INVALID_PROPPUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "property put function must have at least one argument and must have exactly one argument after any [optional] or [lcid] arguments"
}

,{
0, CHECK_ERR( UNSIZED_PARTIAL_IGNORE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "parameters with [partial_ignore] must have a well defined size"
}

,{
0, CHECK_ERR( NOT_DUAL_INTERFACE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 4 )
,"dual interface should be derived from IDispatch"
}

,{
0, CHECK_ERR( NEWLYFOUND_INAPPLICABLE_ATTRIBUTE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"inapplicable attribute"
}

,{
0, CHECK_ERR( WIRE_COMPAT_WARNING )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"wire_compat should be used for known compatibility problems only and should not be used for new code"
}

,{
0, CHECK_ERR( INVALID_VOID_IN_DISPINTERFACE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"invalid usage of void type in a dispinterface"
}

,{
0, CHECK_ERR( ACF_IN_OBJECT_INTERFACE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"acf attributes are not applicable in object interface"
}

}; /* end of array of structs initialization */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\common\cmdutil.cxx ===
// Copyright (c) 1993-1999 Microsoft Corporation

#pragma warning ( disable : 4514 4710 4706)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <direct.h>
#include <io.h>
#include <time.h>

#include "errors.hxx"
#include "cmdana.hxx"
#include "stream.hxx"
#include "midlvers.h"

extern    _swenum           SearchForSwitch( char ** );
extern    void              ReportUnimplementedSwitch( short );
extern    char    *         SwitchStringForValue( unsigned short );
extern    STATUS_T          SelectChoice( const CHOICE *, char *, short *);

const __int64 iMagic = 77736876677768;

CHOICE PrefixChoices[] =
    {
         { "client"         , PREFIX_CLIENT_STUB }
        ,{ "server"         , PREFIX_SERVER_MGR }
        ,{ "switch"         , PREFIX_SWICH_PROTOTYPE }
        ,{ "cstub"          , PREFIX_CLIENT_STUB }
        ,{ "sstub"          , PREFIX_SERVER_MGR }
        ,{ "all"            , PREFIX_ALL }
        ,{ 0                , 0 }
    };

_cmd_arg::_cmd_arg()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    The constructor

 Arguments:

    None.

 Return Value:

    NA.

 Notes:

----------------------------------------------------------------------------*/
{
    switch_def_vector[0]    = switch_def_vector[1] = switch_def_vector[2] =
                              switch_def_vector[3] = switch_def_vector[4] = 0;
    fClient                 = CLNT_STUB;
    fServer                 = SRVR_STUB;

    Env                     = ENV_WIN32;
    CharOption              = CHAR_SIGNED;
    fMintRun                = FALSE;
    fIsNDR64Run             = FALSE;
    fIsNDRRun               = FALSE;
    fIs2ndCodegenRun        = FALSE;
    fNeedsNDR64Header       = FALSE;
    
    MajorVersion            = rmj;
    MinorVersion            = rmm;
    UpdateNumber            = rup;

    ErrorOption             = ERROR_NONE;
    WireCompatOption        = 0;
    ConfigMask              = 0;
    MSCVersion              = 0;
    fShowLogo               = true;

    // NdrVersionControl has a default constructor so it gets initialized.

    OptimFlags              = OPTIMIZE_NONE;
    OptimLevel              = OPT_LEVEL_OS;
    TargetSystem            = NOTARGET;

    iArgV                   = 0;
    cArgs                   = 0;
    WLevel                  = 1;

    ZeePee                  = DEFAULT_ZEEPEE;
    EnumSize                = 4;
    LocaleId                = 0;

    fDoubleFor64            = FALSE;
    fHasAppend64            = FALSE;

    szCompileTime[0]        = 0;
    szCompilerVersion[0]    = 0;

    pInputFNSwitch          =
    pOutputPathSwitch       =
    pCStubSwitch            =
    pSStubSwitch            =
    pHeaderSwitch           =
    pAcfSwitch              = (filename_switch *)NULL;

    pIIDSwitch              =
    pDllDataSwitch          =
    pProxySwitch            =
    pProxyDefSwitch         =
    pTlibSwitch             =
    pNetmonStubSwitch       =
    pNetmonStubObjSwitch    =
    pRedirectOutputSwitch   = (filename_switch *)NULL;

    pSwitchPrefix           = new pair_switch( &PrefixChoices[0] );
    pSwitchSuffix           = (pair_switch *)0;

    pDSwitch                =
    pISwitch                =
    pUSwitch                = (multiple_switch *)NULL;

    pCppCmdSwitch           =
    pCppOptSwitch           =
    pMSCVerSwitch           =
    pDebug64Switch          =
    pDebug64OptSwitch       = (onetime_switch *) NULL;

}

BOOL
CMD_ARG::IsValidZeePee(
    long        NewZeePee
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Tests if the argument is a valid packing level.

 Arguments:

    NewZeePee    -    Packing level.

 Return Value:

    TRUE if the argument is valid.

 Notes:

    Valid packing levels are nonzero powers of 2 less then 2^16.


----------------------------------------------------------------------------*/
{

    switch( NewZeePee )
        {
        case (1 << 0):
        case (1 << 1):
        case (1 << 2):
        case (1 << 3):
        case (1 << 4):
        case (1 << 5):
        case (1 << 6):
        case (1 << 7):
        case (1 << 8):
        case (1 << 9):
        case (1 << 10):
        case (1 << 11):
        case (1 << 12):
        case (1 << 13):
        case (1 << 14):
        case (1 << 15):
            return TRUE;
        default:
            return FALSE;
        }

}

void
CMD_ARG::SwitchDefined(
    short    sw
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Set switch to be defined.

 Arguments:

    sw    - switch number.

 Return Value:

    None.

 Notes:

    set the switch definition vector bit.
----------------------------------------------------------------------------*/
    {
    switch_def_vector[ sw / 32 ] |=
            (ulong)( (ulong)0x1 << (ulong)( (ulong)sw % 32 ) );
    }

char *
CMD_ARG::GetOutputPath()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get the output path.

 Arguments:

    None.

 Return Value:

    None.

 Notes:

    Reconstitute the path name from the outputpath switch, if nothing
    was specified, put in a path and a slash at the end.

----------------------------------------------------------------------------*/
{
    char        agName[ _MAX_DRIVE + _MAX_PATH + _MAX_FNAME + _MAX_EXT + 1];
    char    *    pOut;
    char        flag = 0;

    strcpy( agName, pOut = pOutputPathSwitch->GetFileName() );

    if( agName[0] == '\0' )
        {
        strcpy(agName, ".\\"), flag = 1;
        }

    if( flag )
        {
        pOut = new char [strlen( agName ) + 1];
        strcpy( pOut , agName );
        pOutputPathSwitch->SetFileName( pOut );
        }
    return pOut;
}

char *
CMD_ARG::GetMinusISpecification()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    get the consolidate -i specification, without the -I characters in them

 Arguments:

    none.

 Return Value:

    pointer to  a buffer containing the consolidated -i options. If the -i
    is not specified, then return a null.

    the returned area (if the pointer returned is not null) can be deleted
    by the caller.

 Notes:

    GetConsolidatedLength will always return a buffer size including the -I
    characters. We can safely assume, that since we are stripping those
    characters, the length returned is sufficient, even if we are appending
    a ; after each -I option

    Also assume that the -I specification buffer always has the -I to start
    with.

----------------------------------------------------------------------------*/
{
    char    *    pMinusI;
    char    *    pTemp;

    if( IsSwitchDefined( SWITCH_I ) )
        {
        pMinusI        = new char[ pISwitch->GetConsolidatedLength() + 1];
        pMinusI[0]    = '\0';

        pISwitch->Init();

        size_t ActualOffset;
        while ( ( pTemp = pISwitch->GetNext( &ActualOffset ) ) != 0 )
            {
            strcat( pMinusI, pTemp+ActualOffset );
            strcat( pMinusI, ";");
            }
        return pMinusI;
        }
    else
        return (char *)0;
}

/*****************************************************************************
 *    filename_switch member functions
 *****************************************************************************/
filename_switch::filename_switch(
    char    *        pThisArg
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    constructor

 Arguments:

    pointer to the filename argument.

 Return Value:

    NA.

 Notes:

    set the filename.

----------------------------------------------------------------------------*/
    {
    pFullName = (char *)NULL;
    if( pThisArg )
        {
        SetFileName( pThisArg );
        }
    }

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    consructor.

 Arguments:

    filename components.

 Return Value:

    NA.

 Notes:

    set the file names.

----------------------------------------------------------------------------*/
filename_switch::filename_switch(
    char    *    pD,
    char    *    pP,
    char    *    pN,
    char    *    pE,
    char    *    pS )
    {
    pFullName = (char *)NULL;
    SetFileName( pD, pP, pN, pE, pS );
    }

filename_switch::~filename_switch()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    KABOOOM !

 Arguments:

    None.

 Return Value:

    Huh ?

 Notes:

----------------------------------------------------------------------------*/
    {

    if( pFullName )
        delete pFullName;
    }


void
filename_switch::SetFileName(
    char    *    pName
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    set filename

 Arguments:

    pName    -    filename

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
    {
    if( pFullName )
        delete pFullName;
    pFullName = new char [strlen(pName) + 1];
    strcpy( pFullName, pName );
    }

void
filename_switch::SetFileName(
    char    *    pD,
    char    *    pP,
    char    *    pN,
    char    *    pE,
    char    *    pS
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    set file name, given its components.

 Arguments:

    pD    -    pointer to drive name ( can be null );
    pP    -    pointer to path name ( can be null );
    pN    -    pointer to name ( can be null );
    pE    -    pointer to extension name ( can be null );
    pS    -    pointer to suffix.

 Return Value:

    None.

 Notes:

    The suffix is added to the filename if necesary. This routine is useful
    if we need to set the filename in partial name set operations. Any
    filename components previously set are overriden.

----------------------------------------------------------------------------*/
{
    char    agDrive[ _MAX_DRIVE ];
    char    agPath[ _MAX_DIR ];
    char    agBaseName[ _MAX_FNAME ];
    char    agExt[ _MAX_EXT ];
    short    len = 0;


    if( pFullName )
        {
        // modify only those portions of the filename that the
        // caller passed in

        _splitpath( pFullName, agDrive, agPath, agBaseName, agExt );

        delete pFullName;
        }
    else
        {

        // this is the first time the name is being set up.

        agDrive[0] = agPath[0] = agBaseName[0] = agExt[0] = '\0';

        }
    
    if(!pD) pD = agDrive;
    if(!pP) pP = agPath;
    if(!pN) pN = agBaseName;
    if(!pS) pS = "";
    if(!pE) pE = agExt;
    

    len = short(strlen( pD ) + strlen( pP ) + strlen( pN ) + strlen( pS ) + strlen( pE ) + 1);
    pFullName = new char[ len ];

    strcpy( pFullName, pD );
    strcat( pFullName, pP );
    strcat( pFullName, pN );
    strcat( pFullName, pS );
    strcat( pFullName, pE );
    
}

void
filename_switch::TransformFileNameForOut(
    char    *    pD,
    char    *    pP)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    transform file name to incorporate the output path, given its drive
    and path components.

 Arguments:

    pD    -    pointer to drive name ( can be null );
    pP    -    pointer to path name ( can be null );

 Return Value:

    None.

 Notes:

    If the filename switch does not have the path component, the path specified
    by pP overrides it. If it does not have the drive component, the the drive
    specified by pD overrides it.
----------------------------------------------------------------------------*/
    {
    char    agDrive[ _MAX_DRIVE ];
    char    agPath[ _MAX_DIR ];
    char    agPath1[ _MAX_DIR ];
    char    agName[ _MAX_FNAME ];
    char    agExt[ _MAX_EXT ];
    BOOL    fTransformed = FALSE;

    if( pFullName )
        {
        _splitpath( pFullName, agDrive, agPath, agName, agExt );

        // if the original name did not have the  drive component, derive it
        // from the specified one.

        if( (agDrive[0] == '\0')    &&
            (agPath[0] != '\\' )    &&
            (agPath[0] != '/' ) )
            {
            if( pD  && (*pD) )
                strcpy( agDrive, pD );
            if( pP && (*pP ) )
                {
                strcpy( agPath1, pP );
                strcat( agPath1, agPath );
                }
            else
                strcpy( agPath1, agPath );

            fTransformed = TRUE;
            }
        }

    if( fTransformed )
        {
        delete pFullName;
        pFullName = new char [  strlen( agDrive )   +
                                strlen( agPath1 )   +
                                strlen( agName )    +
                                strlen( agExt )     +
                                1 ];
        strcpy( pFullName, agDrive );
        strcat( pFullName, agPath1 );
        strcat( pFullName, agName );
        strcat( pFullName, agExt );
        }
    }

char *
filename_switch::GetFileName()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Getfile name.

 Arguments:

    none.

 Return Value:

    the filename.

 Notes:

----------------------------------------------------------------------------*/
{
    return pFullName;
}

void
filename_switch::GetFileNameComponents(
    char    *    pD,
    char    *    pP,
    char    *    pN,
    char    *    pE
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    get file name components.

 Arguments:

    pD    -    pointer to drive name area.
    pP    -    pointer to path name area.
    pN    -    pointer to name area.
    pE    -    pointer to extension area.

 Return Value:

    None.

 Notes:

    Assume that all pointers pass the right size buffers. I dont check here.
    Useful to get the filename components desired.

----------------------------------------------------------------------------*/
{

    char    agDrive[ _MAX_DRIVE ];
    char    agPath[ _MAX_DIR ];
    char    agBaseName[ _MAX_FNAME ];
    char    agExt[ _MAX_EXT ];


    _splitpath( pFullName ? pFullName : "" ,
                agDrive, agPath, agBaseName, agExt );

    if( pD ) strcpy( pD , agDrive );
    if( pP ) strcpy( pP , agPath );
    if( pN ) strcpy( pN , agBaseName );
    if( pE ) strcpy( pE , agExt );


}

/*****************************************************************************
 *    multiple_switch member functions
 *****************************************************************************
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    constructor.

 Arguments:

    argument to switch. Actual argument offset.

 Return Value:

 Notes:

----------------------------------------------------------------------------*/
multiple_switch::multiple_switch(
    char    *    pArg,
    size_t       ActualArgOffset )
{
    pFirst = pCurrent = (OptList *)NULL;
    if ( pArg )
        {
        Add( pArg, ActualArgOffset );
        }
}

void
multiple_switch::Add(
    char    *    pValue,
    size_t       ActualOffset
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Add another argument to the multiple specification switch.

 Arguments:

    pValue    -    the argument.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
    {
    OptList    *    pOpt    = pFirst;
    OptList    *    pNew    = new OptList;

    pNew->pNext        = (OptList *)NULL;
    pNew->pStr         = pValue;
    pNew->ActualOffset = ActualOffset;

    // determine if argument needs quotes
    bool NeedsQuotes = false;
    // skip to the first character of the switch argument.
    pValue += ActualOffset;
    while( *pValue && !(NeedsQuotes = !!isspace(*pValue++)) ); 
    pNew->NeedsQuotes = NeedsQuotes;

    // link it up

    while( pOpt && pOpt->pNext ) pOpt = pOpt->pNext;

    if( !pOpt )
        pCurrent = pFirst = pNew;
    else
        pOpt->pNext = pNew;

    }

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Init a walk of the multiple input switch.

 Arguments:

    None.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
void
multiple_switch::Init()
{
    pCurrent = pFirst;
}

char *
multiple_switch::GetNext( size_t *pActualOffset, bool *pNeedsQuotes )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get the next argument to theis switch.

 Arguments:

    None.

 Return Value:

    pointer to the next argument.

 Notes:

----------------------------------------------------------------------------*/
    {
    char *  pValue = (char *)NULL;

    if(pCurrent)
        {
        pValue   = pCurrent->pStr;
        if ( pActualOffset )
            {
            *pActualOffset = pCurrent->ActualOffset;
            }
        if ( pNeedsQuotes )
            {
            *pNeedsQuotes = pCurrent->NeedsQuotes;
            }
        pCurrent = pCurrent->pNext;
        }
    return pValue;
    }

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get all the options to the multiple options switch, consolidated into
    a buffer.

 Arguments:

    None.

 Return Value:

    pointer to a buffer containing all the concatenated arguments.

 Notes:

----------------------------------------------------------------------------*/
char *
multiple_switch::GetConsolidatedOptions( bool AddQuotes )
    {
#define OPTION_GAP_STRING() (" ")
#define OPTION_GAP_LENGTH() (1)

    int         len;
    char   *    pReturn = 0;

    len = GetConsolidatedLength( AddQuotes );

    // consolidate the options into 1

    if ( len  && ( pReturn = new char[ len + 1] ) != 0 )
        {
        char *  pTemp;

        *pReturn = '\0';
        Init();

        size_t ActualOffset;
        bool NeedsQuotes;
        while ( ( pTemp = GetNext(&ActualOffset, &NeedsQuotes ) ) != 0)
            {

            if ( NeedsQuotes && AddQuotes )
                {
                char *pTempReturn = pReturn + strlen( pReturn );
                memcpy( pTempReturn, pTemp, ActualOffset );
                sprintf( pTempReturn + ActualOffset, 
                         "\"%s\"%s", pTemp + ActualOffset, OPTION_GAP_STRING() );
                }
            else 
                {
                strcat( pReturn, pTemp );
                strcat( pReturn, OPTION_GAP_STRING() );                
                }
            }
        }

    return pReturn;
    }

short
multiple_switch::GetConsolidatedLength( bool AddQuotes )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get the length of the consolidated options.

 Arguments:

    None.

 Return Value:

    length of the options.

 Notes:

----------------------------------------------------------------------------*/
    {
    char    *   pReturn;
    short       len = 0;

    Init();
    bool NeedsQuotes;
    while ( ( pReturn = GetNext(NULL, &NeedsQuotes ) ) != 0 )
        {
        len = short(len + strlen( pReturn ) + OPTION_GAP_LENGTH());
        if ( AddQuotes && NeedsQuotes ) len += 2; //Add space for quotes
        }
    return len;
    }

#undef OPTION_GAP_STRING
#undef OPTION_GAP_LENGTH

/*****************************************************************************
 *    onetime_switch member functions
 *****************************************************************************/
onetime_switch::onetime_switch(
    char    *    pArg
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    constructor.

 Arguments:

    pArg    -    pointer to switch argument.

 Return Value:

    NA.

 Notes:

----------------------------------------------------------------------------*/
{
    if( pArg )
        {
        pOpt = new char[ strlen( pArg ) + 1];
        strcpy( pOpt, pArg );
        }
    else
        pOpt = (char *)NULL;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    destructor.

 Arguments:

    None.

 Return Value:

    NA.

 Notes:

----------------------------------------------------------------------------*/
onetime_switch::~onetime_switch()
{
    if( pOpt )
        delete pOpt;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get the option string.

 Arguments:

    None.

 Return Value:

    the option string.

 Notes:

----------------------------------------------------------------------------*/
char *
onetime_switch::GetOption()
{
    return pOpt;
}

short
onetime_switch::GetLength()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    get length of the option.

 Arguments:

    None.

 Return Value:

    the length of the option.

 Notes:

----------------------------------------------------------------------------*/
{
    return (short)strlen( pOpt );
}

typedef char*   PSTR;

pair_switch::pair_switch(
    const CHOICE * pValidChoices )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    pair_switch_constructor

 Arguments:

    pValidChoiceArray    - the array of valid choices (this is assumed
                          pre-allocated).

 Return Value:

    NA

 Notes:


----------------------------------------------------------------------------*/
{
    short        MaxIndex    = 0;
    CHOICE *    pCurChoice    = (CHOICE *) pValidChoices;

    pArrayOfChoices = pCurChoice;

    // find the size of the pair array
    while ( pCurChoice->pChoice )
        {
        if ( pCurChoice->Choice > MaxIndex )
            MaxIndex = pCurChoice->Choice;
        pCurChoice++;
        }

    ArraySize = short(MaxIndex + 1);
    pUserStrings = new PSTR [ ArraySize ];

    for ( int i = 0; i <= MaxIndex; i++ )
        pUserStrings[i] = NULL;

    Current = -1;
}

void
pair_switch::AddPair(
    short   Sys,
    char *  pUsr )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    add another prefix pair

 Arguments:

    Sys    - the system-defined string key
    pUsr   - the user-defined string value.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{    
    pUserStrings[ Sys ] = pUsr;
}    

char *
pair_switch::GetUserDefinedEquivalent(
    short   Sys )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    get the user defined prefix corresponding to the system defined prefix.

 Arguments:

    pSystemDefined  - the system defined prefix for which the user defined
                      prefix is being searched.

 Return Value:

    The user defined prefix , if it is defined. If not, return the input

 Notes:

----------------------------------------------------------------------------*/
{
    return pUserStrings[ Sys ];

}
short
pair_switch::GetIndex(
    char    *    pGivenString )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    search is the array of choices, if this string is a valid system known
    string

 Arguments:

    pGivenString   - the string to be searched for.

 Return Value:

    an index into the array of choice , -1 if the given string is not found.

 Notes:

----------------------------------------------------------------------------*/
{
    int         i;
    char  *     p;

    for( i = 0; ( p = (char *)pArrayOfChoices[ i ].pChoice ) != 0 ; ++i )
        {
        if( strcmp( p, pGivenString ) == 0 )
            return pArrayOfChoices[ i ].Choice;
        }
    return -1;
}

BOOL
CMD_ARG::IsPrefixDifferentForStubs()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 see if any prefix for client or server or switch are different

 Arguments:

    None.

 Return Value:

    BOOL - true if different prefix strings.

 Notes:

----------------------------------------------------------------------------*/
{

    char * pCPrefix;
    char * pSPrefix;
    char * pSwPrefix;

    pCPrefix = GetUserPrefix( PREFIX_CLIENT_STUB );
    pSPrefix = GetUserPrefix( PREFIX_SERVER_MGR );
    pSwPrefix = GetUserPrefix( PREFIX_SWICH_PROTOTYPE );

    if ( !pCPrefix )
        pCPrefix = "";
    if ( !pSPrefix )
        pSPrefix = "";
    if ( !pSwPrefix )
        pSwPrefix = "";

    return (BOOL) strcmp( pCPrefix, pSPrefix ) ||
           (BOOL) strcmp( pCPrefix, pSwPrefix ) ||
           (BOOL) strcmp( pSPrefix, pSwPrefix );

}

short            
pair_switch::GetNext( char ** pSys, char ** pUser )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 Get the Next pair of system & user values

 Arguments:

    None.

 Return Value:

    index in array of user value

 Notes:

----------------------------------------------------------------------------*/
{
    
    // find the next non-null user string
    Current++;

    while ( ( Current < ArraySize) && !pUserStrings[ Current ] )
        Current++;

    if ( Current == ArraySize )
        return FALSE;

    // search for the first choice that matches this index
    *pUser = pUserStrings[Current];
    for ( short i = 0; i < ArraySize; i++ )
        {
        if ( ( pArrayOfChoices[i].Choice = Current ) != 0 )
            {
            *pSys = (char *)pArrayOfChoices[i].pChoice;
            return TRUE;
            }
        }
    return FALSE;
}


void
CMD_ARG::EmitConfirm(
    ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit confirm the arguments by dumping onto a stream in a more concise
    format.

 Arguments:

    pStream - the stream to dump it to.

 Return Value:

    None.

----------------------------------------------------------------------------*/
{
    short       Option;
    char       *pEnvName, *pOptFlagName;
    char        Buffer[100];

    pStream->Write( "/* Compiler settings for " );
    if ( !pCommand->IsSwitchDefined( SWITCH_NO_STAMP ) ) 
        {
        pStream->Write( GetInputFileName() );
        if ( IsSwitchDefined( SWITCH_ACF ) )
            {
            pStream->Write( ", " );
            pStream->Write( GetAcfFileName() );
            }
        }
    else
        {
        char FileName[_MAX_FNAME];
        char Ext[_MAX_EXT];
        GetInputFileNameComponents(NULL, NULL, FileName, Ext);
        pStream->Write(FileName);
        pStream->Write(Ext);
        if ( IsSwitchDefined( SWITCH_ACF ) )
            {
            pStream->Write( ", " );
            GetAcfFileNameComponents(NULL, NULL, FileName, Ext);
            pStream->Write(FileName);
            pStream->Write(Ext);
            }
        }

    pStream->Write( ":" );
    pStream->NewLine();

    pOptFlagName = "Os";
    if( GetOptimizationFlags() & OPTIMIZE_INTERPRETER )
        {
        if( OptimFlags & OPTIMIZE_INTERPRETER_IX )
            pOptFlagName= "Ox";
        else if( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 )
            pOptFlagName= "Oicf";
        else if( GetOptimizationFlags() & OPTIMIZE_STUBLESS_CLIENT )
            pOptFlagName= "Oic";
        else
            pOptFlagName= "Oi";
        }

    pEnvName = (GetEnv() == ENV_WIN64) ? "Win64" 
                                       : "Win32";

    sprintf( Buffer, "    %s, W%d, Zp%d, env=%s (%s%s)",
             pOptFlagName,
             GetWarningLevel(),
             GetZeePee(),
             pEnvName,
             (IsDoubleRunFor64() ? "64b run" : "32b run"),
             (HasAppend64() ? ",appending" : "") );
    pStream->Write( Buffer );

    pStream->NewLine();
    pStream->Write("    protocol : " );
    switch ( TargetSyntax )
        {
        case SYNTAX_DCE: 
            pStream->Write("dce ");
            break;
        case SYNTAX_NDR64:
            pStream->Write("ndr64 ");
            break;
        case SYNTAX_BOTH:
            pStream->Write("all ");
            break;
        }

    if ( IsSwitchDefined( SWITCH_MS_EXT))
        pStream->Write( ", ms_ext" );
    if ( IsSwitchDefined( SWITCH_APP_CONFIG))
        pStream->Write( ", app_config" );
    if ( IsSwitchDefined( SWITCH_C_EXT))
        pStream->Write( ", c_ext" );
    if ( IsSwitchDefined( SWITCH_MS_UNION))
        pStream->Write( ", ms_union" );
    if ( IsSwitchDefined( SWITCH_OLDNAMES))
        pStream->Write( ", oldnames" );
    if ( IsSwitchDefined( SWITCH_ROBUST ))
        pStream->Write( ", robust" );
    if ( IsSwitchDefined( SWITCH_MS_CONF_STRUCT))
        pStream->Write( ", ms_conf_struct" );

    pStream->NewLine();

    strcpy( Buffer, "    error checks: " );
    Option = GetErrorOption();
    if( Option != ERROR_NONE )
        {
        if( Option & ERROR_ALLOCATION )
            strcat( Buffer, "allocation ");
        if( Option & ERROR_REF )
            strcat( Buffer, "ref ");
        if( Option & ERROR_BOUNDS_CHECK )
            strcat( Buffer, "bounds_check ");
        if( Option & ERROR_ENUM )
            strcat( Buffer, "enum ");
        if( Option & ERROR_STUB_DATA )
            strcat( Buffer, "stub_data ");
        }
    else
        strcat( Buffer, "none" );
    pStream->Write( Buffer );

    if ( 0 != WireCompatOption)
        {
        pStream->WriteOnNewLine( "    wire_compat options: " );

        if( ErrorOption & WIRE_COMPAT_ENUM16UNIONALIGN )
            pStream->Write( "enum16unionalign ");
            
        pStream->NewLine();
        }

    if ( IsSwitchDefined( SWITCH_NO_FMT_OPT))
        pStream->Write( ", no_format_optimization" );
    if ( IsSwitchDefined( SWITCH_RPCSS))
        pStream->Write( ", memory management on" );
    if ( IsSwitchDefined( SWITCH_NETMON))
        pStream->Write( ", NetMon" );
    if ( IsSwitchDefined( SWITCH_USE_EPV))
        pStream->Write( ", use_epv" );
    if ( IsSwitchDefined( SWITCH_NO_DEFAULT_EPV))
        pStream->Write( ", no_default_epv" );

    pStream->NewLine();

    pStream->Write( "    VC __declspec() decoration level: " );
    if ( GetMSCVer() < 1100 )
        pStream->Write( "  none " );
    else 
        {
        pStream->NewLine();
        pStream->Write( "         __declspec(uuid()), __declspec(selectany), __declspec(novtable)\n" );
        pStream->Write( "         DECLSPEC_UUID(), MIDL_INTERFACE()" );
        }
    pStream->NewLine();

#if defined(TARGET_RKK)
    switch ( TargetSystem )
        {
        case NT35:
            pTarget = "NT 3.5";
            break;
        case NT351:
            pTarget = "NT 3.51 and Win95";
            break;
        case NT40:
            pTarget = "NT 4.0";
            break;
        default:
            pTarget = "NT ???";
        }

    pStream->Write( "    Release: this stub is compatible with " );
    pStream->Write( pTarget );
    pStream->Write( " release" );
    pStream->NewLine();
    pStream->Write( "             or a later version of MIDL and RPC" );
    pStream->NewLine();
#endif

    pStream->Write( "*/" );
    pStream->NewLine();

}


// ISSUE-2000/08/03-mikew
// The ia64 C++ compiler is incorrectly optimizing memcpy in some cases.
// Mark the source buffer as unaligned to work around it.  To repro just run
// midlc in a debugger and it will align fault while parsing the command file

#ifndef UNALIGNED
#ifdef IA64
#define UNALIGNED __unaligned
#else
#define UNALIGNED 
#endif
#endif


#define CopyIntFromBuffer( buffer, dest ) memcpy( &dest, (UNALIGNED char *) (buffer), sizeof( dest ) ), pBuffer += sizeof( dest )


#define CopyStrFromBuffer( buffer, dest )   { \
                                            char *sz = dest; \
                                            while ( *buffer ) *sz++ = *buffer++;\
                                            *sz++ = 0; \
                                            buffer++; \
                                            }

char*
AllocCopyStrFromBuffer( char* buffer, char*& dest )
    {
    unsigned long ulSize = 0; 
    char* szt = buffer; 
    while ( *szt++ ) ulSize++; 
    char* sz = ( ulSize ) ? new char[ ulSize + 1 ] : 0; 
    dest = sz; 
    if ( sz ) 
        memcpy( sz, buffer, ulSize+1 ); 
    return buffer+ulSize+1;
    }

void
filename_switch::StreamIn( char*& pBuffer )
    {
    pBuffer = AllocCopyStrFromBuffer( pBuffer, pFullName );
    }

void
filename_switch::StreamOut( STREAM* stream )
    {
    stream->Write(pFullName);
    }

void
onetime_switch::StreamIn( char*& pBuffer )
    {
    pBuffer = AllocCopyStrFromBuffer( pBuffer, pOpt );
    }

void
onetime_switch::StreamOut( STREAM *stream )
    {
    stream->Write( pOpt );
    }

void
multiple_switch::StreamIn( char*& pBuffer )
    {
    unsigned long   ulCount = 0;

    CopyIntFromBuffer( pBuffer, ulCount );

    while ( ulCount-- )
        {
        char* sz = 0;
        size_t ActualOffset;
        CopyIntFromBuffer( pBuffer, ActualOffset );
        pBuffer = AllocCopyStrFromBuffer( pBuffer, sz );
        Add( sz, ActualOffset );
        }
    }

void
multiple_switch::StreamOut( STREAM* stream )
    {
    OptList*    pTemp = pFirst;
    unsigned long ulCount = 0;

    while ( pTemp )
        {
        ulCount++;
        pTemp = pTemp->pNext;
        }

    stream->Write(&ulCount, sizeof(ulCount));
    pTemp = pFirst;
    while ( pTemp )
        {
        stream->Write( &pTemp->ActualOffset, sizeof( pTemp->ActualOffset ) );
        stream->Write( pTemp->pStr );
        pTemp = pTemp->pNext;
        }
    }

void
pair_switch::StreamIn( char*& pBuffer )
    {
    CopyIntFromBuffer( pBuffer, ArraySize );

    pUserStrings = new PSTR [ ArraySize ];
    if ( pUserStrings )
        {
        for ( short i = 0; i < ArraySize; i++ )
            {
            pBuffer = AllocCopyStrFromBuffer( pBuffer, pUserStrings[i] );
            }
        }
    }

void
pair_switch::StreamOut( STREAM *stream )
    {
    stream->Write( &ArraySize, sizeof( ArraySize ) );
    for ( short i = 0 ; i < ArraySize ; i++ )
        {
        stream->Write( pUserStrings[i] );
        }
    }

void 
CMD_ARG::StreamOut( STREAM *stream )
    {
#define Stream( x ) ( stream->Write( &x, sizeof( x ) ) )
    Stream( iMagic );
    Stream( MajorVersion );
    Stream( MinorVersion );
    Stream( UpdateNumber );
    Stream( fHasAppend64 );
    Stream( switch_def_vector );
    Stream( fClient );
    Stream( fServer );
    Stream( Env );
    Stream( CharOption );
    Stream( fMintRun );
    Stream( ErrorOption );
    Stream( WireCompatOption );
    Stream( ConfigMask );
    Stream( MSCVersion );
    Stream( fShowLogo );
    // BUGBUG: VersionControl is a class
    Stream( VersionControl );
    Stream( OptimFlags );
    Stream( OptimLevel );
    Stream( TargetSystem );
    Stream( iArgV );   
    Stream( cArgs );
    Stream( WLevel );
    Stream( ZeePee );
    Stream( EnumSize );
    Stream( LocaleId );
    Stream( fDoubleFor64 );
    Stream( TargetSyntax );
#undef Stream

    stream->Write( &szCompileTime[0] );
    stream->Write( &szCompilerVersion[0] );

    //
    // The following switches write a single NULL character is they are not
    // present on the command line
    //

#define StreamIfNecessary( x ) ( x ? x->StreamOut(stream) : stream->Write( '\0' ) )

    StreamIfNecessary( pInputFNSwitch );
    StreamIfNecessary( pOutputPathSwitch );
    StreamIfNecessary( pCStubSwitch );
    StreamIfNecessary( pSStubSwitch );
    StreamIfNecessary( pHeaderSwitch );
    StreamIfNecessary( pAcfSwitch );
    StreamIfNecessary( pIIDSwitch );
    StreamIfNecessary( pDllDataSwitch );
    StreamIfNecessary( pProxySwitch );
    StreamIfNecessary( pTlibSwitch );
    StreamIfNecessary( pNetmonStubSwitch );
    StreamIfNecessary( pNetmonStubObjSwitch );
    StreamIfNecessary( pRedirectOutputSwitch );

    StreamIfNecessary( pCppCmdSwitch );
    StreamIfNecessary( pCppOptSwitch );
    StreamIfNecessary( pMSCVerSwitch );
    StreamIfNecessary( pDebug64Switch );
    StreamIfNecessary( pDebug64OptSwitch );

#undef StreamIfNecessary


    // 
    // The following switches write (long) 0 if they are not present on
    // the command line
    //

#define StreamIfNecessary( x )                                          \
                    {                                                   \
                        unsigned long zero = 0;                         \
                        x  ? x->StreamOut(stream)                       \
                           : stream->Write( &zero, sizeof( zero ) );    \
                    }

    StreamIfNecessary( pSwitchPrefix );
    StreamIfNecessary( pSwitchSuffix );

    StreamIfNecessary( pDSwitch );
    StreamIfNecessary( pISwitch );
    StreamIfNecessary( pUSwitch );

#undef StreamIfNecessary
    }

STATUS_T
CMD_ARG::StreamIn( char* pBuffer )
    {
    __int64 magicNumber = 0;

    CopyIntFromBuffer( pBuffer, magicNumber );
    if ( magicNumber != iMagic )
        {
        return BAD_CMD_FILE;
        }

    CopyIntFromBuffer( pBuffer, MajorVersion );
    CopyIntFromBuffer( pBuffer, MinorVersion );
    CopyIntFromBuffer( pBuffer, UpdateNumber );

    if ( ( MajorVersion != rmj ) || 
         ( MinorVersion != rmm ) || 
         ( UpdateNumber != rup ) )
        {
        return INCONSIST_VERSION;
        }
        
    CopyIntFromBuffer( pBuffer, fHasAppend64 );
    CopyIntFromBuffer( pBuffer, switch_def_vector );
    CopyIntFromBuffer( pBuffer, fClient );
    CopyIntFromBuffer( pBuffer, fServer );
    CopyIntFromBuffer( pBuffer, Env );
    CopyIntFromBuffer( pBuffer, CharOption );
    CopyIntFromBuffer( pBuffer, fMintRun );
    CopyIntFromBuffer( pBuffer, ErrorOption );
    CopyIntFromBuffer( pBuffer, WireCompatOption );
    CopyIntFromBuffer( pBuffer, ConfigMask );
    CopyIntFromBuffer( pBuffer, MSCVersion );
    CopyIntFromBuffer( pBuffer, fShowLogo );
    CopyIntFromBuffer( pBuffer, VersionControl );
    CopyIntFromBuffer( pBuffer, OptimFlags );
    CopyIntFromBuffer( pBuffer, OptimLevel );
    CopyIntFromBuffer( pBuffer, TargetSystem );
    CopyIntFromBuffer( pBuffer, iArgV );
    CopyIntFromBuffer( pBuffer, cArgs );
    CopyIntFromBuffer( pBuffer, WLevel );
    CopyIntFromBuffer( pBuffer, ZeePee );
    CopyIntFromBuffer( pBuffer, EnumSize );   
    CopyIntFromBuffer( pBuffer, LocaleId );
    CopyIntFromBuffer( pBuffer, fDoubleFor64 );
    CopyIntFromBuffer( pBuffer, TargetSyntax );
        
    CopyStrFromBuffer( pBuffer, &szCompileTime[0] );
    CopyStrFromBuffer( pBuffer, &szCompilerVersion[0] );

    pInputFNSwitch          = new filename_switch();
    pOutputPathSwitch       = new filename_switch();
    pCStubSwitch            = new filename_switch();
    pSStubSwitch            = new filename_switch();
    pHeaderSwitch           = new filename_switch();
    pAcfSwitch              = new filename_switch();
    pIIDSwitch              = new filename_switch();
    pDllDataSwitch          = new filename_switch();
    pProxySwitch            = new filename_switch();
    pTlibSwitch             = new filename_switch();
    pNetmonStubSwitch       = new filename_switch();
    pNetmonStubObjSwitch    = new filename_switch();
    pRedirectOutputSwitch   = new filename_switch();

    pCppCmdSwitch           = new onetime_switch();
    pCppOptSwitch           = new onetime_switch();
    pMSCVerSwitch           = new onetime_switch();
    pDebug64Switch          = new onetime_switch();
    pDebug64OptSwitch       = new onetime_switch();

    pSwitchPrefix           = new pair_switch( &PrefixChoices[0] );
    pSwitchSuffix           = new pair_switch( &PrefixChoices[0] );

    pDSwitch                = new multiple_switch();
    pISwitch                = new multiple_switch();
    pUSwitch                = new multiple_switch();

    pInputFNSwitch->StreamIn( pBuffer );
    pOutputPathSwitch->StreamIn( pBuffer );
    pCStubSwitch->StreamIn( pBuffer );
    pSStubSwitch->StreamIn( pBuffer );
    pHeaderSwitch->StreamIn( pBuffer );
    pAcfSwitch->StreamIn( pBuffer );
    pIIDSwitch->StreamIn( pBuffer );
    pDllDataSwitch->StreamIn( pBuffer );
    pProxySwitch->StreamIn( pBuffer );
    pTlibSwitch->StreamIn( pBuffer );
    pNetmonStubSwitch->StreamIn( pBuffer );
    pNetmonStubObjSwitch->StreamIn( pBuffer );
    pRedirectOutputSwitch->StreamIn( pBuffer );

    pCppCmdSwitch->StreamIn( pBuffer );
    pCppOptSwitch->StreamIn( pBuffer );
    pMSCVerSwitch->StreamIn( pBuffer );
    pDebug64Switch->StreamIn( pBuffer );
    pDebug64OptSwitch->StreamIn( pBuffer );

    pSwitchPrefix->StreamIn( pBuffer );
    pSwitchSuffix->StreamIn( pBuffer );

    pDSwitch->StreamIn( pBuffer );
    pISwitch->StreamIn( pBuffer );
    pUSwitch->StreamIn( pBuffer );

    // HACK ALERT: we want to generate right header if 
    // -protocol all and no -env is specified. 
    if ( ( TargetSyntax == SYNTAX_BOTH ) && 
         ( Env == ENV_WIN32 ) && 
         !IsSwitchDefined( SWITCH_INTERNAL ) )
        {
        TargetSyntax = SYNTAX_DCE;
        if ( !IsSwitchDefined( SWITCH_ENV) )
            SetNeedsNDR64Header();
        }

    if ( NeedsNDR64Run() )
        GetNdrVersionControl().SetHasMultiTransferSyntax();
         
    
    return STATUS_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\common\errhndl.cxx ===
/*****************************************************************************
 *  Copyright (c) 1993-1999 Microsoft Corporation
 *
 *			RPC compiler: error handler
 *
 *	Author	: Vibhas Chandorkar
 *	Created	: 22nd Aug 1990
 *
 ****************************************************************************/

#pragma warning ( disable : 4514 )      // Unreferenced inline function

/****************************************************************************
 *			include files
 ***************************************************************************/

#include "nulldefs.h"
extern	"C"	
	{
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	}
#include "common.hxx"
#include "errors.hxx"
#include "cmdana.hxx"
#include "control.hxx"
#include "pragma.hxx"

extern CMessageNumberList GlobalMainMessageNumberList;

#define ERROR_PREFIX "MIDL"

/****************************************************************************
 *			local definitions and macros
 ***************************************************************************/

#include "errdb.h"

const ERRDB	UnknownError = 
{
0, CHECK_ERR(I_ERR_UNKNOWN_ERROR)
 MAKE_E_MASK(ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"unknown internal error"
};


extern CMD_ARG	*	pCommand;

/*** IsErrorRelevant ******************************************************
 * Purpose	: To decide whether the error is going to be ignored anyhow, and
 *          : cut out further processing
 * Input	: error value
 * Output	: nothing
 * Notes	: The error number itself is an indicator of the location of
 *			: the error, (user/compile-time,run-time) , and severity.
 ****************************************************************************/
ErrorInfo::ErrorInfo( STATUS_T ErrValue )
{
	ErrVal = ErrValue;

	// cast away the constness
	pErrorRecord	 = (ERRDB *) ErrorDataBase;

	if( ErrVal < D_ERR_MAX )
		{
		pErrorRecord += ( ErrVal - D_ERR_START ) + INDEX_D_ERROR();
		}
	else if( ErrVal < C_ERR_MAX )
		{
		pErrorRecord += ( ErrVal - C_ERR_START ) + INDEX_C_ERROR();
		}
	else if( ErrVal < A_ERR_MAX )
		{
		pErrorRecord += ( ErrVal - A_ERR_START ) + INDEX_A_ERROR();
		}
	else
		{
		pErrorRecord = NULL;
		}
}

int
ErrorInfo::IsRelevant()
{
	unsigned short	ErrorClass	= GET_ECLASS( pErrorRecord->ErrMask );
	unsigned short	ErrorWL		= GET_WL( pErrorRecord->ErrMask );
	unsigned short	ModeSwitchConfigI	= pCommand->GetModeSwitchConfigMask();
	unsigned short	CurWL		= pCommand->GetWarningLevel();

    if ( pCommand->GetEnv() & pErrorRecord->inApplicableEnviron )
        {
        return FALSE;
        }

	// if this is not relevant to this mode, return FALSE
	if( GET_SC(pErrorRecord->ErrMask) & ModeSwitchConfigI )
		return FALSE;

	// does this qualify to be a warning in this mode ? If not return.
	if ( ErrorClass == CLASS_WARN )
		{
		if( CurWL < ErrorWL ) 
			return FALSE;
        if ( !GlobalMainMessageNumberList.GetMessageFlag( ErrVal ) )
            return FALSE;
		}
	return TRUE;
}

/*** RpcError ***************************************************************
 * Purpose	: To report an error in a formatted fashion
 * Input	: filename where the error occured, line number, error value
 *			: error mesage suffix string if any
 *			: input filename ptr could be NULL if no filename
 *			: suffix string ptr could be null if no suffix string
 * Output	: nothing
 * Notes	: The error number itself is an indicator of the location of
 *			: the error, (user/compile-time,run-time) , and severity.
 *			: Filename and line number depend upon where the error occurs. If
 *			: the error is a user-error(command line), file and line number
 *			: does not make sense. The input can be a NULL for filename, and
 *			: 0 for line number in case of the command line errors
 ****************************************************************************/
void
RpcError(
	char			*	pFile,					// filename where error occured
	short				Line,					// line number
	STATUS_T 			ErrVal,					// error value
	char			*	pSuffix)				// error message suffix string
{
	ErrorInfo			ErrDescription( ErrVal );

	// does this qualify to be an error in this mode ? If not return.
	if ( !ErrDescription.IsRelevant() )
		return;
	
	// report the error
	ErrDescription.ReportError( pFile, Line, pSuffix );

}


/*** RpcReportError ***************************************************************
 * Purpose	: To report an error in a formatted fashion
 * Input	: filename where the error occured, line number, error value
 *			: error mesage suffix string if any
 *			: input filename ptr could be NULL if no filename
 *			: suffix string ptr could be null if no suffix string
 * Output	: nothing
 * Notes	: The error number itself is an indicator of the location of
 *			: the error, (user/compile-time,run-time) , and severity.
 *			: Filename and line number depend upon where the error occurs. If
 *			: the error is a user-error(command line), file and line number
 *			: does not make sense. The input can be a NULL for filename, and
 *			: 0 for line number in case of the command line errors
 ****************************************************************************/
void
ErrorInfo::ReportError(
	char			*	pFile,					// filename where error occured
	short				Line,					// line number
	char			*	pSuffix)				// error message suffix string
	{
	char	*		pSeverity	= "error";
	char	*		pPrefix;
	unsigned short	ErrorClass	= GET_ECLASS( pErrorRecord->ErrMask );

	if (!pErrorRecord)
		{
		fprintf( stdout
				, "%s %c%.4d\n"
				, "internal error"
				, 'I'
				, ErrVal
			   );
		return;
		}

	switch( ErrorClass )
		{
		case CLASS_WARN:
			// check if all warnings emitted are to be treated as error
			if( !pCommand->IsSwitchDefined( SWITCH_WX ) )
				{
				pSeverity = "warning";
				}
			else
				{
				// treat as error.
				ErrorClass = CLASS_ERROR;
				}
			break;

		case CLASS_ADVICE:
			// we report these as warnings, because we want tools like VC++ to understand
			// our error messages for "jump to line" actions.
			pSeverity = "warning";
			break;

		case CLASS_ERROR:
		default:
			break;
		}

	// now report the error
	if ( !pSuffix )
		pSuffix = "";

	// mark command line errors specially
	if( GET_MT(pErrorRecord->ErrMask)  == 'D' )
		pPrefix = "command line ";
	else
		pPrefix = "";
		
	// if it a warning , dont increment error count

	if( ErrorClass == CLASS_ERROR )
        IncrementErrorCount();

    // Print the file and line number ...
    // If no file, print something anyway - this is required for automatic 
    // build tools to be able to parse and log error lines correctly.

	if( pFile )
        {
        if ( Line )
    		fprintf(  stdout, "%s(%d) : ", pFile, Line );
        else
    		fprintf(  stdout, "%s : ", pFile );
        }
    else
        fprintf( stdout, "midl : " );

	// print the error message
	fprintf( stdout
			, "%s%s " ERROR_PREFIX "%.4d : %s %s\n"
			, pPrefix
			, pSeverity
			, ErrVal
			, pErrorRecord->pError
			, pSuffix );

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\common\mem.cxx ===
// Copyright (c) 1993-1999 Microsoft Corporation

#pragma warning ( disable : 4514 )

#include "nulldefs.h"

#include <stdlib.h>
#include <string.h>
#include <malloc.h>

#include "common.hxx"
#include "errors.hxx"

unsigned long       TotalAllocation;

void * AllocateNew(
    size_t  size )
    {
    void * _last_allocation;

    if( (_last_allocation = malloc( size )) == 0 )
        {

        RpcError( 0,
                  0,
                  OUT_OF_MEMORY,
                  0 );

        exit( OUT_OF_MEMORY );
        }
    TotalAllocation += size;
    return _last_allocation;
    }

void  AllocateDelete( void * p )
{
if( p )
    free( (char *)p );
}

char * MIDLStrDup( char *p )
{

if (NULL == p)
   return p;

return strcpy( new char[ strlen(p) + sizeof('\0') ], p );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\common\idict.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: idict.hxx
Title				: index based dictionary simulation
History				:
	04-Aug-1991	VibhasC	Created

*****************************************************************************/

#pragma warning ( disable : 4514 4710 )

/****************************************************************************
 local defines and includes
 ****************************************************************************/
#include "nulldefs.h"
extern	"C"	{
	#include <stdio.h>
	
}
#include "idict.hxx"

/****************************************************************************/

/****************************************************************************
	idict class implementation
 ****************************************************************************/
IDICT::IDICT(
	short	InitialSize,
	short	Increment )
	{
	IDICTELEMENT	*	pNewArray	= new
								IDICTELEMENT [ InitialSize ];
	iNextIndex		= 0;
	CurrentSize		= InitialSize;
	IDictIncrement	= Increment;
	SetArray( pNewArray );
	}

/****************************************************************************
 SetElement:
	Set the element in the array to the value that is passed in
 ****************************************************************************/
void
IDICT::SetElement(
	IDICTKEY		Key,
	IDICTELEMENT	Element )
	{
	if( Key < iNextIndex )
		{
		pArray[ Key ] = Element;
		}
	}

/****************************************************************************
 SetNewElement:
	Set the new element in the array to the value that is passed in
 ****************************************************************************/
IDICTKEY
IDICT::SetNewElement(
	IDICTELEMENT	Element )
	{
	pArray[ iNextIndex ] = Element;
	return iNextIndex++;
	}

/****************************************************************************
 ExpandArray:
	Expand the array to accomodate more elements coming in.
 ****************************************************************************/
 void
IDICT::ExpandArray()
	{
	IDICTELEMENT	*	pOldArray	= GetArray();
	IDICTELEMENT	*	pNewArray	= new
								IDICTELEMENT [(CurrentSize+IDictIncrement)];
	int			iIndex		= 0;

    //.. pOldArray moves, so we need pTemp to mark the beginning

	IDICTELEMENT	*	pTemp       = pOldArray;

	SetArray( pNewArray );
	CurrentSize	= short( CurrentSize + IDictIncrement );

	if( pOldArray )
		{
		while( iIndex++ < iNextIndex )
			{
			*pNewArray++ = *pOldArray++;
			}
		}

    delete pTemp;
	}
/***************************************************************************
 GetElement:
	return the element pointed to by the KEY (index)
 ***************************************************************************/
IDICTELEMENT
IDICT::GetElement(
	IDICTKEY	Key )
	{
	IDICTELEMENT	*	pArray	= GetArray();

	if( pArray && ( Key < iNextIndex ) )
		return pArray[ Key ];
	return (IDICTELEMENT) 0;
	}
/***************************************************************************
 IsElementPresent:
	return the element pointed to by the KEY (index)
 ***************************************************************************/
BOOL
IDICT::IsElementPresent(
	IDICTELEMENT	Element )
	{
	IDICTELEMENT	*	pArray	= GetArray();
	short				iIndex;

	if( pArray )
		{
		for( iIndex = 0; iIndex < iNextIndex; ++iIndex )
			{
			if( pArray[ iIndex ] == Element )
				return TRUE;
			}
		}
	return FALSE;
	}
/***************************************************************************
 AddElement:
	Basically SetNewElement, with checks for needed expansion. Notice how the
	array pointer is never accessed in this routine directly. This is becuase
	ExpandArray can potentially change the array underneath. So after evry
	expand call, must make sure that any local pointers to the array are
	updated.
 ***************************************************************************/
IDICTKEY
IDICT::AddElement(
	IDICTELEMENT	pNew )
	{
	if( iNextIndex >= CurrentSize )
		{
		ExpandArray();
		}
	return SetNewElement( pNew );
	}

/*****************************************************************************/

ISTACK::ISTACK(
	short MaxDepth )
	{
	InitNew( MaxDepth );
	CurrentElement = 0;
	}

void
ISTACK::InitNew(
	short MaxDepth )
	{
	MaxElements = MaxDepth;
	pStack = new IDICTELEMENT[ MaxElements ];
	}

IDICTELEMENT
ISTACK::Push( 
	IDICTELEMENT Element )
	{

	if( CurrentElement == MaxElements )
		{
		int 			i;
		IDICTELEMENT (*pStackOld);

		pStackOld = pStack;
		InitNew( short( MaxElements + 10 ) );

		for( i = 0;
			 i < CurrentElement;
			 ++i )
			{
			pStack[ i ] = pStackOld[ i ];
			}

		delete pStackOld;

		}

	pStack[ CurrentElement++ ] = Element;

	return Element;

	}

IDICTELEMENT
ISTACK::Pop()
	{
	MIDL_ASSERT( CurrentElement != 0 );
	return pStack[ --CurrentElement ];
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\common\midlvers.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

#define rmj             6
#define rmm             0
#define rup             347
#define szVerName       ""
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\common\midldebug.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    midldebug.h

 Abstract:

    assert and debugging routines

 Notes:


 Author:

    mzoran Feb-25-2000     Created.

 Notes:


 ----------------------------------------------------------------------------*/

#if !defined(__MIDLDEBUG_H__)
#define __MIDLDEBUG_H__

#if defined(MIDL_ENABLE_ASSERTS)

int DisplayAssertMsg(char *pFileName, int , char *pExpr );

#define MIDL_ASSERT( expr ) \
    ( ( expr ) ? 1 : DisplayAssertMsg( __FILE__ , __LINE__, #expr ) )
     
#else

#define MIDL_ASSERT( expr )

#endif

#endif // __MIDLDEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\common\nulldefs.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

#define _far
#define _near
#define _huge
#define _cdecl
#define _pascal
#define far
#define near
#define huge
#define cdecl
#define pascal
#define _syscall
#define _stdcall
#define _based(x)
#define _segment int
#define volatile
#define __far
#define __near
#define __huge
#define __cdecl
#define __pascal
#define __syscall
#define __based(x)
#define __segment int
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\driver\cmdline.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

#ifndef _CMDLINE_HXX_
#define _CMDLINE_HXX_

#include "idict.hxx"
#include "cmdana.hxx"

class CommandLine : public _cmd_arg
    {
    private:
        IDICT*    pArgDict;            // arguments dictionary
    public:
        CommandLine()
            {
            pArgDict = NULL;
            }

        // register argument vector with the command processor
        void            RegisterArgs( char *[], short );

        // process arguments. This is the command analyser main loop, so to speak.
        STATUS_T        ProcessArgs();

        // get the next argument from the argument vector.
        char    *       GetNextArg();

        // push back argument. Undo the effect of GetNextArg.
        void            UndoGetNextArg();

        // depending upon the switch argument type, bump the argument pointer to
        // the next switch.
        STATUS_T        BumpThisArg( char **, unsigned short );

        // set any post switch processing defaults

        STATUS_T        SetPostDefaults();
        void            SetPostDefaults64();

        // process a filename switch .

        STATUS_T        ProcessFilenameSwitch( short, char * );

        // process a multiple arguments switch.

        STATUS_T        ProcessMultipleSwitch( short, char *, char * );

        // process a onetime argument switch.

        STATUS_T        ProcessOnetimeSwitch( short, char * );

        // process an ordinary switch

        STATUS_T        ProcessOrdinarySwitch( short, char * );

        // process a simple switch multiply defined.

        STATUS_T        ProcessSimpleMultipleSwitch( short, char * );
        void            Confirm();
        STATUS_T        Help();
        char*           GetCompilerVersion();
        char*           GetCompileTime();
    };

#endif // _CMDLINE_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\common\stream.cxx ===
// Copyright (c) 1993-1999 Microsoft Corporation

#pragma warning ( disable : 4514 4710 )

#include "nulldefs.h"
#include <basetsd.h>
#include <stdio.h>
#include <stdarg.h>

#include <string.h>
#include <share.h>
#include <memory.h>
#include <io.h>
#include <fcntl.h>
#include <limits.h>
#include "stream.hxx"
#include "errors.hxx"
#include "cmdana.hxx"

STREAM::~STREAM()
	{
	Close();
	}

STREAM::STREAM(
	IN		char		*	pFileName,
	IN		unsigned char 	SProt )
{

	ResetConsoleStream();
	ResetIgnore();
	pSpecialCommentString = NULL;

	// no alternate file to begin with
	StreamOpenStatus = FILE_STATUS_OK;

	if( !pFileName )
	    {
		SetStreamType( STREAM_NULL );
		ResetError();
		ResetEnd();
		return;
	    }
	else if( *(pFileName+2) == '-' )
		{
		S.F.pHandle = stdout;
		SetConsoleStream();
		}
	else	// named file stream
		{
		// if this is a not a file to overwrite, and it exists, don't overwrite it
		// substitute a temp file instead
		if ( (SProt != FILE_STREAM_OVERWRITE) && 
			 !_access( pFileName, 0 ) )
			{
			if ( SProt == FILE_STREAM_REWRITE )
				{
				// note that tmpfile is opened w+b
				S.F.pHandle = tmpfile();
				StreamOpenStatus = FILE_STATUS_TEMP;
				}
			else	// write-once file already exists, do nothing
				{
				S.F.pHandle = NULL;
				StreamOpenStatus = FILE_STATUS_NO_WRITE;
				SetStreamType( STREAM_NULL );
				ResetError();
				ResetEnd();
				return;
				}
			}
		else	// overwritable file...
			{
            if ( pCommand->HasAppend64() || pCommand->Is2ndCodegenRun() )
                {
    			S.F.pHandle = _fsopen( pFileName, "r+t", SH_DENYWR);
            	if( S.F.pHandle )
                    {
                    // Position at the end of the file.
                    if ( 0 != fseek( S.F.pHandle, 0, SEEK_END ) )
                        {
                        fclose( S.F.pHandle );
                        S.F.pHandle = NULL;
                        }
                    }
                else
                    {
                    // May be the file does not exist, let's open to write.
                    // (it happens only when -append64 is used in the first run).

        			S.F.pHandle = _fsopen( pFileName, "wt", SH_DENYWR);
                    }
                }
            else
	    		S.F.pHandle = _fsopen( pFileName, "wt", SH_DENYWR);
			}

		if ( S.F.pHandle )
			{
			setvbuf( S.F.pHandle, NULL, _IOFBF, 32768 );
			}
		}

	if( S.F.pHandle == (FILE *)0 )
		{
		RpcError( (char *)NULL,
				  	0,
				  	ERROR_WRITING_FILE,
				  	pFileName );
	
		exit( ERROR_WRITING_FILE );
		}
	else
		{
		SetStreamType( STREAM_FILE );
        SetStreamMode( STREAM_TEXT );
		ResetError();
		ResetEnd();
		}
}

STREAM::STREAM(
	IN		FILE	* pFile )
{
	S.F.pHandle = pFile;
    SetStreamType( STREAM_FILE );
    SetStreamMode( STREAM_TEXT );
	ResetError();
	ResetEnd();
	ResetIgnore();
    ResetConsoleStream();
	pSpecialCommentString = NULL;

	// no alternate file to begin with
	StreamOpenStatus = FILE_STATUS_OK;
}

STREAM::STREAM()
{
    S.F.pHandle = NULL;
	SetStreamType( STREAM_MEMORY );
    SetStreamMode( STREAM_TEXT );
	ResetEnd();
	ResetError();
	ResetIgnore();
    ResetConsoleStream();
	StreamOpenStatus = FILE_STATUS_OK;
    pSpecialCommentString = NULL;

	SetCurrentPtr( new char[ SetInitialSize( DEFAULT_MEM_SIZE_FOR_STREAM ) ] );
	SetInitialIncr( DEFAULT_MEM_INCR_FOR_STREAM );
	SetStart( GetCurrentPtr() );
	SetMemStreamEnd( GetCurrentPtr() + GetInitialSize() );
}

STREAM::STREAM(
	int		InitialSize,
	int		InitialIncr )
{
    S.F.pHandle = NULL;
	SetStreamType( STREAM_MEMORY );
    SetStreamMode( STREAM_TEXT );
	ResetEnd();
	ResetError();
	ResetIgnore();
    ResetConsoleStream();
	StreamOpenStatus = FILE_STATUS_OK;
    pSpecialCommentString = NULL;

	SetCurrentPtr( new char[ SetInitialSize( InitialSize ) ] );
	SetInitialIncr( InitialIncr );
	SetStart( GetCurrentPtr() );
	SetMemStreamEnd( GetCurrentPtr() + GetInitialSize() );
}

void
STREAM::SetStreamMode(
    STREAM_MODE mode)
{
    StreamMode = mode;
    int newmode = ( mode == STREAM_BINARY ) ? _O_BINARY : _O_TEXT;

    if (S.F.pHandle)
        _setmode( _fileno( S.F.pHandle ), newmode );
}

#if 0

void
STREAM::Write(
	IN		char	C )
{
	if( (GetStreamType() == STREAM_FILE ) && !IsError() )
		putc( C, S.F.pHandle );
	else
		{
		if( S.M.pCurrent >= S.M.pEnd )
			{
			Expand();
			}
		*(S.M.pCurrent)++ = C;
		}
}
#endif // 0

void 
STREAM::Write(
    IN      const void  *  p, 
    IN      int Len)
{
    if ( ( GetStreamType() == STREAM_NULL ) || IsError() || IsIgnore() )
        return;

    if( (GetStreamType() == STREAM_FILE ) )
        {
        fwrite( p, 1, Len, S.F.pHandle );
        if( IsConsoleStream() )
            fflush( S.F.pHandle );
        }
    else
        {
        if( (GetCurrentPtr() + Len) >= S.M.pEnd )
            {
            ExpandBy( short( Len + GetInitialIncr() ) );
            }
        memcpy( GetCurrentPtr(), p, Len );
        SetCurrentPtr( GetCurrentPtr() + Len );
        }
}

void 
STREAM::Write(
    IN      const char  *  const  string)
{
    if ( string )
        Write( (void *) string, strlen( string ) );

    if ( GetStreamMode() == STREAM_BINARY )
        Write( '\0' );
}

void
STREAM::WriteNumber(
	IN		const char	*	pFmt,
	IN		const unsigned long ul )
{
	char	buffer[128];

	if ( ( GetStreamType() == STREAM_NULL ) || IsError() || IsIgnore() )
		return;

	if( (GetStreamType() == STREAM_FILE ) )
		{
		fprintf(  S.F.pHandle, pFmt, ul );
		if( IsConsoleStream() )
			fflush( S.F.pHandle );
		}
	else
		{
		sprintf( buffer, pFmt, ul );

		short Len	= (short) strlen( buffer );

		if( (GetCurrentPtr() + Len) >= S.M.pEnd )
			{
			ExpandBy( short( Len + GetInitialIncr() ) );
			}
		memcpy( GetCurrentPtr(), buffer, Len );
		SetCurrentPtr( GetCurrentPtr() + Len );
		}
}

void
STREAM::WriteFormat(
        const char * pFmt,
        ... )
{

    char	buffer[128];    

	if ( ( GetStreamType() == STREAM_NULL ) || IsError() || IsIgnore() )
		return;
        
        va_list Arguments;
        va_start( Arguments, pFmt );        

	if( (GetStreamType() == STREAM_FILE ) )
		{
		vfprintf(  S.F.pHandle, pFmt, Arguments );
		if( IsConsoleStream() )
			fflush( S.F.pHandle );
		}
	else
		{
		vsprintf( buffer, pFmt, Arguments );

		short Len	= (short) strlen( buffer );

		if( (GetCurrentPtr() + Len) >= S.M.pEnd )
			{
			ExpandBy( short( Len + GetInitialIncr() ) );
			}
		memcpy( GetCurrentPtr(), buffer, Len );
		SetCurrentPtr( GetCurrentPtr() + Len );
		}

        va_end( Arguments );
}


void
STREAM::Flush()
{

	if( (GetStreamType() == STREAM_FILE ) && !IsError() )
		if( IsConsoleStream() )
			fflush( S.F.pHandle );
}

void
STREAM::Close()
{
	if( (GetStreamType() == STREAM_FILE ) )
		fclose( S.F.pHandle );
}

int
STREAM::SetInitialSize(
	int	InitialSize )
{
	if( GetStreamType() == STREAM_MEMORY )
		return (S.M.InitialSize = InitialSize);

	return 0;
}

int
STREAM::GetInitialSize()
{
	if( GetStreamType() == STREAM_MEMORY )
		return S.M.InitialSize;
	return 0;
}

int
STREAM::SetInitialIncr(
	int	InitialIncr )
{
	if( GetStreamType() == STREAM_MEMORY )
		return (S.M.Increment = InitialIncr);
	return 0;
}

int
STREAM::GetInitialIncr()
{
	if( GetStreamType() == STREAM_MEMORY )
		return S.M.Increment;

	return 0;
}

char *
STREAM::Expand()
{
	if( GetStreamType() == STREAM_MEMORY )
		{
		int	Len 	 = GetInitialSize();
		char * pTemp = GetStart();

		SetStart( new char[ SetInitialSize( Len + GetInitialIncr() ) ] );

		memcpy( GetStart(), pTemp, Len );
		SetCurrentPtr( GetStart() + Len );
		delete pTemp;
		return GetCurrentPtr();
		}

	return 0;
}
char *
STREAM::ExpandBy( short Amt)
{
	if( GetStreamType() == STREAM_MEMORY )
		{
		int	Len 	 = GetInitialSize();
		char * pTemp = GetStart();

		SetStart( new char[ SetInitialSize( Len + GetInitialIncr() + Amt ) ] );

		memcpy( GetStart(), pTemp, Len );
		SetCurrentPtr( GetStart() + Len );
		delete pTemp;
		return GetCurrentPtr();
		}

	return 0;
}
char *
STREAM::NewCopy()
	{
	if( GetStreamType() == STREAM_MEMORY )
		{
        MIDL_ASSERT( (S.M.pCurrent - S.M.pMem + 1) <= INT_MAX );
		int Len = (int) (S.M.pCurrent - S.M.pMem + 1);
		char * p = new char[ Len ]; 
		memcpy( p, S.M.pMem, Len );
		return p;
		}
	return 0;
	}

char *
STREAM::SetCurrentPtr(
	char * pCur)
{
	if( GetStreamType() == STREAM_MEMORY )
		return (S.M.pCurrent = pCur);
	return 0;
}

char *
STREAM::GetCurrentPtr()
{
	if( GetStreamType() == STREAM_MEMORY )
		return S.M.pCurrent;
	return 0;
}

long
STREAM::GetCurrentPosition()
{
    long Position = 0;

    if( GetStreamType() == STREAM_FILE )
        Position = ftell( S.F.pHandle );

    return Position;
}

void
STREAM::SetCurrentPosition( long Position)
{
    if( GetStreamType() == STREAM_FILE )
        if ( 0 != fseek( S.F.pHandle, Position, SEEK_SET ) )
            MIDL_ASSERT(!"fseek failed");

    return;
}


char *
STREAM::SetStart(
	char * pStart)
{
	if( GetStreamType() == STREAM_MEMORY )
		return (S.M.pMem = pStart);
	return 0;
}

char *
STREAM::GetStart()
{
	if( GetStreamType() == STREAM_MEMORY )
		return S.M.pMem;
	return 0;
}

#define MAX_INDENT (sizeof(SpaceBuffer) - 1)

static
char SpaceBuffer[] = "                                                      "
		 "                                                                  "
		 "                                                                  "
		 "                                                                  ";

#define MAX_NEWLINES (sizeof(NewLineBuffer) - 1)

static
char NewLineBuffer[] = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n";


void
ISTREAM::NewLine()
{
	unsigned short	usIndent	= CurrentIndent;

	if (usIndent > MAX_INDENT )
		{
		usIndent = MAX_INDENT;
		};

	Write('\n');

	SpaceBuffer[usIndent] = '\0';
	Write( (char *) SpaceBuffer);

	SpaceBuffer[usIndent] = ' ';
}

void
ISTREAM::NewLine( unsigned short count )
{
	unsigned short	usIndent	= CurrentIndent;

	if (usIndent > MAX_INDENT )
		{
		usIndent = MAX_INDENT;
		};

	if ( count > MAX_NEWLINES )
		{
		count = MAX_NEWLINES;
		};

	NewLineBuffer[ count ] = '\0';
	Write( (char *) NewLineBuffer);
	NewLineBuffer[ count ] = '\n';

	SpaceBuffer[usIndent] = '\0';
	Write( (char *) SpaceBuffer);

	SpaceBuffer[usIndent] = ' ';
}


void
ISTREAM::Spaces(
	unsigned short NoOfSpaces )
{
	if (NoOfSpaces > MAX_INDENT )
		{
		NoOfSpaces = MAX_INDENT;
		};

	SpaceBuffer[NoOfSpaces] = '\0';
	Write( (char *) SpaceBuffer);

	SpaceBuffer[NoOfSpaces] = ' ';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\driver\cmdana.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    cmdana.cxx


 Abstract:

    This file handles all command (switch) processing for the MIDL compiler.

 Notes:


 Author:

    vibhasc

    Nov-12-1991    VibhasC        Modified to conform to coding style gudelines


 Notes:

    The command analysis is handled by a command analyser object. The MIDL
    compiler registers its arguments with the command analyser and calls the
    ProcessArgs functions. The ProcessArgs performs syntactic analysis of the
    switch specification by checking for (1) proper switch syntax, (2) duplicate
    definition of the switch, and (3) illegal switch specification. After all
    the switches are analysed, the SetPostDefault function is called to set the
    default compiler switch values etc.

    Currently switches fall into these categories:

        (1) one-time switches : these can be specified only once, and the
            redefinition results in a warning and the second defintion
            overrides the first. Examples are -cc_cmd / -cc_opt etc.

        (2) multiple definition switches: such switches can be specified
            multiple times. These include /I, /D, /U etc.

        (3) filename switches : this is switch class specialises in filename
            argument handling.

        (4) ordinary switches : all other switches fall into this category.
            Normally a redef of such a switch is also a warning. These are
            different from the one-time switch category just for convenience.
            These switches normally set some internal flag etc and do not need
            the user specified argument to be stored in string form like
            the -cc_cmd etc.

    A general word about the command analyser. Switch syntax comes in various
    flavours. Some switches take arguments, some do not. Switches which have
    arguments may have spaces necesary between the arguments and switch name,
    others may not. The most interesting case, however is when the switch
    may have as its argument a switch-like specification, which should not be
    confused with another MIDL switch. We keep a data-base of switches in the
    switch descriptor, which keeps info about the switch name, switch
    enumeration and the switch syntax descriptor. The core switch syntax
    analyser is BumpThisArg which uses this descriptor.

    Also, some switches like -W? and -Wx must really be separate switches
    because -W? and -Wx can co-exist at the same time. If we treat the switch
    recognition as the same, then the code must detect a separate definition,
    and set the command analyser flags.This approach results in unnecessary code
    all over the place. An alternative is to recognise the Wx as a separate
    switch in the SearchForSwitch routine and return a different switch to
    the command analyser. This is a much cleaner approach. Only, the parsing
    becomes tricky. Since -W? and -Wx look VERY similar, and SearchForSwitch
    stops at the first match, we need to define -Wx BEFORE -W in the switch
    descriptor table. This happens also with the client client_env and -server
    and -server_env switches. In any case it we remember to properly keep
    tables such that the longer string is kept first, this problem gets isolated
    to a very small, manageable part of the command analyser. I therefore
    chose this approach.

     Note: MIDL_INTERNAL is specified by a C preprocessor command line -D option.
     This corresponds to debugging builds for internal purposes only.
 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 4710 )

/****************************************************************************
 *    include files
 ***************************************************************************/

#include "cmdline.h"
#include "stream.hxx"
#include "midlvers.h"

#include <string.h>
#include <io.h>
#include <time.h>

/****************************************************************************
 *    local definitions
 ***************************************************************************/

/**
 ** definitions for the type of switch arguments.
 ** switches may or may not expect arguments, there may be spaces
 ** between the switch and its argument(s). One special case is when the
 ** argument can be switch like, .ie have the - or / as the argument starter,
 ** so we need to treat such switches specially.
 **/

#define ARG_NONE            (0x01)        /* no arg for this switch */
#define ARG_YES             (0x02)        /* arg expected for this switch */
#define ARG_SPACE           (0x04)        /* (a) space(s) may be present */
#define ARG_NO_SPACE        (0x08)        /* no space is allowed */
#define ARG_SWITCH_LIKE     (0x10)        /* the arg may be switch-like */
#define ARG_OPTIONAL        (ARG_YES + ARG_NONE + ARG_SPACE)


#define ARG_SPACED            (ARG_YES + ARG_SPACE)
#define ARG_SPACE_NONE        (ARG_YES + ARG_NO_SPACE)
#define ARG_SPACE_OPTIONAL    (ARG_YES + ARG_NO_SPACE + ARG_SPACE)
#define ARG_CC_ETC            (ARG_SPACE_OPTIONAL + ARG_SWITCH_LIKE)

/***
 *** Preferably keep this table sorted by name.
 *** Also, partially matching names like -client / -client_env, -W/-Wx must
 *** be kept so that the longer sub-string appears first. The only
 *** reason to keep this sorted, is so that we can visually ensure this.
 ***/

const struct sw_desc
    {
    const char     *        pSwitchName;        // switch string
    unsigned short          flag;               // switch descriptor
    enum _swenum            SwitchValue;        // switch enum value
    } switch_desc[] = {
          { "",              ARG_NONE            , SWITCH_NOTHING }
        , { "?",             ARG_NONE            , SWITCH_HELP }
        , { "D",             ARG_SPACE_OPTIONAL  , SWITCH_D }
        , { "I",             ARG_SPACE_OPTIONAL  , SWITCH_I }
        , { "O",             ARG_SPACE_OPTIONAL  , SWITCH_O }
        , { "U",             ARG_SPACE_OPTIONAL  , SWITCH_U }
        , { "WX",            ARG_NONE            , SWITCH_WX }
        , { "W",             ARG_SPACE_NONE      , SWITCH_W }
        , { "Zp",            ARG_SPACE_NONE      , SWITCH_ZP }
        , { "Zs",            ARG_NONE            , SWITCH_ZS }
        , { "append64",      ARG_NONE            , SWITCH_APPEND64 }
        , { "acf",           ARG_SPACE_OPTIONAL  , SWITCH_ACF }
        , { "c_ext",         ARG_NONE            , SWITCH_C_EXT }
        , { "char",          ARG_SPACED          , SWITCH_CHAR }
        , { "client",        ARG_SPACED          , SWITCH_CLIENT }
        , { "confirm",       ARG_NONE            , SWITCH_CONFIRM }
        , { "nologo",        ARG_NONE            , SWITCH_NOLOGO }
        , { "cpp_cmd",       ARG_CC_ETC          , SWITCH_CPP_CMD }
        , { "cpp_opt",       ARG_CC_ETC          , SWITCH_CPP_OPT }
        , { "msc_ver",       ARG_SPACED          , SWITCH_MSC_VER }
        , { "cstub",         ARG_CC_ETC          , SWITCH_CSTUB }
        , { "nocstub",       ARG_NONE            , SWITCH_NO_CLIENT }

#ifdef MIDL_INTERNAL
        , { "dump",          ARG_NONE            , SWITCH_DUMP }
#endif // MIDL_INTERNAL

        , { "debugexc",      ARG_NONE            , SWITCH_DEBUGEXC }
        , { "debugline",     ARG_NONE            , SWITCH_DEBUGLINE }
        , { "debug64_opt",   ARG_SPACED          , SWITCH_DEBUG64_OPT }
        , { "debug64",       ARG_SPACED          , SWITCH_DEBUG64 }
        , { "dlldata",       ARG_CC_ETC          , SWITCH_DLLDATA }
        , { "env",           ARG_SPACED          , SWITCH_ENV }
        , { "error",         ARG_SPACED          , SWITCH_ERROR }
        , { "robust",        ARG_NONE            , SWITCH_ROBUST }
        , { "header",        ARG_CC_ETC          , SWITCH_HEADER }
        , { "help",          ARG_NONE            , SWITCH_HELP }
        , { "iid",           ARG_CC_ETC          , SWITCH_IID }
        , { "internal",      ARG_NONE            , SWITCH_INTERNAL }
        , { "lcid",          ARG_SPACED          , SWITCH_LOCALE_ID }
        , { "mktyplib203",   ARG_NONE            , SWITCH_MKTYPLIB }
        , { "newtlb",        ARG_NONE            , SWITCH_NEW_TLB }
        , { "no_cpp",        ARG_NONE            , SWITCH_NO_CPP }
        , { "no_def_idir",   ARG_NONE            , SWITCH_NO_DEF_IDIR }
        , { "no_warn",       ARG_NONE            , SWITCH_NO_WARN }
        , { "use_epv",       ARG_NONE            , SWITCH_USE_EPV }
        , { "no_default_epv",ARG_NONE            , SWITCH_NO_DEFAULT_EPV }
        , { "no_robust",     ARG_NONE            , SWITCH_NO_ROBUST }
        , { "no_stamp",      ARG_NONE            , SWITCH_NO_STAMP }
        , { "oldnames",      ARG_NONE            , SWITCH_OLDNAMES }
        , { "oldtlb",        ARG_NONE            , SWITCH_OLD_TLB }
        , { "osf",           ARG_NONE            , SWITCH_OSF }
        , { "out",           ARG_SPACE_OPTIONAL  , SWITCH_OUT }

#ifdef MIDL_INTERNAL
        , { "override",      ARG_NONE            , SWITCH_OVERRIDE }
#endif // MIDL_INTERNAL

        , { "pack",          ARG_SPACED          , SWITCH_PACK }
        , { "prefix",        ARG_SPACED          , SWITCH_PREFIX }
//        , { "suffix",        ARG_SPACED          , SWITCH_SUFFIX }
        , { "proxy",         ARG_CC_ETC          , SWITCH_PROXY }
        , { "noproxy",       ARG_NONE            , SWITCH_NO_PROXY }
        , { "proxydef",      ARG_CC_ETC          , SWITCH_PROXY_DEF }
        , { "noproxydef",    ARG_NONE            , SWITCH_NO_PROXY_DEF }
        , { "dlldef",        ARG_CC_ETC          , SWITCH_DLL_SERVER_DEF }
        , { "nodlldef",      ARG_NONE            , SWITCH_NO_DLL_SERVER_DEF }
        , { "dllmain",       ARG_CC_ETC          , SWITCH_DLL_SERVER_CLASS_GEN }
        , { "nodllmain",     ARG_NONE            , SWITCH_NO_DLL_SERVER_CLASS_GEN }
        , { "reg",           ARG_CC_ETC          , SWITCH_SERVER_REG }
        , { "noreg",         ARG_NONE            , SWITCH_NO_SERVER_REG }
        , { "exesuppt",      ARG_CC_ETC          , SWITCH_EXE_SERVER }
        , { "noexesuppt",    ARG_NONE            , SWITCH_NO_EXE_SERVER }
        , { "exemain",       ARG_CC_ETC          , SWITCH_EXE_SERVER_MAIN }
        , { "noexemain",     ARG_NONE            , SWITCH_NO_EXE_SERVER_MAIN }
        , { "testclient",    ARG_CC_ETC          , SWITCH_TESTCLIENT }
        , { "notestclient",  ARG_NONE            , SWITCH_NO_TESTCLIENT }
        , { "methods",       ARG_CC_ETC          , SWITCH_CLASS_METHODS }
        , { "nomethods",     ARG_NONE            , SWITCH_NO_CLASS_METHODS }
        , { "iunknown",      ARG_CC_ETC          , SWITCH_CLASS_IUNKNOWN }
        , { "noiunknown",    ARG_NONE            , SWITCH_NO_CLASS_IUNKNOWN }
        , { "class_hdr",     ARG_CC_ETC          , SWITCH_CLASS_HEADER }
        , { "noclass_hdr",   ARG_NONE            , SWITCH_NO_CLASS_HEADER }

        , { "savePP",        ARG_NONE            , SWITCH_SAVEPP }

        , { "server",        ARG_SPACED          , SWITCH_SERVER }
        , { "sstub",         ARG_CC_ETC          , SWITCH_SSTUB }
        , { "nosstub",       ARG_NONE            , SWITCH_NO_SERVER }
        , { "syntax_check",  ARG_NONE            , SWITCH_SYNTAX_CHECK }
        , { "target",        ARG_SPACED          , SWITCH_TARGET_SYSTEM }
        , { "warn",          ARG_SPACED          , SWITCH_W }

#ifdef MIDL_INTERNAL
        , { "x",             ARG_NONE            , SWITCH_X }
#endif // MIDL_INTERNAL

        , { "ms_ext",        ARG_NONE            , SWITCH_MS_EXT }
        , { "ms_conf_struct",ARG_NONE            , SWITCH_MS_CONF_STRUCT }
        , { "ms_union",      ARG_NONE            , SWITCH_MS_UNION }
        , { "no_format_opt", ARG_NONE            , SWITCH_NO_FMT_OPT }
        , { "app_config",    ARG_NONE            , SWITCH_APP_CONFIG }
        , { "rpcss",         ARG_NONE            , SWITCH_RPCSS }
        , { "hookole",       ARG_NONE            , SWITCH_HOOKOLE }
        , { "netmonstub",    ARG_CC_ETC          , SWITCH_NETMON_STUB_OUTPUT_FILE}
        , { "netmonobjstub", ARG_CC_ETC          , SWITCH_NETMON_STUB_OBJ_OUTPUT_FILE}
        , { "netmon",        ARG_NONE            , SWITCH_NETMON }
        , { "version_stamp", ARG_NONE            , SWITCH_VERSION_STAMP }
// MKTYPLIB switches
        , { "tlb",           ARG_SPACED          , SWITCH_TLIB }
        , { "o",             ARG_SPACED          , SWITCH_REDIRECT_OUTPUT }
        , { "h",             ARG_CC_ETC          , SWITCH_HEADER }
        , { "align",         ARG_SPACE_OPTIONAL  , SWITCH_ZP }
        , { "nocpp",         ARG_NONE            , SWITCH_NO_CPP }
        , { "wire_compat"   ,ARG_SPACED          , SWITCH_WIRE_COMPAT }
        , { "wi",            ARG_SPACE_NONE      , SWITCH_ODL_ENV } // win16, win32, win64
        , { "do",            ARG_SPACE_NONE      , SWITCH_ODL_ENV } // dos
        , { "ma",            ARG_SPACE_NONE      , SWITCH_ODL_ENV } // mac
        , { "po",            ARG_SPACE_NONE      , SWITCH_ODL_ENV } // powermac

        , { "no_buffer_reuse", ARG_NONE          , SWITCH_NOREUSE_BUFFER }
        , { "use_vt_int_ptr",ARG_NONE            , SWITCH_USE_VT_INT_PTR }
        , { "notlb"         ,ARG_NONE            , SWITCH_NO_TLIB }
        , { "protocol"      ,ARG_SPACED          , SWITCH_TRANSFER_SYNTAX }
        , { "ms_ext64"      ,ARG_NONE            , SWITCH_MS_EXT64 }
        , { "debuginfo"     ,ARG_NONE            , SWITCH_DEBUGINFO }
    };

const CHOICE    CharChoice[] =
    {
         { "signed"         , CHAR_SIGNED }
        ,{ "unsigned"       , CHAR_UNSIGNED }
        ,{ "ascii7"         , CHAR_ANSI7 }
        ,{ 0                , 0 }
    };

const CHOICE    ErrorChoice[] =
    {
         { "all"            , ERROR_ALL }
        ,{ "allocation"     , ERROR_ALLOCATION }
        ,{ "bounds_check"   , ERROR_BOUNDS_CHECK }
        ,{ "enum"           , ERROR_ENUM }
        ,{ "ref"            , ERROR_REF }
        ,{ "stub_data"      , ERROR_STUB_DATA }
        ,{ "none"           , ERROR_NONE }
        ,{ 0                , 0 }
    };

const CHOICE    EnvChoice[] =
    {
         { "dos"            , ENV_OBSOLETE }
        ,{ "win16"          , ENV_OBSOLETE }
        ,{ "win32"          , ENV_WIN32 }
        ,{ "win64"          , ENV_WIN64 }
        ,{ "mac"            , ENV_OBSOLETE }
        ,{ "powermac"       , ENV_OBSOLETE }
        ,{ 0                , 0 }
    };

const CHOICE    SyntaxChoice[] =
    {
        { "dce"             , SYNTAX_DCE }
       ,{ "ndr64"           , SYNTAX_NDR64 }
       ,{ "all"             , SYNTAX_BOTH  }
       ,{ 0                 , 0 }
    };
    
const CHOICE    TargetChoice[] =
    {
         { "NT40"           , NT40 }
        ,{ "NT50"           , NT50 }
        ,{ "NT51"           , NT51 }
        ,{ 0                , 0 }
    };

const CHOICE    ClientChoice[]    =
    {
         { "stub"           , CLNT_STUB }
        ,{ "none"           , CLNT_NONE }
        ,{ 0                , 0 }
    };

const CHOICE    ServerChoice[]    =
    {
         { "stub"           , SRVR_STUB }
        ,{ "none"           , SRVR_NONE }
        ,{ 0                , 0 }
    };

const CHOICE    WireCompatChoice[]  =
    {
         { "enum16unionalign", WIRE_COMPAT_ENUM16UNIONALIGN }
        ,{ 0                 , 0 }
    };


#define IS_NUMERIC_1( pThisArg ) ((strlen( pThisArg) == 1 )  &&  \
                                  (isdigit( *pThisArg )) )

// this is now the same for ALL platforms
#define C_COMPILER_NAME()           ("cl.exe")
#define C_PREPROCESSOR_NAME()       ("cl.exe")
#define ADDITIONAL_CPP_OPT()        (" -E -nologo")

#define MIDL_HELP_FILE_NAME         ("midl.hlp")

/****************************************************************************
 *    local data
 ***************************************************************************/

/****************************************************************************
 *    externs
 ***************************************************************************/


extern    void              ReportUnimplementedSwitch( short );
extern    char    *         SwitchStringForValue( unsigned short );
extern    _swenum           SearchForSwitch( char ** );
extern    STATUS_T          SelectChoice( const CHOICE *, char *, short *);
extern    bool              PPCmdEngine( int argc, char *argv[], IDICT * );

extern    void              PrintArg( enum _swenum, char *, char * );

void CmdProcess( pair_switch*,  CommandLine*, char* );
/****************************************************************************/

void
CommandLine::RegisterArgs(
    char    *   pArgs[],
    short       cArguments
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    This routine registers with the command analyser the argument vector
    and argument count for user supplied arguments.

 Arguments:

    pArgs        -    Array of pointers to arguments ( switches etc ).
    cArguments   -    count of arguments.

 Return Value:

    None.

 Notes:

    The process of registering the arguments consists of keeping a local
    copy of the argument vector pointer and count.

    The argument vector is passed such that the argv[1] is the first
    argument available to the command processor. Therefore , count is
    one less too.

    Why do we need registering the arguments ? In the process of parsing
    we might want to skip an argument back or forward. So we keep a local
    copy of the pointer to the arguments.


----------------------------------------------------------------------------*/
    {
    iArgV   = 0;
    pArgDict= new IDICT( 10, 5 );
    fShowLogo = PPCmdEngine( cArguments, pArgs, pArgDict );
    cArgs   = pArgDict->GetCurrentSize();
    }

char *
CommandLine::GetNextArg()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get the next argument in the argument vector.


 Arguments:

    None.

 Return Value:

    returns a pointer to the next argument.

 Notes:

    if no more arguments
        return a null.
    else
        return the next argument pointer.
        decrement the count, increment the pointer to point to the next arg.

----------------------------------------------------------------------------*/
    {
    if(cArgs == 0 )
        return (char *)NULL;
    cArgs--;
    return (char *)pArgDict->GetElement( (IDICTKEY)iArgV++);
    }

void
CommandLine::UndoGetNextArg()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Undo the effect of the last GetNextArg call.

 Arguments:

    None.

 Return Value:

    None.

 Notes:

    if this is not the first argument already
        Push back the argument pointer.
        Increment count.
    else
        Do nothing.

    This prepares the argument  vector to accept more GetNextArgCalls.
----------------------------------------------------------------------------*/
    {
    if(iArgV == 0)
        return;
    cArgs++;
    iArgV--;
    }

STATUS_T
CommandLine::ProcessArgs()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Process command line arguments.

 Arguments:

    None.

 Return Value:

    STATUS_OK    - if all is well
    Error Status otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    char            *   pThisArg,
                   *    pThisArgSave;
    STATUS_T            Status, ReturnStatus    = STATUS_OK;
    enum _swenum        iSwitch;
    short               fSwitchDetected;
    unsigned short      SwitchValue;


    // loop till all arguments have been processed.

    while ( ( pThisArg = GetNextArg() ) != 0 )
        {

        fSwitchDetected    = 0;
        iSwitch            = SWITCH_NOTHING;
    
        // save this pointer, it is useful for error reporting.

        pThisArgSave = pThisArg;

        // if we saw a - or a / we have detected a switch. Get the index of
        // the switch in the switch descriptor table. If the returned index
        // was zero, either the switch was not a valid one, or we saw an input
        // which is taken as an input filename specification. If the input
        // filename has already been specified, this is an error.

        if( *pThisArg == '-' || *pThisArg == '/' )
            {
            pThisArg++;
            fSwitchDetected    = 1;
            iSwitch            = SearchForSwitch( &pThisArg );
            }

        if( iSwitch == SWITCH_NOTHING )
            {

            if( fSwitchDetected || IsSwitchDefined( BASE_FILENAME ) )
                {
                char    *    p = new char[ strlen(pThisArg)+2+1 ];

                sprintf(p, "\"%s\"", pThisArg );

                RpcError( (char *)NULL,
                          0,
                          fSwitchDetected ? UNKNOWN_SWITCH : UNKNOWN_ARGUMENT,
                          p);

                delete p;
                }
            else
                {

                // the only way we can get here is if he did not specify a
                // switch like input AND the input filename has not been
                // defined yet. Hence this must be the input filename.

                pInputFNSwitch = new filename_switch( pThisArg);

                SwitchDefined( BASE_FILENAME );

                }

            continue;

            }


        // bump the input pointer to point to the argument. Depending on
        // what type of argument this switch takes ( spaced, non-spaced,
        // switch-like etc ) bump the argument pointer to the actual argument.

        SwitchValue = unsigned short ( switch_desc[ iSwitch ].SwitchValue );

        Status = BumpThisArg( &pThisArg, switch_desc[ iSwitch ].flag );

        if( Status != STATUS_OK )
            {
            RpcError( (char *)NULL,
                      0,
                      Status,
                      pThisArgSave );
            continue;
            }

        MIDL_ASSERT(NULL != pThisArg);

        // Process the switch. The input pointer is pointing to the
        // argument to the switch, after the '-' or '/'.

        switch( SwitchValue )
            {
            case SWITCH_CSTUB:
            case SWITCH_HEADER:
            case SWITCH_ACF:
            case SWITCH_SSTUB:
            case SWITCH_OUT:
            case SWITCH_IID:
            case SWITCH_PROXY:
            case SWITCH_TESTCLIENT:
            case SWITCH_CLASS_METHODS:
            case SWITCH_CLASS_HEADER:
            case SWITCH_CLASS_IUNKNOWN:
            case SWITCH_PROXY_DEF:
            case SWITCH_DLL_SERVER_DEF:
            case SWITCH_DLL_SERVER_CLASS_GEN:
            case SWITCH_SERVER_REG:
            case SWITCH_EXE_SERVER:
            case SWITCH_EXE_SERVER_MAIN:
            case SWITCH_DLLDATA:
            case SWITCH_TLIB:
            case SWITCH_REDIRECT_OUTPUT:
            case SWITCH_NETMON_STUB_OUTPUT_FILE:
            case SWITCH_NETMON_STUB_OBJ_OUTPUT_FILE:
                Status = ProcessFilenameSwitch( SwitchValue, pThisArg );
                break;

            case SWITCH_LOCALE_ID:
            case SWITCH_PACK:
            case SWITCH_ZP:
            case SWITCH_NO_WARN:
            case SWITCH_USE_EPV:
            case SWITCH_NO_DEFAULT_EPV:
            case SWITCH_DEBUGEXC:
            case SWITCH_DEBUGLINE:
            case SWITCH_SYNTAX_CHECK:
            case SWITCH_ZS:
            case SWITCH_NO_CPP:
            case SWITCH_CLIENT:
            case SWITCH_SERVER:
            case SWITCH_ENV:
            case SWITCH_TARGET_SYSTEM:
            case SWITCH_RPCSS:
            case SWITCH_NETMON:
            case SWITCH_VERSION_STAMP:
            case SWITCH_DUMP:
            case SWITCH_OVERRIDE:
            case SWITCH_SAVEPP:
            case SWITCH_NO_DEF_IDIR:
            case SWITCH_VERSION:
            case SWITCH_CONFIRM:
            case SWITCH_NOLOGO:
            case SWITCH_CHAR:
            case SWITCH_HELP:
            case SWITCH_W:
            case SWITCH_WX:
            case SWITCH_X:
            case SWITCH_O:
            case SWITCH_APPEND64:
            case SWITCH_APP_CONFIG:
            case SWITCH_MS_EXT:
            case SWITCH_MS_CONF_STRUCT:
            case SWITCH_MS_UNION:
            case SWITCH_OLDNAMES:
            case SWITCH_NO_FMT_OPT:
            case SWITCH_GUARD_DEFS:
            case SWITCH_INTERNAL:
            case SWITCH_NO_STAMP:
            case SWITCH_ROBUST:
            case SWITCH_NO_ROBUST:
            case SWITCH_C_EXT:
            case SWITCH_OSF:
            case SWITCH_MKTYPLIB:
            case SWITCH_OLD_TLB:
            case SWITCH_NEW_TLB:
            case SWITCH_NOREUSE_BUFFER:
            case SWITCH_USE_VT_INT_PTR:
            case SWITCH_NO_TLIB:
            case SWITCH_TRANSFER_SYNTAX:
            case SWITCH_MS_EXT64:
            case SWITCH_DEBUGINFO:
                Status = ProcessOrdinarySwitch( SwitchValue, pThisArg );
                break;
            
            case SWITCH_ODL_ENV:
                Status = ProcessOrdinarySwitch( SwitchValue, pThisArg );
                SwitchValue = SWITCH_ENV;
                break;

            case SWITCH_ERROR:
            case SWITCH_WIRE_COMPAT:                
                Status = ProcessSimpleMultipleSwitch( SwitchValue, pThisArg );
                break;

            case SWITCH_D:
            case SWITCH_I:
            case SWITCH_U:

                // specifically for -D/-I/-U we want the two characters
                // -I / -D / -U inside too, so that we can pass it as such to
                // the c preprocessor.

                Status = ProcessMultipleSwitch( SwitchValue, pThisArgSave, pThisArg );
                break;


            case SWITCH_MSC_VER:
            case SWITCH_CPP_CMD:
            case SWITCH_CPP_OPT:
            case SWITCH_DEBUG64_OPT:
            case SWITCH_DEBUG64:
                Status = ProcessOnetimeSwitch( SwitchValue, pThisArg );
                break;

            case SWITCH_PREFIX:

                CmdProcess( pSwitchPrefix, this, pThisArg );
                break;

            case SWITCH_HOOKOLE:
                RpcError( NULL, 0, SWITCH_NOT_SUPPORTED_ANYMORE, "hookole" );
                break;

            default:

                ReportUnimplementedSwitch( SwitchValue );
                continue;
            }

        // set up the defintion vector, to indicate that the switch has been
        // defined.

        if( Status == ILLEGAL_ARGUMENT )
            ReturnStatus = ILLEGAL_ARGUMENT;

        SwitchDefined( SwitchValue );

        }

    if (!IsSwitchDefined(SWITCH_OSF))
        {
            SwitchDefined(SWITCH_C_EXT);
            SwitchDefined(SWITCH_MS_EXT);
        }

    // if the user has asked for output to be redirected, redirect stdout
    if (IsSwitchDefined(SWITCH_REDIRECT_OUTPUT))
        {
        FILE * pFH;
        char * newfile = pRedirectOutputSwitch->GetFileName();

        if ( HasAppend64() || Is2ndCodegenRun() )
            {
            pFH = freopen(newfile, "r+", stdout);

            if ( pFH )
                {
                if ( 0 != fseek( pFH, 0, SEEK_END ) )
                    RpcError( NULL, 0, ERROR_OPENING_FILE, newfile );
                }
            else
                pFH = freopen(newfile, "a+", stdout);
            }
        else
            pFH = freopen(newfile, "w", stdout);

        if ( NULL == pFH )
            RpcError( NULL, 0, ERROR_OPENING_FILE, newfile );
        }

    // if he has not specified the input filename, report
    // error, but only if the confirm switch is not specified. If it is,
    // processing will not occur anyway.

    if(!IsSwitchDefined(BASE_FILENAME) )
        {
        if( IsSwitchDefined( SWITCH_CONFIRM ) )
            {
            pInputFNSwitch = new filename_switch( "sample.idl");
            SwitchDefined( BASE_FILENAME );
            }
        else if( IsSwitchDefined( SWITCH_HELP ))
            return STATUS_OK;
        else
            {
            RpcError((char *)NULL,0,NO_INPUT_FILE, (char *)NULL);
            return NO_INPUT_FILE;
            }
        }

    // set post switch processing defaults

    ReturnStatus = SetPostDefaults();

    return ReturnStatus;
}

STATUS_T
CommandLine::BumpThisArg(
    char            **    ppArg,
    unsigned short        flag
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Bump the argument pointer to the start of the argument that this switch
    expects.

 Arguments:

    ppArg    -    pointer to the argument pointer.
    flag    -    descriptor of the type of argument expected by the switch.

 Return Value:

    ILLEGAL_ARGUMENT    -    if the switch did not expect this argument
    BAD_SWITCH_SYNTAX    -     if the switch + arg. syntax is improper.
    MISSING_ARGUMENT    -    a mandatory arg. is missing.
    STATUS_OK            -    evrything is hunky dory.

 Notes:

    In the routine below, fHasImmediateArg is a flag which is true if the
    switch argument follws the switch name without any spaces in between.
    Optional space is indicated in the switch descriptor as ARG_SPACE +
    ARG_NO_SPACE, so it gets reflected in fSpaceOptional as fMustNotHaveSpace
    && fMustHaveSpace.

    Other flags have self-explanatory names.

    This routine forms the core syntax checker for the switches.

----------------------------------------------------------------------------*/
    {
    char   *    pArg                = *ppArg;
    BOOL        fMustHaveArg        = (BOOL) !(flag & ARG_NONE);
    BOOL        fOptionalArg        = (flag & ARG_NONE) && (flag & ARG_YES);
    BOOL        fMustHaveSpace      = (BOOL) ((flag & ARG_SPACE) != 0 );
    BOOL        fMustNotHaveSpace   = (BOOL) ((flag & ARG_NO_SPACE) != 0 );
    BOOL        fSpaceOptional      = (BOOL) (fMustNotHaveSpace &&
                                              fMustHaveSpace );
    BOOL        fSwitchLike         = (BOOL) ((flag & ARG_SWITCH_LIKE) != 0 );
    BOOL        fHasImmediateArg    = (*pArg != 0);
    BOOL        fMustGetNextArg     = FALSE;


    // first deal with the case of the switch having an optional argument.
    // If the switch has an optional argument, then check the next argument
    // to see if it is switch like. If it is, then this switch was specified
    // without an argument. If it is not, then the next argument is taken to
    // be the argument for the switch.

    if( fOptionalArg )
        {

        pArg = GetNextArg();
        if(!fSwitchLike && pArg && ((*pArg == '-') || (*pArg == '/') ) )
            {
            UndoGetNextArg();
            pArg = (char *)0;
            }
        *ppArg = pArg;
        return STATUS_OK;
        }

    // if the switch must not have an immediate argument and has one,
    // it is an error.

    if( !fMustHaveArg && fHasImmediateArg )

        return ILLEGAL_ARGUMENT;

    else if ( fMustHaveArg )
        {

        // if it needs an argument, and has an immediate argument, it is bad
        // if the switch must have space.

        if( fHasImmediateArg )
            {

            if( fMustHaveSpace && !fSpaceOptional )
                return BAD_SWITCH_SYNTAX;

            }
        else    
            {

            // This is the case when the switch must have an argument and
            // does not seem to have an immediate argument. This is fine only
            // if space was either optional or expected. In either case, we must
            // assume that the next argument is the argument for this switch.

            // If switch must not have any space then this is a case of
            // bad switch syntax.


            if( fSpaceOptional || fMustHaveSpace   )
                fMustGetNextArg    = TRUE;
            else
                return BAD_SWITCH_SYNTAX;
            }
        }

    if( fMustGetNextArg )
        {

        // we arrive here if the switch expects an argument and
        // space between the switch and the argument is optional.

        // Note that the flag fHasImmediateArg now specifies whether
        // the argument is present at all.

        pArg = GetNextArg();

        fHasImmediateArg = (BOOL) ( pArg && (*pArg != 0) );

        if( fHasImmediateArg )
            {

            // we got the next argument.
            // If we get something that looks like a switch, and this switch
            // does not expect switch_like arguments, then this is illegal
            // argument for the switch.

            if(!fSwitchLike && ((*pArg == '-') || (*pArg == '/') ) )
                {
                UndoGetNextArg();
                return ILLEGAL_ARGUMENT;
                }
            }
        else
            // well, we expect an argument, and didnt get one. He just
            // shot himself is all I can say.

            return MISSING_ARG;
        }

    // we have found the right argument.

    *ppArg = pArg;

    // finally ! out of this mess.

    return STATUS_OK;
}

STATUS_T
CommandLine::ProcessOnetimeSwitch(
    short        SwitchNo,
    char    *    pThisArg
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Process a onetime switch.

 Arguments:

    SwitchNo        -    switch number being processed.
    pThisArg        -    pointer to the argument for this switch.

 Return Value:

    None.

 Notes:

    Check for duplicate definition of this switch. If there is a duplicate
    definition, override the previous one after warning him.

----------------------------------------------------------------------------*/
    {
    onetime_switch    **    ppSSwitch;

    switch( SwitchNo )
        {
        case SWITCH_CPP_CMD:    ppSSwitch = &pCppCmdSwitch; break;
        case SWITCH_CPP_OPT:    ppSSwitch = &pCppOptSwitch; break;
        case SWITCH_MSC_VER:
            ppSSwitch = &pMSCVerSwitch;
            MSCVersion = (unsigned short) atoi( pThisArg );
            break;
        case SWITCH_DEBUG64:    ppSSwitch = &pDebug64Switch; break;
        case SWITCH_DEBUG64_OPT:ppSSwitch = &pDebug64OptSwitch; break;
        default:                return STATUS_OK;
        }

    if( IsSwitchDefined(SwitchNo) )
        {
        RpcError( (char *)NULL,
                      0,
                      SWITCH_REDEFINED,
                    SwitchStringForValue( SwitchNo ) );

        delete *ppSSwitch;
        }

    (*ppSSwitch) = new onetime_switch( pThisArg );
    return STATUS_OK;

    }

STATUS_T
CommandLine::ProcessMultipleSwitch(
    short        SwitchNo,
    char    *    pThisArg,
    char    *    pActualArg
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Process a multiple occurrence switch.

 Arguments:

    SwitchNo    -    switch number being processed.
    pThisArg    -    pointer to the argument for this switch.
    pActualArg  -    pointer to the actual argument to -I/-D etc

 Return Value:

    None.

 Notes:

    Multiple specifications can occur. Dont check for duplicate definitions.

----------------------------------------------------------------------------*/
    {

    char             *    pTemp     = pThisArg;
    multiple_switch  **   ppMSwitch;

    switch( SwitchNo )
        {
        case SWITCH_D:  ppMSwitch = &pDSwitch; break;
        case SWITCH_I:  ppMSwitch = &pISwitch; break;
        case SWITCH_U:  ppMSwitch = &pUSwitch; break;
        default:        return STATUS_OK;
        }

    // now set the switches. Space is optional
    // If no space exists between the -I/-D value of pActualArg will point to
    // the byte next to the end of -I/-D etc. If there is at least one space,
    // the pActualArg will point further away. This fact can be used to decide
    // how the argument needs to be presented to the c preprocessor.
    // If we need the space, then create a new buffer with the space between the
    // -I/-D etc.

    // I assume the assumptions above will hold true even for segmented
    // architectures.

    size_t ActualArgOffset = pActualArg - pThisArg;

    if( ( pActualArg - (pThisArg+2) ) != 0 )
        {

        // we need a space
        ActualArgOffset = strlen( pThisArg ) + 1; // 1 for space
        pTemp = new char [ ActualArgOffset      +
                           strlen( pActualArg ) +
                           1                         // 1 for terminator.
                         ];
        sprintf( pTemp, "%s %s", pThisArg, pActualArg );
        }

    if(!(*ppMSwitch) )
        *ppMSwitch = new multiple_switch( pTemp, ActualArgOffset );
    else
        (*ppMSwitch)->Add( pTemp, ActualArgOffset );

    return STATUS_OK;
    }

STATUS_T
CommandLine::ProcessFilenameSwitch(
    short       SwitchNo,
    char    *   pThisArg
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Process a filename switch.

 Arguments:

    SwitchNo    -    switch number being processed.
    pThisArg    -    pointer to the argument for this switch.

 Return Value:

    STATUS_OK if all is well, error otherwise.

 Notes:

    This is like a single occurrence switch too. Warn if duplicate definition
    and override the previous specification.

----------------------------------------------------------------------------*/
    {

    filename_switch    **        ppFNSwitch;
    BOOL                    fCheck = TRUE;
    char                    agBaseName[ _MAX_FNAME ];

    switch( SwitchNo )
        {
        case SWITCH_CSTUB:                ppFNSwitch = &pCStubSwitch;  break;
        case SWITCH_HEADER:               ppFNSwitch = &pHeaderSwitch; break;
        case SWITCH_ACF:                  ppFNSwitch = &pAcfSwitch;    break;
        case SWITCH_SSTUB:                ppFNSwitch = &pSStubSwitch;  break;
        case SWITCH_OUT:                  ppFNSwitch = &pOutputPathSwitch; fCheck=FALSE; break;
        case SWITCH_IID:                  ppFNSwitch = &pIIDSwitch;    break;
        case SWITCH_PROXY:                ppFNSwitch = &pProxySwitch;  break;
        case SWITCH_DLLDATA:              ppFNSwitch = &pDllDataSwitch;  break;
        case SWITCH_TLIB:                 ppFNSwitch = &pTlibSwitch;     break;
        case SWITCH_REDIRECT_OUTPUT:      ppFNSwitch = &pRedirectOutputSwitch; break;
        case SWITCH_NETMON_STUB_OUTPUT_FILE:     ppFNSwitch = &pNetmonStubSwitch; break;
        case SWITCH_NETMON_STUB_OBJ_OUTPUT_FILE: ppFNSwitch = &pNetmonStubObjSwitch; break;
        default:                          return STATUS_OK;
        }

    if( IsSwitchDefined(SwitchNo) )
        {
        RpcError( (char *)NULL,
                      0,
                      SWITCH_REDEFINED,
                    SwitchStringForValue( SwitchNo ) );

        delete *ppFNSwitch;
        }

    (*ppFNSwitch)    = new filename_switch( pThisArg );

    // check for validity of the switch. All switches other than the
    // out switch must have a base name specified.

    if( fCheck )
        {
        (*ppFNSwitch)->GetFileNameComponents( (char *)NULL,
                                              (char *)NULL,
                                              agBaseName,
                                              (char *)NULL );

        if( agBaseName[ 0 ] == '\0' )
            {
            RpcError( (char *)NULL,
                      0,
                      ILLEGAL_ARGUMENT,
                      SwitchStringForValue( SwitchNo ) );
            }
        }
    return STATUS_OK;
    }

STATUS_T
CommandLine::ProcessOrdinarySwitch(
    short        SWValue,
    char    *    pThisArg
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    process ordinary switch catrgory.

 Arguments:

    SWValue        -    switch value
    pThisArg    -    the users argument to this switch.

 Return Value:

 Notes:

    check and warn for redefinition of the switch. Switch Warn is a special
    case, the warn can be redefined. The last specified warning level is
    valid.

    Generally we let the user who redefines a switch off the hook. When the
    arguments to a switch are wrong, we report an error and return an illegal
    argument status.

----------------------------------------------------------------------------*/
{
    short        Temp;
    STATUS_T    Status    = STATUS_OK;

    if( IsSwitchDefined( SWValue ) && (SWValue != SWITCH_O) )
        {
        RpcError( (char *)NULL,
                  0,
                  SWITCH_REDEFINED,
                  SwitchStringForValue( SWValue ) );
        }

    switch( SWValue )
        {
        case SWITCH_PACK:
            SwitchDefined( SWITCH_ZP );
            // fall through
        case SWITCH_ZP:
            {
               int TempZeePee = atoi( pThisArg );
               if (!TempZeePee || !IsValidZeePee( TempZeePee ) )
                   goto illarg;
               ZeePee = (unsigned short)TempZeePee;               
            }
            break;

        case SWITCH_LOCALE_ID:
             
            SwitchDefined( SWITCH_LOCALE_ID );
            LocaleId = atoi( pThisArg );
            /*
            if ( ! CurrentCharSet.SetDbcsLeadByteTable( LocaleId ) )
                {
                char temp[20];

                sprintf( temp, "%d", LocaleId );
                RpcError( NULL, 0, INVALID_LOCALE_ID, temp );
                }
            */
            break;

        case SWITCH_W:

                // warning level of 0 specifies no warnings.

                Temp = short( *pThisArg - '0' );

                if( ( !IS_NUMERIC_1( pThisArg ) )    ||
                    ( Temp > WARN_LEVEL_MAX ) )
                    goto illarg;

                WLevel = Temp;

            break;

        case SWITCH_O:
            {    
            if ( ! *pThisArg )
                goto illarg;

            if ( OptimFlags & 
                 (OPTIMIZE_SIZE | OPTIMIZE_ANY_INTERPRETER) )
                RpcError( (char *)NULL,
                          0,
                          SWITCH_REDEFINED,
                          SwitchStringForValue( SWValue ) );

            if ( strcmp( pThisArg, "s" ) == 0 )
                {
                SetOptimizationFlags( OPTIMIZE_SIZE );
                OptimLevel = OPT_LEVEL_OS;
                }
            else if ( strcmp( pThisArg, "i" ) == 0 )
                {
                SetOptimizationFlags( OPTIMIZE_INTERPRETER );
                OptimLevel = OPT_LEVEL_OI;
                }
            else if ( strcmp( pThisArg, "ic" ) == 0 )
                {
                SetOptimizationFlags( OPTIMIZE_ALL_I1_FLAGS );
                OptimLevel = OPT_LEVEL_OIC;
                RpcError( 0, 0, OIC_SUPPORT_PHASED_OUT, "Oi1");
                }
            else if ( strcmp( pThisArg, "i1" ) == 0 )
                {
                SetOptimizationFlags( OPTIMIZE_ALL_I1_FLAGS );
                OptimLevel = OPT_LEVEL_OIC;
                RpcError( NULL, 0, CMD_OI1_PHASED_OUT, "Oi1");
                }
            else if ( strcmp( pThisArg, "icf" ) == 0  ||
                      strcmp( pThisArg, "if" ) == 0  )
                {
                SetOptimizationFlags( OPTIMIZE_ALL_I2_FLAGS );
                OptimLevel = OPT_LEVEL_OICF;
                }
            else if ( strcmp( pThisArg, "i2" ) == 0 )
                {
                SetOptimizationFlags( OPTIMIZE_ALL_I2_FLAGS );
                OptimLevel = OPT_LEVEL_OICF;
                RpcError( NULL, 0, CMD_OI2_OBSOLETE, "Oi2");
                }
            else
                goto illarg;
                
            }
            break;

        case SWITCH_ODL_ENV:
            pThisArg -= 2; // back up past the first three characters of the switch "win"
            SWValue = SWITCH_ENV; // to ensure that the right thing gets reported if an error occurs
            // fall through to SWITCH_ENV

        case SWITCH_ENV:
            
            if( SelectChoice( EnvChoice,pThisArg, &Temp ) != STATUS_OK )
                goto illarg;

            Env = (unsigned char) Temp;

            if (ENV_OBSOLETE == Env)
                RpcError( NULL, 0, SWITCH_NOT_SUPPORTED_ANYMORE, pThisArg );

            break;

        case SWITCH_TARGET_SYSTEM:
            
            if( SelectChoice( TargetChoice, pThisArg, &Temp ) != STATUS_OK )
                goto illarg;
            TargetSystem = (TARGET_ENUM) Temp;
            GetNdrVersionControl().SetTargetSystem(TargetSystem);
            break;

        case SWITCH_TRANSFER_SYNTAX:
            if ( SelectChoice( SyntaxChoice, pThisArg, &Temp ) != STATUS_OK )
                goto illarg;
            TargetSyntax = (SYNTAX_ENUM) Temp;
            break;

        case SWITCH_NO_WARN:
            
            WLevel = 0; // was WARN_LEVEL_MAX
            break;

        case SWITCH_INTERNAL:
            RpcError( 0, 0, INTERNAL_SWITCH_USED, NULL );

        case SWITCH_NO_STAMP:
        case SWITCH_NETMON:
        case SWITCH_VERSION_STAMP:
        case SWITCH_DEBUGEXC:
        case SWITCH_DEBUGLINE:
        case SWITCH_SYNTAX_CHECK:
        case SWITCH_ZS:
        case SWITCH_NO_CPP:
        case SWITCH_SAVEPP:
        case SWITCH_DUMP:
        case SWITCH_OVERRIDE:
        case SWITCH_NO_DEF_IDIR:
        case SWITCH_USE_EPV:
        case SWITCH_NO_DEFAULT_EPV:
        case SWITCH_VERSION:
        case SWITCH_CONFIRM:
        case SWITCH_NOLOGO:
        case SWITCH_HELP:
        case SWITCH_WX:
        case SWITCH_X:
        case SWITCH_APPEND64:
        case SWITCH_APP_CONFIG:
        case SWITCH_MS_EXT:
        case SWITCH_MS_CONF_STRUCT:
        case SWITCH_MS_UNION:
        case SWITCH_OLDNAMES:
        case SWITCH_NO_FMT_OPT:
        case SWITCH_GUARD_DEFS:
        case SWITCH_C_EXT:
        case SWITCH_OSF:
        case SWITCH_MKTYPLIB:
        case SWITCH_OLD_TLB:
        case SWITCH_NEW_TLB:
        case SWITCH_NO_SERVER:
        case SWITCH_NO_CLIENT:
        case SWITCH_NO_HEADER:
        case SWITCH_NO_IID:
        case SWITCH_NO_DLLDATA:
        case SWITCH_NO_PROXY:
        case SWITCH_NO_CLASS_METHODS:
        case SWITCH_NO_CLASS_IUNKNOWN:
        case SWITCH_NO_CLASS_HEADER:
        case SWITCH_NO_PROXY_DEF:
        case SWITCH_NO_DLL_SERVER_DEF:
        case SWITCH_NO_DLL_SERVER_CLASS_GEN:
        case SWITCH_NO_SERVER_REG:
        case SWITCH_NO_EXE_SERVER:
        case SWITCH_NO_EXE_SERVER_MAIN:
        case SWITCH_NO_TESTCLIENT:
        case SWITCH_RPCSS:
        case SWITCH_ROBUST:
        case SWITCH_NO_ROBUST:
        case SWITCH_NOREUSE_BUFFER:
        case SWITCH_USE_VT_INT_PTR:
        case SWITCH_NO_TLIB:
        case SWITCH_MS_EXT64:
        case SWITCH_DEBUGINFO:
            SwitchDefined( SWValue );
            break;

        case SWITCH_CPP_CMD:
        case SWITCH_CPP_OPT:
        case SWITCH_MSC_VER:
        case SWITCH_DEBUG64:
        case SWITCH_DEBUG64_OPT:

            ProcessOnetimeSwitch( SWValue, pThisArg );
            break;

        case SWITCH_CLIENT:

            if( SelectChoice( ClientChoice, pThisArg ,&Temp ) != STATUS_OK )
                goto illarg;
            fClient = (unsigned char) Temp;
            break;

        case SWITCH_SERVER:

            if( SelectChoice( ServerChoice, pThisArg ,&Temp ) != STATUS_OK )
                goto illarg;
            fServer = (unsigned char) Temp;
            break;

        case SWITCH_CHAR:

            if( SelectChoice( CharChoice, pThisArg ,&Temp ) != STATUS_OK )
                goto illarg;
            CharOption = (unsigned char) Temp;
            break;

        default:
            break;
        }

    return Status;

illarg:
        RpcError( (char *)NULL,
                  0,
                  Status = ILLEGAL_ARGUMENT,
                  SwitchStringForValue( SWValue ) );
return Status;
}

STATUS_T
CommandLine::ProcessSimpleMultipleSwitch(
    short        SWValue,
    char    *    pThisArg
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    process simple switches which can be multiply defined.

 Arguments:

    SWValue        -    switch value
    pThisArg    -    the users argument to this switch.

 Return Value:

 Notes:

    check and warn for redefinition of the switch. Switch Warn is a special
    case, the warn can be redefined. The last specified warning level is
    valid.

    Generally we let the user who redefines a switch off the hook. When the
    arguments to a switch are wrong, we report an error and return an illegal
    argument status.

----------------------------------------------------------------------------*/
{
    short       Temp;
    STATUS_T    Status    = STATUS_OK;

    switch( SWValue )
        {
        case SWITCH_ERROR:
            Temp = ERROR_NONE;
            if( pThisArg && SelectChoice( ErrorChoice, pThisArg ,&Temp ) != STATUS_OK )
                {
                Status = ILLEGAL_ARGUMENT;
                RpcError( (char *)0,
                          0,
                          Status,
                          SwitchStringForValue( SWValue )
                          );
                }
            if( Temp == ERROR_NONE)
                ErrorOption = ERROR_NONE;
            else
                ErrorOption |= Temp;
            break;

        case SWITCH_WIRE_COMPAT:
            if( !pThisArg || ( SelectChoice( WireCompatChoice, pThisArg ,&Temp ) != STATUS_OK ) )
                {
                Status = ILLEGAL_ARGUMENT;
                RpcError( (char *)0,
                          0,
                          Status,
                          SwitchStringForValue( SWValue )
                          );
                }
            else
                WireCompatOption |= Temp;
            break;

        default:
            break;
        }
    return Status;
}

STATUS_T
CommandLine::SetPostDefaults()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Set compiler switch defaults for switches not specified.

 Arguments:

    None.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
    {
    char    agDrive[ _MAX_DRIVE ];
    char    agPath[ _MAX_PATH ];
    char    agBaseName[ _MAX_FNAME ];
    char    agExt[ _MAX_EXT ];
    char    agBuffer[ _MAX_DRIVE + _MAX_PATH + _MAX_FNAME + _MAX_EXT + 1 ];


    if( !IsSwitchDefined( SWITCH_OUT ) )
        {
        strcpy( agDrive, "");
        strcpy( agPath, ".\\");
        }
    else
        {
        _splitpath( pOutputPathSwitch->GetFileName(),
                    agDrive,
                    agPath,
                    agBaseName,
                    agExt );
        strcat( agPath, agBaseName );
        strcat( agPath, agExt );
        delete pOutputPathSwitch;
        }

    agBaseName[0]    = '\0';
    agExt[0]        = '\0';

    _makepath( agBuffer, agDrive, agPath, agBaseName, agExt );


    pOutputPathSwitch    = new filename_switch( agBuffer );

    _splitpath( agBuffer, agDrive, agPath, agBaseName, agExt );

    // we have all the components but the base filename must be the
    // filename of the input file. So we get this component of the base
    // filename

    pInputFNSwitch->GetFileNameComponents( (char *)NULL,
                                           (char *)NULL,
                                           agBaseName,
                                           (char *)NULL );

    // if the cstub switch is not set, set the default.

    if(!IsSwitchDefined( SWITCH_CSTUB ) )
        {
        pCStubSwitch = new filename_switch( agDrive,
                                            agPath,
                                            agBaseName,
                                            ".c",
                                            "_c" );
        }
    else
        pCStubSwitch->TransformFileNameForOut( agDrive, agPath );

    // if the sstub switch is not set, set the default

    if(!IsSwitchDefined( SWITCH_SSTUB ) )
        {
        pSStubSwitch = new filename_switch( agDrive,
                                            agPath,
                                            agBaseName,
                                            ".c",
                                            "_s" );
        }
    else
        pSStubSwitch->TransformFileNameForOut( agDrive, agPath );


    // if the IID switch is not set, set it
    if(!IsSwitchDefined( SWITCH_IID ) )
        {
        pIIDSwitch = new filename_switch( agDrive,
                                          agPath,
                                          agBaseName,
                                          ".c",
                                          "_i" );
        }
    else
        pIIDSwitch->TransformFileNameForOut( agDrive, agPath );

    // if the Proxy switch is not set, set it
    if(!IsSwitchDefined( SWITCH_PROXY ) )
        {
        pProxySwitch = new filename_switch( agDrive,
                                            agPath,
                                            agBaseName,
                                            ".c",
                                            "_p" );
        }
    else
        pProxySwitch->TransformFileNameForOut( agDrive, agPath );

    if (!IsSwitchDefined( SWITCH_TLIB ) )
        {
        pTlibSwitch = new filename_switch( agDrive,
                                           agPath,
                                           agBaseName,
                                           ".tlb",
                                           "" );
        }
    else
        pTlibSwitch->TransformFileNameForOut(agDrive, agPath);

    // if the DllData switch is not set, set it
    if(!IsSwitchDefined( SWITCH_DLLDATA ) )
        {
        pDllDataSwitch = new filename_switch( agDrive,
                                              agPath,
                                              "dlldata",
                                              ".c",
                                              "" );
        }
    else
        pDllDataSwitch->TransformFileNameForOut( agDrive, agPath );

    // if the acf switch is not set, set it

    if(!IsSwitchDefined( SWITCH_ACF ) )
        {
        pAcfSwitch   = new filename_switch( agDrive,
                                            agPath,
                                            agBaseName,
                                            ".acf",
                                            (char *)NULL );
        }

    // if the header switch is not set, set it

    if(!IsSwitchDefined( SWITCH_HEADER ) )
        {
        pHeaderSwitch   = new filename_switch( agDrive,
                                               agPath,
                                               agBaseName,
                                               ".h",
                                               (char *)NULL );
        }
    else
        pHeaderSwitch->TransformFileNameForOut( agDrive, agPath );

    // set up the cpp options.

    if( !IsSwitchDefined( SWITCH_CPP_CMD ) )
        {
        pCppCmdSwitch = new onetime_switch( C_PREPROCESSOR_NAME() );
        }

    if( !IsSwitchDefined( SWITCH_MSC_VER ) )
        {
        pMSCVerSwitch = new onetime_switch( "1100" );
        MSCVersion = 1100;
        }

    // set up the cpp_opt and cc_opt. If he did not specify a cpp_opt
    // then we will pass onto the preprocessor the /I , /D and /U options.
    // if he did specify a cpp_opt, then he knows best, take his options
    // and dont make your own assumptions.

    if ( ! IsSwitchDefined( SWITCH_CPP_OPT ) )
        {
        int          Len = 0;
        char    *    pTemp,
                *    pTemp1;

        Len    += (int) strlen( ADDITIONAL_CPP_OPT() );
        if( !pISwitch && IsSwitchDefined( SWITCH_NO_DEF_IDIR ) )
            Len += (int) strlen( "-I." ) + 1;

        if( pISwitch )    Len    += pISwitch->GetConsolidatedLength( true ); // Room for quotes
        if( pDSwitch )    Len    += pDSwitch->GetConsolidatedLength();
        if( pUSwitch )    Len    += pUSwitch->GetConsolidatedLength();


        pTemp = new char[ Len + 1 ]; pTemp[0] = '\0';

        if( !pISwitch && IsSwitchDefined( SWITCH_NO_DEF_IDIR ) )
            {
            strcat( pTemp, "-I." );
            }

        if( pISwitch )
            {
            strcat( pTemp, pTemp1 = pISwitch->GetConsolidatedOptions( true ) ); // Get quotes
            delete pTemp1;
            }

        if( pDSwitch )
            {
            strcat( pTemp, pTemp1 = pDSwitch->GetConsolidatedOptions() );
            delete pTemp1;
            }

        if( pUSwitch )
            {
            strcat( pTemp, pTemp1 = pUSwitch->GetConsolidatedOptions() );
            delete pTemp1;
            }

        strcat( pTemp, ADDITIONAL_CPP_OPT() );

        pCppOptSwitch   = new onetime_switch( pTemp );

        delete pTemp;
        }

    // if he specified the cpp_cmd or cpp_opt switches, then no_cpp
    // overrides them if specified.

    if( IsSwitchDefined( SWITCH_NO_CPP ) )
        {
        if( IsSwitchDefined( SWITCH_CPP_CMD) ||
            IsSwitchDefined( SWITCH_CPP_OPT) )
            {
            RpcError( (char *)NULL,
                      0,
                      NO_CPP_OVERRIDES,
                      (char *)NULL );
            }
        }


    // if the client switch is not defined, define it

    if( !IsSwitchDefined( SWITCH_CLIENT ) )
        {
        fClient = CLNT_STUB;
        }

    // if warnlevel and no_warn is defined, then errors

    if( IsSwitchDefined( SWITCH_W ) &&
        (IsSwitchDefined( SWITCH_NO_WARN ) || (WLevel == 0) ) )
        {
        //
        // if we set the no_warn switch already then this warning will itself
        // not be emitted. Make the current warning level 1 so that this warning
        // will be spit out. WLevel is made 0 anyways after that.
        //

        WLevel = 1;

        RpcError( (char *)NULL,
                   0,
                   NO_WARN_OVERRIDES,
                   (char *)NULL );
        WLevel = 0;
        }

    // if the error switch is not defined, define it.

    if( !IsSwitchDefined( SWITCH_ERROR ) )
        {
        ErrorOption = ERROR_ALL;
        }
    else if ( GetNdrVersionControl().TargetIsNT40OrLater() )
        {
        if ( ERROR_ALL != ErrorOption )
            {
            RpcError( 
                    NULL, 
                    0, 
                    CONTRADICTORY_SWITCHES, 
                    "-error vs. -target" );
            }
        }

    /////////////////////////////////////////////////////////////////////

    // if he defined env, then he may want to compile for a platform different
    // from what he is building for. Take care of platform dependent switches
    // for the proper platforms.

    // 64 bit additions:
    // -append64 means forcing the appending on the current run
    //     .. it should be the second run, but it always forces with win32 or 64
    // -win32 or -win64 means 32 or 64 bit run only, respectively.
    //

    if ( !IsSwitchDefined( SWITCH_ENV )
         && NT40 == GetNdrVersionControl().GetTargetSystem() )
        {
        SetEnv( ENV_WIN32 ); 
        SwitchDefined( SWITCH_ENV );
        }

    if( IsSwitchDefined( SWITCH_ENV ) )
        {
        if( !IsSwitchDefined( SWITCH_ZP ) )
            {
            switch( GetEnv() )
                {
                case ENV_WIN32: ZeePee = DEFAULT_ZEEPEE; break;
                case ENV_WIN64: ZeePee = DEFAULT_ZEEPEE; break;
                default:        ZeePee = DEFAULT_ZEEPEE; break;
                }
            }

        // EnumSize is set to 4 by default
        }

    if ( NT40 == GetNdrVersionControl().GetTargetSystem() 
         && ENV_WIN32 != GetEnv() 
          )
        {
            RpcError( 
                    NULL, 
                    0, 
                    CONTRADICTORY_SWITCHES, 
                    "-win64 vs. -target NT40" );
        }

    if ( !IsSwitchDefined ( SWITCH_TRANSFER_SYNTAX ) )
        {
        if ( GetNdrVersionControl().TargetIsNT51OrLater() )
            TargetSyntax = SYNTAX_BOTH;
        else
            TargetSyntax = SYNTAX_DCE;
        }

    if ( GetNdrVersionControl().TargetIsNT51OrLater() )
        {
        if ( SYNTAX_BOTH != TargetSyntax )
            {
            RpcError( 
                    NULL, 
                    0, 
                    CONTRADICTORY_SWITCHES, 
                    "-protocol vs. -target NT51" );
            }
        }

    // we support ndr64 on 32bit platform only when -internal is specified.
    if ( ( TargetSyntax == SYNTAX_NDR64 ) &&
         ( GetEnv() == ENV_WIN32 ) &&
         !IsSwitchDefined( SWITCH_INTERNAL ) )
        {
        RpcError( NULL, 0, UNSUPPORT_NDR64_FEATURE, 0 );   
        }

    // ndr64 is not supported in /Osf mode        
    if ( IsSwitchDefined(SWITCH_OSF) && TargetSyntax != SYNTAX_DCE )
        {
        RpcError( NULL, 0, CONTRADICTORY_SWITCHES, "-osf vs. -protocol ndr64 or -protocol all" );
        }        
    
     if  ( GetEnv() == ENV_WIN64  || GetEnv() == ENV_WIN32 )
         {
         if ( IsSwitchDefined( SWITCH_APPEND64 ) )
             {
             SetHasAppend64( TRUE );
             SetEnv( ENV_WIN64 );
             }
         }

    if ( GetEnv() == ENV_WIN64 )
        {
        // -ms_ext64 is set by default in 64bit.
        SwitchDefined( SWITCH_MS_EXT64 );
        }

    if ( IsSwitchDefined( SWITCH_MS_EXT64 ) )
        GetNdrVersionControl().SetHasMsExt64();       
    
        
    if ( IsSwitchDefined(SWITCH_OSF) && IsSwitchDefined(SWITCH_C_EXT)  ||
         IsSwitchDefined(SWITCH_OSF) && IsSwitchDefined(SWITCH_MS_EXT) )
        {
        RpcError( NULL, 0, CONTRADICTORY_SWITCHES, "-osf vs. -ms_ext or -c_ext" );
        }

    // The default optimization level is -Os for dce only mode when -target
    // is not used.  With target or in ndr64 or "all" protocol use -Oicf.

    if ( !IsSwitchDefined( SWITCH_O ) )
        {
        if ( GetNdrVersionControl().TargetIsNT40OrLater() )
            {
            SetOptimizationFlags( OPTIMIZE_ALL_I2_FLAGS );
            OptimLevel = OPT_LEVEL_OICF;
            SwitchDefined( SWITCH_O );
            }
        else if ( TargetSyntax == SYNTAX_DCE )
            {
            SetOptimizationFlags( OPTIMIZE_SIZE );
            OptimLevel = OPT_LEVEL_OS;
            }
        else
            {
            SetOptimizationFlags( OPTIMIZE_ALL_I2_FLAGS );
            OptimLevel = OPT_LEVEL_OICF;
            }
        }
    else if ( GetNdrVersionControl().TargetIsNT40OrLater() )
        {
        if ( OptimLevel != OPT_LEVEL_OICF )
            {
            RpcError( 
                    NULL, 
                    0, 
                    CONTRADICTORY_SWITCHES, 
                    "-Os/Oi/Oic vs. -target" );
            }
        }

    if ( GetEnv() == ENV_WIN64 )
        {
        SetPostDefaults64();        
        }

    if ( ( GetOptimizationFlags() != OPTIMIZE_ALL_I2_FLAGS ) && 
         ( TargetSyntax != SYNTAX_DCE ) )
        {
        RpcError( NULL, 0, CONTRADICTORY_SWITCHES, "-Os/Oi/Oic vs. -protocol ndr64 or -protocol all" );
        }
        
    // Force /Oicf when ( /Oi or /Os ) are used with /robust

    if ( GetNdrVersionControl().TargetIsNT50OrLater() )
        {
        if ( IsSwitchDefined( SWITCH_NO_ROBUST ) )
            RpcError( NULL, 0, CONTRADICTORY_SWITCHES, "-no_robust vs. -target" );
        else
            SwitchDefined( SWITCH_ROBUST );
        }

    if ( IsSwitchDefined( SWITCH_ROBUST ) )
        {
        if ( IsSwitchDefined( SWITCH_NO_ROBUST ) )
            RpcError( NULL, 0, CONTRADICTORY_SWITCHES, "-robust vs. -no_robust" );

        if ( NT40 == GetNdrVersionControl().GetTargetSystem() )
            RpcError( NULL, 0, CONTRADICTORY_SWITCHES, "-robust vs. -target NT40" );

        GetNdrVersionControl().SetHasDOA();
        
        if ( ( GetOptimizationFlags() & OPTIMIZE_ALL_I2_FLAGS )  != OPTIMIZE_ALL_I2_FLAGS )
            {
            RpcError( 0, 0, ROBUST_REQUIRES_OICF, 0 );
            }
            
        SetOptimizationFlags( OPTIMIZE_ALL_I2_FLAGS );
        }

    if ( !IsSwitchDefined( SWITCH_INTERNAL ) ) 
        {
        // Make sure netmon switches also use -internal
        if ( IsSwitchDefined( SWITCH_NETMON ) )
            {
            ReportUnimplementedSwitch( SWITCH_NETMON );
            }
        else if ( IsSwitchDefined( SWITCH_NETMON_STUB_OUTPUT_FILE ) )
            {
            ReportUnimplementedSwitch( SWITCH_NETMON_STUB_OUTPUT_FILE );
            }
        else if ( IsSwitchDefined( SWITCH_NETMON_STUB_OBJ_OUTPUT_FILE ) )
            {
            ReportUnimplementedSwitch( SWITCH_NETMON_STUB_OBJ_OUTPUT_FILE );
            }
        }    

    // Make sure -netmon is only used with -Oicf and setup output files

    if ( IsSwitchDefined( SWITCH_NETMON )) 
        {
        if ( ! ( ( GetOptimizationFlags() & OPTIMIZE_ALL_I2_FLAGS ) &&
            OptimLevel == OPT_LEVEL_OICF ) )
            {
            RpcError( 0, 0, NETMON_REQUIRES_OICF, 0 );
            }
        
        if (!IsSwitchDefined (SWITCH_NETMON_STUB_OUTPUT_FILE)) 
            {
            pNetmonStubSwitch = new filename_switch( agDrive,
                agPath,
                agBaseName,
                ".c",
                "_netmon_stub" );
            } 
        else 
            {
            pNetmonStubSwitch->TransformFileNameForOut( agDrive, agPath );
            }
        
        if (!IsSwitchDefined (SWITCH_NETMON_STUB_OBJ_OUTPUT_FILE)) 
            {
            pNetmonStubObjSwitch = new filename_switch( agDrive,
                agPath,
                agBaseName,
                ".c",
                "_netmon_stub_obj" );
            
            } 
        else 
            {
            pNetmonStubObjSwitch->TransformFileNameForOut( agDrive, agPath );
            }
        }


    // Check if the target system is consistent with other switches.

    if ( TargetSystem < NT40  &&  IsSwitchDefined( SWITCH_NETMON) )
        RpcError( NULL, 0, CMD_REQUIRES_NT40, "netmon" );

    // If the -no_default_epv switch is specified then -epv switch is auto
    // enabled.

    if( IsSwitchDefined( SWITCH_NO_DEFAULT_EPV ) )
        SwitchDefined( SWITCH_USE_EPV );
    
    // if he specified all, set them all
    if ( IsSwitchDefined( SWITCH_PREFIX ) )
        {
        char *    pAll = pSwitchPrefix->GetUserDefinedEquivalent( PREFIX_ALL );
        if ( pAll )
            {
            for ( short j = 0; j < PREFIX_ALL; j++ )
                {
                if ( !pSwitchPrefix->GetUserDefinedEquivalent( j ) )
                    pSwitchPrefix->AddPair( j, pAll );
                }
            }
        }

    SetModeSwitchConfigMask();

    return STATUS_OK;
    }

void
CommandLine::SetPostDefaults64()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Set switch defaults for 64 bit runs

 Arguments:

    None.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    GetNdrVersionControl().SetHas64BitSupport();

    if ( IsSwitchDefined( SWITCH_O ) )
        {
        // For 64b force any interpreter mode to be -Oicf.
        //
        if ( OptimFlags == OPTIMIZE_SIZE )
            {
//                    RpcError( NULL, 0, WIN64_INTERPRETED, "-Oicf" );
            }
        else if ( OptimLevel != OPT_LEVEL_OICF )
            {
            RpcError( NULL, 0, WIN64_INTERPRETED, ": -Oicf" );
            SetOptimizationFlags( OPTIMIZE_ALL_I2_FLAGS );
            OptimLevel = OPT_LEVEL_OICF;
            }
        }
    else
        {
        // Default for the -O switch is -Oicf on 64b
        SetOptimizationFlags( OPTIMIZE_ALL_I2_FLAGS );
        OptimLevel = OPT_LEVEL_OICF;
        }
    
    // Disable -no_robust switch for 277.
    // if ( ! IsSwitchDefined( SWITCH_NO_ROBUST ) &&
    
    if ( GetOptimizationFlags() & OPTIMIZE_ALL_I2_FLAGS )
        {
        // Default 64b processing to robust, when -Oicf, unless -no_robust
        GetNdrVersionControl().SetHasDOA();
        SwitchDefined( SWITCH_ROBUST );
        }

}
    
/*****************************************************************************
 *    utility functions
 *****************************************************************************/
void
ReportUnimplementedSwitch(
    short    SWValue
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    report an unimplemented switch error.

 Arguments:

    SWValue    -    switch value.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
    {
    char    buf[ 50 ];
    sprintf( buf, "%s", SwitchStringForValue( SWValue ) );
    RpcError((char *)NULL,0,UNIMPLEMENTED_SWITCH, buf);
    }

STATUS_T
SelectChoice(
    const CHOICE *  pCh,
    char     *      pUserInput,
    short    *      pChoice)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Search for the given multiple choice table for the given choice.

 Arguments:

    pCh           -    pointer to multiple choice table.
    pUserInput    -    user input string.
    pChoice       -    return the choice value.

 Return Value:

    ILLEGAL_ARGUMENT   if the user input did not represent a valid choice
                       for the switch.

    STATUS_OK          if everything is hunky dory.

 Notes:

----------------------------------------------------------------------------*/
{

    char    *    pChStr;

    while ( pCh && ( pChStr = (char *) pCh->pChoice ) != 0 )
        {
        if( strcmp( pChStr, pUserInput ) == 0 )
            {
            *pChoice = pCh->Choice;
            return STATUS_OK;
            }
        pCh++;
        }
    return ILLEGAL_ARGUMENT;
}

enum _swenum
SearchForSwitch(
    char    **    ppArg )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Search for the switch, given the users input as switch name.

 Arguments:

    ppArg    - pointer to users input pointer.

 Return Value:

    the switch value, if found, SWITCH_NOTHING otherwise.

 Notes:

    search for exact switch name match, and if found, bump the pointer to
    point to the character after the switch name, so that any input to the
    switch can be looked at after the switch string is out of the way.

    Checking the exact length may be a problem, because some switches like
    -I can take no space between the arg. In these cases, ignore the length
    match.

----------------------------------------------------------------------------*/
    {
    short               Len , LenArg, iIndex = 0;
    BOOL                fLengthIsOk;
    char            *   pSrc;
    struct sw_desc  *   pSwDesc = (struct sw_desc*) &switch_desc[0];

    LenArg = (short)strlen( *ppArg );

    while( iIndex < (sizeof(switch_desc) / sizeof( struct sw_desc ) ) )
        {
        pSrc        = (char *) pSwDesc->pSwitchName;
        Len         = (short)strlen( pSrc );
        fLengthIsOk =
            ((pSwDesc->flag & ARG_SPACE_OPTIONAL) || (Len==LenArg));

        if(fLengthIsOk && strncmp( pSrc, *ppArg, Len ) == 0 )
            {
            *ppArg += Len;
            return (_swenum) iIndex;
            }
        iIndex++;
        pSwDesc++;
        }
    return SWITCH_NOTHING;
    }

char*
SwitchStringForValue(
    unsigned short SWValue
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    return the switch string given the value of the switch.

 Arguments:

    SWValue    - switch value.


 Return Value:

    pointer to the switch string. pointer to a null string if not found.

 Notes:

----------------------------------------------------------------------------*/
    {
#define SWITCH_DESC_SIZE (sizeof(switch_desc) / sizeof(struct sw_desc))
    struct sw_desc  *   pDesc  = (struct sw_desc*) &switch_desc[0],
                    *   pDescEnd = (struct sw_desc*) &switch_desc[0] + SWITCH_DESC_SIZE;

    while( pDesc < pDescEnd )
        {
        if( pDesc->SwitchValue == (enum _swenum ) SWValue)
            return (char *) pDesc->pSwitchName;
        pDesc++;
        }
    return "";
    }

inline
char *
YesOrNoString( BOOL Yes )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 return "Yes" for true, "No" for false

 Arguments:

    None.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    return Yes ? "Yes" : "No";
}

void
CommandLine::Confirm()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 confirm the arguments by dumping onto the screen

 Arguments:

    None.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    short       Option;
    char   *    p;
    char        Buffer[100];

    fprintf( stdout, "%s bit arguments", 
                     (Is64BitEnv() ? "64" : "32" )
           );

    PrintArg( BASE_FILENAME, GetInputFileName() , 0 );
    if( IsSwitchDefined( SWITCH_ACF ) )
        PrintArg( SWITCH_ACF , GetAcfFileName(), 0);

    PrintArg( SWITCH_APP_CONFIG,
              YesOrNoString(IsSwitchDefined( SWITCH_APP_CONFIG)), 0);

    PrintArg( SWITCH_C_EXT,
              YesOrNoString(IsSwitchDefined( SWITCH_C_EXT)), 0);

    Option    = GetClientSwitchValue();
    PrintArg( SWITCH_CLIENT,
              (Option == CLNT_STUB) ? "stub" : "none", 0);

    Option = GetCharOption();

    PrintArg( SWITCH_CHAR, (Option == CHAR_SIGNED ) ? "signed" :
                           (Option == CHAR_UNSIGNED ) ? "unsigned" : "ascii7",0);
                        
    if( IsSwitchDefined(SWITCH_CONFIRM) )
        PrintArg( SWITCH_CONFIRM, "Yes" , 0);

    PrintArg( SWITCH_CPP_CMD, GetCPPCmd() , 0);
    PrintArg( SWITCH_CPP_OPT, GetCPPOpt() , 0);
    _itoa( GetMSCVer(), Buffer, 10 );
    PrintArg( SWITCH_MSC_VER, Buffer , 0);

    if ( ( p = GetCstubFName() ) != 0 )
        PrintArg( SWITCH_CSTUB, p , 0);

    if( IsSwitchDefined( SWITCH_D ) )
        PrintArg( SWITCH_D, pDSwitch->GetConsolidatedOptions(), 0 );

    Option = GetEnv();
    PrintArg( SWITCH_ENV,
              (Option == ENV_WIN64)  ? "win64"
                                     : "win32",
              0 );

    PrintArg( SWITCH_APPEND64,
              YesOrNoString(IsSwitchDefined( SWITCH_APPEND64)), 0);

    Option = GetErrorOption();

    Option = (short)IsRpcSSAllocateEnabled();

    PrintArg( SWITCH_RPCSS,
              YesOrNoString(IsSwitchDefined( SWITCH_RPCSS)), 0);

#ifdef MIDL_INTERNAL
    PrintArg( SWITCH_NETMON,
              YesOrNoString(IsSwitchDefined( SWITCH_NETMON)), 0);
#endif

    PrintArg( SWITCH_USE_EPV, YesOrNoString(IsSwitchDefined( SWITCH_USE_EPV )), 0);

    PrintArg( SWITCH_NO_DEFAULT_EPV, YesOrNoString(IsSwitchDefined( SWITCH_NO_DEFAULT_EPV )), 0);

    //
    // error options.
    //


    Buffer[0] = '\0';

    if( ErrorOption != ERROR_NONE )
        {
        if( ErrorOption & ERROR_ALLOCATION )
            strcat( Buffer, "allocation ");
        if( ErrorOption & ERROR_REF )
            strcat( Buffer, "ref ");
        if( ErrorOption & ERROR_BOUNDS_CHECK )
            strcat( Buffer, "bounds_check ");
        if( ErrorOption & ERROR_ENUM )
            strcat( Buffer, "enum ");
        if( ErrorOption & ERROR_STUB_DATA )
            strcat( Buffer, "stub_data ");
        }
    else
        strcat( Buffer, "none" );
            
    PrintArg( SWITCH_ERROR, Buffer, 0 );


    if ( ( p = GetHeader() ) != 0 )
        PrintArg( SWITCH_HEADER, p , 0);

    if( IsSwitchDefined( SWITCH_I ) )
        PrintArg( SWITCH_I, pISwitch->GetConsolidatedOptions(), 0 );

    PrintArg( SWITCH_NOLOGO,
              YesOrNoString(IsSwitchDefined( SWITCH_NOLOGO)), 0);

    PrintArg( SWITCH_MS_EXT,
              YesOrNoString(IsSwitchDefined( SWITCH_MS_EXT)), 0);

    PrintArg( SWITCH_MS_UNION,
              YesOrNoString(IsSwitchDefined( SWITCH_MS_UNION)), 0);

    PrintArg( SWITCH_NO_FMT_OPT,
              YesOrNoString(IsSwitchDefined( SWITCH_NO_FMT_OPT)), 0);

#ifdef MIDL_INTERNAL
    PrintArg( SWITCH_GUARD_DEFS,
              YesOrNoString(IsSwitchDefined( SWITCH_GUARD_DEFS)), 0);
#endif

    PrintArg( SWITCH_OLDNAMES,
              YesOrNoString(IsSwitchDefined( SWITCH_OLDNAMES)), 0);

    if ( 0 != WireCompatOption)
        {
        Buffer[0] = '\0';

        if( ErrorOption & WIRE_COMPAT_ENUM16UNIONALIGN )
            strcat( Buffer, "enum16unionalign ");
            
        PrintArg( SWITCH_WIRE_COMPAT, Buffer, 0 );
        }

    if( IsSwitchDefined( SWITCH_NO_CPP ) )
        PrintArg( SWITCH_NO_CPP, "Yes" , 0);

    if( IsSwitchDefined( SWITCH_NO_DEF_IDIR ) )
        PrintArg( SWITCH_NO_DEF_IDIR, "Yes", 0 );

    if( IsSwitchDefined( SWITCH_NO_WARN ) )
        PrintArg( SWITCH_NO_WARN, "Yes" , 0);

    if( IsSwitchDefined( SWITCH_USE_EPV ) )
        PrintArg( SWITCH_USE_EPV, "Yes" , 0);
    
    if( IsSwitchDefined( SWITCH_NO_DEFAULT_EPV ) )
        PrintArg( SWITCH_NO_DEFAULT_EPV, "Yes" , 0);
    

    if ( ( p = GetOutputPath() ) != 0 )
        PrintArg( SWITCH_OUT, GetOutputPath(), 0 );

    Option    = GetZeePee();

    if( IsSwitchDefined( SWITCH_PACK ) )
        PrintArg( SWITCH_PACK,
                  (Option == 1) ? "1"    :
                  (Option == 2) ? "2"    :
                  (Option == 4) ? "4"    : "8" , 0);

    if( IsSwitchDefined( SWITCH_PREFIX ) )
        {
        char    *    pSys;
        char    *    pUser;
        char    *    pAll    = pSwitchPrefix->GetUserDefinedEquivalent( PREFIX_ALL );
        short        Cur;
        while( (Cur = pSwitchPrefix->GetNext( &pSys, &pUser ) ) >= 0 )
            {
            // if he specified all, don't report others that are the same
            if ( ( Cur == PREFIX_ALL ) ||
                 !pAll ||
                 strcmp( pAll, pUser ) )
                {
                PrintArg( SWITCH_PREFIX,
                          pSys,
                          pUser );
                }
            }
        }

    Option    = GetServerSwitchValue();

    PrintArg( SWITCH_SERVER,
              (Option == SRVR_STUB) ? "stub" : "none" , 0 );

    if ( ( p = GetSstubFName() ) != 0 )
        PrintArg( SWITCH_SSTUB, p , 0);

    if ( IsSwitchDefined( SWITCH_SYNTAX_CHECK ) )
        PrintArg( SWITCH_SYNTAX_CHECK, "Yes", 0 );

    if ( IsSwitchDefined( SWITCH_U ) )
        PrintArg( SWITCH_U, pUSwitch->GetConsolidatedOptions(), 0 );

    PrintArg( SWITCH_O,
              GetOptimizationFlags() == OPTIMIZE_SIZE
                                     ?  "inline stubs"
                                     :  "interpreted stubs",
                  0 );

    Option    = GetWarningLevel();
    PrintArg( SWITCH_W,
              (Option == 0 ) ? "0" :
              (Option == 1 ) ? "1" :
              (Option == 2 ) ? "2" :
              (Option == 3 ) ? "3" :
              (Option == 4 ) ? "4" :
              (Option == 5 ) ? "5" : "6" , 0);
        
    if( IsSwitchDefined( SWITCH_WX ) )
        PrintArg( SWITCH_WX, "Yes", 0 );

    Option = GetZeePee();

    PrintArg( SWITCH_ZP,
              (Option == 1) ? "1"    :
              (Option == 2) ? "2"    :
              (Option == 4) ? "4"    : "8" , 0);

    if( IsSwitchDefined( SWITCH_ZS ) )
        PrintArg( SWITCH_ZS, "Yes", 0 );

    if( IsSwitchDefined( SWITCH_MS_CONF_STRUCT ) )
        PrintArg( SWITCH_MS_CONF_STRUCT, "Yes", 0 );

    fprintf(stdout, "\n" );
}

char *            
CommandLine::GetCompilerVersion()
    {
    if ( !szCompilerVersion[0] )
        {
        sprintf( szCompilerVersion, "%d.%02d.%04d", rmj, rmm, rup );
        }
    return szCompilerVersion;
    }

// note that this string ends with a newline.
char *            
CommandLine::GetCompileTime()
    {
    if ( !szCompileTime[0] )
        {
        time_t        LocalTime;
        // fetch the time
        time( &LocalTime );
        // convert to a string
        strcpy( szCompileTime, ctime( &LocalTime ) );
        }
    return szCompileTime;
    }


// ----------------------------------------------------------------------------
//    The help screen(s)
//

const char *HelpArray[] = {
 "                       -MIDL COMPILER OPTIONS-"
,"                                -MODE-"
,"/ms_ext            Microsoft extensions to the IDL language (default)"
,"/c_ext             Allow Microsoft C extensions in the IDL file (default)"
,"/osf               OSF mode - disables /ms_ext and /c_ext options"
,"/app_config        Allow selected ACF attributes in the IDL file"
,"/mktyplib203       MKTYPLIB Version 2.03 compatiblity mode"
,""
,"                               -INPUT-"
,"/acf filename      Specify the attribute configuration file"
,"/I directory-list  Specify one or more directories for include path"
,"/no_def_idir       Ignore the current and the INCLUDE directories"
,""
,"                       -OUTPUT FILE GENERATION-"
,"/client none       Do not generate client files"
,"/client stub       Generate client stub file only"
,"/out directory     Specify destination directory for output files"
,"/server none       Generate no server files"
,"/server stub       Generate server stub file only"
,"/syntax_check      Check syntax only; do not generate output files"
,"/Zs                Check syntax only; do not generate output files"
,"/oldtlb            Generate old format type libraries"
,"/newtlb            Generate new format type libraries (default)"
,"/notlb             Don't generate the tlb file"
,""
,"                         -OUTPUT FILE NAMES-"
,"/cstub filename    Specify client stub file name"
,"/dlldata filename  Specify dlldata file name"
,"/h filename        Specify header file name"
,"/header filename   Specify header file name"
,"/iid filename      Specify interface UUID file name"
,"/proxy filename    Specify proxy file name"
,"/sstub filename    Specify server stub file name"
,"/tlb filename      Specify type library file name"
#ifdef MIDL_INTERNAL
,"/netmonstub filename     Specify Netmon classic interface stub file name"
,"/netmonobjstub filename  Specify Netmon object interface stub file name"
#endif // MIDL_INTERNAL
,""
,"                -C COMPILER AND PREPROCESSOR OPTIONS-"
,"/cpp_cmd cmd_line  Specify name of C preprocessor (default: cl.exe)"
,"/cpp_opt options   Specify additional C preprocessor options"
,"/D name[=def]      Pass #define name, optional value to C preprocessor"
,"/no_cpp            Turn off the C preprocessing option"
,"/nocpp             Turn off the C preprocessing option"
,"/U name            Remove any previous definition (undefine)"
,"/msc_ver <nnnn>    Microsoft C/C++ compiler version"
,"/savePP            Save the preprocessed temporary file(s)"
,""
,"                            -ENVIRONMENT-"
,"/char signed       C compiler default char type is signed"
,"/char unsigned     C compiler default char type is unsigned"
,"/char ascii7       Char values limited to 0-127"
,"/env win32         Target environment is Microsoft Windows 32-bit (NT)"
,"/env win64         Target environment is Microsoft Windows 64-bit (NT)"
,"/lcid              Locale id for international locales"
,"/ms_union          Use Midl 1.0 non-DCE wire layout for non-encapsulated unions"
,"/oldnames          Do not mangle version number into names"
,"/rpcss             Automatically activate rpc_sm_enable_allocate"
,"/use_epv           Generate server side application calls via entry-pt vector"
,"/no_default_epv    Do not generate a default entry-point vector"
,"/prefix client str Add \"str\" prefix to client-side entry points"
,"/prefix server str Add \"str\" prefix to server-side manager routines"
,"/prefix switch str Add \"str\" prefix to switch routine prototypes"
,"/prefix all str    Add \"str\" prefix to all routines"
,"/win32             Target environment is Microsoft Windows 32-bit (NT)"
,"/win64             Target environment is Microsoft Windows 64-bit (NT)"
,"/protocol dce      Use DCE NDR transfer syntax (default for 32b)"
,"/protocol all      Use all supported transfer syntaxes"
,"/protocol ndr64    Use Microsoft extension NDR64 transfer syntax"
,"/target {system}   Set the minimum target system"

,""
,"                     -RUNTIME ERROR CHECKING BY STUBS-"
,"/error all         Turn on all the error checking options, the best flavor"
,"/error none        Turn off all the error checking options"
,"/error allocation  Check for out of memory errors"
,"/error bounds_check   Check size vs transmission length specification"
,"/error enum        Check enum values to be in allowable range"
,"/error ref         Check ref pointers to be non-null"
,"/error stub_data   Emit additional check for server side stub data validity"
,"/robust            Generate additonal information to validate parameters"
,""
,"                            -OPTIMIZATION-"
,"/align {N}         Designate packing level of structures"
,"/pack {N}          Designate packing level of structures"
,"/Zp {N}            Designate packing level of structures"
,"/no_format_opt     Skip format string reusage optimization"
,"/Oi                Generate fully interpreted stubs, old style"
,"                   -Oicf is usually better"
,"/Oic               Generate fully interpreted stubs for standard interfaces and"
,"                   stubless proxies for object interfaces as of NT 3.51 release"
,"                   using -Oicf instead is usually better"
,"/Oicf              Generate fully interpreted stubs with extensions and"
,"                   stubless proxies for object interfaces as of NT 4.0 release"
,"/Oif               Same as -Oicf"
,"/Os                Generate inline stubs"
#ifdef MIDL_INTERNAL
,"/netmon            Generate stubs for Netmon debugging (requires -Oicf)"
#endif // MIDL_INTERNAL
,""
,"                           -MISCELLANEOUS-"
,"@response_file     Accept input from a response file"
,"/?                 Display a list of MIDL compiler switches"
,"/confirm           Display options without compiling MIDL source"
,"/help              Display a list of MIDL compiler switches"
,"/nologo            Supress displaying of the banner lines"
,"/o filename        Redirects output from screen to a file"
,"/W{0|1|2|3|4}      Specify warning level 0-4 (default = 1)"
,"/WX                Report warnings at specified /W level as errors"
,"/no_warn           Suppress compiler warning messages"
};

STATUS_T
CommandLine::Help()
    {
    int         i,LineCount,MaxLineCount = 23;

    for(i = 0; i < sizeof(HelpArray)/sizeof(char *) ;)
        {
        for( LineCount = 0;
             (LineCount < MaxLineCount) && (i < sizeof(HelpArray)/sizeof(char *)) ;
             LineCount++,++i )
            {
            fprintf(stdout, "%s\n", HelpArray[i] );
            }

        //
        // if all the help strings are displayed, then no need for user input.
        //

        if( i < (sizeof( HelpArray ) / sizeof( char *)) )
            {
            if( _isatty( MIDL_FILENO( stdout ) ) )
                {
                fprintf( stdout, "[ Press <return> to continue ]" );
                MIDL_FGETCHAR();
                }
            }
        }

    return STATUS_OK;
    }

void
PrintArg(
    enum _swenum Switch,
    char    *    pFirst,
    char    *    pSecond )
{
    char *    pL        = "",
         *    pR        = "",
         *    pComma    = "";
    char *    pSwString = (Switch == BASE_FILENAME) ? "input file" :
                        SwitchStringForValue( (unsigned short)Switch );

    if( pSecond )
        {
        pL    = "(";
        pR    = ")";
        pComma    = ",";
        }
    else
        pSecond = "";

    fprintf( stdout, "\n%20s - %s %s %s %s %s"
            , pSwString
            , pL
            , pFirst
            , pComma
            , pSecond
            , pR );
}

void
CmdProcess(
    pair_switch*    pPair,
    CommandLine*    pCmdAna,
    char*           pFirstOfPair)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    pair_switch command analyzer

 Arguments:

    pCmdAna                - a ptr to the command analyser object calling this.
    pFirstOfPair        - the first argument after the -prefix switch.

 Return Value:

    NA

 Notes:

    Use the GetNextArg and UndoGetNextArg functions as necessary.

    1. We start with the input argument, which is the first of the
       arguments to the prefix switch, ie first of the first pair.

    2. If we find an argument starting with a '-' or  '/' it is definitely the
       end of the prefix specification. If the switch starter is seen at the end
       of a pair it is a proper end of the prefix switch, else the prefix switch
       pair specification is illegal.

    3. In either case, as soon as a switch starter is seen, we must
       UndoGetNextArg.

    This class needs a pointer to the command analyser object that is calling
    it, since it has to get and undoget argument from there

----------------------------------------------------------------------------*/
{
    short        PairCheck    = 0;
    char    *    pNextOfPair;
    char    *    pTemp;
    STATUS_T     Status       = STATUS_OK;
    short        i;


    while( pFirstOfPair &&  (*pFirstOfPair != '-') && (*pFirstOfPair != '/' ) )
        {

        // the first of the pair is a system defined string. Is it a valid one?

        if( (i = pPair->GetIndex( pFirstOfPair )) >= 0 )
            {

            // we know the first of the pair is valid. Check the next before
            // allocating any memory.

            PairCheck++;
            pTemp = pCmdAna->GetNextArg();

            if( pTemp && (*pTemp != '-') && (*pTemp != '/') )
                {
                pNextOfPair = new char [ strlen( pTemp ) + 1 ];
                strcpy( pNextOfPair, pTemp );

                // update the list

                pPair->AddPair( i, pNextOfPair );
                PairCheck++;
                }
            else
                break;
            }
        else
            break;
        pFirstOfPair = pCmdAna->GetNextArg();

        if( PairCheck == 0 )
            {
            Status = ILLEGAL_ARGUMENT;
            }
        else if( (PairCheck % 2) != 0 )
            {
            Status = MISMATCHED_PREFIX_PAIR;
            }
    
        if( Status != STATUS_OK )
            {
            RpcError( (char *)NULL,
                      0,
                      Status,
                      SwitchStringForValue( SWITCH_PREFIX ) );

            }
    
    }

    // if we read ahead, push the argument back
    if ( pFirstOfPair )
        pCmdAna->UndoGetNextArg();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\driver\exec.cxx ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include <windows.h>

#include "errors.hxx"

STATUS_T
Execute( char* szCmd, char* szCmdFile )
    {
    PROCESS_INFORMATION prc;
    STARTUPINFO         info;
    BOOL                fCreated;
    char                cmdLine[512];
    STATUS_T            status = STATUS_OK;

    ZeroMemory( &info, sizeof( info ) );
    info.cb = sizeof( info );
    info.hStdError = GetStdHandle( STD_ERROR_HANDLE );
    info.hStdInput = GetStdHandle( STD_INPUT_HANDLE );
    info.hStdOutput = GetStdHandle( STD_OUTPUT_HANDLE );

    strcpy( cmdLine, szCmd );
    strcat( cmdLine, " \"" );       // quote the command file in case it has
    strcat( cmdLine, szCmdFile );   // spaces in the path
    strcat( cmdLine, "\" " );

    fCreated = CreateProcess( NULL, cmdLine, 0, 0, TRUE, 0, 0, 0, &info, &prc );

    if ( fCreated )
        {
        WaitForSingleObject( prc.hProcess, INFINITE );
        GetExitCodeProcess( prc.hProcess, ( LPDWORD ) &status );

        CloseHandle( prc.hThread );
        CloseHandle( prc.hProcess );
        }
    else
        {
        status = SPAWN_ERROR;
        }

    return status;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\common\pragma.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1997-1999 Microsoft Corporation

 Module Name:

    pragma.cxx

 Abstract:

    Implementation of the object that maintains flags for each warning/error
    message. The flag indicates whether or not the warning should be emitted.
    Error messages are always emitted.

 Notes:


 Author:

    NishadM Dec-30-1997     Created.

 Notes:


 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 4512 )

#include "Pragma.hxx"

CMessageNumberList::CMessageNumberList()
{
    SetAll();
}

void CMessageNumberList::SetAll()
{
    for ( unsigned long i = 0; i < c_nMsgs; i++ )
        {
        fMessageNumber[i] = ( unsigned long ) -1;
        }
}

void CMessageNumberList::ResetAll()
{
    for ( unsigned long i = 0; i < c_nMsgs; i++ )
        {
        fMessageNumber[i] = 0;
        }
}

unsigned long CMessageNumberList::BitIndex( unsigned long ulMsg )
{
    if ( ulMsg >= C_ERR_START && ulMsg <= C_ERR_MAX )
        {
        ulMsg = ulMsg - C_ERR_START + D_ERR_MAX - D_ERR_START + 2;
        }
    else if ( ulMsg >= D_ERR_START && ulMsg <= D_ERR_MAX )
        {
        ulMsg = ulMsg - D_ERR_START + 1;
        }
    else
        {
        ulMsg = 0;
        }
    return ulMsg;
}

void CMessageNumberList::SetMessageFlags( CMessageNumberList& list )
{
    for ( unsigned long i = 0; i < c_nMsgs; i++ )
        {
        fMessageNumber[i] |= list.fMessageNumber[i];
        }
}

void CMessageNumberList::ResetMessageFlags( CMessageNumberList& list )
{
    for ( unsigned long i = 0; i < c_nMsgs; i++ )
        {
        fMessageNumber[i] &= ~(list.fMessageNumber[i]);
        }
}

/*
GlobalMainMessageNumberList contains the list of currently enabled/disabled warnings. 
*/
CMessageNumberList   GlobalMainMessageNumberList;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\driver\main.cxx ===
#pragma warning ( disable : 4514 )

#include <stdio.h>
#include <malloc.h>
#include <excpt.h>
#include <process.h>
#include <string.h>

#include "cmdline.h"
#include "errdb.h"

#ifdef MIDL_INTERNAL
#define MIDL_FREE_BUILD  0
#define MIDL_INTERNAL_PRINTF(x)  printf(x)  
#else
#define MIDL_FREE_BUILD  1
#define MIDL_INTERNAL_PRINTF(x)  
#endif

const char *pSignon1 = "Microsoft (R) 32b/64b MIDL Compiler Version %s \n";
const char *pSignon2 = "Copyright (c) Microsoft Corp 1991-2000. All rights reserved.\n";

STATUS_T Execute( char* szCmd, char* szCmdLine );
void RpcError( char* pFile, short Line, STATUS_T status, char* pSuffix );
void ReportError( STATUS_T status, char* szMsg );
void WriteCommandAnaFile(char *pszFilename, CommandLine *pCmdLine);

extern "C" long __stdcall GetTempPathA( long, char * );
extern "C" long __stdcall GetTempFileNameA( const char*, const char*, unsigned int, char * );

CMD_ARG*    pCommand;
bool        fCommandLineErrors = false;

inline bool BadIntermediateFileError( STATUS_T status )
{
    return    ( BAD_CMD_FILE            == status )
           || ( UNABLE_TO_OPEN_CMD_FILE == status );
}


int
main(
    int     argc,
    char**  argv
    )
    {
    STATUS_T        status = STATUS_OK;
    char            szTempCmdFile[_MAX_PATH];

    _try
        {
        CommandLine* pCmdLine = new CommandLine;
        pCommand = pCmdLine;

        // /nologo is specially detected by RegisterArgs
        pCmdLine->RegisterArgs( argv+1, short(argc -1) );
        char* szVersion = pCmdLine->GetCompilerVersion();
        pCmdLine->GetCompileTime();

        if ( pCmdLine->ShowLogo() )
            {
            // the signon
            fprintf( stderr, pSignon1, szVersion );
            fprintf( stderr, pSignon2 );
            fflush( stderr );
            }

        status = pCmdLine->ProcessArgs();

        if( status == STATUS_OK && ! fCommandLineErrors )
            {
            if( pCmdLine->IsSwitchDefined( SWITCH_CONFIRM ) )
                {
                pCmdLine->Confirm();
                }
            else if( pCmdLine->IsSwitchDefined( SWITCH_HELP ) )
                {
                pCmdLine->Help();
                }
            else
                {
                char path_buffer[_MAX_PATH];
                char drive[_MAX_DRIVE];
                char dir[_MAX_DIR];
                char fname[_MAX_FNAME];
                char ext[_MAX_EXT];

                // Create the core intermediate file

                GetTempPathA( _MAX_PATH, path_buffer );

                if ( !GetTempFileNameA(path_buffer, "MIDLC", 0, szTempCmdFile) )
                    {
                    status = INTERMEDIATE_FILE_CREATE;
                    RpcError( NULL, 0, status, path_buffer);
                    return status;
                    }

                WriteCommandAnaFile( szTempCmdFile, pCmdLine );
        
                // The path to midlc.exe should be the same as the path to
                // midl.exe

                _splitpath( argv[0], drive, dir, fname, ext );
                _makepath( path_buffer, drive, dir, "midlc", "exe" );

                // if -debugline is present, spit out the midlcore command
                // line and quit; the command ana file is preserved.

                if ( pCmdLine->IsSwitchDefined( SWITCH_DEBUGLINE ) )
                {
                    printf( "\ndebugline: %s %s\n", path_buffer, szTempCmdFile );
                    return 0;
                }

                // spawn 32b MIDL run

                status = ( STATUS_T ) Execute( path_buffer, szTempCmdFile );

                if ( ! BadIntermediateFileError( status ) )
                    _unlink( szTempCmdFile );

                if ( !pCmdLine->IsSwitchDefined( SWITCH_ENV ) && status == STATUS_OK )
                    {
                    // spawn 64b MIDL run
                    pCmdLine->SetEnv( ENV_WIN64 );
                    pCmdLine->SetHasAppend64( TRUE );
                    pCmdLine->SwitchDefined( SWITCH_APPEND64 );
                    pCmdLine->SetPostDefaults64();

                    if ( status == STATUS_OK && ! fCommandLineErrors )
                        {
                        WriteCommandAnaFile( szTempCmdFile, pCmdLine );

                        status = ( STATUS_T ) Execute( path_buffer, szTempCmdFile );

                        if ( ! BadIntermediateFileError( status ) )
                            _unlink( szTempCmdFile );
                        }
                    }
                }
            }

        if ( status == SPAWN_ERROR )
            {
            RpcError( 0, 0, status, 0 );
            }
        }
    __except( MIDL_FREE_BUILD && ! pCommand->IsSwitchDefined( SWITCH_DEBUGEXC ) )
        {
        // Catch exceptions only for free builds run without -debugexc switch.
        status = (STATUS_T) GetExceptionCode();
        printf( "\nmidl : error MIDL%d : internal compiler problem -",
                I_ERR_UNEXPECTED_INTERNAL_PROBLEM );
        printf( " See documentation for suggestions on how to find a workaround.\n" );
        }

    return status;
    }

void WriteCommandAnaFile(
    char *pszFilename, 
    CommandLine *pCmdLine
    )
    {
    STREAM stream( pszFilename );
    stream.SetStreamMode( STREAM_BINARY );
    pCmdLine->StreamOut( &stream );
    fflush( NULL );
    }    
    
void
IncrementErrorCount()
    {
    fCommandLineErrors = true;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\expr\expr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    expr.cxx

 Abstract:

    expression evaluator routines implementation.

 Notes:


 History:

    VibhasC     Aug-05-1993     Created

 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 )

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "nulldefs.h"

extern "C"
    {
    #include <stdio.h>
    
    #include <string.h>
    }

#include "expr.hxx"
#include "listhndl.hxx"
#include "nodeskl.hxx"
#include "semantic.hxx"
#include "symtable.hxx"
#include "cmdana.hxx"
#include <excpt.h>
#include <float.h>

/****************************************************************************
 *  extern definitions
 ***************************************************************************/
/****************************************************************************
 *  extern data
 ***************************************************************************/
extern  SymTable        *   pBaseSymTbl;
extern  CMD_ARG         *   pCommand;

/****************************************************************************
 *  local definitions
 ***************************************************************************/
/****************************************************************************
 *  local data
 ***************************************************************************/
/***************************************************************************/

short
expr_node::MakeListOfVars(
    ITERATOR & 
    )
{
    return( 0 );
}

short
expr_named_constant::MakeListOfVars(
    ITERATOR & 
    )
{
    return( 0 );
}

short
expr_variable::MakeListOfVars(
    ITERATOR & pList
    )
{
    pList.Insert( this );
    return( 1 );
}

short
expr_op_unary::MakeListOfVars(
    ITERATOR & pList
    )
{
    short VarCount = 0;

    if ( GetLeft() )
        VarCount = GetLeft()->MakeListOfVars( pList );
    return( VarCount );
}

short
expr_sizeof::MakeListOfVars(
    ITERATOR & 
    )
/*++
    expr_sizeof is a unary_op but it doesn't have a child!
--*/
{
    return( 0 );
}

short
expr_alignof::MakeListOfVars(
    ITERATOR & 
    )
/*++
    expr_alignof is a unary_op but it doesn't have a child!
--*/
{
    return( 0 );
}

short
expr_op_binary::MakeListOfVars(
    ITERATOR & pList
    )
{
    short VarCount;

    VarCount = GetLeft()->MakeListOfVars( pList );
    if ( GetRight() )
        {
        VarCount = short( VarCount + GetRight()->MakeListOfVars( pList ) );
        }
    return( VarCount );
}

short
expr_ternary::MakeListOfVars(
    ITERATOR & pList
    )
{
    short VarCount;

    VarCount = GetLeft()->MakeListOfVars( pList );
    if ( GetRight() )
        {
        VarCount = short( VarCount + GetRight()->MakeListOfVars( pList ) );
        }
    if ( GetRelational() )
        {
        VarCount = short( VarCount + GetRelational()->MakeListOfVars( pList ) );
        }
    return( VarCount );
}

/***************************************************************************/
void
expr_node::DecorateWithPrefix(
    char *      pPrefix )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    This routine decorates all the variable nodes in the expression
    with a prefix.

 Arguments:

    pPrefix     - the prefix to be prepended to each variable

 Return Value:

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR  VarList;
    expr_variable * pVarNode = 0;

    short VarCount = MakeListOfVars( VarList );
    if ( VarCount )
        {
        VarList.Init();
        while ( ITERATOR_GETNEXT( VarList, pVarNode ) )
            pVarNode->SetPrefix( pPrefix );
        }
    return;
}

expr_index::expr_index(
    expr_node * pL,
    expr_node * pR ) : expr_op_binary( OP_INDEX, pL, pR )
    {
    SetType( pL->GetType() );
    }

expr_param *
expr_proc_call::SetParam(
    expr_param  *   pParam )
    {
    expr_param  *   p   = GetFirstParam();

    IncrNoOfParams();
    if( p )
        {
        return p->SetLastPeerParam( pParam );
        }
    else
        return SetFirstParam( pParam );
    }
expr_param *
expr_proc_call::SetParam(
    expr_node * pExpr )
    {
    return SetParam( new expr_param( pExpr ));
    }

expr_param *
expr_param::SetLastPeerParam(
    expr_param  *   pParam )
    {
    expr_param  *   p   = GetNextParam();

    if( p )
        {
        return p->SetLastPeerParam( pParam );
        }
    else
        {
        return SetNextParam( pParam );
        }
    }


/**
 ** This routine attempts to recreate the string to be eaten by c compilers.
 ** If the user specified a string with a quote inside, substitute with an
 ** escape character. The new string with possible escapes will ALWAYS be
 ** smaller than the older one, so allocating the same amount of space is
 ** enough.
 **/

char *
MakeNewStringWithProperQuoting(
    char    *   pSrc )
    {
    char    *   pResult = new char [ strlen( pSrc ) + 1];
    char        ch;
    char    *   pDest   = pResult;

    while( ( ch = *pSrc++ ) != 0 )
        {

        *pDest = ch;

        if( ch == '\\')
            {
            if( ( ch = *pSrc++ ) != 0 )
                {
                if( (ch == '"') || ( ch == '\\') )
                    {
                    *pDest = ch;
                    }
                else
                    {
                    *pDest++ = '\\';
                    *pDest   = ch;
                    }
                }
            else
                break;
            }
        pDest++;
        }
    *pDest = '\0';
    return pResult;
    }

// routines for expr_variable...

// constructor - see if the type is constant
expr_variable::expr_variable( PNAME p, node_skl * pT )
{
    SetName( p );
    SetType( pT );
    SetConstant( FALSE );
    SetPrefix( NULL );
}

// resolve forwards on GetType
node_skl        *
expr_variable::GetType( void )
{
    if ( pType )
        {
        if ( pType->NodeKind() == NODE_FORWARD )
            {
            node_forward*   pFwd = (node_forward *) pType;
            // (permanently) resolve the forward
            pType = pFwd->ResolveFDecl();
            // if it couldn't be resolved, put back the forward
            if ( !pType )
                {
                pType = pFwd;
                }
            }
        }
    return pType;
}

// named constant routines...

// evaluate the variable if it is a constant
EXPR_VALUE
expr_named_constant::GetValue()
{
    node_skl *  pT      = GetType();
    NODE_T      Kind    = ( pT ) ? (NODE_T) pT->NodeKind()
                                 : (NODE_T) NODE_ILLEGAL;

    if ( !IsConstant() )
        return 0;

    // identifiers may be const... Forwards are assumed NOT const
    if ( Kind == NODE_ID )
        {
        node_id *       pId     = (node_id *) pT;
        node_skl    *   pType   = pId->GetBasicType();
        EXPR_VALUE      Result  = (pId->GetExpr()->GetValue() );

        return (pType) ? pType->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result;
        }
    else if ( Kind == NODE_LABEL )
        {
        return ( (node_label *) pT)->GetValue();
        }

    MIDL_ASSERT(FALSE);
    return 0; // for the compiler...
}

// evaluate the variable if it is a constant
expr_node *
expr_named_constant::GetExpr()
{
    node_skl *  pT      = GetType();
    NODE_T      Kind    = ( pT ) ? (NODE_T) pT->NodeKind()
                                 : (NODE_T) NODE_ILLEGAL;

    if ( !IsConstant() )
        return 0;

    // identifiers may be const... Forwards are assumed NOT const
    if ( Kind == NODE_ID )
        {
        node_id *       pId = (node_id *) pT;

        return pId->GetExpr();
        }
    else if ( Kind == NODE_LABEL )
        {
        return ( (node_label *) pT)->pExpr;
        }

    MIDL_ASSERT(FALSE);
    return 0; // for the compiler...
}

/******************************************************************************
 *  expression list handler
 *****************************************************************************/
expr_list::expr_list()
    {
    SetConstant( TRUE );
    }

STATUS_T
expr_list::GetPeer(
    expr_node   **  ppExpr )
    {
    return (GetNext( (void **)ppExpr ) );
    }
STATUS_T
expr_list::SetPeer(
    expr_node   *   pExpr )
    {
    if ( pExpr && !pExpr->IsConstant() )
        SetConstant( FALSE );

    return Insert( (void *) pExpr );
    }

EXPR_VALUE
expr_u_arithmetic::GetValue()
{
        EXPR_VALUE  LeftValue   = GetLeft()->GetValue();
        EXPR_VALUE  Result;

        switch ( GetOperator() )
            {
            case OP_UNARY_PLUS:
                {
                Result = LeftValue;
                break;
                }
            case OP_UNARY_MINUS:
                {
                if (IsStringConstant())
                    {
                    char * szVal = (char *)LeftValue;
                    char * szNewVal = new char[strlen(szVal)+2];
                    szNewVal[0] = '-';
                    strcpy(szNewVal + 1, szVal);
                    Result = (EXPR_VALUE) szNewVal;
                    }
                else
                    {
                    Result = -LeftValue;
                    }    
                break;
                }
            default:
                {
                Result = 0;
                break;
                }
            }
        return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result;
}

EXPR_VALUE
expr_u_not::GetValue()
{
    EXPR_VALUE  Result = !GetLeft()->GetValue();

    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result;
}

EXPR_VALUE
expr_u_complement::GetValue()
{
    EXPR_VALUE  Result = ~ GetLeft()->GetValue();

    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result;
}

EXPR_VALUE
expr_cast::GetValue()
{
    return GetType()->
                ConvertMyKindOfValueToEXPR_VALUE(GetLeft()->GetValue());
}

EXPR_VALUE
expr_constant::GetValue()
{
    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Value.I64) 
                       : Value.I64;
}


EXPR_VALUE
expr_sizeof::GetValue()
    {
    return  (pType) ? pType->GetSize() : 0;
    }

EXPR_VALUE
expr_alignof::GetValue()
    {
    return  (pType) ? pType->GetAlign() : 0;  
    }

EXPR_VALUE
expr_b_arithmetic::GetValue()
    {
    EXPR_VALUE  LeftValue   = GetLeft()->GetValue();
    EXPR_VALUE  RightValue  = GetRight()->GetValue();
    EXPR_VALUE  Result;

    switch ( GetOperator() )
        {
        case OP_PLUS:
            {
            Result = LeftValue + RightValue;
            break;
            }
        case OP_MINUS:
            {
            Result = LeftValue - RightValue;
            break;
            }
        case OP_STAR:
            {
            Result = LeftValue * RightValue;
            break;
            }
        case OP_SLASH:
            {
            if (RightValue == 0)
                Result = 1;
            else
                Result = LeftValue / RightValue;
            break;
            }
        case OP_MOD:
            {
                        if ( 0 == RightValue )
                                Result = 1;
                        else
                    Result = LeftValue % RightValue;
            break;
            }
        default:
            {
            Result = 0;
            break;
            }
        }
    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result ;
    }

EXPR_VALUE
expr_b_logical::GetValue()
    {
    EXPR_VALUE  LeftValue   = GetLeft()->GetValue();
    EXPR_VALUE  RightValue  = GetRight()->GetValue();
    EXPR_VALUE  Result;

    switch ( GetOperator() )
        {
        case OP_LOGICAL_AND:
            {
            Result = LeftValue && RightValue;
            break;
            }
        case OP_LOGICAL_OR:
            {
            Result = LeftValue || RightValue;
            break;
            }
        default:
            {
            Result = 0;
            break;
            }
        }
    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result ;
    }

EXPR_VALUE
expr_relational::GetValue()
    {
    EXPR_VALUE  LeftValue   = GetLeft()->GetValue();
    EXPR_VALUE  RightValue  = GetRight()->GetValue();
    EXPR_VALUE  Result;

    switch ( GetOperator() )
        {
        // gaj - we implicitly assume signed types
        case OP_LESS:
            {
            Result = LeftValue < RightValue;
            break;
            }
        case OP_LESS_EQUAL:
            {
            Result = LeftValue <= RightValue;
            break;
            }
        case OP_GREATER_EQUAL:
            {
            Result = LeftValue >= RightValue;
            break;
            }
        case OP_GREATER:
            {
            Result = LeftValue > RightValue;
            break;
            }
        case OP_EQUAL:
            {
            Result = LeftValue == RightValue;
            break;
            }
        case OP_NOT_EQUAL:
            {
            Result = LeftValue != RightValue;
            break;
            }
        default:
            {
            Result = 0;
            break;
            }
        }
    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result;
    }

EXPR_VALUE
expr_shift::GetValue()
    {
    EXPR_VALUE  LeftValue   = GetLeft()->GetValue();
    EXPR_VALUE  RightValue  = GetRight()->GetValue();
    EXPR_VALUE  Result;

    switch ( GetOperator() )
        {
        // gaj - we implicitly assume signed types
        case OP_LEFT_SHIFT:
            {
            Result = LeftValue << RightValue;
            break;
            }
        case OP_RIGHT_SHIFT:
            {
            Result = LeftValue >> RightValue;
            break;
            }
        default:
            {
            Result = 0;
            break;
            }
        }
    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result;
    }

EXPR_VALUE
expr_bitwise::GetValue()
    {
    EXPR_VALUE  LeftValue   = GetLeft()->GetValue();
    EXPR_VALUE  RightValue  = GetRight()->GetValue();
    EXPR_VALUE  Result;

    switch ( GetOperator() )
        {
        // gaj - we implicitly assume signed types
        case OP_AND:
            {
            Result = LeftValue & RightValue;
            break;
            }
        case OP_OR:
            {
            Result = LeftValue | RightValue;
            break;
            }
        case OP_XOR:
            {
            Result = LeftValue ^ RightValue;
            break;
            }
        default:
            {
            Result = 0;
            break;
            }
        }
    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result ;
    }

EXPR_VALUE
expr_ternary::GetValue()
    {
    EXPR_VALUE  RelValue    = GetRelational()->GetValue();
    EXPR_VALUE  Result;

    if ( RelValue )
        Result = GetLeft()->GetValue();
    else
        Result = GetRight()->GetValue();

    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result;
    }

////////////////////////////////////////////////////////////////////////
// analysis of expressions
//

void
expr_node::ExprAnalyze( EXPR_CTXT * pExprCtxt )
    {
    pExprCtxt->SetUpFlags( EX_VALUE_INVALID );
    }

//
// determine the type of the expression
//

void
expr_op_unary::DetermineType()
{
    node_skl    *   pLeftType;

    if ( !GetLeft() )
        {
        return;
        }

    pLeftType = GetLeft()->AlwaysGetType();
    SetConstant( GetLeft()->IsConstant() );

    switch ( GetOperator() )
        {
        case OP_UNARY_PLUS:
        case OP_UNARY_COMPLEMENT:
        case OP_UNARY_MINUS:
        case OP_PRE_INCR:
        case OP_PRE_DECR:
        case OP_POST_INCR:
        case OP_POST_DECR:
            {
            // same type
            SetType( pLeftType );
            break;
            }
        case OP_UNARY_NOT:
            {
            node_skl *  pTmpType;

            GetBaseTypeNode( &pTmpType, SIGN_UNDEF, SIZE_UNDEF, TYPE_BOOLEAN );

            SetType( pTmpType );
            break;
            }
        case OP_UNARY_CAST:
            {
            SetType( GetType() );
            break;
            }
        case OP_UNARY_SIZEOF:
                case OP_UNARY_ALIGNOF:
            {
            node_skl *  pTmpType;

            GetBaseTypeNode( &pTmpType, SIGN_SIGNED, SIZE_UNDEF, TYPE_INT );

            SetType( pTmpType );
            SetConstant( TRUE );
            break;
            }
        case OP_UNARY_INDIRECTION:
            {
            node_skl *  pNode = pLeftType;

            if ( pNode->NodeKind() != NODE_POINTER )
                {
                // probably the param or field; look down
                pNode = pNode->GetBasicType();
                }

            // now get the pointee
            pNode = pNode->GetBasicType();

            SetType( pNode );
            break;
            }
        case OP_UNARY_AND:
            {
            node_pointer    *   pPtr    = new node_pointer;

            pPtr->SetChild( pLeftType );
            SetType( pPtr );
            break;
            }
        default:
            {
            break;
            }
        }   // end of switch
}

void
expr_op_unary::ExprAnalyze( EXPR_CTXT * pExprCtxt )
{
    EXPR_CTXT           LeftCtxt( pExprCtxt );

    if ( GetLeft() )
        {
        GetLeft()->ExprAnalyze( &LeftCtxt );
        pExprCtxt->MergeUpFlags( &LeftCtxt );
        SetConstant( GetLeft()->IsConstant() );
        }
    else if ( GetOperator() != OP_UNARY_SIZEOF && GetOperator() != OP_UNARY_ALIGNOF)
        pExprCtxt->SetUpFlags( EX_VALUE_INVALID );

    // do type compatibility stuff

    switch ( GetOperator() )
        {
        case OP_UNARY_PLUS:
        case OP_UNARY_COMPLEMENT:
            {
            // same type
            pExprCtxt->pType = LeftCtxt.pType;
            pExprCtxt->TypeInfo = LeftCtxt.TypeInfo;
            pExprCtxt->fIntegral = LeftCtxt.fIntegral;
            SetType( pExprCtxt->pType );
            break;
            }
        case OP_UNARY_MINUS:
            {
            node_skl    *   pTmp;

            pExprCtxt->pType = LeftCtxt.pType;
            pExprCtxt->TypeInfo = LeftCtxt.TypeInfo;
            pExprCtxt->TypeInfo.TypeSign = SIGN_SIGNED;
            pExprCtxt->fIntegral = LeftCtxt.fIntegral;
            GetBaseTypeNode( &pTmp, pExprCtxt->TypeInfo );
            if ( pTmp )
                pExprCtxt->pType = pTmp;

            SetType( pExprCtxt->pType );
            break;
            }
        case OP_UNARY_NOT:
            {
            pExprCtxt->TypeInfo.TypeSize = SIZE_UNDEF;
            pExprCtxt->TypeInfo.BaseType = TYPE_BOOLEAN;
            pExprCtxt->TypeInfo.TypeSign = SIGN_UNDEF;
            GetBaseTypeNode( &(pExprCtxt->pType ), pExprCtxt->TypeInfo );

            pExprCtxt->fIntegral = TRUE;
            SetType( pExprCtxt->pType );
            break;
            }
        case OP_UNARY_CAST:
            {
            SetType( GetType() );
            break;
            }
        case OP_UNARY_SIZEOF:
                case OP_UNARY_ALIGNOF:
            {
            pExprCtxt->TypeInfo.TypeSize = SIZE_UNDEF;
            pExprCtxt->TypeInfo.BaseType = TYPE_INT;
            pExprCtxt->TypeInfo.TypeSign = SIGN_SIGNED;
            GetBaseTypeNode( &(pExprCtxt->pType ), pExprCtxt->TypeInfo);

            pExprCtxt->fIntegral = TRUE;
            SetType( pExprCtxt->pType );
            break;
            }
        case OP_UNARY_INDIRECTION:
            {
            node_skl    *       pNode       = GetLeft()->GetType();
            node_skl    *       pOrigNode   = pNode;
            node_ptr_attr   *   pPtrAttr;
            PTRTYPE             PtrKind     = PTR_UNKNOWN;

            if ( pNode->FInSummary( ATTR_PTR_KIND ) )
                {
                pPtrAttr = (node_ptr_attr *)
                            ((named_node *)pNode)->GetAttribute( ATTR_PTR_KIND );
                PtrKind = pPtrAttr->GetPtrKind();
                }

            if ( pNode->FInSummary( ATTR_IGNORE ) )
                {
                SEM_ANALYSIS_CTXT * pCtxt = pExprCtxt->GetCtxt();

                // Only complain about this on the actual type, not every
                // single use of the type.

                if ( !pCtxt->AnyAncestorBits( IN_PARAM_LIST ) )
                    {
                    SemError( 
                            pNode, 
                            *pCtxt, 
                            CORRELATION_DERIVES_FROM_IGNORE_POINTER, 
                            NULL );
                    }
                }

            if ( pNode->NodeKind() != NODE_POINTER )
                {
                // probably the param or field; look down
                pNode = pNode->GetBasicType();
                }

            if ( pNode->NodeKind() != NODE_POINTER )
                {
                // error
                pNode = NULL;
                }
            else
                {
                // check things about type of pointer
                if ( PtrKind == PTR_UNKNOWN )
                    {
                    node_interface  *   pIntf   = pOrigNode->GetMyInterfaceNode();

                    if ( pOrigNode->NodeKind() == NODE_PARAM )
                        PtrKind = PTR_REF;
                    else if ( pIntf->FInSummary( ATTR_PTR_KIND ) )
                        {
                        pPtrAttr = (node_ptr_attr *)
                                        pIntf->GetAttribute( ATTR_PTR_KIND );
                        PtrKind = pPtrAttr->GetPtrKind();
                        }
                    else
                        {
                        pIntf = pExprCtxt->GetCtxt()->GetInterfaceNode();
                        if ( pIntf->FInSummary( ATTR_PTR_KIND ) )
                            {
                            pPtrAttr = (node_ptr_attr *)
                                            pIntf->GetAttribute( ATTR_PTR_KIND );
                            PtrKind = pPtrAttr->GetPtrKind();
                            }
                        else
                            {
                            if (pCommand->IsSwitchDefined( SWITCH_MS_EXT ) )
                                {
                                PtrKind = PTR_UNIQUE;
                                }
                            else
                                {
                                PtrKind = PTR_FULL;
                                }
                            }
                        }
                    }

                if ( ( PtrKind == PTR_FULL ) ||
                     ( PtrKind == PTR_UNIQUE ) )
                    {
                    SEM_ANALYSIS_CTXT * pCtxt   = pExprCtxt->GetCtxt();

                    pExprCtxt->SetUpFlags( EX_PTR_FULL_UNIQUE );
                    SemError( pCtxt->GetParent(),
                              *pCtxt,
                              SIZE_LENGTH_SW_UNIQUE_OR_FULL,
                              NULL );
                    }

                pNode = pNode->GetBasicType();
                }

            SetType( pNode );
            break;
            }
        case OP_UNARY_AND:
            {
            if ( GetType() )
                break;

            node_pointer    *   pPtr    = new node_pointer;

            pPtr->SetChild( GetLeft()->GetType() );
            SetType( pPtr );
            break;
            }
        case OP_PRE_INCR:
        case OP_PRE_DECR:
        case OP_POST_INCR:
        case OP_POST_DECR:
            {
            SetType( GetLeft()->GetType() );
            break;
            }
        default:
            {
            break;
            }
        }   // end of switch

    pExprCtxt->pType = GetType();

    // compute the value
    if ( !pExprCtxt->AnyUpFlags( EX_VALUE_INVALID ) )
        {
        // tbd - update value from LeftCtxt
        EXPR_VALUE  &   LeftValue   = LeftCtxt.Value();
        EXPR_VALUE  &   Result      = pExprCtxt->Value();


        switch ( GetOperator() )
            {
            case OP_UNARY_PLUS:
                {
                Result = LeftValue;
                break;
                }
            case OP_UNARY_MINUS:
                {
                Result = -LeftValue;
                break;
                }
            case OP_UNARY_NOT:
                {
                Result = !LeftValue;
                break;
                }
            case OP_UNARY_COMPLEMENT:
                {
                Result = ~LeftValue;
                break;
                }
            case OP_UNARY_CAST:
                {
                Result = LeftValue;
                break;
                }
            case OP_UNARY_SIZEOF:
                        case OP_UNARY_ALIGNOF:
                {
                Result = GetValue();
                break;
                }
            case OP_UNARY_INDIRECTION:
            case OP_UNARY_AND:
            case OP_PRE_INCR:
            case OP_PRE_DECR:
            case OP_POST_INCR:
            case OP_POST_DECR:
                {
                SetConstant( FALSE );
                pExprCtxt->SetUpFlags( EX_VALUE_INVALID );
                break;
                }
            default:
                {
                SetConstant( FALSE );
                Result = 0;
                break;
                }
            }   // end of case

        }  // end of if valid


}

//
// determine the type of the expression
//

void
expr_op_binary::DetermineType()
{
    node_skl    *   pLeftType   = NULL;
    node_skl    *   pRightType  = NULL;


    if ( GetLeft() )
        pLeftType   = GetLeft()->AlwaysGetType();
    if ( GetRight() )
        pRightType  = GetRight()->AlwaysGetType();

    SetConstant( GetRight()->IsConstant() && GetLeft()->IsConstant() );

    ////////////////////////////////////////////////////////////////////////
    // do type compatibility stuff

    switch ( GetOperator() )
        {
        case OP_PLUS:
        case OP_MINUS:
        case OP_STAR:
        case OP_MOD:
        // gaj - we implicitly assume signed types
        case OP_LEFT_SHIFT:
        case OP_RIGHT_SHIFT:
        case OP_AND:
        case OP_OR:
        case OP_XOR:
        case OP_SLASH:
            {
            // tbd - for now, just grab one of the types
            if ( !pRightType ||
                 (pLeftType &&
                        (pLeftType->GetSize() >= pRightType->GetSize() ) ) )
                {
                SetType( pLeftType );
                }
            else if ( pRightType )
                {
                SetType( pRightType );
                }

            break;
            }
        case OP_LOGICAL_AND:
        case OP_LOGICAL_OR:
        // gaj - we implicitly assume signed types
        case OP_LESS:
        case OP_LESS_EQUAL:
        case OP_GREATER_EQUAL:
        case OP_GREATER:
        case OP_EQUAL:
        case OP_NOT_EQUAL:
            {
            node_skl *  pTmpType;

            GetBaseTypeNode( &pTmpType, SIGN_UNDEF, SIZE_UNDEF, TYPE_BOOLEAN );

            SetType( pTmpType );
            break;
            }
        default:
            {
            break;
            }
        }



}

void
expr_op_binary::ExprAnalyze( EXPR_CTXT * pExprCtxt )
    {
    EXPR_CTXT           LeftCtxt( pExprCtxt );
    EXPR_CTXT           RightCtxt( pExprCtxt );

    if ( GetLeft() )
        {
        GetLeft()->ExprAnalyze( &LeftCtxt );
        pExprCtxt->MergeUpFlags( &LeftCtxt );
        SetConstant( IsConstant() && GetLeft()->IsConstant() );
        }
    else
        pExprCtxt->SetUpFlags( EX_VALUE_INVALID );

    if ( GetRight() )
        {
        GetRight()->ExprAnalyze( &RightCtxt );
        pExprCtxt->MergeUpFlags( &RightCtxt );
        SetConstant( IsConstant() && GetRight()->IsConstant() );

        // check here for div by zero ( could be var / 0 )
        if ( !RightCtxt.AnyUpFlags( EX_VALUE_INVALID ) &&
             ( GetOperator() == OP_SLASH ) &&
             ( RightCtxt.Value() == 0 ) )
            {
            SemError( pExprCtxt->GetNode(),
                      *(pExprCtxt->GetCtxt()),
                      EXPR_DIV_BY_ZERO,
                      NULL );
            pExprCtxt->SetUpFlags( EX_VALUE_INVALID );
            }
        }
    else
        pExprCtxt->SetUpFlags( EX_VALUE_INVALID );


    ////////////////////////////////////////////////////////////////////////
    // do type compatibility stuff

    switch ( GetOperator() )
        {
        case OP_PLUS:
        case OP_MINUS:
        case OP_STAR:
        case OP_MOD:
        // gaj - we implicitly assume signed types
        case OP_LEFT_SHIFT:
        case OP_RIGHT_SHIFT:
        case OP_AND:
        case OP_OR:
        case OP_XOR:
        case OP_SLASH:
            {
            // tbd - for now, just grab the bigger of the types
            if ( !RightCtxt.pType ||
                 (LeftCtxt.pType &&
                        (LeftCtxt.pType->GetSize() >= RightCtxt.pType->GetSize() ) ) )
                {
                pExprCtxt->pType = LeftCtxt.pType;
                pExprCtxt->TypeInfo = LeftCtxt.TypeInfo;
                pExprCtxt->fIntegral = LeftCtxt.fIntegral;
                SetType( pExprCtxt->pType );
                }
            else if ( RightCtxt.pType )
                {
                pExprCtxt->pType = RightCtxt.pType;
                pExprCtxt->TypeInfo = RightCtxt.TypeInfo;
                pExprCtxt->fIntegral = RightCtxt.fIntegral;
                SetType( pExprCtxt->pType );
                }

            break;
            }
        case OP_LOGICAL_AND:
        case OP_LOGICAL_OR:
        // gaj - we implicitly assume signed types
        case OP_LESS:
        case OP_LESS_EQUAL:
        case OP_GREATER_EQUAL:
        case OP_GREATER:
        case OP_EQUAL:
        case OP_NOT_EQUAL:
            {
            pExprCtxt->TypeInfo.TypeSize = SIZE_UNDEF;
            pExprCtxt->TypeInfo.BaseType = TYPE_BOOLEAN;
            pExprCtxt->TypeInfo.TypeSign = SIGN_UNDEF;
            GetBaseTypeNode( &(pExprCtxt->pType ), pExprCtxt->TypeInfo );

            pExprCtxt->fIntegral = TRUE;
            SetType( pExprCtxt->pType );
            break;
            }
        default:
            {
            break;
            }
        }


    ////////////////////////////////////////////////////////////////////////
    // compute the value

    if ( !pExprCtxt->AnyUpFlags( EX_VALUE_INVALID ) )
        {
        // update value directly from LeftCtxt and RightCtxt
        EXPR_VALUE  &       LeftValue   = LeftCtxt.Value();
        EXPR_VALUE  &       RightValue  = RightCtxt.Value();
        EXPR_VALUE  &       Result      = pExprCtxt->Value();

        switch ( GetOperator() )
            {
            case OP_PLUS:
                {
                Result = LeftValue + RightValue;
                break;
                }
            case OP_MINUS:
                {
                Result = LeftValue - RightValue;
                break;
                }
            case OP_STAR:
                {
                Result = LeftValue * RightValue;
                break;
                }
            case OP_SLASH:
                {
                if (RightValue == 0)
                    Result = 0;
                else
                    Result = LeftValue / RightValue;
                break;
                }
            case OP_MOD:
                {
                Result = LeftValue % RightValue;
                break;
                }
            case OP_LOGICAL_AND:
                {
                Result = LeftValue && RightValue;
                break;
                }
            case OP_LOGICAL_OR:
                {
                Result = LeftValue || RightValue;
                break;
                }
            // gaj - we implicitly assume signed types
            case OP_LESS:
                {
                Result = LeftValue < RightValue;
                break;
                }
            case OP_LESS_EQUAL:
                {
                Result = LeftValue <= RightValue;
                break;
                }
            case OP_GREATER_EQUAL:
                {
                Result = LeftValue >= RightValue;
                break;
                }
            case OP_GREATER:
                {
                Result = LeftValue > RightValue;
                break;
                }
            case OP_EQUAL:
                {
                Result = LeftValue == RightValue;
                break;
                }
            case OP_NOT_EQUAL:
                {
                Result = LeftValue != RightValue;
                break;
                }
            // gaj - we implicitly assume signed types
            case OP_LEFT_SHIFT:
                {
                Result = LeftValue << RightValue;
                break;
                }
            case OP_RIGHT_SHIFT:
                {
                Result = LeftValue >> RightValue;
                break;
                }
            case OP_AND:
                {
                Result = LeftValue & RightValue;
                break;
                }
            case OP_OR:
                {
                Result = LeftValue | RightValue;
                break;
                }
            case OP_XOR:
                {
                Result = LeftValue ^ RightValue;
                break;
                }
            default:
                {
                Result = 0;
                break;
                }
            }

        }

    }

//
// determine the type of the expression
//

void
expr_ternary::DetermineType()
{
    node_skl    *   pLeftType   = NULL;
    node_skl    *   pRightType  = NULL;


    if ( GetLeft() )
        pLeftType   = GetLeft()->AlwaysGetType();
    if ( GetRight() )
        pRightType  = GetRight()->AlwaysGetType();

    SetConstant( GetRight()->IsConstant() && GetLeft()->IsConstant() );

    if ( pLeftType )
        SetType( pLeftType );
    else if ( pRightType )
        SetType( pRightType );

}

void
expr_ternary::ExprAnalyze( EXPR_CTXT * pExprCtxt )
    {
    EXPR_CTXT           LeftCtxt( pExprCtxt );
    EXPR_CTXT           RightCtxt( pExprCtxt );
    EXPR_CTXT           RelCtxt( pExprCtxt );

    if ( GetLeft() )
        {
        GetLeft()->ExprAnalyze( &LeftCtxt );
        pExprCtxt->MergeUpFlags( &LeftCtxt );
        SetConstant( IsConstant() && GetLeft()->IsConstant() );
        }
    else
        pExprCtxt->SetUpFlags( EX_VALUE_INVALID );

    if ( GetRight() )
        {
        GetRight()->ExprAnalyze( &RightCtxt );
        pExprCtxt->MergeUpFlags( &RightCtxt );
        SetConstant( IsConstant() && GetRight()->IsConstant() );
        }
    else
        pExprCtxt->SetUpFlags( EX_VALUE_INVALID );

    if ( GetRelational() )
        {
        GetRelational()->ExprAnalyze( &RelCtxt );
        pExprCtxt->MergeUpFlags( &RelCtxt );
        SetConstant( IsConstant() && GetRelational()->IsConstant() );
        }
    else
        pExprCtxt->SetUpFlags( EX_VALUE_INVALID );


    // tbd - get the type from the left or right of the ':'
    if ( LeftCtxt.pType )
        {
        pExprCtxt->pType = LeftCtxt.pType;
        pExprCtxt->TypeInfo = LeftCtxt.TypeInfo;
        pExprCtxt->fIntegral = LeftCtxt.fIntegral;
        SetType( pExprCtxt->pType );
        }
    else if ( RightCtxt.pType )
        {
        pExprCtxt->pType = RightCtxt.pType;
        pExprCtxt->TypeInfo = RightCtxt.TypeInfo;
        pExprCtxt->fIntegral = RightCtxt.fIntegral;
        SetType( pExprCtxt->pType );
        }
    else
        SetType( NULL );

    ////////////////////////////////////////////////////////////////////////
    // compute the value

    if ( !pExprCtxt->AnyUpFlags( EX_VALUE_INVALID ) )
        {
        // update value directly from LeftCtxt and RightCtxt
        EXPR_VALUE  &       LeftValue   = LeftCtxt.Value();
        EXPR_VALUE  &       RightValue  = RightCtxt.Value();
        EXPR_VALUE  &       RelValue    = RelCtxt.Value();
        EXPR_VALUE  &       Result      = pExprCtxt->Value();

        Result = (RelValue) ? LeftValue : RightValue;

        }

    }

//
// determine the type of the expression
//

void
expr_variable::DetermineType()
{
    if ( pType->NodeKind() == NODE_FORWARD )
        {
        node_forward *  pFwd = (node_forward *) pType;
        // (permanently) resolve the forward
        pType = pFwd->ResolveFDecl();

        // This appears to be a better fix for the problem of unresolved
        // variables in async size expressions than the NULL type pointer check
        // in Fixup[Begin|Finish]ProcExpr in front\copyto.cxx.  However, at this
        // time we don't fully understand the implications of this change while
        // the other is localized to the async_uuid interfaces only.
        // e.g. ([in] long size, [in, size_is(huh)] long *p)
        // 03-May-99 MikeW
/*
        // if it couldn't be resolved, put back the forward
        if ( !pType )
            {
            pType = pFwd;
            }
*/
        }
}

void
expr_variable::ExprAnalyze( EXPR_CTXT * pExprCtxt )
    {
    pExprCtxt->SetUpFlags( EX_VALUE_INVALID );
    pExprCtxt->SetUpFlags( EX_NON_NUMERIC );

    if ( !pType )
        {
        pExprCtxt->SetUpFlags( EX_UNSAT_FWD );
        return;
        }

    if ( pType->NodeKind() == NODE_FORWARD )
        {
        node_forward *  pFwd = (node_forward *) pType;
        // (permanently) resolve the forward
        pType = pFwd->ResolveFDecl();
        // if it couldn't be resolved, put back the forward
        if ( !pType )
            {
            pExprCtxt->SetUpFlags( EX_UNSAT_FWD );
            pExprCtxt->TypeInfo.TypeSize = SIZE_UNDEF;
            pExprCtxt->TypeInfo.BaseType = TYPE_INT;
            pExprCtxt->TypeInfo.TypeSign = SIGN_SIGNED;
            GetBaseTypeNode( &pType, pExprCtxt->TypeInfo);
            pExprCtxt->pType = pType;
            return;
            }
        }

    // do type compatibility stuff
    pExprCtxt->pType = pType;
    pExprCtxt->TypeInfo.TypeSize = SIZE_UNDEF;
    pExprCtxt->TypeInfo.BaseType = TYPE_UNDEF;
    pExprCtxt->TypeInfo.TypeSign = SIGN_UNDEF;
    pExprCtxt->fIntegral = FALSE; // for now...

    if ( ( pType->NodeKind() == NODE_PARAM ) &&
          pType->FInSummary( ATTR_OUT ) &&
         !pType->FInSummary( ATTR_IN ) )
        pExprCtxt->SetUpFlags( EX_OUT_ONLY_PARAM );

    }

//
// determine the type of the expression
//

void
expr_named_constant::DetermineType()
{
    // do type compatibility stuff
    if ( !GetType() )
        {
        SetType( GetExpr()->AlwaysGetType() );
        }

}

void
expr_named_constant::ExprAnalyze( EXPR_CTXT * pExprCtxt )
    {
    // named constants shouldn't be folded away
    pExprCtxt->SetUpFlags( EX_NON_NUMERIC );

    // update value
    pExprCtxt->Value() = GetValue();

    // do type compatibility stuff
    if ( GetType() )
        {
        pExprCtxt->pType = GetType();
        pExprCtxt->TypeInfo.TypeSize = SIZE_UNDEF;
        pExprCtxt->TypeInfo.BaseType = TYPE_UNDEF;
        pExprCtxt->TypeInfo.TypeSign = SIGN_UNDEF;
        pExprCtxt->fIntegral = FALSE; // for now...
        }
    else
        {
        EXPR_CTXT       LeftCtxt( pExprCtxt );
        expr_node   *   pExpr   = GetExpr();

        pExpr->ExprAnalyze( &LeftCtxt );

        pExprCtxt->pType = LeftCtxt.pType;
        pExprCtxt->TypeInfo = LeftCtxt.TypeInfo;
        pExprCtxt->fIntegral = LeftCtxt.fIntegral;
        SetType( pExprCtxt->pType );
        }


    }

//
// determine the type of the expression
//

void
expr_constant::DetermineType()
{
    node_skl* pNewType = 0;

    // do type compatibility stuff
    if ( GetType() )
        return;

    // do type compatibility stuff
    switch (Format)
        {
        case VALUE_TYPE_STRING:
            {
            node_skl    *   pBottomType;
            GetBaseTypeNode( &pBottomType,
                             SIGN_SIGNED,
                             SIZE_CHAR,
                             TYPE_INT );
            pNewType = new node_pointer;
            pNewType->SetChild( pBottomType );
            break;
            }
        case VALUE_TYPE_WSTRING:
            {
            node_skl    *   pBottomType;
            SymKey  SKey( "wchar_t", NAME_DEF );

            pBottomType = pBaseSymTbl->SymSearch( SKey );
            pNewType = new node_pointer;
            pNewType->SetChild( pBottomType );
            break;
            }
        case VALUE_TYPE_CHAR:
            {
            GetBaseTypeNode( &pNewType,
                             SIGN_SIGNED,
                             SIZE_CHAR,
                             TYPE_INT );
            break;
            }
        case VALUE_TYPE_WCHAR:
            {
            SymKey  SKey( "wchar_t", NAME_DEF );

            pNewType    = pBaseSymTbl->SymSearch( SKey );
            break;
            }
        case VALUE_TYPE_NUMERIC:
        case VALUE_TYPE_HEX:
        case VALUE_TYPE_OCTAL:
            {
            GetBaseTypeNode( &pNewType,
                             SIGN_SIGNED,
                             SIZE_UNDEF,
                             TYPE_INT );
            break;
            }
        case VALUE_TYPE_NUMERIC_U:
        case VALUE_TYPE_HEX_U:
        case VALUE_TYPE_OCTAL_U:
            {
            GetBaseTypeNode( &pNewType,
                             SIGN_UNSIGNED,
                             SIZE_SHORT,
                             TYPE_INT );
            break;
            }

        case VALUE_TYPE_NUMERIC_LONG:
        case VALUE_TYPE_HEX_LONG:
        case VALUE_TYPE_OCTAL_LONG:
            {
            GetBaseTypeNode( &pNewType,
                             SIGN_SIGNED,
                             SIZE_LONG,
                             TYPE_INT );
            break;
            }

        case VALUE_TYPE_NUMERIC_ULONG:
        case VALUE_TYPE_HEX_ULONG:
        case VALUE_TYPE_OCTAL_ULONG:
            {
            GetBaseTypeNode( &pNewType,
                             SIGN_UNSIGNED,
                             SIZE_LONG,
                             TYPE_INT );
            break;
            }

        case VALUE_TYPE_BOOL:
            {
            GetBaseTypeNode( &pNewType,
                             SIGN_UNDEF,
                             SIZE_UNDEF,
                             TYPE_BOOLEAN );
            break;
            }

        case VALUE_TYPE_FLOAT:
            {
            GetBaseTypeNode( &pNewType,
                             SIGN_UNDEF,
                             SIZE_UNDEF,
                             TYPE_FLOAT );
            break;
            }
        case VALUE_TYPE_DOUBLE:
            {
            GetBaseTypeNode( &pNewType,
                             SIGN_UNDEF,
                             SIZE_UNDEF,
                             TYPE_DOUBLE );
            break;
            }

        default:
            break;
        }
    SetType( pNewType );
}

void
expr_constant::ExprAnalyze( EXPR_CTXT * pExprCtxt )
    {

    // update value
    pExprCtxt->Value() = GetValue();

    if ( GetType() )
        {
        pExprCtxt->pType = GetType();
        pExprCtxt->TypeInfo.TypeSize = SIZE_UNDEF;
        pExprCtxt->TypeInfo.BaseType = TYPE_UNDEF;
        pExprCtxt->TypeInfo.TypeSign = SIGN_UNDEF;
        pExprCtxt->fIntegral = FALSE; // for now...
        return;
        }

    // do type compatibility stuff
    switch (Format)
        {
        case VALUE_TYPE_STRING:
            {
            node_skl    *   pBottomType;
            GetBaseTypeNode( &pBottomType,
                             SIGN_SIGNED,
                             SIZE_CHAR,
                             TYPE_INT );
            pExprCtxt->pType = new node_pointer;
            pExprCtxt->pType->SetChild( pBottomType );
            break;
            }
        case VALUE_TYPE_WSTRING:
            {
            node_skl    *   pBottomType;
            SymKey  SKey( "wchar_t", NAME_DEF );

            pBottomType = pBaseSymTbl->SymSearch( SKey );
            pExprCtxt->pType = new node_pointer;
            pExprCtxt->pType->SetChild( pBottomType );
            break;
            }
        case VALUE_TYPE_CHAR:
            {
            GetBaseTypeNode( &pExprCtxt->pType,
                             SIGN_SIGNED,
                             SIZE_CHAR,
                             TYPE_INT );
            break;
            }
        case VALUE_TYPE_WCHAR:
            {
            SymKey  SKey( "wchar_t", NAME_DEF );

            pExprCtxt->pType    = pBaseSymTbl->SymSearch( SKey );
            break;
            }
        case VALUE_TYPE_NUMERIC:
        case VALUE_TYPE_HEX:
        case VALUE_TYPE_OCTAL:
            {
            short   RealSize    = SIZE_HYPER;
            __int64 val         = GetValue();

            if ( (val <= 127) && (val >= -128 ) )
                RealSize = SIZE_CHAR;
            else if ( (val <= _I16_MAX) && (val >= _I16_MIN ) )
                RealSize = SIZE_SHORT;
            else if ( (val <= _I32_MAX) && (val >= _I32_MIN ) )
                RealSize = SIZE_LONG;

            GetBaseTypeNode( &pExprCtxt->pType,
                             SIGN_SIGNED,
                             RealSize,
                             TYPE_INT );
            break;
            }
        case VALUE_TYPE_NUMERIC_U:
        case VALUE_TYPE_HEX_U:
        case VALUE_TYPE_OCTAL_U:
            {
            short RealSize      = SIZE_LONG;
            unsigned long  val  = (unsigned long) GetValue();

            if ( val <= 255 )
                RealSize = SIZE_CHAR;
            else if ( val <= 65536 )
                RealSize = SIZE_SHORT;

            GetBaseTypeNode( &pExprCtxt->pType,
                             SIGN_UNSIGNED,
                             RealSize,
                             TYPE_INT );
            break;
            }

        case VALUE_TYPE_NUMERIC_LONG:
        case VALUE_TYPE_HEX_LONG:
        case VALUE_TYPE_OCTAL_LONG:
            {
            GetBaseTypeNode( &pExprCtxt->pType,
                             SIGN_SIGNED,
                             SIZE_LONG,
                             TYPE_INT );
            break;
            }

        case VALUE_TYPE_NUMERIC_ULONG:
        case VALUE_TYPE_HEX_ULONG:
        case VALUE_TYPE_OCTAL_ULONG:
            {
            GetBaseTypeNode( &pExprCtxt->pType,
                             SIGN_UNSIGNED,
                             SIZE_LONG,
                             TYPE_INT );
            break;
            }

        case VALUE_TYPE_BOOL:
            {
            GetBaseTypeNode( &pExprCtxt->pType,
                             SIGN_UNDEF,
                             SIZE_UNDEF,
                             TYPE_BOOLEAN );
            break;
            }

        case VALUE_TYPE_FLOAT:
            {
            GetBaseTypeNode( &pExprCtxt->pType,
                             SIGN_UNDEF,
                             SIZE_UNDEF,
                             TYPE_FLOAT );
            break;
            }
        case VALUE_TYPE_DOUBLE:
            {
            GetBaseTypeNode( &pExprCtxt->pType,
                             SIGN_UNDEF,
                             SIZE_UNDEF,
                             TYPE_DOUBLE );
            break;
            }

        default:
            break;
        }
    SetType( pExprCtxt->pType );
    }

//
// determine the type of the expression
//

void
expr_init_list::DetermineType()
{
    SetType( pExpr->AlwaysGetType() );
}

void
expr_init_list::ExprAnalyze( EXPR_CTXT * pExprCtxt )
    {

    // tbd - for now only process first element
    pExpr->ExprAnalyze( pExprCtxt );
    SetConstant( pExpr->IsConstant() );
    SetType( pExpr->GetType() );

    }

short
expr_op_binary::MakeListOfDerefedVars( ITERATOR& List )
    {
    if( GetLeft() )
        GetLeft()->MakeListOfDerefedVars( List );

    if( GetRight() )
        GetRight()->MakeListOfDerefedVars( List );
    return (short) ITERATOR_GETCOUNT( List );
    }

short
expr_u_deref::MakeListOfDerefedVars( ITERATOR& List )
    {
    expr_node * pLeft = GetLeft();

    if( !pLeft ) return 0;

    if( pLeft->IsAVariable() )
        ITERATOR_INSERT( List, pLeft );
    else if( pLeft->GetOperator() == OP_UNARY_INDIRECTION )
        pLeft->MakeListOfDerefedVars( List );

    return ITERATOR_GETCOUNT( List );
    }

BOOL
expr_b_arithmetic::GetExprValue( SExprValue& v )
    {
    SExprValue  LeftValue  = {VALUE_TYPE_UNDEFINED, 0};
    SExprValue  RightValue = {VALUE_TYPE_UNDEFINED, 0};
    BOOL        fSuccess;

    fSuccess =  GetLeft()->GetExprValue( LeftValue ) &&
                GetRight()->GetExprValue( RightValue ) &&
                (LeftValue.format == VALUE_TYPE_DOUBLE || LeftValue.format == VALUE_TYPE_DOUBLE) && 
                (RightValue.format == VALUE_TYPE_DOUBLE || RightValue.format == VALUE_TYPE_DOUBLE);

    if (fSuccess)
        {
        v.format = LeftValue.format == VALUE_TYPE_DOUBLE || RightValue.format == VALUE_TYPE_DOUBLE ?
                    VALUE_TYPE_DOUBLE : VALUE_TYPE_FLOAT ;
        double l = LeftValue.format == VALUE_TYPE_DOUBLE ? LeftValue.d : LeftValue.f ;
        double r = RightValue.format == VALUE_TYPE_DOUBLE ? RightValue.d : RightValue.f ;
    
        switch ( GetOperator() )
            {
            case OP_PLUS:
                l += r;
                break;
            case OP_MINUS:
                l -= r;
                break;
            case OP_STAR:
                l *= r;
                break;
            case OP_SLASH:
                __try 
                    {
                    l /= r;
                    }
                __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                    fSuccess = FALSE;
                    }
                break;
            }
        if (v.format == VALUE_TYPE_FLOAT)
            {
            v.f = (float) l;
            }
        else if (v.format == VALUE_TYPE_DOUBLE)
            {
            v.d = l;
            }
        }
    return fSuccess;
    }

BOOL
expr_u_arithmetic::GetExprValue( SExprValue& v )
{
    SExprValue  LeftValue = {VALUE_TYPE_UNDEFINED, 0};
    BOOL        fSuccess  = GetLeft()->GetExprValue( LeftValue );

    if (fSuccess)
        {
        v = LeftValue;
        if (GetOperator() == OP_UNARY_MINUS)
            {
            switch ( v.format )
                {
                case VALUE_TYPE_FLOAT:
                    v.f = -LeftValue.f;
                    break;
                case VALUE_TYPE_DOUBLE:
                    v.d = -LeftValue.d;
                    break;
                default:
                    fSuccess = FALSE;
                    break;
                }
            }
        }
    return fSuccess;
}

void
expr_node::CopyTo( expr_node* lhs )
    {
    DetermineType();
    lhs->pType       = pType;
    lhs->fFloatExpr  = fFloatExpr;
    lhs->fConstant   = fConstant;
    }

void
expr_constant::CopyTo( expr_node* pExpr )
    {
    expr_constant* lhs = (expr_constant*) pExpr;
    expr_node::CopyTo( lhs );
    lhs->Format = Format;
    lhs->Value  = Value;
    }

void
expr_init_list::CopyTo( expr_node* pExpr )
    {
    expr_init_list* lhs = (expr_init_list*) pExpr;
    expr_node::CopyTo( lhs );
    lhs->pSibling = (expr_init_list*)pSibling->Clone();
    pSibling->CopyTo(lhs->pSibling);
    lhs->pExpr = pExpr->Clone();
    pExpr->CopyTo(lhs->pExpr);
    }

void
expr_operator::CopyTo( expr_node* pExpr )
    {
    expr_operator* lhs = (expr_operator*) pExpr;
    expr_node::CopyTo( lhs );
    lhs->Operator = Operator;
    }

void
expr_op_binary::CopyTo( expr_node* pExpr )
    {
    expr_op_binary* lhs = (expr_op_binary*) pExpr;
    expr_operator::CopyTo( lhs );
    lhs->pLeft = pLeft->Clone();
    pLeft->CopyTo(lhs->pLeft);
    lhs->pRight = pRight->Clone();
    pRight->CopyTo(lhs->pRight);
    }

void
expr_param::CopyTo( expr_node* pExpr )
    {
    expr_param* lhs = (expr_param*) pExpr;
    expr_op_binary::CopyTo( lhs );
    _STRDUP( lhs->pName, pName );
    }

void
expr_op_unary::CopyTo( expr_node* pExpr )
    {
    expr_op_unary* lhs = (expr_op_unary*) pExpr;
    expr_operator::CopyTo( lhs );
    lhs->pLeft = pLeft->Clone();
    pLeft->CopyTo(lhs->pLeft);
    }

void
expr_cast::CopyTo( expr_node* pExpr )
    {
    expr_cast* lhs = (expr_cast*) pExpr;
    expr_op_unary::CopyTo( lhs );
    lhs->fEmitModifiers  = fEmitModifiers;
    lhs->pCastType       = pCastType;
    }

void
expr_proc_call::CopyTo( expr_node* pExpr )
    {
    expr_proc_call* lhs = (expr_proc_call*) pExpr;
    expr_op_unary::CopyTo( lhs );
    _STRDUP( lhs->pName, pName );
    lhs->NoOfParams = NoOfParams;
    }

void
expr_sizeof::CopyTo( expr_node* pExpr )
    {
    expr_sizeof* lhs = (expr_sizeof*) pExpr;
    expr_op_unary::CopyTo( lhs );
    lhs->pType = pType;
    }

void
expr_alignof::CopyTo( expr_node* pExpr )
    {
    expr_alignof* lhs = (expr_alignof*) pExpr;
    expr_op_unary::CopyTo( lhs );
    lhs->pType = pType;
    }

void
expr_ternary::CopyTo( expr_node* pExpr )
    {
    expr_ternary* lhs = (expr_ternary*) pExpr;
    expr_operator::CopyTo( lhs );
    lhs->pLeft = pLeft->Clone();
    pLeft->CopyTo(lhs->pLeft);
    lhs->pRight = pRight->Clone();
    pRight->CopyTo(lhs->pRight);
    lhs->pRelational = pRelational->Clone();
    pRelational->CopyTo(lhs->pRelational);
    }

void
expr_variable::CopyTo( expr_node* pExpr )
    {
    expr_variable* lhs = (expr_variable*) pExpr;
    expr_node::CopyTo( lhs );
    _STRDUP( lhs->pIDName, pIDName );
    _STRDUP( lhs->pPrefix, pPrefix );
    }

expr_node*
expr_ternary::Clone()
    {
    return new expr_ternary(OP_ILLEGAL,0,0,0);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\driver\ppcmd.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    ppcmd.cxx

 Abstract:

    This file preprocesses the command line to check for response file
    input.

 Notes:

    This file extends the register args routine from the command analyser to
    incorporate the response files.

 Author:

    vibhasc 03-16-91 Created to conform to coding guidelines.
    NishadM 02-03-97 rewrite to simplify, allow DBCS, remove bugs

 ----------------------------------------------------------------------------*/

#if 0
                            Notes
                            -----
    We want to make implementations of the response file completely transparent 
    to the rest of the compiler. The response file is specified to midl using 
    the syntax:

        midl <some switches> @full response file path name <more switches>.

    We dont want to restrict the user from specifyin the response file at any
    place in the command line, any number of times. At the same time we do not
    want the command analyser to even bother about the response file, to keep
    implementation very localised. In order to do that, we do a preprocessing
    on the command line to look for the response file command. 

    The command analyser expects the arguments in an argv like array. The 
    preprocessor will creates this array, expanding all response file commands
    into this array, so that the command analyser does not even notice the 
    difference. 

    We use our fancy dynamic array implementation to create this argv-like
    array.

    Things to keep in mind:

    1. The response file needs to be parsed.
    2. Each option must be completely specified in a command line. i.e
       the option cannot be continued in a separate line using the continuation
       character or anything.
    3. Each switch must be presented just the same way that the os command 
       processor does. We need to analyse the string for escaped '"'

#endif // 0

#pragma warning ( disable : 4514 )

/*****************************************************************************
            local defines and includes
 *****************************************************************************/

#include "nulldefs.h"
extern  "C" {
    #include <stdio.h>
    #include <string.h>
    #include <ctype.h>
}
#include "common.hxx"
#include "errors.hxx"
#include "idict.hxx"

extern BOOL                     fNoLogo;
extern void                     RpcError( char *, short, STATUS_T, char *);

bool
AnalyseResponseFile (
                    char*   p,
                    IDICT*  pIDict
                    );
char *
ParseResponseFile   (
                    FILE*           h,
                    unsigned int    uLineNumber,
                    char*           szFilename
                    );

/*****************************************************************************/

bool
PPCmdEngine(
    int         argc,
    char    *   argv[],
    IDICT   *   pIDict )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    command preprocessor engine.

 Arguments:

    argc    - count of the number of arguments
    argv    - vector of arguments to the program
    pIDict  - dictionary of arguments to be returned.

 Return Value:

    Pointer to an indexed dictionary (actually a dynamic array ), containing
    the entire set of arguments, including the ones from the response file.

 Notes:

    Go thru each of the arguments. If you find a response file switch, pick up
    the arguments from the response file and add to the argument list.

----------------------------------------------------------------------------*/
    {
    int         iArg;
    char    *   p,
            *   q;

    bool        fNoLogo = false;

    for( iArg = 0; iArg < argc ; ++iArg )
        {
        p   = argv[ iArg ];

        switch( *p )
            {
            case '@':
                fNoLogo |= AnalyseResponseFile( p, pIDict );
                break;
            case '/':
            case '-':
                // detect /nologo early in the cmd parse
                if ( !strcmp( p+1, "nologo" ) )
                    fNoLogo = true;
                // fall through
            default:
                q   = new char[ strlen( p ) + 1 ];
                strcpy( q, p );
                pIDict->AddElement( (IDICTELEMENT) q );
                break;
            }
        }
    return !fNoLogo;
    }

bool
AnalyseResponseFile (
                    char*   p,
                    IDICT*  pIDict
                    )
{
    FILE*   pResponseFile;
    bool    fNoLogo = false;
    
    // try to open the response file.
    // ++p to skip '@' preceding the filename.
    if ( ( pResponseFile = fopen( ++p, "r") ) == (FILE *)NULL )
        {
        RpcError( (char *)0, 1, CANNOT_OPEN_RESP_FILE, p );
        }
    else
        {
        char*           szArg = 0;
        unsigned int    uLineNumber = 1;

        // the response file successfully opened. parse it.
        while ( ( szArg = ParseResponseFile(
                                            pResponseFile,
                                            uLineNumber,
                                            p
                                            ) ) != 0 )
            {
            if ( 0 == strcmp(szArg, "-nologo")
                 || 0 == strcmp(szArg, "/nologo") )
                {
                fNoLogo = true;
                }

            pIDict->AddElement( szArg );
            }

        fclose( pResponseFile );
        }

    return fNoLogo;
}

char *
ParseResponseFile   (
                    FILE*           h,
                    unsigned int    uLineNumber,
                    char*           szFilename
                    )
{
    char    szTempArg[1024];
    char*   p  = szTempArg;
    int     ch = 0;

    // initialize pTempArg
    *p = 0;

    // remove all the leading spaces
    do
        {
        ch = fgetc( h );
        if ( ch == '\n' )
            {
            uLineNumber++;
            }
        }
    while ( isspace( ch ) );

    if ( ch == '"' )
        {
        // if the argument is within quotes,
        // all chars including spaces make up the
        // argument. The quote is treated as a delimiter
        do
            {
            ch = fgetc( h );
            *p++ = (char) ch;
            if ( ch == '\\' )
                {
                // double back slash is interpreted as one.
                ch = fgetc( h );
                *p++ = (char) ch;
                if ( ch == '\\' )
                    {
                    p--;
                    }
                }
            else if ( ch == '\n' )
                {
                uLineNumber++;
                }
            }
        while ( ch != '"' && ch != EOF );
        *(p - 1) = 0;
        }
    else if ( ch == '@' )
        {
        // first char of the argument is a '@'
        // this means a response file with a response
        // file. Flag an error.
        RpcError( szFilename,
                  (short)uLineNumber,
                  NESTED_RESP_FILE,
                  (char *)0 );
        }
    else if ( ch != EOF )
        {
        // if the argument is not with in quotes,
        // white spaces are delimiters.
        *p++ = (char)ch;
        do
            {
            ch = fgetc( h );
            *p++ = (char)ch;
            if ( ch == '\n' )
                {
                uLineNumber++;
                }
            }
        while ( !isspace( ch ) && ch != EOF );
        *(p - 1) = 0;
        }

    size_t  nSize = strlen( szTempArg );
    char*   szRet = 0;

    if ( nSize != 0 )
        {
        szRet = new char[nSize+1];
        if ( szRet != 0 )
            {
            strcpy( szRet, szTempArg );
            }
        }
    return szRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\expr\exprpr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	exprpr.cxx

 Abstract:

	expression evaluator print routines implementation.

 Notes:


 History:

 	VibhasC		Aug-05-1993		Created

 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 )

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "nulldefs.h"

extern "C"
	{
	#include <stdio.h>
	
	#include <string.h>
	}

#include "expr.hxx"
#include "nodeskl.hxx"

/****************************************************************************
 *	extern definitions
 ***************************************************************************/

extern char * OperatorToString( OPERATOR Op );

/***************************************************************************/

void
expr_node::PrintWithPrefix(
    ISTREAM *   pStream,
    char *      pPrefix )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    This routine prints an expression adding a prefix to each of the varaibles
    within the expression.

 Arguments:

 	pStream		- A pointer to the stream to output to.
    pPrefix     - the prefix to be prepended to each variable
	
 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR  VarList;
    expr_variable * pVarNode = 0;

    short VarCount = MakeListOfVars( VarList );
    if ( VarCount )
        {

        VarList.Init();
        while ( ITERATOR_GETNEXT( VarList, pVarNode ) )
            pVarNode->SetPrefix( pPrefix );
        }

    Print( pStream );

    if ( VarCount )
        {
        VarList.Init();
        while ( ITERATOR_GETNEXT( VarList, pVarNode ) )
            pVarNode->SetPrefix( NULL );
        }
}



/*
//  table of precedences ( lower number => lower precedence )
 200	[] () . -> ()++ ()--
 190	++() --() sizeof() & *(deref) +() -() ~() !()
 180	(cast)
 170	* / %
 160	+ -
 150	<< >>
 140	< > <= >=
 130	== !=
 120	& (bitwise)
 110	^
 100	|
 90		&&
 80		||
 70		?:
 60		= *= /= %= += -= <<= >>= &= |= ^=
 50		, (seqential eval)
 0		all other operators (should be none)
 */

const short Prec[] =
	{
	0	// OP_ILLEGAL = OP_START

	// OP_UNARY_START

	// OP_UNARY_ARITHMETIC_START	= OP_UNARY_START
	,190	// OP_UNARY_PLUS 				= OP_UNARY_ARITHMETIC_START
	,190	// OP_UNARY_MINUS
	// OP_UNARY_ARITHMETIC_END

	// OP_UNARY_LOGICAL_START		= OP_UNARY_ARITHMETIC_END
	,190	// OP_UNARY_NOT				= OP_UNARY_LOGICAL_START
	,190	// OP_UNARY_COMPLEMENT
	// OP_UNARY_LOGICAL_END

	,190	// OP_UNARY_INDIRECTION		= OP_UNARY_LOGICAL_END
	,180	// OP_UNARY_CAST
	,190	// OP_UNARY_AND
	,190	// OP_UNARY_SIZEOF
        ,190    // OP_UNARY_ALIGNOF
	,190	// OP_PRE_INCR
	,190	// OP_PRE_DECR
	,200	// OP_POST_INCR
	,200	// OP_POST_DECR

	// OP_UNARY_END

	// OP_BINARY_START			= OP_UNARY_END

	// OP_BINARY_ARITHMETIC_START	= OP_BINARY_START
	,160	// OP_PLUS					= OP_BINARY_ARITHMETIC_START
	,160	// OP_MINUS
	,170	// OP_STAR
	,170	// OP_SLASH
	,170	// OP_MOD
	// OP_BINARY_ARITHMETIC_END

	// OP_BINARY_SHIFT_START		= OP_BINARY_ARITHMETIC_END
	,150	// OP_LEFT_SHIFT				= OP_BINARY_SHIFT_START
	,150	// OP_RIGHT_SHIFT
	// OP_BINARY_SHIFT_END

	// OP_BINARY_RELATIONAL_START	= OP_BINARY_SHIFT_END
	,140	// OP_LESS					= OP_BINARY_RELATIONAL_START
	,140	// OP_LESS_EQUAL
	,140	// OP_GREATER_EQUAL
	,140	// OP_GREATER
	,130	// OP_EQUAL
	,130	// OP_NOT_EQUAL
	// OP_BINARY_RELATIONAL_END

	// OP_BINARY_BITWISE_START	= OP_BINARY_RELATIONAL_END
	,120	// OP_AND						= OP_BINARY_BITWISE_START
	,100	// OP_OR
	,110	// OP_XOR
	// OP_BINARY_BITWISE_END

	// OP_BINARY_LOGICAL_START	= OP_BINARY_BITWISE_END
	,90		// OP_LOGICAL_AND				= OP_BINARY_LOGICAL_START
	,80		// OP_LOGICAL_OR
	// OP_BINARY_LOGICAL_END

	// OP_BINARY_TERNARY_START	= OP_BINARY_LOGICAL_END
	,70		// OP_QM						= OP_BINARY_TERNARY_START
	,70		// OP_COLON
	// OP_BINARY_TERNARY_END

	// OP_BINARY_END				= OP_BINARY_TERNARY_END

	,0		// OP_INTERNAL_START			= OP_BINARY_END
	,200	// OP_FUNCTION
	,0		// OP_PARAM

	,200	// OP_POINTSTO
	,200	// OP_DOT
	,200	// OP_INDEX
	,50		// OP_COMMA
	,0		// OP_STMT
	,60		// OP_ASSIGN
	
	,0		// OP_END
	};


/*
//  table of associativity ( -1 => L to R, 1 => R to L )
 -1	[] () . -> ()++ ()--
 1	++() --() sizeof() & *(deref) +() -() ~() !()
 1	(cast)
 -1	* / %
 -1	+ -
 -1	<< >>
 -1	< > <= >=
 -1	== !=
 -1	& (bitwise)
 -1	^
 -1	|
 -1		&&
 -1		||
 1		?:
 1		= *= /= %= += -= <<= >>= &= |= ^=
 -1		, (seqential eval)
 0		all other operators (should be none)
 */

const short AssocTbl[] =
	{
	0	// OP_ILLEGAL = OP_START

	// OP_UNARY_START

	// OP_UNARY_ARITHMETIC_START	= OP_UNARY_START
	,-1	// OP_UNARY_PLUS 				= OP_UNARY_ARITHMETIC_START
	,-1	// OP_UNARY_MINUS
	// OP_UNARY_ARITHMETIC_END

	// OP_UNARY_LOGICAL_START		= OP_UNARY_ARITHMETIC_END
	,1	// OP_UNARY_NOT				= OP_UNARY_LOGICAL_START
	,1	// OP_UNARY_COMPLEMENT
	// OP_UNARY_LOGICAL_END

	,1	// OP_UNARY_INDIRECTION		= OP_UNARY_LOGICAL_END
	,1	// OP_UNARY_CAST
	,1	// OP_UNARY_AND
	,1	// OP_UNARY_SIZEOF
        ,1      // OP_UNARY_ALIGNOF
	,1	// OP_PRE_INCR
	,1	// OP_PRE_DECR
	,-1	// OP_POST_INCR
	,-1	// OP_POST_DECR

	// OP_UNARY_END

	// OP_BINARY_START			= OP_UNARY_END

	// OP_BINARY_ARITHMETIC_START	= OP_BINARY_START
	,-1	// OP_PLUS					= OP_BINARY_ARITHMETIC_START
	,-1	// OP_MINUS
	,-1	// OP_STAR
	,-1	// OP_SLASH
	,-1	// OP_MOD
	// OP_BINARY_ARITHMETIC_END

	// OP_BINARY_SHIFT_START		= OP_BINARY_ARITHMETIC_END
	,-1	// OP_LEFT_SHIFT				= OP_BINARY_SHIFT_START
	,-1	// OP_RIGHT_SHIFT
	// OP_BINARY_SHIFT_END

	// OP_BINARY_RELATIONAL_START	= OP_BINARY_SHIFT_END
	,-1	// OP_LESS					= OP_BINARY_RELATIONAL_START
	,-1	// OP_LESS_EQUAL
	,-1	// OP_GREATER_EQUAL
	,-1	// OP_GREATER
	,-1	// OP_EQUAL
	,-1	// OP_NOT_EQUAL
	// OP_BINARY_RELATIONAL_END

	// OP_BINARY_BITWISE_START	= OP_BINARY_RELATIONAL_END
	,-1	// OP_AND						= OP_BINARY_BITWISE_START
	,-1	// OP_OR
	,-1	// OP_XOR
	// OP_BINARY_BITWISE_END

	// OP_BINARY_LOGICAL_START	= OP_BINARY_BITWISE_END
	,-1		// OP_LOGICAL_AND				= OP_BINARY_LOGICAL_START
	,-1		// OP_LOGICAL_OR
	// OP_BINARY_LOGICAL_END

	// OP_BINARY_TERNARY_START	= OP_BINARY_LOGICAL_END
	,1		// OP_QM						= OP_BINARY_TERNARY_START
	,1		// OP_COLON
	// OP_BINARY_TERNARY_END

	// OP_BINARY_END				= OP_BINARY_TERNARY_END

	,0		// OP_INTERNAL_START			= OP_BINARY_END
	,0		// OP_FUNCTION
	,0		// OP_PARAM

	,-1	// OP_POINTSTO
	,-1	// OP_DOT
	,-1	// OP_INDEX
	,-1		// OP_COMMA
	,0		// OP_STMT
	,1		// OP_ASSIGN
	
	,0		// OP_END
	};

void
expr_operator::PrintSubExpr(
	expr_node	* pExpr,
	ISTREAM	*	pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Print a subexpression, optionally adding parens.

 Arguments:

	pExpr		- the expression to print
 	pStream		- A pointer to the stream to output to.
	
 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
	short	PrecMe		= Prec[ GetOperator() ];
	short	PrecChild;
	BOOL	fAddParens	= FALSE;
	
	if ( pExpr->IsOperator() )
		{
		PrecChild = Prec[ pExpr->GetOperator() ];
		// account for associativity
		if ( pExpr != GetLeft() )
			PrecChild = short( PrecChild + AssocTbl[ pExpr->GetOperator() ] );

		fAddParens = PrecChild < PrecMe;
		}
		
	if ( fAddParens )
		pStream->Write('(');

	pExpr->Print( pStream );

	if ( fAddParens )
		pStream->Write(')');

}


void
expr_variable::Print(
	ISTREAM	*	pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Print a variable name expression.

 Arguments:

 	pStream		- A pointer to the stream to output to.
	
 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
    if ( GetPrefix() )
    	pStream->Write( GetPrefix() );
	pStream->Write( GetName() );
}

char	*	ConstFormats[]	=
	{
	"\"%s\"",		// string
	"L\"%Ls\"",		// wstring
	"0x%x",			// char
	"L'%Lc'",		// wchar

	"%d",			// numeric
	"%uU",			// numeric unsigned
	"%ldL",			// numeric long
	"%luUL",		// numeric unsigned long

	"%#x",			// hex
	"%#xU",			// hex unsigned
	"%#lxL",		// hex long
	"%#lxUL",		// hex unsigned long

	"%#o",			// octal
	"%#oU",			// octal unsigned 
	"%#loL",		// octal long
	"%#loUL",		// octal unsigned long

	"%s",			// BOOL ( not used )

	"%g",			// float
	"%lg",			// double

// RKK64
// value types for int64

	};

void
expr_constant::Print(
	ISTREAM	*	pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit a constant expression to the stream.

 Arguments:
	
	pStream	- A pointer to the stream.

 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
	char Array[ 256 ];

    Array[0] = 0;
	if (Format == VALUE_TYPE_BOOL)
        {
		sprintf( Array, "%s", (Value.L) ? "TRUE" : "FALSE" );
        }
    else if ( Format == VALUE_TYPE_FLOAT )
        {
		sprintf( Array, ConstFormats[ Format] , Value.F );
        }
    else if ( Format == VALUE_TYPE_DOUBLE )
        {
		sprintf( Array, ConstFormats[ Format] , Value.D );
        }
    else if ( Format == VALUE_TYPE_CHAR )
        {
        if ( Value.C )
            {
            Array[0] = '0';
            Array[1] = 'x';
            char ch = ( char ) ( ( Value.C >> 4 ) & 0xF );
            Array[2] = ( char ) ( ( ch >= 0 && ch <= 9 ) ? ch + '0' : ch + 'A' - 0xA );
            ch = ( char ) ( Value.C & 0xF );
            Array[3] = ( char ) ( ( ch >= 0 && ch <= 9 ) ? ch + '0' : ch + 'A' - 0xA );
            Array[4] = 0;
            }
        else
            {
            Array[0] = '0';
            Array[1] = 0;
            }
        }
    else if ( Format == VALUE_TYPE_STRING )
        {
        if (Value.pC) 
            {
	        pStream->Write( "\"" );
	        pStream->Write( ( char* ) Value.pC );
	        pStream->Write( "\"" );
            }
        else
            {
	        pStream->Write( "0" );
            }
        }
    else if ( Format == VALUE_TYPE_WSTRING )
        {
        if (Value.pWC) 
            {
	        pStream->Write( "L\"" );
	        pStream->Write( ( char* ) Value.pWC );
	        pStream->Write( "\"" );
            }
        else
            {
	        pStream->Write( "0" );
            }
        }
	else
        {
		sprintf( Array, ConstFormats[ Format] , Value.I64 );
        }
	pStream->Write( (char *)Array );
}

void
expr_op_unary::Print(
	ISTREAM	*	pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit a unary expression to the stream.

 Arguments:
	
	pStream	- A pointer to the stream.

 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
	OPERATOR	Op	= GetOperator();
	char		ch;

	switch( Op )
		{
		case OP_UNARY_PLUS:			ch = '+'; break;
		case OP_UNARY_MINUS:		ch = '-'; break;
		case OP_UNARY_NOT:			ch = '!'; break;
		case OP_UNARY_COMPLEMENT:	ch = '~'; break;
		case OP_UNARY_INDIRECTION:	ch = '*'; break;
		case OP_UNARY_AND:			ch = '&'; break;
		default:					ch = 'X'; break;
		}

	pStream->Write( ch );
	PrintSubExpr( GetLeft(), pStream );
}

void
expr_cast::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a cast expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
    if ( GetEmitModifiers() == true )
        {
	    GetType()->PrintType( (PRT_CAST),
					       pStream,
					       (node_skl *)0
					    );
        }
    else
        {
	    GetType()->PrintType( (PRT_CAST) | PRT_SUPPRESS_MODIFIERS,
					       pStream,
					       (node_skl *)0
					    );
        }
	PrintSubExpr( GetLeft(), pStream );

}

void
expr_sizeof::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a sizeof expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
	pStream->Write( "sizeof" );
	pType->PrintType( (PRT_CAST | PRT_ARRAY_SIZE_ONE),
					   pStream,
					   (node_skl *)0
					);
}

void
expr_alignof::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a sizeof expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
	pStream->Write( "__alignof" );
	pType->PrintType( (PRT_CAST | PRT_ARRAY_SIZE_ONE),
					   pStream,
					   (node_skl *)0
					);
}


void
expr_pre_incr::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a pre-incr expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
	pStream->Write("++");
	PrintSubExpr( GetLeft(), pStream );
}

void
expr_pre_decr::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a pre-decrement expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
	pStream->Write("--");
	PrintSubExpr( GetLeft(), pStream );
}

void
expr_post_incr::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a post-increment expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
	PrintSubExpr( GetLeft(), pStream );
	pStream->Write("++");
}

void
expr_post_decr::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a post-decrement expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
	PrintSubExpr( GetLeft(), pStream );
	pStream->Write("--");
}

void
expr_op_binary::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a binary arithmetic expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
	PrintSubExpr( GetLeft(), pStream );

	pStream->Write( OperatorToString( GetOperator() ) );

	PrintSubExpr( GetRight(), pStream );

}
void
expr_op_binary::PrintCall(
	ISTREAM	*	pStream,
	short		LeftMargin,
	BOOL		fInProc )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit expression as part of a procedure call.

 Arguments:

 	pStream	- A pointer to the stream.
 	LeftMargin	- The start margin for the procedure call.
 	fInProc	- Is it in a proc context already ?
	
 Return Value:
	
 	None.

 Notes:

	The left margin is 0 if the call is the only thing on the line. If the
	call is in an assignment, the start of param indent must take that into
	account.
----------------------------------------------------------------------------*/
{
	expr_node	*	pN;
	if ( ( pN = GetLeft() ) != 0 )
		pN->PrintCall( pStream, LeftMargin, fInProc );

	pStream->Write( OperatorToString( GetOperator() ) );

	if ( ( pN = GetRight() ) != 0 )
		pN->PrintCall( pStream, LeftMargin, fInProc );
}
void
expr_assign::PrintCall(
	ISTREAM	*	pStream,
	short		LeftMargin,
	BOOL		fInProc )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit expression as part of a procedure call.

 Arguments:

 	pStream	- A pointer to the stream.
 	LeftMargin	- The start margin for the procedure call.
 	fInProc	- Is it in a proc context already ?
	
 Return Value:
	
 	None.

 Notes:

	The left margin is 0 if the call is the only thing on the line. If the
	call is in an assignment, the start of param indent must take that into
	account.
----------------------------------------------------------------------------*/
{
	expr_node	*	pN;
	if ( ( pN = GetLeft() ) != 0 )
		pN->PrintCall( pStream, LeftMargin, fInProc );

	pStream->Write( " = " );

	if ( ( pN = GetRight() ) != 0 )
		pN->PrintCall( pStream, LeftMargin, fInProc );
}

void
expr_index::Print(
	ISTREAM	*	pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit expression for the array index operator.

 Arguments:

 	pStream	- A pointer to the stream.
	
 Return Value:
	
 	None.

 Notes:

----------------------------------------------------------------------------*/
{

	PrintSubExpr( GetLeft(), pStream );
	pStream->Write( '[' );
	GetRight()->Print( pStream );
	pStream->Write( ']' );
}
void
expr_index::PrintCall(
	ISTREAM	*	pStream,
	short		LeftMargin,
	BOOL		fInProc )
	{
	GetLeft()->PrintCall( pStream, LeftMargin, fInProc );
	pStream->Write( '[' );
	GetRight()->PrintCall( pStream, LeftMargin, fInProc );
	pStream->Write( ']' );
	}

void
expr_proc_call::PrintCall(
	ISTREAM	*	pStream,
	short		LeftMargin,
	BOOL		fInProc )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit expression for a procedure call.

 Arguments:

 	pStream	- A pointer to the stream.
 	LeftMargin	- The start margin for the procedure call.
 	fInProc	- Is it in a proc context already ?
	
 Return Value:
	
 	None.

 Notes:

	The left margin is 0 if the call is the only thing on the line. If the
	call is in an assignment, the start of param indent must take that into
	account.
----------------------------------------------------------------------------*/
{
	PNAME	pName = GetName();
	unsigned short CurPref	= pStream->GetPreferredIndent();
	unsigned short CurIndent= pStream->GetIndent();

	//
	// Print fancy only if more than 2 params.
	//

	if( GetNoOfParams() < 3 )
		{
		Print( pStream );
		if( !fInProc )
			pStream->Write(';');
		return;
		}

	pStream->Write( GetName() );

	pStream->Write( '(' );
	pStream->SetPreferredIndent( short( LeftMargin + CurPref + strlen( pName ) - CurIndent ) );
	pStream->IndentInc();
	pStream->NewLine();
	if( GetFirstParam())
		{
		GetFirstParam()->PrintCall( pStream,
								    LeftMargin,
								    TRUE // now in proc context
								  );
		}

	pStream->Write( ')' );
	if( !fInProc )
		pStream->Write( ';' );
	pStream->IndentDec();
	pStream->SetPreferredIndent( CurPref );
}

void
expr_proc_call::Print(
	ISTREAM	*	pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit expression for a procedure call.

 Arguments:

 	pStream	- A pointer to the stream.
	
 Return Value:
	
 	None.

 Notes:

----------------------------------------------------------------------------*/
{
	pStream->Write( GetName() );
	pStream->Write( '(' );
	if( GetFirstParam())
		GetFirstParam()->Print( pStream );
	pStream->Write( ')' );
}

void
expr_param::Print(
	ISTREAM	*	pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit expression for a parameter.

 Arguments:

 	pStream	- A pointer to the stream.
	
 Return Value:
	
 	None.

 Notes:

----------------------------------------------------------------------------*/
{
	expr_node * pNextParam;

	GetLeft()->Print( pStream );

	if ( ( pNextParam = GetNextParam() ) != 0 )
		{
		pStream->Write( ',' );
//		pStream->NewLine();
		pNextParam->Print( pStream );
		}
}

void
expr_param::PrintCall(
	ISTREAM	*	pStream,
	short		LeftMargin,
	BOOL		fInProc )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit expression as part of a procedure call.

 Arguments:

 	pStream	- A pointer to the stream.
 	LeftMargin	- The start margin for the procedure call.
 	fInProc	- Is it in a proc context already ?
 	pStream	- A pointer to the stream.
	
 Return Value:
	
 	None.

 Notes:

----------------------------------------------------------------------------*/
{
	expr_node * pNextParam;

	GetLeft()->PrintCall( pStream, LeftMargin, fInProc );

	if ( ( pNextParam = GetNextParam() ) != 0 )
		{
		pStream->Write( ',' );
		pStream->NewLine();
		pNextParam->PrintCall( pStream, LeftMargin, fInProc );
		}
}

void
expr_ternary::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a ternary expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
	PrintSubExpr( GetRelational(), pStream );
	pStream->Write( " ? " );
	PrintSubExpr( GetLeft(), pStream );
	pStream->Write( " : " );
	PrintSubExpr( GetRight(), pStream );
}
/****************************************************************************
 	utilities
 ****************************************************************************/
char *
OperatorToString(
	OPERATOR	Op )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Translate the operator to its string.

 Arguments:
	
	Op	- The operator value.

 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
    char *p;

    switch( Op )
        {
        case OP_PLUS:           p = " + ";  break;
        case OP_MINUS:          p = " - ";  break;
        case OP_STAR:           p = " * ";  break;
        case OP_SLASH:          p = " / ";  break;
        case OP_MOD:            p = " % ";  break;
        case OP_LEFT_SHIFT:     p = " << "; break;
        case OP_RIGHT_SHIFT:    p = " >> "; break;
        case OP_LESS:           p = " < ";  break;
        case OP_LESS_EQUAL:     p = " <= "; break;
        case OP_GREATER_EQUAL:  p = " >= "; break;
        case OP_GREATER:        p = " > ";  break;
        case OP_EQUAL:          p = " == "; break;
        case OP_NOT_EQUAL:      p = " != "; break;
        case OP_AND:            p = " & ";  break;
        case OP_OR:             p = " | ";  break;
        case OP_XOR:            p = " ^ ";  break;
        case OP_LOGICAL_AND:    p = " && "; break;
        case OP_LOGICAL_OR:     p = " || "; break;
        case OP_QM:             p = " ? ";  break;
        case OP_COLON:          p = " : ";  break;
        case OP_ASSIGN:         p = " = ";  break;
        case OP_DOT:            p = " . ";  break;
        case OP_POINTSTO:       p = " -> "; break;
        case OP_COMMA:          p = " , ";  break;
        case OP_UNARY_NOT:      p = " ! ";  break;
        default:                p = " X ";  break;
        }

    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\expr\makexpr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	makexpr.cxx

 Abstract:

	This file contains specialized routines for creating complex expressions
	from the basic expressions.

 Notes:


 History:

 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 )

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "nulldefs.h"
extern "C"
	{
	#include <stdio.h>
	
	}
#include "makexpr.hxx"
#include "gramutil.hxx"

/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

expr_node *
MakeReferentExpressionIfNecessary(
	expr_node * pExpr )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Create a reference expression out of this expression.

 Arguments:
	
	pExpr	- The input expression for making another reference expr.

 Return Value:

 	The final generated expression.
	
 Notes:

 	If the input expression is a simple variable, make a &(variable) expression
 	out of it. If it is already a pointer, return the same expression.

	The method is implemented for this situation: I have an expression with me,
	I dont really want to know if it is a pointer or not. I just know that this
	expression represents the final data location for me to unmarshall into or
	marshall from. Given that , generate an expression that will effectively
	point to this piece of data. So if it is already a pointer, just return the
	same expression, if it is a variable, return the address of this variable,
	if it is already a pointer, just dont do anything.
----------------------------------------------------------------------------*/
{
	node_skl	*	pNode = pExpr->GetType();
	NODE_T	NT			  = pExpr->GetType()->NodeKind();

	if( (NT == NODE_PARAM) || (NT == NODE_ID) || (NT == NODE_FIELD) )
		{
		pNode = pNode->GetBasicType();
		NT	  = pNode->NodeKind();
		}

	if( IS_BASE_TYPE_NODE( NT )  )
		{
		return MakeAddressExpressionNoMatterWhat( pExpr );
		}

	switch( NT )
		{
		default:
			MIDL_ASSERT( FALSE );

		case NODE_POINTER:
			return pExpr;
		}
}
expr_node *
MakeDereferentExpressionIfNecessary(
	expr_node * pExpr )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Create a de-reference expression out of this expression.

 Arguments:
	
	pExpr	- The input expression for making another de-reference expr.

 Return Value:

 	The final generated expression.
	
 Notes:

 	If the input expression is a simple variable, return just that.
 	If it is already a pointer, return a deref expression.

	The method is implemented for this situation: I have an expression with me,
	I dont really want to know if it is a variable or not. I just know that this
	expression represents the final data address for me to unmarshall into or
	marshall from. Given that , generate an expression that will effectively
	be a dereference of this piece of data. So if it is already a variable,
	just return the same expression, if it is a pointer, return the deref of
	this expression.
----------------------------------------------------------------------------*/
{
	expr_node	*	pENew;
	node_skl	*	pNode	= pExpr->GetType();
	NODE_T			NT		= pNode->NodeKind();

	if( (NT == NODE_PARAM) || (NT == NODE_FIELD) || (NT == NODE_ID) )
		{
		pNode	= pNode->GetBasicType();
		NT		= pNode->NodeKind();
		}

	if( IS_BASE_TYPE_NODE( NT ) )
		{
		return pExpr;
		}

	switch( NT )
		{
		default:
	//		MIDL_ASSERT( FALSE );
		case NODE_POINTER:
			pENew = new expr_u_deref( pExpr );
			pENew->SetType( pNode->GetBasicType() );
			return pENew;
		}
}

expr_node *
MakeAddressExpressionNoMatterWhat(
	expr_node	*	pExpr )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Make an address expression out of this one, ie generate &(expr).

 Arguments:
	
	pExpr	- A pointer to the expression to manipulate.

 Return Value:
	
 	The final expression.

 Notes:

----------------------------------------------------------------------------*/
{
	expr_node	*	pENew	= (expr_node *) new expr_u_address( pExpr );
	node_skl	*	pNode	= new node_pointer();
	pNode->SetBasicType( pExpr->GetType() );
	pNode->SetEdgeType( EDGE_USE );
	pENew->SetType( pNode );
	return pENew;
}

expr_node *
MakeDerefExpressionOfCastPtrToType(
	node_skl	*	pType,
	expr_node	*	pExpr )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Make an deref expression of a pointer cast to the type.

 Arguments:
	
	pType	- The type to cast to.
	pExpr	- A pointer to the expression to manipulate.

 Return Value:
	
 	The final expression.

 Notes:

----------------------------------------------------------------------------*/
{
	node_skl	*	pPtr	= new node_pointer();

	pPtr->SetBasicType( pType );
	pPtr->SetEdgeType( EDGE_USE );

	pExpr	= new expr_cast( pPtr, pExpr );
	pExpr	= new expr_u_deref( pExpr );
	pExpr->SetType( pType );

	return pExpr;
}
expr_node *
MakeExpressionOfCastPtrToType(
	node_skl	*	pType,
	expr_node	*	pExpr )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Make an expression of a pointer cast to the type.
      (type *) expr

 Arguments:
	
	pType	- The type to cast to.
	pExpr	- A pointer to the expression to manipulate.

 Return Value:
	
 	The final expression.

 Notes:

----------------------------------------------------------------------------*/
{
	node_skl	*	pPtr	= new node_pointer();

	pPtr->SetBasicType( pType );
	pPtr->SetEdgeType( EDGE_USE );

	pExpr	= new expr_cast( pPtr, pExpr );

	return pExpr;
}
expr_node *
MakeExpressionOfCastToTypeName(
	PNAME			pName,
	expr_node	*	pExpr )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Make an expression of a cast to the type whose name is specified.
      (name) expr

 Arguments:
	
	pName	- The type name to cast to.
	pExpr	- A pointer to the expression to manipulate.

 Return Value:
	
 	The final expression.

 Notes:

----------------------------------------------------------------------------*/
{
	node_skl	*	pDef	= new node_def( (char *)pName );

	pDef->SetBasicType( 0 );
	pDef->SetEdgeType( EDGE_USE );

	pExpr	= new expr_cast( pDef, pExpr );

	return pExpr;
}

expr_proc_call *
MakeProcCallOutOfParamExprList(
	PNAME			pName,
	node_skl	*	pType,
	ITERATOR&		ParamExprList )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Make a procedure call expression given a list of param expressions.

 Arguments:

 	pName			- The name of the procedure.
 	pType			- The return type of the procedure.
	ParamExprList	- The list of expressions (sans the expr_param nodes)
	
 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
	expr_node		*	pExpr = 0;
	expr_proc_call	*	pProc	= new expr_proc_call( pName );

	pProc->SetType( pType );

	if( ITERATOR_GETCOUNT( ParamExprList ) )
		{
		while( ITERATOR_GETNEXT( ParamExprList, pExpr ) )
			{
			pProc->SetParam( new expr_param( pExpr ) );
			}
		}

	return pProc;
}
expr_node *
MakeRefExprOutOfDeref(
	expr_node * pExpr )
	{

	if( pExpr->GetOperator() == OP_UNARY_INDIRECTION )
		{
		return pExpr->GetLeft();
		}
	return pExpr;
	}
expr_node *
MakeAddressOfPointer(
	expr_node * pExpr )
	{
	if( pExpr->GetOperator() == OP_UNARY_INDIRECTION )
		{
		return pExpr->GetLeft();
		}
	else
		{
		return MakeAddressExpressionNoMatterWhat( pExpr );
		}
	}
expr_node *
MakeCastExprPtrToUChar(
	expr_node	*	pExpr )
	{
	node_skl	*	pType;
	node_skl	*	pP;

	GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_CHAR, TYPE_INT );
	pP	= new node_pointer();
	pP->SetBasicType( pType );
	pP->SetEdgeType( EDGE_USE );
	return new expr_cast( pP, pExpr );
	}
expr_node *
MakeCastExprPtrToPtrToUChar(
	expr_node	*	pExpr )
	{
	node_skl	*	pType;
	node_skl	*	pP;
	node_skl	*	pP1;

	GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_CHAR, TYPE_INT );
	pP	= new node_pointer();
	pP->SetBasicType( pType );
	pP->SetEdgeType( EDGE_USE );
	pP1	= new node_pointer();
	pP1->SetBasicType( pP );
	pP1->SetEdgeType( EDGE_USE );
	return new expr_cast( pP1, pExpr );
	}
expr_node *
MakeCastExprPtrToVoid(
	expr_node	*	pExpr )
	{
	node_skl	*	pType;
	node_skl	*	pP;

	GetBaseTypeNode( &pType, SIGN_UNDEF, SIZE_UNDEF, TYPE_VOID );
	pP	= new node_pointer();
	pP->SetBasicType( pType );
	pP->SetEdgeType( EDGE_USE );
	return new expr_cast( pP, pExpr );
	}
void
SetPrefixes(
	ITERATOR&	VarList,
	char * pPrefix,
	expr_node * pTarget )
	{
	short Count;

	ITERATOR_INIT(VarList);

	for( Count =  pTarget->MakeListOfVars( VarList),
		 ITERATOR_INIT( VarList) ;
		 Count > 0 ;
		 Count-- )
		{
		expr_variable * pE = 0;

		ITERATOR_GETNEXT( VarList, pE );
		pE->SetPrefix( pPrefix );

		}
	}
void
ResetPrefixes(
	ITERATOR&	VarList,
	expr_node * pTarget )
	{
	short Count;

	ITERATOR_INIT(VarList);

	for( Count =  pTarget->MakeListOfVars( VarList),
		 ITERATOR_INIT( VarList) ;
		 Count > 0 ;
		 Count-- )
		{
		expr_variable * pE = 0;

		ITERATOR_GETNEXT( VarList, pE );
		pE->SetPrefix( 0 );

		}
	}

expr_node *
Make_1_ArrayExpressionFromVarName(
    PNAME   pName,
    int     Dimension )
    {
    expr_variable * pEV = new expr_variable( pName, 0 );
    expr_index    * pIV = new expr_index( pEV,
                                           new expr_constant( (long) Dimension)
                                         ); 
    return pIV;
    }



// This method combines all expressions in the list wiht logical ANDs. There is
// guaranteed to be at least 1 member in the list.

expr_node *
CombineIntoLogicalAndExpr(
    ITERATOR&   List )
    {
    expr_node   *   pExpr = 0;
    expr_node   *   pExpr1 = 0;

    ITERATOR_INIT( List );

    ITERATOR_GETNEXT( List, pExpr );

    while( ITERATOR_GETNEXT( List, pExpr1 ) )
        {
        pExpr = new expr_op_binary( OP_LOGICAL_AND, pExpr, pExpr1 );
        }

    return pExpr;
    }

/*******************************************************************
    We need to generate an expression to check that any pointers that
    are used in the expression are non-null, otherwise we will end
    up generating a deref of those pointers and GP fault. 

    For example, a length_is expression of *pLengthIs should generate
    code like so:
    _StubMsg.ActualCount = (pLengthIs) ? *pLengthIs : 0;

    Return the same expression if there is no pointer deref in the expr.
*******************************************************************/
expr_node *
MakeAttrExprWithNullPtrChecks(
    expr_node * pAttrExpr )
    {
    ITERATOR        List;
        
    if( pAttrExpr->MakeListOfDerefedVars( List ) )
        {
        expr_node   *   pExpr;

        // There is at least 1 deref expression here.

        pExpr = CombineIntoLogicalAndExpr( List );
        pAttrExpr = new expr_ternary( OP_QM,
                                      pExpr,
                                      pAttrExpr,
                                      new expr_constant( 0L ) );
        }
    return pAttrExpr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\attrnode.cxx ===
/*****************************************************************************/
/**                         Microsoft LAN Manager                           **/
/**                 Copyright(c) Microsoft Corp., 1987-1999                 **/
/*****************************************************************************/
/*****************************************************************************
File        : attrnode.cxx
Title       : attribute node routines
History     :
              04-Aug-1991     VibhasC Created

*****************************************************************************/

#pragma warning ( disable : 4514 4710 )

/****************************************************************************
 local defines and includes
 ****************************************************************************/

#include "nulldefs.h"
extern  "C"
    {
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <ctype.h>
    
    }

#include "allnodes.hxx"
#include "cmdana.hxx"
#include "buffer.hxx"
#include "mbcs.hxx"

#define W_CHAR_T_STRLEN_NAME    ("MIDL_wchar_strlen")
#define CHAR_STRLEN_NAME        ("MIDL_ascii_strlen")


/****************************************************************************
                           external data
 ****************************************************************************/

extern  CMD_ARG     *   pCommand;
extern  SymTable    *   pBaseSymTbl;

/****************************************************************************
                        external procedures
 ****************************************************************************/

extern void         ParseError( STATUS_T, char *);
extern  int         HexCheck(char *);
extern node_skl *   pBaseImplicitHandle;
/****************************************************************************/


/****************************************************************************
 node_base_attr:
 ****************************************************************************/
const char  *   const AttrNodeNameArray[ ACF_ATTR_END ] =
    {
    "[none]"
    ,"[first_is]"
    ,"[last_is]"
    ,"[length_is]"
    ,"[min_is]"
    ,"[max_is]"
    ,"[size_is]"
    ,"[range]"
    ,"[case]"
    ,"[funcdescattr]"
    ,"[idldescattr]"
    ,"[typedescattr]"
    ,"[vardescattr]"
    ,"[type attribute]"
    ,"[member attribute]"
    ,"[id]"
    ,"[helpcontext]"
    ,"[helpstringcontext]"
    ,"[lcid]"   // ATTR_LCID - applied to libraries - associated with an LCID constant
    ,"[dllname]"
    ,"[helpstring]"
    ,"[helpfile]"
    ,"[helpstringdll]"
    ,"[entry]"
    ,"[uuid]"
    ,"[async_uuid]"
    ,"[version]"
    ,"[switch_is]"
    ,"[iid_is]"
    ,"[defaultvalue]"
    ,"[transmit_as]"
    ,"[wire_marshal]"
    ,"[represent_as]"
    ,"[call_as]"        // last attribute that may not appear more than once
    ,"[custom]" 
    ,"[switch_type]"
    ,"[handle]"
    ,"[user_marshal]"
    ,"[ms_union]"
    ,"[ms_conf_struct]"
    ,"[v1_enum]"
    ,"[lcid]"   // ATTR_FLCID - applied to parameters - bit attribute
    ,"[hidden]"
    ,"[ptr kind]"
    ,"[string]"
    ,"[bstring]"
    ,"[endpoint]"
    ,"[local]"
    ,"[object]"
    ,"[ignore]"
    ,"[opaque]"
    ,"[idempotent]"
    ,"[broadcast]"
    ,"[maybe]"
    ,"[async]"
    ,"[input_sync]"
    ,"[byte_count]"
    ,"[callback]"
    ,"[message]"
    ,"[in]"
    ,"[out]"
    ,"[partial_ignore]"
    ,"[default]"
    ,"[context_handle]"
    ,"[code]"
    ,"[nocode]"
    ,"[optimize]"
    ,"[comm_status]"
    ,"[fault_status]"
    ,"[allocate]"
    ,"[heap]"
    ,"[implicit_handle]"
    ,"[explicit_handle]"
    ,"[auto_handle]"
    ,"[ptrsize]"
    ,"[notify]"
    ,"[notify_flag]"
    ,"[enable_allocate]"
    ,"[encode]"
    ,"[decode]"
    ,"[strict_context_handle]"
    ,"[context_handle_noserialize]"
    ,"[context_handle_serialize]"
    ,"[force_allocate]"
    ,"[cs_drtag]"
    ,"[cs_rtag]"
    ,"[cs_stag]"
    ,"[cs_char]"
    ,"[cs_tag_rtn]"
    };

const char * PtrKindArray[] =
    {
    "",
    "[ref]",
    "[unique]",
    "[full]"
    };

const char * TypeAttrArray[] =
    {
    "[public]",
    "[appobject]",
    "[control]",
    "[dual]",
    "[licensed]",
    "[nonextensible]",
    "[oleautomation]",
    "[noncreatable]",
    "[aggregatable]",
    "[proxy]"
    };

const char * MemberAttrArray[] =
    {
    "[readonly]",
    "[source]",
    "[bindable]",
    "[displaybind]",
    "[defaultbind]",
    "[requestedit]",
    "[propget]",
    "[propput]",
    "[propputref]",
    "[restricted]",
    "[optional]",
    "[retval]",
    "[vararg]",
    "[predeclid]",
    "[uidefault]",
    "[nonbrowsable]",
    "[defaultcollelem]",
    "[defaultvtable]",
    "[immediatebind]",
    "[usesgetlasterror]",
    "[replaceable]"
    };

char    *
node_base_attr::GetNodeNameString()
    {
    int At  = (int) GetAttrID();

    MIDL_ASSERT ( At < sizeof(AttrNodeNameArray)/sizeof(char *) );

    if ( At == ATTR_PTR_KIND )
        return (char *) PtrKindArray[ ((node_ptr_attr *)this)->GetPtrKind() ];
    if ( At == ATTR_TYPE )
        return (char *) TypeAttrArray[ ((node_type_attr *)this)->GetAttr() - TATTR_BEGIN];
    if ( At == ATTR_MEMBER )
        return (char *) MemberAttrArray[ ((node_member_attr *)this)->GetAttr() - MATTR_BEGIN];
    return (char *) AttrNodeNameArray[ (int) At ];
    }

/****************************************************************************
 ATTRLIST::Merge
    Merge two ATTRLISTs -- singly linked linear lists - insert at head
 ****************************************************************************/
void
ATTRLIST::Merge(ATTRLIST & MoreAttrs )
    {
    node_base_attr * pCur = MoreAttrs.pHead;

    if (pCur == NULL)
        {
        return;
        }

    while (pCur->pNext)
        {
        pCur = pCur->pNext;
        }

    pCur->pNext = pHead;
    pHead = MoreAttrs.pHead;

    };
/****************************************************************************
 ATTRLIST::Reverse
    Reverse an ATTRLIST -- singly linked linear list
 ****************************************************************************/
void
ATTRLIST::Reverse()
    {
    node_base_attr * pCur   = pHead;
    node_base_attr * pNext;
    node_base_attr * pPrev  = NULL;

    while (pCur)
        {
        pNext = pCur->pNext;
        pCur->pNext = pPrev;

        // advance to the next node
        pPrev = pCur;
        pCur = pNext;
        }

    pHead = pPrev;

    };
/****************************************************************************
 ATTRLIST::FInSummary
    Search for matching attribute -- singly linked linear lists
 ****************************************************************************/
BOOL
ATTRLIST::FInSummary(ATTR_T flag )
    {
    node_base_attr * pCur = pHead;

    while (pCur)
        {
        if ( pCur->AttrID == flag )
            {
            return TRUE;
            };
        pCur = pCur->pNext;
        }
    return FALSE;
    };

/****************************************************************************
 ATTRLIST::FMATTRInSummary
    Search for matching MEMEBER attribute -- singly linked linear lists
 ****************************************************************************/
BOOL
ATTRLIST::FMATTRInSummary(MATTR_T flag)
    {
    node_base_attr * pCur = pHead;

    while (pCur)
        {
        if ( pCur->AttrID == ATTR_MEMBER)
            {
            if (((node_member_attr *)pCur)->GetAttr() == flag)
                return TRUE;
            };
        pCur = pCur->pNext;
        }
    return FALSE;
    };

/****************************************************************************
 ATTRLIST::FTATTRInSummary
    Search for matching MEMEBER attribute -- singly linked linear lists
 ****************************************************************************/
BOOL
ATTRLIST::FTATTRInSummary(TATTR_T flag)
    {
    node_base_attr * pCur = pHead;

    while (pCur)
        {
        if ( pCur->AttrID == ATTR_TYPE)
            {
            if (((node_member_attr *)pCur)->GetAttr() == flag)
                return TRUE;
            };
        pCur = pCur->pNext;
        }
    return FALSE;
    };

/****************************************************************************
 ATTRLIST::GetAttribute
    Search for matching attribute -- singly linked linear lists
 ****************************************************************************/
node_base_attr  *
ATTRLIST::GetAttribute(ATTR_T flag )
    {
    node_base_attr * pCur = pHead;

    while (pCur)
        {
        if ( pCur->AttrID == flag )
            {
            return pCur;
            }
        pCur = pCur->pNext;
        }
    return NULL;
    };

/****************************************************************************
 ATTRLIST::Remove
 ****************************************************************************/
void
ATTRLIST::Remove( ATTR_T flag )
    {
    node_base_attr* pCur = pHead;
    node_base_attr* pPrev = 0;

    while (pCur)
        {
        if ( pCur->AttrID == flag )
            {
            if ( pPrev )
                {
                pPrev->pNext = pCur->pNext;
                }
            else
                {
                pHead = pHead->pNext;
                }
            delete pCur;
            }
        pPrev = pCur;
        pCur = pCur->pNext;
        }
    }

    /****************************************************************************
 ATTRLIST::GetAttributeList
    Return entire attribute list
 ****************************************************************************/
STATUS_T
ATTRLIST::GetAttributeList(type_node_list * pTNList )
    {
    node_base_attr * pCur = pHead;

    while (pCur)
        {
        pTNList->SetPeer( (node_skl *)pCur );
        pCur = pCur->pNext;
        }
    return (pHead) ? STATUS_OK: I_ERR_NO_MEMBER;
    };

/****************************************************************************
 ATTRLIST::Clone
    Return an attribute list with all new attribute nodes
 ****************************************************************************/
ATTRLIST
ATTRLIST::Clone()
    {
    node_base_attr * pCur = pHead;
    ATTRLIST    NewList;

    NewList.MakeAttrList();
    while (pCur)
        {
        // gaj - does this reverse the list ?? and if so is it OK?
        NewList.Add( pCur->Clone() );
        pCur = pCur->pNext;
        }
    return NewList;
    };

/****************************************************************************
 ATTRLIST::Dump
    Dump all attributes on list
 ****************************************************************************/
void
ATTRLIST::Dump( ISTREAM* pStream)
    {
    node_base_attr * pCur = pHead;

    while (pCur)
        {
        int At  = (int) pCur->GetAttrID();

        if ( At == ATTR_CASE )
            {
            pStream->Write( "[case(" );
/*
            I removed this section just before check in for midl 3.00.12
            as it somehow was messing up with the print type's Buffer
            at the typedef level for an upper struct, when the
            expression had a (DWORD) cast in it.
            repro: test10, problem from spoolss. Rkk.
            
            expr_list * pExprList;
            expr_node * pExpr;
            BOOL        fFirstExpr = TRUE;

            pExprList = ((node_case *)pCur)->GetExprList();
            pExprList->Init();
            while (( pExprList->GetPeer( &pExpr ) == STATUS_OK ))
                {
                if ( fFirstExpr )
                    fFirstExpr = FALSE;
                else
                    pStream->Write( "," );

                if ( pExpr )
                    pExpr->Print( pStream );
                }
*/

            pStream->Write( ")]" );
            }
        else
            {
            // returns a "[attrname]" string
            
            pStream->Write( pCur->GetNodeNameString() );
            }

        pCur = pCur->pNext;
        }
    };

/****************************************************************************
 miscellaneous attributes
 ****************************************************************************/

inline unsigned long
HexToULong( const char * pStr)
    {
    unsigned long   Cumulative      = 0;

    for ( ; *pStr; pStr++ )
        {
        Cumulative <<= 4;

        // add in another nibble
        Cumulative += ( *pStr >= 'a' ) ? ( *pStr - 'a' + 10  )
            : ( *pStr >= 'A' ) ? ( *pStr - 'A' + 10 )
                                                                                                                  : ( *pStr - '0' );
        }
    return Cumulative;
    }

#define GUID_STRING_1_SIZE  8
#define GUID_STRING_2_SIZE  4
#define GUID_STRING_3_SIZE  4
#define GUID_STRING_4_SIZE  4
#define GUID_STRING_5_SIZE  12

void
GUID_STRS::SetValue()
    {
    char    buffer[GUID_STRING_5_SIZE + 1];
    int     i,j;

    Value.Data1 = HexToULong( str1 );
    Value.Data2 = (unsigned short) HexToULong( str2 );
    Value.Data3 = (unsigned short) HexToULong( str3 );

    // go through the last strings backwards, advancing the null
    // byte as we go.

    // compute bytes 1 and 0
    strncpy( buffer, str4, GUID_STRING_4_SIZE+1 );
    for ( i = GUID_STRING_4_SIZE/2 - 1, j=GUID_STRING_4_SIZE-2  ; i >=0 ; i--, j-=2 )
        {
        Value.Data4[i] = (unsigned char) HexToULong( &buffer[j] );
        buffer[j] = '\0';
        }

    // compute bytes 7 to 2
    strncpy( buffer, str5, GUID_STRING_5_SIZE+1 );
    for ( i = GUID_STRING_5_SIZE/2 + 1, j=GUID_STRING_5_SIZE-2 ; i >=2 ; i--, j-=2 )
        {
        Value.Data4[i] = (unsigned char) HexToULong( &buffer[j] );
        buffer[j] = '\0';
        }
    }

node_guid::node_guid(char* pIn, ATTR_T At ) : ma( At )
    {
    char * p1  = pIn,
         * p2  = (p1) ? (strchr( p1+1 , '-')) : 0,
         * p3  = (p2) ? (strchr( p2+1 , '-')) : 0,
         * p4  = (p3) ? (strchr( p3+1 , '-')) : 0,
         * p5  = (p4) ? (strchr( p4+1 , '-')) : 0;

    if( p1 && p2 && p3 && p4 && p5 )
        {
        *p2++ = *p3++ = *p4++ = *p5++ = '\0';
        CheckAndSetGuid( p1, p2, p3, p4, p5 );
        }
    else
        ParseError( UUID_FORMAT, (char *)0 );
    }

node_guid::node_guid (
        char * pStr1,
        char * pStr2,
        char * pStr3,
        char * pStr4,
        char * pStr5,
        ATTR_T At ) : ma( At )
    {
    CheckAndSetGuid( pStr1, pStr2, pStr3, pStr4, pStr5 );
    }

void
node_guid::GetStrs (
        char ** pStr1,
        char ** pStr2,
        char ** pStr3,
        char ** pStr4,
        char ** pStr5 )
    {
    *pStr1 = cStrs.str1;
    *pStr2 = cStrs.str2;
    *pStr3 = cStrs.str3;
    *pStr4 = cStrs.str4;
    *pStr5 = cStrs.str5;
    };

void
node_guid::CheckAndSetGuid(
        char * pStr1,
        char * pStr2,
        char * pStr3,
        char * pStr4,
        char * pStr5 )
    {
    cStrs.SetStrs( pStr1, pStr2, pStr3, pStr4, pStr5 );

    int Len1 = (int) strlen(pStr1);
    int Len2 = (int) strlen(pStr2);
    int Len3 = (int) strlen(pStr3);
    int Len4 = (int) strlen(pStr4);
    int Len5 = (int) strlen(pStr5);

    if( (Len1 == GUID_STRING_1_SIZE) &&
    (Len2 == GUID_STRING_2_SIZE) &&
    (Len3 == GUID_STRING_3_SIZE) &&
    (Len4 == GUID_STRING_4_SIZE) &&
    (Len5 == GUID_STRING_5_SIZE) )
        {
        if( !HexCheck(pStr1)    ||
            !HexCheck(pStr2)    ||
            !HexCheck(pStr3)    ||
            !HexCheck(pStr4)    ||
            !HexCheck(pStr5) )
            {
            ParseError(UUID_NOT_HEX, (char *)NULL);
            }
        else
            {
            guidstr = new char[ Len1 + Len2 + Len3 + Len4 + Len5 + 5 ];
            strcpy(guidstr, pStr1);
            strcat(guidstr, "-");
            strcat(guidstr, pStr2);
            strcat(guidstr, "-");
            strcat(guidstr, pStr3);
            strcat(guidstr, "-");
            strcat(guidstr, pStr4);
            strcat(guidstr, "-");
            strcat(guidstr, pStr5);
            }
        }
    else
        {
        ParseError(UUID_FORMAT, (char *)NULL);
        }
    }

node_version::node_version(
        unsigned long   vMajor,
        unsigned long   vMinor ) : nbattr( ATTR_VERSION )
    {
    major   = vMajor;
    minor   = vMinor;

    if( (major > 0x0000ffff ) || (minor > 0x0000ffff))
        ParseError( VERSION_FORMAT, (char *)0);
    }

node_version::node_version(char *  pV ) : nbattr(ATTR_VERSION)
    {
    char * pMinor;
    char * pMajor  = pV;
    BOOL   fError  = TRUE;

    major = minor = 0;

    if( pMajor && *pMajor )
        {
        if( ( pMinor = strchr( pMajor, '.' ) ) != 0 )
            {
            fError = TRUE;
            if( *(++pMinor) )
                {
                minor = strtoul( pMinor, &pMinor, 10 );
                if( ! *pMinor )
                    fError = FALSE;
                }
            }
        else
            fError = FALSE;

        if( fError == FALSE )
            {
            //use pMinor to save pMajor value;

            major = strtoul( pMinor = pMajor, &pMajor, 10 );

            if( (*pMajor && (*pMajor != '.' )) || (pMajor == pMinor) )
                fError = TRUE;
            }
        }

    if( (fError == TRUE )                       ||
        (major > (unsigned long )0x0000ffff)    ||
        (minor > (unsigned long )0x0000ffff)    )
        {
        ParseError( VERSION_FORMAT, (char *)0 );
        }

    }

STATUS_T
node_version::GetVersion(
        unsigned short *pMajor,
        unsigned short *pMinor )
    {
    *pMajor = (unsigned short) major;
    *pMinor = (unsigned short) minor;
    return STATUS_OK;
    }

node_endpoint::node_endpoint(char * pEndPointString ) : nbattr( ATTR_ENDPOINT )
    {
    SetEndPointString( pEndPointString );
    }

void
node_endpoint::SetEndPointString(
        char * pString )
    {
    ENDPT_PAIR * pEntry  = new ENDPT_PAIR;
    char       * p1      = pString;
    char       * p2      = 0;
    char       * pTemp;
    short        Len;
    STATUS_T     Status  = ENDPOINT_SYNTAX;

    //
    // Parse the string. Note that we can assume that the string is at least
    // a null string, because it came from the parser. If it wasnt a string,
    // the parser would have barfed anyhow.
    //
    // Firstly, the string must have a ':' separator. Also, it must have
    // at least 1 character before the :.
    //

    if( pString && (pTemp = strchr( pString , ':' ) ) != 0 && ((pTemp - pString) > 0) )
        {
        //
        // pick up the first part of the string.
        //

        Len = short( pTemp - pString );
        p1  = new char [ Len + 1 ]; // one for null.
        strncpy( p1, pString, Len );
        p1[ Len ] = '\0';

        //
        // pick up the last part of the string. Skip beyond the :. There can be
        // some characters after the : and before the '['. This is the server
        // name. Then follows the port within the []. The actual string will
        // not have the [].
        //

        // skip the :

        pTemp   += 1;

        // find out the total length of the string. Allocate 2 less than that
        // 'cause we dont need the '[' and ']'. The string must be more than
        // 2 characters 'cause it must have the brackets anyhow.

        Len = (short) strlen( pTemp );

        if( (Len > 2 ) &&
            (strchr( pTemp, '[' )) &&
            (pTemp[ Len - 1] == ']'))
            {
            char *p2Cur;

            while( *pTemp != '[' )
                {
                pTemp++;
                Len--;
                }

            //
            // in the second half of the parse, just get the whole string till
            // the null. Now the user could be perverted, he could have a
            // ] embedded within the string, in addition to the last ]. To
            // ensure that he gets what he deserves, transfer till the end
            // except the last character which must be ']'.

            pTemp++; Len--;

            p2Cur   = p2 = new char[ Len ]; // Yes, not Len + 1 'cause we are
                                            // going to re-use the last char
                                            // which is ] for the null.

            strncpy( p2Cur, pTemp, --Len );

            p2Cur[ Len ] = '\0';

            Status = STATUS_OK;
            }
        else
            {
            delete p1;
            }

        }

    if( Status != STATUS_OK )
        {
        ParseError( Status, pString );
        p1 = p2 = 0;
        }

    //
    // set up the pair.
    //

    pEntry->pString1    = p1;
    pEntry->pString2    = p2;

    EndPointStringList.Insert( pEntry );

    }

ITERATOR &
node_endpoint::GetEndPointPairs()
    {
    EndPointStringList.Init();
    return EndPointStringList;
    }


/****************************************************************************
                                utility routines
 ****************************************************************************/
int
HexCheck(char *pStr)
    {
    if(pStr && *pStr)
        {
        while(*pStr)
            {
            if(! isxdigit(*pStr)) return 0;
            pStr++;
            }
        return 1;
        }
    return 0;
    }


//+---------------------------------------------------------------------------
//
//  Function:   TranslateEscapeSequences
//
//  Purpose:    Replaces a string's escape sequences with the appropriate 
//              ASCII characters.
//
//              NOTE: this can be done in place because the resulting string
//              length will always be shorter than or equal to the input string 
//              length.
//
//  Assumes:    The string is NULL terminated and in writable memory.
//
//----------------------------------------------------------------------------

#define ESCAPE_CHARACTER '\\'
void TranslateEscapeSequences(char * sz)
{
    char * pchNextOut = sz;
    char ch; 
    
    while (0 != (ch = *sz))
        {
        if ((char)ESCAPE_CHARACTER == ch)
            {
            ch = *(++sz);
            switch ((char)tolower(ch))
                {
                case '0':   // octal sequence
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                    {
                    char count = 3;
                    unsigned char value = 0;
                    do 
                        {
                        value *= 8;
                        value = unsigned char( value + ch - '0' );
                        ch = *(++sz);
                        count--;
                        }
                    while (ch <= '8' && ch >= '0' && count);
                    sz--;
                    ch = (char) value;
                    break;
                    }
                case 'x':   // hex sequence
                    {
                    unsigned char value = 0;
                    ch = (char)tolower(*(++sz));
                    if ((ch <= '8' && ch >= '0') || (ch <= 'f' && ch >= 'a'))
                        {
                        do
                            {
                            value *= 16;
                            if (ch < 'a')
                                value = unsigned char(value + ch - '0');
                            else 
                                value = unsigned char(value + ch - 'a' + 10);
                            ch = (char)tolower(*(++sz));
                            }
                        while ((ch <= '8' && ch >= '0') || (ch <= 'f' && ch >= 'a'));
                        sz--;
                        ch = (char) value;
                        }
                    else    // "\x" with no trailing hex digits is treated as an "x"
                        {
                        ch = *(--sz);
                        }
                    break;
                    }
                case 'n':   // newline
                    ch = (char) '\n';
                    break;
                case 't':   // tab
                    ch = (char) '\t';
                    break;
                case 'v':   // vertical tab
                    ch = (char) '\v';
                    break;
                case 'b':   // backspace
                    ch = (char) '\b';
                    break;
                case 'r':   // carriage return
                    ch = (char) '\r';
                    break;
                case 'f':   // formfeed
                    ch = (char) '\f';
                    break;
                case 'a':   // alert
                    ch = (char) '\a';
                    break;
                case 0:     // just in case the last character in the string is an escape character
                    ch = (char) ESCAPE_CHARACTER;
                    sz--;
                    break;
                default:
                    break;
                }
            }
        *(pchNextOut++) = ch;
        ++sz;

        if (CurrentCharSet.IsMbcsLeadByte(ch))
            *(pchNextOut++) = *(sz++);
        }
    *(pchNextOut++) = ch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\copyto.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    CopyTo.cxx

 Abstract:

    cloning routines

 Notes:


 Author:

    NishadM Sep-29-1997     Created.

 Notes:


 ----------------------------------------------------------------------------*/

// unreferenced inline/local function has been removed
#pragma warning ( disable : 4514 )

// includes
#include "nodeskl.hxx"
#include "attrnode.hxx"
#include "acfattr.hxx"
#include "idict.hxx"

// externs
extern SymTable*    pBaseSymTbl;

// constants
const char* const szAsyncIntfPrefix     = "Async";
const unsigned int uAsyncIntfPrefixLen  = 5;
const char* const szFinishProcPrefix    = "Finish_";
const unsigned int uFinishProcPrefixLen = 7;
const char* const szBeginProcPrefix     = "Begin_";
const unsigned int uBeginProcPrefixLen  = 6;

// forwards
extern IDICT* pInterfaceDict;

void
FixupCallAs (
            node_call_as*,
            ITERATOR&
            );
node_interface*
DuplicateNodeInterface  (
                        node_interface*     pIntfSrc,
                        const char* const   szPrefix,
                        unsigned short      uPrefixLen
                        );
node_proc*
DuplicateNodeProc   (
                    node_proc*          pProcSrc,
                    const char* const   szPrefix,
                    unsigned            uPrefixLen,
                    unsigned long       uInterfaceKey,
                    ITERATOR&           Itr
                    );
node_param*
DuplicateNodeParam  (
                    node_param*     pParamSrc,
                    node_proc*      pProc
                    );
node_skl*
FindInOnlyParamInExpr   (
                        expr_node*  pExpr
                        );
node_skl*
GetInOnlyParamPairedWithOut (
                            MEM_ITER&    MemParamList
                            );
void
FixupBeginProcExpr  (
                    expr_node*  pExpr
                    );

void
FixupFinishProcExpr (
                    expr_node*  pExpr
                    );
void
TraverseParamsAndExprs  (
                        MEM_ITER&    MemParamList,
                        void (*CallFunc)( expr_node* )
                        );

// routines

/****************************************************************************
 CloneIFAndSplitMethods:
    Given an interface, copy it and split the methods for async.  e.g.
    method IFoo::Foo becomes AsyncIFoo::Begin_Bar and AsyncIFoo::Finish_Bar.
 ****************************************************************************/
node_interface*
CloneIFAndSplitMethods  (
                        node_interface* pSrc
                        )
    {
    node_interface* pAsyncIntf = DuplicateNodeInterface (
                                                        pSrc,
                                                        szAsyncIntfPrefix,
                                                        uAsyncIntfPrefixLen
                                                        ) ;

    if ( pAsyncIntf )
        {
        // for [call_as] fixups
        ITERATOR BeginProcList;
        ITERATOR FinishProcList;

        // each IFoo::Bar() becomes,
        named_node* pNodeProcItr = 0;
        named_node* pPrevSibling = 0;
        MEM_ITER    MemList( pSrc );
        while ( ( pNodeProcItr = MemList.GetNext() ) != 0 )
            {
            if ( pNodeProcItr->NodeKind() == NODE_PROC )
                {
                // AsyncIFoo::Begin_Bar()
                node_proc* pProcBegin = DuplicateNodeProc   (
                                                            (node_proc*)pNodeProcItr,
                                                            szBeginProcPrefix,
                                                            uBeginProcPrefixLen,
                                                            CurrentIntfKey,
                                                            BeginProcList
                                                            );
                pProcBegin->SetIsBeginProc();
                if ( pPrevSibling )
                    {
                    pPrevSibling->SetSibling( pProcBegin );
                    }
                else
                    {
                    pAsyncIntf->SetFirstMember( pProcBegin );
                    }

                // AsyncIFoo::Finish_Bar()
                node_proc* pProcFinish = DuplicateNodeProc  (
                                                            (node_proc*)pNodeProcItr,
                                                            szFinishProcPrefix,
                                                            uFinishProcPrefixLen,
                                                            CurrentIntfKey,
                                                            FinishProcList
                                                            );
                pProcFinish->SetIsFinishProc();
                pProcFinish->SetBeginProc( pProcBegin );
                pProcBegin->SetSibling( pProcFinish );
                pPrevSibling = pProcFinish;

                // AsyncIFoo::Begin_Bar() gets all [in] params of IFoo::Bar() &
                // AsyncIFoo::Finish_Bar() gets all [out] params IFoo::Bar().
                MEM_ITER    MemParamList( (node_proc*)pNodeProcItr );
                named_node* pNodeParamItr = 0;
                MemParamList.Init();
                while ( ( pNodeParamItr = (node_param *) MemParamList.GetNext() ) != 0 )
                    {
                    // if parameter has [in] or, does not have either [in] or [out] attributes
                    // assume [in] by default
                    if ( pNodeParamItr->FInSummary( ATTR_IN ) || 
                            !( pNodeParamItr->FInSummary( ATTR_IN ) || pNodeParamItr->FInSummary( ATTR_OUT ) ) )
                        {
                        ( (node_param*) pNodeParamItr )->SetAsyncBeginSibling   (
                                        DuplicateNodeParam( (node_param*)pNodeParamItr, pProcBegin )
                                                                                );
                        }
                    if ( pNodeParamItr->FInSummary( ATTR_OUT )
                         // || ( (node_param *) pNodeParamItr )->IsTaggedForAsyncFinishParamList()
                         )
                        {
                        ( (node_param*) pNodeParamItr )->SetAsyncFinishSibling  (
                                        DuplicateNodeParam( (node_param*)pNodeParamItr, pProcFinish )
                                                                                );
                        }
                    }
                // fix up expr in Begin_* and Finish_*
                MEM_ITER    BeginProcParamList( pProcBegin );
                TraverseParamsAndExprs( BeginProcParamList, FixupBeginProcExpr );

                MEM_ITER    FinishProcParamList( pProcFinish );
                TraverseParamsAndExprs( FinishProcParamList, FixupFinishProcExpr );
                }
            }
        // [call_as] fixups
        // [call_as(Baz)] IFoo::Bar() becomes,
        // [call_as(Begin_Baz)] AsyncIFoo::Begin_Bar()
        // [call_as(Finish_Baz)] AsyncIFoo::Finish_Bar()
        MEM_ITER    AsyncMemList( pAsyncIntf );
        AsyncMemList.Init();
        while ( ( pNodeProcItr = AsyncMemList.GetNext() ) != 0 )
            {
            node_call_as* pCallAs = ( node_call_as* )pNodeProcItr->GetAttribute( ATTR_CALL_AS );

            if ( pCallAs )
                {
                FixupCallAs( pCallAs, BeginProcList );
                pNodeProcItr = AsyncMemList.GetNext();
                // if Begin_* has [call_as] Finish_* has it too.
                pCallAs = ( node_call_as* )pNodeProcItr->GetAttribute( ATTR_CALL_AS );
                FixupCallAs( pCallAs, FinishProcList );
                }
            }
        }
    return pAsyncIntf;
    }


/****************************************************************************
 DuplicateNodeInterface:
    Duplicate an interface changing it's name from IFoo to AsyncIFoo and
    changing the [async_uuid] attribute to [uuid]
 ****************************************************************************/
node_interface*
DuplicateNodeInterface  (
                        node_interface*     pIntfSrc,
                        const char* const   szPrefix,
                        unsigned short      uPrefixLen
                        )
    {
    node_interface* pIntfDup = new node_interface;
    if ( pIntfDup ) 
        {
        *pIntfDup = *pIntfSrc;
        // new named_node get a new copy of the attributes
        pIntfDup->CopyAttributes( pIntfSrc );
        // members will be added later
        pIntfDup->SetFirstMember( 0 );

        // async interface inherits from base interface's async clone
        node_interface* pSrcBase = pIntfSrc->GetMyBaseInterface();
        if ( pSrcBase && pSrcBase->GetAsyncInterface() )
            {
            pIntfDup->SetMyBaseInterfaceReference   (
                                                    new node_interface_reference(
                                                        pSrcBase->GetAsyncInterface()
                                                                                )
                                                    );
            }

        // [async_uuid] becomes [uuid]
        node_guid* pAsyncGuid = (node_guid*) pIntfSrc->GetAttribute( ATTR_ASYNCUUID );
        char* szGuid = new char[strlen(pAsyncGuid->GetGuidString())+1];
        strcpy( szGuid, pAsyncGuid->GetGuidString() );
        pIntfDup->RemoveAttribute( ATTR_GUID );
        pIntfDup->RemoveAttribute( ATTR_ASYNCUUID );
        pIntfDup->SetAttribute( new node_guid( szGuid, ATTR_GUID ) );

        // IFoo becomes AsyncIFoo
        char* szName = new char[strlen(pIntfSrc->GetSymName())+uPrefixLen+1];
        strcpy( szName, szPrefix );
        strcat( szName, pIntfSrc->GetSymName() );
        pIntfDup->SetSymName( szName );

        // AsyncIFoo added to the list of interfaces
        pIntfDup->SetSibling( pIntfSrc->GetSibling() );
        pIntfSrc->SetSibling( pIntfDup );

        CurrentIntfKey = (unsigned short) pInterfaceDict->AddElement( pIntfDup );

        SymKey  SKey( pIntfDup->GetSymName(), NAME_DEF );
        named_node* pFound = pBaseSymTbl->SymSearch( SKey );
        if ( pFound )
            {
            pFound->SetChild( pIntfDup );
            }
        }
    return pIntfDup;
    }

/****************************************************************************
 DuplicateNodeProc
    Duplicate a node_proc and prefix it's name with the given string.
    Only the procedure node is duplicated, parameters are not set.
 ****************************************************************************/
node_proc*
DuplicateNodeProc   (
                    node_proc*          pProcSrc,
                    const char* const   szPrefix,
                    unsigned            uPrefixLen,
                    unsigned long       uInterfaceKey,
                    ITERATOR&           Itr
                    )
    {
    node_proc*  pProcDup = new node_proc( short( 0 ), true );
    // pProcSrc->CopyTo( pProcDup );
    *pProcDup = *pProcSrc;
    pProcDup->SetSibling( 0 );
    pProcDup->SetClientCorrelationCount();
    pProcDup->SetServerCorrelationCount();
    // new named_node get a new copy of the attributes
    pProcDup->CopyAttributes( pProcSrc );
    // members will be added later
    pProcDup->SetFirstMember( 0 );
    pProcDup->SetInterfaceKey( uInterfaceKey );
    char* szName = new char[strlen(pProcSrc->GetSymName())+uPrefixLen+1];
    strcpy( szName, szPrefix );
    strcat( szName, pProcSrc->GetSymName() );
    pProcDup->SetSymName( szName );
    ITERATOR_INSERT( Itr, pProcDup );
    return pProcDup;
    }

/****************************************************************************
 DuplicateNodeParam:
    Duplicate the given parameter and attach it to the given procedure.
 ****************************************************************************/
node_param*
DuplicateNodeParam  (
                    node_param*     pParamSrc,
                    node_proc*      pProc
                    )
    {
    node_param* pParamDup = new node_param;
    // pParamSrc->CopyTo( pParamDup );
    *pParamDup = *pParamSrc;
    pParamDup->SetSibling( 0 );
    // new named_node get a new copy of the attributes
    pParamDup->CopyAttributes( pParamSrc );
    pProc->AddLastMember( pParamDup );
    return pParamDup;
    }

/****************************************************************************
 FixupCallAs:
    When an async interface is created from a sync one the duplicated
    interface still points to stuff in the original interface.  Fix up [call_as]
    procs to point to the split procedures instead.
 ****************************************************************************/
void
FixupCallAs( node_call_as* pCallAs, ITERATOR& ProcList )
    {
    char*       szProcName = pCallAs->GetCallAsName();
    node_proc*  pProcItr = 0;

    ITERATOR_INIT( ProcList );
    while ( ITERATOR_GETNEXT( ProcList, pProcItr ) )
        {
        // advance past Begin_ or Finish_
        char*   szProcItrName = pProcItr->GetSymName();
        szProcItrName = strchr( szProcItrName, '_' );
        szProcItrName++;
        // semantic errors will be caught in node_proc::SemanticAnalysis()
        if ( !strcmp( szProcItrName, szProcName ) )
            {
            pCallAs->SetCallAsName( pProcItr->GetSymName() );
            pCallAs->SetCallAsType( pProcItr );
            break;
            }
        }
    }

/****************************************************************************
 FindInOnlyParamInExpr:
    Search an expression for an in-only parameter.
 ****************************************************************************/
node_skl*
FindInOnlyParamInExpr   (
                        expr_node*  pExpr
                        )
    {
    node_skl* pRet = 0;
    if ( pExpr )
        {
         if ( pExpr->IsAVariable() )
            {
            if ( !pExpr->GetType()->FInSummary( ATTR_OUT ) )
                pRet = pExpr->GetType();
            }
        else
            {
            pRet = FindInOnlyParamInExpr( pExpr->GetLeft() );
            if ( !pRet )
                {
                pRet = FindInOnlyParamInExpr( pExpr->GetRight() );
                }
            }        
        }
    return pRet;
    }

/****************************************************************************
 GetUnknownExpression:
    Determine if a given expression is a non-simple with in parameters.
    An expression is simple if it is NULL, a constant, or a single variable.
    An expression is also simple if it is of the form "var+1", "var-1", 
    "var*2", "var/2", or "*var" (these are simple because they can be
    expressed by directly in the correlation descriptor).

    If the expression is non-simple with in parameters, non-0 is returned,
    else 0 is returned.
 ****************************************************************************/
bool
IsSimpleExpression(
                expr_node*  pExpr
                )
    {
    if ( ! pExpr || pExpr->IsAVariable() || pExpr->IsConstant() )
        {
        return true;
        }

    expr_node*  pExprLHS = pExpr->GetLeft();
    expr_node*  pExprRHS = pExpr->GetRight();

    switch ( pExpr->GetOperator() )
        {
        case OP_SLASH:
        case OP_STAR:
            if ( pExprLHS->IsAVariable() &&
                     pExprRHS->IsConstant() &&
                     ((expr_constant *)pExprRHS)->GetValue() == 2 )
                {
                return true;
                }
            break;

        case OP_PLUS :
        case OP_MINUS :
            if ( pExprLHS->IsAVariable() &&
                     pExprRHS->IsConstant() &&
                     ((expr_constant *)pExprRHS)->GetValue() == 1 )
                {
                return true;
                }
            break;

        case OP_UNARY_INDIRECTION :
            if ( pExprLHS->IsAVariable() )
                {
                return true;
                }
            break;

       default:
            break;
        }

    return false;
    }

/****************************************************************************
 GetInOnlyParamPairedWithOut:
    Determine if any of the expression in the given parameter list mixes
    in and out parameters in non-simple ways.  Return non-0 if the do and 0
    if they don't.
 ****************************************************************************/
node_skl*
GetInOnlyParamPairedWithOut (
                            MEM_ITER&    MemParamList
                            )
    {
    named_node* pNodeParamItr = 0;
    node_skl* pNode  = 0;
    MemParamList.Init();
    while ( ( pNodeParamItr = (node_param *) MemParamList.GetNext() ) != 0 )
        {
        if ( !pNodeParamItr->GetAttribute( ATTR_OUT ) )
            {
            continue;
            }
        node_base_attr* pAttr;
        ATTRLIST        AList = pNodeParamItr->GetAttributeList(AList);
        ATTR_T          lastAttrID = ATTR_NONE;
        int             nAttrInstance = 0;
        bool            bFirstInstanceWasNull = false;
        bool            bHasInParam = false;

        for ( pAttr = AList.GetFirst(); NULL != pAttr && 0 == pNode; pAttr = pAttr->GetNext() )
            {
            ATTR_T  thisAttrID = pAttr->GetAttrID();

            if ( thisAttrID == lastAttrID )
                ++nAttrInstance;
            else
                nAttrInstance = 1;

            lastAttrID = thisAttrID;

            switch ( thisAttrID )
                {
                case ATTR_SIZE:
                case ATTR_LENGTH:
                case ATTR_SWITCH_IS:
                case ATTR_IID_IS:
                case ATTR_FIRST:
                case ATTR_LAST:
                case ATTR_MAX:
                case ATTR_MIN:
                    {
                    if ( 1 == nAttrInstance )
                        {
                        bFirstInstanceWasNull = ( NULL == pAttr->GetExpr() );
                        bHasInParam = false;
                        }

                    // Don't allow any dimensions after one with an in param
                    if ( bHasInParam )
                        {
                        pNode = (node_skl *) -1;
                        break;
                        }
                        
                    if ( FindInOnlyParamInExpr( pAttr->GetExpr() ) )
                        {
                        if ( ! IsSimpleExpression( pAttr->GetExpr() )
                             || ( nAttrInstance > 2 )
                             || ( nAttrInstance == 2 && ! bFirstInstanceWasNull ) )
                            {
                            pNode = (node_skl *) -1;
                            break;
                            }

                        bHasInParam = true;
                        }

                    break;
                    }
                   
                case ATTR_BYTE_COUNT:
                    {
                    pNode = ( ( node_byte_count* ) pAttr )->GetByteCountParam();
                    if ( pNode->FInSummary( ATTR_OUT ) )
                        {
                        pNode = 0;
                        }
                    break;
                    }

                default:
                    // Only need to worry about attributes with parameter
                    // expressions
                    break;
                }
            }

        if ( pNode )
            {
            // Do this to have an error message context.
            pNode = pNodeParamItr;
            break;
            }
        }

    return pNode;
    }

/****************************************************************************
 FixupFinishProcExpr:
    When an async interface is created from a sync one the duplicated
    interface still points to stuff in the original interface.  Fix up 
    parameters in a Finish method to point to the duplicated parameters
    in the async interface instead of the original sync interface.
 ****************************************************************************/
void
FixupFinishProcExpr (
                    expr_node*  pExpr
                    )
    {
    if ( pExpr )
        {
        // If we don't have a type then that means we have a reference to a
        // variable that doesn't exist.  The dangling reference will be caught
        // and reported in FIELD_ATTR_INFO::Validate

        if ( NULL == pExpr->GetType() )
            {
            return;
            }

        if ( pExpr->GetType()->NodeKind() == NODE_PARAM )
            {
            node_param* pParam = (node_param*)pExpr->GetType();
            if ( pParam->GetAsyncFinishSibling() )
                {
                pExpr->SetType( pParam->GetAsyncFinishSibling() );
                }
            else
                {
                pExpr->SetType( pParam->GetAsyncBeginSibling() );
                pParam->GetAsyncBeginSibling()->SaveForAsyncFinish();
                }
            }
        FixupFinishProcExpr( pExpr->GetLeft() );
        FixupFinishProcExpr( pExpr->GetRight() );
        // FixupFinishProcExpr( pExpr->GetRelational() );
        }
    }

/****************************************************************************
 FixupFinishProcExpr:
    When an async interface is created from a sync one the duplicated
    interface still points to stuff in the original interface.  Fix up 
    parameters in a Begin method to point to the duplicated parameters
    in the async interface instead of the original sync interface.
 ****************************************************************************/
void
FixupBeginProcExpr  (
                    expr_node*  pExpr
                    )
    {
    if ( pExpr )
        {
        // If we don't have a type then that means we have a reference to a
        // variable that doesn't exist.  The dangling reference will be caught
        // and reported in FIELD_ATTR_INFO::Validate

        if ( NULL == pExpr->GetType() )
            {
            return;
            }

        if ( pExpr->GetType()->NodeKind() == NODE_PARAM )
            {
            node_param* pParam = (node_param*)pExpr->GetType();
            pExpr->SetType( pParam->GetAsyncBeginSibling() );
            }
        FixupBeginProcExpr( pExpr->GetLeft() );
        FixupBeginProcExpr( pExpr->GetRight() );
        // FixupExpr( pExpr->GetRelational() );
        }
    }

/****************************************************************************
 FixupFinishProcExpr:
    When an async interface is created from a sync one the duplicated
    interface still points to stuff in the original interface.  This routine
    traverses the parameters and fixes up the pointers to point to the 
    proper stuff in the duplicated interface instead.

    This routine is quite specific to the needs of async and is not meant as
    a general purpose parameter traversing function.
 ****************************************************************************/
void
TraverseParamsAndExprs  (
                        MEM_ITER&    MemParamList,
                        void (*CallFunc)( expr_node* )
                        )
    {
    node_param* pNodeParamItr = 0;

    MemParamList.Init();
    while ( ( pNodeParamItr = ( node_param *) MemParamList.GetNext() ) != 0 )
        {
        node_base_attr* pAttr;
        ATTRLIST        AList = pNodeParamItr->GetAttributeList(AList);

        for ( pAttr = AList.GetFirst(); NULL != pAttr; pAttr = pAttr->GetNext() )
            {
            switch ( pAttr->GetAttrID() )
                {
                case ATTR_SIZE:
                case ATTR_LENGTH:
                case ATTR_SWITCH_IS:
                case ATTR_IID_IS:
                case ATTR_FIRST:
                case ATTR_LAST:
                case ATTR_MAX:
                case ATTR_MIN:
                    {
                    CallFunc( pAttr->GetExpr() );
                    break;
                    }
                    
                case ATTR_BYTE_COUNT:
                    {
                    node_param* pParam = ( ( node_byte_count* ) pAttr )->GetByteCountParam();
                    if ( FixupBeginProcExpr == CallFunc )
                        {
                        ( ( node_byte_count* ) pAttr )->SetByteCountParam( pParam->GetAsyncBeginSibling() );
                        }
                    else
                        {
                        if ( pParam->GetAsyncFinishSibling() )
                            {
                            ( ( node_byte_count* ) pAttr )->SetByteCountParam( pParam->GetAsyncFinishSibling() );
                            }
                        else
                            {
                            ( ( node_byte_count* ) pAttr )->SetByteCountParam( pParam->GetAsyncBeginSibling() );
                            pParam->GetAsyncBeginSibling()->SaveForAsyncFinish();
                            }
                        }
                    }

                default:
                    // Only need to worry about attributes with parameter
                    // expressions
                    break;
                }
            }
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\data.cxx ===
/*****************************************************************************
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: listhndl.cxx
Title				: general purpose list handler
					:
Description			: this file handles the general purpose list routines
History				:
	05-Aug-1991	VibhasC	Created

*****************************************************************************/
#if 0
							Notes
							-----

The MIDL compilers DGROUP is larger than 64K (remember, 10k of stack space
is allocated). To get around the link errors of DGROUP more than 64k, we 
allocate all data in a single file, and compile that file such that the
data segement is a different named data segment. This way, we need not
specify /Gt1 for every source file which has reasonably big data segments


NOTE: In order to search easily I enter the data items in sorted order of names

	  Please maintain this order

#endif // 0


#pragma warning ( disable : 4514 )

/****************************************************************************
	include files
 ****************************************************************************/


#include "nulldefs.h"
extern	"C"
	{
	#include <stdio.h>
	#include <stdlib.h>
	}
#include "allnodes.hxx"
#include "cmdana.hxx"
#include "filehndl.hxx"
#include "lextable.hxx"
#include "symtable.hxx"
#include "gramutil.hxx"
#include "control.hxx"
#include "treg.hxx"


/****************************************************************************
	general data declarations
 ****************************************************************************/

unsigned short 				CurrentIntfKey;
unsigned short				CurrentZp			= 0;
ATTR_SUMMARY				DisallowedAttrs[INTERNAL_NODE_END];
ATTR_SUMMARY				FieldAttrs;
BOOL						fPragmaImportOn	= FALSE;

BOOL						fNoLogo			= FALSE;
short						GrammarAct;
short						ImportLevel = 0;
TREGISTRY				*	pCallAsTable;
CMD_ARG					*	pCommand;
CCONTROL				*	pCompiler;
SymTable				*	pCurSymTbl;
SymTable				*	pBaseSymTbl;
node_error				*	pErrorTypeNode;
node_e_attr				*	pErrorAttrNode;
node_e_status_t			*	pError_status_t;
NFA_INFO				*	pImportCntrl;
LexTable				*	pMidlLexTable;
IDICT					*	pInterfaceDict;
node_pragma_pack		*	pPackStack;
PASS_1					*	pPass1;
PASS_2					*	pPass2;
PASS_3					*	pPass3;
pre_type_db				*	pPreAllocTypes;
node_source				*	pSourceNode;
nsa						*	pSymTblMgr;
SymTable				*	pUUIDTable;
ISTACK					*	pZpStack;
ATTR_SUMMARY				RedundantsOk;
char					*	Skl_bufstart		= 0;
char					*	Skl_bufend			= 0;
unsigned long				Skl_Allocations		= 0;
unsigned long				Skl_Bytes			= 0;
unsigned long				Skl_Deletions		= 0;
short						yysavestate;
IINFODICT				*	pInterfaceInfoDict;
BOOL						fRedundantImport = FALSE;
node_skl				*	pBaseImplicitHandle = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\acfattr.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: acfattr.cxx
Title				: the acf attribute handler
Description			: this file handles all the code connected to the acf
					: attribute handling
History				:
	02-Jan-1990	VibhasC	Create - Happy New Year !!
*****************************************************************************/

/*****************************************************************************
 * include files
 *****************************************************************************/

#pragma warning ( disable : 4514 )

#include "nulldefs.h"
extern "C"	{
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
}
#include "allnodes.hxx"
#include "cmdana.hxx"

/*****************************************************************************
 * local defines
 *****************************************************************************/

/*****************************************************************************
 * local data 
 *****************************************************************************/

/*****************************************************************************
 * extern data
 *****************************************************************************/

extern ATTR_VECTOR					AcfConflicts[ ][ ATTR_VECTOR_SIZE ];
extern CMD_ARG					*	pCommand;

/*****************************************************************************
 * local procs
 *****************************************************************************/

/*****************************************************************************
 * extern procs
 *****************************************************************************/
 extern void						ParseError( STATUS_T, char * );
 


node_implicit::node_implicit(
	node_skl	*	pType,
	node_id		*	pID ) : acf_attr( ATTR_IMPLICIT )
	{
	pHandleID	= pID;
	pID->SetEdgeType( EDGE_USE );
	pID->SetChild( pType );
	pHandleType	= pType;
	}

void
node_implicit::ImplicitHandleDetails(
	node_skl	**	ppType,
	node_id		**	ppID )
	{
	(*ppID)		= pHandleID;
	(*ppType)	= pHandleType;
	}

BOOL
node_implicit::IsHandleTypeDefined()
	{
	return ( pHandleType && 
			 ( pHandleType->NodeKind() != NODE_FORWARD) );
	}


OPT_LEVEL_ENUM
ParseAcfOptimizationAttr(
    char *              pOptString,
    unsigned short *    pOptFlags )
/*
    Before the /target switch was introduced, we had the following
    optimization switches (up to beta2 for NT40):
        -Os   size                        from NT 3.5 (always available)
        -Oi   old interpreter             from NT 3.5 (always available)
        -Oi1  -Oi w/stubless obj client   from NT 3.51
        -Oi2  new interpreter             from NT 4.0
*/
{
    unsigned short  OptFlags = pCommand->GetOptimizationFlags(); 
    OPT_LEVEL_ENUM  OptLevel = pCommand->GetOptimizationLevel();

    if ( strcmp( pOptString, "i" ) == 0 )
        {
        OptLevel = OPT_LEVEL_OI;
        }
    else if ( strcmp( pOptString, "ic" ) == 0 )
        {
        OptLevel = OPT_LEVEL_OIC;
        }
    else if ( strcmp( pOptString, "i1" ) == 0 )
        {
        ParseError( OI1_PHASED_OUT, "i1");
        OptLevel = OPT_LEVEL_OIC;
        }
    else if ( strcmp( pOptString, "icf" ) == 0  ||
              strcmp( pOptString, "if" ) == 0  )
        {
        OptLevel = OPT_LEVEL_OICF;
        }
    else if ( strcmp( pOptString, "i2" ) == 0 )
        {
        ParseError( OI2_OBSOLETE, "i2");
        OptLevel = OPT_LEVEL_OICF;
        }
    else if ( strcmp( pOptString, "s" ) == 0 )
        {
        if ( pCommand->NeedsNDR64Run() )
            ParseError( OS_IN_NDR64, "" );

        OptLevel = OPT_LEVEL_OS;
        }
    else
        ParseError( ILLEGAL_ARG_VALUE, pOptString );

    switch ( OptLevel )
        {
        case OPT_LEVEL_OS:
            OptFlags = OPTIMIZE_SIZE;
            break;

    // Force Oi and Oic to mean Oicf for 64b platforms.

        case OPT_LEVEL_OI:
            if ( pCommand->Is64BitEnv() )
                { 
                ParseError( WIN64_INTERPRETED, "-Oicf for -Oi" );
                OptFlags = OPTIMIZE_ALL_I2_FLAGS;
                }
            else
                OptFlags = OPTIMIZE_INTERPRETER;
            break;

        case OPT_LEVEL_OIC:
            if ( pCommand->Is64BitEnv() )
                { 
                ParseError( WIN64_INTERPRETED, "-Oicf for -Oic" );
                OptFlags = OPTIMIZE_ALL_I2_FLAGS;
                }
            else
                OptFlags = OPTIMIZE_ALL_I1_FLAGS;

            break;

        case OPT_LEVEL_OICF:
            OptFlags = OPTIMIZE_ALL_I2_FLAGS;
            break;
        }

    *pOptFlags = OptFlags;

    return OptLevel;
}

/*****************************************************************************
 * utility routines
 *****************************************************************************/
short
CheckValidAllocate(
	char	*	pAllocID )
	{
static char *ValidAllocates[] = {
	 "single_node"
	,"all_nodes"
	,"dont_free"
	,"free"
	,"all_nodes_aligned"
	,(char *)0
};
static short AllocateValues[] = {
	 ALLOCATE_SINGLE_NODE
	,ALLOCATE_ALL_NODES
	,ALLOCATE_DONT_FREE
	,ALLOCATE_FREE
	,ALLOCATE_ALL_NODES_ALIGNED
};
	char	*	pSearch;
	int			i		= 0;

	while( ( pSearch = ValidAllocates[i] ) != 0 )
		{
		if( !strcmp( pSearch, pAllocID ) )
			return AllocateValues[ i ];
		++i;
		}

	ParseError( INVALID_ALLOCATE_MODE, pAllocID );
	return 0;
	}

/*****************************************************************************
 * clone routines
 *****************************************************************************/

node_base_attr *	node_optimize::Clone()
							{
							node_optimize	*	pNew = new node_optimize( this );
							return pNew;
							}
node_base_attr *	node_ptr_size::Clone()
							{
							node_ptr_size	*	pNew = new node_ptr_size( this );
							return pNew;
							}

node_base_attr *	node_implicit::Clone()
							{
							node_implicit	*	pNew = new node_implicit( this );
							return pNew;
							}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\dict.cxx ===
/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                  Copyright(c) Microsoft Corp., 1990-1999

          RPC - Written by Dov Harel


    This file contains the implementation for splay tree self
    adjusting binary trees
-------------------------------------------------------------------- */

#pragma warning ( disable : 4514 )

#include "dict.hxx"

// Handy macros used to define common tree operations.
// Dummy is a member of the Dictionary now, not a global.

#define ROTATELEFT  tmp=t->right; t->right=tmp->left;  tmp->left =t; t=tmp
#define ROTATERIGHT tmp=t->left;  t->left =tmp->right; tmp->right=t; t=tmp

#define LINKLEFT  tmp=t; t = t->right; l = l->right = tmp
#define LINKRIGHT tmp=t; t = t->left;  r = r->left = tmp

#define ASSEMBLE r->left = t->right;     l->right = t->left; \
         t->left = Dummy->right; t->right = Dummy->left


// initialize the memory allocator for TreeNode

FreeListMgr
TreeNode::MyFreeList( sizeof ( TreeNode ) );

//*************************************************************************
//*****       Core functions (internal)               *****
//*************************************************************************

SSIZE_T                  // return last comparision
Dictionary::SplayUserType(        // general top down splay

    pUserType keyItem    // pointer to a "key item" searched for

) //-----------------------------------------------------------------------//
{
    TreeNode*   t;      // current search point
    TreeNode*   l;      // root of "left subtree" < keyItem
    TreeNode*   r;      // root of "right subtree" > keyItem
    SSIZE_T     kcmp;   // cash comparison results
    TreeNode*   tmp;

    if ((fCompare = Compare(keyItem, root->item)) == 0)
    return (fCompare);

    Dummy = l = r = &Dumbo;
    Dumbo.left = Dumbo.right = Nil;

    t = root;

    do {
    if ( fCompare < 0 ) {
     if ( t->left == Nil ) break;

     if ( (kcmp = Compare(keyItem, t->left->item)) == 0 ) {
        LINKRIGHT;
     }
     else if ( kcmp < 0 ) {
                ROTATERIGHT;
        if ( t->left != Nil ) {
         LINKRIGHT;
        }
     }
            else { // keyItem > t->left->item
                LINKRIGHT;
        if ( t->right != Nil ) {
         LINKLEFT;
        }
     }
    }
        else { // keyItem > t->item
     if ( t->right == Nil ) break;

     if ( (kcmp = Compare(keyItem, t->right->item)) == 0 ) {
        LINKLEFT;
     }
     else if ( kcmp > 0 ) {
                ROTATELEFT;
        if ( t->right != Nil ) {
         LINKLEFT;
        }
     }
            else { // keyItem < t->right->item
                LINKLEFT;
        if ( t->left != Nil ) {
         LINKRIGHT;
        }
     }
        }
    } while ( (fCompare = Compare(keyItem, t->item)) != 0 );

    ASSEMBLE;

//  if (fCompare != Compare(keyItem, t->item))
//    printf("Dictionary error!");

    root = t;
    return(fCompare);
}

//-----------------------------------------------------------------------

TreeNode *
Dictionary::SplayLeft(
    TreeNode * t )          // root of tree & current "search" point
{
    TreeNode *  l = Dummy;  // root of "left subtree" < keyItem
    TreeNode *  r = Dummy;  // root of "right subtree" > keyItem
    TreeNode *  tmp;

    if (t == Nil || t->left == Nil)
    return(t);

    if (t->left->left == Nil) {
    ROTATERIGHT;
    return(t);
    }

    Dummy->left = Dummy->right = Nil;

    while ( t->left != Nil ) {
        ROTATERIGHT;

    if ( t->left != Nil ) {
     LINKRIGHT;
    }
    }
    ASSEMBLE;
    return(t);
}

#ifndef DICT_NOPREV

//-----------------------------------------------------------------------

TreeNode *
Dictionary::SplayRight(
    TreeNode * t )          // root of tree & current "search" point
{
    TreeNode *  l = Dummy;  // root of "left subtree" < keyItem
    TreeNode *  r = Dummy;  // root of "right subtree" > keyItem
    TreeNode *  tmp;

    if (t == Nil || t->right == Nil)
    return(t);

    Dummy->left = Dummy->right = Nil;

    while ( t->right != Nil ) {
        ROTATELEFT;

    if ( t->right != Nil ) {
     LINKLEFT;
    }
    }
    ASSEMBLE;
    return(t);
}

#endif



// Class methods for Splay Tree

Dict_Status
Dictionary::Dict_Find(     // return a item that matches

    pUserType itemI        // this value

  // Returns:
  //   itemCur - Nil if at not in Dict, else found item
) //-----------------------------------------------------------------------//
{
    itemCur = Nil;

    if (root == Nil)
    return (EMPTY_DICTIONARY);

    if (itemI == Nil)
    return (NULL_ITEM);

    if (SplayUserType (itemI) == 0){

    itemCur = root->item;
    return(SUCCESS);
    }
//  printf("After NotFound %ld: (", this); PrintItem(itemI); printf(")\n"); Dict_Print();
    return(ITEM_NOT_FOUND);
}

#ifndef DICT_NONEXT

Dict_Status
Dictionary::Dict_Next(        // return the next item

    pUserType itemI        // of a key greater then this

  // Returns:
  //   itemCur - Nil if at end of Dict, else current item
) //-----------------------------------------------------------------------//
{
    TreeNode* t;

    itemCur = Nil;

    if (root == Nil)
    return (EMPTY_DICTIONARY);

    if (itemI == Nil) {         // no arg, return first record
    root = SplayLeft (root);

    itemCur = root->item;
        return (SUCCESS);
    }

    if (itemI != root->item)

    if (SplayUserType (itemI) > 0) {
     itemCur = root->item;
     return (SUCCESS);
    }

    if (root->right == Nil)
    return (LAST_ITEM);

    t = root;

    root = SplayLeft (root->right);
    root->left = t;
    t->right = Nil;

    itemCur = root->item;
    return (SUCCESS);
}
#endif // DICT_NONEXT

#ifndef DICT_NOPREV

Dict_Status
Dictionary::Dict_Prev(        // return the previous item

    pUserType itemI        // of a key less then this

  // Returns:
  //   itemCur - Nil if at begining of Dict, else current item
) //-----------------------------------------------------------------------//
{
    TreeNode* t;

    itemCur = Nil;

    if (root == Nil)
    return (EMPTY_DICTIONARY);

    if (itemI == Nil) {         // no arg, return last record
    root = SplayRight (root);

    itemCur = root->item;
        return (SUCCESS);
    }

    if (itemI != root->item)

    if (SplayUserType (itemI) < 0) {
     itemCur = root->item;
     return (SUCCESS);
    }

    if (root->left == Nil)
    return (LAST_ITEM);

    t = root;
    root = SplayRight (root->left);
    root->right = t;
    t->left = Nil;

    itemCur = root->item;
    return (SUCCESS);
}

#endif // DICT_NOPREV

Dict_Status
Dictionary::Dict_Insert(        // insert the given item into the tree

    pUserType itemI        // the item to be inserted

  // Returns:
  //  itemCur - point to new item
) //-----------------------------------------------------------------------//
{
    TreeNode *newNode, *t;

    if ((itemCur = itemI) == Nil)
    return (NULL_ITEM);

    if (root == Nil) {
    root = new TreeNode(itemI);
        size++;
        return (SUCCESS);
    }

    if (SplayUserType (itemI) == 0)
        return (ITEM_ALREADY_PRESENT);

    newNode = new TreeNode(itemI);
    size++;

    t = root;

    if (fCompare > 0) {
    newNode->right = t->right;    //  item >= t->item
    newNode->left = t;
    t->right = Nil;
    }
    else {
    newNode->left = t->left;
    newNode->right = t;
    t->left = Nil;
    }
    root = newNode;

//  printf("After Insert %ld: (", this); PrintItem(itemI); printf(")\n"); Dict_Print();
    return (SUCCESS);
}


Dict_Status
Dictionary::Dict_Delete(    // delete the given item from the tree

    pUserType *itemI        // points to the (key) item to be deleted

  // Returns:
  //   itemCur is Nil - undefined
) //-----------------------------------------------------------------------//
{
    TreeNode *t, *r;

    itemCur = Nil;

    if (root == Nil)
    return (EMPTY_DICTIONARY);

    if (itemI == Nil)
    return (NULL_ITEM);

    if (itemI != root->item) {

    if (SplayUserType (*itemI) != 0)
     return(ITEM_NOT_FOUND);
    }

    *itemI = root->item;
    t = root;

    if (t->left == Nil)
        root = t->right;

    else if ( (r = t->right) == Nil)
        root = t->left;

    else {
    r = SplayLeft (r);
    r->left = t->left;    // at this point r->left == Nil
        root = r;
    }

    delete t;
    size--;

    return (SUCCESS);
}


pUserType        
Dictionary::Dict_Delete_One()
{
    TreeNode     *    pCurrent    = root;
    TreeNode    *    pPrev        = NULL;        // NULL indicates prev is root
    pUserType        pResult;
    BOOL            fLeft = FALSE;

    while ( pCurrent )
        {
        if ( pCurrent->left )
            {
            pPrev        = pCurrent;
            pCurrent    = pCurrent->left;
            fLeft         = TRUE;
            continue;
            }

        if ( pCurrent->right )
            {
            pPrev        = pCurrent;
            pCurrent    = pCurrent->right;
            fLeft        = FALSE;
            continue;
            }

        // found a leaf
        break;
        }

    // we are now at a leaf (or tree empty)
    if ( !pCurrent )
        return NULL;

    // unhook from parent
    if ( pPrev )
        {
        if ( fLeft )
            pPrev->left        = NULL;
        else
            pPrev->right    = NULL;
        }
    else
        root    = NULL;

    // return the item, and delete the treenode
    pResult    = pCurrent->item;
    delete pCurrent;
    size--;
    return pResult;
}

short
Dictionary::Dict_GetList( 
    gplistmgr & ListIter )
{
    pUserType        pN;
    Dict_Status        Status;
    short            Count = 0;

    // Get to the top of the dictionary.

    Status    = Dict_Next( (pUserType)0 );

    // make sure we start with a clean iterator
    ITERATOR_DISCARD( ListIter );

    // Iterate till the entire dictionary is looked at.

    while( SUCCESS == Status )
        {
        pN    = Dict_Curr_Item();
        ListIter.Insert( pN );
        Count++;
        Status = Dict_Next( pN );
        }

    return Count;
}

// Utility functions to print of a tree

#ifndef DICT_NOPRINT

static indentCur;
static PrintFN printCur;

static char spaces[] =
"                                                                           ";

void
Dictionary::PrinTree(        // recursively print out a tree
    int lmargin,    // current depth & margen
    TreeNode *np    // subtree to print

) //-----------------------------------------------------------------------//
{
    if (np == Nil)
       return;

    PrinTree(lmargin+indentCur, np->right);

    if (lmargin > sizeof(spaces))
    lmargin = sizeof(spaces);;

    spaces[lmargin] = 0;
    printf(spaces);
    spaces[lmargin] = ' ';

    Print(np->item);
    printf("\n");

    PrinTree(lmargin+indentCur, np->left);

}

void
Dictionary::Dict_Print(
long indent

  // prints the binary tree (indented right subtree,
  // followed by the root, followed by the indented right dubtree)
) //-----------------------------------------------------------------------//
{
    indentCur = indent;

    PrinTree(0, root);
}

#endif // DICT_PRINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\filehndl.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: filehndl.cxx
Title				: file i/o handler for the MIDL compiler. Handles nested
					: file accessing, preprocessed file handling etc
Description			: Used by the compiler for handling import files, pre-
					  processing of files etc
History				:
	25-Aug-1990	VibhasC	Create
	26-Aug-1990	VibhasC	Add functionality

*****************************************************************************/

#pragma warning ( disable : 4514 )

/****************************************************************************
 ***		local defines
 ***************************************************************************/


#define MAX_LINE_LENGTH			(256)
#define INTERMEDIATE_EXT		("._i")
#define SMART_INCLUDE_STRING	("smart_include")

/****************************************************************************
 ***		include files
 ***************************************************************************/
#include "nulldefs.h"
extern	"C"	
	{
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	
	#include <process.h>
	#include <ctype.h>
	#include <errno.h>
	#include <malloc.h>
	#include <fcntl.h>
	#include <sys\types.h>
	#include <sys\stat.h>
	#include <io.h>
	#include <share.h>
	}
#include "common.hxx"
#include "errors.hxx"
#include "filehndl.hxx"
#include "cmdana.hxx"
#include "control.hxx"
#include "linenum.hxx"
#include "midlvers.h"

/****************************************************************************
 ***		public data
 ***************************************************************************/

short  		DebugLine = 0;
char	*	pDebugFile;
int			StdoutSave = -1;
int			StderrSave = -1;
FILE 	*	pNullFile  = NULL;

/****************************************************************************
 ***		extern procs
 ***************************************************************************/

extern void			StripSlashes( char * );
extern void			ChangeToForwardSlash( char *, char * ); 
extern STATUS_T		CreateFullPathAndFName( char *, char **, char ** );
extern "C" long     __stdcall    GetTempPathA( long, char * );
extern "C" long     __stdcall    GetTempFileNameA( const char*, const char*, unsigned int, char * );


/****************************************************************************
 ***		extern data
 ***************************************************************************/

extern CCONTROL	*	pCompiler;
extern CMD_ARG	*	pCommand;
extern short		curr_line_G;
extern FILE		*	hFile_G;
extern BOOL			fRedundantImport;


/*** _nfa_info *************************************************************
 * Purpose	: constructor for the _nfa_info class
 * Input	: nothing
 * Output	:
 * Notes	: Initialize
 ***************************************************************************/
_nfa_info::_nfa_info( void )
	{

	BOOL	fMinusIDefined		= pCommand->IsSwitchDefined(SWITCH_I);
	BOOL	fNoDefIDirDefined	= pCommand->IsSwitchDefined(SWITCH_NO_DEF_IDIR);
	char *	pDefault			= ".";
	char *	pEnv				= (char *)0;
	char *	pIPaths				= (char *)0;
	char *	p1					= (char *)0;
	char *	p2					= (char *)0;
	char *	p3					= (char *)0;

	/***
	 *** init
	 ***/

	pFileList			= 0;
	pPathList			= (PATH_LIST *)NULL;
	pStack = pStackFirst= (IN_STACK_ELEMENT *)NULL;
	iCurLexLevel		= 0;
	Flags.fPreProcess	= 0;
	Flags.fFileSet		= 0;
	Flags.fEOI			= 0;
	Flags.fBaseFileName= 0;
	Flags.fInInclude	= 0;

	// macro expansion handling

	pTextDict			= new ISTACK( 10 );



	// init the search paths. If the -no_def-idir switch is defined, then
	// dont set the default paths. But if the -no_def_idir switch IS defined,
	// then if the -I switch is not found, set the current path to .

	if ( fMinusIDefined )
		pIPaths		= pCommand->GetMinusISpecification();

	if ( ( pEnv  = getenv( "INCLUDE" ) ) == 0 )
		pEnv = getenv( "include" );

	//
	// make a copy of this because we will be doing strtoks on this.
	//

	if( pEnv )
		{
		// use p1 as temp;
		p1	= new char [ strlen( pEnv ) + 1 ];
		strcpy( p1, pEnv );
		pEnv = p1;
		}

	p1	= pDefault;
	p2	= pIPaths;
	p3	= pEnv;

	if( fNoDefIDirDefined && fMinusIDefined )
		{
		p1	= p3 = (char *)0;
		}
	else if( fNoDefIDirDefined && !fMinusIDefined )
		{
		p2 = p3 = (char *)0;
		}
	else if( !fNoDefIDirDefined && !fMinusIDefined )
		{
		p1	= pDefault;
		p2	= (char *)0;
		p3	= pEnv;
		}

	SetSearchPathsInOrder( p1, p2, p3 );

	if( pIPaths ) delete pIPaths;

	//
	// we have made a copy of the env variable, so we can delete this copy
	// now.
	//

	if( pEnv ) delete pEnv;

	}
void
_nfa_info::Init()
	{

	CMD_ARG	*	pCommandProcessor = pCompiler->GetCommandProcessor();

	// set preprocessing on or off depending upon the need

	if( !pCommandProcessor->IsSwitchDefined( SWITCH_NO_CPP ) )
		SetPreProcessingOn();

	}

void
_nfa_info::SetSearchPathsInOrder(
	char	*	p1,
	char	*	p2,
	char	*	p3 )
	{
	if( p1 )
		RegisterIt( p1 );
	if( p2 )
		RegisterIt( p2 );
	if( p3 )
		RegisterIt( p3 );
	}

void
_nfa_info::RegisterIt(
	char	*	pPath
	)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	register command paths.

 Arguments:

	pPath	-	pointer to path bein registered.

 Return Value:

	None.

 Notes:

	We expect the path components to be separated by a ';'. register those
	with the import controller. This function must become part of the import
	controller class.

----------------------------------------------------------------------------*/
	{
#define TOKEN_STRING (";")

	char	*	pToken = strtok( pPath, TOKEN_STRING );

	if( pToken )
		{
		SetPath( pToken );

		while ( ( pToken = strtok( 0, TOKEN_STRING ) ) != 0 )
			{
			SetPath( pToken );
			}
		}
	}

void
_nfa_info::RegisterTextSubsObject( TEXT_BUFFER* )
	{
	MIDL_ASSERT(0);
	}

_nfa_info::~_nfa_info()
	{
	EndOperations();
	}

/*** GetLexLevel **********************************************************
 * Purpose	: to return the current lexical level of the nfa
 * Input	: nothing
 * Output	: current lexical level
 * Notes	:
 **************************************************************************/
short
NFA_INFO::GetLexLevel( void )
	{
		return iCurLexLevel;
	}

/*** PushLexLevel **********************************************************
 * Purpose	: push lexical level in preparation of a new input file
 * Input	: nothing
 * Output	: 0 if all is well, error otherwise.
 * Notes	: 
 **************************************************************************/
short
NFA_INFO::PushLexLevel ( void )
	{

	// if an attempt to push the lexical level without opening any file
	// at that level was made, assert

	MIDL_ASSERT( Flags.fFileSet == 1 );

	// if we are in a deep imports heirarchy,
	// close the current file, record its position so that we can start
	// reading at the same place when we come back to it on a poplexlevel

	if ( iCurLexLevel > 12 )
		{
		pStack->ulPos		= ftell( pStack->hFile );
		fclose(pStack->hFile);
		pStack->fOpen		= 0;
		}
	Flags.fFileSet		= 0;
	iCurLexLevel++;
	return 0;
	}

/*** PopLexLevel **********************************************************
 * Purpose	: pop the lexical level
 * Input	: nothing
 * Output	: returns STATUS_OK if all is well.Error otherwise
 *	Notes	: pop involves, re-opening the input file, if it was closed
 *			: retsoring the input file handle back, deleting the stack
 *			: element for that lexical level.
 *************************************************************************/
STATUS_T
NFA_INFO::PopLexLevel( void )
	{

	IN_STACK_ELEMENT *	pCurStack;
	char			 *	pName;

	MIDL_ASSERT( iCurLexLevel > 0 );

	//
	// remove the current stack level, by closing the file at that 
	// level and deleting the stack element. reduce the current lexical
	// level by one
	// 

	iCurLexLevel--;

	if( ! pStack->fRedundantImport )
		{
		EndOneOperation( pStack );
		}
	else	// close the nul file
		{
//		if ( pStack->hFile && pStack->fOpen && )
//			fclose( pStack->hFile );
		}

	pCurStack = pStack	= pStack->pPrev;
	delete pStack->pNext;
	pStack->pNext		= (IN_STACK_ELEMENT *)NULL;

	//
	//  if the file at this lexical level is closed, open it
	// 

	pName = pStack->pName;

	if( !pStack->fOpen )
		{

		if( (pStack->hFile = fopen( pStack->pIFileName, "rb" )) == (FILE *)NULL)
			{
			RpcError((char *)NULL, 0, INPUT_OPEN, pName);
			return INPUT_OPEN;
			}
		if ( !pStack->pBuffer )
			pStack->pBuffer = new char [MIDL_RD_BUFSIZE];
		setvbuf( pStack->hFile, pStack->pBuffer,_IOFBF, MIDL_RD_BUFSIZE );

		// restore the system-wide file handle

		pStack->fOpen	= 1;

		// the input file is open now, position it to where it was before
		// we changed current lexical level

		if( fseek( pStack->hFile, pStack->ulPos, SEEK_SET) )
			{
			RpcError((char *)NULL, 0, INPUT_READ, pName);
			return INPUT_READ;
			}
		
		}

	// update the line number information, and set current file
	curr_line_G = pStack->uLine;
	hFile_G = pStack->hFile;
	AddFileToDB( pName );

	// everything is fine , lets go
	return STATUS_OK;

	}
STATUS_T
NFA_INFO::EndOperations()
	{
	IN_STACK_ELEMENT * pS	= pStackFirst;

	while( pStackFirst = pS )
		{
		EndOneOperation( pS );
		pS	= pS->pNext;
		delete pStackFirst;
		}
	pStackFirst = pStack = (IN_STACK_ELEMENT *)0;
	Flags.fFileSet		= 0;
	return STATUS_OK;
	}

STATUS_T
NFA_INFO::EndOneOperation( IN_STACK_ELEMENT * pSElement)
	{
	BOOL	fSavePP	= pCommand->IsSwitchDefined( SWITCH_SAVEPP );

	if( pSElement && pSElement->hFile )
		{
		fclose( pSElement->hFile );
		if( Flags.fPreProcess  && !fSavePP )
			{
			MIDL_UNLINK( pSElement->pIFileName );
			delete pSElement->pIFileName;
			}
		if( pSElement->pMIFileName && !fSavePP )
			{
			MIDL_UNLINK( pSElement->pMIFileName );
			delete pSElement->pMIFileName;
			}
		}
	return STATUS_OK;
	}

/*** SetNewInputFile *******************************************************
 * Purpose	: to set the input file to a new one
 * Input	: pointer to the new input file name
 * Output	: STATUS_OK if all is ok, error otherwise.
 * Notes	:
 **************************************************************************/
#define _MAX_FILE_NAME (_MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT)

STATUS_T
NFA_INFO::SetNewInputFile(
	char *pFullInputName)
	{
	FILE			*hFile = (FILE *)NULL;
	STATUS_T 		uError;
	IN_STACK_ELEMENT	*pStackCur = pStack;
	char			agNameBuf[ _MAX_FILE_NAME + 1];
	char			agDrive[_MAX_DRIVE];
	char			agPath[_MAX_DIR];
	char			agName[_MAX_FNAME];
	char			agExt[_MAX_EXT];
	char			*pPath;
	char			*pIFileName = (char *)NULL,
					*pMIFileName = (char *) NULL;
	char			*pFullName	= new char[ strlen( pFullInputName ) + 1];

	// make sure everything opened in binary mode
	_fmode = _O_BINARY;

	//
	// if the filename has any forward slashes, change them to back-slashes.
	//

	ChangeToForwardSlash( pFullInputName, pFullName ); 

	// if we have seen this file before, do not process it again, just return
	// an error

	if( IsDuplicateInput( pFullName ) )
		{
		pStack	= new IN_STACK_ELEMENT;
		if(pStackCur)
			{
			pStackCur->pNext	= pStack;
			pStack->pPrev		= pStackCur;
			pStackCur->uLine	= curr_line_G;
			}
		else
			{
			pStack->pPrev		= (IN_STACK_ELEMENT *)NULL;
			pStackFirst			= pStack;
			}
		pStack->pNext		= (IN_STACK_ELEMENT *)NULL;
		pStack->fNewLine	= 0;
		pStack->fRedundantImport	= 1;
		fRedundantImport = 1;

		// make the next read get eof
		if ( !pNullFile )
			{
			pNullFile = fopen("nul", "rb");
			hFile = 0;
			}
			 
		// fseek(hFile, 0, SEEK_END );
		pStack->fOpen		= 1;
		pStack->fShadow		= 0;
		pStack->ulPos		= 
		pStack->uShadowLine	= 0;
	
		curr_line_G		= 1;

		pStack->pShadowName = 
		pStack->pName		= pFullName;
		pStack->pIFileName	= pIFileName;
		pStack->hFile		= hFile;
		hFile_G				= pNullFile;
		Flags.fFileSet		= 1;
		return STATUS_OK;
		}

	// We need to find details of the file name. We need to see if the user
	// has already specified path, if so, override the current paths.
	// if the user has specified a file extension, get the extension. We
	// need to do that in order to have uniformity with the case where
	// a preprocessed file is input with a different extension

	_splitpath( pFullName, agDrive, agPath, agName, agExt );
//	fprintf( stdout, "Processing %s:\n", pFullName);

	// if file is specified with a path, the user knows fully the location
	// else search for the path of the file

	pPath = agPath;
	if( !*pPath && !agDrive[0] )
		{
		sprintf(agNameBuf, "%s%s", agName, agExt);
		if( (pPath = SearchForFile(agNameBuf)) == (char *)NULL)
			{
			RpcError((char *)NULL, 0, INPUT_OPEN, agNameBuf);
			return INPUT_OPEN;
			}
		strcpy(agPath, pPath);
		}
	else
		{
		// there is a path specification, which we must tag to this name
		// for all subsequent accesses to the file although it should not 
		// be considered as part of the list of paths the user gave.
		// Remember, in our file list we store the paths too

		pPath	= new char[ strlen(agPath) + 1];
		strcpy( pPath, agPath );
		}

	// do we need to preprocess the file ?

    if ( pCommand->Is64BitEnv() )
    	fprintf( stdout, "64 bit " );
	fprintf( stdout, "Processing " );

	if( agDrive[0] )
		fprintf( stdout, "%s", agDrive );
	if( agPath[0] )
		fprintf( stdout, "%s", agPath );
	if( agName[0] )
		fprintf( stdout, "%s", agName );
	if( agExt[0] )
		fprintf( stdout, "%s", agExt );
	fprintf( stdout, "\n" );

	fflush( stdout );

	if (Flags.fPreProcess)
		{
		if ( ( uError = PreProcess( agDrive, agPath, agName, agExt, pIFileName) ) != 0 )
			return uError;
		}
	else  // if no_cpp...
		{
		pIFileName = new char [ strlen( agDrive ) + 
								strlen( agPath ) +
								strlen( agName ) +
								strlen( agExt ) + 2 ];
		strcpy( pIFileName, agDrive );
		strcat( pIFileName, agPath);
		if( agPath[0] &&  (agPath[ strlen(agPath)-1 ] != '\\'))
			strcat(pIFileName,"\\");
		strcat( pIFileName, agName );
		strcat( pIFileName, agExt );
		}

	
	if( (hFile = fopen(pIFileName, "rb")) == (FILE *)NULL)
		{
		// error obtained while reading file, return the error

		RpcError((char *)NULL, 0, INPUT_OPEN, pIFileName);
		return INPUT_OPEN;
		}

	// file was sucessfully opened, initialize its info

	// if a file has not been set at this nested level , a stack element 
	// must be allocated for it. else the current file must be closed
	
	if( ! Flags.fFileSet )
		{
		pStack	= new IN_STACK_ELEMENT;
		if(pStackCur)
			{
			pStackCur->pNext	= pStack;
			pStack->pPrev		= pStackCur;
			pStackCur->uLine	= curr_line_G;
			}
		else
			{
			pStack->pPrev		= (IN_STACK_ELEMENT *)NULL;
			pStackFirst			= pStack;
			}
		pStack->pNext		= (IN_STACK_ELEMENT *)NULL;
		pStack->fNewLine	= 1;
		Flags.fFileSet		= 1;
		}
	else
		{
		// file was set. That means input was coming from a file. Close
		// that file.
		fclose(pStack->hFile);
		}

	if ( !pStack->pBuffer )
		pStack->pBuffer = new char [MIDL_RD_BUFSIZE];
	setvbuf( hFile, pStack->pBuffer,_IOFBF, MIDL_RD_BUFSIZE );

	pStack->fOpen		= 1;
	pStack->fRedundantImport	= 0;
	fRedundantImport 	= 0;
	pStack->fShadow		= 0;
	pStack->uShadowLine	= 0;

	curr_line_G		= 1;

	pStack->pShadowName = 
	pStack->pName		= pFullName;
	pStack->pIFileName	= pIFileName;
	pStack->pMIFileName	= pMIFileName;
	pStack->hFile		= hFile;
	hFile_G				= hFile;

	// update the line number information, and set current file
	AddFileToDB( pFullName );

	// add the file to the list of files that we have seen

	AddFileToFileList(pFullName, pPath);
	return STATUS_OK;
	}

/*** SetLineFilename ******************************************************
 * Purpose	: to add filename to the list of files we have input from
 * Input	: filename to add to the list of files, file path
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	:
 ****************************************************************************/
void
NFA_INFO::SetLineFilename(
	char *	pFName
	)
{
	if(strcmp(pFName, pStack->pName) != 0)
		{
		pStack->pName = new char[strlen( pFName ) + 1 ];
		strcpy(pStack->pName, pFName);
		
		// update the line number information, and set current file
		AddFileToDB( pStack->pName );

		}
}


/*** AddFileToFileList ******************************************************
 * Purpose	: to add filename to the list of files we have input from
 * Input	: filename to add to the list of files, file path
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	:
 ****************************************************************************/
STATUS_T
NFA_INFO::AddFileToFileList(
	char 	*pName ,
	char	*pPath )
	{
	FNAME_LIST	*pList	= pFileList;
	FNAME_LIST	*pTemp;
	char		agNameBuf[ _MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT+1];
	char *		pN;
	char *		pP;
	STATUS_T	Status;
	char			agDrive[_MAX_DRIVE];
	char			agPath[_MAX_DIR];
	char			agName[_MAX_FNAME];
	char			agExt[_MAX_EXT];
	BOOL		fNameHadNoPath = FALSE;

#if 1
	_splitpath( pName, agDrive, agPath, agName, agExt );

	//
	// if the filename came with a path component choose that to add to the file
	// list else use the path parameter.
	//

	strcpy( agNameBuf, agDrive );
	strcat( agNameBuf, agPath );

    fNameHadNoPath = strlen( agNameBuf ) == 0;
	if ( fNameHadNoPath )
		strcpy( agNameBuf, pPath );
	
	if( pPath[ strlen(pPath) - 1] != '\\' )
		strcat( agNameBuf, "\\" );

	//
	// if the filename had  a path component, then dont use that name, use the
	// name provided by splitpath.
	//

	if( fNameHadNoPath )
		strcat( agNameBuf, pName );
	else
		{
		strcat( agNameBuf, agName );
		strcat( agNameBuf, agExt );
		}

	if( (Status = CreateFullPathAndFName( agNameBuf, &pP, &pN )) != STATUS_OK )
		return OUT_OF_MEMORY;
#endif // 1

	while(pList && pList->pNext) pList = pList->pNext;
	
	if ( (pTemp = new FNAME_LIST) == 0 )
		return OUT_OF_MEMORY;

	if(pList) 
		pList->pNext	= pTemp;
	else
		pFileList	= pTemp;
	pList			= pTemp;
	pList->pName = pN;
	pList->pPath = pP;
	pList->pNext	= (FNAME_LIST *)NULL;
	return	STATUS_OK;
	}

STATUS_T
CreateFullPathAndFName( char * pInput, char **ppPOut, char **ppNOut )
	{
	char			agNameBuf[ _MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT+1];
	char			agDrive[_MAX_DRIVE];
	char			agPath[_MAX_DIR];
	char			agName[_MAX_FNAME];
	char			agExt[_MAX_EXT];

	_fullpath( agNameBuf, pInput,_MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT+1);
	_splitpath( agNameBuf, agDrive, agPath, agName, agExt );
	strcpy( agNameBuf, agDrive );
	strcat( agNameBuf, agPath );
	*ppPOut = new char [strlen( agNameBuf ) + 1];
	strcpy( *ppPOut, agNameBuf );

	strcpy( agNameBuf, agName );
	strcat( agNameBuf, agExt );
	*ppNOut = new char [strlen( agNameBuf ) + 1];
	strcpy( *ppNOut, agNameBuf );

	return STATUS_OK;
	}
BOOL
NFA_INFO::IsDuplicateInput(
	char	*	pThisName)
	{
	FNAME_LIST	*pList	= pFileList;
	char		* pN;
	char		* pP;
	BOOL		f = FALSE;
	char			agNameBuf[ _MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT+1];
	char			agDrive[_MAX_DRIVE];
	char			agPath[_MAX_DIR];
	char			agName[_MAX_FNAME];
	char			agExt[_MAX_EXT];

	//
	// if the file did not come with a path component, then try the normal
	// search for file.
	//

	_splitpath( pThisName, agDrive, agPath, agName, agExt );
	strcpy( agNameBuf, agDrive );
	strcat( agNameBuf, agPath );
	

	if( strlen( agNameBuf ) == 0 )
		{
		if ( ( pP = SearchForFile( pThisName ) ) != 0 )
			{
			strcpy( agNameBuf, pP );
			strcat( agNameBuf, pThisName );
			}
		else
			{
			strcpy( agNameBuf, pThisName );
			}
		}
	else
		strcpy( agNameBuf, pThisName );

	CreateFullPathAndFName( agNameBuf, &pP, &pN );

	while( pList && pList->pName )
		{
		if( (_stricmp( pList->pName , pN ) == 0 ) &&
			(_stricmp( pList->pPath , pP ) == 0 ) 
		  )
		  {
		  f = TRUE;
		  break;
		  }
		pList = pList->pNext;
		}
	delete pN;
	delete pP;
	return f;
	}
/*** SetPath *****************************************************************
 * Purpose	: to add a string to the list of possible paths
 * Input	: path to add to the list of paths
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	:
 ****************************************************************************/
STATUS_T
NFA_INFO::SetPath(
	char	*pPath )
	{
	PATH_LIST 	*pList	= pPathList;
	PATH_LIST 	*pTemp;
	size_t		 Len;

	while(pList && pList->pNext) pList = pList->pNext;
	
	if ( (pTemp = new PATH_LIST) == 0 )
		return OUT_OF_MEMORY;

	if(pList) 
		pList->pNext	= pTemp;
	else
		pPathList		= pTemp;

#if 0
	// The user could specify a path using a leading space, for example, he can
	// specify the -I with a leading space. Even tho the -I should be presented
	// to the user with the leading space, we should not get confused. We omit 
	// leading spaces.

	while( isspace( *pPath ) ) pPath++;
#endif

	pList			= pTemp;
	pList->pPath	= new char[ (Len = strlen(pPath)) + 2];// one possible "\\"
	pList->pNext	= (PATH_LIST *)NULL;
	strcpy( pList->pPath, pPath );

	if( Len  &&  (pPath[ Len - 1 ] != '\\' ) )
		strcat( pList->pPath, "\\");

	return	STATUS_OK;
	}

/*** SetPreProcessingOn *****************************************************
 * Purpose	: to set preprocessing on
 * Input	: nothing
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	: Set the preprocessing flag on. This denotes that preprocessing
 *			: will be on for all the files that are input to the compiler
 ****************************************************************************/
STATUS_T
NFA_INFO::SetPreProcessingOn(void)
	{
	Flags.fPreProcess	= 1;
	return STATUS_OK;
	}

/*** SearchForFile ********************************************************
 * Purpose	: to search for a file in a previously registered set of paths
 * Input	: file name
 * Output	: (char *)NULL if the file was not found in the given set of paths
 *			: else a pointer to the path where it was found
 * Notes	:
 *************************************************************************/
char *
NFA_INFO::SearchForFile(
	char	*pName)
	{

	PATH_LIST	*pPathTemp = pPathList;
	char		agNameBuf[ _MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT+1];

	// the name is guaranteed not to have path or drive info, just the 
	// base name and extension. We must figure out the paths, from 
	// the list of paths that we have registered so far

	while(pPathTemp)
		{
		sprintf(agNameBuf, "%s%s", pPathTemp->pPath, pName);
		// check for existence only. The read errors need to be checked
		// only at read time.

		if( _access( agNameBuf, 0 ) == 0 )
			return pPathTemp->pPath;

		pPathTemp = pPathTemp->pNext;
		}
	
	// we did not find the file, return an error
	return (char *)NULL;
	}

/*** PreProcess ************************************************************
 * Purpose	: to preprocess the given file into an intermediate file
 * Input	: drive, path, name and current extension of the file
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	: The c compiler uses the /E switch to generate the 
 *			: the preprocessed output with line numbers to a file.
 *			: Now the way to do the preprocessing is to spawn the
 *			: c compiler with the /E switch. But we need to redirect the
 *			: output to a file. To force the spawnee to redirect, we 
 *			: must also do the redirection in this process, so that the
 *			: spawnee inherits our file handles.
 **************************************************************************/
STATUS_T
NFA_INFO::PreProcess(
	char	*pDrive,
	char	*pPath,
	char	*pName,
	char	*pExt,
	char	*&pIFileName )
	{
	STATUS_T	Status = STATUS_OK;
	char		agNameBuf[ _MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT+1];
	char	*	pCppCmd = (pCompiler->GetCommandProcessor())->GetCPPCmd();
	char	*	pCppOptions;
	char	*	pCppBaseOptions;
	intptr_t	SpawnError;
	int			IFHandle;
	BOOL		fStderrSaved	= FALSE;
	FILE	*	hIFile;
	int			XHandle;
	FILE	*	hXHandle = 0;
	BOOL		fEraseFile		= FALSE;
	char        TempPathBuffer[1000];


    // build up the arguments
	strcpy( agNameBuf, "\"" );
	strcat( agNameBuf, pDrive );
	strcat(agNameBuf,pPath);
	if( *pPath &&  (pPath[ strlen(pPath)-1 ] != '\\'))
		strcat(agNameBuf,"\\");
	strcat( agNameBuf, pName );
	strcat( agNameBuf, pExt );
	strcat( agNameBuf, "\"" );

	pCppBaseOptions = pCommand->GetCPPOpt();
	pCppOptions = new char[ strlen( pCppBaseOptions ) + 40 ];

    int nVersion = ( rmj * 100 ) + ( rmm % 100 );
	if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
        {
        sprintf(pCppOptions, "-D__midl=%d -D__MKTYPLIB__=%d ", nVersion, nVersion );
        }
    else
        {
        sprintf(pCppOptions, "-D__midl=%d ", nVersion );
        }
	strcat( pCppOptions, pCppBaseOptions );
	
	// generate the name of the intermediate file into a buffer

//	pIFileName = _tempnam( NULL, "MIDL" );
	GetTempPathA( 1000, TempPathBuffer );
	pIFileName = new char[1000];
	if ( GetTempFileNameA( TempPathBuffer, "MIDL", 0, pIFileName ) == 0)
		{
		RpcError(	(char *)NULL,
					0,
					Status = INTERMEDIATE_FILE_CREATE,
					TempPathBuffer);
		return Status;
		}

//    printf("Intermediary files\n filename is %s\n agNameBuf is %s\n pCppOptions is %s\n", pIFileName, agNameBuf, pCppOptions );

	// open the intermediate file for writing.

	if( (hIFile = _fsopen( pIFileName, "w", SH_DENYWR )) == (FILE *)0 )
		{
		RpcError(	(char *)NULL,
					0,
					Status = INTERMEDIATE_FILE_CREATE,
					pIFileName);
		return Status;
		}

	IFHandle = MIDL_FILENO( hIFile );

	// save the current stdout handle

	if ( StdoutSave == -1 )
		{
		if( (StdoutSave = _dup(1)) == -1 )
			{
			RpcError(	(char *)NULL,
						0,
						Status = OUT_OF_SYSTEM_FILE_HANDLES,
						(char *)NULL);

			return Status;
			}
		}

	// now force the stdout to refer to the intermediate file handle,
	// thus establishing redirection.

	if( _dup2( IFHandle, 1 ) == -1 )
		{
		RpcError(	(char *)NULL,
					0,
					Status = OUT_OF_SYSTEM_FILE_HANDLES,
					(char *)NULL);
		return Status;
		}


	if( pCommand->IsSwitchDefined(SWITCH_X) )
		{


		fStderrSaved	= TRUE;
		if( (hXHandle = fopen( "nul", "w" ) ) == (FILE *)0 )
			{
			RpcError(	(char *)NULL,
						0,
						Status = INTERMEDIATE_FILE_CREATE,
						"nul");
	
			return Status;
			}

		XHandle = MIDL_FILENO( hXHandle );
	
		// save the current stderr handle
		StderrSave = -1;
		if( (StderrSave = _dup(2)) == -1 )
			{
			RpcError(	(char *)NULL,
						0,
						Status = OUT_OF_SYSTEM_FILE_HANDLES,
						(char *)NULL);

			return Status;
			}
	
		// now force the stdout to refer to the intermediate file handle,
		// thus establishing redirection.
	
		if( _dup2( XHandle, 2 ) == -1 )
			{
			RpcError(	(char *)NULL,
						0,
						Status = OUT_OF_SYSTEM_FILE_HANDLES,
						(char *)NULL);
			return Status;
			}
	
		}

	// From now on, stdout is no longer stdout, till we restore it back.
	// thus if there are intermediate errors, stdout MUST be restored
	// before returning.

	// From now on, stderr is no longer stderr, till we restore it back.
	// stderr MUST be restored before returning.

	SpawnError = MIDL_SPAWNLP(	 P_WAIT
							,pCppCmd
							,pCppCmd
							,pCppOptions
							,agNameBuf
							,(char *)NULL );
	
	delete pCppOptions;

	// before doing anything, close the intermediate file handle

	fclose( hIFile );

	// restore the stdout back

	_dup2( StdoutSave, 1 );

	if( fStderrSaved )
		{
		fclose( hXHandle );
		_dup2( StderrSave, 2 );
		}

	if( SpawnError == -1 )
		{
		switch( errno )
			{
			case ENOMEM:
				Status	= OUT_OF_MEMORY;
				break;
			case ENOENT:
				Status	= NO_PREPROCESSOR;
				break;
			case ENOEXEC:
				Status	= PREPROCESSOR_INVALID;
				break;
			default:
				Status	= PREPROCESSOR_EXEC;
				break;
			}

		RpcError((char *)NULL, 0, Status , pCppCmd);
		fEraseFile	= TRUE;
		}
	else if( SpawnError )
		{
		char	buf[10];
		sprintf(buf, "(%d)", SpawnError );
		RpcError((char *)NULL, 0, Status = PREPROCESSOR_ERROR, buf);
		fEraseFile	= TRUE;
		}

	if( fEraseFile )
		{
		MIDL_UNLINK( pIFileName );
		}


	return Status;
	}

/*** GetChar ****************************************************************
 * Purpose	: get a character from the input stream
 * Input	: nothing
 * Output	: a character from the file
 * Notes	: returns 0 if at end of file
 ****************************************************************************/
short
NFA_INFO::GetChar( void )
	{
		short	ch;

		if( pStack->fRedundantImport )
			{
			fRedundantImport = TRUE;
			return 0x0;
			}

		if( !Flags.fFileSet || !pStack->fOpen) return 0;

		if( ( (ch=(short)getc(pStack->hFile)) == EOF ) && feof(pStack->hFile) )
			return 0;

#if 0
		// if the line starts off with a '#', it may be a line number
		// indicator.

		if(pStack->fNewLine && (ch == '#'))
			{
			unsigned long SavePos = ftell(pStack->hFile);
			char buffer[_MAX_DRIVE + _MAX_PATH + _MAX_FNAME + _MAX_EXT ];
			short Count = 0;
			short fLinePresent = 0;

			// it coule be a # <space> number or #line <space> number

			while( (ch = getc( pStack->hFile ) ) == ' ' );

			if( isdigit( ch ) )
				{
				fLinePresent = 1;
				}
			else
				{
				buffer[ Count++ ] = (char)ch;

				// if it is #line, the first 5 characters will be #line
				while(Count < 4)
					buffer[Count++] = (char) getc(pStack->hFile);
				buffer[Count] = '\0';
				fLinePresent = (strcmp( buffer, "line" ) == 0 );
				if( fLinePresent )
					while( (ch = getc( pStack->hFile )) == ' ' );
				}

			if( fLinePresent )
				{
				Count = 0;
				do
					{
					buffer[Count++] = (char) ch;
					} while( (ch = getc(pStack->hFile)) != ' ');

				buffer[Count] = '\0';

				// line to be seen now is the line number indicated.
				// but the line number indicator is on a line
				// previous to that it indicates, so reflect that in
				// the line number
				pStack->uLine = atoi(buffer) - 1;

				while( (ch=getc(pStack->hFile)) == ' ');
				Count = 0;
//				buffer[Count++] = ch;
//				fgetc(pStack->hFile);		// skip the quote

				if(ch == '\"')
					{
					while( (ch=getc(pStack->hFile)) != '\"')
						{
						buffer[Count++] = (char) ch;
						}
					buffer[Count] = 0;

					// make the collected filename as the new name

					StripSlashes( buffer );

					if(strcmp(buffer, pStack->pName) != 0)
						{
						pStack->pName = new char[Count+1];
						strcpy(pStack->pName, buffer);
						
						// update the line number information, and set current file
						AddFileToDB( pStack->pName );

						}
					}

				while( (ch = getc( pStack->hFile )) != '\n');
				goto newline;
				}
			else
				{
				fseek(pStack->hFile, SavePos, SEEK_SET);
				ch = '#';
				}
			}
newline:
		if(ch == '\n')
			{
			DebugLine = pStack->uLine++;
			pDebugFile= pStack->pName;
			pStack->fNewLine = 1;

			}
		else
			{
			// leave fNewLine set for leading white space
			pStack->fNewLine = pStack->fNewLine && isspace( ch );
			}
#endif // 0
		return ch;
	}

/*** UnGetChar **************************************************************
 * Purpose	: to unget the given character
 * Input	: the character to unget
 * Output	: the character which was unget-ed
 * Notes	:
 ***************************************************************************/
short
NFA_INFO::UnGetChar( 
	short	c)
	{

	if( !Flags.fFileSet || !pStack->fOpen) return 0;
	ungetc( c, pStack->hFile );

#if 0
	if(c == '\n')
		{
		pStack->uLine--;
		// dont know what to do with column, really
		}
#endif
	return c;
	}

/*** GetCurrentInputDetails *************************************************
 * Purpose	: to return details of the current input
 * Input	: pointer to name pointer, pointer to line no, pointer to col
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	:
 ****************************************************************************/
STATUS_T
NFA_INFO::GetCurrentInputDetails( 
	char **ppName,
	short	 *pLineNo,
	short	 *pColNo )
	{
	if(!pStack)
		{
		(*ppName)	= "";
		(*pLineNo)	= 0;
		(*pColNo)	= 0;
		return NO_INPUT_FILE;
		}

	(*ppName)	= pStack->pName;
	(*pLineNo)	= curr_line_G;
	(*pColNo)	= 0;
	return STATUS_OK;
	}
/*** GetInputDetails ********************************************************
 * Purpose	: to return details of the input
 * Input	: pointer to name pointer, pointer to line no, pointer to col
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	:
 ****************************************************************************/
STATUS_T
NFA_INFO::GetInputDetails( 
	char **ppName,
	short	 *pLineNo)
	{
	if(!pStack)
		{
		(*ppName)	= "";
		(*pLineNo)	= 0;
		return NO_INPUT_FILE;
		}

	(*ppName)	= pStack->pShadowName;
	(*pLineNo)	= curr_line_G;
	return STATUS_OK;
	}
/*** GetInputDetails ********************************************************
 * Purpose	: to return details of the current input
 * Input	: pointer to name pointer
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	:
 ****************************************************************************/
STATUS_T
NFA_INFO::GetInputDetails( 
	char **ppName)
	{
	if(!pStack) return NO_INPUT_FILE;

	(*ppName)	= pStack->pShadowName;
	return STATUS_OK;
	}

void
NFA_INFO::SetEOIFlag()
	{
	Flags.fEOI	= 1;
	}

short
NFA_INFO::GetEOIFlag()
	{
	return (short)Flags.fEOI;
	}
BOOL
NFA_INFO::IsInInclude()
	{
	return Flags.fInInclude;
	}
/****************************************************************************
 ****	temp functions to see if things are fine
 ****************************************************************************/
void
NFA_INFO::Dump()
	{
	PATH_LIST	*pPathTemp = pPathList;
	FNAME_LIST	*pNameTemp = pFileList;

	printf("\nDump of file handler data structure:");
	printf("\nPreprocessing      :%d", Flags.fPreProcess);
	printf("\nfFileSet           :%d", Flags.fFileSet);
	printf("\nCurrentLexLevel    :%d", iCurLexLevel);


	printf("\n");
	if(pPathTemp)
		{
		printf("\nList of paths:");
		while( pPathTemp )
			{
			printf("\nPATH:	%s", pPathTemp->pPath);
			pPathTemp	= pPathTemp->pNext;
			}
		}
	if(pNameTemp)
		{
		printf("\nList of input files so far:");
		while(pNameTemp)
			{
			printf("\nFILE:	%s", pNameTemp->pName);
			pNameTemp	= pNameTemp->pNext;
			}
		}
	}

/******************************************************************************
 *	general utility routines
 ******************************************************************************/
/*** SplitFileName ************************************************************
 * Purpose	: to analyse the filename and return individual components
 * Input	: pointers to individual components
 * Output	: nothing
 * Notes	:
 *****************************************************************************/
void
SplitFileName(
	char	*	pFullName,
	char	**	pagDrive,
	char	**	pagPath,
	char	**	pagName,
	char	**	pagExt )
	{
	char		agDrive[ _MAX_DRIVE ];
	char		agPath[ _MAX_DIR ];
	char		agName[ _MAX_FNAME ];
	char		agExt[ _MAX_EXT ];

	_splitpath( pFullName, agDrive, agPath, agName, agExt );

	if( agDrive[0] )
		{
		(*pagDrive) = new char[ strlen(agDrive) + 1 ];
		strcpy( (*pagDrive), agDrive );
		}
	else
		{
		(*pagDrive) = new char[ 1 ];
		*(*pagDrive) = '\0';
		}

	if( agPath[0] )
		{
		(*pagPath) = new char[ strlen(agPath) + 1 ];
		strcpy( (*pagPath), agPath );
		}
	else
		{
		(*pagPath) = new char[ 2 + 1 ];
		strcpy( (*pagPath), ".\\");
		}

	if( agName[0] )
		{
		(*pagName) = new char[ strlen(agName) + 1 ];
		strcpy( (*pagName), agName );
		}
	else
		{
		(*pagName) = new char[ 1 ];
		*(*pagName) = '\0';
		}
	if( agExt[0] )
		{
		(*pagExt) = new char[ strlen(agExt) + 1 ];
		strcpy( (*pagExt), agExt );
		}
	else
		{
		(*pagExt) = new char[ 1 ];
		*(*pagExt) = '\0';
		}

	}

void
StripSlashes(
	char	*	p )
	{
	char	*	pSave = p;
	char	*	p1;
	char	*	dest = new char [ 256 ],
			*	destSave = dest;
	short		n;

	if( p )
		{

		dest[0] = 0;

		while ( ( p1 = strstr( p, "\\\\" ) ) != 0 )
			{
			strncpy( dest, p, n = short(p1 - p) );
			dest 	+= n;
			*dest++  = '\\';
			*dest	 = 0;
			p		 = p1 + 2;
			while( *p == '\\') p++;
			}

		strcat( dest, p );
		strcpy( pSave, destSave );

		}

	delete destSave;
	}

void
ChangeToForwardSlash(
char	* pFullInputName,
char	* pFullName )
	{
	short ch;
	while ( (ch = *pFullInputName++ ) != 0 )
		{
		if( ch == '/' )
			ch = '\\';
		*pFullName++ = (char) ch;
		}
	*pFullName = '\0';
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\fldattr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	fldattr.cxx

 Abstract:

	field attribute handling routines

 Notes:


 Author:

	GregJen	Oct-27-1993	Created.

 Notes:


 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 )

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "allnodes.hxx"
#include "fldattr.hxx"
#include "semantic.hxx"

/****************************************************************************
 *	local data
 ***************************************************************************/

expr_constant	*	pZero	= NULL;
expr_constant	*	pOne	= NULL;
node_skl		*	pInt	= NULL;

/****************************************************************************
 *	externs
 ***************************************************************************/

/****************************************************************************
 *	definitions
 ***************************************************************************/

/////////////////
// helper routines for Normalize functions; 

//Don't add or subtract 0.
expr_node	*
CreateSimpleBinaryArithExpression( 
	OPERATOR 		Op,
	expr_node	* 	pL,
	expr_node	* 	pR
	)
{
	MIDL_ASSERT( (Op==OP_PLUS) || (Op==OP_MINUS) );
	MIDL_ASSERT( pL );
	MIDL_ASSERT( pR );


	if ( pR->IsConstant() && (pR->GetValue() == 0) )
		return pL;

	if ( pL->IsConstant() && (pL->GetValue() == 0) )
		return pR;

	expr_node	*	pRet	= new expr_b_arithmetic( Op, pL, pR );

	if ( pL->GetType() )
		pRet->SetType( pL->GetType() );
	else if ( pR->GetType() )
		pRet->SetType( pR->GetType() );
	else
		MIDL_ASSERT( !"no type for expression" );

	return pRet;

}


// return the constant 0 over and over
expr_constant	*
GetConstant0()
{
	if ( pZero )	return pZero;

	pZero	= new expr_constant( 0L, VALUE_TYPE_NUMERIC );
	
	if ( !pInt )
		GetBaseTypeNode( &pInt, SIGN_SIGNED, SIZE_UNDEF, TYPE_INT );

	pZero->SetType( pInt );
	return pZero; 
}
	
// return the constant 1 over and over
expr_constant	*
GetConstant1()
{
	if ( pOne )	return pOne;

	pOne	= new expr_constant( 1L, VALUE_TYPE_NUMERIC );
	if ( !pInt )
		GetBaseTypeNode( &pInt, SIGN_SIGNED, SIZE_UNDEF, TYPE_INT );

	pOne->SetType( pInt );
	return pOne; 
}
	
BOOL
IsInValidOutOnly( SEM_ANALYSIS_CTXT * pCtxt )
{
	// an out-only size is valid only on out-only non-top-level things

	// in, in/out things not allowed
	if ( pCtxt->AnyAncestorBits( UNDER_IN_PARAM ) )
		return TRUE;

	// look up the stack for a pointer (or array) that is unique
	SEM_ANALYSIS_CTXT	*	pCurCtxt = pCtxt;
	NODE_T					Kind;
	node_skl			*	pNode;
	while ( pCurCtxt )
		{
		pNode	= pCurCtxt->GetParent();
		Kind	= pNode->NodeKind();

		switch ( Kind )
			{
			case NODE_DEF:
			case NODE_ARRAY:
				break;
			case NODE_POINTER:
				if ( pCtxt->AnyAncestorBits( IN_NON_REF_PTR ) )
					return FALSE;
				break;
			case NODE_PARAM:
			case NODE_PROC:
			default:
				return TRUE;
			}
		pCurCtxt = ( SEM_ANALYSIS_CTXT	* ) pCurCtxt->GetParentContext();
		}
	return TRUE;
}

BOOL Xxx_Is_Type_OK( node_skl * pType)
{
	if ( !pType )
		return FALSE;

	for (;;)
		{
		switch ( pType->NodeKind() )
			{
			case NODE_PARAM:
			case NODE_FIELD:
				if ( !pType->GetChild() )
					return FALSE;

				break;

			// make sure that there is no transmit_as or represent_as
			case NODE_DEF:
				if ( pType->FInSummary( ATTR_TRANSMIT ) ||
				     pType->FInSummary( ATTR_REPRESENT_AS ) ||
				     pType->FInSummary( ATTR_USER_MARSHAL ) ||
				     pType->FInSummary( ATTR_WIRE_MARSHAL ) )
					return FALSE;

				break;
			
			// for an ID, make sure it is a const decl, then use its type
			case NODE_ID:
				{
				node_id		*	pID	= (node_id *) pType;
				if ( !pID->pInit )
					return FALSE;

				break;
				}
			case NODE_ENUM:
			case NODE_LONG:
			case NODE_SHORT:
			case NODE_INT:
			case NODE_INT32:
			case NODE_SMALL:
			case NODE_CHAR:
			case NODE_BOOLEAN:
			case NODE_BYTE:
                return TRUE;

            // 64b expr support
			case NODE_INT3264:
			case NODE_INT64:
			case NODE_HYPER:
				return FALSE;

            // no 128b expr support
            case NODE_INT128:
            case NODE_FLOAT80:
            case NODE_FLOAT128:
                return FALSE;

			default:
				return FALSE;
			}
		pType = pType->GetChild();
		}
}


BOOL IID_Is_Type_OK( node_skl * pType )
{
	if ( !pType )
		return FALSE;

    for (;;)
        {
		switch ( pType->NodeKind() )
			{
			case NODE_PARAM:
			case NODE_FIELD:
				if ( !pType->GetChild() )
					return FALSE;

				break;

			case NODE_DEF:
				if ( pType->FInSummary( ATTR_TRANSMIT ) ||
				     pType->FInSummary( ATTR_REPRESENT_AS ) ||
				     pType->FInSummary( ATTR_USER_MARSHAL ) ||
				     pType->FInSummary( ATTR_WIRE_MARSHAL )  )
					return FALSE;

				break;
			
			case NODE_POINTER:
				if ( pType->GetChild() )
					return ( 16 == pType->GetChild()->GetSize() );
				
			default:
				return FALSE;
			}
		pType = pType->GetChild();
		}
}

// validate the bunch of attributes for pointers: check combinations, ranges, 
// and expressions

void			
FIELD_ATTR_INFO::Validate( SEM_ANALYSIS_CTXT * pCtxt )
{
	if ( Kind == FA_NONE )
		return;

	node_skl	*		pParent		= pCtxt->GetParent();

// things to check:
// expression types (must be integral types)
	
	if ( pMaxIsExpr )
		{
		EXPR_CTXT		MaxCtxt( pCtxt );

		pMaxIsExpr->ExprAnalyze( &MaxCtxt );

		if ( MaxCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( MaxCtxt.AnyUpFlags( EX_OUT_ONLY_PARAM ) && IsInValidOutOnly( pCtxt ) )
			RpcSemError( pParent, *pCtxt, SIZE_SPECIFIER_CANT_BE_OUT, NULL );

		if ( !MaxCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pMaxIsExpr->GetType() ) &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			RpcSemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pMinIsExpr )
		{
		EXPR_CTXT		MinCtxt( pCtxt );

		pMinIsExpr->ExprAnalyze( &MinCtxt );

		if ( MinCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			RpcSemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( MinCtxt.AnyUpFlags( EX_OUT_ONLY_PARAM ) && IsInValidOutOnly( pCtxt ) )
			SemError( pParent, *pCtxt, SIZE_SPECIFIER_CANT_BE_OUT, NULL );

		if ( !MinCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pMinIsExpr->GetType() ) &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pSizeIsExpr )
		{
		EXPR_CTXT		SizeCtxt( pCtxt );

		pSizeIsExpr->ExprAnalyze( &SizeCtxt );

		if ( SizeCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( SizeCtxt.AnyUpFlags( EX_OUT_ONLY_PARAM ) && IsInValidOutOnly( pCtxt ) )
			SemError( pParent, *pCtxt, SIZE_SPECIFIER_CANT_BE_OUT, NULL );

		if ( !SizeCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pSizeIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pFirstIsExpr )
		{
		EXPR_CTXT		FirstCtxt( pCtxt );

		pFirstIsExpr->ExprAnalyze( &FirstCtxt );

		if ( FirstCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( !FirstCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pFirstIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pLastIsExpr )
		{
		EXPR_CTXT		LastCtxt( pCtxt );

		pLastIsExpr->ExprAnalyze( &LastCtxt );

		if ( LastCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( !LastCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pLastIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pLengthIsExpr )
		{
		EXPR_CTXT		LengthCtxt( pCtxt );

		pLengthIsExpr->ExprAnalyze( &LengthCtxt );

		if ( LengthCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( !LengthCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pLengthIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pIIDIsExpr )
		{
		EXPR_CTXT		IIDCtxt( pCtxt );

		pIIDIsExpr->ExprAnalyze( &IIDCtxt );

		if ( IIDCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( !IIDCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !IID_Is_Type_OK( pIIDIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, IID_IS_EXPR_NON_POINTER, NULL );

		}

// min_is == 0 ( for now )
// constant min_is <= constant max_is
// size_is not with max_is
	if ( pMaxIsExpr && pSizeIsExpr )
		SemError( pParent, *pCtxt, MAX_AND_SIZE, NULL );

// min_is not alone

// constant first_is <= constant last_is + 1
// length_is not with last_is
	if ( pLengthIsExpr && pLastIsExpr )
		SemError( pParent, *pCtxt, LAST_AND_LENGTH, NULL );

// constant first_is, last_is both within min<->max range
// length_is <= size_is 
// string attrs not with varying attrs
// string and bstring not together

// conformant strings may leave out size_is if [in] or [in,out]

// accept the NULL value ( turn expression back null, clear kind bits )
// make sure variables come from the correct context

// lengthed, unsized pointer

	if ( ( pLengthIsExpr || pFirstIsExpr || pLastIsExpr || pMinIsExpr) &&
		!( pSizeIsExpr || pMaxIsExpr ) )
		SemError( pParent, *pCtxt, UNSIZED_ARRAY, NULL );
}

void			
FIELD_ATTR_INFO::Validate( SEM_ANALYSIS_CTXT * pCtxt, 
							  expr_node * pLower, 
							  expr_node * pUpper )
{
	node_skl	*		pParent		= pCtxt->GetParent();

    if ( pUpper	== (expr_node *) -1 )
		{
		pUpper	=	NULL;
		Kind	|=	FA_CONFORMANT;
		}
	else if ( pUpper )
		{
		if ( pUpper->GetValue() <= 0 )
			{
			SemError( pParent, *pCtxt, ILLEGAL_ARRAY_BOUNDS, NULL );
			}
		}
		
	if (   pLower && 
		 ( pLower != (expr_node *) -1 ) &&
		 ( pLower->GetValue() != 0 ) )
		{
		SemError( pParent, *pCtxt, ARRAY_BOUNDS_CONSTRUCT_BAD, NULL );
		}

	if ( pUpper && ( pMaxIsExpr || pSizeIsExpr ) )
		{
		SemError( pParent, *pCtxt, SIZING_ON_FIXED_ARRAYS, NULL );
		}

// things to check:
// expression types (must be integral types)
	
	if ( pMaxIsExpr )
		{
		EXPR_CTXT		MaxCtxt( pCtxt );

		pMaxIsExpr->ExprAnalyze( &MaxCtxt );

		if ( MaxCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( MaxCtxt.AnyUpFlags( EX_OUT_ONLY_PARAM ) )
			SemError( pParent, *pCtxt, SIZE_SPECIFIER_CANT_BE_OUT, NULL );

		if ( !MaxCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pMaxIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pMinIsExpr )
		{
		EXPR_CTXT		MinCtxt( pCtxt );

		pMinIsExpr->ExprAnalyze( &MinCtxt );

		if ( MinCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( MinCtxt.AnyUpFlags( EX_OUT_ONLY_PARAM ) )
			SemError( pParent, *pCtxt, SIZE_SPECIFIER_CANT_BE_OUT, NULL );

		if ( !MinCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pMinIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pSizeIsExpr )
		{
		EXPR_CTXT		SizeCtxt( pCtxt );

		pSizeIsExpr->ExprAnalyze( &SizeCtxt );

		if ( SizeCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( SizeCtxt.AnyUpFlags( EX_OUT_ONLY_PARAM ) )
			SemError( pParent, *pCtxt, SIZE_SPECIFIER_CANT_BE_OUT, NULL );

		if ( !SizeCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pSizeIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}


	if ( pFirstIsExpr )
		{
		EXPR_CTXT		FirstCtxt( pCtxt );

		pFirstIsExpr->ExprAnalyze( &FirstCtxt );

		if ( FirstCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( !FirstCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pFirstIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pLastIsExpr )
		{
		EXPR_CTXT		LastCtxt( pCtxt );

		pLastIsExpr->ExprAnalyze( &LastCtxt );

		if ( LastCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( !LastCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pLastIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pLengthIsExpr )
		{
		EXPR_CTXT		LengthCtxt( pCtxt );

		pLengthIsExpr->ExprAnalyze( &LengthCtxt );

		if ( LengthCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( !LengthCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pLengthIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}


	if ( pIIDIsExpr )
		{
		SemError( pParent, *pCtxt, IID_IS_NON_POINTER, NULL );
		}

// min_is == 0 ( for now )
// constant min_is <= constant max_is
// size_is not with max_is
	if ( pMaxIsExpr && pSizeIsExpr )
		SemError( pParent, *pCtxt, MAX_AND_SIZE, NULL );

	// a conformant unsized array:
	//		must have string
	//		must not be out_only
	if ( ( Kind & FA_CONFORMANT ) && !pMaxIsExpr && !pSizeIsExpr && !pUpper )
		{
		if ( !( Kind & FA_STRING ) )
			{
			if ( pCtxt->AnyAncestorBits( IN_RPC ) )
				SemError( pParent, *pCtxt, UNSIZED_ARRAY, NULL );
			}
		else
			{
			if ( pCtxt->AllAncestorBits( IN_RPC |
										 IN_PARAM_LIST |
										 UNDER_OUT_PARAM ) &&
				 !pCtxt->AnyAncestorBits( UNDER_IN_PARAM ) )
				SemError( pParent, *pCtxt, DERIVES_FROM_UNSIZED_STRING, NULL );
			}
		}
		

// min_is not alone

// constant first_is <= constant last_is + 1
// length_is not with last_is
	if ( pLengthIsExpr && pLastIsExpr )
		SemError( pParent, *pCtxt, LAST_AND_LENGTH, NULL );

// constant first_is, last_is both within min<->max range
// length_is <= size_is 
// string attrs not with varying attrs
// string and bstring not together

// conformant strings may leave out size_is if [in] or [in,out]

// accept the NULL value ( turn expression back null, clear kind bits )
// make sure variables come from the correct context

}


//
// normalize for pointers ( no default bound )
void
FIELD_ATTR_INFO::Normalize()
{
	expr_node	*	pTmp1;
	expr_node	*	pTmp2;

	// convert the set: min_is, max_is, size_is to 			min_is + size_is

	if ( Kind & FA_CONFORMANT )
		{
		// default min_is is 0
		if ( ! pMinIsExpr )
			{
			pMinIsExpr		=	GetConstant0();
			}

		// size_is = (max_is - min_is) + 1;
		if ( ! pSizeIsExpr )
			{
			if ( pMaxIsExpr )
				{
				pTmp1		=	GetConstant1();
				pTmp2		=	CreateSimpleBinaryArithExpression( OP_MINUS, pMaxIsExpr, pMinIsExpr);
				pSizeIsExpr	=	CreateSimpleBinaryArithExpression( OP_PLUS, pTmp2, pTmp1 );
				}
			}
		}


	// convert the set: first_is, last_is, length_is to:	first_is + length_is
	if ( Kind & FA_VARYING )
		{
		// default first_is is 0
		if ( ! pFirstIsExpr )
			{
			pFirstIsExpr	=	GetConstant0();
			}

		// default last_is is max_is or size_is+1
		if ( ! pLastIsExpr )
			{
			if ( pMaxIsExpr )
				pLastIsExpr	= pMaxIsExpr;
			else if ( pSizeIsExpr )
				pLastIsExpr = CreateSimpleBinaryArithExpression( OP_MINUS, pSizeIsExpr, GetConstant1() ); 
			}

		// length_is = (last_is - first_is) + 1;
		if ( ! pLengthIsExpr )
			{
			if ( pLastIsExpr )
				{
				pTmp1			=	GetConstant1();
				pTmp2			=	CreateSimpleBinaryArithExpression( OP_MINUS, pLastIsExpr, pFirstIsExpr);
				pLengthIsExpr	=	CreateSimpleBinaryArithExpression( OP_PLUS, pTmp2, pTmp1 );
				}
			}
		}

}

// normalize for arrays (provided lower and upper bound)
void
FIELD_ATTR_INFO::Normalize(expr_node * pLower, expr_node * pUpper)
{
	expr_node	*	pTmp1;
	expr_node	*	pTmp2;
	BOOL			OneBound = FALSE;

	if ( pLower == (expr_node *) 0 )
		{
		pLower	=	GetConstant0();
		OneBound	= TRUE;
		}

	if ( pUpper	== (expr_node *) -1 )
		{
		pUpper	=	NULL;
		Kind	|=	FA_CONFORMANT;
		}

	// convert the set: min_is, max_is, size_is to:	min_is + size_is

	// first, copy from the bounds
	if ( ! pMinIsExpr )
		{
		pMinIsExpr		=	pLower;
		}

	if ( ! pMaxIsExpr && ! pSizeIsExpr && pUpper )
		{
            // note that the [n..m] case has m already incremented by 1
			pTmp1		= GetConstant1();
			pMaxIsExpr	= CreateSimpleBinaryArithExpression( OP_MINUS, pUpper, pTmp1 );
		}

	// size_is = (max_is - min_is) + 1;
	if ( ! pSizeIsExpr )
		{
		if ( pMaxIsExpr )
			{
			pTmp1		= GetConstant1();
			pTmp2		= CreateSimpleBinaryArithExpression( OP_MINUS, pMaxIsExpr, pMinIsExpr);
			pSizeIsExpr	= CreateSimpleBinaryArithExpression( OP_PLUS, pTmp2, pTmp1 );
			}
		}


	// convert the set: first_is, last_is, length_is to:	first_is + length_is

	// default first_is is min_is
	if ( ! pFirstIsExpr )
		{
		pFirstIsExpr	= pMinIsExpr;
		}

	// default last_is is max_is or size_is+1
	if ( ! pLastIsExpr )
		{
		if ( pMaxIsExpr )
			pLastIsExpr	= pMaxIsExpr;
		else if ( pSizeIsExpr )
			pLastIsExpr = CreateSimpleBinaryArithExpression( OP_MINUS, pSizeIsExpr, GetConstant1() ); 
		}

	// length_is = (last_is - first_is) + 1;
	if ( ! pLengthIsExpr )
		{
		if ( pLastIsExpr )
			{
			pTmp1			= GetConstant1();
			pTmp2			= CreateSimpleBinaryArithExpression( OP_MINUS, pLastIsExpr, pFirstIsExpr);
			pLengthIsExpr	= CreateSimpleBinaryArithExpression( OP_PLUS, pTmp2, pTmp1 );
			}
		}
		
}


bool
FIELD_ATTR_INFO::VerifyOnlySimpleExpression()
{
    const int nExprTypes = 7;

    expr_node *pExpr[nExprTypes] = 
                    {
                    pSizeIsExpr,
                    pMinIsExpr,
                    pMaxIsExpr,
                    pLengthIsExpr,
                    pFirstIsExpr,
                    pIIDIsExpr,
                    pLastIsExpr,
                    };

    for ( int i = 0; i < nExprTypes; i++ )
    {
        // No expression is ok
        if ( NULL == pExpr[i] )
            continue;

        // A simple variable is ok
        if ( pExpr[i]->IsAVariable() )
            continue;

        // A pointer to a simple variable is ok
        if ( OP_UNARY_INDIRECTION == pExpr[i]->GetOperator() 
             && pExpr[i]->GetLeft()->IsAVariable() )
            {
            continue;
            }   

        // Everything else is not ok
        return false;
    }

    return true;
}


BOOL
FIELD_ATTR_INFO::SetExpressionVariableUsage( SIZE_LENGTH_USAGE )
{
    return TRUE;
}

#if 0

BUGBUG: CG_INTERFACE_POINTER has a bug.  See nodeskl.h for details

BOOL 
FIELD_ATTR_INFO::SetExpressionVariableUsage( SIZE_LENGTH_USAGE usage )
{
    const int nExprTypes = 7;

    expr_node *pExpr[nExprTypes] =
                    {
                    pSizeIsExpr,
                    pMinIsExpr,
                    pMaxIsExpr,
                    pLengthIsExpr,
                    pFirstIsExpr,
                    pIIDIsExpr,
                    pLastIsExpr,
                    };

    for ( int i = 0; i < nExprTypes; i++ )
        if ( ! SetExpressionVariableUsage( pExpr[i], usage ) )
            return false;

    return true;
}

BOOL
FIELD_ATTR_INFO::SetExpressionVariableUsage(
        expr_node          *pExpr,
        SIZE_LENGTH_USAGE   usage )
{
    if ( !pExpr )
        return true;

    if ( pExpr->IsAVariable() )
        {
        node_skl *pParent = NULL;
        node_skl *pType = pExpr->GetType();

        while ( NULL != pType && !pType->IsBasicType() )
            {
            pParent = pType;
            pType = pType->GetChild();
            }

        if ( NULL != pType && pType->IsBasicType() )
            {
            SIZE_LENGTH_USAGE TypeUsage = ((node_base_type *) pType)
                                                   ->GetSizeLengthUsage();
            if ( CSSizeLengthUsage == usage  
                 && NoSizeLengthUsage != TypeUsage )
                {
                return FALSE;
                }
            
            if ( CSSizeLengthUsage == TypeUsage  
                 && NoSizeLengthUsage != usage )
                {
                return FALSE;
                }

            if ( NoSizeLengthUsage != usage )
                {
                // Typically base type nodes are preallocated and identical.
                // Pointing at them with size_is, etc makes the different
                // because we need to note that fact.  So clone it to get
                // a new one.

                MIDL_ASSERT( NULL != pParent );
                pType = new node_base_type( (node_base_type *) pType );   
                ((node_base_type *) pType)->SetSizeLengthUsage( usage );
                pParent->SetChild( pType );
                }
            }
        }

    if ( ! SetExpressionVariableUsage( pExpr->GetLeft(), usage ) )
        return false;

    return SetExpressionVariableUsage( pExpr->GetRight(), usage );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\lex.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* SCCSWHAT( "@(#)lex.h	3.2 88/12/08 15:03:58	" ) */
/*
**	union used to return values from the lexer
*/

#if !defined(_LEX_H)

#define _LEX_H

typedef unsigned short token_t;

extern 	token_t yylex(void);
extern  void    yyunlex( token_t token);

token_t is_keyword(char*, short);

/*
 *	These parser flags control three things:
 *	1] whether the has parser has parsed a valid t_spec yet (ATYPE)
 *	2] whether "const" and "volatile" are modifiers (ACVMOD)
 *	3] whether we have a declaration with no type (AEMPTY)
 *	4] whether the rpc keywords are active. (RPC)
 *	5] whether we are in an enum\struct\union (AESU)
 *
 *	ISTYPENAME checks that we have not seen a type yet.
 */

#define REG
#define	PF_ATYPE		0x01
#define	PF_AESU			0x02
#define	PF_ASTROP		0x04
#define PF_ACVMOD		0x08
#define PF_AEMPTY		0x10
#define PF_RPC			0x20

#define PF_TMASK		(PF_ATYPE | PF_AESU | PF_ASTROP)
#define PF_MMASK		(PF_ACVMOD | PF_AEMPTY)
#define	PF_ISTYPENAME	((ParseFlags & PF_TMASK) == 0)
#define PF_ISMODIFIER	((ParseFlags & PF_MMASK) != 0)
#define PF_ISEMPTY		((ParseFlags & PF_AEMPTY) != 0)
#define PF_INRPC		(ParseFlags & PF_RPC)
#define PF_SET(a)		(ParseFlags |= (a))
#define PF_CLEAR(a)		(ParseFlags &= (~(a)))

#define PF_LOOKFORTYPENAME ((ParseFlags & PF_ATYPE) == 0)

extern short inside_rpc;

/* some notes about the parse flags....

PF_ATYPE is the important part of PF_LOOKFORTYPENAME, the macro that
tells the lexer whether or not it is valid to return an L_TYPENAME
token.  It should be cleared after a valid type is read (int, another
typedefed name, struct x, etc) and reset after an identifier is assigned
to that type.

*/

#define KW_IN_IDL	0x0001
#define KW_IN_ACF	0x0002
#define KW_IN_BOTH	( KW_IN_IDL | KW_IN_ACF )

#define M_OSF		0x0010
#define M_MSE		0x0020
#define M_CPORT		0x0040
#define M_ALL		(M_OSF | M_MSE | M_CPORT)

#define INBRACKET		0x0100
#define UNCONDITIONAL	0x0000
#define BRACKET_MASK	0x0100

#define LEX_NORMAL			0x0000
#define LEX_VERSION			0x0001	// return VERSION and set mode back to LEX_NORMAL
#define LEX_GUID			0x0002	// return GUID and set mode back to LEX_NORMAL
#define LEX_ODL_BASE_IMPORT     0x0005  // return KWIMPORTODLBASE STRING as next two tokens
#define LEX_ODL_BASE_IMPORT2    0x0006  // return STRING

#define MAX_STRING_SIZE	255

#endif // _LEX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\erep.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: erep.cxx
Title				: error reporting and recovery utility routines
Description			: contains associated routines for the grammar (pass 1)
History				:
	02-Jan-1992	VibhasC	Created
*****************************************************************************/

#pragma warning ( disable : 4514 )

/****************************************************************************
 *			include files
 ***************************************************************************/

#include "nulldefs.h"
extern	"C" {
	#include <stdio.h>
	#include <ctype.h>
	#include <string.h>
	
	#include "ebase.h"
	#include "idlerec.h"
	#include "acferec.h"
	#include "grammar.h"
	}
#include <limits.h>
#include "common.hxx"
#include "errors.hxx"
#include "filehndl.hxx"
#include "control.hxx"


/****************************************************************************
 *			external data
 ***************************************************************************/

extern CCONTROL	*	pCompiler;

/****************************************************************************
 *			external functions
 ***************************************************************************/

/****************************************************************************
 *			local  functions
 ***************************************************************************/

/****************************************************************************
 *			local definitions 
 ***************************************************************************/

#define IDENTIFIER_WEIGHT	(6)
#define NUMBER_WEIGHT		(6)
#define LBRACE_WEIGHT		(5)
#define RBRACE_WEIGHT		(5)
#define RBRACK_WEIGHT		(4)
#define LBRACK_WEIGHT		(4)
#define SEMI_WEIGHT			(3)
#define LPARAN_WEIGHT		(2)
#define RPARAN_WEIGHT		(2)
#define COMMA_WEIGHT		(1)
#define NO_WEIGHT			(0)

short					TokenWeight( short );

typedef short ELEMTYPE;

#define COMPARE_LESS( a, b )	 	( TokenWeight(a) < TokenWeight(b) )
#define COMPARE_GREATER( a, b ) 	( TokenWeight(a) > TokenWeight(b) )

extern char			*	GetExpectedSyntax( char *, short );
void					qsort( ELEMTYPE a[], int l, int r );
int						SearchForGotoStates( short, SGOTO ** );
BOOL					IsValidTokenInState( SGOTO *, short );

/*
   search in the state vs token table to see if a possible missing token
   can be detected. This routine is called when there is a syntax error, and
   a missing token may be the case. A token is a missing token, if the current
   state has a goto where the current token is valid. 

   For each state in the goto entries for the current state, check if the
   current token is a valid token. If it is , then this is a possible missing
   token.

   After the list of possinble missing tokens has been made, the tough part
   is deciding which is the best possible token. Im afraid, the only simple
   thing right now is to decide on the token, on some kind of priority basis.
   Later we might extend the parser semantic actions to indicate which token
   is the token of choice. But for now, this stays.
 */


short
PossibleMissingToken(
	short	State,
	short	CurrentToken)
	{
	short		Token;
	short	*	pToken;
	short	*	pTokenSave;
	SGOTO	*	pSGoto;
	int			Count, i;


	/*
	 * search for the states goto array
	 */

	Count = SearchForGotoStates( State, &pSGoto );

	if( !Count ) return -1;

	pToken = pTokenSave = new short[ Count ];

	/*
	   for each goto in the array, search for the state where the current
	   token is valid.
	 */
	
	for( i = 0;
		 i < Count;
		 i++ )
		 {

		 if( IsValidTokenInState( pSGoto + i, CurrentToken ))
			{
			Token 	  = (pSGoto+i)->Token;

		 	if( (Token < 128 )			||
			 	(Token == IDENTIFIER)	||
			 	(Token == NUMERICCONSTANT))
				{
				*pToken++ = Token;
				}

			}

		 }
	/*
		if we cannot make any intelligent decision about the lookahead token
		pick up the ones in the current lookahead set

	 */

	if( (pToken - pTokenSave) == 0 )
		{
		delete pTokenSave;
		return -1;
		}

	if( pCompiler->GetPassNumber() == IDL_PASS )
		{
		if( (pToken - pTokenSave) == 0 )
			{
			for( i = 0;
		 		i < Count;
		 		i++ )
		 		{
		
	
				Token = (pSGoto+i)->Token;
	
		 		if( (Token < 128 )			||
			 		(Token == IDENTIFIER)	||
			 		(Token == NUMERICCONSTANT))
					{
					*pToken++ = Token;
					}
	
		 		}
			}
		}


	/*
		We now have a list of possible tokens. Sort them in the order of
		priority.
	 */
	
	if( pToken - pTokenSave )
		{
        MIDL_ASSERT( (pToken - pTokenSave - 1) <= INT_MAX );
		qsort( pTokenSave, 0, (int) (pToken - pTokenSave - 1));

		/* return the first in the list */

		CurrentToken =  *pTokenSave;

		}
	else
		CurrentToken = -1;


	delete pTokenSave;

	return CurrentToken;
	}

int
SearchForGotoStates(
	short	State,
	SGOTO	**	ppSGoto)
	{
	int				i;
	SGOTOVECTOR	*	p = SGotoIDL;
	short			ValidStates;

	if( (pCompiler->GetPassNumber() == IDL_PASS ) )
		{
		ValidStates = VALIDSTATES_IDL;
		p = SGotoIDL;
		}
	else
		{
		ValidStates = VALIDSTATES_ACF;
		p = SGotoACF;
		}

	for( i = 0; i < ValidStates; ++i,++p )
		{
		if( p->State == State )
			{
			*ppSGoto = p->pSGoto;
			return p->Count;
			}
		}
	return 0;
	}

BOOL
IsValidTokenInState(
	SGOTO *	pSGoto,
	short	Token )
	{
	int			Count,i;
	SGOTO	*	p;
	short		State = pSGoto->Goto;
	
	Count = SearchForGotoStates( State, &p );

	if( !Count )
		{

	if( pCompiler->GetPassNumber() == IDL_PASS )
		{
		if( ( (pSGoto->Token == IDENTIFIER ) ||
			  (pSGoto->Token == NUMERICCONSTANT) &&
			  (Token == (short) ';' )) )
			  {
			  return TRUE;
			  }
		}

		return FALSE;
		}

	for( i = 0; i < Count; ++i, ++p )
		{
		if( p->Token == Token )
			return TRUE;
		}
	return FALSE;
	}

void
qsort( 
	ELEMTYPE	a[],
	int			l,
	int			r )
	{

	ELEMTYPE	v, t;
	int			i, j;


	if( r > l )
		{

		v	= a[ r ];
		i 	= l - 1;
		j	= r;

		for (;; )
			{

			/** sort in reverse order of token weight **/

			while( COMPARE_GREATER( a[ ++i ], v ) );
			while( COMPARE_LESS( a[ --j ], v ) );

			if( i >= j ) break;

			t		= a[ i ];
			a[ i ]	= a[ j ];
			a[ j ] 	= t;

			}

		t		= a[ i ];
		a[ i ]	= a[ r ];
		a[ r ] 	= t;

		qsort( a, l, i - 1 );
		qsort( a, i+1, r );
		}
	}

char *
GetExpectedSyntax(
	char	*	pBuffer,
	short		state )
	{
	int 		i = 0;
	int			Max;
	DBENTRY *	pDB;

	if( (pCompiler->GetPassNumber() == IDL_PASS ) )
		{
		pDB	= IDL_SyntaxErrorDB;
		Max	= MAXSTATEVSEXPECTED_SIZE_IDL;
		}
	else
		{
		pDB	= ACF_SyntaxErrorDB;
		Max	= MAXSTATEVSEXPECTED_SIZE_ACF;
		}

	while( i < Max ) 
		{
		if( pDB[ i ].State == state )
			{
			char fFirst = 1;
			strcpy( pBuffer , "expecting ");

			while( pDB[ i ].State == state )
				{
				// make sure not to report the same translated string twice, when two non-terminals
				// have the same translated string
				if ( !strstr( pBuffer, pDB[ i ].pTranslated ) )
					{
					if( !fFirst )
						strcat( pBuffer, " or ");
					fFirst = 0;
					strcat( pBuffer, pDB[ i ].pTranslated );
					}
				i++;
				}
			return pBuffer;
			}
		else
			i++;
		}
	return (char *)NULL;
	}

short
TokenWeight(
	short	Token)
	{
	switch( Token )
		{
		case IDENTIFIER:			return IDENTIFIER_WEIGHT;

		case NUMERICCONSTANT:		return NUMBER_WEIGHT;

		case (short)(']'):			return RBRACK_WEIGHT;

		case (short)('['):			return LBRACK_WEIGHT;

		case (short)('{'):			return LBRACE_WEIGHT;

		case (short)('}'):			return RBRACE_WEIGHT;

		case (short)(';'):			return SEMI_WEIGHT;

		case (short)('('):			return LPARAN_WEIGHT;

		case (short)(')'):			return RPARAN_WEIGHT;

		case (short)(','):			return COMMA_WEIGHT;

		default:					return NO_WEIGHT;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\lex.cxx ===
/********************************** module *********************************/
/*              Copyright (c) 1993-2000 Microsoft Corporation              */
/*                                                                         */
/*                                  cclex                                  */
/*                  lexical analyser for the C compiler                    */
/*                                                                         */
/***************************************************************************/
/*                                                                         */
/*    @ Purpose:                                                           */
/*                                                                         */
/*    @ Functions included:                                                */
/*                                                                         */
/*                                                                         */
/*    @ Author: Gerd Immeyer              @ Version:                       */
/*                                                                         */
/*    @ Creation Date: 1987.02.09         @ Modification Date:             */
/*                                                                         */
/***************************************************************************/


#pragma warning ( disable : 4514 4310 4710 )

#include "nulldefs.h"
extern "C" {
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <ctype.h>
}

#include "common.hxx"
#include "errors.hxx"
#include "midlnode.hxx"
#include "listhndl.hxx"
#include "filehndl.hxx"
#include "lextable.hxx"
#include "lexutils.hxx"
#include "grammar.h"
#include "gramutil.hxx"
#include "cmdana.hxx"
#include "mbcs.hxx"

extern "C" {
    #include "lex.h"
}

extern void ParseError( STATUS_T, char *);
extern  NFA_INFO *pImportCntrl;

extern  lextype_t   yylval;

extern token_t  toktyp_G;           /* token type */
extern short    toklen_G;           /* len of token string */
extern char     *tokptr_G;          /* pointer to token string */
extern long     tokval_G;           /* value of constant token */
extern short    curr_line_G;


extern LexTable *pMidlLexTable;
extern short    CompileMode;
extern CMD_ARG * pCommand;

int chCached = 0;

char NewCCputbackc( char ch )
    {
    if (chCached)
    {
        pImportCntrl->UnGetChar(short(chCached));
    }
    chCached = ch;

    if ( ch == '\n' )
        curr_line_G--;
    return ch;
    }


/*****              definition of state table fields            ****/

#define ERR 0x7f0c          /* character not in character set */

#define X10 0x0100
#define X11 0x0101
#define X20 0x0200
#define X21 0x0201
#define X23 0x0203
#define X30 0x0300
#define X40 0x0400
#define X41 0x0401
#define X43 0x0403
#define X50 0x0500
#define X51 0x0501
#define X53 0x0503
#define X62 0x0602
#define X70 0x0700
#define X71 0x0701
#define X73 0x0703
#define X82 0x0802
#define X90 0x0900
#define X91 0x0901

#define XLQ 0x0a00
#define XLD 0x0b00

/*----              define of single operators          ----*/

#define O65     0x410d                      /* ' 65 */
#define O43     ('(' * 256 + 12)            /* ( 43 */
#define O44     (')' * 256 + 12)            /* ) 44 */
#define O49     (',' *256 + 12)             /* , 49 */
#define O24     ('.' *256 + 10)             /* . 24 */
#define O14     (':'  *256 + 12)            /* : 14 */
#define O50     (';'  *256 + 12)            /* ; 50 */
#define O13     ('?'  *256 + 12)            /* ? 13 */
#define O47     ('['  *256 + 12)            /* [ 47 */
#define O48     (']'  *256 + 12)            /* ] 48 */
#define O45     ('{'  *256 + 12)            /* { 45 */
#define O46     ('}'  *256 + 12)            /* } 46 */
#define O23     ('~'  *256 + 12)            /* ~ 23 */
#define OHS     ('#'  *256 + 12)            /* #    */
#define O64     0x400e                      /* " 64 */
#define O7d     0x0000                      /*  eol */
#define O7e     (short)0x9f0c               /*  eof */

/*----         define of possible multi character operator      ----*/

#define D00 0x000b      /* - 00 */
#define D01 0x010c      /* / 01 */
#define D02 0x020c      /* < 02 */
#define D03 0x030c      /* > 03 */
#define D04 0x040c      /* ! 04 */
#define D05 0x050c      /* % 05 */
#define D06 0x060c      /* & 06 */
#define D07 0x070c      /* * 07 */
#define D08 0x080b      /* + 08 */
#define D09 0x090c      /* = 09 */
#define D0a 0x0a0c      /* ^ 0a */
#define D0b 0x0b0c      /* | 0b */


/*****             character table              *****/
/*  MIDL supports the ANSI character set as input   */

const extern short ct[256]= {

/*     0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f    */
     O7e,ERR,ERR,ERR,ERR,  0,ERR,ERR,ERR,  0,O7d,ERR,  0,  0,ERR,ERR,
/*    10  11  12  13  14  15  16  17  18  19  1a  1b  1c  1d  1e  1f    */
     ERR,ERR,ERR,ERR,ERR,ERR,ERR,ERR,ERR,ERR,O7e,ERR,ERR,ERR,ERR,ERR,
/*         !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /    */
       0,D04,O64,OHS,ERR,D05,D06,O65,O43,O44,D07,D08,O49,D00,O24,D01,
/*     0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?    */
       7,  8,  8,  8,  8,  8,  8,  8,  9,  9,O14,O50,D02,D09,D03,O13,
/*     @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O    */ 
     ERR,  1,  1,  1,  1,  2,  3,  4,  4,  4,  4,  4, 15,  4,  4,  4,
/*     P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _    */ 
       4,  4,  4,  4,  4,  4,  4,  4,  6,  4,  4,O47,ERR,O48,D0a,  4,
/*     `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o    */ 
     ERR,  1,  1,  1,  1,  2,  3,  4,  4,  4,  4,  4,  5,  4,  4,  4,
/*     p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~ DEL    */ 
       4,  4,  4,  4,  4,  4,  4,  4,  6,  4,  4,O45,D0b,O46,O23,ERR,
/*    80  81  82  83  84  85  86  87  88  89  8a  8b  8c  8d  8e  8f    */
       4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
/*    90  91  92  93  94  95  96  97  98  99  9a  9b  9c  9d  9e  9f    */
       4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
/*    a0  a1  a2  a3  a4  a5  a6  a7  a8  a9  aa  ab  ac  ad  ae  af    */
       4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
/*    b0  b1  b2  b3  b4  b5  b6  b7  b8  b9  ba  bb  bc  bd  be  bf    */
       4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
/*    c0  c1  c2  c3  c4  c5  c6  c7  c8  c9  ca  cb  cc  cd  ce  cf    */
       4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
/*    d0  d1  d2  d3  d4  d5  d6  d7  d8  d9  da  db  dc  dd  de  df    */
       4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
/*    e0  e1  e2  e3  e4  e5  e6  e7  e8  e9  ea  eb  ec  ed  ee  ef    */
       4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
/*    f0  f1  f2  f3  f4  f5  f6  f7  f8  f9  fa  fb  fc  fd  fe  ff    */
       4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4};


/*****              state transition table          *****/

const extern short st[ 13 ][ 16 ] = {

//               0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15 
//             spc a-d   e   f g-z   l   x   0 1-7 8-9   . + -  op   '  "    L
//                                                                    
/* start 0 */    0,  1,  1,  1,  1,  1,  1,  2,  5,  5,X90,X90,X90,X90,X90, 12,
/* name  1 */  X10,  1,  1,  1,  1,  1,  1,  1,  1,  1,X11,X11,X11,X11,X11,  1,
/* 0     2 */  X20,X23,  9,X23,X23,X30,  3,  6,  6,  6,X23,X21,X21,X21,X21,X30,
/* 0x    3 */  X53,  4,  4,  4,X53,X53,X53,  4,  4,  4,X53,X53,X53,X53,X53,X53,
/* hex   4 */  X50,  4,  4,  4,X53,X53,X53,  4,  4,  4,X53,X51,X51,X51,X51,X53,
/* int   5 */  X20,X23,  9,X23,X23,X23,X23,  5,  5,  5,X21,X21,X21,X21,X21,X23,
/* oct   6 */  X70,X73,  9,X73,X73,X73,X73,  6,  6,  5,  8,X71,X71,X71,X71,X73,
/* .     7 */  X91,X91,X91,X91,X91,X91,X91,X91,X91,X91,X91,X91,X91,X91,X91,X91,
/* int.  8 */  X40,X43,  9,X43,X43,X43,X43,  8,  8,  8,X43,X41,X41,X41,X41,X43,
/* .e    9 */  X40,X43,X43,X43,X43,X43,X43, 11, 11, 11,X43, 10,X41,X41,X41,X43,
/* .e-   10*/  X43,X43,X43,X43,X43,X43,X43, 11, 11, 11,X43,X43,X43,X43,X43,X43,
/* .e-i  11*/  X40,X43,X43,X43,X43,X43,X43, 11, 11, 11,X43,X41,X41,X41,X41,X43,
/* L     12*/  X10,  1,  1,  1,  1,  1,  1,  1,  1,  1,X11,X11,X11,XLQ,XLD,  1

};


/*****             multi character operator table           *****/

const token_t moptab[]     = {

/*             0   1   2   3   4   5   6   7   8   9  10  11      */
/*             -   /   <   >   !   %   &   *   +   =   ^   |      */
/*                                                                */
/*  single */ MINUS,DIV,LT,GT,EXCLAIM, MOD,
                                AND,  MULT, PLUS, ASSIGN, XOR, OR,
/*  op =   */ SUBASSIGN, DIVASSIGN, LTEQ, GTEQ, NOTEQ, 
              MODASSIGN, ANDASSIGN, MULASSIGN, ADDASSIGN, EQUALS, 
              XORASSIGN, ORASSIGN,
/*  op op  */ DECOP, GARBAGETOKEN, LSHIFT, RSHIFT, 0, 0,
                                ANDAND, 0, INCOP, EQUALS, 0, OROR   };

/*****          define of the action routines           *****/

token_t name(void);
token_t mulop(void);
token_t character(void);
token_t string(void);
token_t ProcessHash();
token_t ProcessComplexDefine( char *, char *, int );
token_t LChar();
token_t LStr();

extern token_t ScanGuid( void );
extern token_t ScanVersion( void );
extern token_t ScanImplicitImports(void);

typedef token_t (*TOKEN_PFN)(void);

const static TOKEN_PFN action[] = {
    0,              /* unused */
    name,               /* handle name token */
    cnv_int,            /* convert integer token */
    cnv_int,            /* convert integer token */
    cnv_hex,                /* convert hex constant */
    cnv_hex,                /* convert hex constant */
    cnv_octal,          /* convert octal constant */
    cnv_octal,          /* convert octal constant */
    cnv_float,          /* convert floating point constant */
    mulop,          /* handle multi character operator */
    LChar,          /* wide character */
    LStr,           /* wide character string */
    };

/*****          declare of global varables          *****/

static short ci;            /* current state character index */
static char ch;         /* current character */
static int pbch;        /* flag describing whether to take the next char
                            or not */
char LastLexChar;

unsigned short LexContext   = LEX_NORMAL;

#define MAX_LINE_SIZE 256
static char tok_buffer[MAX_LINE_SIZE];

token_t IsValidPragma( char *);


/*............................. internal function ..........................*/
/*                                      */ 
/*              comment analyzer                */ 
/*                                      */ 

token_t comment()
{
    BOOL    fParseError = FALSE;

    for (;;)
        {
        ch = NewCCGetch();
        if (ch == 0)
            {
            fParseError = TRUE;
            break;
            }
        if (CurrentCharSet.IsMbcsLeadByte(ch))
            {
            NewCCGetch();
            }
        else if (ch == '*')
            {
            char    chNext = NewCCGetch();
            if (chNext == 0)
                {
                fParseError = TRUE;
                break;
                }
            if (CurrentCharSet.IsMbcsLeadByte(chNext))
                {
                NewCCGetch();
                }
            else if (chNext == '/')
                {
                break;
                }
            else if (chNext == '*')
                {
                NewCCputbackc(chNext);
                }
            }
        }
    if (fParseError)
        {
        ParseError(EOF_IN_COMMENT, (char *)NULL);   /*   no end of comment operator */
        exit( EOF_IN_COMMENT );
        }
    return ( NOTOKEN );
}

token_t commentline()
{
    for (;;)
        {
        ch =  NewCCGetch();
        if( ch == 0 )
            {
            ParseError(EOF_IN_COMMENT, (char *)NULL);
            exit( EOF_IN_COMMENT );
            break;
            }
        else if (CurrentCharSet.IsMbcsLeadByte(ch))
            {
            NewCCGetch();
            }
        else if (ch == '\n')
            {
            break;
            }
        }
    return ( NOTOKEN );         /* get the next token */
}


/*............................. internal function ..........................*/
/*                                      */ 
/*              multi character operator                */
/*                                      */ 

const static token_t *snglop = &moptab[0];  /* adr of single character operator */
const static token_t *assgop = &moptab[12]; /* adr of assignment operator */
const static token_t *dblop  = &moptab[24]; /* adr of double character operator */

token_t mulop()
    {
    REG unsigned short i;                   /* index into multi operator table */
    REG char lstch;
//printf ("in mulop ch = %c\n", ch);

    i = unsigned short(((unsigned short)ci) >> 8);  /* get high byte of character index */
    if( i > 11 ) {          /* is it a type specification ? */
        // check for EOI
        if ( ci == short(0x9f0c) ) 
            {
            if(pImportCntrl->GetLexLevel() == 0)
                {
                if(pImportCntrl->GetEOIFlag())
                    return 0;
                else
                    pImportCntrl->SetEOIFlag();
                }
            return EOI;
            }
        if( i == 64 )           /* character is " */
            return ( string() );    /* handle string token */
        if( i == 65 )           /* character is ' */
            return ( character() ); /* handle character constant */
        if( i == '#' )
            return ProcessHash();   /* process any hash tokens */
        if( i == '.' )
            {
            if( (ch = NewCCGetch()) == '.' )
                {
                return DOTDOT;
                }
            NewCCputbackc( ch );
            }

        if ( i == LBRACK )
            {
            inside_rpc++;
            return i;
            }
        if ( i == RBRACK )
            {
            inside_rpc--;
            return i;
            }

        return ( i );               /* return type of single operator */
    }
    lstch = ch;                     /* save entry character */
    ch = NewCCGetch();              /* get a new one */
    if (CurrentCharSet.IsMbcsLeadByte(ch))
        {
        toklen_G = 1;
        tokptr_G[1] = 0;
        NewCCputbackc(ch);
        return *(snglop+i);
        }
    tokptr_G[1] = ch; tokptr_G[2] = 0;
    toklen_G = 2;                   /* add to token string */
    if( ch == '=' ) {               /* is next character an equal op. */
        return *(assgop+i);         /* return an assign operator */
    }
    if( lstch == ch ) {             /* is next char. = current char. ? */
        toktyp_G = *(dblop+i);      /*   yes, get its type */
        if( !toktyp_G ) {           /* is it a doppel operator ? */ 
            toklen_G = 1;           /* update token string */
            tokptr_G[1] = 0;
            NewCCputbackc(ch);      /* deliberate, puback of EOF is ignored */
            return *(snglop+i);     /*   no, return single operator */
        }
        if( ch == '/' )             /* if the operator is double // */
            {
            // potentially an error

//          ParseError( SINGLE_LINE_COMMENT, (char *)0 );
            return(commentline());  /*   the next line is a comment */
            }
        ch = NewCCGetch();                  /* get next character */
        if (ch == '=') {
            tokptr_G[2] = '='; tokptr_G[3] = '\0';
            toklen_G = 3;           /* update token string */
                        if(toktyp_G == LSHIFT) {              /* if shift op.and equal sign ? */
                                return (LEFTASSIGN);                     /* return as assign operator */
                        }
                        if(toktyp_G == RSHIFT) {
                                return (RIGHTASSIGN);
            }
            tokptr_G[2] = '\0'; toklen_G = 2;
        }
        NewCCputbackc(ch);                  /* put back unused character */
        return (toktyp_G);              /* else return doppel char. operator */
    }
    if( lstch == '-' && ch == '>' ) {   /* if structure operator */
                return (POINTSTO);                    /* return structure operator */
    }
    if( lstch == '/' && ch == '*' ) {   /* if comment */
        return( comment() );            /* ignore the comment */
    }
    tokptr_G[1] = '\0'; toklen_G = 1;   /* remove from token string */
    NewCCputbackc(ch);                      /* putback unused character */
    return *(snglop+i);                 /* return single character operator */
}

/*............................. internal function ..........................*/
/*                                      */ 
/*          convert escape (\) character                */ 
/*                                      */ 

char convesc()
    {
    unsigned short  value = 0;
    unsigned short  tmp;
    BOOL            fConstantIsIllegal  = FALSE;

    ch = NewCCGetch();

    if ( ch == 'n' )
        ch = 0xa;
    else if (ch == 't')
        ch = 0x9;
    else if (ch == 'v')
        ch = 0xb;
    else if (ch == 'b')
        ch = 0x8;
    else if( ch == 'r' )
        ch = 0xd;
    else if( ch == 'f' )
        ch = 0xc;
    else if( ch == 'a' )
        ch = 0x7;
    else if( (ch == 'x') || (ch == 'X') )
        {
        int i;

        for( i = 0, value = 0, fConstantIsIllegal = FALSE; i < 2; ++i )
            {
            tmp = ch = NewCCGetch();
            tmp = (unsigned short)toupper( tmp );
            if( isxdigit( tmp ) )
                {
                tmp = unsigned short( (tmp >= '0') && (tmp <= '9') ? (tmp - '0') : (tmp - 'A') + 0xa );
                }
            else if( ch == '\'' )
                {
                NewCCputbackc( ch );
                break;
                }
            else
                {
                fConstantIsIllegal  = TRUE;
                }
            value = unsigned short( value * 16 + tmp );
        }

        if( fConstantIsIllegal || (value > (unsigned short) 0x00ff) )
            ParseError( ILLEGAL_CONSTANT, (char *)0 );

        ch = (char )value;
        }
    else if( (ch >= '0') && (ch <= '7'))
        {
        int i;
        value = unsigned short(ch - '0');

        // the limit for this for loop is 2 because we already saw 1 character

        for ( i = 0, value = unsigned short(ch - '0'), fConstantIsIllegal = FALSE; i < 2; ++i)
            {
            tmp = ch = NewCCGetch();
            if( (ch >= '0') && (ch <= '7'))
                {
                tmp = unsigned short(tmp - '0');
                value = unsigned short(value * 8 + tmp);
                }
            else if( ch == '\'' )
                {
                NewCCputbackc( ch );
                break;
                }
            else
                fConstantIsIllegal = TRUE;
            }


        if( fConstantIsIllegal || (value > (unsigned short) 0x00ff) )
            ParseError( ILLEGAL_CONSTANT, (char *)0 );
        ch = (char )value;
        }

    return ( ch );
    }


/*............................. internal function ..........................*/
/*                                      */ 
/*               string analyzer                */ 
/*                                      */ 

token_t
character()
    {
        ch = NewCCGetch();
        if (CurrentCharSet.IsMbcsLeadByte(ch))
            {
            tokptr_G[0] = ch;
            tokptr_G[1] = NewCCGetch();
            tokptr_G[2] = 0;
            toklen_G = 2;
            }
        else
            {
            if (ch == '\\')
                {
                ch = convesc();
                }
            tokptr_G[0] = ch;
            tokptr_G[1] = '\0';

            yylval.yy_numeric.Val = tokval_G = ch;
            }
        if (NewCCGetch() != '\'')
            {
            ParseError(CHAR_CONST_NOT_TERMINATED,(char *)NULL );
            exit( CHAR_CONST_NOT_TERMINATED );
            }
         return (CHARACTERCONSTANT);
    }

// this rtn is called when the quote has been sensed.

char*    g_pchStrBuffer   = 0;
unsigned long g_ulStrBufferLen = 1024;

//
// Scan ahead in the current file to see if the next non-space character is a
// quote.  If it is then this is a string constant that is split into two
// pieces (e.g. "this" ... " is a " ... "test").  If the next character is 
// not a quote reset the file back to where we started from.
//
// If this is a multi-string situation return MULTIPLE_PROPERTY_ATTRIBUTES.
// This is a bit of a mis-use of that error code but it sounds nice.
//
// HACKHACK: The routine depends on internal knowledge of how NewCCGetch works.
//           Doing something similiar using the grammar was tried but failed
//           when processing imports because of details of how the trickery
//           played on the lexer works to get it to change streams in mid-go.
//

STATUS_T spacereadahead()
{
    fpos_t  fpos;
    short   newlines = 0;
    int     ch = ' ';

    if (0 != fgetpos(hFile_G, &fpos))
        return INPUT_READ;

    while (isspace(ch) && !feof(hFile_G))
        {
        ch = getc(hFile_G);

        if ( '\n' == ch )
            ++newlines;
        }

    if ('\"' == ch)
        {
        curr_line_G = (short) (curr_line_G + newlines);
        return MULTIPLE_PROPERTY_ATTRIBUTES;
        }
    else
        {
        if (0 != fsetpos(hFile_G, &fpos))
            return INPUT_READ;

        return STATUS_OK;
        }
}


token_t
string()
    {
    STATUS_T    Status          = STATUS_OK;
    char    *   ptr;

    if ( !g_pchStrBuffer )
        {
        g_pchStrBuffer = ( char * )malloc( sizeof( char ) * g_ulStrBufferLen );
        if ( NULL == g_pchStrBuffer )
            {
            RpcError( 0, 0, OUT_OF_MEMORY, 0 );
            exit( OUT_OF_MEMORY );
            }
        }

    strncpy( g_pchStrBuffer, tokptr_G, toklen_G );
    ptr = g_pchStrBuffer;

    ch  = 0;
    while( ( ch != '"' ) && ( Status == STATUS_OK ) )
        {
        if ( ( unsigned long ) ( ptr - g_pchStrBuffer ) > ( g_ulStrBufferLen - 3 ) )
            {
            char* pTempStrBuffer = ( char* ) realloc( g_pchStrBuffer, g_ulStrBufferLen * 2 );
            if ( pTempStrBuffer )
                {
                ptr = ( g_pchStrBuffer - ptr ) + pTempStrBuffer;
                g_pchStrBuffer = pTempStrBuffer;
                g_ulStrBufferLen = g_ulStrBufferLen * 2;
                }
            else
                {
                Status = STRING_TOO_LONG;
                }
            }

        ch  = NewCCGetch();

        if( ch == 0 )
            {
            Status  = EOF_IN_STRING;
            }
        else if ( ch == '\\' )
            {
            *ptr++ = ch;
            *ptr++ = NewCCGetch();
            ch = 0;
            }
        else if ( ch != '\"' )
            {
            *ptr++  = ch;
            if (CurrentCharSet.IsMbcsLeadByte(ch))
                *ptr++ = NewCCGetch();
            }
        else
            {
            Status = spacereadahead();

            if ( MULTIPLE_PROPERTY_ATTRIBUTES == Status )
                {
                Status = STATUS_OK;
                ch = 0;
                }
            }
        }
    
    *ptr = 0;

    if( Status != STATUS_OK )
        {
        ParseError( Status, (char *)0 );
        exit( Status );
        }

    yylval.yy_string = pMidlLexTable->LexInsert( g_pchStrBuffer );
    return ( STRING );
    }
/****************************** external function ***************************/
/*                                      */ 
/*              lexical analyzer                */ 
/*                                      */ 

static BOOL     fLastToken  = 0;
static BOOL     fLineLengthError = 0;
static token_t  LastToken;

void
initlex()
    {
    fLastToken  = 0;
    }


void
yyunlex( token_t T )
    {
    LastToken   = T;
    fLastToken  = 1;
    }

token_t yylex()
{
    REG short state;        /* token state */
    REG char *ptr;

    if( fLastToken )
        {
        fLastToken  = 0;
        return LastToken;
        }

    if ( LexContext != LEX_NORMAL )
        {
        switch ( LexContext )
            {
            case LEX_GUID:
                {
                LexContext = LEX_NORMAL;
                return ScanGuid();
                }
            case LEX_VERSION:
                {
                LexContext = LEX_NORMAL;
                return ScanVersion();
                }
            case LEX_ODL_BASE_IMPORT:
            case LEX_ODL_BASE_IMPORT2:
                {
                return ScanImplicitImports();
                break;
                }
            default:
                MIDL_ASSERT(0);

            }
        }

again:
    state = 0;              /* initial state */
    ptr = tokptr_G = tok_buffer;    /* remember token begin position */
    toklen_G = 0;
    
    do
        {
        ci = ct[ (unsigned char) (ch=NewCCGetch()) ];         /* character index out of char.tab. */
        state = st[ state ][ ci & 0x00ff ]; /* determine new state */
        } while ( state == 0 );                 /* skip white space */
    
    *(ptr++) = ch;
    toklen_G++;             /* add chacter to token string */

    if (CurrentCharSet.IsMbcsLeadByte(ch))
        {
        *(ptr++) = NewCCGetch();
        toklen_G++;
        }
    
    while( state < 13 )
        {           /* loop til end state */
        ci = ct[ (unsigned char) (ch=NewCCGetch()) ];       /* character index out of char.tab. */
        state = st[ state ][ ci & 0x00ff ]; /* determine new state */
        if (state < 13)
            {                   /* if still going, */
            if (toklen_G + 1 != MAX_LINE_SIZE) /* and the token isn't too large */
                {
                *(ptr++) = ch;  toklen_G++;     /* add chacter to token string */
                if (CurrentCharSet.IsMbcsLeadByte(ch))
                    {
                    *(ptr++) = NewCCGetch();
                    toklen_G++;
                    }
                }
            else
                {
                fLineLengthError = 1;
                }
            }
        };
    
    *ptr = '\0';
    LastLexChar = ch;

    if (fLineLengthError)
        {
        ParseError(IDENTIFIER_TOO_LONG, (char *)0 );    
        fLineLengthError = 0;
        }

    switch( state & 0x00ff )
        {
        case 2: ch = NewCCGetch();      /* position to next character */
            break;

        case 3: 
        case 1: NewCCputbackc(ch);          /* position to current character */
            break;
        /* case 0 - do nothing */
        }
//printf ("current ch = %c\n", ch);
    toktyp_G = (*action[ state >> 8 ])();   /* execute action */

    // skip fluff like #line
    if (toktyp_G == NOTOKEN)
        goto again;

    return(toktyp_G);
}

token_t
LChar()
    {
    character();
    return WIDECHARACTERCONSTANT;
    }

token_t
LStr()
    {
    string();
    return WIDECHARACTERSTRING;
    }

// process line number tokens
token_t
ProcessLine()
    {
    char    *   ptr     = tokptr_G;

    curr_line_G = short( atoi( ptr ) - 1 );
    
    // skip spaces before file name
    while ( ( ch = NewCCGetch() ) == ' ' ) 
        ;

    ptr = tokptr_G;
    // see if we got a filename
    if ( ch == '\"' )
        {
        for (;;)
            {
            ch = NewCCGetch();
            *ptr++ = ch;
            if (CurrentCharSet.IsMbcsLeadByte(ch))
                {
                *ptr++ = NewCCGetch();
                }
            else if (ch == '\"')
                {
                break;
                }
            }
        *(--ptr) = '\0';

        StripSlashes( tokptr_G );

        pImportCntrl->SetLineFilename( tokptr_G );

        }
    
    // skip to end of line
    for (;;)
        {
        ch = NewCCGetch();
        if (ch == 0)
            {
            break;
            }
        else if (CurrentCharSet.IsMbcsLeadByte(ch))
            {
            ch = NewCCGetch();
            }
        else if (ch == '\n')
            {
            break;
            }
        }

    return NOTOKEN;
    }

// process # <something>
token_t
ProcessHash()
    {
    char    *   ptr     = tokptr_G,
            *   ptrsave = ptr;
    token_t     PragmaToken;

    do  // eat spaces
        {
        ch = NewCCGetch();
        } while( isspace( ch ) );

    // collect first token
    while( !isspace( ch ) )
        {
        *ptr++ = ch;
        if (CurrentCharSet.IsMbcsLeadByte(ch))
            {
            *ptr++ = NewCCGetch();
            }
        ch = NewCCGetch();
        }
    *ptr = '\0';

    // is this hash a pragma starter ?

#define PRAGMA_STRING               ("pragma")
#define LEN_PRAGMA_STRING           (6)
#define MIDL_PRAGMA_PREFIX          ("midl_")
#define LEN_MIDL_PRAGMA_PREFIX      (5)
#define LINE_STRING                 ("line")
#define LEN_LINE_STRING             (4)

    // we handle #pragma and #line directives

    // #line found
    if (strncmp( tokptr_G, LINE_STRING, LEN_LINE_STRING ) == 0 ) 
        {
        ptr = tokptr_G;
        // get the next token (the number)
        do  // eat spaces
            {
            ch = NewCCGetch();
            } while( isspace( ch ) );

        // collect first token
        while( !isspace( ch ) )
            {
            *ptr++ = ch;
            if (CurrentCharSet.IsMbcsLeadByte(ch))
                {
                *ptr++ = NewCCGetch();
                }
            ch = NewCCGetch();
            }
        *ptr = '\0';
        return ProcessLine();   // this needs to be called with tokptr_G pointing after
                                // the #line part
        }
    // # <number> found
    else if ( isdigit(*tokptr_G) )
        {
        *ptr = '\0';
        return ProcessLine();
        }
    else if( strncmp( tokptr_G, PRAGMA_STRING, LEN_PRAGMA_STRING ) == 0 )
        {
        // eat white space between #pragma and next word
        for(;;)
            {
            ch = NewCCGetch();
            if(!isspace(ch) ) break;
            *ptr++ = ch;
            }

        ptrsave = ptr;

        *ptr++ = ch;

        // pull next word in
        for(;;)
            {
            ch = NewCCGetch();
            if(!isalpha(ch) && (ch != '_') ) break;
            *ptr++ = ch;
            if (CurrentCharSet.IsMbcsLeadByte(ch))
                {
                *ptr++ = NewCCGetch();
                }
            }

        // put back next char (it may even be the \n)
        NewCCputbackc( ch );
        *ptr = 0;

        // check if it is a MIDL pragma or not
        if ( ( PragmaToken  = IsValidPragma( ptrsave ) ) != 0 )
            {
            return PragmaToken;
            }


        // assume it is some other C pragma, so return the string

        for (;;)
            {
            ch = NewCCGetch();
            *ptr++ = ch;
            if (CurrentCharSet.IsMbcsLeadByte(ch))
                {
                *ptr++ = NewCCGetch();
                }
            else if (ch == '\n')
                {
                break;
                }
            }
        *(--ptr) = 0;

        yylval.yy_string = pMidlLexTable->LexInsert( ptrsave );
        return KWCPRAGMA;

        }
    else
        {
        // some graceful recovery by the parser
        return GARBAGETOKEN;
        }
    }

token_t
IsValidPragma( 
    char    *   p )
    {
static char * agPragmaNames[] = {
       "midl_import"
      ,"midl_echo"
      ,"midl_import_clnt_aux"
      ,"midl_import_srvr_aux"
      ,"pack"
};
static token_t agTokenVal[] = {
      KWMPRAGMAIMPORT
     ,KWMPRAGMAECHO
     ,KWMPRAGMAIMPORTCLNTAUX
     ,KWMPRAGMAIMPORTSRVRAUX
     ,KWCPRAGMAPACK
};

    short   Index = 0;

    while( Index < sizeof( agPragmaNames ) / sizeof(char *) )
        {
        if( !strcmp( p, agPragmaNames[ Index ] ) )
            return agTokenVal[ Index ];
        ++Index;
        }
    return 0;
    }

token_t
ScanGuid( void )
    {
    char        c;
    char    *   p = tokptr_G;

    if( (c = NewCCGetch()) == '\"' )
        {
        string();
        ParseError( QUOTED_UUID_NOT_OSF, (char *)0 );
        return UUIDTOKEN;
        }

    NewCCputbackc( c );

    // remove leading spaces.

    while ( (c = NewCCGetch()) != 0  && isspace( c ) )
        ;

    while ( c && (c  != ')') && (c != ',') && !isspace(c) )
        {
        *p++ = c;
        if (CurrentCharSet.IsMbcsLeadByte(c))
            {
            *p++ = NewCCGetch();
            }
        c = NewCCGetch();
        }

    NewCCputbackc( c );
    *p++ = 0;
    yylval.yy_string = pMidlLexTable->LexInsert(tokptr_G);

    return UUIDTOKEN;
    }

token_t
ScanVersion( void )
    {
    char        c;
    char    *   p = tokptr_G;

    //
    // remove leading spaces.
    //

    while ( (c = NewCCGetch()) != 0 && isspace(c) )
        ;

    while ( c && (c  != ')') && !isspace(c) )
        {
        *p++ = c;
        if (CurrentCharSet.IsMbcsLeadByte(c))
            {
            *p++ = NewCCGetch();
            }
        c    = NewCCGetch();
        }

    NewCCputbackc( c );
    *p++ = 0;
    yylval.yy_string = pMidlLexTable->LexInsert(tokptr_G);

    return VERSIONTOKEN;
    }

token_t
ScanImplicitImports( void )
    {
    switch ( LexContext )
        {
        case LEX_ODL_BASE_IMPORT:
            {
            tokptr_G    = "import";
            toktyp_G    = KWIMPORTODLBASE;
            LexContext  = LEX_ODL_BASE_IMPORT2;
            break;
            }
        case LEX_ODL_BASE_IMPORT2:
            {
            tokptr_G    = "oaidl.idl";
            toktyp_G    = STRING;
            yylval.yy_string = pMidlLexTable->LexInsert(tokptr_G);
            LexContext  = LEX_NORMAL;
            break;
            }
        default:
            MIDL_ASSERT(0);
        }


    return toktyp_G;    

    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\gramutil.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: gramutil.cxx
Title				: grammar utility routines
Description			: contains associated routines for the grammar (pass 1)
History				:
	05-Aug-1991	VibhasC	Created
*****************************************************************************/

#pragma warning ( disable : 4514 4710 )

/****************************************************************************
 *			include files
 ***************************************************************************/

#include "nulldefs.h"
extern	"C" {
	#include <stdio.h>
	#include <ctype.h>
	#include <string.h>
	
	}
#include "lextable.hxx"
#include "allnodes.hxx"
#include "gramutil.hxx"
#include "filehndl.hxx"
#include "idict.hxx"
#include "control.hxx"
#include "cmdana.hxx"

/****************************************************************************
 *			external data
 ***************************************************************************/

extern CMD_ARG			*	pCommand;
extern class _nfa_info	*	pImportCntrl;
extern pre_type_db		*	pPreAllocTypes;
extern SymTable			*	pBaseSymTbl;
extern node_error		*	pErrorTypeNode;
extern short				CompileMode;
extern node_e_attr		*	pErrorAttrNode;
extern CCONTROL			*	pCompiler;
extern LexTable			*	pMidlLexTable;
extern IINFODICT		*	pInterfaceInfoDict;
extern short				ImportLevel;
extern node_e_status_t	*	pError_status_t;
extern IDICT			*	pInterfaceDict;

/****************************************************************************
 *			external functions
 ***************************************************************************/

extern char			*	GetTypeName( short );
extern STATUS_T			GetBaseTypeNode( node_skl **, short, short, short);
extern ATTRLIST			GenerateFieldAttribute(ATTR_T, expr_list *);

extern char			*	GetExpectedSyntax( char *, short );
extern int				GetExpectedChar( short );
extern void				CheckGlobalNamesClash( SymKey );
extern void             NormalizeString( char*   szSrc, char*   szNrm );

/****************************************************************************
 *			local  functions
 ***************************************************************************/

/****************************************************************************
 *			local definitions
 ***************************************************************************/
//
// the parse stack
//
lextype_t	yyv[YYMAXDEPTH];	/* where the values are stored */
short		yys[YYMAXDEPTH];	/* the parse stack */


struct pre_init
	{
	unsigned short		TypeSpec;
	NODE_T				NodeType;
	ATTR_T				Attr; // signed or unsigned
	ATTR_T				Attr2; // __w64
	char			*	pSymName;
	};
struct pre_init PreInitArray[ PRE_TYPE_DB_SIZE ] =
{
 { /** float **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_UNDEF, TYPE_FLOAT, ATT_NONE )
  ,NODE_FLOAT
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"float"
 }
,{ /** double **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_UNDEF, TYPE_DOUBLE, ATT_NONE )
  ,NODE_DOUBLE
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"double"
 }
,{  /** __float80 **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_UNDEF, TYPE_FLOAT80, ATT_NONE )
  ,NODE_FLOAT80
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"__float80"
}
,{  /** __float128 **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_UNDEF, TYPE_FLOAT128, ATT_NONE )
  ,NODE_FLOAT128
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"__float128"
}
,{ /** signed hyper **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_HYPER, TYPE_INT, ATT_NONE )
  ,NODE_HYPER
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"hyper"
 }
,{ /** unsigned hyper **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_HYPER, TYPE_INT, ATT_NONE )
  ,NODE_HYPER
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"hyper"
 }
,{ /** signed int32 **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_INT32, TYPE_INT, ATT_NONE )
  ,NODE_INT32
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"__int32"
 }
,{ /** unsigned int32 **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_INT32, TYPE_INT, ATT_NONE )
  ,NODE_INT32
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"__int32"
 }
,{ /** signed int3264 **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_INT3264, TYPE_INT, ATT_NONE )
  ,NODE_INT3264
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"__int3264"
 }
,{ /** unsigned int3264 **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_INT3264, TYPE_INT, ATT_NONE )
  ,NODE_INT3264
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"__int3264"
 }
,{ /** signed int64 **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_INT64, TYPE_INT, ATT_NONE )
  ,NODE_INT64
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"__int64"
 }
,{ /** unsigned int64 **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_INT64, TYPE_INT, ATT_NONE )
  ,NODE_INT64
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"__int64"
 }
,{ /** signed int128 **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_INT128, TYPE_INT, ATT_NONE )
  ,NODE_INT128
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"__int128"
 }
,{ /** unsigned int128 **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_INT128, TYPE_INT, ATT_NONE )
  ,NODE_INT128
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"__int128"
 }
,{ /** signed long **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_LONG, TYPE_INT, ATT_NONE )
  ,NODE_LONG
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"long"
 }
,{ /** unsigned long **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_LONG, TYPE_INT, ATT_NONE )
  ,NODE_LONG
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"long"
 }
,{ /** signed int **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_UNDEF, TYPE_INT, ATT_NONE )
  ,NODE_INT
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"int"
 }
,{ /** unsigned int **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_UNDEF, TYPE_INT, ATT_NONE )
  ,NODE_INT
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"int"
 }
,{ /** __w64 signed long **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_LONG, TYPE_INT, ATT_W64 )
  ,NODE_LONG
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_W64
  ,"long"
 }
,{ /** __w64 unsigned long **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_LONG, TYPE_INT, ATT_W64 )
  ,NODE_LONG
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_W64
  ,"long"
 }
,{ /** __w64 signed int **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_UNDEF, TYPE_INT, ATT_W64 )
  ,NODE_INT
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_W64
  ,"int"
 }
,{ /** __w64 unsigned int **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_UNDEF, TYPE_INT, ATT_W64 )
  ,NODE_INT
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_W64
  ,"int"
 }
,{ /** signed short **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_SHORT, TYPE_INT, ATT_NONE )
  ,NODE_SHORT
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"short"
 }
,{ /** unsigned short **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_SHORT, TYPE_INT, ATT_NONE )
  ,NODE_SHORT
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"short"
 }
,{ /** signed small **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_SMALL, TYPE_INT, ATT_NONE )
  ,NODE_SMALL
  ,(ATTR_T)ATTR_SIGNED
  ,(ATTR_T)ATTR_NONE
  ,"small"
 }
,{ /** small **//** NOTE : SMALL W/O SIGN IS A SPECIAL HACK FOR THE BACKEND **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_SMALL, TYPE_INT, ATT_NONE )
  ,NODE_SMALL
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"small"
 }
,{ /** unsigned small **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_SMALL, TYPE_INT, ATT_NONE )
  ,NODE_SMALL
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"small"
 }
,{ /** signed char **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_CHAR, TYPE_INT, ATT_NONE )
  ,NODE_CHAR
  ,(ATTR_T)ATTR_SIGNED
  ,(ATTR_T)ATTR_NONE
  ,"char"
 }
,{ /** plain char **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_CHAR, TYPE_INT, ATT_NONE )
  ,NODE_CHAR
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"char"
 }
,{ /** unsigned char **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_CHAR, TYPE_INT, ATT_NONE )
  ,NODE_CHAR
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"char"
 }
,{ /** boolean **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_UNDEF, TYPE_BOOLEAN, ATT_NONE )
  ,NODE_BOOLEAN
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"boolean"
 }
,{ /** byte **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_UNDEF, TYPE_BYTE, ATT_NONE )
  ,NODE_BYTE
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"byte"
 }
,{ /** void **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_UNDEF, TYPE_VOID, ATT_NONE )
  ,NODE_VOID
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"void"
 }
,{ /** handle_t **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_UNDEF, TYPE_HANDLE_T, ATT_NONE )
  ,NODE_HANDLE_T
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"handle_t"
 }
,{ /** signed long long **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_LONGLONG, TYPE_INT, ATT_NONE )
  ,NODE_LONGLONG
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"long long"
 }
,{ /** unsigned long **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_LONGLONG, TYPE_INT, ATT_NONE )
  ,NODE_LONGLONG
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"long long"
 }
};


/*****************************************************************************/


SIBLING_LIST
SIBLING_LIST::Add( named_node * pNewNode )
	{
	if (pTail == NULL)
		{
		return Init( pNewNode );
		};

	if ( pNewNode )
		{
		named_node * pHead =  (named_node *) pTail->GetSibling();

		pNewNode->SetSibling( pHead );
		pTail->SetSibling(pNewNode);
		pTail = pNewNode;
		};

	return *this;
	};

SIBLING_LIST
SIBLING_LIST::Merge( SIBLING_LIST & NewList )
	{
	if (NewList.pTail == NULL)
		{
		return *this;
		};

	if ( pTail != NULL )
		{
		named_node * tmp = (named_node *)
					NewList.pTail->GetSibling();
		NewList.pTail->SetSibling( pTail->GetSibling());
		pTail->SetSibling(tmp);
		};

	pTail = NewList.pTail;
	return *this;
	};

named_node *
SIBLING_LIST::Linearize()
	{
	named_node * pHead;

	if (pTail == NULL)
		{
		pHead = NULL;
		}
	else
		{
		pHead =  (named_node *) pTail->GetSibling();

		pTail->SetSibling( (named_node *) NULL);
		};

	return pHead;
	};

void
SIBLING_LIST::AddAttributes( ATTRLIST & AList )
{
	named_node * 	pCur;
	ATTRLIST		pClone;

	// for each of the node_skl nodes, apply the ATTRLIST
	if ( pTail == NULL) return;

	pCur = pTail->GetSibling();
	// this traversal skips the last node on the list;
	// that one gets the original list added.
	while (pCur != pTail)
		{
		// clone attr list
		// apply to pCur
		pClone = AList.Clone();
		pCur->AddAttributes( AList );

		pCur = pCur->GetSibling();
		}

	pCur->AddAttributes( AList );

}

/*****************************************************************************/

/*** ParseError ************************************************************
 * Purpose	: format and report parsing errors
 * Input	:
 * Output	:
 * Notes	: errors will be reported many times. This is one localised place
 *			: for the RpcError Call
 ***************************************************************************/
void
ParseError(
	STATUS_T		Err,
	char 		*	pSuffix )
	{
	char	*	pFileName;
	short		Line;
	short		Col;
	char		TempBuf[512 + 50];
	char	*	pBuffer;
	ErrorInfo	ErrStats( Err );

	if ( !ErrStats.IsRelevant() )
		return;

	pImportCntrl->GetCurrentInputDetails( &pFileName, &Line, &Col);

	if (pSuffix)
		{
		strcpy( TempBuf, ": " );
		strcat( TempBuf, pSuffix );
		pBuffer = TempBuf;
		}
	else
		{
		pBuffer = "";
		}

	ErrStats.ReportError(pFileName, Line, pBuffer);
	}

void
SyntaxError(
	STATUS_T	Err,
	short		State )
	{

#define NEAR_STRING 			(" near ")
#define STRLEN_OF_NEAR_STRING	(6)

	extern	char *tokptr_G;
	char	*	pTemp;
	short		len		= (short) strlen( tokptr_G );
	char	*	pBuffer	= new char[
									512	+
									STRLEN_OF_NEAR_STRING +
									len + 2 +
									1 ];



#ifndef NO_GOOD_ERRORS

	if( Err == BENIGN_SYNTAX_ERROR )
		{
		GetExpectedSyntax( pBuffer, State );
		strcat( pBuffer, NEAR_STRING );
		strcat( pBuffer, "\"" );
		strcat( pBuffer, tokptr_G );
		strcat( pBuffer, "\"" );
		pTemp = pBuffer;
		}
	else
		pTemp = (char *)0;

	ParseError( Err, pTemp );

#else // NO_GOOD_ERRORS

	strcpy( pBuffer, "syntax error" );
	ParseError( Err, pBuffer );

#endif // NO_GOOD_ERRORS

	delete pBuffer;

	}


/*** BaseTypeSpecAnalysis  *************************************************
 * Purpose	: to check for valid base type specification
 * Input	: pointer to already collected specs, new base type spec
 * Output	: modified collected specs
 * Notes	:
 ***************************************************************************/
void
BaseTypeSpecAnalysis(
	struct _type_ana *pType,
	short			 NewBaseType )
	{
	char	TempBuf[ 50 ];

	if( pType->BaseType == TYPE_PIPE )
		return;
	if( (pType->BaseType != TYPE_UNDEF)  && (NewBaseType != TYPE_UNDEF) )
		{
		sprintf(TempBuf,", ignoring %s", GetTypeName(NewBaseType));
		ParseError(BENIGN_SYNTAX_ERROR, TempBuf);
		}
	if(NewBaseType != TYPE_UNDEF)
		pType->BaseType = NewBaseType;
	}

/**************************************************************************
 *		routines for the pre_type_db class
 **************************************************************************/
/*** pre_type_db *********************************************************
 * Purpose	: constructor for pre-allocated type data base
 * Input	: nothing
 * Output	:
 * Notes	: inits the prellocated types data base. This routine exist mainly
 *			: because static preallocation was giving a problem. If that is
 *			: solved, remove this
 **************************************************************************/
pre_type_db::pre_type_db (void)
	{
	named_node			*	pNode;
	int						i			= 0;
	struct _pre_type	*	pPreType	= &TypeDB[ 0 ];
	struct pre_init		*	pInitCur	= PreInitArray;

	while( i < PRE_TYPE_DB_SIZE )
		{
		pPreType->TypeSpec	= pInitCur->TypeSpec;
		pPreType->pPreAlloc	= pNode = new node_base_type(
										pInitCur->NodeType,
										pInitCur->Attr );
        if ( pInitCur->Attr2 == ATTR_W64 )
            {
            pNode->GetModifiers().SetModifier( pInitCur->Attr2 );
            }
		pNode->SetSymName( pInitCur->pSymName );
		pInitCur++;
		pPreType++;
		++i;
		}

	}

/*** GetPreAllocType ******************************************************
 * Purpose	: to search for a preallocated base type node, whose type
 *			: spec is provided
 * Input	: pointer to the resultant base node
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	:
 **************************************************************************/
STATUS_T
pre_type_db::GetPreAllocType(
	node_skl	 **	ppNode,
	unsigned short		TypeSpec )
	{
	int i = 0;

	if( GET_TYPE( TypeSpec ) == TYPE_PIPE )
		{
		(*ppNode) = pErrorTypeNode;
		return STATUS_OK;
		}

	while(i < sizeof(TypeDB) / sizeof(struct _pre_type) )
		{
		if( TypeDB[i].TypeSpec	== TypeSpec )
			{
			(*ppNode)	= TypeDB[i].pPreAlloc;
			return STATUS_OK;
			}
		++i;
		}
	return SYNTAX_ERROR;
	}


/****************************************************************************
 *			nested symbol table access support
 ***************************************************************************/
nsa::nsa( void )
	{
	SymTable *	pSymTable = new GlobalSymTable;
	CurrentLevel	= 0;
	InsertHead( (void *)pSymTable );
	}
STATUS_T
nsa::PushSymLevel(
	SymTable **ppSymTable )
	{
	STATUS_T	Status;
	SymTable *pSymTable = new SymTable;

	CurrentLevel++;
	Status = InsertHead( (void *)pSymTable);
	*ppSymTable = pSymTable;
	return Status;
	}
STATUS_T
nsa::PopSymLevel(
	SymTable **ppSymTable )
	{
	if(CurrentLevel == 0)
		return I_ERR_SYMTABLE_UNDERFLOW;
	CurrentLevel--;
	RemoveHead();
	return GetCurrent( (void **)ppSymTable );
	}
short
nsa::GetCurrentLevel( void )
	{
	return CurrentLevel;
	}
SymTable *
nsa::GetCurrentSymbolTable()
	{
	SymTable *pSymbolTable;
	GetCurrent( (void **)&pSymbolTable );
	return pSymbolTable;
	}

/****************************************************************************
 *			nested symbol table access support
 ***************************************************************************/
void
IINFODICT::StartNewInterface()
	{
	IINFO	*	pInfo	= new IINFO;

	pInfo->fLocal					= FALSE;
	pInfo->InterfacePtrAttribute	= ATTR_NONE;
	pInfo->pInterfaceNode			= NULL;
	pInfo->CurrentTagNumber			= 1;
	pInfo->fPtrDefErrorReported		= 0;
	pInfo->fPtrWarningIssued		= FALSE;
	pInfo->IntfKey					= CurrentIntfKey;

	Push( (IDICTELEMENT) pInfo );

	}

BOOL
IINFODICT::IsPtrWarningIssued()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	return pInfo->fPtrWarningIssued;
	}

void
IINFODICT::SetPtrWarningIssued()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	pInfo->fPtrWarningIssued  =  TRUE;
	}

void
IINFODICT::EndNewInterface()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();

	delete pInfo;
	Pop();

	pInfo = (IINFO *) GetTop();
	if ( pInfo )
		CurrentIntfKey = pInfo->IntfKey;	
	}
void
IINFODICT::SetInterfacePtrAttribute(
	ATTR_T	A )
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	pInfo->InterfacePtrAttribute	= A;
	if( ImportLevel == 0 ) BaseInterfacePtrAttribute = A;
	}
void
IINFODICT::SetInterfaceLocal()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	pInfo->fLocal	= TRUE;
	if( ImportLevel == 0 ) fBaseLocal = TRUE;
	}
void
IINFODICT::SetInterfaceNode(
	node_interface	*	p )
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	pInfo->pInterfaceNode	= p;
	if( ImportLevel == 0 ) pBaseInterfaceNode = p;
	CurrentIntfKey	= (unsigned short) pInterfaceDict->AddElement( p );
	pInfo->IntfKey = CurrentIntfKey;
	}
void
IINFODICT::IncrementCurrentTagNumber()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	pInfo->CurrentTagNumber++;
	}
ATTR_T
IINFODICT::GetInterfacePtrAttribute()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	return pInfo->InterfacePtrAttribute;
	}
ATTR_T
IINFODICT::GetBaseInterfacePtrAttribute()
	{
	return BaseInterfacePtrAttribute;
	}
BOOL
IINFODICT::IsInterfaceLocal()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	return pInfo->fLocal;
	}
node_interface *
IINFODICT::GetInterfaceNode()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	return pInfo->pInterfaceNode;
	}
short
IINFODICT::GetCurrentTagNumber()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	return pInfo->CurrentTagNumber;
	}
void
IINFODICT::SetPtrDefErrorReported()
	{
	IINFO	*	pInfo	= (IINFO *) GetTop();
	pInfo->fPtrDefErrorReported = 1;
	}
BOOL
IINFODICT::IsPtrDefErrorReported()
	{
	IINFO	*	pInfo	= (IINFO *) GetTop();
	return (BOOL) (pInfo->fPtrDefErrorReported == 1);
	}


/****************************************************************************
 *			utility functions
 ***************************************************************************/
char *
GetTypeName(
	short Type )
	{
	char	*p;
	switch(Type)
		{
		case  TYPE_INT:			p = "\"int\""; break;
		case  TYPE_FLOAT:		p = "\"float\""; break;
		case  TYPE_DOUBLE:		p = "\"double\""; break;
                case  TYPE_FLOAT80:             p = "\"__float80\""; break;
                case  TYPE_FLOAT128:            p = "\"__float128\""; break;
		case  TYPE_VOID:		p = "\"void\""; break;
		case  TYPE_BOOLEAN:		p = "\"boolean\""; break;
		case  TYPE_HANDLE_T:	p = "\"handle_t\""; break;
		default:				p = ""; break;
		}
	return p;
	}

STATUS_T
GetBaseTypeNode(
	node_skl	**	ppNode,
	short				TypeSign,
	short				TypeSize,
	short				BaseType,
    short               TypeAttrib)
	{

	STATUS_T uStatus = STATUS_OK;

	if( pPreAllocTypes->GetPreAllocType(
					ppNode,
					(unsigned short)MAKE_TYPE_SPEC(TypeSign,TypeSize,BaseType,TypeAttrib)) != STATUS_OK)
		{
		// this should never happen
		MIDL_ASSERT( FALSE );
		*ppNode = (node_skl *)new node_error;
		}
	return uStatus;

	}

STATUS_T
GetBaseTypeNode(
	node_skl	**	ppNode,
	struct _type_ana	Type)
	{

	STATUS_T uStatus = STATUS_OK;

	if( pPreAllocTypes->GetPreAllocType(
					ppNode,
					(unsigned short)MAKE_TYPE_SPEC(Type.TypeSign,Type.TypeSize,Type.BaseType, Type.TypeAttrib)) != STATUS_OK)
		{
		// this should never happen
		*ppNode = (node_skl *) NULL;
		}
	return uStatus;

	}

#define TEMPNAME				("__MIDL_")
#define TEMP_NAME_LENGTH		(7)
#define INTF_ADDITION			("itf_")
#define INTF_ADDITION_LENGTH	(4)
#define LENGTH_OF_1_UNDERSCORE	(1)

char *
GenTempName()
	{
static short NameCounter = 0;
	char TempBuf[ TEMP_NAME_LENGTH + 4 + 1 ];
	sprintf(TempBuf, "%s%.4d", TEMPNAME, NameCounter++);
	return pMidlLexTable->LexInsert( TempBuf );
	}

char *
GenIntfName()
	{
static short NameCounter = 0;
	char TempBuf[ TEMP_NAME_LENGTH + INTF_ADDITION_LENGTH + 4 + 1 + _MAX_PATH ];
	char FileBase[_MAX_PATH];
	char dbcsFileBase[_MAX_PATH*2];
	pCommand->GetInputFileNameComponents(NULL, NULL, FileBase, NULL );
    
    // account for spaces and DBCS chars.
    NormalizeString( FileBase, dbcsFileBase );

	sprintf(TempBuf, "%s%s%s_%.4d", 
                TEMPNAME, 
                INTF_ADDITION, 
                dbcsFileBase, 
                NameCounter++);

	return pMidlLexTable->LexInsert( TempBuf );
	}

char *
GenCompName()
	{
	char*	pCurrentInterfaceName = pInterfaceInfoDict->GetInterfaceName();
	short	Length = (short) strlen(pCurrentInterfaceName);
	char*	pBuffer;
	char*	pTemp;
	short	CurrentTagNumber;

	pBuffer	= new char[	TEMP_NAME_LENGTH +			// __MIDL_
						Length +					// intface name
						LENGTH_OF_1_UNDERSCORE +	// _
						4 +							// temp number
						1 ];						// term. zero.

	CurrentTagNumber		= pInterfaceInfoDict->GetCurrentTagNumber();

	sprintf( pBuffer, "%s%s_%.4d", TEMPNAME, pCurrentInterfaceName, CurrentTagNumber );

	pInterfaceInfoDict->IncrementCurrentTagNumber();

	pTemp	= pMidlLexTable->LexInsert( pBuffer );
	delete pBuffer;
	return pTemp;

	}

BOOL
IsTempName(
	char *pName )
	{
	return !(strncmp( pName, TEMPNAME , TEMP_NAME_LENGTH ) );
	}

void
ApplyAttributes(
	named_node		*	pNode,
	ATTRLIST		&	attrs )
	{
	if( attrs )
		{
		pNode->SetAttributes(attrs);
		}
	}


/****************************************************************************
 This routine exists to share code for setting up the field attribute nodes
 ****************************************************************************/
ATTRLIST
GenerateFieldAttribute(
	ATTR_T					NodeType,
	expr_list			*	pExprList )
	{
	node_base_attr 	*	pAttr = 0;
	expr_node		*	pExpr = 0;
	ATTRLIST			AList;

	AList.MakeAttrList();

	/**
	 ** we delibrately dont set the bits in the summary attribute 'cause
	 ** these bits will get set in the set attribute anyways for the
	 ** field attributes
	 **/

	if(pExprList != (expr_list *)NULL)
		{
		pExprList->Init();
		while( pExprList->GetNext( (void **)&pExpr )  == STATUS_OK)
			{
			switch(NodeType)
				{
				case ATTR_FIRST:
				case ATTR_LAST:
				case ATTR_LENGTH:
				case ATTR_SIZE:
				case ATTR_MIN:
				case ATTR_MAX:
					pAttr = new size_attr( pExpr, NodeType );
					break;
				default:
					//this should never happen
					MIDL_ASSERT(FALSE && "Attribute not supported");
					break;
				}
			AList.SetPeer( pAttr );
			}
		}
	delete pExprList;
	AList.Reverse();
	return AList;
	}
/****************************************************************************
 SearchTag:
	This routine provides a means of searching the global symbol space for
	struct/union tags, and enums. These share the same name space but we want to
	keep the symbol table identity of enums, struct tags etc separate. so
	we need to search for all of these separately when verifying that a tag
	has really not been seen before.

	This routine returns:
		1. (node_skl *)NULL if NO struct/union/enum was defined by that name
		2. node_skl * if the a definition was found for what you are looking
		   for.
		3. (node_skl *) error type node if a definition was found, but it is
		   not what you are looking for.
 ****************************************************************************/
node_skl *
SearchTag(
	char	*	pName,
	NAME_T		Tag )
	{
	node_skl	*	pNode;
	NAME_T			MyTag;
	SymKey			SKey( pName, MyTag = NAME_TAG );

	/**
	 ** Has it been declared as a struct ?
	 **/

	if ( (pNode = pBaseSymTbl->SymSearch(SKey) ) == 0 )
		{

		/**
		 ** not a tag - maybe enum / union
		 **/

		SKey.SetKind( MyTag = NAME_ENUM );

		if ( (pNode = pBaseSymTbl->SymSearch(SKey) ) == 0 )
			{

			/**
			 ** not a enum maybe union
			 **/

			SKey.SetKind( MyTag = NAME_UNION );

			if ( (pNode = pBaseSymTbl->SymSearch(SKey) ) == 0 )
				return (node_skl *)NULL;
			}
		}

	/**
	 ** search was sucessful. Check whether this was what you were looking
	 ** for. If it is , it means we found a definition of the symbol. If not
	 ** then we found a definition all right, but it is of a different entity.
	 ** The routine can find this out by verifying that the typenode returned
	 ** was an error type node or not
	 **/

	return (MyTag == Tag ) ? pNode : pErrorTypeNode;
	}


/****************************************************************************
 SetPredefinedTypes:
	Set up predefined types for the midl compiler. The predefined types
	are error_status_t and wchar_t( the latter dependent on compile mode )
 ****************************************************************************/
void
SetPredefinedTypes()
	{

	char			*	pName = 0;
	node_e_status_t	*	pNew = new node_e_status_t;
	node_def_fe		*	pDef = new node_def_fe( pName = pNew->GetSymName(), pNew );

	// set global version
	pError_status_t	= pNew;

	// the typedef of error_status_t in the symbol table

	SymKey			SKey( pName, NAME_DEF);
	pBaseSymTbl->SymInsert(SKey, (SymTable *)NULL, pDef );

	//
	// we always predefine wchar_t and report the error to the user. If
	// we dont enter wchar_t in the predefined types, then we get all
	// kinds of syntax and error recovery errors which could be confusing
	// in this context. We therefore explicitly give an error on wchar_t.
	//

	node_wchar_t *	pNew2 = new node_wchar_t;

	pDef = new node_def_fe( pName = pNew2->GetSymName(), pNew2 );

	// the typedef of wchar_t in the symbol table

	SKey.SetString( pName );
	pBaseSymTbl->SymInsert(SKey, (SymTable *)NULL, pDef );

	}

//
// We check for a proc/typedef/member/param/tag/enum/label name already defined
// as an identifier. Only if the identifier is one which will be turned into
// a #define, do we report an error. However, it is not worth it to check if
// an identifier is used as a name because in any case we will not be able to
// check for clashes with field / param names since they are at a lower than
// global, symbol table scope. Generally checking if the name of a member etc
// is already defined as an id which will be turned into a #define should be
// enough.
//

void
CheckGlobalNamesClash(
	SymKey	SKeyOfSymbolBeingDefined )
	{
	NAME_T		NT		= SKeyOfSymbolBeingDefined.GetKind();
	char	*	pName	= SKeyOfSymbolBeingDefined.GetString();
	SymKey		SKey;

	SKey.SetString( pName );

	switch( NT )
		{
		case NAME_PROC:
		case NAME_MEMBER:
		case NAME_TAG:
		case NAME_DEF:
		case NAME_LABEL:
		case NAME_ENUM:

			node_id	*	pID;

			SKey.SetKind( NAME_ID );

			if ( ( pID = (node_id *) pBaseSymTbl->SymSearch( SKey ) ) != 0 )
				{
				BOOL	fWillBeAHashDefine = !pID->FInSummary( ATTR_EXTERN ) &&
											 !pID->FInSummary( ATTR_STATIC ) &&
											 pID->GetInitList();
				if( fWillBeAHashDefine )
					ParseError( NAME_ALREADY_USED, pName );
				}
			break;

		case NAME_ID:

#if 0
			SKey.SetKind( NAME_PROC );
			if( !pBaseSymTbl->SymSearch( SKey ) )
				{
				SKey.SetKind( NAME_TAG );
				if( !pBaseSymTbl->SymSearch( SKey ) )
					{
					SKey.SetKind( NAME_DEF );
					if( !pBaseSymTbl->SymSearch( SKey ) )
						{
						SKey.SetKind( NAME_LABEL );
						if( !pBaseSymTbl->SymSearch( SKey ) )
							{
							SKey.SetKind( NAME_ENUM );
							if( !pBaseSymTbl->SymSearch( SKey ) )
								break;
							}
						}
					}
				}
			ParseError( NAME_CLASH_WITH_CONST_ID, pName );
			break;
#endif // 0
		default:
			break;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\lexutils.cxx ===
// Copyright (c) 1993-1999 Microsoft Corporation

/*
** helper functions for Gerd Immeyer's grammar
**
*/

/****************************************************************************
 *			include files
 ***************************************************************************/

#pragma warning ( disable : 4514 4710 )

#include "nulldefs.h"
extern "C" {
	#include <stdio.h>
	#include <io.h>
	#include <process.h>
	#include <string.h>

	#include <stdlib.h>
}

#include "common.hxx"
#include "errors.hxx"
#include "midlnode.hxx"
#include "listhndl.hxx"
#include "filehndl.hxx"
#include "lextable.hxx"
#include "lexutils.hxx"
#include "grammar.h"
#include "gramutil.hxx"
#include "cmdana.hxx"
#include "control.hxx"
#include "tlgen.hxx"
#include <float.h>

extern "C" {
    #include "lex.h"
}

/****************************************************************************
 *		local definitions and macros
 ***************************************************************************/

#define warning(p)		/* temp defintion to get rid of compiler probs */

#define MAX_ID_LENGTH  		(31)
#define MAX_DECIMAL_LENGTH	(10)
#define MAX_HEX_LENGTH		(8)
#define MAX_OCTAL_LENGTH	(25)

/***************************************************************************
 *		local data
 ***************************************************************************/

/***************************************************************************
 *		local procedures
 ***************************************************************************/
long 						convert(char *, short, short);
token_t 					cnv_int(void);
token_t 					cnv_hex(void);
token_t 					cnv_octal(void);
token_t 					cnv_float(void);
inline token_t              GetNextToken() {return yylex();}
inline void                 UngetToken(token_t token) {yyunlex(token);}
token_t 					name(void);
token_t 					map_token(token_t token);
void 						lex_error(int number);

/***************************************************************************
 *		global data
 ***************************************************************************/

// token_t 					TokenMap[LASTTOKEN];
short						handle_import;
short						inside_rpc;
lextype_t					yylval;
token_t						toktyp_G;			/* token type */
short						toklen_G;			/* len of token string */
char 						*tokptr_G;			/* pointer to token string */
short						curr_line_G;		/* current line in file */
char						*curr_file_G;		/* current file name */
long						tokval_G;			/* value of constant token */
FILE						*hFile_G;			/* current file */
BOOL						fAbandonNumberLengthLimits;

/***************************************************************************
 *		external data
 ***************************************************************************/
extern short				DebugLine;
extern NFA_INFO				*pImportCntrl;
extern LexTable 	*		pMidlLexTable;
extern short				CompileMode;
extern SymTable		*		pBaseSymTbl;
extern CMD_ARG		*		pCommand;
extern ccontrol		*		pCompiler;
extern char					LastLexChar;

/***************************************************************************
 *		external procedures
 ***************************************************************************/

token_t						is_keyword( char *, short);


/***************************************************************************/

const extern short st[ 13 ][ 16 ];
const extern short ct[256];

// Used to disable identifier to keyword mapping for declspec parsing. 
BOOL                        IdToKeywordMapping = TRUE;

#define __isdigit(c)      (((c) >= '0' && (c) <= '9'))

token_t cnv_int(void)
{
    LastLexChar = NewCCGetch();
    int chBeyond = NewCCGetch();
    NewCCputbackc((char)chBeyond);

    if( LastLexChar == '.' && chBeyond!= '.')
        {
        STATUS_T	Status			= STATUS_OK;
        short		LengthCollected	= (short)strlen(tokptr_G);
        char	*	ptr				= &tokptr_G[LengthCollected];

        char ch	= LastLexChar;

        *ptr++ = ch;
        *ptr++ = ch	= NewCCGetch();
        if (__isdigit(ch))
            {
            *ptr++ = ch	= NewCCGetch();
            while (__isdigit(ch))
                {
                *ptr++ = ch	= NewCCGetch();
                }
            if (ch == 'e' || ch == 'E')
                {
                *ptr++ = ch	= NewCCGetch();
                if (ch == '-' || ch == '+')
                    {
                    *ptr++ = ch	= NewCCGetch();
                    if (__isdigit(ch))
                        {
                        *ptr++ = ch	= NewCCGetch();
                        while (__isdigit(ch))
                            {
                            *ptr++ = ch	= NewCCGetch();
                            }
                        }
                    else
                        {
                        Status = ERROR_PARSING_NUMERICAL;
                        }
                    }
                else if (__isdigit(ch))
                    {
                    *ptr++ = ch	= NewCCGetch();
                    while (__isdigit(ch))
                        {
                        *ptr++ = ch	= NewCCGetch();
                        }
                    }
                }
            }
        else
            {
            Status = ERROR_PARSING_NUMERICAL;
            }

        if (Status != STATUS_OK)
            {
            ParseError( Status, (char *)0 );
            exit( Status );
            }

        *ptr = 0;
        token_t tokenType = DOUBLECONSTANT;
        double d = atof(tokptr_G);

        if (ch != 'l' && ch != 'L')
            {
            NewCCputbackc(ch);
            *(ptr-1) = 0;
            tokenType = unsigned short( (d < FLT_MAX || d > FLT_MIN) ? FLOATCONSTANT : DOUBLECONSTANT );
            }
        else
            {
            NewCCputbackc(NewCCGetch());
            }
        
        if ( tokenType == DOUBLECONSTANT )
            {
	        yylval.yy_numeric.dVal = d;
           }
        else
            {
	        yylval.yy_numeric.fVal = (float) d;
            }

	    yylval.yy_numeric.pValStr = pMidlLexTable->LexInsert(tokptr_G);
        return tokenType;
        }
    else
        {
	    token_t	Tok	= NUMERICCONSTANT;
	    yylval.yy_numeric.pValStr = pMidlLexTable->LexInsert(tokptr_G);
	    yylval.yy_numeric.Val = tokval_G = convert(tokptr_G, 10, MAX_DECIMAL_LENGTH );

	    if( (LastLexChar == 'L') || (LastLexChar == 'l'))
    		{
		    Tok = NUMERICLONGCONSTANT;
		    }
	    else
    		{
	    	if( (LastLexChar == 'U') || (LastLexChar == 'u'))
		    	{
			    Tok = NUMERICULONGCONSTANT;
			    if( ((LastLexChar = NewCCGetch()) != 'L') && (LastLexChar != 'l'))
				    {
				    NewCCputbackc(LastLexChar);
				    Tok = NUMERICUCONSTANT;
				    }
			    }
		    else
    			{
        	    NewCCputbackc( LastLexChar );
		        return NUMERICCONSTANT;
			    }
		    }
        return Tok;
        }
}

token_t cnv_hex(void)
{
	token_t Tok = HEXCONSTANT;
	unsigned long Val;

	yylval.yy_numeric.pValStr = pMidlLexTable->LexInsert(tokptr_G);
	tokptr_G += 2;	/* skip 0x */
	Val = yylval.yy_numeric.Val = tokval_G = convert(tokptr_G, 16, MAX_HEX_LENGTH);
	tokptr_G -= 2;	

	LastLexChar = NewCCGetch();

	if( (LastLexChar == 'L') || (LastLexChar == 'l'))
		{
		Tok = HEXLONGCONSTANT;
		}
	else
		{
//		LastLexChar = NewCCGetch();

		if( (LastLexChar == 'U') || (LastLexChar == 'u'))
			{
			Tok = HEXULONGCONSTANT;
			if( ((LastLexChar = NewCCGetch()) != 'L') && (LastLexChar != 'l'))
				{
				NewCCputbackc(LastLexChar);
				Tok = HEXUCONSTANT;
				}
			}
		else
			{
			NewCCputbackc(LastLexChar);
				return HEXCONSTANT;
			}
		}
    return Tok;
}

token_t cnv_octal(void)
{
	token_t	Tok	= OCTALCONSTANT;
	unsigned long Val;

	yylval.yy_numeric.pValStr = pMidlLexTable->LexInsert(tokptr_G);
	Val = yylval.yy_numeric.Val = tokval_G = convert(tokptr_G, 8, MAX_OCTAL_LENGTH);

	LastLexChar = NewCCGetch();

	if( (LastLexChar == 'L') || (LastLexChar == 'l'))
		{
		Tok = OCTALLONGCONSTANT;
		}
	else
		{
//		LastLexChar = NewCCGetch();

		if( (LastLexChar == 'U') || (LastLexChar == 'u'))
			{
			Tok = OCTALULONGCONSTANT;
			if( ((LastLexChar = NewCCGetch()) != 'L') && (LastLexChar != 'l'))
				{
				NewCCputbackc(LastLexChar);
				Tok = OCTALUCONSTANT;
				}
			}
		else
			{
			NewCCputbackc(LastLexChar);
			return OCTALCONSTANT;
			}
		}

    return Tok;
}

token_t cnv_float(void)
{
	warning("floating point constants not allowed");
	yylval.yy_numeric.Val = tokval_G = 0;
	lex_error(101);
	yylval.yy_numeric.pValStr = pMidlLexTable->LexInsert(tokptr_G);
    return NUMERICCONSTANT;
}

long convert(char *ptr, short base, short MaxSize)
{
	REG	long	answer = 0;
	REG	char	ch;
	BOOL		fZeroIsNotALeadingZeroAnymore = FALSE;
		short count = 0;

	while ((ch = *ptr++) != 0)
		 {
		if ((ch & 0x5f) >= 'A')
			answer = answer * base + (ch & 0x5f) - 'A'+ 10;
		else
			answer = answer * base + ch - '0';

		if( ch == '0')
			{
			if( fZeroIsNotALeadingZeroAnymore )
				count++;
			}
		else
			{
			fZeroIsNotALeadingZeroAnymore = TRUE;
			count++;
			}
		}

	if( ( count > MaxSize ) && !fAbandonNumberLengthLimits )
		{
		ParseError( CONSTANT_TOO_BIG, (char *)NULL );
		}

	return answer;
}

void SkipToToken(token_t token)
{
    token_t NextToken;
    do {
        NextToken = GetNextToken();
    } while( ( token != NextToken) && (EOI != NextToken) );
}

MODIFIER_SET ParseUnknownDeclSpecItem(char *pIdentifier)
{

    INITIALIZED_MODIFIER_SET ModifierSet;
    unsigned long Level = 0;

    char AppendTxt[512];
    unsigned int CurChar = 0;

    memset( AppendTxt, '\0', sizeof(AppendTxt) );

    const unsigned int MaxCurChar = 512 - 1 - sizeof(')') - sizeof(' ') - sizeof('\0');

    char ch;
    short ci;
    for(;;) // skip white space
        {
        ci = ct[ (unsigned char)(ch = NewCCGetch()) ];
        if (0 == st[ 0 ][ ci & 0x00ff ])
		    {
     		AppendTxt[CurChar++] = ch;
            if ( CurChar >= MaxCurChar )
			    {
                ParseError(SYNTAX_ERROR, "Invalid _declspec");
                return ModifierSet;
                }
            }       
        else 
			break;
		}
      
    if ('(' == ch) 
        {
        // identifier(...) form
        Level++;
        AppendTxt[CurChar++] = '(';

        do
            {
            ch = NewCCGetch();
            switch(ch)
                {
                case 0:
                    //end of file
                    goto Exit;
                case '(':
                    Level++;
                    break;
                case ')':
                    Level--;
                    break;
                }

            AppendTxt[CurChar++] = ch;
            if ( CurChar >= MaxCurChar )
                {
                ParseError(SYNTAX_ERROR, "Invalid _declspec");
                return ModifierSet;
                }

            }
        while ( Level );
        

        }

    else
        {
        NewCCputbackc(ch);
        }
    
    Exit:   
    
    AppendTxt[CurChar++] = ')';
    AppendTxt[CurChar++] = ' ';    
    size_t StringLength = sizeof("__declspec(") + strlen(pIdentifier) + CurChar + sizeof('\0');
    char *UnknownDeclspec = new char[StringLength];
    strcpy( UnknownDeclspec, "__declspec(");
    strcat( UnknownDeclspec, pIdentifier );
    strcat( UnknownDeclspec, AppendTxt);
    ModifierSet.SetDeclspecUnknown( UnknownDeclspec );
    delete[] UnknownDeclspec;

    return ModifierSet;
    
}

#pragma warning(push)
#pragma warning( disable : 4244 ) // disable long to short conversion warning

MODIFIER_SET ParseDeclSpecAlign()
{

    unsigned short AlignmentValue = 8;
    
    toktyp_G = GetNextToken();

    if (toktyp_G != '(')
        {
        ParseError( BENIGN_SYNTAX_ERROR, "( expected after _declspec( align");
        UngetToken(toktyp_G);
        goto exit;
        }

    toktyp_G = GetNextToken();

    switch(toktyp_G) 
        {
        case NUMERICCONSTANT:
        case NUMERICLONGCONSTANT:
        case HEXCONSTANT:
        case HEXLONGCONSTANT:
        case OCTALCONSTANT:
        case OCTALLONGCONSTANT:
        case NUMERICUCONSTANT:
        case NUMERICULONGCONSTANT:
        case HEXUCONSTANT:
        case HEXULONGCONSTANT:
        case OCTALUCONSTANT:
        case OCTALULONGCONSTANT:
            break; //valid case 

        default:
            ParseError( MSCDECL_INVALID_ALIGN, NULL);
            SkipToToken(')');
            goto exit;
        }

    //Check if value is nonzero power of 2 <= 8192
    switch((long)tokval_G)
        {
        case 1:
        case 2:
        case 4:
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
            AlignmentValue = (unsigned short)tokval_G;
            break; //valid case
        default:
            ParseError( MSCDECL_INVALID_ALIGN, NULL);
            AlignmentValue = 8;
            break;
        }      

    toktyp_G = GetNextToken();

    if (toktyp_G != ')')
        {
        ParseError( BENIGN_SYNTAX_ERROR, ") expected to follow _declspec(align(N \n");        
        SkipToToken(')');
        }

exit:
    INITIALIZED_MODIFIER_SET ModifierSet;
    ModifierSet.SetDeclspecAlign(AlignmentValue);
    ParseError( BENIGN_SYNTAX_ERROR, "_declspec(align()) is not supported." );
    return ModifierSet;
}

#pragma warning(pop)

token_t ParseDeclSpec() 
{
  /* Parses the MS_VC declspec() syntax.
     syntax: _declspec(declspeclist )        
            declspeclist:  declspecitemlist declspecitem |
                           declspecitem                  |
                           nothing
                        
            declspecitem:  identifier |
                           identifier(...)
  */
  
  token_t LParen = GetNextToken();
  if ('(' != LParen)
      {
      ParseError( BENIGN_SYNTAX_ERROR, "( expected after _declspec");
      return LParen;
      }

  // Disable ID to keyword mapping.

  BOOL OldIdToKeywordMapping = IdToKeywordMapping;
  IdToKeywordMapping = FALSE;

  INITIALIZED_MODIFIER_SET ModifierSet;

  for(;;) 
      {
      // VC skips comma, so we skip commas.
      while(',' == (toktyp_G = GetNextToken()));
   
      if (')' == toktyp_G)
          {
          break;
          }

      if (IDENTIFIER == toktyp_G || TYPENAME == toktyp_G || LIBNAME == toktyp_G)
          {
          if (strcmp( tokptr_G, "dllimport") == 0)
              {
              ModifierSet.SetModifier(ATTR_DLLIMPORT);
              }
          else if (strcmp( tokptr_G, "dllexport") == 0)
              {
              ModifierSet.SetModifier(ATTR_DLLEXPORT);
              }
          else if (strcmp( tokptr_G, "align") == 0)
              {
              ModifierSet.Merge(ParseDeclSpecAlign());
              }
          else 
              {
              ModifierSet.Merge(ParseUnknownDeclSpecItem(tokptr_G));
              }
          }
      else 
          {
          ParseError( BENIGN_SYNTAX_ERROR, "Invalid _declspec" );
          SkipToToken(')');
          break;
          }
      }

  IdToKeywordMapping = OldIdToKeywordMapping;

  yylval.yy_modifiers = ModifierSet;
  return (toktyp_G = KWMSCDECLSPEC);
}

const extern short ct[256];
const extern short st[13][16];

token_t name(void)
{
    /* have received a name from the input file,  first we */
    /* check to see if it is a keyword. */

	short	InBracket	= short( inside_rpc ? INBRACKET : 0 );

    if ( IdToKeywordMapping )
        toktyp_G = is_keyword(tokptr_G, InBracket);
    else 
		toktyp_G = IDENTIFIER;

    if (KWMSCDECLSPEC == toktyp_G)
    {
        return ParseDeclSpec();
    }

    if( KWSAFEARRAY == toktyp_G)
    {
        /* SAFEARRAY is a special case
         * In order to correctly parse the ODL SAFEARRAY syntax:
         *      SAFEARRAY ( FOO * ) BAR;
         * we look ahead at the next non white space character
         * to see if it's an open parenthasis.  If it is then we eat
         * the character and return KWSAFEARRAY, otherwise we
         * put the character back into the stream and return the
         * string "SAFEARRAY" as an IDENTIFIER.
         */
        char ch;
        short ci;
        do
            ci = ct[ (unsigned char)(ch = NewCCGetch()) ];
        while (0 == st[ 0 ][ ci & 0x00ff ]);  /* skip white space */
        if ('(' != ch)
        {
            NewCCputbackc(ch);
            toktyp_G = IDENTIFIER;
        }
    }

	if (toktyp_G == IDENTIFIER)
		{
		if( strlen( tokptr_G ) > MAX_ID_LENGTH )
			{
			ParseError( ID_TRUNCATED, tokptr_G );
//				tokptr_G[ MAX_ID_LENGTH ] = '\0'; // dont truncate
			}

        /* We need to know if the identifier is followed by a period.
         * If it is, it may be a library name and so we need to check
         * the libary name table to see if we should return LIBNAME
         * instead of TYPENAME or IDENTIFIER.
         * We look ahead to the next non white space character as above;
         * the difference being that we do not consume the non whitespace
         * character as we would for "SAFEARRAY(".
         */
        char ch;
        short ci;
        do
            ci = ct[ (unsigned char)(ch = NewCCGetch()) ];
        while (0 == st[ 0 ][ ci & 0x00ff ]);  /* skip white space */
        NewCCputbackc(ch);
        if( '.' == ch )
            {
            // we need to check to see if the identifier is a library name
            if (FIsLibraryName(tokptr_G))
                {
                toktyp_G = LIBNAME;
                yylval.yy_pSymName = new char [toklen_G + 1];
                strcpy(yylval.yy_pSymName, tokptr_G);
                return toktyp_G;
                }
            }
        /* Check the symbol table to see if the identifier
         * is a TYPENAME.
         */
#ifdef unique_lextable
		// all names go in the lex table -- this is important for the symtable search
		yylval.yy_pSymName = pMidlLexTable->LexInsert(tokptr_G);

		// see if the name corresponds to a base level typedef
		SymKey	SKey( yylval.yy_pSymName, NAME_DEF );

		if( pBaseSymTbl->SymSearch( SKey ) )
			{
			toktyp_G = TYPENAME;
			}
		}
#else // unique_lextable
		// see if the name corresponds to a base level typedef
		SymKey			SKey( tokptr_G, NAME_DEF );
		named_node	*	pNode;

		if ( ( pNode = pBaseSymTbl->SymSearch( SKey ) ) != 0 )
			{
            char * szTemp = new char[toklen_G + 1];
            strcpy(szTemp, tokptr_G);
			pNode->SetCurrentSpelling(szTemp);
			toktyp_G = TYPENAME;
            yylval.yy_graph = pNode;
            }
		else
			{
			yylval.yy_pSymName = pMidlLexTable->LexInsert(tokptr_G);
			}

		}
#endif // unique_lextable

	return toktyp_G;
}

void lex_error(int number)
{
	printf("lex error : %d\n", number);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\lextable.cxx ===
/**********************************************************************/
/**                      Microsoft LAN Manager                       **/
/**             Copyright(c) Microsoft Corp., 1987-1999              **/
/**********************************************************************/

/*

lextable.cxx
MIDL Compiler Lexeme Table Implementation 

This class centralizes access to allocated strings throughout the
compiler.

*/

/*

FILE HISTORY :

DonnaLi     08-23-1990      Created.

*/

#pragma warning ( disable : 4514 )

#include "nulldefs.h"
extern "C" {

#include <stdio.h>
#include <malloc.h>
#include <string.h>

}
#include "common.hxx"
#include "lextable.hxx"

/**********************************************************************\

NAME:		PrintLexeme

SYNOPSIS:	Prints out the name of a lexeme table entry.

ENTRY:		key	- the key to lexeme table entry to be printed.

EXIT:

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

void 
PrintLexeme(
	void * key
	)
{
	printf ("%s", ((LexKey *)key)->sz);
}

/**********************************************************************\

NAME:		CompareLexeme

SYNOPSIS:	Compares keys to two lexeme table entries.

ENTRY:		key1	- the key to 1st lexeme table entry to be compared.
			key2	- the key to 2nd lexeme table entry to be compared.

EXIT:		Returns a positive number if key1 > key2.
			Returns a negative number if key1 < key2.
			Returns 0 if key1 = key2.

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

int
CompareLexeme(
	void * key1,
	void * key2
	)
{
	return(strcmp(((LexKey *)key1)->sz, ((LexKey *)key2)->sz));
}

/**********************************************************************\

NAME:		LexTable::LexTable

SYNOPSIS:	Constructor.

ENTRY:		Allocates memory according to Size.
			Passes the compare and print functions to base class.

EXIT:

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

LexTable::LexTable(
	size_t	Size,
	int		(* )(void *, void *),
	void	(* )(void *)
	) 
#ifdef unique_lextable
	: Dictionary(pfnCompare, pfnPrint)
#endif // unique_lextable
{
	BufferSize = Size;
	BufferNext = 0;
	pBuffer = new char[BufferSize];
}

/**********************************************************************\

NAME:		LexTable::LexInsert

SYNOPSIS:	Inserts a lexeme into the lexeme table.

ENTRY:		psz	- the string to be inserted.

EXIT:		Returns the string.

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

char *
LexTable::LexInsert(
	char * psz
	)
{
	char *		NewString;
#ifdef unique_lextable
	LexKey *	NewLexeme;
	Dict_Status	Status;

	SearchKey.SetString(psz);
	Status = Dict_Find(&SearchKey);
	switch (Status)
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:
#endif // unique_lextable
			if ((BufferSize - BufferNext) <= strlen(psz))
				{
				BufferSize *= 2;
				if ( BufferSize > 32700 )
					BufferSize = 32700;
				BufferNext = 0;
				pBuffer = new char[BufferSize];
				}
			NewString = (char *)(pBuffer + BufferNext);
			(void) strcpy(NewString, psz);
			BufferNext += strlen(psz) + 1;

#ifdef unique_lextable
			NewLexeme = new LexKey (NewString);
			Status = Dict_Insert(NewLexeme);
#endif // unique_lextable
			return NewString;
#ifdef unique_lextable
		default:
			return ((LexKey *)Dict_Curr_Item())->GetString();
		}
#endif // unique_lextable
}

/**********************************************************************\

NAME:		LexSearch

SYNOPSIS:	Searches the lexeme table for a lexeme.

ENTRY:		psz	- the string to be searched.

EXIT:		Returns the string.

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

char *
LexTable::LexSearch(
	char *
	)
{
#ifdef unique_lextable
	Dict_Status	Status;

	SearchKey.SetString(psz);
	Status = Dict_Find(&SearchKey);
	if (Status == SUCCESS)
		return ((LexKey *)Dict_Curr_Item())->GetString();
	else
#endif // unique_lextable
		return (char *)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\listhndl.cxx ===
/*****************************************************************************
/**                     Microsoft LAN Manager                               **/
/**             Copyright(c) Microsoft Corp., 1987-1999                     **/
/*****************************************************************************/
/*****************************************************************************
File                : listhndl.cxx
Title               : general purpose list handler
                    :
Description         : this file handles the general purpose list routines
History             :
    16-Oct-1990 VibhasC     Created
    11-Dec-1990 DonnaLi     Fixed include dependencies

*****************************************************************************/

#pragma warning ( disable : 4514 )

/****************************************************************************
 ***        local defines
 ***************************************************************************/
#define IS_AGGREGATE_TYPE(NodeType) (   (NodeType == NODE_ARRAY)    ||  \
                                        (NodeType == NODE_STRUCT) )
#define ADJUST_OFFSET(Offset, M, AlignFactor)   \
            Offset += (M = Offset % AlignFactor) ? (AlignFactor-M) : 0
/****************************************************************************
 ***        include files
 ***************************************************************************/
#include "nulldefs.h"
extern "C"  {
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <malloc.h>

    typedef char far * FARPOINTER;
}
#include "gramutil.hxx"

/****************************************************************************
 ***        external procedures 
 ***************************************************************************/
int                 AttrComp( void *, void *);
/****************************************************************************
 ***        external data 
 ***************************************************************************/


/****************************************************************************
 ***        local data 
 ***************************************************************************/




/*****************************************************************************
 *  general purpose list (iterator) control functions
 *****************************************************************************/
/****************************************************************************
 _gplist:
    the private memory allocator
 ****************************************************************************/

// initialize the memory allocator for _gplist

FreeListMgr
_gplist::MyFreeList( sizeof (_gplist ) );


gplistmgr::~gplistmgr( void )
    {
    while(pFirst)
        {
        pCurrent    = pFirst->pNext;
        delete pFirst;
        pFirst  = pCurrent;
        }
    }

STATUS_T
gplistmgr::Discard()
    {
    while(pFirst)
        {
        pCurrent    = pFirst->pNext;
        delete pFirst;
        pFirst  = pCurrent;
        }
    pTail = pFirst;
    return STATUS_OK;
    }

STATUS_T
gplistmgr::Insert( 
    void * pNewElement )
    {
    struct _gplist *pNew = new struct _gplist( pNewElement );

    if(pNew != (struct _gplist *)NULL)
        {
        if(pTail != (struct _gplist *)NULL)
            {
            pTail->pNext    = pNew;
            }
        pTail   = pNew;
        if(pFirst == NULL) pFirst = pNew;
        if(pCurrent == NULL) pCurrent = pNew;
        return STATUS_OK;
        }
    return OUT_OF_MEMORY;
    }

STATUS_T    
gplistmgr::InsertHead( 
    void * pNewElement )
    {
    struct _gplist *pNew = new struct _gplist( pNewElement );

    if(pNew != (struct _gplist *)NULL)
        {
        pNew->pNext     = pFirst;
        pFirst          = pNew;
        pCurrent        = pNew;
        if(pTail == NULL)   pTail = pNew;
        return STATUS_OK;
        }
    return OUT_OF_MEMORY;
    }

STATUS_T
gplistmgr::RemoveHead( void )
    {
    struct _gplist  *pDel;
    
    pDel    = pFirst;
    pFirst  = pFirst->pNext;

    if ( pCurrent == pDel )
        {
        pCurrent = pFirst;
        }

    if ( pFirst == NULL )
        {
        pTail       = NULL;
        }

    delete pDel;
    return STATUS_OK;
    }

STATUS_T
gplistmgr::GetCurrent(
    void **ppReturn )
    {
    if( pCurrent != (struct _gplist *)NULL )
        {
        (*ppReturn) = pCurrent->pElement;
        return STATUS_OK;
        }
    return I_ERR_NO_PEER;
    }

short
gplistmgr::GetCount()
    {
    short               cnt = 0;
    struct _gplist *    pCur = pFirst;

    while( pCur )
        {
        cnt++;
        pCur = pCur->pNext;
        };

    return cnt;
    }

STATUS_T
gplistmgr::MergeToTail(
    gplistmgr   *pSrcList,
    BOOL bDeleteList )
    {
        if(pSrcList)
        {
        if (pSrcList->pFirst)
            {
            if ( pTail )    // glue to tail of current list
                {
                pTail->pNext    = pSrcList->pFirst;
                pTail           = pSrcList->pTail;
                }
            else    // add to empty list
                {
                pFirst          = pSrcList->pFirst;
                pTail           = pSrcList->pTail;
                }
            }

        // Clear pointer in previous list since
        // we are assuming ownership of the nodes.
        pSrcList->pFirst    = NULL;
        pSrcList->pTail     = NULL;
        
        // delete the source list.
        if ( bDeleteList )
            delete pSrcList;
        }
    return STATUS_OK;
    }

STATUS_T
gplistmgr::Clone(
    gplistmgr   *pOldList )
    {
    if(pOldList)
        {
        struct _gplist  *   pCur = pOldList->pFirst;
        struct _gplist  *   pNew;

        while ( pCur )
            {
            
            pNew = new struct _gplist( pCur->pElement );

            if ( pTail )
                {
                pTail->pNext    = pNew;
                pTail           = pNew;
                }
            else        // first element
                {
                pFirst      = 
                pCurrent    =
                pTail       = pNew;
                }

            pCur = pCur->pNext;
            }
        }
    return STATUS_OK;
    }

/**************************************************************************
 *              public functions for type_node_list
 **************************************************************************/
type_node_list::type_node_list( void )
    {
    }
type_node_list::type_node_list( 
    node_skl    *   p)
    {
    SetPeer( p );
    }
STATUS_T
type_node_list::SetPeer( 
    class node_skl *pNode )
    {
    return Insert( (void *)pNode );
    }
STATUS_T
type_node_list::GetPeer(
    class node_skl **pNode )
    {
    return GetNext ( (void **)pNode );
    }

STATUS_T
type_node_list::GetFirst(
    class node_skl **pNode )
    {
    STATUS_T Status;

    if( (Status = Init())  == STATUS_OK)
        {
        Status = GetNext( (void**)pNode );
        }
    return Status;
    }


short
IndexedList::Insert(
    void *pData
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Routine Description:

    Insert a pointer into a list and return a unique index representing that
    pointer.  Duplicate pointers return the same index.

  ReturnValue:

    The index of the pointer in the list.

----------------------------------------------------------------------------*/
{
    _gplist    *pCurrent = pFirst;
    short       i        = 0;

    while ( NULL != pCurrent )
    {
        if ( pCurrent->pElement == pData )
            return i;

        ++i;
        pCurrent = pCurrent->pNext;
    }

    gplistmgr::Insert( pData );

    return i;
}


short
IndexedStringList::Insert(
    char * pString
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Insert a strint into the list such that the string is associated with a
    unqiue index.   If the name already exists don't insert it again and 
    return the index of the previous entry.

  ReturnValue:

    The index of the string in the list.

----------------------------------------------------------------------------*/
{
    _gplist    *pCurrent = pFirst;
    short       i        = 0;

    while ( NULL != pCurrent )
    {
        if ( 0 == strcmp( (char *) pCurrent->pElement, pString ) )
            return i;

        ++i;
        pCurrent = pCurrent->pNext;
    }

    gplistmgr::Insert( pString );

    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\linenum.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: linenum.cxx
Title				: Line number storage routines
History				:
	29-Oct-93	GregJen	Created

*****************************************************************************/

#pragma warning ( disable : 4514 )

/****************************************************************************
 local defines and includes
 ****************************************************************************/

#include "nulldefs.h"
extern	"C"
	{
	#include <stdio.h>
	
	}

#include "common.hxx"
#include "linenum.hxx"
#include "filehndl.hxx"
#include "idict.hxx"


/****************************************************************************
 external data
 ****************************************************************************/

extern NFA_INFO					*	pImportCntrl;
extern short						curr_line_G;

/****************************************************************************
 external procs
 ****************************************************************************/


/****************************************************************************
 global data
 ****************************************************************************/

short		FileIndex;

IDICT	*	pFileDict;


/****************************************************************************/


void
tracked_node::SetLine()
{
	//FLine = pImportCntrl->GetCurrentLineNo();
	FLine = curr_line_G;
}


STATUS_T
tracked_node::GetLineInfo( 
	char *& pName,
	short & Line )
{
	if (FIndex)
		{
		// fetch file name from dictionary and line number from here
		pName	= FetchFileFromDB( FIndex );
		Line = FLine;
		return STATUS_OK;
		}
	
	pName = "";
	Line = 0;
	return NO_INPUT_FILE;
}



/****************************************************************************/

short 
AddFileToDB( char * pFile )
{
	FileIndex = (short) pFileDict->AddElement( (IDICTELEMENT) pFile );
	return FileIndex;
};

char *
FetchFileFromDB( short Index )
{
	return (char *) pFileDict->GetElement( (IDICTKEY) Index );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\main.cxx ===
/**                        Microsoft LAN Manager                            **/
/**                Copyright(c) Microsoft Corp., 1987-1999                  **/
/*****************************************************************************/
/*****************************************************************************
File                : main.cxx
Title                : compiler controller object management routines
History                :
    05-Aug-1991    VibhasC    Created

*****************************************************************************/

#if 0
                        Notes
                        -----
This file provides the entry point for the MIDL compiler. The main routine
creates the compiler controller object, which in turn fans out control to
the various passes of the compiler.

#endif // 0

#pragma warning ( disable : 4514 )

/****************************************************************************
 includes
 ****************************************************************************/

#include "nulldefs.h"
extern    "C"    {
    #include <stdio.h>
    #include <stdlib.h>
    #include <malloc.h>
    #include <excpt.h>
    #include <process.h>
    #include <io.h>
    #include <fcntl.h>
    #include <sys/types.h>
    #include <sys/stat.h>
}

#include "allnodes.hxx"
#include "cmdana.hxx"
#include "filehndl.hxx"
#include "lextable.hxx"
#include "control.hxx"
#include "idict.hxx"
#include "Pragma.hxx"
#include "midlvers.h"
extern unsigned long BackAllocation;
extern unsigned long				Skl_Bytes;

#define MAX_LEX_STRINGS (1000)
#define MIDL_LEX_TABLE_SIZE (unsigned long)(1 * MAX_LEX_STRINGS)

#ifdef MIDL_INTERNAL
#define MIDL_FREE_BUILD  0
#define MIDL_INTERNAL_PRINTF(x)  printf(x)  
#else
#define MIDL_FREE_BUILD  1
#define MIDL_INTERNAL_PRINTF(x)  
#endif

/****************************************************************************
    extern procedures
 ****************************************************************************/
extern void                 Test();
extern STATUS_T             MIDL_4();
extern void                 CGMain( node_skl    *    pNode );
extern void                 Ndr64CGMain( node_skl    *    pNode );


/****************************************************************************
    extern data
 ****************************************************************************/
extern unsigned long        TotalAllocation;
extern CCONTROL          *  pCompiler;
extern NFA_INFO          *  pImportCntrl;
extern LexTable          *  pMidlLexTable;
extern PASS_1            *  pPass1;
extern PASS_2            *  pPass2;
extern PASS_3            *  pPass3;
extern CMD_ARG           *  pCommand;
extern node_source       *  pSourceNode;
extern BOOL                 fNoLogo;
extern CMessageNumberList   GlobalMainMessageNumberList;

/****************************************************************************
    extern functions
 ****************************************************************************/

extern    void              print_memstats();
extern    void              print_typegraph();

/****************************************************************************
    local data
 ****************************************************************************/

#define szVerName    ""


const char *pSignon1 = "Microsoft (R) 32b/64b MIDL Compiler Engine Version %s " szVerName " " "\n";
const char *pSignon2 = "Copyright (c) Microsoft Corp 1991-1999. All rights reserved.\n";

/****************************************************************************/

void
DumpArgs(
    int         argc,
    char    *   argv[],
    char *      Comment )
{
    printf("Dumping args %s\n", Comment );

    for (int i = 0; i < argc  &&  argv[i]; i++ )
        printf("  %s\n", argv[i] );
}



/****************************************************************************

    Read the command file into a in-memory buffer.

    The pointer returned is a pointer to the contents of the command file.
    To aid debugging the size of the file is tucked away just in front of it.
 ****************************************************************************/

char * ReadCommandFile(const char *pszFilename)
{
    int             fileCmd = -1;
    struct _stat    filestat = {0};
    char           *Buffer = NULL;
    int             bytesread;

    fileCmd = _open( pszFilename, _O_BINARY | _O_RDONLY | _O_SEQUENTIAL );

    if ( -1 == fileCmd )
        goto Error;

    if ( -1 == _fstat( fileCmd, &filestat ) )
        goto Error;

    Buffer = new char[filestat.st_size + sizeof(filestat.st_size)];

    // Tuck away the size of the buffer to make debugging easier

    * (_off_t *) Buffer = filestat.st_size;
    Buffer += sizeof( _off_t );

    bytesread = _read( fileCmd, Buffer, filestat.st_size );

    if ( bytesread != filestat.st_size )
        goto Error;

    _close(fileCmd);

    return Buffer;

Error:

    if (NULL != Buffer)
        delete [] (Buffer - sizeof(_off_t));

    if (-1 != fileCmd )
        _close( fileCmd );

    char message[1024];
    sprintf(message, ": %s (%s)", _strerror(NULL), pszFilename);

    // _strerror embeds a newline in the error string, get rid of it
    * ( strchr( message, '\n') ) = ' ';

    RpcError( 0, 0, UNABLE_TO_OPEN_CMD_FILE, message );

    return NULL;
}



/****************************************************************************

    If the command file is corrupt do a hex dump of (up to) the first 
    256 bytes of the file to aid in finding out what whacked it.

    REVIEW: This was intended to be a temporary feature.  It may be useful
             to just leave it in.

 ****************************************************************************/

void HexDumpCommandFile(char *buffer)
{
    _off_t  length = * (_off_t *) (buffer - sizeof(_off_t));
    _off_t  bytes = 0;

    for (int i = 0; i < 16 && bytes < length; i++)
        {
        printf("%02x: ", i * 16);

        for ( int j = 0; j < 16 && bytes < length; j++)
            {
            printf( "%02x ", buffer[i*16+j] );
            ++bytes;
            }

        for ( int k = j; k < 16; k++ )
            printf("   ");

        for ( int l = 0; l < j; l++ )
            if ( iscntrl( buffer[i*16+l] ) )
                putchar( '.' );
            else
                putchar( buffer[i*16+l] );

        printf("\n");
        }                
}



/****************************************************************************

  If this is a fre build and the -debugexc switch is *not* present then
  catch any exceptions and shutdown MIDL at least semi-gracefully.  Otherwise
  allow the system to throw up a popup / enter a debugger / etc to make
  debugging easier.

  In any case print a message saying that something bad happened.
    
 ****************************************************************************/

int FilterException()
{
    printf( "\nmidl : error MIDL%d : internal compiler problem -",
            I_ERR_UNEXPECTED_INTERNAL_PROBLEM );
    printf( " See documentation for suggestions on how to find a workaround.\n" );

#if MIDL_FREE_BUILD
    if ( ! pCommand->IsSwitchDefined( SWITCH_DEBUGEXC ) )
        return EXCEPTION_EXECUTE_HANDLER;
#endif

    return EXCEPTION_CONTINUE_SEARCH;
}



int
main    (
        int     argc,
        char*   argv[]
        )
    {
    STATUS_T Status = UNABLE_TO_OPEN_CMD_FILE;

    pCommand = new CMD_ARG;

    __try
        {

        if ( argc  != 2 )
            {
            char szCompilerVersion[32];
            Status = NO_INTERMEDIATE_FILE;
            sprintf( szCompilerVersion, "%d.%02d.%04d", rmj, rmm, rup );
            fprintf( stderr, pSignon1, szCompilerVersion );
            fprintf( stderr, pSignon2 );
            fflush( stderr );
            RpcError( 0, 0, Status, 0 );
            }
        else
            {
            char *Buffer;

            Buffer = ReadCommandFile( argv[1] );

            if ( NULL != Buffer )
                Status = pCommand->StreamIn( Buffer );

            switch (Status)
                {
                case STATUS_OK:
                    pCompiler = new ccontrol( pCommand );    
                    Status = pCompiler->Go();
                    break;

                case BAD_CMD_FILE:
                    RpcError( 0, 0, Status, argv[1] );
                    HexDumpCommandFile( Buffer );
                    break;

                case UNABLE_TO_OPEN_CMD_FILE:
                    // This should have been reported in ReadCommandFile
                    break;      

                default:
                    RpcError( 0, 0, Status, NULL );
                }

            if ( NULL != Buffer )
                {
                // The buffer was biased by it's size to make debugging easier.
                delete [] (Buffer - sizeof(_off_t));
                }
            }
        }
    __except( FilterException() )
        {
        // The real work is done in FilterException
        Status = (STATUS_T) GetExceptionCode();
        }

    return Status;
    }

/****************************************************************************
 ccontrol:
    the constructor
 ****************************************************************************/
ccontrol::ccontrol( CMD_ARG* pCommand )
    {
    // initialize
    ErrorCount = 0;
    pCompiler  = this;

    // set up the command processor
    SetCommandProcessor( pCommand );

    // set up the lexeme table
    pMidlLexTable = new LexTable( (size_t )MIDL_LEX_TABLE_SIZE );
    }


_inline void
DumpStatsTypeGraph()
{
#ifdef MIDL_INTERNAL

    if((pCompiler->GetCommandProcessor())->IsSwitchDefined( SWITCH_DUMP ) )
        {
        print_memstats();
        print_typegraph();
        };
#endif
}


/****************************************************************************
 go:
    the actual compiler execution
 ****************************************************************************/

STATUS_T
ccontrol::Go()
    {
    STATUS_T   Status = STATUS_OK;

    pPass1 = new PASS_1;
    if( (Status = pPass1->Go() ) == STATUS_OK )
        {

        MIDL_INTERNAL_PRINTF( "starting ACF pass\n" );

        pPass2    = new PASS_2;
        if( (Status = pPass2->Go() ) == STATUS_OK )
            {
            // DumpStatsTypeGraph();

            MIDL_INTERNAL_PRINTF( "starting Semantic pass\n" );

            GlobalMainMessageNumberList.SetAll();
            pPass3 = new PASS_3;
            if ( ( (Status = pPass3->Go() ) == STATUS_OK )
#ifdef MIDL_INTERNAL
                 || pCommand->IsSwitchDefined( SWITCH_OVERRIDE )     
#endif // MIDL_INTERNAL
                                    )
                {
                DumpStatsTypeGraph();

                // Complain if the user used -wire_compat.  Put it here so
                // that they can turn it off with midl_pragma if they want to.

                if ( pCommand->IsSwitchDefined( SWITCH_WIRE_COMPAT ) )
                    RpcError( NULL, 0, WIRE_COMPAT_WARNING, NULL );

                //UseBackEndHeap();
#ifndef NOBACKEND
                if( !pCommand->IsSwitchDefined( SWITCH_SYNTAX_CHECK ) &&
                    !pCommand->IsSwitchDefined( SWITCH_ZS ) &&
                    pCommand->NeedsNDRRun() )
                    {
                    MIDL_INTERNAL_PRINTF( "starting codegen pass\n");
                    pCommand->SetIsNDRRun();

                    GlobalMainMessageNumberList.SetAll();
                    CGMain( pSourceNode );

                    pCommand->ResetIsNDRRun();
#endif // NOBACKEND
                    }
                //DestroyBackEndHeap();



                // BUGBUG: for now assume NDR is always the first, unless in ndr64 only case.

                if (pCommand->NeedsNDR64Run() )
                    {
                    //UseBackEndHeap();

                    pCommand->SetIsNDR64Run();
                    if ( pCommand->NeedsNDRRun() )
                        pCommand->SetIs2ndCodegenRun();
                        
                    GlobalMainMessageNumberList.SetAll();
                    Ndr64CGMain( pSourceNode );

                    //DestroyBackEndHeap();
                    }
                    
                }

            }
        }

#ifdef DEBUG
    printf("front end %d , back end %d, other %d \n",Skl_Bytes,BackAllocation,TotalAllocation);
#endif
    if((pCompiler->GetCommandProcessor())->IsSwitchDefined( SWITCH_DUMP ) )
        {
        print_memstats();
        // print_typegraph();
        }

      return Status;
    }


void
IncrementErrorCount()
    {
    if ( pCompiler )
        pCompiler->IncrementErrorCount();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\makefile.inc ===
# Copyright (c) 1993-1999 Microsoft Corporation

!ifndef		MIDLTOOLS
YACC	= midlyacc.exe
PREGRAM	= midlpg.exe
EBASE	= midleb.exe
!else	#	MIDLTOOLS
YACC	= $(MIDLTOOLS)\yacc\midlyacc.exe
PREGRAM	= $(MIDLTOOLS)\pg\midlpg.exe
EBASE	= $(MIDLTOOLS)\erec\obj\os2\midleb.exe
!endif	#	MIDLTOOLS

TARGETS=$(O)\grammar.cxx \
        $(O)\acfgram.cxx

grammars: $(TARGETS)

.SUFFIXES: .y .c

{.}.y{$(O)}.y:
	copy $? $(O)

{.}.c{$(O)}.c:
	copy $? $(O)

$(O)\grammar.cxx : $(O)\grammar.y xlatidl.dat $(O)\yypars.c makefile.inc
    cd $(O)
    
    $(YACC) -his -t "YYCONST " grammar.y
    findstr -v /c:"#line " grammar.c > grammar.tmp
    erase grammar.c
    $(PREGRAM) grammar.tmp > grammar.cxx
    erase grammar.tmp
    $(EBASE) - ..\..\xlatidl.dat IDL > idlerec.h
    
    cd ..\..

$(O)\acfgram.cxx : $(O)\acfgram.y xlatacf.dat yypars.c makefile.inc
    cd $(O)
     
    $(YACC) -his -t "YYCONST " acfgram.y
    findstr -v /c:"#line " acfgram.c > acfgram.tmp
    erase acfgram.c
    $(PREGRAM) acfgram.tmp > acfgram.cxx
    erase acfgram.tmp
    $(EBASE) - ..\..\xlatacf.dat ACF > acferec.h
    
    cd ..\..
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\misc.cxx ===
// Copyright (c) 1993-1999 Microsoft Corporation

#pragma warning ( disable : 4514 4710 )

#include <stdio.h>
#include "cmdana.hxx"

extern CMD_ARG* pCommand;

/*
put the following lines in rpcndr.h

     // MIDL 3.03.98
#define __RPCNDR_H_VERSION__        440

#ifdef __REQUIRED_RPCNDR_H_VERSION__ 
    #if ( __RPCNDR_H_VERSION__ < __REQUIRED_RPCNDR_H_VERSION__ )
        #error incorrect <rpcndr.h> version. Use the header that matches with the MIDL compiler.
    #endif 
#endif // __REQUIRED_RPCNDR_H_VERSION__

put the following lines in rpcproxy.h
     
       // MIDL 3.03.98
#define __RPCPROXY_H_VERSION__      440

#ifdef __REQUIRED_RPCPROXY_H_VERSION__ 
    #if ( __RPCPROXY_H_VERSION__ < __REQUIRED_RPCPROXY_H_VERSION__ )
        #error incorrect <rpcproxy.h> version. Use the header that matches with the MIDL compiler.
    #endif 
#endif // __REQUIRED_RPCPROXY_H_VERSION__

*/

#define RPC_HEADERS_VERSION "/* verify that the %s version is high enough to compile this file*/\n" \
                            "#ifndef %s\n#define %s %d\n#endif\n\n"
                                    
char*
GetRpcNdrHVersionGuard( char* szVer )
    {
    unsigned long   ulVersion = 440;

    *szVer = 0;
    if ( !pCommand->IsSwitchDefined( SWITCH_VERSION_STAMP ) )
        {
        if ( pCommand->GetNdrVersionControl().HasNdr50Feature() )
            {
            if (pCommand->GetNdrVersionControl().HasAsyncUUID() ||
                pCommand->GetNdrVersionControl().HasDOA() ||
                pCommand->GetNdrVersionControl().HasContextSerialization() ||
                pCommand->GetNdrVersionControl().HasInterpretedNotify() )
                {
                ulVersion = 475;
                }
            else
                {
                ulVersion = 450;
                }
            }
        sprintf( szVer, RPC_HEADERS_VERSION, "<rpcndr.h>",
                "__REQUIRED_RPCNDR_H_VERSION__", "__REQUIRED_RPCNDR_H_VERSION__", ulVersion );
        }
    return szVer;
    }

char*
GetRpcProxyHVersionGuard( char* szVer )
    {
    unsigned long   ulVersion = 440;

    *szVer = 0;
    if ( !pCommand->IsSwitchDefined( SWITCH_VERSION_STAMP ) )
        {
        if ( pCommand->GetNdrVersionControl().HasNdr50Feature() )
            {
            if (pCommand->GetNdrVersionControl().HasAsyncUUID() ||
                pCommand->GetNdrVersionControl().HasDOA() ||
                pCommand->GetNdrVersionControl().HasContextSerialization() ||
                pCommand->GetNdrVersionControl().HasInterpretedNotify() )
                {
                ulVersion = 475;
                }
            else
                {
                ulVersion = 450;
                }
            }
        sprintf( szVer, RPC_HEADERS_VERSION, "<rpcproxy.h>",
                "__REDQ_RPCPROXY_H_VERSION__", "__REQUIRED_RPCPROXY_H_VERSION__", ulVersion );
        }
    return szVer;
    }

void 
MidlSleep( int sec )
    {
    _sleep( 1000 * sec );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\mbcs.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1995-1999 Microsoft Corporation

 Module Name:

    mbcs.cxx

 Abstract:

    MBCS support related code used by the lexer.

 Notes:

 History:

    RyszardK   Sep-1996        Created.
    
 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 )

#include <windows.h>
#include <stdlib.h>
#include "mbcs.hxx"

CharacterSet CurrentCharSet;

int
CharacterSet::DBCSDefaultToCaseSensitive()
    {
    // these languages do not distinguish cases
    return (
            PRIMARYLANGID(LANGIDFROMLCID(CurrentLCID)) == LANG_JAPANESE ||
            PRIMARYLANGID(LANGIDFROMLCID(CurrentLCID)) == LANG_CHINESE  ||
            PRIMARYLANGID(LANGIDFROMLCID(CurrentLCID)) == LANG_KOREAN
            );
    }


CharacterSet::CharacterSet()
{
    memset( DbcsLeadByteTable, 0, 128 );
    SetDbcsLeadByteTable( GetSystemDefaultLCID() );
}

CharacterSet::DBCS_ERRORS
CharacterSet::SetDbcsLeadByteTable( 
    unsigned long   ulLocale )
{
    DBCS_ERRORS dbcsRet     = dbcs_Failure;
    
    if (CurrentLCID != ulLocale)
        {
        dbcsRet = dbcs_Success;
        char  szCodePage[6];

        if ( GetLocaleInfo( ulLocale,
                            LOCALE_NOUSEROVERRIDE | LOCALE_IDEFAULTANSICODEPAGE,
                            szCodePage,
                            sizeof(szCodePage) ) )
            {
            unsigned int  CodePage = atoi( szCodePage );

            for (int i = 128; i < 256; i++ )
                {
                DbcsLeadByteTable[i] = (char) IsDBCSLeadByteEx( CodePage,
                                                                (char) i );
                }
            }
        else
            {
            unsigned char i = 0;
	        switch (PRIMARYLANGID(ulLocale))
                {
	            case LANG_CHINESE:
                    if (SUBLANGID(ulLocale) == SUBLANG_CHINESE_SIMPLIFIED)
                        {
                        for (i=0xA1; i <= 0xFE; i++)
                            {
                            DbcsLeadByteTable[i] = 1;
                            }
                        }
                    break;
                case LANG_KOREAN:
                    for (i = 0x81; i <= 0xFE; i++)
                        {
                        DbcsLeadByteTable[i] = 1;
                        }
                    break;
                case LANG_JAPANESE:
                    for (i = 0x81; i <= 0x9F; i++)
                        {
                        DbcsLeadByteTable[i] = 1;
                        }
                    for (i = 0xE0; i <= 0xFC; i++)
                        {
                        DbcsLeadByteTable[i] = 1;
                        }
                    break;
                default:
                    dbcsRet = dbcs_BadLCID;
                    break;
	            }
            }
        }
    else
        {
        dbcsRet = dbcs_Success;
        }
    if (CurrentLCID != (unsigned long)-1 &&
        CurrentLCID != ulLocale &&
        ulLocale    != 0)
        {
        dbcsRet = dbcs_LCIDConflict;
        }
    CurrentLCID = ulLocale;
    return dbcsRet;
}

int
CharacterSet::CompareDBCSString(
    char*           szLHStr,
    char*           szRHStr,
    unsigned long   ulFlags
    )
{
    int     nRet = CompareStringA(  CurrentLCID,
                                    NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE | ulFlags,
                                    szLHStr,
                                    -1,
                                    szRHStr,
                                    -1) - 2;
    if (nRet == -2)
        {
        nRet = strcmp(szLHStr, szRHStr);
        }
    return nRet;
}

unsigned int
GetConsoleMaxLineCount()
{
    CONSOLE_SCREEN_BUFFER_INFO  ConsoleInfo;
    HANDLE hOutput = GetStdHandle( STD_OUTPUT_HANDLE );
    ZeroMemory( &ConsoleInfo,  sizeof( ConsoleInfo ) );
    BOOL fResult = GetConsoleScreenBufferInfo( hOutput, &ConsoleInfo );
    if ( fResult )
    {
        return ConsoleInfo.srWindow.Bottom - 1;
    }
    else
    {
        return 23;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\nkeyw.c ===
/*****************************************************************************
 *      Copyright (c) 1990-1999 Microsoft Corporation
 *
 *                      RPC compiler: Pass1 handler
 *
 *      Author  : Vibhas Chandorkar
 *      Created : 01st-Sep-1990
 *
 ****************************************************************************/

#pragma warning ( disable : 4514 4214 )

/****************************************************************************
 *                      include files
 ***************************************************************************/
#include "nulldefs.h"
#include "midldebug.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "grammar.h"
#include "lex.h"

/****************************************************************************
 *                      local definitions and macros
 ***************************************************************************/

const struct _keytable
    {

    const char  *   pString;
    token_t         Token   : 16;
    short           flag    : 16;

    } KeywordTable[] =
{
 {"FALSE",              TOKENFALSE,         UNCONDITIONAL }
,{"ISO_LATIN_1",        KWISOLATIN1,        UNCONDITIONAL }
,{"ISO_UCS",            KWISOUCS,           UNCONDITIONAL }
,{"ISO_MULTI_LINGUAL",  KWISOMULTILINGUAL,  UNCONDITIONAL }
,{"NULL",               KWTOKENNULL,        UNCONDITIONAL }
,{"SAFEARRAY",          KWSAFEARRAY,        UNCONDITIONAL }
,{"TRUE",               TOKENTRUE,          UNCONDITIONAL }
,{"__alignof",          KWALIGNOF,          UNCONDITIONAL }
,{"__asm",              MSCASM,             UNCONDITIONAL }
,{"__cdecl",            MSCCDECL,           UNCONDITIONAL }
,{"__declspec",         KWMSCDECLSPEC,      UNCONDITIONAL }
,{"__export",           MSCEXPORT,          UNCONDITIONAL }
,{"__far",              MSCFAR,             UNCONDITIONAL }
,{"__fastcall",         MSCFASTCALL,        UNCONDITIONAL }
,{"__float128",         KWFLOAT128,         UNCONDITIONAL }
,{"__float80",          KWFLOAT80,          UNCONDITIONAL }
,{"__fortran",          MSCFORTRAN,         UNCONDITIONAL }
,{"__huge",             MSCHUGE,            UNCONDITIONAL }
,{"__inline",           KW_C_INLINE,        UNCONDITIONAL }
,{"__int128",           KWINT128,           UNCONDITIONAL }
,{"__int32",            KWINT32,            UNCONDITIONAL }
,{"__int3264",          KWINT3264,          UNCONDITIONAL }
,{"__int64",            KWINT64,            UNCONDITIONAL }
,{"__loadds",           MSCLOADDS,          UNCONDITIONAL }
,{"__near",             MSCNEAR,            UNCONDITIONAL }
,{"__pascal",           MSCPASCAL,          UNCONDITIONAL }
,{"__ptr32",            MSCPTR32,           UNCONDITIONAL }
,{"__ptr64",            MSCPTR64,           UNCONDITIONAL }
,{"__saveregs",         MSCSAVEREGS,        UNCONDITIONAL }
,{"__segment",          MSCSEGMENT,         UNCONDITIONAL }
,{"__self",             MSCSELF,            UNCONDITIONAL }
,{"__stdcall",          MSCSTDCALL,         UNCONDITIONAL }
,{"__unaligned",        MSCUNALIGNED,       UNCONDITIONAL }
,{"__w64",              MSCW64,             UNCONDITIONAL }
,{"_asm",               MSCASM,             UNCONDITIONAL }
,{"_cdecl",             MSCCDECL,           UNCONDITIONAL }
,{"_declspec",          KWMSCDECLSPEC,      UNCONDITIONAL }
,{"_export",            MSCEXPORT,          UNCONDITIONAL }
,{"_far",               MSCFAR,             UNCONDITIONAL }
,{"_fastcall",          MSCFASTCALL,        UNCONDITIONAL }
,{"_fortran",           MSCFORTRAN,         UNCONDITIONAL }
,{"_huge",              MSCHUGE,            UNCONDITIONAL }
,{"_inline",            KW_C_INLINE,        UNCONDITIONAL }
,{"_loadds",            MSCLOADDS,          UNCONDITIONAL }
,{"_near",              MSCNEAR,            UNCONDITIONAL }
,{"_pascal",            MSCPASCAL,          UNCONDITIONAL }
,{"_saveregs",          MSCSAVEREGS,        UNCONDITIONAL }
,{"_segment",           MSCSEGMENT,         UNCONDITIONAL }
,{"_self",              MSCSELF,            UNCONDITIONAL }
,{"_stdcall",           MSCSTDCALL,         UNCONDITIONAL }
,{"aggregatable",       KWAGGREGATABLE,     INBRACKET }
,{"align",              KWALIGN,            INBRACKET }
,{"allocate",           KWALLOCATE,         INBRACKET }
,{"appobject",          KWAPPOBJECT,        INBRACKET }
,{"async",              KWASYNC,            INBRACKET }
,{"async_uuid",         KWASYNCUUID,        INBRACKET }
,{"auto",               KWAUTO,             UNCONDITIONAL }
,{"auto_handle",        KWAUTOHANDLE,       INBRACKET }
,{"bindable",           KWBINDABLE,         INBRACKET }
,{"boolean",            KWBOOLEAN,          UNCONDITIONAL }
,{"broadcast",          KWBROADCAST,        INBRACKET }
,{"bstring",            KWBSTRING,          INBRACKET }
,{"byte",               KWBYTE,             UNCONDITIONAL }
,{"byte_count",         KWBYTECOUNT,        INBRACKET }
,{"call_as",            KWCALLAS,           INBRACKET }
,{"callback",           KWCALLBACK,         INBRACKET }
,{"case",               KWCASE,             UNCONDITIONAL }
,{"cdecl",              MSCCDECL,           UNCONDITIONAL }
,{"char",               KWCHAR,             UNCONDITIONAL }
,{"coclass",            KWCOCLASS,          UNCONDITIONAL }
,{"code",               KWCODE,             INBRACKET }
,{"comm_status",        KWCOMMSTATUS,       INBRACKET }
,{"const",              KWCONST,            UNCONDITIONAL }
,{"context_handle",     KWCONTEXTHANDLE,    INBRACKET }
,{"context_handle_noserialize",KWNOSERIALIZE,      INBRACKET }
,{"context_handle_serialize",  KWSERIALIZE,        INBRACKET }
,{"control",            KWCONTROL,          INBRACKET }
,{"cpp_quote",          KWCPPQUOTE,         UNCONDITIONAL }
,{"cs_char",            KWCSCHAR,           INBRACKET }
,{"cs_drtag",           KWCSDRTAG,          INBRACKET }
,{"cs_rtag",            KWCSRTAG,           INBRACKET }
,{"cs_stag",            KWCSSTAG,           INBRACKET }
,{"cs_tag_rtn",         KWCSTAGRTN,         INBRACKET }
,{"custom",             KWCUSTOM,           INBRACKET }
,{"declare_guid",       KWDECLGUID,         UNCONDITIONAL }
,{"decode",             KWDECODE,           INBRACKET }
,{"default",            KWDEFAULT,          UNCONDITIONAL }
,{"defaultbind",        KWDEFAULTBIND,      INBRACKET }
,{"defaultcollelem",    KWDEFAULTCOLLELEM,  INBRACKET }
,{"defaultvalue",       KWDEFAULTVALUE,     INBRACKET }
,{"defaultvtable",      KWDEFAULTVTABLE,    INBRACKET }
,{"dispinterface",      KWDISPINTERFACE,    UNCONDITIONAL }
,{"displaybind",        KWDISPLAYBIND,      INBRACKET }
,{"dllname",            KWDLLNAME,          INBRACKET }
,{"double",             KWDOUBLE,           UNCONDITIONAL }
,{"dual",               KWDUAL,             INBRACKET }
,{"enable_allocate",    KWENABLEALLOCATE,   INBRACKET }
,{"encode",             KWENCODE,           INBRACKET }
,{"endpoint",           KWENDPOINT,         INBRACKET }
,{"entry",              KWENTRY,            INBRACKET}
,{"enum",               KWENUM,             UNCONDITIONAL }
,{"explicit_handle",    KWEXPLICITHANDLE,   INBRACKET }
,{"extern",             KWEXTERN,           UNCONDITIONAL }
,{"far",                MSCFAR,             UNCONDITIONAL }
,{"fault_status",       KWFAULTSTATUS,      INBRACKET }
,{"first_is",           KWFIRSTIS,          INBRACKET }
,{"float",              KWFLOAT,            UNCONDITIONAL }
,{"force_allocate",		KWFORCEALLOCATE,	INBRACKET }
,{"funcdescattr",       KWFUNCDESCATTR,     INBRACKET }
,{"handle",             KWHANDLE,           INBRACKET }
,{"handle_t",           KWHANDLET,          UNCONDITIONAL }
,{"heap",               KWHEAP,             INBRACKET }
,{"helpcontext",        KWHC,               INBRACKET }
,{"helpfile",           KWHELPFILE,         INBRACKET }
,{"helpstring",         KWHELPSTR,          INBRACKET }
,{"helpstringcontext",  KWHSC,              INBRACKET }
,{"helpstringdll",      KWHELPSTRINGDLL,    INBRACKET }
,{"hidden",             KWHIDDEN,           INBRACKET }
,{"hyper",              KWHYPER,            UNCONDITIONAL }
,{"id",                 KWID,               INBRACKET }
,{"idempotent",         KWIDEMPOTENT,       INBRACKET }
,{"idldescattr",        KWIDLDESCATTR,      INBRACKET }
,{"ignore",             KWIGNORE,           INBRACKET }
,{"iid_is",             KWIIDIS,            INBRACKET }
,{"immediatebind",      KWIMMEDIATEBIND,    INBRACKET }
,{"implicit_handle",    KWIMPLICITHANDLE,   INBRACKET }
,{"import",             KWIMPORT,           UNCONDITIONAL }
,{"importlib",          KWIMPORTLIB,        UNCONDITIONAL }
,{"in",                 KWIN,               INBRACKET }
,{"in_line",            KWINLINE,           INBRACKET }
,{"include",            KWINCLUDE,          UNCONDITIONAL }
,{"inline",             KW_C_INLINE,        UNCONDITIONAL }
,{"input_sync",         KWINPUTSYNC,        INBRACKET }
,{"int",                KWINT,              UNCONDITIONAL }
,{"interface",          KWINTERFACE,        UNCONDITIONAL }
,{"interpret",          KWINTERPRET,        INBRACKET }
,{"last_is",            KWLASTIS,           INBRACKET }
,{"lcid",               KWLCID,             INBRACKET}
,{"length_is",          KWLENGTHIS,         INBRACKET }
,{"library",            KWLIBRARY,          UNCONDITIONAL }
,{"licensed",           KWLICENSED,         INBRACKET }
,{"local",              KWLOCAL,            INBRACKET }
,{"local_call",         KWLOCAL,            INBRACKET }
,{"long",               KWLONG,             UNCONDITIONAL }
,{"long_enum",          KWLONGENUM,         INBRACKET }
,{"manual",             KWMANUAL,           INBRACKET }
,{"max_is",             KWMAXIS,            INBRACKET }
,{"maybe",              KWMAYBE,            INBRACKET }
,{"message",            KWMESSAGE,          INBRACKET }
,{"methods",            KWMETHODS,          UNCONDITIONAL }
,{"midl_pragma",        KWMIDLPRAGMA,       UNCONDITIONAL }
,{"min_is",             KWMINIS,            INBRACKET }
,{"module",             KWMODULE,           UNCONDITIONAL }
,{"ms_conf_struct",     KWMS_CONF_STRUCT,   INBRACKET }
,{"ms_union",           KWMSUNION,          INBRACKET }
,{"near",               MSCNEAR,            UNCONDITIONAL }
,{"nocode",             KWNOCODE,           INBRACKET }
,{"nointerpret",        KWNOINTERPRET,      INBRACKET }
,{"nonbrowsable",       KWNONBROWSABLE,     INBRACKET }
,{"noncreatable",       KWNONCREATABLE,     INBRACKET }
,{"nonextensible",      KWNONEXTENSIBLE,    INBRACKET }
,{"notify",             KWNOTIFY,           INBRACKET }
,{"notify_flag",        KWNOTIFYFLAG,       INBRACKET }
,{"object",             KWOBJECT,           INBRACKET }
,{"odl",                KWODL,              INBRACKET }
,{"off_line",           KWOFFLINE,          INBRACKET }
,{"oleautomation",      KWOLEAUTOMATION,    INBRACKET }
,{"optimize",           KWOPTIMIZE,         INBRACKET }
,{"optional",           KWOPTIONAL,         INBRACKET }
,{"out",                KWOUT,              INBRACKET }
,{"out_of_line",        KWOUTOFLINE,        INBRACKET }
,{"partial_ignore",     KWPARTIALIGNORE,    INBRACKET }
,{"pascal",             MSCPASCAL,          UNCONDITIONAL }
,{"pipe",               KWPIPE,             UNCONDITIONAL }
,{"pointer_default",    KWDEFAULTPOINTER,   INBRACKET }
,{"predeclid",          KWPREDECLID,        INBRACKET }
,{"private_char_16",    KWPRIVATECHAR16,    UNCONDITIONAL }
,{"private_char_8",     KWPRIVATECHAR8,     UNCONDITIONAL }
,{"properties",         KWPROPERTIES,       UNCONDITIONAL }
,{"propget",            KWPROPGET,          INBRACKET }
,{"propput",            KWPROPPUT,          INBRACKET }
,{"propputref",         KWPROPPUTREF,       INBRACKET }
,{"proxy",              KWPROXY,            INBRACKET }
,{"ptr",                KWPTR,              INBRACKET }
,{"public",             KWPUBLIC,           INBRACKET }
,{"range",              KWRANGE,            INBRACKET }
,{"readonly",           KWREADONLY,         INBRACKET }
,{"ref",                KWREF,              INBRACKET }
,{"register",           KWREGISTER,         UNCONDITIONAL }
,{"replaceable",        KWREPLACEABLE,      INBRACKET }
,{"represent_as",       KWREPRESENTAS,      INBRACKET }
,{"requestedit",        KWREQUESTEDIT,      INBRACKET }
,{"restricted",         KWRESTRICTED,       INBRACKET }
,{"retval",             KWRETVAL,           INBRACKET }
,{"shape",              KWSHAPE,            INBRACKET }
,{"short",              KWSHORT,            UNCONDITIONAL }
,{"short_enum",         KWSHORTENUM,        INBRACKET }
,{"signed",             KWSIGNED,           UNCONDITIONAL }
,{"size_is",            KWSIZEIS,           INBRACKET }
,{"sizeof",             KWSIZEOF,           UNCONDITIONAL }
,{"small",              KWSMALL,            UNCONDITIONAL }
,{"source",             KWSOURCE,           INBRACKET }
,{"static",             KWSTATIC,           UNCONDITIONAL }
,{"stdcall",            MSCSTDCALL,         UNCONDITIONAL }
,{"strict_context_handle", KWSTRICTCONTEXTHANDLE, INBRACKET }
,{"string",             KWSTRING,           INBRACKET }
,{"struct",             KWSTRUCT,           UNCONDITIONAL }
,{"switch",             KWSWITCH,           UNCONDITIONAL }
,{"switch_is",          KWSWITCHIS,         INBRACKET }
,{"switch_type",        KWSWITCHTYPE,       INBRACKET }
,{"transmit_as",        KWTRANSMITAS,       INBRACKET }
,{"typedef",            KWTYPEDEF,          UNCONDITIONAL }
,{"typedescattr",       KWTYPEDESCATTR,     INBRACKET }
,{"uidefault",          KWUIDEFAULT,        INBRACKET }
,{"unaligned",          KWUNALIGNED,        INBRACKET }
,{"union",              KWUNION,            UNCONDITIONAL }
,{"unique",             KWUNIQUE,           INBRACKET }
,{"unsigned",           KWUNSIGNED,         UNCONDITIONAL }
,{"user_marshal",       KWUSERMARSHAL,      INBRACKET }
,{"usesgetlasterror",   KWUSESGETLASTERROR, INBRACKET }
,{"uuid",               KWUUID,             INBRACKET }
,{"v1_array",           KWV1ARRAY,          INBRACKET }
,{"v1_enum",            KWV1ENUM,           INBRACKET }
,{"v1_string",          KWV1STRING,         INBRACKET }
,{"v1_struct",          KWV1STRUCT,         INBRACKET }
,{"vararg",             KWVARARG,           INBRACKET }
,{"vardescattr",        KWVARDESCATTR,      INBRACKET }
,{"version",            KWVERSION,          INBRACKET }
,{"void",               KWVOID,             UNCONDITIONAL }
,{"volatile",           KWVOLATILE,         UNCONDITIONAL }
,{"wire_marshal",       KWWIREMARSHAL,      INBRACKET }
};

#define SIZE_OF_KEYWORD_TABLE   \
        ( sizeof( KeywordTable ) / sizeof(struct _keytable ) )

/****************************************************************************
 *                      local data
 ***************************************************************************/

/****************************************************************************
 *                      local procedure prototypes
 ***************************************************************************/


/****************************************************************************
 *                      external data
 ***************************************************************************/

/****************************************************************************
 *                      external procedures/prototypes/etc
 ***************************************************************************/

/**************************************************************************
 is_keyword:
    Is the given string a keyword ? if yes, return the token value of
    the token. Else return IDENTIFIER.
 **************************************************************************/
token_t
is_keyword(
        char    *       pID,
        short           InBracket
        )
    {
    short cmp;

    short low  = 0;
    short high = SIZE_OF_KEYWORD_TABLE - 1;
    short mid;


    while ( low <= high )
        {
        mid = (short)( (low + high) / 2 );

        cmp =  (short) strcmp( pID, KeywordTable[mid].pString );
        if( cmp < 0 )
            {
            high = (short)( mid - 1 );
            }
        else if (cmp > 0)
            {
            low = (short)( mid + 1 );
            }
        else
            {
            // since InBracket is the only flag, this check is enough
            if (KeywordTable[mid].flag <= InBracket)
                return KeywordTable[mid].Token;
            else
                return IDENTIFIER;
            }

        }
    return IDENTIFIER;
    }

char *
KeywordToString(
        token_t Token )
    {
    struct _keytable *  pTable      = (struct _keytable *) KeywordTable;
    struct _keytable *  pTableEnd   = pTable + SIZE_OF_KEYWORD_TABLE;


    while( pTable < pTableEnd )
        {
        if( pTable->Token == Token )
            return (char*) pTable->pString;
        pTable++;
        }

    MIDL_ASSERT( 0 );
    return "";
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\miscnode.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: miscnode.cxx
Title				: miscellaneous typenode handler
History				:
	08-Aug-1991	VibhasC	Created

*****************************************************************************/

#pragma warning ( disable : 4514 )

/****************************************************************************
 includes
 ****************************************************************************/

#include "nulldefs.h"
extern	"C"	{
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	
}

#include "allnodes.hxx"
#include "gramutil.hxx"
#include "cmdana.hxx"
#include "control.hxx"
#include "filehndl.hxx"
#include "lextable.hxx"

extern BOOL							IsTempName( char * );

/****************************************************************************
 extern data
 ****************************************************************************/

extern SymTable					*	pBaseSymTbl;
extern CCONTROL					*	pCompiler;
extern PASS_1					*	pPass1;
extern node_error				*	pErrorTypeNode;
extern short						ImportLevel;
extern CMD_ARG					*	pCommand;
extern NFA_INFO					*	pImportCntrl;
extern IINFODICT				*	pInterfaceInfoDict;
extern LexTable 				*	pMidlLexTable;

/****************************************************************************
 local defines
 ****************************************************************************/
/****************************************************************************/

/****************************************************************************
 						node_interface procedures
 ****************************************************************************/
node_interface::node_interface( NODE_T Kind )
        : named_node( Kind )
    {
    ProcCount           = 0;
    CallBackProcCount   = 0;
    pBaseIntf           = NULL;
    pDefiningFile       = NULL;
    OptimFlags          = OPTIMIZE_NONE;
    OptimLevel          = OPT_LEVEL_OS;
    fIAmIUnknown        = 0;
    fPickle             = 0;
    fHasProcsWithRpcSs  = 0;
    fSemAnalyzed        = 0;
    fPrintedDef         = 0;
    fPrintedIID         = 0;
    pMyCG               = NULL;
    pMyTlbCG            = NULL;
    pProcTbl            = NULL;
    fHasOLEAutomation   = 0;
    fIsAsyncClone       = 0;
    pAsyncInterface     = 0;
    if ( pCommand->IsSwitchDefined( SWITCH_MS_CONF_STRUCT ) )
        {
        fHasMSConfStructAttr = TRUE;
        }
    else
        {
        fHasMSConfStructAttr = FALSE;
        }
    }

void                
node_interface::GetVersionDetails( unsigned short * Maj, 
								   unsigned short * Min )
	{
	node_version	*	pAttr;

	pAttr = (node_version *)
				 GetAttribute( ATTR_VERSION );
	if (pAttr)
		{
		pAttr->GetVersion( Maj, Min );
		}
	else
		{
		*Maj = 0;
		*Min = 0;
		};
	};

node_interface *
node_interface::GetMyBaseInterface()
{
	node_interface *pRealBaseInterface = 0;
	node_interface_reference *pRef;

	//Get the real base interface node, skipping over the 
	//node_forward and the node_interface_reference.
	if(pBaseIntf)
		{
		//if necessary, skip over forward reference node
		if(pBaseIntf->NodeKind() == NODE_FORWARD)
			pRef = (node_interface_reference *)pBaseIntf->GetChild();
		else
			pRef = (node_interface_reference *)pBaseIntf;

		//skip over the interface reference node.
		if(pRef)		
	    	pRealBaseInterface = pRef->GetRealInterface();
		}

	return pRealBaseInterface;
}


/****************************************************************************
 						node_file procedures
 ****************************************************************************/
node_file::node_file(
	char	*	pInputName,
	short		ImpLevel ) : named_node( NODE_FILE, pInputName )
	{

	fHasComClasses = FALSE;

	/**
	 ** save our file name and import level
	 **/

	ImportLevel		= ImpLevel;

	pActualFileName	= new char[ strlen( pInputName ) + 1 ];
	strcpy( pActualFileName, pInputName );

	/**
	 ** if the pass is the acf pass, then just set the symbol name to
	 ** be the input name, else munge it.
	 **/

	if( pCompiler->GetPassNumber() == IDL_PASS )
		{
		fAcfInclude = FALSE;
		SetFileName( pInputName );
		}
	else
		{
		fAcfInclude = TRUE;
		SetSymName( pInputName );
		}

	fIsXXXBaseIdl = FALSE;

	}

void
node_file::SetFileName(
	char	*	pFullName )
	{
	char		pDrive[ _MAX_DRIVE ],
				pPath[ _MAX_PATH ],
				pName[ _MAX_FNAME ],
				pExt[ _MAX_EXT ];
	short		lenDrive,
				lenPath,
				lenName,
				lenExt;
	char	*	pNewName;
	CMD_ARG	*	pCmd	= pCompiler->GetCommandProcessor();

	_splitpath( pFullName, pDrive, pPath, pName, pExt );

	if( (GetImportLevel() != 0 ) ||
		!pCmd->IsSwitchDefined( SWITCH_HEADER ) )
		{
		strcpy( pExt, ".h" );
		}
	else
		{
		pCmd->GetHeaderFileNameComponents( pDrive,pPath,pName,pExt);
		}

	lenDrive= (short) strlen( pDrive );
	lenPath	= (short) strlen( pPath );
	lenName	= (short) strlen( pName );
	lenExt	= (short) strlen( pExt );

	pNewName = new char [ lenDrive + lenPath + lenName + lenExt + 1 ];
	strcpy( pNewName, pDrive );
	strcat( pNewName, pPath );
	strcat( pNewName, pName );
	strcat( pNewName, pExt );

	SetSymName( pNewName );

	// insert the original name into the symbol table to be able to
	// access the filename later and get at the aux thru the symbol table

	SymKey	SKey( pFullName, NAME_FILE );

	pBaseSymTbl->SymInsert( SKey, (SymTable *)NULL, (named_node *)this );

	}
BOOL
node_file::AcfExists()
	{
	char		agBuf[ _MAX_DRIVE + _MAX_PATH + _MAX_FNAME + _MAX_EXT + 1];
	FILE	*	hFile;

	AcfName( agBuf );

	if ( agBuf[0] && ( hFile = fopen( agBuf, "r") ) != 0 )
		{
		fclose( hFile );
		return (BOOL)1;
		}
	return (BOOL)0;
	}

void
node_file::AcfName(
	char	*	pBuf )
	{
	char		agDrive[ _MAX_DRIVE ] ,
				agPath[ _MAX_PATH ],
				agName[ _MAX_FNAME ],
				agExt[ _MAX_EXT ];
	char		agLast[ _MAX_PATH];
	char	*	pPath;
	BOOL		fUserSpecifiedAcf;
	char	*	pTemp;


	// if this is the base idl file, then it can potentially have
	// an acf called differently. The imported file will have its acf
	// only derived from the idl files name.

	fUserSpecifiedAcf	= ( ( GetImportLevel() == 0 ) &&
							  pCommand->IsSwitchDefined( SWITCH_ACF ) );

	if( fUserSpecifiedAcf )
		pTemp	= pCommand->GetAcfFileName();
	else
		pTemp	= pActualFileName;

	strcpy( agLast, pTemp );

	//
	// we need to figure out the complete file name of the file we are searching
	// for.
	// If the user specified a file
	//	{
	//	if it did not have a path component
	// 		then we need to search in the path list that we derive from his
	//		-I and include env vsriable specification.
	//	else // (if he did have a path )
	//		we pick that file up from this path.
	//  }
	// else // (the user did not specify a file )
	//	{
	//	we derive the file name from he idl file name and add a .acf to it.
	//	}

	_splitpath( agLast, agDrive, agPath, agName, agExt );

	if( fUserSpecifiedAcf )
		{
		if( (agDrive[0] == '\0') && (agPath[0] == '\0') )
			{

			// no path was specified,

			pPath	= (char *)0;

			}
		else
			{
			// agLast has the whole thing...
			pPath	= "";
			}
		}
	else
		{

		// he did not specify an acf switch, so derive the filename and
		// the path. The basename is available, the extension in this case
		// is .acf

		pPath	= (char *)0;
		strcpy( agExt, ".acf" );

		}

	if( ! pPath )
		{
		strcpy( agLast, agName );
		strcat( agLast, agExt );

		pPath	= pImportCntrl->SearchForFile( agLast );

		}

	//
	// now we know all components of the full file name. Go ahead and
	// reconstruct the file name.
	//

	sprintf(pBuf, "%s%s", pPath, agLast);
	//_makepath( pBuf, agDrive, pPath, agName, agExt );

	}

/****************************************************************************
 						node_e_status_t procedures
 ****************************************************************************/
node_e_status_t::node_e_status_t() : named_node( NODE_E_STATUS_T, (char *) NULL )
	{
	node_skl	*	pC;
	char		*	pName;

	GetBaseTypeNode( &pC, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
 	// force name into lexeme table
 	pName = pMidlLexTable->LexInsert("error_status_t");	
	SetSymName( pName );
	SetChild( pC);
	}

/****************************************************************************
 						node_wchar_t procedures
 ****************************************************************************/
node_wchar_t::node_wchar_t() : named_node( NODE_WCHAR_T, (char *) NULL )
	{
	node_skl	*	pC;
	char		*	pName;

	GetBaseTypeNode( &pC, SIGN_UNSIGNED, SIZE_SHORT, TYPE_INT );
 	pName = pMidlLexTable->LexInsert("wchar_t");	
	SetSymName( pName );
	SetChild( pC);
	}

void
node_forward::GetSymDetails(
	NAME_T	*	pTag,
	char	**	ppName )
	{
	*pTag	= SKey.GetKind();
	*ppName	= SKey.GetString();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\pass2.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: pass2.cxx
Title				: pass2 controller
History				:
	24-Aug-1991	VibhasC	Created

*****************************************************************************/

#if 0
						Notes
						-----
This file provides the interface for the acf semantics pass. It also
initializes the pass2 controller object.

#endif // 0

#pragma warning ( disable : 4514 )

/****************************************************************************
 includes
 ****************************************************************************/

#include "nulldefs.h"
extern	"C"	{
	#include <string.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <malloc.h>
	extern int yyacfparse();
}

#include "allnodes.hxx"
#include "control.hxx"
#include "cmdana.hxx"
#include "filehndl.hxx"
#include "idict.hxx"

/****************************************************************************
	local definitions
 ****************************************************************************/

#define ACF_ATTR_COUNT	(ACF_ATTR_END - ACF_ATTR_START)
#define ACF_ATTR_MAX	(ACF_ATTR_COUNT - 1)

/****************************************************************************
	extern procedures
 ****************************************************************************/

extern void						initlex();
extern void						ParseError( STATUS_T, char * );

/****************************************************************************
	extern data 
 ****************************************************************************/

extern class ccontrol		*	pCompiler;
extern node_source			*	pSourceNode;
extern NFA_INFO				*	pImportCntrl;
extern CMD_ARG				*	pCommand;

/****************************************************************************
	local data
 ****************************************************************************/

/****************************************************************************/


_pass2::_pass2()
	{
	pCompiler->SetPassNumber( ACF_PASS );
	}

STATUS_T
_pass2::Go()
	{
	MEM_ITER			MemIter( pSourceNode );
	node_file		*	pFNode;
	node_file		*	pBaseFileNode = 0;
	char				Buffer[_MAX_DRIVE+_MAX_PATH+_MAX_FNAME+_MAX_EXT+1];
	STATUS_T			Status = STATUS_OK;

	/**
	 ** create a new import controller for the acf and
	 ** set the defaults needed
	 **/

	pImportCntrl	= pCompiler->SetImportController( new NFA_INFO );
	pImportCntrl->Init();

	/**
	 ** for each idl file, check if the corresponding acf exists.
	 ** if yes, process it.
	 **/


	while ( ( pFNode = (node_file *) MemIter.GetNext() ) != 0 )
		{
		pFileNode = pFNode;
		if(pFNode->GetImportLevel() == 0)
			pBaseFileNode = pFNode;

		if( pFNode->AcfExists() )
			{
			pFNode->AcfName( Buffer );

			if( !pImportCntrl->IsDuplicateInput( Buffer ) )
				{
				Status = pImportCntrl->SetNewInputFile( Buffer );
				char * pCopy	= new char[ strlen( Buffer) + 1];
				strcpy( pCopy, Buffer );
				AddFileToDB( pCopy );

				if( Status != STATUS_OK)
					break;

				pImportCntrl->ResetEOIFlag();

				initlex();


				if( yyacfparse()  || pCompiler->GetErrorCount() )
					{
					Status = SYNTAX_ERROR;
					break;
					}
				}
			}
		else if(pFNode->GetImportLevel() == 0)
			{

			// he could not find  the acf file. If the user did specify 
			// an acf switch then we must error out if we do not find
			// the acf.

			if( pCommand->IsSwitchDefined( SWITCH_ACF ) )
				{
				RpcError((char *)NULL,
						 0,
						 (Status = INPUT_OPEN) ,
						 pCommand->GetAcfFileName());
				break;
				}
			}

		// clean up
		pImportCntrl->EndOperations();

		} // end of outer while loop

	if( (Status == STATUS_OK) )
		{
		/**
	 	 ** The acf pass may have created include file nodes They must translate
	 	 ** into include statements in the generated stubs. We handle that by
	 	 ** merging the include file list with the members of the source node.
	 	 **/

		pSourceNode->MergeMembersToHead( AcfIncludeList );	

		}
	else
		{
		ParseError( ERRORS_PASS1_NO_PASS2, (char *)0 );
		}

	delete pImportCntrl;
	return Status;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\nodeskl.cxx ===
/*****************************************************************************/
/**                     Microsoft LAN Manager                               **/
/**             Copyright(c) Microsoft Corp., 1987-1999                     **/
/*****************************************************************************/
/*****************************************************************************
File                : nodeskl.cxx
Title               : skeletal node build routines
History             :
    04-Aug-1991 VibhasC Created

*****************************************************************************/

#pragma warning ( disable : 4514 )

/****************************************************************************
 local defines and includes
 ****************************************************************************/

#include "nulldefs.h"
extern  "C"
    {
    #include <stdio.h>
    
    #include <string.h>
    }

#include "allnodes.hxx"
#include "gramutil.hxx"
#include "cmdana.hxx"
#include "attrnode.hxx"
#include "ndrtypes.h"
#include "lextable.hxx"
#include "control.hxx"

inline
unsigned short ComputeAlignmentForZP( unsigned short Align, unsigned short ZeePee, BOOL IsMustAlign)
{
    return ((Align > ZeePee) && !IsMustAlign) ? ZeePee : Align;
}

inline
unsigned long RoundToAlignment( unsigned long Size, unsigned short Align)
{
    Align--;
    return (Size + Align) & ~Align; 
}

/****************************************************************************
 external data
 ****************************************************************************/

extern CMD_ARG                  *   pCommand;
extern node_e_attr              *   pErrorAttrNode;
extern node_error               *   pErrorTypeNode;
extern SymTable                 *   pBaseSymTbl;
extern IDICT                    *   pInterfaceDict;
extern ISTACK                   *   pZpStack;
extern LexTable                 *   pMidlLexTable;
extern CCONTROL                 *   pCompiler;

/****************************************************************************
 external procs
 ****************************************************************************/

extern BOOL                         IsTempName( char * );
extern void                         ParseError( STATUS_T, char * );
/****************************************************************************/


void
MEMLIST::SetMembers( class SIBLING_LIST & MEMLIST )
    {
    pMembers = MEMLIST.Linearize();
    }

void
MEMLIST::MergeMembersToTail( class SIBLING_LIST & MEMLIST )
    {
    AddLastMember( MEMLIST.Linearize() );
    }

STATUS_T
MEMLIST::GetMembers( class type_node_list * MEMLIST )
    {
    named_node      *   pCur     = pMembers;

    while ( pCur )
        {
        MEMLIST->SetPeer( pCur );
        pCur = pCur->GetSibling();
        }

    return (pMembers)? STATUS_OK: I_ERR_NO_MEMBER;
    };

short
MEMLIST::GetNumberOfArguments()
    {
    short           count   = 0;
    named_node  *   pNext   = pMembers;

    while ( pNext )
        {
        count++;
        pNext = pNext->GetSibling();
        };

    return count;
    };

// add a new member onto the very tail
void            
MEMLIST::AddLastMember( named_node * pNode )
{
    named_node  *   pPrev   = NULL;
    named_node  *   pCur    = pMembers;

    while ( pCur )
        {
        pPrev   = pCur;
        pCur    = pCur->GetSibling();
        }

    // pPrev is now null (empty list) or points to last element of list
    if ( pPrev )
        {
        pPrev->SetSibling( pNode );
        }
    else
        {
        pMembers = pNode;
        }

}


// Remove the last member from the tail
void            
MEMLIST::RemoveLastMember()
{
    named_node  *   pPrev   = NULL;
    named_node  *   pCur    = pMembers;

    while ( pCur && pCur->GetSibling() )
        {
        pPrev   = pCur;
        pCur    = pCur->GetSibling();
        }

    // pPrev is now null (empty list) or points to next to last element of list
    if ( pPrev )
        {
        pPrev->SetSibling( NULL);
        }

}

void            
MEMLIST::AddSecondMember( named_node * pNode )
{
    named_node* pFirst = (named_node*)GetFirstMember();

    if ( pFirst )
        {
        named_node* pSecond = pFirst->GetSibling();
        pFirst->SetSibling( pNode );
        pNode->SetSibling( pSecond );
        }
    else
        {
        pMembers = pNode;
        }

}

/****************************************************************************
 node_id:
    the private memory allocator
 ****************************************************************************/

// initialize the memory allocators for node_id and node_id_fe

FreeListMgr
node_id::MyFreeList( sizeof (node_id ) );

FreeListMgr
node_id_fe::MyFreeList( sizeof (node_id_fe ) );

FRONT_MEMORY_INFO
node_skl::AdjustMemoryInfoForModifiers(FRONT_MEMORY_INFO OrigInfo)
{
   if (!GetModifiers().IsModifierSet(ATTR_DECLSPEC_ALIGN))
       return OrigInfo;

   OrigInfo.IsMustAlign = TRUE;
   OrigInfo.Align = __max(OrigInfo.Align, GetModifiers().GetDeclspecAlign());

   return OrigInfo;
}

FRONT_MEMORY_INFO
node_skl::GetModifiedMemoryInfoFromChild()
{
    node_skl *pChild = GetChild();
    MIDL_ASSERT( pChild );
    return AdjustMemoryInfoForModifiers( pChild->GetMemoryInfo() );
}

FRONT_MEMORY_INFO
node_skl::GetInvalidMemoryInfo()
{
    return FRONT_MEMORY_INFO(0, 1, 0);
}

FRONT_MEMORY_INFO
node_enum::GetMemoryInfo()
{
    unsigned long EnumSize = pCommand->GetEnumSize();
    return AdjustMemoryInfoForModifiers( FRONT_MEMORY_INFO( EnumSize, (short)EnumSize, 0 ) ); 
}

FRONT_MEMORY_INFO 
node_pointer::GetMemoryInfo()
{
   unsigned long PointerSize = SIZEOF_MEM_PTR();
   return AdjustMemoryInfoForModifiers( FRONT_MEMORY_INFO( PointerSize, (short)PointerSize, 0 ) );
}

FRONT_MEMORY_INFO
node_safearray::GetMemoryInfo()
{
    unsigned long PointerSize = SIZEOF_MEM_PTR();
    return AdjustMemoryInfoForModifiers( FRONT_MEMORY_INFO( PointerSize, (short)PointerSize, 0 ) ); 
}

FRONT_MEMORY_INFO
node_union::GetMemoryInfo()
{

   // The size of a union is the size of the largest element rounded
   // to the largest alignment.   
    
   FRONT_MEMORY_INFO UnionSize(0, 1, 0);
   unsigned short    ZeePee = GetZeePee();
   MEM_ITER			 MemIter( this );
   node_skl       *  pNode;

   while ( ( pNode = MemIter.GetNext() ) != NULL )
   {
       FRONT_MEMORY_INFO TempSize = pNode->GetMemoryInfo();

       // Merge in the size of the new union arm.
       UnionSize.Size = __max(UnionSize.Size, TempSize.Size);
       UnionSize.Align = __max(UnionSize.Align, TempSize.Align);
       UnionSize.IsMustAlign = (UnionSize.IsMustAlign || TempSize.IsMustAlign);
   }

   // Add padding to end of union.
   UnionSize = AdjustMemoryInfoForModifiers(UnionSize);
   
   UnionSize.Align = ComputeAlignmentForZP( UnionSize.Align, ZeePee, UnionSize.IsMustAlign );
   UnionSize.Size = RoundToAlignment( UnionSize.Size, UnionSize.Align );

   return UnionSize;
}

FRONT_MEMORY_INFO
node_array::GetMemoryInfo()
{
    // The size of an array is the size of the array element times the element count.

    FRONT_MEMORY_INFO ArraySize = GetChild()->GetMemoryInfo();
    
    unsigned long ArrayElements;
    if ( pUpperBound && ( pUpperBound != (expr_node *) -1) )
        {

        ArrayElements = (ulong)pUpperBound->Evaluate();
        }
    else 
        {
        // A conformant array is not sized.
        ArrayElements = 0;
        }

    ArraySize.Size *= ArrayElements;

    return AdjustMemoryInfoForModifiers(ArraySize);
}


FRONT_MEMORY_INFO
node_struct::GetMemoryInfo()
{
    
    // The alignment of a structure is the largest alignment of all the members.
    // Each structure is aligned according to the following rules.
    // 1. If the field is a must align, the field is aligned to the Alignment.
    // 2. If the field is not a must align, the field is aligned to min(Zp, Alignment).


    MEM_ITER            MemIter( this );
    unsigned short ZeePee = GetZeePee();
    FRONT_MEMORY_INFO StructSize(0,1,0);
    node_skl          * pNode;

    while ( ( pNode = MemIter.GetNext() ) != 0 )
       {
       
       FRONT_MEMORY_INFO FieldSize = pNode->GetMemoryInfo();
       FieldSize.Align = ComputeAlignmentForZP( FieldSize.Align, ZeePee, FieldSize.IsMustAlign );

       StructSize.Size = RoundToAlignment( StructSize.Size, FieldSize.Align );

       // StructSize.Size now contains the offset of the field.
       
       // Merge in the attributes from the member
       StructSize.Size += FieldSize.Size;
       StructSize.Align = __max( FieldSize.Align, StructSize.Align );
       StructSize.IsMustAlign = ( StructSize.IsMustAlign || FieldSize.IsMustAlign );

       }

    // Add padding to end of structure.
    StructSize = AdjustMemoryInfoForModifiers( StructSize );

    StructSize.Align = ComputeAlignmentForZP( StructSize.Align, ZeePee, StructSize.IsMustAlign );
    StructSize.Size = RoundToAlignment( StructSize.Size, StructSize.Align );

    return StructSize;

}

FRONT_MEMORY_INFO
node_def::GetMemoryInfo()
{
  FRONT_MEMORY_INFO TypedefSize;
  node_represent_as *pRep = (node_represent_as *)GetAttribute(ATTR_REPRESENT_AS);
  node_user_marshal *pUserMarshall = (node_user_marshal *)GetAttribute(ATTR_USER_MARSHAL);
  node_cs_char      *pCSChar = (node_cs_char *) GetAttribute(ATTR_CSCHAR);

  if (!pUserMarshall && !pRep && !pCSChar)
      {
      // Just use the modified child sizes.
      return GetModifiedMemoryInfoFromChild();
      }

  if (pCSChar)
    {
    MIDL_ASSERT( NULL != pCSChar->GetUserType() );
    return AdjustMemoryInfoForModifiers( 
                        pCSChar->GetUserType()->GetMemoryInfo() );
    }

  // If both user_marshal and represent_as are specified, use represent_as and let semantic 
  // analysis flag the error.

  if (pUserMarshall)
      pRep = pUserMarshall;

  node_skl *pNode = pRep->GetRepresentationType();

  if (!pNode)
      {
          // unknown type. Use 0 as the size.
          TypedefSize.Init(0, 1, 0);
      }
  else 
      {
      TypedefSize = pNode->GetMemoryInfo();
      }

  return AdjustMemoryInfoForModifiers(TypedefSize);
}

FRONT_MEMORY_INFO
node_label::GetMemoryInfo()
{
    return AdjustMemoryInfoForModifiers( FRONT_MEMORY_INFO(sizeof(short), (short)sizeof(short), 0) ); 
}

FRONT_MEMORY_INFO
node_base_type::GetMemoryInfo()
{
    unsigned long size;

    switch( NodeKind() )
        {
        case NODE_FLOAT:    size = sizeof(float); break;
        case NODE_DOUBLE:   size = sizeof(double); break;
        case NODE_FLOAT80:  size = 16; break; //BUG, BUG double check once
                                              //VC supports this
        case NODE_FLOAT128: size = 16; break; 
        case NODE_HYPER:    size = sizeof(__int64); break;
        case NODE_INT64:    size = sizeof(__int64); break;
        case NODE_INT128:   size = 16; break;
        case NODE_INT3264:  size = SIZEOF_MEM_INT3264(); break;
        case NODE_INT32:    size = sizeof(long); break;
        case NODE_LONG:     size = sizeof(long); break;
        case NODE_LONGLONG: size = sizeof(LONGLONG); break;
        case NODE_SHORT:    size = sizeof(short); break;
        case NODE_INT:      size = sizeof(int); break;
        case NODE_SMALL:    size = sizeof(char); break;
        case NODE_CHAR:     size = sizeof(char); break;
        case NODE_BOOLEAN:  size = sizeof(char); break;
        case NODE_BYTE:     size = sizeof(char); break;
        case NODE_HANDLE_T: size = SIZEOF_MEM_PTR(); break;
        case NODE_VOID:     
             return AdjustMemoryInfoForModifiers(FRONT_MEMORY_INFO(0, 1, 0));
        default:
            size = 0;
            MIDL_ASSERT(0);
        }

    return AdjustMemoryInfoForModifiers(FRONT_MEMORY_INFO(size, (short)size, 0));
}

FRONT_MEMORY_INFO
node_href::GetMemoryInfo()
{
    node_skl *pChild = Resolve();
    MIDL_ASSERT(pChild);
    return AdjustMemoryInfoForModifiers(pChild->GetMemoryInfo());
}

/***************************************************************************
 GetBasicType:
    Get the basic type of the typenode
 ***************************************************************************/
node_skl *
node_skl::GetBasicType()
    {
    node_skl *  pChildPtr;

    switch( NodeKind() )
        {
        case NODE_STRUCT:
        case NODE_ENUM:
        case NODE_UNION:

            return this;

        case NODE_ID:

            return GetChild();

        default:
            if ( ( pChildPtr = GetChild() ) != 0 )
                {
                if ( pChildPtr->NodeKind() == NODE_DEF  ||  
                     pChildPtr->NodeKind() == NODE_FORWARD  || 
                     pChildPtr->NodeKind() == NODE_HREF )
                    return pChildPtr->GetBasicType();

                return pChildPtr;
                }
            return this;
        }
    }


/***************************************************************************
 GetMyInterfaceNode:
    Get the interface node for the typenode
 ***************************************************************************/
node_interface *
node_skl::GetMyInterfaceNode()
{
    return (node_interface *) pInterfaceDict->GetElement( IntfKey );
}


void
node_interface::ResetCGIfNecessary()
{
if ( !fIs2ndCodegen &&
     pCompiler->GetPassNumber() == NDR64_ILXLAT_PASS  )
     {
     fIs2ndCodegen = TRUE;
     SetCG(TRUE,NULL);
     SetCG(FALSE,NULL);
     }
}


node_file *
node_skl::GetDefiningFile()
{
    if (GetMyInterfaceNode())
        return GetMyInterfaceNode()->GetFileNode();
    else
        return NULL;
}

node_skl*
node_skl::GetDuplicateGuid  (
                            node_guid*  pGuid,
                            SymTable*   pUUIDTable
                            )
    {
    node_skl* pDuplicate = 0;

    if ( pGuid )
        {
        char * GuidStr = pGuid->GetGuidString();
        SymKey SKey(GuidStr, NAME_DEF);
        if ( !pUUIDTable->SymInsert( SKey, 0, (named_node*) this) )
            {
            pDuplicate = pUUIDTable->SymSearch( SKey );
            }
        }
    return ( pDuplicate == this ) ? 0 : pDuplicate;
    }

/*****************************************************************************
    utility functions
 *****************************************************************************/

BOOL
COMPARE_ATTR(
    ATTR_VECTOR &   A1,
    ATTR_VECTOR &   A2 )
    {
    int i;
    for( i = 0; i < MAX_ATTR_SUMMARY_ELEMENTS; ++i )
        {
        if( (A1[ i ] & A2[ i ] ) != A2[i] )
            return FALSE;
        }
    return TRUE;
    }

void
OR_ATTR(
    ATTR_VECTOR &   A1,
    ATTR_VECTOR &   A2 )
    {
    int i;
    for( i= 0; i < MAX_ATTR_SUMMARY_ELEMENTS; ++i )
        {
        A1[ i ] |= A2[ i ];
        }
    }
void
XOR_ATTR(
    ATTR_VECTOR &   A1,
    ATTR_VECTOR &   A2 )
    {
    int i;
    for( i= 0; i < MAX_ATTR_SUMMARY_ELEMENTS; ++i )
        {
        A1[ i ] ^= A2[ i ];
        }
    }
void
CLEAR_ATTR(
    ATTR_VECTOR &   A1 )
    {
    int i;
    for( i= 0; i < MAX_ATTR_SUMMARY_ELEMENTS; ++i )
        {
        A1[ i ] = 0;
        }
    }
void
SET_ALL_ATTR(
    ATTR_VECTOR &   A1 )
    {
    int i;
    for( i= 0; i < MAX_ATTR_SUMMARY_ELEMENTS; ++i )
        {
        A1[ i ] = 0xffffffff;
        }
    }


ATTR_T  
CLEAR_FIRST_SET_ATTR ( ATTR_VECTOR & A)
{
    int             i;
    unsigned long   mask;
    short           at;
            
    for ( i = 0; i < MAX_ATTR_SUMMARY_ELEMENTS; ++i )
        {
        for ( at = 0, mask = 1;
              mask != 0;
              ++at, mask = mask<<1 )
            {
            if ( mask & A[i] )
                {
                A[i] &= ~mask;
                return (ATTR_T) (at + ( i * 32 ));
                }
            }
        }
    return ATTR_NONE;
    
}

BOOL
node_base_type::IsUnsigned()
{

    // make obvious choices
    if ( FInSummary( ATTR_UNSIGNED ) ) 
        return TRUE;

    if ( FInSummary( ATTR_SIGNED ) )
        return FALSE;

    // unspec'd char is always unsigned
    if ( NodeKind() == NODE_CHAR )
        {
        return TRUE;
        }
    // unspec'd small is always signed
    else if ( NodeKind() == NODE_SMALL )
        {
        return FALSE;
        }

    // the cracks...
    return FALSE;
}

EXPR_VALUE
node_base_type::ConvertMyKindOfValueToEXPR_VALUE( EXPR_VALUE value )
{

    // make obvious choice
    if ( FInSummary( ATTR_UNSIGNED ) ) 
        return value;
    
    // small values are irrelevant
    if ( (value & 0xffffff80) == 0 )
        return value;

    // handle default signedness
    // simple type should be converted to int in expression evaluation.
    switch ( NodeKind() )
        {
        case NODE_CHAR:
            if ( !FInSummary( ATTR_SIGNED ) )
                return value;
            // fall through to sign extend
        case NODE_SMALL:
            {
            signed int     ch  = (signed int) value;
            return (EXPR_VALUE) ch;
            }
        case NODE_SHORT:
            {
            signed int    sh  = (signed int) value;
            return (EXPR_VALUE) sh;
            }
        case NODE_LONG:
        case NODE_INT32:
        case NODE_INT:
            {
            signed long     lng = (signed long) value;
            return (EXPR_VALUE) lng;
            }
        case NODE_INT3264:
            {
            if ( ! pCommand->Is64BitEnv() )
                {
                signed long     lng = (signed long) value;
                return (EXPR_VALUE) lng;
                }
            }
        }

    return value;
}

BOOL
named_node::IsNamedNode()
{
    return ( ( pName ) && !IsTempName( pName ) );
};

// return the transmit_as type (or NULL)
node_skl    *   
node_def::GetTransmittedType()
    {
    ta *        pXmit = (ta *) GetAttribute( ATTR_TRANSMIT );

/*
Rkk just in case
*/
    if ( !pXmit )
        pXmit = (ta *) GetAttribute( ATTR_WIRE_MARSHAL );

    // allow for transitive xmit_as
    if ( !pXmit && ( GetChild()->NodeKind() == NODE_DEF ) )
        return ((node_def*)GetChild())->GetTransmittedType();

    return (pXmit) ? pXmit->GetType() : NULL;
    }

// return the represent_as type (or NULL)
char        *   
node_def::GetRepresentationName()
    {
    node_represent_as   *   pRep    = 
                        (node_represent_as *) GetAttribute( ATTR_REPRESENT_AS );

    if ( !pRep )
        pRep = (node_represent_as *) GetAttribute( ATTR_USER_MARSHAL );

    return (pRep) ? pRep->GetRepresentationName() : NULL;
    }


    // link self on as new top node
void                    
node_pragma_pack::Push( node_pragma_pack *& pTop )
{
    pStackLink = pTop;
    pTop       = this;
}

    // search for matching push and pop it off, returning new ZP
unsigned short          
node_pragma_pack::Pop( node_pragma_pack *& pTop )
{
    unsigned short      result = 0;

    if ( pString )
        {
        while ( pTop->PackType != PRAGMA_PACK_GARBAGE )
            {
            if ( pTop->pString &&
                 !strcmp( pTop->pString, pString ) )
                {
                result = pTop->usPackingLevel;
                pTop = pTop->pStackLink;
                return result;
                }

            pTop = pTop->pStackLink;
            }
                 
        }
    else
        {
        if ( pTop->PackType != PRAGMA_PACK_GARBAGE )
            {
            result = pTop->usPackingLevel;
            pTop = pTop->pStackLink;
            }
        }

    return result;
}

// routines to save the pragma stack across files

class PRAGMA_FILE_STACK_ELEMENT
    {
public:
    node_pragma_pack *  pPackStack;
    unsigned short      SavedZp;

                        PRAGMA_FILE_STACK_ELEMENT( node_pragma_pack * pSt,
                                                   unsigned short  usZp )
                            {
                            pPackStack  = pSt;
                            SavedZp     = usZp;
                            }
    };


void                        
PushZpStack( node_pragma_pack * & PackStack, 
             unsigned short & CurrentZp )
{
    PRAGMA_FILE_STACK_ELEMENT   *   pSave   = new PRAGMA_FILE_STACK_ELEMENT (
                                                        PackStack, CurrentZp );
    
    pZpStack->Push( (IDICTELEMENT) pSave );
    
    // make new zp stack and start new file with command line Zp
    PackStack           = new node_pragma_pack( NULL,
                                                pCommand->GetZeePee(),
                                                PRAGMA_PACK_GARBAGE );
    CurrentZp   = pCommand->GetZeePee();
}

// restore the Zp stack and current Zp on returning from imported file
void                        
PopZpStack( node_pragma_pack * & PackStack, 
             unsigned short & CurrentZp )
{

    PRAGMA_FILE_STACK_ELEMENT   *   pSaved  = (PRAGMA_FILE_STACK_ELEMENT *)
                                                    pZpStack->Pop();

    PackStack = pSaved->pPackStack;
    CurrentZp = pSaved->SavedZp;

}

BOOL MODIFIER_SET::IsFlagAModifier(ATTR_T flag) const 
   {
   return (flag >= ATTR_CPORT_ATTRIBUTES_START && flag <= ATTR_CPORT_ATTRIBUTES_END);
   }

BOOL MODIFIER_SET::IsModifierSet(ATTR_T flag) const
   {
   return (BOOL)( ModifierBits & SetModifierBit( flag ) );
   }

BOOL MODIFIER_SET::AnyModifiersSet() const
   {
   return ModifierBits != 0; 
   }

void MODIFIER_SET::SetModifier(ATTR_T flag)
   {
   ModifierBits |= SetModifierBit( flag );
   }

void MODIFIER_SET::ClearModifier(ATTR_T flag)
   {
   unsigned _int64 ModifierMask = SetModifierBit( flag );
   ModifierBits &= ~ModifierMask;
   if (ATTR_DECLSPEC_ALIGN == flag)
       Align = 0;
   }

void MODIFIER_SET::SetDeclspecAlign( unsigned short NewAlign)
   {
   SetModifier( ATTR_DECLSPEC_ALIGN);
   Align = NewAlign; 
   }

unsigned short MODIFIER_SET::GetDeclspecAlign() const
   {
   if ( !IsModifierSet( ATTR_DECLSPEC_ALIGN ) )
       return 1;
   return Align;
   }

void MODIFIER_SET::SetDeclspecUnknown(char *pNewUnknownTxt)
   {
   pUnknownTxt = pMidlLexTable->LexInsert(pNewUnknownTxt);
   SetModifier( ATTR_DECLSPEC_UNKNOWN );
   return;
   } 
        
char *MODIFIER_SET::GetDeclspecUnknown() const
   {
   if ( !IsModifierSet( ATTR_DECLSPEC_UNKNOWN ) )
       return " ";
   return pUnknownTxt;
   }

void MODIFIER_SET::Clear()
   {
   ModifierBits = 0; Align = 0; pUnknownTxt = 0;
   }

void MODIFIER_SET::Merge(const MODIFIER_SET & MergeModifierSet)
   { 
   if ( MergeModifierSet.IsModifierSet( ATTR_DECLSPEC_ALIGN ) )
       {
	   if (! IsModifierSet( ATTR_DECLSPEC_ALIGN ) ) 
	       {
           Align = MergeModifierSet.Align;
	       }
       else 
           {
           Align = __max(MergeModifierSet.Align, Align);
           }
       }
   
   if (MergeModifierSet.pUnknownTxt)
       {
       if (!pUnknownTxt)
           {
           pUnknownTxt = MergeModifierSet.pUnknownTxt;
           }
       else 
           {
           size_t StrSize = strlen(MergeModifierSet.pUnknownTxt);
           StrSize += strlen(pUnknownTxt) + 1;
           char *pNewText = new char[StrSize];
           strcpy(pNewText, pUnknownTxt);
           strcat(pNewText, MergeModifierSet.pUnknownTxt);
           pUnknownTxt = pMidlLexTable->LexInsert(pNewText);
           delete[] pNewText;
           }
       
       }
   
   ModifierBits |= MergeModifierSet.ModifierBits;
   
   }

void MODIFIER_SET::PrintDebugInfo() const 
   {
   printf("Modifiers: 0x%I64X\n", ModifierBits);
   printf("Align: %u\n", Align);
   if (pUnknownTxt)
       {
       printf("UnknownTxt: %s\n", pUnknownTxt);
       }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\pass1.cxx ===
/*****************************************************************************/
/**                     Microsoft LAN Manager                               **/
/**             Copyright(c) Microsoft Corp., 1987-1999                     **/
/*****************************************************************************/
/*****************************************************************************
File                : pass1.cxx
Title               : pass1 controller
History             :
    05-Aug-1991 VibhasC Created

*****************************************************************************/

#if 0
                        Notes
                        -----
This file provides the entry point for the MIDL compiler front end.
It initializes the data structures for the front end , and makes the parsing
pass over the idl file. Does the semantics and second semantics passes if
needed.

#endif // 0

#pragma warning ( disable : 4514 )

/****************************************************************************
 includes
 ****************************************************************************/

#include "nulldefs.h"
extern  "C" {
    #include <stdio.h>
    #include <stdlib.h>
    #include <malloc.h>
    extern int yyparse();
}

#include "allnodes.hxx"
#include "control.hxx"
#include "gramutil.hxx"
#include "cmdana.hxx"
#include "filehndl.hxx"
#include "idict.hxx"
#include "treg.hxx"

/****************************************************************************
    extern procedures
 ****************************************************************************/

extern void                     SetUpAttributeMasks( void );
extern void                     SetPredefinedTypes();
extern void                     initlex();

/****************************************************************************
    extern data
 ****************************************************************************/

extern unsigned short           CurrentZp;
extern ATTR_SUMMARY             DisallowedAttrs[INTERNAL_NODE_END];
extern ATTR_SUMMARY             FieldAttrs;
extern TREGISTRY            *   pCallAsTable;
extern class ccontrol       *   pCompiler;
extern nsa                  *   pSymTblMgr;
extern SymTable             *   pBaseSymTbl;
extern SymTable             *   pCurSymTbl;
extern node_error           *   pErrorTypeNode;
extern IDICT                *   pFileDict;
extern IDICT                *   pInterfaceInfo;
extern node_pragma_pack     *   pPackStack;
extern pre_type_db          *   pPreAllocTypes;
extern node_source          *   pSourceNode;
extern NFA_INFO             *   pImportCntrl;
extern CMD_ARG              *   pCommand;
extern node_e_attr          *   pErrorAttrNode;
extern IINFODICT            *   pInterfaceInfoDict;
extern IDICT                *   pInterfaceDict;
extern SymTable             *   pUUIDTable;
extern ISTACK               *   pZpStack;
extern ATTR_SUMMARY             RedundantsOk;

/****************************************************************************
    local data
 ****************************************************************************/

/****************************************************************************/


/****************************************************************************
_pass1:
    The constructor.
 ****************************************************************************/
_pass1::_pass1()
    {
    pSymTblMgr      = new nsa;
    pBaseSymTbl     = pCurSymTbl = pSymTblMgr->GetCurrentSymbolTable();
    pUUIDTable      = new SymTable;
    pCallAsTable    = new TREGISTRY;
    pCompiler->SetPassNumber( IDL_PASS );

    }
/****************************************************************************
 Go:
    The execution of pass1
 ****************************************************************************/
STATUS_T
_pass1::Go()
    {
    STATUS_T    Status;

    /**
     ** set up the input file for each pass
     **/

    pImportCntrl    = pCompiler->SetImportController( new NFA_INFO );
    pImportCntrl->Init();

    pFileDict       = new IDICT( 8, 8 );
    AddFileToDB( "Dummy" );     // to get index to be non-zero

    Status = pImportCntrl->SetNewInputFile( pCommand->GetInputFileName() );
    AddFileToDB( pCommand->GetInputFileName() );

    if( Status == STATUS_OK )
        {

        /**
         ** set up for the 1st pass, allocate the semantics context manager
         ** and the pre-allocated types data base
         **/

        pPreAllocTypes      = new pre_type_db;
        pErrorTypeNode      = new node_error;
        pErrorAttrNode      = new node_e_attr;
        pInterfaceInfoDict  = new IINFODICT;
        pInterfaceInfoDict->StartNewInterface();
        pInterfaceDict      = new IDICT(8,8);
        pInterfaceDict->AddElement( NULL ); // so that 0 is a reserved value
        pPackStack          = new node_pragma_pack( NULL,
                                                    pCommand->GetZeePee(),
                                                    PRAGMA_PACK_GARBAGE );
        CurrentZp   = pCommand->GetZeePee();
        pZpStack            = new ISTACK( 10 );

        /**
         ** Set up the predefined types and bit attributes.
         **/

#ifdef gajdebug4
    printf("about to do predefined types...\n");
#endif
        SetPredefinedTypes();
#ifdef gajdebug4
    printf("\t\t\t...done\n");
#endif

        /**
         ** set up attribute masks, to indicate which node takes what attribute.
         ** also set up acf conflicts.
         **/

        SetUpAttributeMasks();

        /**
         ** go parse.
         **/

        initlex();

        if( yyparse() )
            Status = SYNTAX_ERROR;
        pInterfaceInfoDict->EndNewInterface();
        }

    delete pImportCntrl;


    return Status;
    }
/****************************************************************************
 SetUpAttributeMasks:
    This function exists to initialize the attribute masks. Attribute masks
    are nothing but summary attribute bit vectors, which have bits set up
    in them to indicate which attributes are acceptable at a node. The way
    the attribute distribution occurs, we need to indicate the attributes
    collected on the way down the chain and up the chain. That is why we need
    two attribute summary vectors. We init them up front so that we need not
    do this at run-time. This whole operation really is too large to my liking
    but for the time being, it stays

    NOTE: A pointer node handles its own attribute mask setting, it varies
          with the type graph underneath a pointer
 ****************************************************************************/
void
SetUpAttributeMasks( void )
    {
    MIDL_ASSERT(MAX_ATTR_SUMMARY_ELEMENTS == ((ACF_ATTR_END / 32) + 1));

    int i = 0;

    // RedundantsOk is the set of attributes we silently allow duplicates of
    // All other duplicates are redundant and need complaining about
    CLEAR_ATTR( RedundantsOk );
    SET_ATTR( RedundantsOk, ATTR_FIRST );
    SET_ATTR( RedundantsOk, ATTR_LAST );
    SET_ATTR( RedundantsOk, ATTR_LENGTH );
    SET_ATTR( RedundantsOk, ATTR_MIN );
    SET_ATTR( RedundantsOk, ATTR_MAX );
    SET_ATTR( RedundantsOk, ATTR_SIZE );
    SET_ATTR( RedundantsOk, ATTR_RANGE );
    SET_ATTR( RedundantsOk, ATTR_CASE );
    SET_ATTR( RedundantsOk, ATTR_FUNCDESCATTR );
    SET_ATTR( RedundantsOk, ATTR_IDLDESCATTR );
    SET_ATTR( RedundantsOk, ATTR_TYPEDESCATTR );
    SET_ATTR( RedundantsOk, ATTR_VARDESCATTR );
    SET_ATTR( RedundantsOk, ATTR_TYPE );
    SET_ATTR( RedundantsOk, ATTR_MEMBER );

    // FieldAttrs is the set of all field attributes
    CLEAR_ATTR( FieldAttrs );
    SET_ATTR( FieldAttrs, ATTR_FIRST );
    SET_ATTR( FieldAttrs, ATTR_LAST );
    SET_ATTR( FieldAttrs, ATTR_LENGTH );
    SET_ATTR( FieldAttrs, ATTR_MIN );
    SET_ATTR( FieldAttrs, ATTR_MAX );
    SET_ATTR( FieldAttrs, ATTR_SIZE );
    SET_ATTR( FieldAttrs, ATTR_STRING );
    SET_ATTR( FieldAttrs, ATTR_BSTRING );
    SET_ATTR( FieldAttrs, ATTR_IID_IS );


    // initialize the array of valid attributes to globally allow everything
    for ( i = 0; i < INTERNAL_NODE_END; i++ )
        CLEAR_ATTR( DisallowedAttrs[i] );

    // turn off bits for attributes allowed on arrays
    SET_ALL_ATTR( DisallowedAttrs[ NODE_ARRAY ] );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_FIRST );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_LAST );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_LENGTH );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_MIN );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_MAX );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_SIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_PTR_KIND );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_STRING );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_CONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_NOSERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_SERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_SWITCH_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_IID_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_SWITCH_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_BYTE_COUNT );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_V1_ENUM );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_ID );

    // turn off bits for attributes allowed on pointers
    SET_ALL_ATTR( DisallowedAttrs[ NODE_POINTER ] );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_FIRST );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_LAST );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_LENGTH );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_MIN );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_MAX );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_SIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_PTR_KIND );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_STRING );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_BSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_CONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_NOSERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_SERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_ALLOCATE );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_IGNORE );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_BYTE_COUNT );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_SWITCH_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_IID_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_COMMSTAT );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_FAULTSTAT );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_SWITCH_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_BYTE_COUNT );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_V1_ENUM );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_ID );

    // turn off bits for attributes allowed on interface
    SET_ALL_ATTR( DisallowedAttrs[ NODE_INTERFACE ] );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_PTR_KIND );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_VERSION );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_ENDPOINT );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_LOCAL );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_OBJECT );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_AUTO );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_IMPLICIT );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_EXPLICIT );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_CODE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_NOCODE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_PTRSIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_OPTIMIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_MS_UNION );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_MS_CONF_STRUCT );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_ENABLE_ALLOCATE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_ENCODE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_DECODE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_TYPE);
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_MEMBER);
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_TYPEDESCATTR);
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_DEFAULT );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_CUSTOM );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_ASYNC );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_ASYNCUUID );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_MESSAGE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_STRICT_CONTEXT_HANDLE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_CSTAGRTN );

    // turn off bits for attributes allowed on an object pipe interface
    SET_ALL_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ] );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_VERSION );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_OBJECT );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_IMPLICIT );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_EXPLICIT );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_CODE );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_NOCODE );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_OPTIMIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_RANGE );

    // turn off bits for attributes allowed on library
    SET_ALL_ATTR( DisallowedAttrs[ NODE_LIBRARY ] );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_VERSION );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_HELPFILE );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_HELPSTRINGDLL );
    // MATTR_RESTRICTED is grouped under ATTR_MEMBER so allow ATTR_MEMBER
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_MEMBER );
    // TATTR_CONTROL is grouped under ATTR_TYPE so allow ATTR_TYPE
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_LCID);
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_CUSTOM );

    // turn off bits for attributes allowed on module
    SET_ALL_ATTR( DisallowedAttrs[ NODE_MODULE ] );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_VERSION );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_MEMBER );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_DLLNAME );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_CUSTOM );

    // turn off bits for attributes allowed on dispinterface
    SET_ALL_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ] );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_VERSION );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_MEMBER );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_CUSTOM );
    
    // turn off bits for attributes allowed on coclass
    SET_ALL_ATTR( DisallowedAttrs[ NODE_COCLASS ] );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_VERSION );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_MEMBER );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_CUSTOM );
    
    // turn off bits for attributes allowed on enumeration labels
    SET_ALL_ATTR( DisallowedAttrs[ NODE_LABEL ] );                                    
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_VERSION );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_MEMBER );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_IDLDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_VARDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_ID );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_CUSTOM );

    // turn off bits for attributes allowed on proc (and return)
    SET_ALL_ATTR( DisallowedAttrs[ NODE_PROC ] );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_PTR_KIND );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_LOCAL );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_CODE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_NOCODE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_PTRSIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_OPTIMIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_MS_UNION );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_HANDLE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_CONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_NOSERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_SERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_IDEMPOTENT );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_BROADCAST );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_MAYBE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_ASYNC );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_MESSAGE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_INPUTSYNC );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_CALLBACK );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_COMMSTAT );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_FAULTSTAT );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_NOTIFY );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_NOTIFY_FLAG );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_ENABLE_ALLOCATE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_EXPLICIT );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_STRING );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_SWITCH_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_BYTE_COUNT );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_V1_ENUM );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_ENCODE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_DECODE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_CALL_AS );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_ID );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_MEMBER );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_ENTRY );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_VARDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_FUNCDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_IDLDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_CUSTOM );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_CSTAGRTN );

    // turn off bits for attributes allowed on typedef
    SET_ALL_ATTR( DisallowedAttrs[ NODE_DEF ] );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_PTR_KIND );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_TRANSMIT );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_WIRE_MARSHAL );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_HANDLE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_REPRESENT_AS );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_USER_MARSHAL );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_CONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_ALLOCATE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_HEAP );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_STRING );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_BSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_FIRST );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_LAST );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_LENGTH );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_MIN );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_MAX );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_SIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_RANGE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_SWITCH_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_MS_UNION );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_COMMSTAT );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_FAULTSTAT );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_BYTE_COUNT );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_SWITCH_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_V1_ENUM );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_IID_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_ENCODE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_DECODE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_ID );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_MEMBER );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_TYPEDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_VERSION );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_CUSTOM );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_NOSERIALIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_SERIALIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_CSCHAR );

    // turn off bits for attributes allowed on param
    SET_ALL_ATTR( DisallowedAttrs[ NODE_PARAM ] );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_PTR_KIND );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_IN );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_OUT );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_PARTIAL_IGNORE );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_COMMSTAT );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_FAULTSTAT );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_HEAP );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_CONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_NOSERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_SERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_HANDLE );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_BYTE_COUNT );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_SWITCH_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_IID_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_CASE );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_FIRST );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_LAST );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_LENGTH );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_MIN );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_MAX );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_SIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_RANGE );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_STRING );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_ALLOCATE );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_BYTE_COUNT );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_SWITCH_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_V1_ENUM );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_MEMBER );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_IDLDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_VARDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_FLCID );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_DEFAULTVALUE );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_CUSTOM );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_DRTAG );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_RTAG );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_STAG );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_FORCEALLOCATE );

    // turn off bits for attributes allowed on field
    SET_ALL_ATTR( DisallowedAttrs[ NODE_FIELD ] );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_PTR_KIND );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_SWITCH_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_IID_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_CASE );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_DEFAULT );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_FIRST );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_LAST );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_LENGTH );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_MIN );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_MAX );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_SIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_RANGE );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_STRING );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_CONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_NOSERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_SERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_ALLOCATE );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_IGNORE );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_BYTE_COUNT );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_SWITCH_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_V1_ENUM );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_ID );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_MEMBER );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_IDLDESCATTR);
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_VARDESCATTR);
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_CUSTOM);

    // turn off bits for attributes allowed on structs
    SET_ALL_ATTR( DisallowedAttrs[ NODE_STRUCT ] );
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_CONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_NOSERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_SERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_TYPEDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_CUSTOM );
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_MEMBER );

    // turn off bits for attributes allowed on unions
    SET_ALL_ATTR( DisallowedAttrs[ NODE_UNION ] );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_CONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_NOSERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_SERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_SWITCH_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_SWITCH_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_MS_UNION );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_TYPEDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_CUSTOM );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\prttype.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    prttype.cxx

Abstract:

    This module collects implementations of DoPrintType and DoPrintDecl
    virtual methods for various classes derived from node_skl.

Author:

    Greg Jensenworth

Revision History:


--*/

#if defined(DBG)
#if DBG == 1
// Switch front end size comments on.
#define gajsize
#endif
#endif

#pragma warning ( disable : 4514 4706 4710 )

#include "nulldefs.h"
extern "C" {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>

}

#include "allnodes.hxx"
#include "cmdana.hxx"
#include "prttype.hxx"
#include "buffer.hxx"


extern CMD_ARG *                pCommand;
extern node_source *    pSourceNode;

#ifdef gaj_debug_prt
#define midl_debug(str) printf("%s", str);
#else
#define midl_debug(str)
#endif

#ifdef _SPITGENSEQ_
#define DUMP_DEBUG_INFO( infotext )                                           \
    printf( infotext " %20s, %16X\n", GetSymName(), Flags);                   \
    GetModifiers().PrintDebugInfo();                                          \

#else
#define DUMP_DEBUG_INFO( infotext )                                           \
    Flags;                                                                    \

#endif

extern  BOOL                    IsTempName( char *);
extern  char *                  GetOperatorString( OPERATOR );
extern  node_skl*               GetNonDefType   ( node_skl*  pType );

////////////////////////////////////////////////////////
// local variables

enum STRING_COMPONENT {
        CHAR_BLANK,
        CHAR_TAB,
        CHAR_COMMA,
        CHAR_EQUAL,
        CHAR_LBRACK,
        CHAR_RBRACK,
        CHAR_LPAREN,
        CHAR_RPAREN,
        CHAR_SEMICOLON,
        OP_DEREF,
        OP_ADDRESS,
        OP_MEMBER,
        OP_POINTER,
        WORD_STRUCT,
        WORD_UNION,
        WORD_ENUM,
        WORD_VOID,
        RETURN_VALUE,
        WORD_SIGNED,
        WORD_UNSIGNED,
        UHYPER_PREFIX,
        WORD_COLON_COLON,
        WORD_W64,
        LAST_COMPONENT
} ;


const char * STRING_TABLE[LAST_COMPONENT+1] =
        {
        " ",
        "\t",
        ", ",
        "= ",
        "[ ",
        " ]",
        "( ",
        " )",
        ";",
        "*",
        "&",
        ".",
        "->",
        "struct ",
        "union ",
        "enum ",
        "void ",
        "_ret_value ",
        "signed ",
        "unsigned ",
        "MIDL_u",
        "::",
        "__w64",
        "--filler--"
        } ;

void
node_skl::EmitModelModifiers( BufferManager * pBuffer)
{
/*
REVIEW: We should probably just get rid of these and maybe some of the
        others also

        if (GetModifiers().IsModifierSet(ATTR_FAR))
                pBuffer->ConcatHead("__far ");
        if (GetModifiers().IsModifierSet(ATTR_NEAR))
                pBuffer->ConcatHead("__near ");
        if (GetModifiers().IsModifierSet(ATTR_HUGE))
                pBuffer->ConcatHead("__huge ");
*/
        if (GetModifiers().IsModifierSet(ATTR_SEGMENT))
                pBuffer->ConcatHead("__segment ");
        if (GetModifiers().IsModifierSet(ATTR_SELF))
                pBuffer->ConcatHead("__self ");
        if (GetModifiers().IsModifierSet(ATTR_BASE))
                pBuffer->ConcatHead("__based ");
        if (GetModifiers().IsModifierSet(ATTR_MSCUNALIGNED))
                pBuffer->ConcatHead("__unaligned ");

};


void
node_skl::EmitModifiers( BufferManager * pBuffer, bool fSuppressConst )
{
        if (GetModifiers().IsModifierSet(ATTR_VOLATILE))
                pBuffer->ConcatHead("volatile ");
        if (GetModifiers().IsModifierSet(ATTR_CONST) && !fSuppressConst )
                pBuffer->ConcatHead("const ");
        if (GetModifiers().IsModifierSet(ATTR_DLLIMPORT))
                pBuffer->ConcatHead("__MIDL_DECLSPEC_DLLIMPORT ");
        if (GetModifiers().IsModifierSet(ATTR_DLLEXPORT))
                pBuffer->ConcatHead("__MIDL_DECLSPEC_DLLEXPORT ");
        if (GetModifiers().IsModifierSet(ATTR_DECLSPEC_ALIGN)) 
            {
            char *Chars = new char[256];
            unsigned long Alignment = GetModifiers().GetDeclspecAlign();
            sprintf(Chars, "__declspec(align(%d)) ", Alignment);
            pBuffer->ConcatHead(Chars);
            }
        if (GetModifiers().IsModifierSet(ATTR_DECLSPEC_UNKNOWN))
            {
            pBuffer->ConcatHead(GetModifiers().GetDeclspecUnknown());
            }

};

void node_skl::EmitPtrModifiers( BufferManager* pBuffer, unsigned long )
{
    if ( GetModifiers().IsModifierSet( ATTR_PTR32 ) )
        {
        pBuffer->ConcatHead("__ptr32 ");
        }
    else if ( GetModifiers().IsModifierSet( ATTR_PTR64 ) )
        {
        pBuffer->ConcatHead("__ptr64 ");
        }
}

void
node_skl::EmitProcModifiers( BufferManager * pBuffer, PRTFLAGS Flags)
{
        ATTR_T          CallConv;

        ( (node_proc *) this)->GetCallingConvention( CallConv );

        switch ( CallConv )
                {
                case ATTR_PASCAL:
                        pBuffer->ConcatHead("__pascal ");
                        break;
                case ATTR_FORTRAN:
                        pBuffer->ConcatHead("__fortran ");
                        break;
                case ATTR_CDECL:
                        pBuffer->ConcatHead("__cdecl ");
                        break;
                case ATTR_FASTCALL:
                        pBuffer->ConcatHead("__fastcall ");
                        break;
                case ATTR_STDCALL:
                        pBuffer->ConcatHead("__stdcall ");
                        break;
                default:
                        if ( Flags & PRT_FORCE_CALL_CONV )
                                {
                                // tbd - allow command line switch for default
                                pBuffer->ConcatHead("STDMETHODCALLTYPE ");
                                }
                }

        if (GetModifiers().IsModifierSet(ATTR_LOADDS))
                pBuffer->ConcatHead("__loadds ");
        if (GetModifiers().IsModifierSet(ATTR_SAVEREGS))
                pBuffer->ConcatHead("__saveregs ");
        if (GetModifiers().IsModifierSet(ATTR_INTERRUPT))
                pBuffer->ConcatHead("__interrupt ");
        if (GetModifiers().IsModifierSet(ATTR_EXPORT))
                pBuffer->ConcatHead("__export ");
        if (GetModifiers().IsModifierSet(ATTR_C_INLINE))
                pBuffer->ConcatHead("__inline ");

};

void
node_skl::PrintMemoryInfo( ISTREAM *pStream, BOOL bNewLine )
{
#if defined(DBG) && (DBG==1)
    char NumBuf[40];
    memset(NumBuf, 0, sizeof(NumBuf));
    FRONT_MEMORY_INFO MemInfo = GetMemoryInfo();
                        

    pStream->Write("/* size is ");
    _snprintf(NumBuf, 39, "%u", MemInfo.Size); 
    pStream->Write(NumBuf);
    pStream->Write(", align is ");
    _snprintf(NumBuf, 39, "%u", (unsigned long)MemInfo.Align);
    pStream->Write(NumBuf);
    if (MemInfo.IsMustAlign)
        {
        pStream->Write(", must align ");
        }
    pStream->Write("*/");
    if (bNewLine)
        pStream->Write("\n");
#else
    pStream; bNewLine;
#endif
    return;
}

void 
node_echo_string::PrintMemoryInfo( ISTREAM *pStream, BOOL bNewLine )
{
    // do nothing;
    pStream; bNewLine;
    return;
}

inline void
named_node::DumpAttributes( ISTREAM * pStream )
        {
        if (AttrList)
                {
                pStream->Write("/* ");
                AttrList.Dump( pStream );
                pStream->Write(" */ ");
                }
        };

STATUS_T
node_base_type::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       pParent,
        node_skl        *       )
/*++

Routine Description:

    This routine prints definition for a node of base type. 

Arguments:

    Parent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
        DUMP_DEBUG_INFO( "node_base_type::DoPrintType" );

        char *                  pName;
        NODE_T                  Type;
        unsigned short  Option;

        midl_debug ("node_base_type::DoPrintType\n");

        pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);

        Type = NodeKind();

        Option = pCommand->GetCharOption ();

        if ( pParent &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)  )
                {
                pParent->EmitModelModifiers (pBuffer);
                }

        switch (Type)
                {
                case NODE_BOOLEAN :
                    {
                        if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
                            {
                            pBuffer->ConcatHead(CHAR_BLANK);
                            pBuffer->ConcatHead("VARIANT_BOOL");
                            if (FInSummary(ATTR_UNSIGNED))
                                {
                                pBuffer->ConcatHead (WORD_UNSIGNED);
                                }
                            else if (FInSummary(ATTR_SIGNED))
                                {
                                pBuffer->ConcatHead (WORD_SIGNED);
                                }
                            break;
                            }
                    // deliberately fall through        
                    }
                case NODE_DOUBLE :
                case NODE_FLOAT :
                case NODE_FLOAT80 : 
                case NODE_FLOAT128 :
                case NODE_INT64 :
                case NODE_INT128:
                case NODE_LONGLONG :
                case NODE_INT3264 :
                case NODE_INT32 :
                case NODE_LONG :
                case NODE_SHORT :
                case NODE_BYTE :
                case NODE_INT :
                case NODE_HANDLE_T :
                case NODE_VOID :
                        pBuffer->ConcatHead (CHAR_BLANK);
                        pBuffer->ConcatHead (pName);
                        if (FInSummary(ATTR_UNSIGNED))
                                {
                                pBuffer->ConcatHead (WORD_UNSIGNED);
                                }
                        else if (FInSummary(ATTR_SIGNED))
                                {
                                pBuffer->ConcatHead (WORD_SIGNED);
                                }
                        if (FInSummary(ATTR_W64))
                                {
                                pBuffer->ConcatHead (CHAR_BLANK);
                                pBuffer->ConcatHead (WORD_W64);
                                }
                        break;
                case NODE_HYPER :
                        pBuffer->ConcatHead (CHAR_BLANK);
                        pBuffer->ConcatHead (pName);
                        if (FInSummary(ATTR_UNSIGNED))
                                {
                                pBuffer->ConcatHead (UHYPER_PREFIX);
                                }
                        break;
                case NODE_CHAR :
                        pBuffer->ConcatHead (CHAR_BLANK);
                        pBuffer->ConcatHead (pName);
                        if (FInSummary(ATTR_UNSIGNED))
                                {
                                pBuffer->ConcatHead (WORD_UNSIGNED);
                                }
                        else if (FInSummary(ATTR_SIGNED))
                                {
                                pBuffer->ConcatHead (WORD_SIGNED);
                                }
                        else if (Option == CHAR_SIGNED)
                                {
                                pBuffer->ConcatHead (WORD_UNSIGNED);
                                }
                        break;
                case NODE_SMALL :
                        pBuffer->ConcatHead (CHAR_BLANK);
                        pBuffer->ConcatHead (pName);
                        if (FInSummary(ATTR_UNSIGNED))
                                {
                                pBuffer->ConcatHead (WORD_UNSIGNED);
                                }
                        else if (FInSummary(ATTR_SIGNED))
                                {
                                pBuffer->ConcatHead (WORD_SIGNED);
                                }
                        else if (Option == CHAR_UNSIGNED)
                                {
                                pBuffer->ConcatHead (WORD_SIGNED);
                                }
                        break;
                default :
                        return I_ERR_INVALID_NODE_TYPE;
                }

        if (pParent)
                {
                pParent->EmitModifiers (pBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
                }
        return STATUS_OK;
}

STATUS_T
node_base_type::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints declaration for a node of base type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_base_type::DoPrintDecl" );

        return DoPrintType( Flags, pBuffer, pStream, pParent, pIntf );
}

STATUS_T
node_e_status_t::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       pParent,
        node_skl        *       )
/*++

Routine Description:

    This routine prints definition for a node of error_status_t type.

Arguments:

    pParent - Supplies type of the parent node to pass to the child node.

    pBuffer - Supplies a buffer to pass to the child node.

--*/
{
        DUMP_DEBUG_INFO( "node_e_status_t::DoPrintType" );

        char     *              pName;

        midl_debug ("node_e_status_t::DoPrintType\n");

        pName = GetSymName();

        MIDL_ASSERT (pName != (char *)0);

        if ( pParent  &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0))
                {
                pParent->EmitModelModifiers (pBuffer);
                }

        pBuffer->ConcatHead(CHAR_BLANK);
        pBuffer->ConcatHead(pName);

        if (pParent)
                {
                pParent->EmitModifiers (pBuffer, false );
                }

        return STATUS_OK;
}

STATUS_T
node_e_status_t::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints declaration for a node of error_status_t type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

   DUMP_DEBUG_INFO( "node_e_status_t::DoPrintDecl" ); 

   return DoPrintType( Flags, pBuffer, pStream, pParent, pIntf );
}

STATUS_T
node_wchar_t::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       pParent,
        node_skl        *       )
/*++

Routine Description:

    This routine prints definition for a node of wchar_t type.

Arguments:

    pParent - Supplies type of the parent node to pass to the child node.

    pBuffer - Supplies a buffer to pass to the child node.

--*/
{

        DUMP_DEBUG_INFO( "node_wchar_t::DoPrintType" );

        char    *               pName;

        midl_debug ("node_wchar_t::DoPrintType\n");
        pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);

        if ( pParent  &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0))
                {
                pParent->EmitModelModifiers (pBuffer);
                }

        pBuffer->ConcatHead(CHAR_BLANK);
        pBuffer->ConcatHead(pName);

        if (pParent)
                {
                pParent->EmitModifiers (pBuffer, false);
                }

        return STATUS_OK;
}

STATUS_T
node_wchar_t::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints declaration for a node of wchar_t type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
        DUMP_DEBUG_INFO( "node_wchar_t::DoPrintDecl" );

        return DoPrintType( Flags, pBuffer, pStream, pParent, pIntf );
}

STATUS_T
node_def::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints definition for a node of typedef.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_def::DoPrintType" );

        node_skl *              pNode;
        char *                  pName;
        NODE_T                  Type;
        STATUS_T                Status;

        midl_debug ("node_def::DoPrintType\n");
        pNode = GetChild();
        pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);
        Type = pNode->NodeKind();

        if( !IsTempName( pName ) )
            {
            pStream->Write ("typedef ");

            DumpAttributes( pStream );

            pStream->Write( GetDeclSpecGuid() );

            pBuffer->Clear ();
            if (pParent)
                {
                pParent->EmitModifiers (pBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
                }

            pBuffer->Print(pStream);

            pBuffer->Clear ();
            pBuffer->ConcatHead (pName);
            }

        // the type specification is no longer at the top level
        Flags &= ~PRT_TRAILING_SEMI;
        if ( !IsDef() )
            {
            Status = pNode->DoPrintDecl (Flags, pBuffer, pStream, this, pIntf);
            }
        else
            {
            Status = pNode->DoPrintType (Flags, pBuffer, pStream, this, pIntf);
            }

        pBuffer->Print(pStream);
        pStream->Write (';');
        pStream->NewLine();

        return Status;
}

STATUS_T
node_def::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       pParent,
        node_skl        *       )
/*++

Routine Description:

    This routine prints declaration for a node of typedef.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
 
        DUMP_DEBUG_INFO( "node_def::DoPrintDecl" );

        char                            *       pName;
        node_represent_as       *       pRep;

        midl_debug ("node_def::DoPrintDecl\n");

        pName = GetSymName();

        node_cs_char *pCSChar = (node_cs_char *) GetAttribute( ATTR_CSCHAR );

        if ( pCSChar )
            pName = pCSChar->GetUserTypeName();

        MIDL_ASSERT (pName != (char *)0);

        if (pParent )
            {
            if ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)
                    pParent->EmitModelModifiers (pBuffer);
            else
                    Flags &= ~PRT_SUPPRESS_MODEL;
            }

        pBuffer->ConcatHead(CHAR_BLANK);
        pRep = (node_represent_as *)GetAttribute( ATTR_REPRESENT_AS );
        if ( pRep )
                pName = pRep->GetRepresentationName();
    else
        {
        // Same thing for user_marshal (this is mut. exclusive with rep as)

        pRep = (node_represent_as *)GetAttribute( ATTR_USER_MARSHAL );
            if ( pRep )
                pName = pRep->GetRepresentationName();
        }

    char*       szNameToPrint = pName;
    node_skl*   pChild = GetChild();
    if ( pChild && pChild->NodeKind() == NODE_PIPE && Flags & PRT_ASYNC_DEFINITION )
        {
        szNameToPrint = new char[strlen(pName) + strlen(SZ_ASYNCPIPEDEFPREFIX) + 1];
        strcpy( szNameToPrint, SZ_ASYNCPIPEDEFPREFIX );
        strcat( szNameToPrint, pName );
        }

    pBuffer->ConcatHead(szNameToPrint);

    if (pParent)
            {
            pParent->EmitModifiers (pBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
            }

    return STATUS_OK;
}

STATUS_T
node_array::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints declaration for a node of array type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_array::DoPrintDecl" );

        node_skl *      pNode;
        STATUS_T        Status;
        NODE_T          Parent  = (pParent)? pParent->NodeKind() : NODE_SOURCE;

        midl_debug ("node_array::DoPrintDecl\n");

        pNode = GetChild ();

        if (pParent )
                {
                if ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)
                        pParent->EmitModelModifiers (pBuffer);
                else
                        Flags &= ~PRT_SUPPRESS_MODEL;
                }

        if (Parent == NODE_POINTER)
                {
                pBuffer->ConcatHead (CHAR_LPAREN);
                pBuffer->ConcatTail (CHAR_RPAREN);
                }

        pBuffer->ConcatTail (CHAR_LBRACK);
        if ( (pUpperBound) && (pUpperBound != (expr_node *) -1 ) )
            {
            char    *pNumBuf        = new char[16];

            pBuffer->ConcatTail (MIDL_ITOA( (ulong) pUpperBound->GetValue(), 
                                            pNumBuf, 
                                            10));
            }
        else
            {
            if ( Parent == NODE_FIELD || Parent == NODE_ARRAY
                || ( ( Flags & PRT_ARRAY_SIZE_ONE ) != 0 ) )
                {
                // conformant struct
                pBuffer->ConcatTail( "1" );
                }
            }
        pBuffer->ConcatTail (CHAR_RBRACK);

        if (pParent)
                {
                pParent->EmitModifiers (pBuffer, false);
                }

        // the type specification is no longer at the top level
        Flags &= ~PRT_TRAILING_SEMI;
        if ( ! IsDef() )
                {
                Status = pNode->DoPrintDecl (Flags, pBuffer, pStream, this, pIntf);
                }
        else
                {
                Status = pNode->DoPrintType (Flags, pBuffer, pStream, this, pIntf);
                }

        return Status;
}

STATUS_T
node_array::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints definition for a node of array type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_array::DoPrintType" );

        midl_debug ("node_array::DoPrintType\n");

        return DoPrintDecl (Flags, pBuffer, pStream, pParent, pIntf);
}

STATUS_T
node_pointer::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints declaration for a node of pointer type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_pointer::DoPrintDecl" );

        node_skl *      pNode;
        STATUS_T        Status;

        midl_debug ("node_pointer::DoPrintDecl\n");

        pNode = GetChild ();

        if (pParent )
            {
            if ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)
                {
                pParent->EmitModelModifiers (pBuffer);
                }
            else
                {
                Flags &= ~PRT_SUPPRESS_MODEL;
                }

            pParent->EmitModifiers (pBuffer, ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 );
            }

        EmitPtrModifiers( pBuffer );
        pBuffer->ConcatHead (OP_DEREF);

        // the type specification is no longer at the top level
        Flags &= ~PRT_TRAILING_SEMI;
        if ( ! IsDef() )
            {
            Status = pNode->DoPrintDecl (Flags, pBuffer, pStream, this, pIntf);
            }
        else
            {
            Status = pNode->DoPrintType (Flags, pBuffer, pStream, this, pIntf);
            }

        return Status;
}

STATUS_T
node_pointer::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints definition for a node of pointer type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_pointer::DoPrintType" );
        midl_debug ("node_pointer::DoPrintType\n");

        return DoPrintDecl (Flags, pBuffer, pStream, pParent, pIntf);
}

STATUS_T
node_param::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints declaration for a node of param type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

    DUMP_DEBUG_INFO( "node_param::DoPrintType" );

    node_skl *      pNode;
    char *          pName;
    STATUS_T        Status;
    BOOL            fAddSemi        = Flags & PRT_TRAILING_SEMI;
	node_constant_attr *	pAttr;

    midl_debug ("node_param::DoPrintType\n");

    pNode = GetChild ();
    pName = GetSymName ();
    MIDL_ASSERT (pName != (char *)0);

    pBuffer->Clear ();
    pBuffer->ConcatHead (pName);
    if (!strcmp(pName, "void")) return STATUS_OK;
    if (!strcmp(pName, "..."))
        {
        pStream->NewLine();
        pBuffer->Print( pStream );
        return STATUS_OK;
        }

    pStream->NewLine();

    DumpAttributes( pStream );

    // the type specification is no longer at the top level
    Flags &= ~PRT_TRAILING_SEMI;
    Status = pNode->DoPrintDecl (Flags, pBuffer, pStream, this, pIntf);

    pBuffer->Print(pStream);

    /* we want to force printing defaultvalue of BSTR to be wchar. scenarios:
          defaultvalue("value"); 
          defaultvalue(L"value"); 
          defaultvalue(0); 
          defaultvalue(NULL); 
          defaultvalue(VALUE); BSTR VALUE=L"value". 
          We can do nothing about char * VALUE = "value"

    */
    if ( (Flags & PRT_CPP_PROTOTYPE) && 
         HasGenDefaultValueExpr() &&
         (pAttr = (node_constant_attr *) GetAttribute( ATTR_DEFAULTVALUE ) ) )
        {
        expr_node   *pExpr = pAttr->GetExpr();
    	
        pStream->Write(" = ");

        if ( pNode->NodeKind() == NODE_DEF && !strcmp( pNode->GetSymName(), "BSTR" ) )
            {
            NODE_T Kind = ( pExpr->GetType()) ? (NODE_T) pExpr->GetType()->NodeKind()
                                              : (NODE_T) NODE_ILLEGAL;

            if ( pExpr->GetValue() != 0 && (Kind != NODE_ILLEGAL ) )
                {                
                // node_named_constant can only be NODE_ID or NODE_LABEL
                // only constant expr is allowed here, so this must be node_constant
                if  ( !(Kind == NODE_ID || Kind == NODE_LABEL  ) )
                    {
                    if ( ((expr_constant *)pExpr)->GetFormat() != VALUE_TYPE_WSTRING )
                        pStream->Write("L");
                    }
                pExpr->Print(pStream);
                }
            else
                {
		        pStream->Write("0");
                }
            }
        else
            {
                pExpr->Print(pStream);
            }
        }

    if ( fAddSemi )
        {
        pStream->Write (';');
        pStream->NewLine();
        };

    return Status;
}

STATUS_T
node_param::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       pParent,
        node_skl        *       )
/*++

Routine Description:

    This routine emits the parameter as a local variable in callee stub.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_param::DoPrintDecl" );

        char                            *       pName;

        midl_debug ("node_param::DoPrintDecl\n");
        pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);
        if (pParent )
                {
                if ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)
                        pParent->EmitModelModifiers (pBuffer);
                else
                        Flags &= ~PRT_SUPPRESS_MODEL;
                }

        pBuffer->ConcatHead(CHAR_BLANK);
        pBuffer->ConcatHead(pName);

        if (pParent)
                {
                pParent->EmitModifiers (pBuffer, false);
                }

        return STATUS_OK;
}

STATUS_T
node_proc::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints procedure declaration.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

    DUMP_DEBUG_INFO( "node_proc::DoPrintDecl" );

    MEM_ITER	MemIter( this );
    node_skl *  pNode;
    char *      pName   = GetSymName();
    char    *   pPrefix;
    NODE_T      Parent  = (pParent)? pParent->NodeKind() : NODE_ID;
    BOOL        fHasParameter = FALSE;
    PRTFLAGS    ChildFlags = Flags & ~(PRT_CALL_AS |
                                       PRT_THIS_POINTER |
                                       PRT_TRAILING_SEMI |
                                       PRT_CSTUB_PREFIX |
                                       PRT_SSTUB_PREFIX |
                                       PRT_SWITCH_PREFIX |
                                       PRT_QUALIFIED_NAME );

    midl_debug ("node_proc::DoPrintDecl\n");

    //
    // If PRT_OMIT_CS_TAG_PARAMS is on but we don't have a tag routine
    // the turn it back off
    //
    if ( Flags & PRT_OMIT_CS_TAG_PARAMS && NULL == GetCSTagRoutine() )
        {
        Flags &= ~PRT_OMIT_CS_TAG_PARAMS;
        }

    if ( (Flags & PRT_CALL_AS) == PRT_CALL_AS )
        {
        node_call_as            *       pAttr;
        node_skl                        *       pCallType;
        if ( pAttr = (node_call_as *) GetAttribute( ATTR_CALL_AS ) )
            {
            if ( pCallType = pAttr->GetCallAsType() )
                {
                return pCallType->DoPrintDecl(Flags, pBuffer, pStream, pParent, pIntf);
                }
            else
                {
                MIDL_ASSERT( 0 );
                }
            }
        }

    MIDL_ASSERT (pName != (char *)0);

    DumpAttributes( pStream );

    pNode = GetReturnType();

#ifdef gajdebug5
printf("\t parent type is %d, NODE_INTERFACE is %d\n", Parent, NODE_INTERFACE);
#endif

    if (pParent)
            {
            pParent->EmitModifiers (pBuffer, false);
            }

    if ( !pNode )
            {
            EmitModifiers( pBuffer, false );
            }

    if ( pParent )
            {
            pParent->EmitProcModifiers( pBuffer, Flags & ~PRT_FORCE_CALL_CONV );
            }

    EmitProcModifiers( pBuffer, Flags );

    // append the class name + :: to the proc name
    if ( Flags & PRT_QUALIFIED_NAME )
            {
            char    *               pIntfName;
            if ( pIntf )
                    pIntfName = pIntf->GetSymName();
            else
                    pIntfName = GetMyInterfaceNode()->GetSymName();

            pBuffer->ConcatTail( pIntfName );
            pBuffer->ConcatTail( WORD_COLON_COLON );
            }

    // append the client or server or switch prefix
    if ( (Parent == NODE_ID) ||
         (Parent == NODE_INTERFACE) ||
         (Parent == NODE_MODULE ) ||
         (Parent == NODE_COCLASS ) )
        {
        if( (Flags & PRT_CSTUB_PREFIX) == PRT_CSTUB_PREFIX )
                {
                if( (pPrefix = pCommand->GetUserPrefix( PREFIX_CLIENT_STUB )) )
                        {
                        pBuffer->ConcatTail( pPrefix );
                        }
                }
        else if( (Flags & PRT_SSTUB_PREFIX) == PRT_SSTUB_PREFIX )
                {
                if( (pPrefix = pCommand->GetUserPrefix( PREFIX_SERVER_MGR )) )
                        {
                        pBuffer->ConcatTail( pPrefix );
                        }
                }
        else if( (Flags & PRT_SWITCH_PREFIX) == PRT_SWITCH_PREFIX )
                {
                if( (pPrefix = pCommand->GetUserPrefix( PREFIX_SWICH_PROTOTYPE )) )
                        {
                        pBuffer->ConcatTail( pPrefix );
                        }
                }
        pBuffer->ConcatTail (pName);
        }
    else if (Parent != NODE_DEF)
        {
        ChildFlags |= PRT_SUPPRESS_MODEL;       // turn off __far's
        pBuffer->ConcatHead (CHAR_LPAREN);
        pBuffer->ConcatTail (CHAR_RPAREN);
        }

    // the type specification is no longer at the top level
    if (pNode)
        {
        if ( HasAsyncHandle() )
            {
            if ( pNode->GetBasicType()->NodeKind() == NODE_E_STATUS_T ||
                 ( !strcmp( pNode->GetSymName(), "HRESULT" ) && IsObjectProc() ) )
                {
                pNode->DoPrintDecl (ChildFlags, pBuffer, pStream, this, pIntf);
                }
            else
                {
                pBuffer->ConcatHead (CHAR_BLANK);
                pBuffer->ConcatHead ("void ");
                }
            }
        else
            {
            pNode->DoPrintDecl (ChildFlags, pBuffer, pStream, this, pIntf);
            }
        }
    pBuffer->ConcatTail (CHAR_LPAREN);

    ChildFlags &= ~PRT_SUPPRESS_MODEL;      // turn __far's back on
    pBuffer->Print(pStream );
    pStream->IndentInc();

    pBuffer->Clear ();

    if ( Flags & PRT_THIS_POINTER )
            {
            char    *               pIntfName;
            if ( pIntf )
                    pIntfName = pIntf->GetSymName();
            else
                    pIntfName = GetMyInterfaceNode()->GetSymName();

            pStream->NewLine();
            pStream->Write( pIntfName );
            pStream->Write( " * This" );
            fHasParameter = TRUE;
            }

    if ( HasAsyncHandle() )
        {
        ChildFlags |= PRT_ASYNC_DEFINITION;
        }

    // Emit the parameters
    while ( pNode = MemIter.GetNext() )
            {
            MIDL_ASSERT( NODE_PARAM == pNode->NodeKind() );

            node_param *pParam = ( node_param * ) pNode;

            if ( pParam->HasCSTag() && ( Flags & PRT_OMIT_CS_TAG_PARAMS ) )
                {
                continue;
                }   

            if( fHasParameter == TRUE )
                    {
                    //If this is not the first parameter, then print a ",".
                    pStream->Write (',');
                    }
            pBuffer->Clear ();
            pParam->DoPrintType (ChildFlags, pBuffer, pStream, this, pIntf);
            fHasParameter = TRUE;
            }
#ifdef _SPITGENSEQ_
printf("\n");
#endif

    if(fHasParameter == FALSE)
            {
            //If there are no parameters, then print void.
            pStream->Write("void");
            }
    pStream->Write (')');

    pBuffer->Clear ();
    pStream->IndentDec();

    return STATUS_OK;
}

STATUS_T
node_proc::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints procedure definition.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_proc::DoPrintType" );

        char *                                  pName;

        midl_debug ("node_proc::DoPrintType\n");

        pName = GetSymName();

        MIDL_ASSERT (pName != (char *)0);

    //.. If a local proc, just emit the prototype to the *.h file.

        // pBuffer->Clear ();
        DoPrintDecl (Flags, pBuffer, pStream, pParent, pIntf);
        pBuffer->Print(pStream);

        if (Flags & PRT_TRAILING_SEMI)
                {
                pStream->Write (';');
                pStream->NewLine();
                };
        return STATUS_OK;

}

STATUS_T
node_label::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * ,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine prints an enum label and its value.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
    
        DUMP_DEBUG_INFO( "node_label::DoPrintType" );

        midl_debug ("node_label::DoPrintType\n");

        char* pName = GetSymName();

        MIDL_ASSERT (pName != (char *)0);

        pStream->Write('\t');
        pStream->Write( pName );
        if (pExpr)
                {
                pStream->Write("\t= ");
                pExpr->Print( pStream );
                };

        return STATUS_OK;
}

STATUS_T
node_enum::DoPrintDecl(
    PRTFLAGS                Flags,
    BufferManager * pBuffer,
    ISTREAM           *,
    node_skl        *       pParent,
    node_skl        * )
/*++

Routine Description:

    This routine prints an enum declaration.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_enum::DoPrintDecl" );

        char *          pName;

        midl_debug ("node_enum::DoPrintDecl\n");

        pName = GetSymName();

        MIDL_ASSERT (pName != (char *)0);

        if ( pParent &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)  )
                {
                pParent->EmitModelModifiers (pBuffer);
                }

        pBuffer->ConcatHead (CHAR_BLANK);
        pBuffer->ConcatHead (pName);
        pBuffer->ConcatHead (WORD_ENUM);

        if (pParent)
                {
                pParent->EmitModifiers (pBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
                }

        return STATUS_OK;
}

STATUS_T
node_enum::DoPrintType(
     PRTFLAGS                Flags,
     BufferManager * ,
     ISTREAM           * pStream,
     node_skl        *       pParent,
     node_skl        *       pIntf)

/*++

Routine Description:

    This routine prints an enum definition.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_enum::DoPrintType" );

        MEM_ITER                MemIter( this );
        node_skl *              pNode;
        char *                  pName;
        BufferManager   TempBuffer(8, LAST_COMPONENT, STRING_TABLE);
        PRTFLAGS                ChildFlags              = Flags & ~PRT_TRAILING_SEMI;

        midl_debug ("node_enum::DoPrintType\n");
        pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);
        DumpAttributes( pStream );
        TempBuffer.Clear ();
        TempBuffer.ConcatHead (pName);
        TempBuffer.ConcatHead (GetDeclSpecGuid());
        TempBuffer.ConcatHead (WORD_ENUM);

        // Print the modifiers on the enum since the enum has no child that can print them.
        EmitModifiers (&TempBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );

        if (pParent)
                {
                pParent->EmitModifiers (&TempBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
                }

        pStream->NewLine();
        TempBuffer.Print(pStream);

        pStream->IndentInc();
        pStream->NewLine();
        pStream->Write('{');

        if ( pNode = MemIter.GetNext() )
                {
                TempBuffer.Clear ();
                pNode->DoPrintType (ChildFlags, &TempBuffer, pStream, this, pIntf);
                while ( pNode = MemIter.GetNext() )
                        {
                        pStream->Write (",\n");
                        TempBuffer.Clear ();
                        pNode->DoPrintType (ChildFlags, &TempBuffer, pStream, this, pIntf);
                        }
                }

        pStream->NewLine();
        pStream->Write('}');
        pStream->IndentDec();

        TempBuffer.Clear();
        if ( pParent &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)  )
                {
                pParent->EmitModelModifiers (&TempBuffer);
                TempBuffer.ConcatHead(CHAR_BLANK);                
                }

        TempBuffer.Print( pStream );

        if (Flags & PRT_TRAILING_SEMI)
                pStream->Write (';');
        else
                pStream->Write ('\t');

        return STATUS_OK;
}

STATUS_T
node_field::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints definition for a node of field type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_field::DoPrintType" );

        node_skl *      pNode;
        char *          pName;
        STATUS_T        Status;
        char            NumBuf[16];

        midl_debug ("node_field::DoPrintType\n");

        pNode = GetChild ();

        pName = GetSymName ();

        MIDL_ASSERT (pName != (char *)0);

        if( IsTempName( pName ) && !( Flags & PRT_ALL_NAMES) )
                pName = "";

        pStream->NewLine();

        DumpAttributes( pStream );

        if (IsEmptyArm())
                {
                pStream->Write(" /* Empty union arm */ ");
                return STATUS_OK;
                }

        pBuffer->Clear ();

        pBuffer->ConcatHead (pName);

        // the type specification is no longer at the top level
        Flags &= ~PRT_TRAILING_SEMI;
        if ( ! IsDef() )
                {
                Status = pNode->DoPrintDecl (Flags, pBuffer, pStream, this, pIntf);
                }
        else
                {
                Status = pNode->DoPrintType (Flags, pBuffer, pStream, this, pIntf);
                }

        if (IsBitField())
                {
                pBuffer->ConcatTail ("\t: ");
                // safe to have buffer on stack, since we print below
                pBuffer->ConcatTail (MIDL_ITOA(GetFieldSize(), NumBuf, 10));
                }
        pBuffer->ConcatTail (CHAR_SEMICOLON);
        pBuffer->Print(pStream);

        return Status;
}

STATUS_T
node_union::DoPrintDecl(
        PRTFLAGS        Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        * pParent,
        node_skl        *       )
/*++

Routine Description:

    This routine prints a union declaration.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_union::DoPrintDecl" );

        midl_debug ("node_union::DoPrintDecl\n");

        char*  pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);

        if ( pParent &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)  )
                {
                pParent->EmitModelModifiers (pBuffer);
                }

        pBuffer->ConcatHead (CHAR_BLANK);
        pBuffer->ConcatHead (pName);
        pBuffer->ConcatHead (WORD_UNION);

        if (pParent)
                {
                pParent->EmitModifiers (pBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
                }

        return STATUS_OK;
}

STATUS_T
node_union::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * ,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints a union definition.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
 
        DUMP_DEBUG_INFO( "node_union::DoPrintType" );

        MEM_ITER                MemIter( this );
        node_skl *              pNode;
        char *                  pName;
        BufferManager   TempBuffer(8, LAST_COMPONENT, STRING_TABLE);
        NODE_T                  Parent  = (pParent)? pParent->NodeKind() : NODE_INTERFACE;
        BOOL                    AddPragmas;
        unsigned short  zp;
        char                    NumBuf[4];
        PRTFLAGS                ChildFlags      = Flags & ~PRT_TRAILING_SEMI;

        midl_debug ("node_union::DoPrintType\n");
        pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);
        DumpAttributes( pStream );
        zp      = GetZeePee();
        AddPragmas = ( zp != pCommand->GetZeePee() )
                                 && (Parent != NODE_FIELD )
                                 && !(Flags & PRT_OMIT_PRAGMA_PACK);

        TempBuffer.Clear ();
        if ( ( ( Flags & PRT_INSIDE_OF_STRUCT ) != PRT_INSIDE_OF_STRUCT)  ||
                 !IsTempName( pName ) || IsEncapsulatedUnion())
            {
            TempBuffer.ConcatHead (pName);
            TempBuffer.ConcatHead (GetDeclSpecGuid());
            }

        TempBuffer.ConcatHead (WORD_UNION);

        // Print the modifiers on the union since the union has no child that can
        // print them.
        EmitModifiers (&TempBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) ); 

        if (pParent)
                {
                pParent->EmitModifiers (&TempBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
                }

        if ( AddPragmas )
                {
                TempBuffer.ConcatHead (")\n");
                TempBuffer.ConcatHead (MIDL_ITOA(zp, NumBuf, 10));
                TempBuffer.ConcatHead ("\n#pragma pack (");
                };

        TempBuffer.Print( pStream );

        pStream->IndentInc();
        pStream->NewLine();
        pStream->Write('{');
        while ( pNode = MemIter.GetNext() )
                {
                TempBuffer.Clear ();
                
                pNode->DoPrintType (ChildFlags, &TempBuffer, pStream, this, pIntf);}
        pStream->NewLine();
        pStream->Write('}');
        pStream->IndentDec();

        TempBuffer.Clear();
        if ( pParent &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)  )
                {
                pParent->EmitModelModifiers (&TempBuffer);
                TempBuffer.ConcatHead(CHAR_BLANK);                
                }

        TempBuffer.Print( pStream );

        if ( AddPragmas )
                {
                pStream->Write ("\n#pragma pack ()\n");
                };

        if (Flags & PRT_TRAILING_SEMI)
                pStream->Write (';');
        else
                pStream->Write ('\t');

        return STATUS_OK;
}

STATUS_T
node_struct::DoPrintDecl(
        PRTFLAGS        Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        * pParent      ,
        node_skl        *       )
/*++

Routine Description:

    This routine prints a struct declaration.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_struct::DoPrintDecl" );

        midl_debug ("node_struct::DoPrintDecl\n");

        char* pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);

        if ( pParent &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)  )
                {
                pParent->EmitModelModifiers (pBuffer);
                }

        pBuffer->ConcatHead (CHAR_BLANK);
        pBuffer->ConcatHead (pName);
        pBuffer->ConcatHead (WORD_STRUCT);

        if (pParent)
                {
                pParent->EmitModifiers (pBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
                }

        return STATUS_OK;
}

STATUS_T
node_struct::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * ,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints a struct definition.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_struct::DoPrintType" );

        MEM_ITER                MemIter( this );
        node_skl *              pNode;
        char *                  pName = GetSymName();
        BufferManager   TempBuffer(8, LAST_COMPONENT, STRING_TABLE);
        NODE_T                  Parent  = (pParent)? pParent->NodeKind() : NODE_INTERFACE;
        char                    NumBuf[4];
        BOOL                    AddPragmas;
        unsigned short  zp;
        PRTFLAGS                ChildFlags      = ( Flags & ~PRT_TRAILING_SEMI)
                                                  | PRT_INSIDE_OF_STRUCT;

        midl_debug ("node_struct::DoPrintType\n");
        MIDL_ASSERT (pName != (char *)0);
        DumpAttributes( pStream );
        zp      = GetZeePee();
        AddPragmas = ( zp != pCommand->GetZeePee() )
                                 && (Parent != NODE_FIELD )
                                 && !(Flags & PRT_OMIT_PRAGMA_PACK);

        TempBuffer.Clear ();
        if ( ( ( Flags & PRT_INSIDE_OF_STRUCT ) != PRT_INSIDE_OF_STRUCT)  ||
                 !IsTempName( pName ) )
            {
            TempBuffer.ConcatHead (pName);
            TempBuffer.ConcatHead (GetDeclSpecGuid());
            }
        TempBuffer.ConcatHead (WORD_STRUCT);

        // Print the modifiers on the struct since the struct
        // has no child that can print them.
        EmitModifiers (&TempBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );

        if (pParent)
                {
                pParent->EmitModifiers (&TempBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
                }

        if ( AddPragmas )
                {
                TempBuffer.ConcatHead (")\n");
                TempBuffer.ConcatHead (MIDL_ITOA(zp, NumBuf, 10));
                TempBuffer.ConcatHead ("\n#pragma pack (");
                };


        TempBuffer.Print( pStream );

        pStream->IndentInc();
        pStream->NewLine();
        pStream->Write('{');

        while ( pNode = MemIter.GetNext() )
                {
                TempBuffer.Clear ();
                pNode->DoPrintType (ChildFlags, &TempBuffer, pStream, this, pIntf);
                pNode->PrintMemoryInfo( pStream, FALSE );
                }
        pStream->NewLine();
        pStream->Write('}');
        pStream->IndentDec();

        TempBuffer.Clear();
        if ( pParent &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)  )
                {
                pParent->EmitModelModifiers (&TempBuffer);
                TempBuffer.ConcatHead(CHAR_BLANK);
                }

        TempBuffer.Print( pStream );

        if ( AddPragmas )
                {
                pStream->Write ("\n#pragma pack ()\n");
                };

        if (Flags & PRT_TRAILING_SEMI)
                pStream->Write (';');
        else
                pStream->Write ('\t');

        return STATUS_OK;
}



STATUS_T
node_id::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints an identifier and its initializer.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
        DUMP_DEBUG_INFO( "node_id::DoPrintType" );

        node_skl *      pNode;
        char *          pName;
        STATUS_T        Status;
        BOOL            fDummyDecl;
        PRTFLAGS                ChildFlags      = Flags & ~PRT_TRAILING_SEMI;

        midl_debug ("node_id::DoPrintType\n");
        DumpAttributes( pStream );
        pNode = GetChild ();
        pName = GetSymName ();
        MIDL_ASSERT (pName != (char *)0);
        fDummyDecl      = IsTempName( pName );
        pBuffer->Clear ();

        // convert const <type> <id> = <expr> to:
        //                 #define <id> <expr>
        if (!fDummyDecl && pInit )
                {
                if ( (Flags & PRT_CONVERT_CONSTS) &&
                         ( FInSummary( ATTR_CONST ) || IsConstantString() )     )
                        {
                        //expr_cast             CastExpr( pNode, pInit );

                        pStream->Write ( "#define\t" );
                        pStream->Write ( pName );
                        pStream->Write ( '\t' );

                        // print "( <expr> )
                        pStream->Write ( "( ");
                        pInit->Print( pStream );
                        pStream->Write ( " )");

                        pStream->NewLine ();
                        return STATUS_OK;
                        }
                }

        // id which is NOT a constant declaration
        if( !fDummyDecl || ( Flags & PRT_ALL_NAMES) )
                {
                if (pParent )
                        {
                        if ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)
                                pParent->EmitModelModifiers (pBuffer);
                        else
                                Flags &= ~PRT_SUPPRESS_MODEL;
                        }

                pBuffer->ConcatHead (pName);
                }

        if (pParent)
                {
                pParent->EmitModifiers ( pBuffer, false );
                }

        // emit storage class
        if (GetModifiers().IsModifierSet(ATTR_EXTERN))                 pStream->Write("extern ");
        if (GetModifiers().IsModifierSet(ATTR_STATIC))                 pStream->Write("static ");
        if (GetModifiers().IsModifierSet(ATTR_AUTOMATIC))              pStream->Write("auto ");
        if (GetModifiers().IsModifierSet(ATTR_REGISTER))               pStream->Write("register ");

        if ( ! IsDef() )
                {
                Status = pNode->DoPrintDecl (ChildFlags, pBuffer, pStream, this, pIntf);
                }
        else
                {
                Status = pNode->DoPrintType (ChildFlags, pBuffer, pStream, this, pIntf);
                }

        pBuffer->Print(pStream);

        pBuffer->Clear ();
        pBuffer->Print(pStream);

        // if there is an initializer, print it...  #defines came out above and returned
        if ( pInit )
                {
                pStream->Write ( "\t=\t" );
                pInit->Print( pStream );
                }

        pStream->Write (';');
        pStream->NewLine();

        return Status;
}

STATUS_T
node_id::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       pParent,
        node_skl        *       )
/*++

Routine Description:

    This routine prints declaration for an id node.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_id::DoPrintDecl" );

        midl_debug ("node_id::DoPrintDecl\n");

        char* pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);

        if (pParent )
                {
                if ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)
                        pParent->EmitModelModifiers (pBuffer);
                else
                        Flags &= ~PRT_SUPPRESS_MODEL;
                }

        pBuffer->ConcatHead(CHAR_BLANK);
        pBuffer->ConcatHead(pName);

        if (pParent)
                {
                pParent->EmitModifiers ( pBuffer, false );
                }

        return STATUS_OK;
}


STATUS_T
node_echo_string::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * ,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine reproduces a string into the output header file.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_echo_string::DoPrintType" );

        midl_debug ("node_echo_string::DoPrintType\n");

        PrintSelf( pStream );
        pStream->NewLine();
        return STATUS_OK;
}

void
node_echo_string::PrintSelf( ISTREAM * pStream )
{
        pStream->Write (GetEchoString());
}

void
node_pragma_pack::PrintSelf( ISTREAM * pStream )
{
        char    NumBuf[10];

        pStream->Write( "\n#pragma pack(" );
        switch ( PackType )
                {
                case PRAGMA_PACK_PUSH:
                        pStream->Write( "push" );
                        if ( pString )
                                {
                                pStream->Write (", ");
                                pStream->Write (pString);
                                }
                        if ( usNewLevel )
                                {
                                pStream->Write (", ");
                                pStream->Write(MIDL_ITOA(usNewLevel, NumBuf, 10));
                                }
                        break;
                case PRAGMA_PACK_POP:
                        pStream->Write( "pop" );
                        if ( pString )
                                {
                                pStream->Write (", ");
                                pStream->Write (pString);
                                }
                        break;
                case PRAGMA_PACK_SET:
                        pStream->Write(MIDL_ITOA(usNewLevel, NumBuf, 10));
                        break;
                case PRAGMA_PACK_RESET:
                        break;
                }
        pStream->Write(')' );
}

STATUS_T
PrintMultiple(
        node_proc *             pNode,
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints all the prototype flavors for a proc.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
        PRTFLAGS        ChildFlags;

        char    *       pCPrefix        = pCommand->GetUserPrefix( PREFIX_CLIENT_STUB );
        char    *       pSPrefix        = pCommand->GetUserPrefix( PREFIX_SERVER_MGR );
        char    *       pSwPrefix       = pCommand->GetUserPrefix( PREFIX_SWICH_PROTOTYPE );

        if ( !pCPrefix ) pCPrefix = "";
        if ( !pSPrefix ) pSPrefix = "";
        if ( !pSwPrefix ) pSwPrefix = "";

        BOOL            fCeqS           = !(BOOL) strcmp( pCPrefix, pSPrefix );
        BOOL            fSeqSw          = !(BOOL) strcmp( pSPrefix, pSwPrefix );
        BOOL            fCeqSw          = !(BOOL) strcmp( pCPrefix, pSwPrefix );

        // print both client and server flavors of proc
        if ( fCeqS )
                pStream->Write("/* client and server prototype */");
        else
                pStream->Write("/* client prototype */");
        pStream->NewLine();
        ChildFlags = ( Flags & ~PRT_BOTH_PREFIX ) | PRT_CSTUB_PREFIX;
        pNode->DoPrintType (ChildFlags, pBuffer, pStream, pParent, pIntf );

        if ( !fCeqS )
                {
                pStream->Write("/* server prototype */");
                pStream->NewLine();
                ChildFlags = ( Flags & ~PRT_BOTH_PREFIX ) | PRT_SSTUB_PREFIX;
                pNode->DoPrintType (ChildFlags, pBuffer, pStream, pParent, pIntf );
                }

        if ( !( fSeqSw || fCeqSw ) )
                {
                pStream->Write("/* switch prototype */");
                pStream->NewLine();
                ChildFlags = ( Flags & ~PRT_BOTH_PREFIX ) | PRT_SWITCH_PREFIX;
                pNode->DoPrintType (ChildFlags, pBuffer, pStream, pParent, pIntf );
                }

        return STATUS_OK;
}

STATUS_T
node_interface::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine walks the type graph under an interface node to emit code.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_interface::DoPrintType" );

        MEM_ITER                MemIter( this );
        node_skl *              pNode;
        NODE_T                  ChildKind;
        char *                  pName;
        short                   Option;
        // unsigned short       zp;
        PRTFLAGS                ChildFlags;
        BOOL                    fPrtBoth        = FALSE;

        midl_debug ("node_interface::DoPrintType\n");
        pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);

        Option = pCommand->GetErrorOption ();


        ///////////////////////////////////////////////////
        // prefix determination
        // turn off prefix stuff if we don't want the stubs
        // see which flags are really needed
        if ( ( ( Flags & PRT_BOTH_PREFIX ) == PRT_BOTH_PREFIX ) &&
                 pCommand->IsPrefixDifferentForStubs() )
                fPrtBoth = TRUE;

        ChildFlags      = Flags | PRT_OMIT_PRAGMA_PACK;

        pStream->Write("/* interface ");
        pStream->Write(pName);
        pStream->Write(" */");
        pStream->NewLine();
        DumpAttributes( pStream );
        pStream->NewLine(2);

        while ( pNode = MemIter.GetNext() )
                {
                ChildKind = pNode->NodeKind();

                // skip procs.
                if ( ( Flags & PRT_OMIT_PROTOTYPE ) &&
                         ( ChildKind == NODE_PROC ) )
                        continue;

                pBuffer->Clear ();

                pNode->PrintMemoryInfo( pStream, TRUE );

                // print the type
                if ( fPrtBoth &&
                         (pNode->NodeKind()==NODE_PROC) )
                        {
                        PrintMultiple( (node_proc *)pNode, ChildFlags, pBuffer, pStream, this, this );
                        }
                else
                        pNode->DoPrintType (ChildFlags, pBuffer, pStream, this, this );

                if ( ChildKind != NODE_ECHO_STRING )
                        pStream->NewLine();

                }
        return STATUS_OK;
}

STATUS_T
node_interface_reference::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       pParent,
        node_skl        *       )
/*++

Routine Description:

    This routine emits an interface name.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
  
        DUMP_DEBUG_INFO( "node_interface_reference::DoPrintDecl" );

        midl_debug ("node_interface_reference::DoPrintDecl\n");

        char *pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);

        if (pParent )
                {
                if ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)
                        pParent->EmitModelModifiers (pBuffer);
                else
                        Flags &= ~PRT_SUPPRESS_MODEL;
                }

        pBuffer->ConcatHead(CHAR_BLANK);
        pBuffer->ConcatHead(pName);

        if (pParent)
                {
                pParent->EmitModifiers ( pBuffer, false );
                }

        return STATUS_OK;
}

STATUS_T
node_interface_reference::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine emits an interface name.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_interface_reference::DoPrintType" );

        midl_debug ("node_interface_reference::DoPrintType\n");

        return DoPrintDecl( Flags, pBuffer, pStream, pParent, pIntf );
}

STATUS_T
node_file::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine walks the type graph under a file node to emit code.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_file::DoPrintType" );

        MEM_ITER                MemIter( this );
        node_skl *      pNode;

        midl_debug ("node_file::DoPrintType\n");

        while ( pNode = MemIter.GetNext() )
                {
                pBuffer->Clear ();

                pNode->DoPrintType (Flags, pBuffer, pStream, this, pIntf);
                }

        return STATUS_OK;
}

STATUS_T
node_source::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine walks the type graph under a source node to emit code.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_source::DoPrintType" );

        MEM_ITER                MemIter( this );
        node_skl *              pNode;

        midl_debug ("node_source::DoPrintType\n");
        while ( pNode = MemIter.GetNext() )
                {
#ifdef gajdebug10
                char * pNm = pNode->GetSymName();
                printf("printing decl %s\n",
                        pNm? pNm: "(unknown)");
#endif
                pNode->DoPrintType (Flags, pBuffer, pStream, this, pIntf);
                }

        return STATUS_OK;
}

STATUS_T
node_forward::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine walks the type graph under a source node to emit code.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_source::DoPrintType" );

        char            *       pName;
        named_node      *       pChild = (named_node *) GetChild();

        if ( pChild )
                pName = pChild->GetSymName();
        else
                pName = GetSymName();

        pBuffer->ConcatHead( CHAR_BLANK );
        pBuffer->ConcatHead( pName );
        switch ( SKey.GetKind() )
                {
                case NAME_TAG:
                        pBuffer->ConcatHead(WORD_STRUCT);
                        break;
                case NAME_ENUM:
                        pBuffer->ConcatHead(WORD_ENUM);
                        break;
                case NAME_UNION:
                        if ( pChild && (pChild->IsEncapsulatedStruct() ) )
                                pBuffer->ConcatHead(WORD_STRUCT);
                        else
                                pBuffer->ConcatHead(WORD_UNION);
                        break;
                default:
                        break;

                }
        return STATUS_OK;
}

STATUS_T
node_href::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       ,
        node_skl        *       )
{

        DUMP_DEBUG_INFO( "node_href::DoPrintDecl" );

        named_node      *       pChild = (named_node *) GetChild();
        char            *       pName= pChild->GetSymName();

        pBuffer->ConcatHead( CHAR_BLANK );
        pBuffer->ConcatHead( pName );
        pBuffer->ConcatHead( "/* external definition not present */ ");
        switch ( SKey.GetKind() )
                {
                case NAME_TAG:
                        pBuffer->ConcatHead(WORD_STRUCT);
                        break;
                case NAME_ENUM:
                        pBuffer->ConcatHead(WORD_ENUM);
                        break;
                case NAME_UNION:
                        if ( pChild && (pChild->IsEncapsulatedStruct() ) )
                                pBuffer->ConcatHead(WORD_STRUCT);
                        else
                                pBuffer->ConcatHead(WORD_UNION);
                        break;
                default:
                        break;

                }
        return STATUS_OK;
}

/*++

Routine Description:

    This routine walks a portion of the type graph

Arguments:

        none.

--*/
STATUS_T
node_skl::PrintType(
        PRTFLAGS                Flags,
        ISTREAM         *       pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf )
{

        DUMP_DEBUG_INFO( "node_skl::PrintType" );

        static
        BufferManager   Buffer(8, LAST_COMPONENT, STRING_TABLE);

        PRTFLAGS                ChildFlags      = Flags & ~(PRT_CAST_SYNTAX | PRT_DECL);
        STATUS_T                rc;

        Buffer.Clear();

        if ( Flags & PRT_CAST_SYNTAX ) pStream->Write("( ");

        if ( Flags & PRT_DECL )
                {
                rc = DoPrintDecl(ChildFlags, &Buffer, pStream, pParent, pIntf);
                }
        else
                {
                rc = DoPrintType(ChildFlags, &Buffer, pStream, pParent, pIntf);
                };

        Buffer.Print( pStream );

        if ( Flags & PRT_CAST_SYNTAX ) pStream->Write(" )");

        pStream->Flush();

        return rc;
};


/*++

Routine Description:

    This routine walks the type graph to emit type declarations

Arguments:

        none.

--*/

void
print_typegraph()
        {
        ISTREAM         Stream("dumpfile", 4);
        ISTREAM *       pStream         = &Stream;

        pStream->Write("\t\t\t/* dump of typegraph */\n\n");
        if (pSourceNode)
                {
                pSourceNode->PrintType(PRT_INTERFACE, pStream, NULL);
                }
        else
                {
                pStream->Write(
                   "\n\n------------- syntax errors; no info available ------------\n");
                }
        pStream->Flush();
        pStream->Close();

        }


STATUS_T
node_library::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine walks the type graph under a library node to emit code.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_libray::DoPrintType" );

        MEM_ITER                MemIter( this );
        node_skl *              pNode;
        NODE_T                  ChildKind;
        char *                  pName;
        short                   Option;
        // unsigned short       zp;
        PRTFLAGS                ChildFlags;

        BOOL                    fPrtBoth        = FALSE;

        midl_debug ("node_library::DoPrintType\n");
        pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);
        Option = pCommand->GetErrorOption ();
        ///////////////////////////////////////////////////
        // prefix determination

        // turn off prefix stuff if we don't want the stubs
        // see which flags are really needed
        if ( ( ( Flags & PRT_BOTH_PREFIX ) == PRT_BOTH_PREFIX ) &&
                 pCommand->IsPrefixDifferentForStubs() )
                fPrtBoth = TRUE;

        ChildFlags      = Flags | PRT_OMIT_PRAGMA_PACK;

        pStream->Write("/* library ");
        pStream->Write(pName);
        pStream->Write(" */");
        pStream->NewLine();
        DumpAttributes( pStream );
        pStream->NewLine(2);

        while ( pNode = MemIter.GetNext() )
                {
                ChildKind = pNode->NodeKind();

                // skip procs.
                if ( ( Flags & PRT_OMIT_PROTOTYPE ) &&
                         ( ChildKind == NODE_PROC ) )
                        continue;
                
                // skip interfaces, object interfaces, dispinterfaces, modules, and coclasses
                // for now (they will be dumped explicitly by CG_LIBRARY::GenHeader)
                if ( NODE_INTERFACE == ChildKind ||
                     NODE_DISPINTERFACE == ChildKind ||
                     NODE_MODULE == ChildKind ||
                     NODE_COCLASS == ChildKind  )
                        continue;

                pBuffer->Clear ();

                pNode->PrintMemoryInfo( pStream, TRUE );

                // print the type
                if ( fPrtBoth &&
                         (pNode->NodeKind()==NODE_PROC) )
                        {
                        PrintMultiple( (node_proc *)pNode, ChildFlags, pBuffer, pStream, this, this );
                        }
                else
                        pNode->DoPrintType (ChildFlags, pBuffer, pStream, this, this );

                if ( ChildKind != NODE_ECHO_STRING )
                        pStream->NewLine();

                }
        return STATUS_OK;
}

STATUS_T
node_module::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine walks the type graph under a module node to emit code.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_module::DoPrintType" );

        MEM_ITER                MemIter( this );
        node_skl *              pNode;
        NODE_T                  ChildKind;
        // unsigned short       zp;
        PRTFLAGS                ChildFlags;
        char * szName = GetSymName();

        ChildFlags      = Flags | PRT_OMIT_PRAGMA_PACK;

        pStream->Write("/* module ");
        pStream->Write(szName);
        pStream->Write(" */");
        pStream->NewLine();
        DumpAttributes( pStream );
        pStream->NewLine(2);

        while ( pNode = MemIter.GetNext() )
                {
                ChildKind = pNode->NodeKind();

                pBuffer->Clear ();

                pNode->PrintMemoryInfo( pStream, TRUE );

                // print the type
                pNode->DoPrintType (ChildFlags, pBuffer, pStream, this, this );

                if ( ChildKind != NODE_ECHO_STRING )
                        pStream->NewLine();

                }
    return STATUS_OK;
}

STATUS_T        
node_coclass::DoPrintDecl( PRTFLAGS Flags,
        BufferManager * ,
        ISTREAM * pStream,
        node_skl * ,
        node_skl *  )
{

    DUMP_DEBUG_INFO( "node_coclass::DoPrintDecl" );

    char * pName = GetSymName();

    MIDL_ASSERT (pName != (char *)0);

    pStream->Write(pName);

    if (Flags & PRT_TRAILING_SEMI)
            pStream->Write (';');
    else
            pStream->Write ('\t');

    return STATUS_OK;
}

STATUS_T
node_coclass::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * ,
        ISTREAM           * ,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine would walk the type graph under a coclass node to emit code
    except for the fact that a coclass doesn't emit any code.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

    DUMP_DEBUG_INFO( "node_coclass::DoPrintType" );

    return STATUS_OK;
}

STATUS_T
node_dispinterface::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * ,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine walks the type graph under a dispinterface node to emit code.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_dispinterface::DoPrintType" );

        char* pName= GetSymName();
        
        midl_debug ("node_dispinterface::DoPrintType\n");
        MIDL_ASSERT (pName != (char *)0);

        pStream->Write("/* dispinterface ");
        pStream->Write(pName);
        pStream->Write(" */");
        pStream->NewLine();
        DumpAttributes( pStream );
        pStream->NewLine(2);

        return STATUS_OK;
}

STATUS_T
node_dispinterface::DoPrintDecl (
                                PRTFLAGS        Flags,
                                BufferManager*  ,
                                ISTREAM*        pStream,
                                node_skl*       ,
                                node_skl*       
                                )
{

    DUMP_DEBUG_INFO( "node_dispinterface::DoPrintDecl" );

    char* pName = GetSymName();

    midl_debug ("node_dispinterface::DoPrintDecl\n");
    MIDL_ASSERT (pName != (char *)0);
    pStream->Write(pName);
    if (Flags & PRT_TRAILING_SEMI)
        {
        pStream->Write (';');
        }
    else
        {
        pStream->Write ('\t');
        }

    return STATUS_OK;
}

STATUS_T        
node_pipe::PrintDeclaration (
                            PRTFLAGS        Flags,
                            BufferManager*  ,
                            ISTREAM*        pStream,
                            node_skl*       ,
                            node_skl*       pIntf,
                            char*           szPrefix
                            )
{
    node_skl *              pNode = GetChild();
    char                    pName[128] = { 0 };
    char*                   szSymName;
    PRTFLAGS                ChildFlags = ( Flags & ~PRT_TRAILING_SEMI) | PRT_INSIDE_OF_STRUCT;
    BufferManager           TempBuffer(8, LAST_COMPONENT, STRING_TABLE);
    char*                   szReturn = szPrefix == 0 ? "void " : "RPC_STATUS ";

    szSymName = GetSymName();
    MIDL_ASSERT ( szSymName != (char *)0 );

    if ( szPrefix != 0 )
        {
        strcpy( pName, szPrefix );
        }
    strcat( pName, szSymName );

    DumpAttributes( pStream );

    pStream->Write("struct ");
    pStream->Write(pName);
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write('{');
    // definition of pull 
    pStream->NewLine();
    pStream->Write(szReturn);
    pStream->Write("(* pull) (");
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write("char * state,");
    pStream->NewLine();
    TempBuffer.Clear ();
    pNode->DoPrintDecl (ChildFlags, &TempBuffer, pStream, this, pIntf);
    //pNode->DoPrintType(ChildFlags, &TempBuffer, pStream, this, pIntf);
    TempBuffer.Print(pStream);
    pStream->Write("* buf,");
    pStream->NewLine();
    pStream->Write("unsigned long esize,");
    pStream->NewLine();
    pStream->Write("unsigned long * ecount );");
    pStream->IndentDec();
    // definition of push
    pStream->NewLine();
    pStream->Write(szReturn);
    pStream->Write("(* push) (");
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write("char * state,");
    pStream->NewLine();
    pNode->DoPrintDecl (ChildFlags, &TempBuffer, pStream, this, pIntf);
    //pNode->DoPrintType(ChildFlags, &TempBuffer, pStream, this, pIntf);
    TempBuffer.Print(pStream);
    pStream->Write("* buf,");
    pStream->NewLine();
    pStream->Write("unsigned long ecount );");
    pStream->IndentDec();
    // definition of alloc 
    pStream->NewLine();
    pStream->Write(szReturn);
    pStream->Write("(* alloc) (");
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write("char * state,");
    pStream->NewLine();
    pStream->Write("unsigned long bsize,");
    pStream->NewLine();
    pNode->DoPrintDecl (ChildFlags, &TempBuffer, pStream, this, pIntf);
    //pNode->DoPrintType(ChildFlags, &TempBuffer, pStream, this, pIntf);
    TempBuffer.Print(pStream);
    pStream->Write("* * buf,");
    pStream->NewLine();
    pStream->Write("unsigned long * bcount );");
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("char * state;");
    pStream->NewLine();
    pStream->Write("} ");
    pStream->IndentDec();

    if (Flags & PRT_TRAILING_SEMI)
            pStream->Write (';');
    else
            pStream->Write ('\t');

    return STATUS_OK;
}

STATUS_T
node_pipe::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints declaration for a node of pipe type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

    DUMP_DEBUG_INFO( "node_dispinterface::DoPrintDecl" );

    // print async defn. if the pipe has been used in an async call
    if ( GenAsyncPipeFlavor() )
        {
        PrintDeclaration(
                        Flags,
                        pBuffer,
                        pStream,
                        pParent,
                        pIntf,
                        SZ_ASYNCPIPEDEFPREFIX
                        );
        pStream->Write(SZ_ASYNCPIPEDEFPREFIX);
        pStream->Write(pParent->GetSymName());
        pStream->Write(';');
        pStream->NewLine();
        pStream->NewLine();
        pStream->Write("typedef ");
        }

    PrintDeclaration(
                    Flags,
                    pBuffer,
                    pStream,
                    pParent,
                    pIntf,
                    0
                    );
    return STATUS_OK;
}

STATUS_T
node_pipe::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints definition for a node of pipe type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_pipe::DoPrintType" );

        midl_debug ("node_pipe::DoPrintType\n");
        return DoPrintDecl (Flags, pBuffer, pStream, pParent, pIntf);
}


STATUS_T
node_safearray::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * ,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine prints declaration for a node of safearray type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
  
        DUMP_DEBUG_INFO( "node_safearray::DoPrintDecl" );

        midl_debug ("node_safearray::DoPrintDecl\n");
        pStream->Write("SAFEARRAY * ");
        return STATUS_OK;
}

STATUS_T
node_safearray::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints definition for a node of safearray type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_safearray::DoPrintType" );
 
        midl_debug ("node_safearray::DoPrintType\n");
        return DoPrintDecl (Flags, pBuffer, pStream, pParent, pIntf);
}

STATUS_T
node_async_handle::DoPrintDecl( PRTFLAGS        Flags,
                                BufferManager*  pBuffer,
                                ISTREAM*        pStream,
                                node_skl*       pParent,
                                node_skl*       pIntf )
    {

    DUMP_DEBUG_INFO( "node_async_handle::DoPrintDecl" );

    midl_debug ("node_async_handle::DoPrintDecl\n");

    return DoPrintType (Flags, pBuffer, pStream, pParent, pIntf);
    }

STATUS_T
node_async_handle::DoPrintType( PRTFLAGS        Flags,
                                BufferManager*  ,
                                ISTREAM*        pStream,
                                node_skl*       ,
                                node_skl*       )
    {

    DUMP_DEBUG_INFO( "node_async_handle::DoPrintType" );

    midl_debug ("node_async_handle::DoPrintType\n");

    pStream->Write(GetSymName());
    pStream->Spaces(1);
    return STATUS_OK;
    }

char szDeclSpecGuid[128] = {""};

char*
named_node::GetDeclSpecGuid()
{
    node_guid* pGuid = ( node_guid* ) GetAttribute( ATTR_GUID );

    if ( pGuid && pCommand->GetMSCVer() >= 1100 )
        {
        sprintf( szDeclSpecGuid, " DECLSPEC_UUID(\"%s\") ", pGuid->GetGuidString() );
        }
    else
        {
        szDeclSpecGuid[0] = 0;
        }
    return szDeclSpecGuid;
}

STATUS_T
node_decl_guid::DoPrintType(
        PRTFLAGS        Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *,
        node_skl        *)
{

        DUMP_DEBUG_INFO( "node_decl_guid::DoPrintType" );

        INTERNAL_UUID guid;

        midl_debug ("node_decl_guid::DoPrintType\n");
        DumpAttributes( pStream );
        pBuffer->Clear ();

        // convert const declare_guid( <name>, <guid> ); to:
        //                 EXTERN_GUID( itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8 );
        pStream->Write ( "EXTERN_GUID( " );
        pStream->Write ( GetSymName() );
        pStream->Write ( ',' ); // node_guid
        pGuid->GetGuid( *( (struct _GUID*) &guid ) );
        char tmp[64];
        
        sprintf( tmp, " 0x%x, 0x%x, 0x%x",  guid.Data1, guid.Data2, guid.Data3 );
        pStream->Write ( tmp );
        for ( int i = 0;i < 8;i++ )
            {
            sprintf( tmp, ", 0x%x", guid.Data4[i] );
            pStream->Write( tmp );
            }
        pStream->Write ( " );");

        pStream->NewLine();
        return STATUS_OK;
}

STATUS_T
node_decl_guid::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       pParent,
        node_skl        *       )
{

        DUMP_DEBUG_INFO( "node_decl_guid::DoPrintDecl" );

        midl_debug ("node_decl_guid::DoPrintDecl\n");

        char* pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);

        if (pParent )
                {
                if ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)
                        pParent->EmitModelModifiers (pBuffer);
                else
                        Flags &= ~PRT_SUPPRESS_MODEL;
                }

        pBuffer->ConcatHead(CHAR_BLANK);
        pBuffer->ConcatHead(pName);

        if (pParent)
                {
                pParent->EmitModifiers ( pBuffer, false );
                }

        return STATUS_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\pass3.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: pass3.cxx
Title				: pass3 controller
History				:
	24-Sep-1993	GregJen Created

*****************************************************************************/

#if 0
						Notes
						-----
This file provides the interface for the semantic analysis pass. It also
initializes the pass3 controller object.

#endif // 0

#pragma warning ( disable : 4514 )

/****************************************************************************
 includes
 ****************************************************************************/

#include "nulldefs.h"
extern	"C"	{
	#include <stdio.h>
	#include <stdlib.h>
	#include <malloc.h>
	extern int yyacfparse();
}

#include "allnodes.hxx"
#include "control.hxx"
#include "cmdana.hxx"
#include "filehndl.hxx"
#include "idict.hxx"
#include "semantic.hxx"

/****************************************************************************
	local definitions
 ****************************************************************************/


/****************************************************************************
	extern procedures
 ****************************************************************************/


/****************************************************************************
	extern data 
 ****************************************************************************/

extern class ccontrol		*	pCompiler;
extern node_source			*	pSourceNode;
extern CMD_ARG				*	pCommand;

/****************************************************************************
	local data
 ****************************************************************************/


/****************************************************************************/


_pass3::_pass3()
	{
	
	pCompiler->SetPassNumber( SEMANTIC_PASS );
	}

STATUS_T
_pass3::Go()
	{
	MEM_ITER			MemIter( pSourceNode );
	node_file		*	pFNode;

	// turn off line number additions
	FileIndex = 0;

	/**
	 ** for each idl file, check semantics of all interfaces.
	 **/

	while ( ( pFNode = (node_file *) MemIter.GetNext() ) != 0 )
		{
				SEM_ANALYSIS_CTXT		FileSemAnalysis(pSourceNode);

				pFNode->SemanticAnalysis( &FileSemAnalysis );
		}

	// terminate compilation if we found errors
	return (pCompiler->GetErrorCount()) ? ERRORS_PASS1_NO_PASS2 : STATUS_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\semutil.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    semutil.cxx

 Abstract:

    semantic analysis utility routines

 Notes:


 Author:

    GregJen 28-Oct-1993     Created.

 Notes:


 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 4710 )

/****************************************************************************
 *      include files
 ***************************************************************************/

#include "nulldefs.h"
extern  "C"     {
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
}
#include "allnodes.hxx"
#include "semantic.hxx"
#include "symtable.hxx"
#include "cmdana.hxx"

/****************************************************************************
 *      local data
 ***************************************************************************/

/****************************************************************************
 *      externs
 ***************************************************************************/

extern SymTable *       pBaseSymTbl;
extern ATTR_SUMMARY     DisallowedAttrs[INTERNAL_NODE_END];
extern BOOL             IsTempName( char * );
extern CMD_ARG *        pCommand;

/****************************************************************************
 *      definitions
 ***************************************************************************/





void
WALK_CTXT::FindImportantPosition(tracked_node & Posn)
{
    WALK_CTXT * pCurCtxt = this;
    WALK_CTXT * pParCtxt;
    node_skl * pNode;

    // walk up until we find one whose PARENT was not important
    while ( (pParCtxt=(WALK_CTXT *)pCurCtxt->GetParentContext()) != 0 &&
            ( pParCtxt->IsImportantPosition() ) )
        {
        pCurCtxt = pParCtxt;
        }

    // continue walking up until we find one with a position
    do
        {
        pNode = pCurCtxt->GetParent();
        pNode->GetPositionInfo( Posn );
        pCurCtxt = (WALK_CTXT *) pCurCtxt->GetParentContext();
        }
    while( !Posn.HasTracking() && pCurCtxt );
}

void
SEM_ANALYSIS_CTXT::CheckAttributes()
{
    ATTR_VECTOR & BadAttrs = DisallowedAttrs[ GetParent()->NodeKind() ];
    ATTR_VECTOR ExcessAttrs;
    ATTR_T Attr;
    node_base_attr * pAttr;
    char * pAttrName;

    MASKED_COPY_ATTR( ExcessAttrs, *(pDownAttrList->GetSummary()), BadAttrs );
    while (!IS_CLEAR_ATTR( ExcessAttrs ) )
        {
        Attr = CLEAR_FIRST_SET_ATTR( ExcessAttrs );
        pAttr = ExtractAttribute( Attr );
        pAttrName = pAttr->GetNodeNameString();

        if (pAttr->IsAcfAttr() )
            AcfError( (acf_attr *)pAttr,
                GetParent(),
                *this,
                INAPPLICABLE_ATTRIBUTE,
                pAttrName);
        else
            SemError( GetParent(), *this, INAPPLICABLE_ATTRIBUTE ,pAttrName);

        }
}

void
SEM_ANALYSIS_CTXT::RejectAttributes()
{
    ATTR_VECTOR ExcessAttrs;
    ATTR_T Attr;
    node_base_attr * pAttr;
    char * pAttrName;

    COPY_ATTR( ExcessAttrs, *(pDownAttrList->GetSummary()));
    while (!IS_CLEAR_ATTR( ExcessAttrs ) )
        {
        Attr = CLEAR_FIRST_SET_ATTR( ExcessAttrs );
        pAttr = ExtractAttribute( Attr );
        pAttrName = pAttr->GetNodeNameString();

        if (pAttr->IsAcfAttr() )
            AcfError( (acf_attr *)pAttr,
                GetParent(),
                *this,
                INAPPLICABLE_ATTRIBUTE,
                pAttrName);
        else
            SemError( GetParent(), *this, INAPPLICABLE_ATTRIBUTE ,pAttrName);

        }
}



//
// resolve forward declarations
//
named_node *
node_forward::ResolveFDecl()
{
    if ( !GetChild() )
        {
        named_node * pRef = pSymTbl->SymSearch( SKey );

        if (pRef && ( pRef != this ) && ( pRef->NodeKind() != NODE_FORWARD ) )
            {
            SetChild( pRef );
            }
        }
    return (named_node *) GetChild();
}

void
node_proc::AddExplicitHandle    (
                                SEM_ANALYSIS_CTXT* pParentCtxt,
                                unsigned int       uParamNumber
                                )
{
    node_skl * pHand;
    node_param * pParm;

    // only add the handle once
    if ( !strcmp( GetChild()->GetSymName(), "IDL_handle" ) )
        return;

    GetBaseTypeNode( &pHand, SIGN_UNDEF, SIZE_UNDEF, TYPE_HANDLE_T, 0 );

    // set up [in] param "IDL_handle", pointing to handle_t, add as first parameter
    pParm = new node_param;
    pParm->SetSymName( "IDL_handle" );
    pParm->SetChild( pHand );
    pParm->SetAttribute( new battr( ATTR_IN ) );

    if ( uParamNumber == 1 )
        {
        AddFirstMember( pParm );
        }
    else
        {
        AddSecondMember( pParm );
        }

    // update the information for the parameter
    pParm->SemanticAnalysis( pParentCtxt );

    fHasExplicitHandle = TRUE;
    fHasAtLeastOneIn = TRUE;
}

void
node_proc::AddFullAsyncHandle   (
                                SEM_ANALYSIS_CTXT*  pParentCtxt,
                                node_skl*           pType,
                                char*               szTypeName
                                )
{
    const char* szNameSuffix    = "_AsyncHandle";
    char*       szFullName      = new char[strlen(GetSymName()) + strlen(szNameSuffix) + 1];

    strcpy(szFullName, GetSymName());
    strcat(szFullName, szNameSuffix);
    node_skl*   pAsyncHandle = new node_async_handle( szTypeName );

    if ( pType )
        {
        pAsyncHandle->SetChild( pType );
        }
    node_param* pParm = new node_param;

    pParm->SetSymName( szFullName );
    pParm->SetChild( pAsyncHandle );

    pParm->SetAttribute( new battr( ATTR_IN ) );
    AddFirstMember( pParm );
    pParm->SemanticAnalysis( pParentCtxt );
    SetHasAsyncHandle();
    pParm->SetIsAsyncHandleParam();
    fHasAtLeastOneIn = TRUE;
}

BOOL
node_base_type::RangeCheck( __int64 Val )
{
    NODE_T Kind = NodeKind();

    switch ( Kind )
        {
        case NODE_BOOLEAN:
            return ( Val >= 0 ) && ( Val <= 1 );
        case NODE_SHORT:
            if ( FInSummary( ATTR_UNSIGNED ) )
                return ( Val >= 0 ) && ( Val <= _UI16_MAX );
            else
                return ( Val >= _I16_MIN ) && ( Val <= _I16_MAX );
        case NODE_BYTE:
            return ( Val >= 0 ) && ( Val <= 255 );
        case NODE_CHAR:
            if ( FInSummary( ATTR_UNSIGNED ) )
                return ( Val >= 0 ) && ( Val <= 255 );
            else if ( FInSummary( ATTR_SIGNED ) )
                return ( Val >= -128 ) && ( Val <= 127 );
            else if ( pCommand->GetCharOption() == CHAR_SIGNED )
                return ( Val >= 0 ) && ( Val <= 255 );
            else
                return ( Val >= -128 ) && ( Val <= 127 );
        case NODE_SMALL:
            if ( FInSummary( ATTR_UNSIGNED ) )
                return ( Val >= 0 ) && ( Val <= 255 );
            else if ( FInSummary( ATTR_SIGNED ) )
                return ( Val >= -128 ) && ( Val <= 127 );
            else if ( pCommand->GetCharOption() == CHAR_UNSIGNED )
                return ( Val >= -128 ) && ( Val <= 127 );
            else
                return ( Val >= 0 ) && ( Val <= 255 );
        case NODE_LONG:
        case NODE_INT32:
        case NODE_INT:
            if ( FInSummary( ATTR_UNSIGNED ) )
                return ( Val >= 0 ) && ( Val <= _UI32_MAX );
            else
                return ( Val >= _I32_MIN ) && ( Val <= _I32_MAX );
        case NODE_INT3264:
            if ( ! pCommand->Is64BitEnv() )
                {
                if ( FInSummary( ATTR_UNSIGNED ) )
                    return ( Val >= 0 ) && ( Val <= _UI32_MAX );
                else
                    return ( Val >= _I32_MIN ) && ( Val <= _I32_MAX );
                }
            // else fall through to 64b integral
        case NODE_HYPER:
        case NODE_INT64:
        case NODE_INT128:
            return TRUE;
        }
    return TRUE;
}


BOOL
node_base_type::IsAssignmentCompatible( node_base_type * pOther )
{
    unsigned long MySize = GetSize();
    unsigned long HisSize = pOther->GetSize();

    // tbd - fill in more cases
    if ( MySize < HisSize )
        return FALSE;

    // unsigned <= signed
    if ( FInSummary( ATTR_UNSIGNED ) &&
            !pOther->FInSummary( ATTR_UNSIGNED ) )
        return FALSE;

    // signed <= unsigned ( only OK if dest is larger )
    if ( pOther->FInSummary( ATTR_UNSIGNED ) &&
            FInSummary( ATTR_SIGNED ) &&
            (MySize <= HisSize) )
        return FALSE;

    if ( ( NodeKind() == NODE_BOOLEAN ) &&
            ( pOther->NodeKind() != NODE_BOOLEAN ) )
        return FALSE;

    return TRUE;
}




char *
GetErrorNamePrefix( node_skl * pNode )
{
    if ( !pNode )
        return NULL;

    switch ( pNode->NodeKind() )
        {
        case NODE_FIELD:
            return " Field ";
        case NODE_STRUCT:
            return " Struct ";
        case NODE_UNION:
            return " Union ";
        case NODE_ENUM:
            return " Enum ";
        case NODE_PARAM:
            return " Parameter ";
        case NODE_PROC:
            return " Procedure ";
        case NODE_INTERFACE:
        case NODE_INTERFACE_REFERENCE:
            return " Interface ";
        case NODE_PIPE_INTERFACE:
            return " Object Pipe ";
        case NODE_DEF:
            return " Type ";
        case NODE_LIBRARY:
            return " Library ";
        case NODE_MODULE:
            return " Module ";
        case NODE_COCLASS:
            return " Coclass ";
        case NODE_DISPINTERFACE:
            return " Dispinterface ";
        default:
            return NULL;
        }
}

#define SUFFIX_SIZE         1000
#define CONTEXT_STR_SIZE    1000

void
GetSemContextString(
    char * pResult,
    node_skl * pNode,
    WALK_CTXT * pCtxt )
{
    node_skl * pBase = NULL;
    node_skl * pParent = NULL;
    node_skl * pUsage = NULL;
    char * pPrefix;

    pResult[0] = '\0';

    if ( !pNode )
        {
        pNode = ( pCtxt ) ? pCtxt->GetParent() : NULL;
        }

    // compute base part and parent part
    while ( pCtxt && !pParent && pNode )
        {
        switch ( pNode->NodeKind() )
            {
            case NODE_FIELD:
            case NODE_PARAM:
                pBase = pNode;
                break;
            case NODE_STRUCT:
            case NODE_UNION:
            case NODE_ENUM:
            case NODE_PROC:
            case NODE_INTERFACE:
            case NODE_PIPE_INTERFACE:
            case NODE_INTERFACE_REFERENCE:
            case NODE_DEF:
            case NODE_LIBRARY:
            case NODE_MODULE:
            case NODE_COCLASS:
            case NODE_DISPINTERFACE:
                pParent = pNode;
                break;
            }

        pCtxt = pCtxt->GetParentContext();
        pNode = ( pCtxt ) ? pCtxt->GetParent() : NULL;
        }

    // compute usage part (param or proc or interface)
    // note that pCtxt is one level up above the current pNode
    pCtxt = pCtxt->GetParentContext();
    while ( pCtxt && ! pUsage )
        {
        switch ( pCtxt->GetParent()->NodeKind() )
            {
            // stop at the top-most level ( child of interface, or proc )
            // therefore highest type/proc/param
            case NODE_INTERFACE:
            case NODE_PIPE_INTERFACE:
            case NODE_PROC:
            case NODE_LIBRARY:
            case NODE_MODULE:
            case NODE_COCLASS:
            case NODE_DISPINTERFACE:
                pUsage = pNode;
                break;
            }

        pNode = ( pCtxt ) ? pCtxt->GetParent() : NULL;
        pCtxt = pCtxt->GetParentContext();
        }


    if ( pBase || pParent || pUsage )
        {
        strcat( pResult, "[");

        if ( pBase )
            {
            pPrefix = GetErrorNamePrefix( pBase );
            if ( pPrefix )
                strcat( pResult, pPrefix );
            if ( !IsTempName( pBase->GetSymName() ) )
                {
                strcat( pResult, "'");
                strcat( pResult, pBase->GetSymName() );
                strcat( pResult, "' ");
                }
            }

        if ( pParent )
            {
            if ( !IsTempName( pParent->GetSymName() ) )
                {
                if ( pBase )
                    strcat(pResult, "of");
                pPrefix = GetErrorNamePrefix( pParent );
                if ( pPrefix )
                    strcat( pResult, pPrefix );
                strcat( pResult, "'");
                strcat( pResult, pParent->GetSymName() );
                strcat( pResult, "' ");
                }
            else
                {
                pPrefix = GetErrorNamePrefix( pBase );
                if ( pPrefix && !pBase )
                    strcat( pResult, pPrefix );
                }
            }

        if ( pUsage )
            {
            strcat( pResult, "(");
            pPrefix = GetErrorNamePrefix( pUsage );
            if ( pPrefix )
                strcat( pResult, pPrefix );
            strcat( pResult, "'");
            strcat( pResult, pUsage->GetSymName() );
            strcat( pResult, "' )");
            }

        strcat( pResult, " ]");
        }
}

void
SemError(
    node_skl * pNode,
    WALK_CTXT & Ctxt,
    STATUS_T ErrNum,
    char * pExtra )
{
    ErrorInfo ErrStats( ErrNum );

    // if the error is not relevant to this compile, return right away
    if ( !ErrStats.IsRelevant() )
        return;

    short CurLen = 1; // for the null byte
    char Suffix[SUFFIX_SIZE];
    char ContextStr[ CONTEXT_STR_SIZE ];
    char * pSuffix = Suffix;
    char * pFile;
    short Line;
    tracked_node Posn((void*)NULL);
    WALK_CTXT * pCurCtxt;
    // extract file and line info, and context info

    pCurCtxt = &Ctxt;

    GetSemContextString( ContextStr, pNode, &Ctxt );
    CurLen = short( CurLen + strlen( ContextStr ) );

    // unless the string is REALLY long, just use stack space
    if ( CurLen + 1 > SUFFIX_SIZE )
        pSuffix = new char [CurLen + 1];

    if ( pExtra || strlen( ContextStr ) )
        {
        strcpy( pSuffix, ": " );
        if ( pExtra )
            strcat( pSuffix, pExtra );

        // make sure pSuffix has a trailing space at this point
        if ( pSuffix[ strlen(pSuffix) - 1 ] != ' ' )
            {
            strcat( pSuffix, " " );
            }

        if ( strlen(ContextStr) )
            {
            strcat( pSuffix, ContextStr );
            }
        }
    else
        strcpy( pSuffix, "" );


    // fetch the file position from the context stack
    Ctxt.FindImportantPosition(Posn);
    Posn.GetLineInfo( pFile, Line);

    ErrStats.ReportError( pFile,
        Line,
        pSuffix );

    // clean up if we had to allocate space
    if ( pSuffix != Suffix )
        delete pSuffix;
}

void
AcfError(
    acf_attr * pAttr,
    node_skl * ,
    WALK_CTXT & ,
    STATUS_T ErrNum,
    char * pExtra )
{
    short CurLen  = 1; // for the null byte
    char Suffix[SUFFIX_SIZE];
    char * pSuffix = Suffix;
    char * pName;
    char * pFile;
    short Line;
    tracked_node Posn((void*)NULL);

    // extract file and line info, and context info


    pName = pAttr->GetNodeNameString();
    // <name>[: <extra>]
    CurLen = short( CurLen + strlen(pName) );
    CurLen = short( CurLen + ( (pExtra) ? strlen(pExtra) + 2 : 0 ) );

    // unless the string is REALLY long, just use stack space
    if ( CurLen + 1 > SUFFIX_SIZE )
        pSuffix = new char [CurLen + 1];

    strcpy( pSuffix, pName );
    if (pExtra)
        {
        strcat( pSuffix, ": " );
        strcat( pSuffix, pExtra );
        }

    // fetch the file position from the context stack
    pAttr->Position.GetLineInfo( pFile, Line);

    RpcError( pFile,
        Line,
        ErrNum,
        pSuffix );

    // clean up if we had to allocate space
    if ( pSuffix != Suffix )
        delete pSuffix;
}

BOOL CIDLIST::AddId(__int64 lId, char * szName)
{
    IDLISTMEM ** pThis = &pHead;
    while (*pThis && (*pThis)->lId < lId)
    {
        pThis = &((*pThis)->pNext);
    }
    if (*pThis && (*pThis)->lId == lId)
    {
        if (_stricmp(szName, (*pThis)->szName))
            return FALSE;
        else
            return TRUE;
    }
    IDLISTMEM * pNew = new IDLISTMEM;
    pNew->lId = lId;
    pNew->pNext = *pThis;
	pNew->szName = szName;
    *pThis = pNew;
    return TRUE;
}

/*
Nishad

bool
node_base_type::IsCompatibleType(
                                TypeSet     set
                                )
{
    bool    fReturnCode = false;
    NODE_T  nodeKind = NodeKind();

    switch ( set )
        {
        case ts_UnsignedFixedPoint:
            fReturnCode =   ( 
                            nodeKind == NODE_INT128 ||
                            nodeKind == NODE_HYPER ||
                            nodeKind == NODE_INT64 ||
                            nodeKind == NODE_INT32 ||
                            nodeKind == NODE_LONG ||
                            nodeKind == NODE_LONGLONG ||
                            nodeKind == NODE_SHORT ||
                            nodeKind == NODE_INT ||
                            nodeKind == NODE_SMALL ||
                            nodeKind == NODE_CHAR ||
                            nodeKind == NODE_BOOLEAN ||
                            nodeKind == NODE_BYTE
                            )
                            &&
                            IsUnsigned();
            break;
        case ts_FixedPoint:
            fReturnCode =   (
                            nodeKind == NODE_INT128 || 
                            nodeKind == NODE_HYPER ||
                            nodeKind == NODE_INT64 ||
                            nodeKind == NODE_INT32 ||
                            nodeKind == NODE_LONG ||
                            nodeKind == NODE_LONGLONG ||
                            nodeKind == NODE_SHORT ||
                            nodeKind == NODE_INT ||
                            nodeKind == NODE_SMALL ||
                            nodeKind == NODE_CHAR ||
                            nodeKind == NODE_BOOLEAN ||
                            nodeKind == NODE_BYTE
                            );
            break;
        case ts_FloatingPoint:
            fReturnCode = ( nodeKind == NODE_FLOAT || 
                            nodeKind == NODE_DOUBLE ||
                            nodeKind == NODE_FLOAT80 ||
                            nodeKind == NODE_FLOAT128 );
            break;
        case ts_Character:
            fReturnCode = ( nodeKind == NODE_CHAR || nodeKind == NODE_BYTE || nodeKind == NODE_WCHAR_T );
            break;
        case ts_String:
            // TBD
            break;
        case ts_Interface:
            // TBD
            break;
        }

    return fReturnCode;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\semantic.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    semantic.cxx

 Abstract:

    semantic analysis routines

 Notes:


 Author:

    GregJen Jun-11-1993     Created.

 Notes:


 ----------------------------------------------------------------------------*/
// unreferenced inline/local function has been removed
#pragma warning ( disable : 4514 )

 /****************************************************************************
 *      include files
 ***************************************************************************/
#include <basetsd.h>
#include "allnodes.hxx"
#include "semantic.hxx"
#include "cmdana.hxx"
extern "C"
    {
    #include <string.h>
    }
#include "treg.hxx"
#include "tlgen.hxx"
#include "Pragma.hxx"
// #include "attrguid.hxx"

BOOL
IsOLEAutomationType (
                    char*
                    );
BOOL
IsOLEAutomationCompliant(
                        node_skl*
                        );
node_interface*
CloneIFAndSplitMethods  (
                        node_interface*
                        );
node_skl*
GetInOnlyParamPairedWithOut (
                            MEM_ITER&    MemParamList
                            );
bool
HasCorrelation  (
                node_skl*
                );

#define RPC_ASYNC_HANDLE_NAME       "PRPC_ASYNC_STATE"
#define RPC_ASYNC_STRUCT_NAME       "_RPC_ASYNC_STATE"
#define OBJECT_ASYNC_HANDLE_NAME    "IAsyncManager"

#define IS_OLD_INTERPRETER( x ) ( ((x) & OPTIMIZE_INTERPRETER) && !((x) & OPTIMIZE_INTERPRETER_V2) )
#define IsCoclassOrDispKind(x)  ( (x) == NODE_DISPINTERFACE || (x) == NODE_COCLASS )
#define IsInterfaceKind(x)      ( (x) == NODE_INTERFACE_REFERENCE || (x) == NODE_INTERFACE )

//
// This state table defines the rules that govern valid [propput] methods.
//

namespace PropPut
{
    enum State
    {
        NoParam      = 0,
        GeneralParam = 1,
        Optional     = 2,
        Default      = 3,
        LCID         = 4,
        LastParam    = 5,
        Reject       = 6,
        Accept       = 7,
    };

    // Accept = Param* (optional|default)* (param|lcidparam|default)

    State StateTable[][5] = 
    {
//       no param   regular         optional    default     lcid
//      -----------------------------------------------------------
        {Reject,    GeneralParam,   Optional,   Default,    LCID},      // NoParam
        {Accept,    GeneralParam,   Optional,   Default,    LCID},      // GeneralParam
        {Reject,    LastParam,      Optional,   Default,    LCID},      // Optional
        {Accept,    LastParam,      Optional,   Default,    LCID},      // Default
        {Reject,    LastParam,      Reject,     Reject,     Reject},    // LCID
        {Accept,    Reject,         Reject,     Reject,     Reject},    // LastParam
        {Reject,    Reject,         Reject,     Reject,     Reject},    // Reject
        {Accept,    Reject,         Reject,     Reject,     Reject}     // Accept
    };
}

/****************************************************************************
 *      externs
 ***************************************************************************/

extern BOOL         IsTempName( char * );
extern CMD_ARG  *   pCommand;
extern SymTable *   pUUIDTable;
extern SymTable *   pBaseSymTbl;
extern TREGISTRY *  pCallAsTable;

extern BOOL Xxx_Is_Type_OK( node_skl * pType );

extern "C"
    {
#ifndef GUID_DEFINED
#define GUID_DEFINED
    typedef struct _GUID {          // size is 16
        unsigned long   Data1;
        unsigned short   Data2;
        unsigned short   Data3;
        unsigned char  Data4[8];
    } GUID;
#endif 
    typedef GUID IID;

    extern const GUID IID_IAdviseSink;
    extern const GUID IID_IAdviseSink2;
    extern const GUID IID_IAdviseSinkEx;
    extern const GUID IID_AsyncIAdviseSink;
    extern const GUID IID_AsyncIAdviseSink2;

    // {DE77BA62-517C-11d1-A2DA-0000F8773CE9}
    static const GUID IID_AsyncIAdviseSinkEx2 = 
    { 0xde77ba62, 0x517c, 0x11d1, { 0xa2, 0xda, 0x0, 0x0, 0xf8, 0x77, 0x3c, 0xe9 } };

    };

bool
IsAnyIAdviseSinkIID (
                    GUID&    rIID
                    )
    {
        return (
                    !memcmp( &IID_IAdviseSink, &rIID, sizeof(GUID) ) 
                ||  !memcmp( &IID_IAdviseSink2, &rIID, sizeof(GUID) )
                ||  !memcmp( &IID_AsyncIAdviseSink, &rIID, sizeof(GUID) )
                ||  !memcmp( &IID_AsyncIAdviseSink2, &rIID, sizeof(GUID) )
                // IAdviseSinkEx will be converted to sync interface.
                ||  !memcmp( &IID_IAdviseSinkEx, &rIID, sizeof(GUID) ) 
                );
    }

node_skl*
GetIndirectionLevel (
                    node_skl*       pType,
                    unsigned int&   nIndirectionLevel
                    )
    {
        if ( pType )
            {
            node_skl* pChild = pType->GetChild();

            if ( pChild )
                {
                pType = pChild;
                NODE_T nodeKind = pType->NodeKind();
                if ( nodeKind == NODE_POINTER )
                    {
                    return GetIndirectionLevel( pType, ++nIndirectionLevel );
                    }
                else if ( nodeKind == NODE_INTERFACE )
                    {
                    return pType;
                    }
                else
                    {
                    return GetIndirectionLevel( pType, nIndirectionLevel );
                    }
                }
            }
        return pType;
    }

node_skl*
GetNonDefType   (
                node_skl*  pType
                )
    {
    node_skl*   pChild = pType->GetChild();
    if ( pChild && pType->NodeKind() == NODE_DEF )
        {
        pType = GetNonDefType( pChild );
        }
    return pType;
    }

void
node_skl::SemanticAnalysis( SEM_ANALYSIS_CTXT * )
{
    MIDL_ASSERT( !"node_skl semantic analysis called" );
}

void
node_skl::CheckDeclspecAlign( SEM_ANALYSIS_CTXT & MyContext )
{
    if (GetModifiers().IsModifierSet( ATTR_DECLSPEC_ALIGN ) &&
        MyContext.AnyAncestorBits( IN_LIBRARY ) )
        {
        SemError( this, MyContext, DECLSPEC_ALIGN_IN_LIBRARY, GetSymName() ); 
        }
}

void
node_href::SemanticAnalysis( SEM_ANALYSIS_CTXT * )
{
    // If this reference hasn't already been expanded, Resolve() will expand it.

    named_node * pRef = Resolve();
    MIDL_ASSERT(pRef || !"node_href::Resolve() failed" );

    // NOTE - we might want to just skip this step and simply clear any
    //        remaining attributes.
    //        Presumably, if it came from a type library, it must have
    //        been previously analyzed and found to be correct.
    //    pRef->SemanticAnalysis(pParentCtxt);
    // pParentCtxt->ClearAttributes();
}

void
node_forward::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    if ( fBeingAnalyzed )
        {
        return;
        }
    fBeingAnalyzed = TRUE;

    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );

    named_node * pRef = ResolveFDecl();

    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    MyContext.ExtractAttribute( ATTR_DEFAULT );
    while(MyContext.ExtractAttribute( ATTR_CUSTOM ));

    // check for illegal member attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_RETVAL:
            case MATTR_VARARG:
            case MATTR_SOURCE:
            case MATTR_DEFAULTVTABLE:
            case MATTR_RESTRICTED:
            case MATTR_OPTIONAL:
            case MATTR_PREDECLID:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_IMMEDIATEBIND:
            case MATTR_USESGETLASTERROR:
                break;
            case MATTR_REPLACEABLE:
            default:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }

    if ( !pRef && MyContext.AnyAncestorBits( IN_RPC )  )
        {
        SemError( this, MyContext, UNRESOLVED_TYPE, GetSymName() );
        }

    if ( pRef && ( pRef->NodeKind() == NODE_HREF ))
    {
        // expand the href
        pRef->SemanticAnalysis( &MyContext );
        node_skl* pChild = pRef->GetChild();
        if (pChild && pChild->NodeKind() == NODE_INTERFACE)
        {
            pRef = new node_interface_reference((node_interface *)pRef->GetChild());
        }
    }

    // we must go on and process interface references; they will
    // control any recursing and eliminate the forward reference.
    if ( pRef )
        {
        pRef->SemanticAnalysis( &MyContext );

        node_skl * pParent = pParentCtxt->GetParent();
        if ( pParent )
            {
            // if we came from an interface, set the base interface
            if ( pParent->IsInterfaceOrObject() && pRef->NodeKind() == NODE_INTERFACE_REFERENCE )
                {
                ((node_interface *)pParent)->SetMyBaseInterfaceReference( pRef );
                }
            else // otherwise, probably an interface pointer
                {
                pParent->SetChild( pRef );
                }
            }
        }
    else
        {
        // incomplete types may only be used in certain contexts...
        MyContext.SetDescendantBits( HAS_INCOMPLETE_TYPE );
        }

    if ( MyContext.FindRecursiveContext( pRef ) )
        {
        MyContext.SetDescendantBits( HAS_RECURSIVE_DEF );
        MyContext.SetAncestorBits( IN_RECURSIVE_DEF );
        }
    MyContext.RejectAttributes();
    pParentCtxt->ReturnValues( MyContext );
    fBeingAnalyzed = FALSE;
}

// checking the void usage in dispinterface. 
// currently we only check:
// . void is not allowed as property or part of a structure. 
void node_base_type::CheckVoidUsageInDispinterface( SEM_ANALYSIS_CTXT * pContext )
{
    SEM_ANALYSIS_CTXT *     pCtxt = (SEM_ANALYSIS_CTXT *)
                                pContext->GetParentContext();
    node_skl *                pCur = pCtxt->GetParent();
    BOOL                     fHasPointer = FALSE;

    while ( pCur->NodeKind() != NODE_FIELD && pCur->NodeKind() != NODE_PROC )
        {
        if ( pCur->NodeKind() == NODE_POINTER )
            fHasPointer = TRUE;
        else
            {
            if ( pCur->NodeKind() != NODE_DEF )
                {
                RpcSemError( this, *pContext, NON_RPC_RTYPE_VOID, NULL );
                return;
                }
            }
        pCtxt   = (SEM_ANALYSIS_CTXT *) pCtxt->GetParentContext();
        pCur    = pCtxt->GetParent();        
        }

    // This is either a property or part of a structure. 
    if ( pCur->NodeKind() == NODE_FIELD )
        {
        if ( !fHasPointer )
            {
            SemError( this, *pContext, INVALID_VOID_IN_DISPINTERFACE, NULL );
            return;
            }
        }
}
void
node_base_type::CheckVoidUsage( SEM_ANALYSIS_CTXT * pContext )
{

    SEM_ANALYSIS_CTXT * pCtxt = (SEM_ANALYSIS_CTXT *)
                                pContext->GetParentContext();
    node_skl * pCur = pCtxt->GetParent();

    // we assume that we are in an RPC, so we are in the return type
    // or we are in the param list
    if (pContext->AnyAncestorBits( IN_FUNCTION_RESULT ) )
        {
        // check up for anything other than def below proc
        while ( pCur->NodeKind() != NODE_PROC )
            {
            if ( pCur->NodeKind() != NODE_DEF )
                {
                RpcSemError( this, *pContext, NON_RPC_RTYPE_VOID, NULL );
                return;
                }
            pCtxt   = (SEM_ANALYSIS_CTXT *) pCtxt->GetParentContext();
            pCur    = pCtxt->GetParent();
            }
        return;
        }

    // else param list...
    node_proc * pProc;
    node_param * pParam;

    // check up for anything other than def below proc
    // make sure the proc only has one param
    while ( pCur->NodeKind() != NODE_PARAM )
        {
        if ( pCur->NodeKind() != NODE_DEF )
            {
            RpcSemError( this, *pContext, NON_RPC_PARAM_VOID, NULL );
            return;
            }
        pCtxt   = (SEM_ANALYSIS_CTXT *) pCtxt->GetParentContext();
        pCur    = pCtxt->GetParent();
        }

    // now we know the param derives directly from void
    // assume the proc is the immediate parent of the param
    pParam  = ( node_param * ) pCur;
    pProc = ( node_proc * ) pCtxt->GetParentContext()->GetParent();

    MIDL_ASSERT ( pProc->NodeKind() == NODE_PROC );

    if ( ! IsTempName( pParam->GetSymName() ) )
        SemError( this, *pContext, VOID_PARAM_WITH_NAME, NULL );

    if ( pProc->GetNumberOfArguments() != 1 )
        SemError( this, *pContext, VOID_NON_FIRST_PARAM, NULL );

    // We know that the parameter is void.
    // So, chop it off to prevent complications from renaming etc.
    // and then using in a node_def in ILxlate.

    pProc->SetFirstMember( NULL );
    pProc->SetSibling( NULL );

}

void
node_base_type::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT   MyContext( this, pParentCtxt );

    CheckContextHandle( MyContext );

    CheckDeclspecAlign( MyContext );

    // warn about OUT const things
    if ( FInSummary( ATTR_CONST ) )
        {
        if ( MyContext.AnyAncestorBits(  UNDER_OUT_PARAM ) )
            RpcSemError( this, MyContext, CONST_ON_OUT_PARAM, NULL );
        else if ( MyContext.AnyAncestorBits( IN_FUNCTION_RESULT ) )
            RpcSemError( this, MyContext, CONST_ON_RETVAL, NULL );
        }

    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
    node_range_attr* pRange = ( node_range_attr* ) MyContext.ExtractAttribute(ATTR_RANGE);
    MyContext.ExtractAttribute(ATTR_RANGE);
    if ( pRange )
        {
        if ( pRange->GetMinExpr()->GetValue() > pRange->GetMaxExpr()->GetValue() )
            {
            SemError(this, MyContext, INCORRECT_RANGE_DEFN, 0);
            }
        }

    switch ( NodeKind() )
        {
        case NODE_FLOAT:
        case NODE_DOUBLE:
        case NODE_HYPER:
        case NODE_INT64:
        case NODE_LONGLONG:
            if ( pRange )
                {
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, 0 );
                }
            break;
        case NODE_INT3264:
            if ( MyContext.AnyAncestorBits( IN_LIBRARY ) )
                {
                SemError( this, MyContext, NO_SUPPORT_IN_TLB, 0 );
                }
            if ( pRange  &&  pCommand->Is64BitEnv() )
                {
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, 0 );
                }
            break;
        case NODE_INT:
            if ( MyContext.AnyAncestorBits( IN_FUNCTION_RESULT ) )
                RpcSemError( this, MyContext, NON_RPC_RTYPE_INT, NULL );
            else
                RpcSemError( this, MyContext, NON_RPC_PARAM_INT, NULL );

            break;
        case NODE_INT128:
        case NODE_FLOAT80:
        case NODE_FLOAT128:
            if ( pRange )
                {
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, 0 );
                }
            if ( MyContext.AnyAncestorBits( IN_LIBRARY ) )
                {
                SemError( this, MyContext, NO_SUPPORT_IN_TLB, 0 );
                }
            break;
        case NODE_VOID:
            MyContext.SetDescendantBits( DERIVES_FROM_VOID );
            // if we are in an RPC, then we must be THE return type,
            // or we must be the sole parameter, which must be tempname'd
            // (except that void * is allowed in [iid_is] constructs)
            if (MyContext.AnyAncestorBits( IN_RPC ) && !MyContext.AnyAncestorBits( IN_INTERFACE_PTR ) )
                CheckVoidUsage( &MyContext );
            if ( MyContext.AnyAncestorBits( IN_DISPINTERFACE ) )
                CheckVoidUsageInDispinterface( &MyContext );
            break;
        case NODE_HANDLE_T:
            MyContext.SetDescendantBits( HAS_HANDLE );
            if (MyContext.AnyAncestorBits( IN_PARAM_LIST ) )
                {
                SEM_ANALYSIS_CTXT * pParamCtxt;
                node_param * pParamNode;

                pParamCtxt = (SEM_ANALYSIS_CTXT *)
                             pParentCtxt->FindAncestorContext( NODE_PARAM );
                pParamNode = (node_param *) pParamCtxt->GetParent();
                if ( MyContext.AnyAncestorBits( IN_RPC ) )
                    pParamNode->HandleKind  = HDL_PRIM;

                if ( MyContext.AnyAncestorBits( UNDER_OUT_PARAM ) &&
                        !MyContext.AnyAncestorBits( UNDER_IN_PARAM ) )
                    RpcSemError( this, MyContext, HANDLE_T_CANNOT_BE_OUT, NULL );

                if ( MyContext.AnyAncestorBits( IN_HANDLE ) )
                    {
                    RpcSemError( this, MyContext, GENERIC_HDL_HANDLE_T, NULL );
                    }

                node_skl * pParamBasic = pParamNode->GetBasicType();
                if ( pParamBasic->NodeKind() == NODE_POINTER )
                    {
                    if ( pParamBasic->GetBasicType()->NodeKind() != NODE_HANDLE_T )
                        RpcSemError( pParamNode, *pParamCtxt, HANDLE_T_NO_TRANSMIT, NULL );
                    }
                }
            break;
        default:
            break;
        }

    MyContext.RejectAttributes();

    pParentCtxt->ReturnValues( MyContext );
};

BOOL
node_id::IsConstantString()
{
    // check for *, and const stringable type below
    node_skl * pBasic  = GetBasicType();

    if ( pBasic->NodeKind() != NODE_POINTER )
        return FALSE;

    node_skl * pParent = pBasic;
    node_skl * pChild  = pParent->GetChild();
    BOOL       fConst  = FALSE;

    while ( pChild )
        {
        // if we reached a stringable type, report it's constness
        if ( pChild->IsStringableType() || ( pChild->NodeKind() == NODE_VOID ) )
            {
            return fConst || pParent->FInSummary( ATTR_CONST );
            }

        // skip only typedefs looking for the base type
        if ( pChild->NodeKind() != NODE_DEF )
            return FALSE;

        // catch intervening const's
        if ( pParent->FInSummary( ATTR_CONST ) )
            fConst = TRUE;

        pParent = pChild;
        pChild  = pParent->GetChild();
        }

    return FALSE;
}


void
node_id::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    BOOL fIsConstant;
    node_constant_attr * pID = (node_constant_attr *) MyContext.ExtractAttribute(ATTR_ID);
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRING);

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }

        
    CheckDeclspecAlign( MyContext );


    /*
    // NishadM: Stricter type checking
    if ( pID && pID->GetExpr()->AlwaysGetType() )
        {
        if ( !( ( node_base_type*) pID->GetExpr()->GetType() )->IsCompatibleType( ts_FixedPoint ) )
            {
            SemError( this, MyContext, EXPR_INCOMPATIBLE_TYPES, NULL);
            }
        }

    if ( pHC && pHC->GetExpr()->AlwaysGetType() )
        {
        if ( !( ( node_base_type*) pHC->GetExpr()->GetType() )->IsCompatibleType( ts_UnsignedFixedPoint ) )
            {
            SemError( this, MyContext, EXPR_INCOMPATIBLE_TYPES, NULL);
            }
        }

    if ( pHSC && pHSC->GetExpr()->AlwaysGetType() )
        {
        if ( !( ( node_base_type*) pHSC->GetExpr()->GetType() )->IsCompatibleType( ts_UnsignedFixedPoint ) )
            {
            SemError( this, MyContext, EXPR_INCOMPATIBLE_TYPES, NULL);
            }
        }
    */

    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }
    MyContext.ExtractAttribute(ATTR_HIDDEN);
    GetChild()->SemanticAnalysis( &MyContext );

    fIsConstant = FInSummary( ATTR_CONST ) ||
        IsConstantString() ||
        GetChild()->FInSummary( ATTR_CONST );

    if (pID)
    {
        SEM_ANALYSIS_CTXT * pIntfCtxt = (SEM_ANALYSIS_CTXT *)
                                            MyContext.GetInterfaceContext();
        node_interface * pIntf = (node_interface *) pIntfCtxt->GetParent();
        if (!pIntf->AddId(pID->GetExpr()->GetValue(), GetSymName()))
            SemError( this, MyContext, DUPLICATE_IID, NULL);
        if (fIsConstant)
            {
            SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
            }
    }

    // don't allow instantiation of data
    if ( GetChild()->NodeKind() != NODE_PROC )
        {
        if ( !FInSummary( ATTR_EXTERN ) &&
                !FInSummary( ATTR_STATIC ) &&
                !fIsConstant )
            SemError( this, MyContext, ACTUAL_DECLARATION, NULL );

        // error here if dce for extern or static, too
        if ( !GetInitList() || !fIsConstant )
            SemError( this, MyContext, ILLEGAL_OSF_MODE_DECL, NULL );
        }

    if ( pInit )
        {
        EXPR_CTXT InitCtxt( &MyContext );
        node_skl * pBasicType = GetBasicType();
        node_skl * pInitType = NULL;

        pInit->ExprAnalyze( &InitCtxt );

        if ( InitCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
            TypeSemError( this,
                MyContext,
                EXPR_NOT_EVALUATABLE,
                NULL );

        pInitType = pInit->GetType();
        if ( pInitType && !pInitType->IsBasicType() )
            pInitType = pInitType->GetBasicType();

        if ( pBasicType &&
                pInitType &&
                pBasicType->IsBasicType() &&
                pInitType->IsBasicType() )
            {
            if ( !((node_base_type *)pBasicType)
                    ->RangeCheck( pInit->GetValue() ) )
                TypeSemError( this, MyContext, VALUE_OUT_OF_RANGE, NULL );
            }

        if ( !pInit->IsConstant() )
            TypeSemError( this, MyContext, RHS_OF_ASSIGN_NOT_CONST, NULL );

        }

    if ( MyContext.AnyAncestorBits( HAS_OLEAUTOMATION )|| MyContext.AnyAncestorBits( IN_DISPINTERFACE ) )
        {
        if ( !IsOLEAutomationCompliant( this ) )
            {
            SemError(this, MyContext, NOT_OLEAUTOMATION_INTERFACE, NULL);
            }
        }

    // disallow forward references on declarations
    if ( MyContext.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
        {
        if (! MyContext.AnyAncestorBits( IN_LIBRARY ))
            SemError( this, MyContext, UNDEFINED_SYMBOL, NULL );
        MyContext.ClearDescendantBits( HAS_INCOMPLETE_TYPE );
        }
    MyContext.ClearDescendantBits( HAS_RECURSIVE_DEF );

    pParentCtxt->ReturnValues( MyContext );
}

void
node_label::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    if ( MyContext.ExtractAttribute(ATTR_IDLDESCATTR) )
        {
        SemError(this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, 0);
        }
    if ( MyContext.ExtractAttribute(ATTR_VARDESCATTR) )
        {
        SemError(this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, 0);
        }
    
    if ( MyContext.ExtractAttribute(ATTR_ID) )
        {
        SemError(this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, 0);
        }
    
    MyContext.ExtractAttribute(ATTR_HIDDEN);    
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT );
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    // check for illegal member attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_RETVAL:
            case MATTR_VARARG:
            case MATTR_SOURCE:
            case MATTR_DEFAULTVTABLE:
            case MATTR_RESTRICTED:
            case MATTR_OPTIONAL:
            case MATTR_PREDECLID:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_IMMEDIATEBIND:
            case MATTR_USESGETLASTERROR:
                break;
            case MATTR_REPLACEABLE:
            default:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }
        

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }
        
    CheckDeclspecAlign( MyContext );

    if ( pExpr )
        {
        EXPR_CTXT ExprCtxt( &MyContext );

        pExpr->ExprAnalyze( &ExprCtxt );

        if ( ExprCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
            TypeSemError( this,
                MyContext,
                EXPR_NOT_EVALUATABLE,
                NULL );
        }

    pParentCtxt->ReturnValues( MyContext );
};

#define DIRECT_NONE     0
#define DIRECT_IN       1
#define DIRECT_OUT      2
#define DIRECT_PARTIAL_IGNORE (DIRECT_IN | DIRECT_OUT | 4 )
#define DIRECT_IN_OUT   (DIRECT_IN | DIRECT_OUT)

void
node_param::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    unsigned short Direction = DIRECT_NONE;
    char * pName = GetSymName();
    node_skl * pChild = GetChild();
    BOOL NoDirection = FALSE;
    
    MyContext.SetAncestorBits( IN_PARAM_LIST );
    MyContext.MarkImportantPosition();
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    MyContext.ExtractAttribute(ATTR_IDLDESCATTR);
    
    if ( MyContext.ExtractAttribute(ATTR_FLCID) )
        {
        LCID();
        }
              
    CheckDeclspecAlign( MyContext );

    // check for illegal member attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_OPTIONAL:
                {
                node_skl * pBase = this;
                do {
                    pBase = pBase->GetChild()->GetBasicType();
                } while (NODE_ARRAY == pBase->NodeKind() || NODE_POINTER == pBase->NodeKind());

                if ( !pBase->GetSymName() || 
                     ( (0 != _stricmp(pBase->GetSymName(), "tagVARIANT") ) 
                       && FNewTypeLib() 
                       && ( MyContext.AnyAncestorBits( HAS_OLEAUTOMATION )
                            || MyContext.AnyAncestorBits( IN_DISPINTERFACE ) ) ) )
                    {
                    SemError(this, MyContext, INAPPLICABLE_OPTIONAL_ATTRIBUTE, pMA->GetNodeNameString());
                    }

                if ( ! MyContext.AnyAncestorBits( IN_LIBRARY ) )
                {
                    SemError(this, MyContext, OPTIONAL_OUTSIDE_LIBRARY, NULL);
                }
                Optional();
                break;
                }
            case MATTR_RETVAL:
                Retval();
                break;
            case MATTR_RESTRICTED:
            case MATTR_SOURCE:
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_VARARG:
            case MATTR_DEFAULTVTABLE:
            case MATTR_PREDECLID:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_USESGETLASTERROR:
            case MATTR_IMMEDIATEBIND:
                break;
            case MATTR_REPLACEABLE:
            default:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }

    node_constant_attr * pcaDefaultValue = (node_constant_attr *)MyContext.ExtractAttribute(ATTR_DEFAULTVALUE);
    if ( pcaDefaultValue )
        {
        // UNDONE: Check that this attribute has a legal default value

        // We already have an [optional] flag. MIDL should issue a warning 
        // that we shouldn't have both.
        if ( IsOptional() )
        {
            SemError( this, MyContext, DEFAULTVALUE_WITH_OPTIONAL, 0);
        }
        pParentCtxt->SetDescendantBits( HAS_DEFAULT_VALUE );
        Optional();
        }

    if ( MyContext.ExtractAttribute(ATTR_IN) )
        {
        pParentCtxt->SetDescendantBits( HAS_IN );
        MyContext.SetAncestorBits( UNDER_IN_PARAM );
        Direction |= DIRECT_IN;
        }
    if ( MyContext.ExtractAttribute(ATTR_OUT) )
        {
        pParentCtxt->SetDescendantBits( HAS_OUT );
        MyContext.SetAncestorBits( UNDER_OUT_PARAM );
        Direction |= DIRECT_OUT;
        }
   
    if ( MyContext.ExtractAttribute( ATTR_PARTIAL_IGNORE ) )
        {
        pCommand->GetNdrVersionControl().SetHasPartialIgnore();

        pParentCtxt->SetDescendantBits( HAS_PARTIAL_IGNORE );
        MyContext.SetAncestorBits( UNDER_PARTIAL_IGNORE_PARAM );
        
        if ( !( Direction & DIRECT_IN ) || !( Direction & DIRECT_OUT ) )
            {
            SemError( this, MyContext, PARTIAL_IGNORE_IN_OUT, GetSymName() );
            }
        
        if ( FInSummary( ATTR_STRING )
             && ! ( FInSummary( ATTR_SIZE ) || FInSummary( ATTR_MAX) ) )
            {
            SemError( this, MyContext, UNSIZED_PARTIAL_IGNORE, GetSymName() );
            }

        Direction |= DIRECT_PARTIAL_IGNORE;   
        }

    if ( IsExtraStatusParam() )
        MyContext.SetAncestorBits( UNDER_HIDDEN_STATUS );

    // [retval] parameter must be on an [out] parameter and it
    // must be the last parameter in the list
    if (IsRetval() && (Direction != DIRECT_OUT || GetSibling() != NULL))
        SemError(this, MyContext, INVALID_USE_OF_RETVAL, NULL );

    // if the parameter has no IN or OUT, it is an IN parameter by default.
    // if so, issue a warning message
    // REVIEW: No warning is being issued.  What about hidden status params
    //         which are neither in nor out?
    if ( (Direction == DIRECT_NONE) &&
            MyContext.AnyAncestorBits( IN_RPC ) )
        {
        NoDirection = TRUE;
        MyContext.SetAncestorBits( UNDER_IN_PARAM );
        Direction |= DIRECT_IN;
        }

    // warn about OUT const things
    if ( ( Direction & DIRECT_OUT ) &&
            FInSummary( ATTR_CONST ) )
        RpcSemError( this, MyContext, CONST_ON_OUT_PARAM, NULL );


    if ( MyContext.FInSummary(ATTR_HANDLE) )
        {
        HandleKind |= HDL_GEN;
        fAppliedHere = 1;
        }

    if ( MyContext.FInSummary(ATTR_CONTEXT) )
        {
        HandleKind |= HDL_CTXT;
        fAppliedHere = 1;
        }

    if (HandleKind != HDL_NONE)
        MyContext.SetDescendantBits( HAS_HANDLE | HAS_CONTEXT_HANDLE );

    // notice comm and fault statuses; the attributes are extracted by
    // the error_status_t
    if ( MyContext.FInSummary( ATTR_COMMSTAT ) )
        {
        Statuses |= STATUS_COMM;
        }
    if ( MyContext.FInSummary( ATTR_FAULTSTAT ) )
        {
        Statuses |= STATUS_FAULT;
        }

    acf_attr *pDRtag = (acf_attr *) MyContext.ExtractAttribute( ATTR_DRTAG );
    acf_attr *pStag  = (acf_attr *) MyContext.ExtractAttribute( ATTR_STAG );
    acf_attr *pRtag  = (acf_attr *) MyContext.ExtractAttribute( ATTR_RTAG );

    if ( pDRtag )
        {
        if ( !( Direction & DIRECT_IN ) )
            AcfError(pDRtag, this, MyContext, IN_TAG_WITHOUT_IN, NULL);

        SetHasCSDRTag();
        MyContext.SetDescendantBits( HAS_DRTAG );
        }

    if ( pStag )
        {
        if ( !( Direction & DIRECT_IN ) )
            AcfError(pStag, this, MyContext, IN_TAG_WITHOUT_IN, NULL);

        SetHasCSSTag();
        MyContext.SetDescendantBits( HAS_STAG );
        }

    if ( pRtag )
        {
        if ( !( Direction & DIRECT_OUT ) )
            AcfError(pRtag, this, MyContext, OUT_TAG_WITHOUT_OUT, NULL);
    
        SetHasCSRTag();
        MyContext.SetDescendantBits( HAS_RTAG );
        }

    acf_attr * pForceAllocate = (acf_attr *) MyContext.ExtractAttribute( ATTR_FORCEALLOCATE );
    if ( pForceAllocate )
        {
        // we allow force allocation on [in] and [in,out] parameters. server allocate 
        if ( ! (Direction & DIRECT_IN ) )
            AcfError( pForceAllocate, this, MyContext, OUT_ONLY_FORCEALLOCATE, NULL );

        MyContext.SetDescendantBits ( HAS_FORCEALLOCATE );
    	pCommand->GetNdrVersionControl().SetHasForceAllocate();
        }
        
    pChild->SemanticAnalysis( &MyContext );

    // OUT parameters should be pointers or arrays.
    // Don't use HAS_POINTER or arrays as it may come from a field.

    if ( ( Direction & DIRECT_PARTIAL_IGNORE ) == DIRECT_PARTIAL_IGNORE )
        {   
        node_skl *pPointer = GetNonDefChild();

        if ( ( pPointer->NodeKind() != NODE_POINTER ) ||
             MyContext.AnyDescendantBits((DESCENDANT_FLAGS) HAS_PIPE) )
            {
            SemError( this, MyContext, PARTIAL_IGNORE_UNIQUE, NULL );
            }

        node_skl *pPointee = pPointer->GetNonDefChild();

        if ( pPointee->IsStructOrUnion() )
            if ( ((node_su_base *) pPointee)->HasConformance() )
                SemError( this, MyContext, UNSIZED_PARTIAL_IGNORE, NULL );

        }

    else if ( (Direction & DIRECT_OUT) && !(
            GetNonDefChild()->IsPtrOrArray()
            || MyContext.AnyDescendantBits((DESCENDANT_FLAGS) HAS_PIPE)))
        {
        SemError( this, MyContext, NON_PTR_OUT, NULL );
        }

    if ( pForceAllocate )
        {
        if ( MyContext.AnyDescendantBits((DESCENDANT_FLAGS) HAS_PIPE) )
            AcfError( pForceAllocate, this, MyContext, FORCEALLOCATE_ON_PIPE, NULL );
        }
        
    // if no direction was specified, and we are not just void or a hidden
    // status parameter, then error
    if ( NoDirection )
        {
        pParentCtxt->SetDescendantBits( HAS_IN );
        
        if (     !MyContext.AnyDescendantBits( DERIVES_FROM_VOID ) 
             &&  !IsExtraStatusParam() )
            {
            RpcSemError( this, MyContext, NO_EXPLICIT_IN_OUT_ON_PARAM, NULL );
            }
        }

    // disallow forward references as union members
    if ( MyContext.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
        {
        if (! MyContext.AnyAncestorBits( IN_LIBRARY ))
            SemError( this, MyContext, UNDEFINED_SYMBOL, NULL );
        MyContext.ClearDescendantBits( HAS_INCOMPLETE_TYPE );
        }
    MyContext.ClearDescendantBits( HAS_RECURSIVE_DEF );

    // disallow  module as params
    
    if ( GetBasicType()->NodeKind() == NODE_MODULE )
        {
        SemError( this, MyContext, DERIVES_FROM_COCLASS_OR_MODULE, 0);
        }
    else if (GetBasicType()->NodeKind() == NODE_POINTER)
        {
        if (GetBasicType()->GetChild()->NodeKind() == NODE_MODULE )
            {
            SemError( this, MyContext, DERIVES_FROM_COCLASS_OR_MODULE, 0);
            }
        }

    if ( GetBasicType()->NodeKind() == NODE_INTERFACE || 
         GetBasicType()->NodeKind() == NODE_DISPINTERFACE )
    {
        SemError( this, MyContext, INTF_NON_POINTER, 0);
    }
    

    // compound types may not be declared in param lists
    NODE_T ChildKind = pChild->NodeKind();

    if ( ( ChildKind == NODE_ENUM )
            || ( ChildKind == NODE_STRUCT )
            || ( ChildKind == NODE_UNION ) )
        {
        if ( IsDef() )
            SemError( this, MyContext, COMP_DEF_IN_PARAM_LIST, NULL );
        }

    // things not allowed in an RPC
    if ( MyContext.AnyAncestorBits( IN_RPC | IN_LIBRARY ) )
        {
        if ( strcmp( pName, "..." ) == 0 )
            SemError( this, MyContext, PARAM_IS_ELIPSIS, NULL );

        if ( IsTempName( pName ) )
            RpcSemError( this, MyContext, ABSTRACT_DECL, NULL );

        }

    if ( ( HandleKind != HDL_NONE ) &&
            ( Direction & DIRECT_IN ) )
        fBindingParam = TRUE;

    if ( ( HandleKind == HDL_CTXT ) &&
            MyContext.AnyDescendantBits( HAS_TRANSMIT_AS ) )
        RpcSemError( this, MyContext, CTXT_HDL_TRANSMIT_AS, NULL );

    if ( MyContext.AnyAncestorBits( HAS_OLEAUTOMATION ) || MyContext.AnyAncestorBits( IN_DISPINTERFACE ) ) 
        {
        // check the child type instead of NODE_PARAM directly. nt bug #371499
        if ( !IsOLEAutomationCompliant( GetBasicType() ) )
            {
            SemError(this, MyContext, NOT_OLEAUTOMATION_INTERFACE, NULL);
            }
        }

    // don't allow functions as params
    if ( MyContext.AnyDescendantBits( HAS_FUNC ) &&
            MyContext.AllAncestorBits( IN_INTERFACE | IN_RPC ) )
        RpcSemError( this, MyContext, BAD_CON_PARAM_FUNC, NULL );

    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }
    if ( ( Direction & DIRECT_OUT ) && MyContext.GetCorrelationCount() )
        {
        MyContext.SetDescendantBits( HAS_CLIENT_CORRELATION );
        }
    if ( ( Direction & DIRECT_IN ) && MyContext.GetCorrelationCount() )
        {
        MyContext.SetDescendantBits( HAS_SERVER_CORRELATION );
        }

    if ( MyContext.AnyAncestorBits( HAS_ASYNCHANDLE ) && 
            MyContext.AnyDescendantBits( (DESCENDANT_FLAGS) HAS_PIPE ) && 
                pChild->GetNonDefSelf()->NodeKind() != NODE_POINTER )
        {
        SemError(this, MyContext, ASYNC_PIPE_BY_REF, GetSymName() );
        }

    // This is completely banned with the new transfer syntax.
    if ( pCommand->NeedsNDR64Run() )
        {
        if ( MyContext.AnyDescendantBits( HAS_UNSAT_REP_AS ) )
            {
            RpcSemError( this, MyContext, UNSPECIFIED_EMBEDDED_REPRESENT_AS_NOT_SUPPORTED, NULL );
            }        
        }

    pParentCtxt->ReturnValues( MyContext );
}

void
node_file::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    MEM_ITER MemIter( this );
    node_skl * pN;
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );

    if ( ImportLevel == 0 )
        {
        MyContext.SetAncestorBits( IN_INTERFACE );
        }
#ifdef ReducedImportSemAnalysis
    else
        return;
#endif


    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        // each interface node gets a fresh context
        MyContext.SetInterfaceContext( &MyContext );
        // allow echo string and midl_grama outside library block,
        // even in mktyplib compatible mode
        if ( ( 0 == ImportLevel )
             && ( NODE_LIBRARY != pN->NodeKind() )
             && ( NODE_ECHO_STRING != pN->NodeKind() ) 
             && ( NODE_MIDL_PRAGMA != pN->NodeKind() )
             && ( pCommand->IsSwitchDefined(SWITCH_MKTYPLIB ) ) )
            {
            SEM_ANALYSIS_CTXT DummyContext( pN, &MyContext );
            SemError(pN, DummyContext, ILLEGAL_IN_MKTYPLIB_MODE, NULL);
            }
        pN->SemanticAnalysis( &MyContext );
        };

    pParentCtxt->ReturnValues( MyContext );

};

// for fault_status and comm_status
#define NOT_SEEN        0
#define SEEN_ON_RETURN  1
#define SEEN_ON_PARAM   2

void
node_proc::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    node_param*         pN;
    node_optimize*      pOptAttr;
    acf_attr*           pAttr;
    ATTR_T              CallingConv;

    MEM_ITER            MemIter( this );
    SEM_ANALYSIS_CTXT   MyContext( this, pParentCtxt );
    SEM_ANALYSIS_CTXT*  pIntfCtxt = (SEM_ANALYSIS_CTXT *) MyContext.GetInterfaceContext();
    node_interface*     pIntf = (node_interface *) pIntfCtxt->GetParent();
    node_entry_attr*    pEntry = NULL;
    node_base_attr*     pAttrAsync      = MyContext.ExtractAttribute( ATTR_ASYNC );

    unsigned short Faultstat    = NOT_SEEN;
    unsigned short Commstat     = NOT_SEEN;
    unsigned short OpBits       = MyContext.GetOperationBits();

    BOOL fNoCode        = FALSE;
    BOOL fCode          = FALSE;
    BOOL Skipme         = FALSE;
    BOOL fNonOperation  = FALSE;
    BOOL fEncode        = (NULL != MyContext.ExtractAttribute( ATTR_ENCODE ));
    BOOL fDecode        = (NULL != MyContext.ExtractAttribute( ATTR_DECODE ));
    // Use bitwise or because otherwise the C/C++ compiler will incorrectly 
    // short-circuit the call to ExtractAttribute(ATTR_DECODE).
    BOOL HasPickle      = fEncode | fDecode;
    BOOL fExpHdlAttr    = FALSE;
    BOOL fMaybe         = OpBits & OPERATION_MAYBE;
    BOOL fMessage       = OpBits & OPERATION_MESSAGE;
    BOOL fBindingFound  = FALSE;

    BOOL fProcIsCallback= (NULL != MyContext.ExtractAttribute( ATTR_CALLBACK ));
    BOOL fLocal         = (NULL != MyContext.ExtractAttribute( ATTR_LOCAL ));
    BOOL fNotify        = (NULL != MyContext.ExtractAttribute( ATTR_NOTIFY ));
    BOOL fNotifyFlag    = (NULL != MyContext.ExtractAttribute( ATTR_NOTIFY_FLAG ));

    node_skl*           pRet            = GetReturnType();
    NODE_T              BasicChildKind  = pRet->GetBasicType()->NodeKind();
    node_call_as*       pCallAs         = (node_call_as *) MyContext.ExtractAttribute( ATTR_CALL_AS );
    acf_attr*           pEnableAllocate = (acf_attr *) MyContext.ExtractAttribute( ATTR_ENABLE_ALLOCATE );
    node_constant_attr* pID             = (node_constant_attr *) MyContext.ExtractAttribute(ATTR_ID);
    node_constant_attr* pHC             = (node_constant_attr *) MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    node_constant_attr* pHSC            = (node_constant_attr *) MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    node_text_attr*     pHelpStr        = (node_text_attr *) MyContext.ExtractAttribute(ATTR_HELPSTRING);
    bool                fAddExplicitHandle = false;
    long                nAfterLastOptionalParam = 0;
    node_cs_tag_rtn *   pCSTagAttr = (node_cs_tag_rtn *) MyContext.ExtractAttribute( ATTR_CSTAGRTN );
 
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    MyContext.ExtractAttribute(ATTR_FUNCDESCATTR);
    MyContext.ExtractAttribute( ATTR_HIDDEN );

    fHasDeny = pCommand->IsSwitchDefined( SWITCH_ROBUST );

    if (MyContext.AnyAncestorBits( IN_MODULE ))
    {
        pEntry = (node_entry_attr *) MyContext.ExtractAttribute( ATTR_ENTRY );
        if (pEntry)
        {

            if (pEntry->IsNumeric())
            {
                char * szEntry = (char *)pEntry->GetID();
                if ( ((LONG_PTR) szEntry) > 0xFFFF )
                {
                    SemError( this, MyContext, BAD_ENTRY_VALUE, NULL);
                }
            }
            else
            {
                char * szEntry = pEntry->GetSz();
                if ( ((LONG_PTR) szEntry) <= 0xFFFF )
                {
                    SemError( this, MyContext, BAD_ENTRY_VALUE, NULL);
                }
            }
        }
        else
        {
            SemError(this, MyContext, BAD_ENTRY_VALUE, NULL);
        }
    }

    bool fBindable = false;
    bool fPropSomething = false;
    bool fPropGet = false;
    int  nchSkip = 0;
    bool fHasVarArg = false;
    // check for illegal member attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_BINDABLE:
                fBindable = TRUE;
                break;
            case MATTR_PROPGET:
                nchSkip = 4;
                fPropSomething = TRUE;
                fPropGet = TRUE;
                break;
            case MATTR_PROPPUT:
                nchSkip = 4;
                fPropSomething = TRUE;
                break;
            case MATTR_PROPPUTREF:
                nchSkip = 7;
                fPropSomething = TRUE;
                break;
            case MATTR_VARARG:
                fHasVarArg = true;
                break;
            case MATTR_RESTRICTED:
            case MATTR_SOURCE:
                if ( MyContext.AnyAncestorBits( IN_MODULE ))
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }                    
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_DEFAULTVTABLE:
            case MATTR_IMMEDIATEBIND:
            case MATTR_REPLACEABLE:
                break;
            case MATTR_READONLY:
            case MATTR_USESGETLASTERROR:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            
            case MATTR_RETVAL:
            case MATTR_OPTIONAL:
            case MATTR_PREDECLID:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }

    if (pID)
    {
        if (!pIntf->AddId(pID->GetExpr()->GetValue(),GetSymName() + nchSkip))
            SemError( this, MyContext, DUPLICATE_IID, NULL);
    }

    if (fBindable && !fPropSomething)
        SemError(this, MyContext, INVALID_USE_OF_BINDABLE, NULL);

    if ( pEnableAllocate )
        pIntf->SetHasProcsWithRpcSs();

    fNonOperation = !pParentCtxt->GetParent()->IsInterfaceOrObject();

    if ( !GetCallingConvention( CallingConv ) )
        SemError( this, MyContext, MULTIPLE_CALLING_CONVENTIONS, NULL );

    // locally applied [code] attribute overrides global [nocode] attribute
    fNoCode = (NULL != MyContext.ExtractAttribute( ATTR_NOCODE ));
    fCode   = (NULL != MyContext.ExtractAttribute( ATTR_CODE ));
    if ( fCode && fNoCode )
        {
        SemError( this, MyContext, CODE_NOCODE_CONFLICT, NULL );
        }

    fNoCode = fNoCode || pIntfCtxt->FInSummary( ATTR_NOCODE );
    fNoCode = !fCode && fNoCode;

    if ( fNoCode && pCommand->GenerateSStub() )
        RpcSemError( this, MyContext, NOCODE_WITH_SERVER_STUBS, NULL );

    // do my attribute parsing...

    fObjectProc = MyContext.ExtractAttribute( ATTR_OBJECT ) || pIntfCtxt->FInSummary( ATTR_OBJECT );
    SetObjectProc( fObjectProc );
    if ( fObjectProc )
        {
        if ( pCommand->GetEnv() != ENV_WIN32  &&
             pCommand->GetEnv() != ENV_WIN64  &&
             !pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
            {
            // REVIEW: We can eliminate the warning if object procs can be
            //         in win64.  It was necessary for dos, mac, etc.
            SemError( this, MyContext, OBJECT_PROC_MUST_BE_WIN32, NULL );
            }
        if ( pEnableAllocate )
            {
            AcfError( pEnableAllocate, this, MyContext, INAPPROPRIATE_ON_OBJECT_PROC, NULL );
            }
        if ( HasPickle )
            {
            SemError( this, MyContext, PICKLING_INVALID_IN_OBJECT, NULL );
            }
        }

    bool fAsync = ( MyContext.AnyAncestorBits( HAS_ASYNCHANDLE ) != 0 ) || ( pAttrAsync != 0 );
    if ( fAsync )
        {
        MyContext.SetAncestorBits( HAS_ASYNCHANDLE );
        // because we don't support async retry now, we need to issue an
        // explicit warning about this. 
        if ( pCommand->NeedsNDR64Run() && !pCommand->NeedsNDRRun() )
            SemError( this, MyContext, ASYNC_NDR64_ONLY, 0 );
        }
        

    // check return types for non object proc.s with maybe, message
    // object proc.s should have HRESULT. This is checked later.
    if ( ( fMessage || fMaybe ) && !fObjectProc )
        {
        if ( BasicChildKind != NODE_VOID )
            {
            if ( BasicChildKind != NODE_E_STATUS_T )
                {
                SemError( this, MyContext, MAYBE_NO_OUT_RETVALS, NULL );
                }
            else
                {
                unsigned long   ulCommStat = (unsigned long) ( MyContext.FInSummary(ATTR_COMMSTAT) ? 1 : 0 ),
                                ulFaultStat = (unsigned long) ( MyContext.FInSummary(ATTR_FAULTSTAT) ? 1 : 0);
                if ( ulCommStat ^ ulFaultStat )
                    {
                    SemError( this, MyContext, ASYNC_INCORRECT_ERROR_STATUS_T, 0 );
                    }
                }
            }
        }

    // check call_as characteristics
    if ( pCallAs )
        {
        node_proc*  pCallType = pCallAs->GetCallAsType();

        // if we don't have it yet, search for the call_as target
        if ( !pCallType )
            {
            // search the proc table for the particular proc
            SymKey SKey( pCallAs->GetCallAsName(), NAME_PROC );

            pCallType = ( node_proc* ) pIntf->GetProcTbl()->SymSearch( SKey );

            if ( !pCallType )
                {
                if ( pIntfCtxt->FInSummary( ATTR_OBJECT ) )
                    AcfError( pCallAs,
                        this,
                        MyContext,
                        CALL_AS_UNSPEC_IN_OBJECT,
                        pCallAs->GetCallAsName() );
                }
            else
                {
                pCallAs->SetCallAsType(pCallType);
                }
            }

        // now we should have the call_as type
        if ( pCallType )        // found the call_as proc
            {
            ((node_proc *)pCallType)->fCallAsTarget = TRUE;

            if ( ( pCallType->NodeKind() != NODE_PROC )     ||
                    !pCallType->FInSummary( ATTR_LOCAL ) )
                AcfError( pCallAs,
                    this,
                    MyContext,
                    CALL_AS_NON_LOCAL_PROC,
                    pCallType->GetSymName() );

            // insert pCallType into pCallAsTable
            if ( pCallAsTable->IsRegistered( pCallType ) )
                // error
                AcfError( pCallAs,
                    this,
                    MyContext,
                    CALL_AS_USED_MULTIPLE_TIMES,
                    pCallType->GetSymName() );
            else
                pCallAsTable->Register( pCallType );

            }
            SetCallAsType( pCallType );
        }


    // local procs don't add to count
    Skipme = fLocal;
    if ( Skipme )
        {
        SemError( this, MyContext, LOCAL_ATTR_ON_PROC, NULL );
        }

    Skipme = Skipme || pIntfCtxt->FInSummary( ATTR_LOCAL );
    if ( Skipme )
        {
        MyContext.SetAncestorBits( IN_LOCAL_PROC );
        }

    // do my attribute parsing...

    // check for the [explicit_handle] attribute
    fExpHdlAttr = (NULL != MyContext.ExtractAttribute( ATTR_EXPLICIT ));
    fExpHdlAttr = fExpHdlAttr || pIntfCtxt->FInSummary( ATTR_EXPLICIT );

    // we are in an RPC if we are in the main interface, its not local, and
    // we are not a typedef of a proc...
    if  (
        (ImportLevel == 0) &&
        !MyContext.FindAncestorContext( NODE_DEF ) &&
        pIntf &&
        !Skipme
        )
        {
        MyContext.SetAncestorBits( IN_RPC );
        }
    else
        {
        MyContext.ClearAncestorBits( IN_RPC );
        }

    // our optimization is controlled either locally or for the whole interface
    if ( ( pOptAttr = (node_optimize *) MyContext.ExtractAttribute( ATTR_OPTIMIZE ) ) != 0 )
        {
        SetOptimizationFlags( pOptAttr->GetOptimizationFlags() );
        SetOptimizationLevel( pOptAttr->GetOptimizationLevel() );
        }
    else
        {
        SetOptimizationFlags( pIntf->GetOptimizationFlags() );
        SetOptimizationLevel( pIntf->GetOptimizationLevel() );
        }

    unsigned long   fOptimize = GetOptimizationFlags();
    if ( fOptimize & OPTIMIZE_INTERPRETER )
        {
        MyContext.SetAncestorBits( IN_INTERPRET );
        }

    HasPickle = HasPickle || pIntfCtxt->FInSummary( ATTR_ENCODE )
                || pIntfCtxt->FInSummary( ATTR_DECODE );

    if ( HasPickle && pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
        {
        if ( fOptimize & OPTIMIZE_INTERPRETER_V2 )
            {
            pCommand->GetNdrVersionControl().SetHasOicfPickling();
            }
        else
            {
            SemError( this, MyContext, ROBUST_PICKLING_NO_OICF, 0 );
            }
        }

    BOOL HasCommFault = MyContext.FInSummary( ATTR_COMMSTAT )
                        || MyContext.FInSummary( ATTR_FAULTSTAT );

    if ( HasPickle && HasCommFault )
        {
        if ( ! ( fOptimize & OPTIMIZE_INTERPRETER_V2 ) )
            {
            SemError( this, MyContext, COMMFAULT_PICKLING_NO_OICF, 0 );
            }
        }

    // determine the proc number (local procs don't get a number)
    if ( !fNonOperation )
        {
        if ( !fLocal )
            {
            if ( fProcIsCallback )
                {
                ProcNum = ( pIntf ->GetCallBackProcCount() )++;
                RpcSemError( this, MyContext, CALLBACK_NOT_OSF, NULL );
                }
            else
                {
                ProcNum = ( pIntf ->GetProcCount() )++;
                }
            }
        // object procs need the procnum set for local procs, too
        else if ( fObjectProc && fLocal )
            {
            ProcNum = ( pIntf ->GetProcCount() )++;
            }
        }
    else if ( MyContext.AnyAncestorBits( IN_RPC ) )
        {
        RpcSemError( this, MyContext, FUNC_NON_RPC, NULL );
        }
    else            // proc not an operation, validate its usage
        {
        SEM_ANALYSIS_CTXT * pAbove  = (SEM_ANALYSIS_CTXT *)
        MyContext.FindNonDefAncestorContext();
        node_skl * pAboveNode = pAbove->GetParent();

        if ( !pAboveNode->IsInterfaceOrObject() )
            {
            if ( pAboveNode->NodeKind() != NODE_POINTER )
                {
                TypeSemError( this, MyContext, FUNC_NON_POINTER, NULL );
                }
            }
        }

    if ( MyContext.FInSummary( ATTR_COMMSTAT ) )
        Commstat = SEEN_ON_RETURN;
    if ( MyContext.FInSummary( ATTR_FAULTSTAT ) )
        Faultstat = SEEN_ON_RETURN;

    //////////////////////////////////////
    // process the return type (it will eat commstat or faultstat)
    MyContext.SetAncestorBits( IN_FUNCTION_RESULT );
    MyContext.MarkImportantPosition();

    // warn about OUT const things
    if ( FInSummary( ATTR_CONST ) )
        RpcSemError( this, MyContext, CONST_ON_RETVAL, NULL );

    pRet->SemanticAnalysis( &MyContext );

    MyContext.UnMarkImportantPosition();

    if ( MyContext.AnyDescendantBits( HAS_UNION | HAS_STRUCT ) 
         && !pCommand->GetNdrVersionControl().AllowIntrepretedComplexReturns() )
        {
        // REVIEW: complex return types work for protocol all and ndr64.
        //         make it work for dce also.
        if (HasPickle)
            {
            if (pCommand->Is64BitEnv())
                RpcSemError( this, MyContext, PICKLING_RETVAL_TO_COMPLEX64, NULL );    
            }
        else if (ForceNonInterpret())
            {
            RpcSemError( this, MyContext, NON_OI_BIG_RETURN, NULL );
            }
        }
    else if ( MyContext.AnyDescendantBits( HAS_TOO_BIG_HDL ) )
        {
        if (ForceNonInterpret())
            RpcSemError( this, MyContext, NON_OI_BIG_GEN_HDL, NULL );
        }
    else if ( !pCommand->NeedsNDR64Run()
              && MyContext.AnyDescendantBits( HAS_UNSAT_REP_AS ))
        {
        // REVIEW: Another case of an error that has already been caught
        // elsewhere.  Investigate removing this check.
        if (ForceNonInterpret())
            RpcSemError( this, MyContext, NON_OI_UNK_REP_AS, NULL );
        }
    else if ( !pCommand->NeedsNDR64Run() &&
              ( MyContext.AnyDescendantBits( HAS_REPRESENT_AS 
                                                    | HAS_TRANSMIT_AS ) &&
                MyContext.AnyDescendantBits( HAS_ARRAY ) ) )
        {
        if (ForceNonInterpret())
            RpcSemError( this, MyContext, NON_OI_XXX_AS_ON_RETURN, NULL );
        }
    else if ( ( BasicChildKind == NODE_INT128 ) ||
              ( BasicChildKind == NODE_FLOAT80 ) ||
              ( BasicChildKind == NODE_FLOAT128 ) )
        {
            if (ForceNonInterpret())
                RpcSemError( this, MyContext, RETURNVAL_TOO_COMPLEX_FORCE_OS, NULL );     
        }
    else if ( !pCommand->GetNdrVersionControl().AllowIntrepretedComplexReturns() && 
              ( ( ( BasicChildKind == NODE_HYPER ) && !pCommand->Is64BitEnv() )
                || ( BasicChildKind == NODE_FLOAT )
                || ( BasicChildKind == NODE_DOUBLE ) ) )
        {
        if ( HasPickle )
            {
            if ( fOptimize & OPTIMIZE_INTERPRETER_V2 )
                {
                if ( pCommand->Is64BitEnv() )
                    {
                    RpcSemError( this, MyContext, PICKLING_RETVAL_TO_COMPLEX64, NULL );
                    }
                else if (ForceNonInterpret())
                    {
                    // For pickling -Os is the same as -Oi
                    RpcSemError( this, MyContext, PICKLING_RETVAL_FORCING_OI, NULL );
                    }
                }
            }
        else if ( ( fOptimize & OPTIMIZE_INTERPRETER_V2) ) 
            {
            if ( fObjectProc )
                {
                // Don't switch, generate NT 4.0 guard
                pCommand->GetNdrVersionControl().SetHasFloatOrDoubleInOi();
                }
            else
                if (ForceNonInterpret())
                    RpcSemError( this, MyContext, NON_OI_RETVAL_64BIT, NULL );
            }
        else if ( ( fOptimize & OPTIMIZE_ALL_I1_FLAGS ) )
            {
            if (ForceNonInterpret())
                RpcSemError( this, MyContext, NON_OI_RETVAL_64BIT, NULL );
            }
        }
    else if ( ( CallingConv != ATTR_NONE ) &&
            ( CallingConv != ATTR_STDCALL ) &&
            ( CallingConv != ATTR_CDECL ) && 
              !Skipme )
        {
        if (ForceNonInterpret())
            RpcSemError( this, MyContext, NON_OI_WRONG_CALL_CONV, NULL );
        }

    if ( fProcIsCallback )
        {
        if ( MyContext.AnyDescendantBits( HAS_HANDLE) )
            RpcSemError( this, MyContext, HANDLES_WITH_CALLBACK, NULL );
        if ( fObjectProc )
            RpcSemError( this, MyContext, INVALID_ON_OBJECT_PROC, "[callback]" );
        }

    if ( MyContext.AnyDescendantBits( HAS_FULL_PTR ) )
        fHasFullPointer = TRUE;

    // all object methods must return HRESULT (except those of IUnknown and async methods)
    if ( fObjectProc &&
        !Skipme &&
        !MyContext.AnyDescendantBits( HAS_HRESULT ) )
        {
        if ( !MyContext.AnyAncestorBits( IN_ROOT_CLASS ) && // not IUnknown
             !fAsync ) // not [async]
            {
            RpcSemError( this, MyContext, OBJECT_PROC_NON_HRESULT_RETURN, NULL );
            }
        }

    //////////////////////////////////////
    // process the parameters

    if ( !pIntf->IsAsyncClone() )
        {
        if ( MyContext.AnyAncestorBits( HAS_ASYNC_UUID ) )
            {
            node_skl* pParam = GetInOnlyParamPairedWithOut( MemIter );
            if ( pParam )
                {
                SemError( this, MyContext, ASYNC_INVALID_IN_OUT_PARAM_COMBO, pParam->GetSymName() );
                }
            }
        }

    BOOL    fParentIsAnyIAdviseSink = MyContext.AnyAncestorBits( IN_IADVISESINK );
    BOOL    fHasAsyncManager        = FALSE;
    MyContext.ClearAncestorBits( IN_FUNCTION_RESULT );
    MyContext.SetAncestorBits( IN_PARAM_LIST );

    BOOL    fLastParamWasOptional   = FALSE;
    BOOL    fHasPipeParam           = FALSE;
    BOOL    fHasConfOrVaryingParam  = FALSE;
    BOOL    fGenDefaultValueExpr    = FALSE;
    BOOL    fHasDRtag               = FALSE;
    BOOL    fHasRtag                = FALSE;
    BOOL    fHasStag                = FALSE;
    BOOL    fHasInCSType            = FALSE;
    BOOL    fHasOutCSType           = FALSE;

    node_param* pFirstParamWithDefValue = 0;
    node_param* pLastParam = 0;
    node_param* p2LastParam = 0;
    node_param* p3LastParam = 0;
    
    bool fRetval = false;
    bool fLCID = false;

    unsigned long ulParamNumber = 0;

    MemIter.Init();
    while ( ( pN = (node_param *) MemIter.GetNext() ) != 0 )
        {
        fOptimize    = GetOptimizationFlags();
        BasicChildKind = pN->GetBasicType()->NodeKind();
        p3LastParam = p2LastParam;
        p2LastParam = pLastParam;
        pLastParam = pN;
        MyContext.ClearAllDescendantBits();
        MyContext.ResetCorrelationCount();
        pN->SemanticAnalysis( &MyContext );

        fRetval = fRetval || pN->IsRetval();
        if ( pN->IsLCID() )
        {
            if (BasicChildKind != NODE_LONG)
            {
                SemError( this, MyContext, LCID_SHOULD_BE_LONG, 0 );
            }
            if (fLCID)
            {
                SemError( this, MyContext, INVALID_USE_OF_LCID, 0 );
            }
            else
                fLCID = true;
        }


        if ( MyContext.AnyDescendantBits( HAS_MULTIDIM_VECTOR ) )
            {
            if ( ForceInterpret2() )
                {
                RpcSemError( this, MyContext, MULTI_DIM_VECTOR, NULL );
                }
            }

        if ( MyContext.AnyDescendantBits( HAS_PARTIAL_IGNORE ) )
            {

            if ( (fOptimize & OPTIMIZE_INTERPRETER ) )
                {
                if ( ForceInterpret2() )
                    {
                    RpcSemError( this, MyContext, PARTIAL_IGNORE_NO_OI, NULL );
                    }
                }

            if ( MyContext.AnyAncestorBits( IN_LIBRARY ) )
                {
                SemError( this, MyContext, PARTIAL_IGNORE_IN_TLB, NULL );
                }

            if ( pCommand->IsSwitchDefined( SWITCH_OSF ) )
                {
                SemError( this, MyContext, INVALID_OSF_ATTRIBUTE, "[partial_ignore]" );
                }

            }

        if ( MyContext.AnyDescendantBits( HAS_SERVER_CORRELATION ) )
            {
            SetHasServerCorr();
            IncServerCorrelationCount( MyContext.GetCorrelationCount() );
            }
        if ( MyContext.AnyDescendantBits( HAS_CLIENT_CORRELATION ) )
            {
            SetHasClientCorr();
            IncClientCorrelationCount( MyContext.GetCorrelationCount() );
            }
        BOOL fDefaultValue = MyContext.AnyDescendantBits( HAS_DEFAULT_VALUE );
        if ( fDefaultValue )
            {
            if ( !pFirstParamWithDefValue )
                {
                pFirstParamWithDefValue = pN;
                fGenDefaultValueExpr = TRUE;
                }
            // can't have defaultvalue in vararg
            if ( fHasVarArg )
                SemError(this, MyContext, NOT_VARARG_COMPATIBLE, 0);
            }
        else
            {
            // don't generate defaultvalue is c++ header if we have 
            // non-defaultvalue parameter after it.
            fGenDefaultValueExpr = FALSE;
            pFirstParamWithDefValue = 0;
            }

        if ( MyContext.AnyDescendantBits( HAS_PIPE ) )
            {
            fHasPipeParam = TRUE;
            node_skl* pBasicType = pN->GetBasicType();
            while ( pBasicType && pBasicType->NodeKind() == NODE_POINTER )
                {
                pBasicType = pBasicType->GetChild();
                }
            if ( ( pBasicType->NodeKind() == NODE_INTERFACE_REFERENCE && !fObjectProc ) ||
                 ( pBasicType->NodeKind() == NODE_PIPE && fObjectProc ) )
                {
                SemError(this, MyContext, UNIMPLEMENTED_FEATURE, pN->GetSymName() );
                }
            }
        else if ( MyContext.AnyDescendantBits   (
                                                HAS_STRING          |
                                                HAS_FULL_PTR        |
                                                HAS_VAR_ARRAY       |
                                                HAS_CONF_ARRAY      |
                                                HAS_CONF_VAR_ARRAY
                                                ) )
            {
            fHasConfOrVaryingParam = TRUE;
            }

        if ( ulParamNumber == 0 ) // first parameter
            {
            // if parent interface is is any IAdviseSink ignore [async].
            if ( fAsync && fObjectProc )
                {
                unsigned int    nIndirection    = 0;
                node_skl*       pFType          = GetIndirectionLevel   (
                                                                        pN,
                                                                        nIndirection
                                                                        );
                // check async handle type
                if ( nIndirection != 2 )
                    {
                    if ( !fParentIsAnyIAdviseSink )
                        {
                        SemError(this, MyContext, OBJECT_ASYNC_NOT_DOUBLE_PTR, pN->GetChild()->GetSymName() );
                        }
                    }
                if ( strcmp( pFType->GetSymName(), OBJECT_ASYNC_HANDLE_NAME ) )
                    {
                    if ( !fParentIsAnyIAdviseSink )
                        {
                        SemError(this, MyContext, ASYNC_INCORRECT_TYPE, pN->GetChild()->GetSymName() );
                        }
                    }
                else
                    {
                    fHasAsyncManager = TRUE;
                    }
                // flag the first param of an object interface as async handle
                pN->SetIsAsyncHandleParam();
                if ( MyContext.AnyDescendantBits( HAS_OUT ) )
                    {
                    SemError( this, MyContext, ASYNC_NOT_IN, NULL );
                    }
                }

            // Oicf interpreter cannot handle floats as first param, switch to Os.
            // This is a non-issue for ORPC because of the 'this' pointer.

            if ( ! pCommand->NeedsNDR64Run()
                  && ( ( BasicChildKind == NODE_FLOAT ) 
                         || ( BasicChildKind == NODE_DOUBLE ) ) )
                {
                if ( ( fOptimize & OPTIMIZE_INTERPRETER_V2) )
                    {
                    if ( fObjectProc )
                        {
                        // Don't switch, generate NT 4.0 guard
                        pCommand->GetNdrVersionControl().SetHasFloatOrDoubleInOi();
                        }
                    else
                        if ( ForceNonInterpret() )
                            {
                            RpcSemError( this, MyContext, NON_OI_TOPLEVEL_FLOAT, NULL );
                            }
                    }
                }
            } // first parameter

        // Oi/Oic interpreter cannot handle float params on alpha, switch to Os.

        if ( ( BasicChildKind == NODE_FLOAT ) 
                   || ( BasicChildKind == NODE_DOUBLE )  )
            {
            if ( ! pCommand->NeedsNDR64Run() &&
                 ( fOptimize & OPTIMIZE_INTERPRETER ) )
                {
                // Old interpreter, always switch to -Os.
                if ( !( fOptimize & OPTIMIZE_INTERPRETER_V2 ) )
                    {
                    if (ForceNonInterpret())
                        {
                        RpcSemError( this, MyContext, NON_OI_TOPLEVEL_FLOAT, NULL );
                        }
                    }
                // For -Oicf, there were no problems for object rpc; check standard
                else if ( !fObjectProc  &&  ulParamNumber > 0 )
                    {
                    // For 64b, float and double work for object and standard rpc.
                    // The 32b NT4 engine didn't work for float args in standard rpc.
                    if ( !pCommand->Is64BitEnv()  &&  ( BasicChildKind == NODE_FLOAT ) )
                        {
                        if (ForceNonInterpret())
                            {
                            RpcSemError( this, MyContext, NON_OI_TOPLEVEL_FLOAT, NULL );
                            }
                        }
                    }
                    // For param0 and retval we force above.

                }
            }

/*
parameter sequence of odl:
1. Required parameters (parameters that do not have the defaultvalue or optional 
    attributes), 
2. optional parameters with or without the defaultvalue attribute, 
3. parameters with the optional attribute and without the defaultvalue attribute, 
4. lcid parameter, if any, 
5. retval parameter 
*/
        if ( pN->IsOptional() )
            {
            fLastParamWasOptional = TRUE;
            // [in,optional] VARIANT v1, [in] long l1, [in,optional] VARIANT v2
            if (nAfterLastOptionalParam > 0)
                nAfterLastOptionalParam++;
            // vararg can't coexist with optional parameter.
            if ( fHasVarArg )
                SemError(this, MyContext , NOT_VARARG_COMPATIBLE, 0 );
            
            }
        else
            {
            // If the following parameter after [optional] is either a RetVal or
            // LCID, we don't fail. The logic between Retval and LCID will be 
            // checked later.
            if ( fLastParamWasOptional )
                {
                // The only other parameter allowed to come after [optional]
                // in a propput/propget method is lcid. 
                if ( fPropSomething && !pN->IsLCID() )
                    nAfterLastOptionalParam++;
                else
                    if ( (!pN->IsRetval() && !pN->IsLCID()) && FNewTypeLib() )
                        {
                        // In regular method, we can only have retval and lcid coming
                        // after optional
                        SemError( this, MyContext, OPTIONAL_PARAMS_MUST_BE_LAST, NULL );
                        }
                }
            }

        if ( ( pAttr = (acf_attr *) pN->GetAttribute( ATTR_COMMSTAT ) ) != 0 )
            {
            if ( !MyContext.AnyDescendantBits( HAS_E_STAT_T ) )
                AcfError( pAttr, this, MyContext, INVALID_COMM_STATUS_PARAM, NULL );

            if ( Commstat == NOT_SEEN )
                Commstat = SEEN_ON_PARAM;
            else if ( Commstat == SEEN_ON_RETURN )
                AcfError( pAttr, this, MyContext, PROC_PARAM_COMM_STATUS, NULL );
            else // already on another parameter
                AcfError( pAttr, this, MyContext, ERROR_STATUS_T_REPEATED, NULL );
            }

        if ( ( pAttr = (acf_attr *) pN->GetAttribute( ATTR_FAULTSTAT ) ) != 0 )
            {
            if ( !MyContext.AnyDescendantBits( HAS_E_STAT_T ) )
                AcfError( pAttr, this, MyContext, INVALID_COMM_STATUS_PARAM, NULL );

            if ( Faultstat == NOT_SEEN )
                Faultstat = SEEN_ON_PARAM;
            else if ( Faultstat == SEEN_ON_RETURN )
                AcfError( pAttr, this, MyContext, PROC_PARAM_FAULT_STATUS, NULL );
            else // already on another parameter
                AcfError( pAttr, this, MyContext, ERROR_STATUS_T_REPEATED, NULL );
            }

        if (MyContext.AnyDescendantBits( HAS_HANDLE) )
            fHasExplicitHandle = TRUE;
        if (MyContext.AnyDescendantBits( HAS_IN ) )
            fHasAtLeastOneIn = TRUE;
        if ( MyContext.AnyDescendantBits( HAS_POINTER ) )
            fHasPointer = TRUE;
        if ( MyContext.AnyDescendantBits( HAS_FULL_PTR ) )
            fHasFullPointer = TRUE;
        if (MyContext.AnyDescendantBits( HAS_OUT) )
            {
            fHasAtLeastOneOut = TRUE;

            // complain about [out] on [maybe] procs
            if ( fMaybe )
                RpcSemError( this, MyContext, MAYBE_NO_OUT_RETVALS, NULL );
            }
        if (MyContext.AnyDescendantBits( (DESCENDANT_FLAGS) HAS_PIPE ))
        {
#if defined(TARGET_RKK)
            if ( pCommand->GetTargetSystem() < NT40 )
                RpcSemError( this, MyContext, REQUIRES_NT40, NULL );
#endif

            if (ForceInterpret2())
                RpcSemError( this, MyContext, REQUIRES_OI2, NULL );
            fHasPipes = TRUE;

            if ( HasPickle )
                RpcSemError( this, MyContext, PIPES_WITH_PICKLING, NULL );
        }

        // handle checks
        if ( pN->GetHandleKind() != HDL_NONE )
            {
            if ( !fBindingFound )   // first handle seen
                {
                // dce only allows in handles as the first param
                if ( ulParamNumber != 0 )
                    RpcSemError( this, MyContext, HANDLE_NOT_FIRST, NULL );

                // if the first binding handle is out-only, complain
                if ( !MyContext.AnyDescendantBits( HAS_IN ) &&
                        MyContext.AnyDescendantBits( HAS_OUT ) )
                    {
                    if ( !( MyContext.AnyAncestorBits( HAS_AUTO_HANDLE | HAS_IMPLICIT_HANDLE ) || 
                            fExpHdlAttr ) )
                        {
                        RpcSemError( this, MyContext, BINDING_HANDLE_IS_OUT_ONLY, NULL );
                        }
                    else if ( fExpHdlAttr )
                        {
                        fAddExplicitHandle = true;
                        }
                    }
                else if ( MyContext.AnyDescendantBits( HAS_OUT ) &&
                        ( pN->GetHandleKind() == HDL_PRIM ) )
                    {
                    RpcSemError( this, MyContext, HANDLE_T_CANNOT_BE_OUT, NULL );
                    }
                else  // plain [in], or [in,out]
                    {
                    fBindingFound = TRUE;
                    MyContext.SetAncestorBits( BINDING_SEEN );
                    }
                }
            else    // binding handle after the real one
                {
                if ( pN->GetHandleKind() == HDL_PRIM )
                    RpcSemError( this, MyContext, HANDLE_T_NO_TRANSMIT, NULL );
                }
            }       // if it had a handle

        if ( MyContext.AnyDescendantBits( HAS_TOO_BIG_HDL ) )
            {
            if (ForceNonInterpret())
                RpcSemError( this, MyContext, NON_OI_BIG_GEN_HDL, NULL );
            }
        else if ( !pCommand->NeedsNDR64Run() 
                  &&MyContext.AnyDescendantBits( HAS_UNSAT_REP_AS ) )
            {
            // This case should have been caught earlier.
            // REVIEW: Is this still relevant?
            if (ForceNonInterpret())
                RpcSemError( this, MyContext, NON_OI_UNK_REP_AS, NULL );
            }
        else if ( MyContext.AnyDescendantBits( HAS_UNION ) && IS_OLD_INTERPRETER( GetOptimizationFlags() ) )
            {
            node_skl * pNDC = pN->GetNonDefChild();
            if (pNDC->NodeKind() != NODE_PIPE && !pNDC->IsPtrOrArray())
                {
                // unions by value but not arrays of unions
                if (ForceNonInterpret())
                    RpcSemError( this, MyContext, NON_OI_UNION_PARM, NULL );
                }
            }

        if ( MyContext.AnyDescendantBits( HAS_DRTAG ) )
            fHasDRtag = TRUE;
        if ( MyContext.AnyDescendantBits( HAS_RTAG ) )
            fHasRtag = TRUE;
        if ( MyContext.AnyDescendantBits( HAS_STAG ) )
            fHasStag = TRUE;
        if ( MyContext.AnyDescendantBits( HAS_IN_CSTYPE ) )
            fHasInCSType = TRUE;
        if ( MyContext.AnyDescendantBits( HAS_OUT_CSTYPE ) )
            fHasOutCSType = TRUE;

        ulParamNumber++;
        }      // end of param list

    if ( MyContext.AnyDescendantBits( HAS_FORCEALLOCATE ) )
        {
        if ( ! ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) )
            SemError( this, MyContext, FORCEALLOCATE_SUPPORTED_IN_OICF_ONLY, NULL );
        }

    if ( fGenDefaultValueExpr )
        {
        bool fReallyGenDefaultValueExpr = true;
        MemIter.Init();
        do
            {
            pN = (node_param *) MemIter.GetNext();
            }
        while ( pN != pFirstParamWithDefValue );
        do
            {
            node_skl* pType = GetNonDefType( pN->GetChild() );
            if ( !pType->IsBasicType() && pType->NodeKind() != NODE_POINTER && 
                 pType->NodeKind() != NODE_ENUM )
                {
                SemError( this, MyContext, DEFAULTVALUE_NOT_ALLOWED, pN->GetSymName() );
                fReallyGenDefaultValueExpr = false;
                break;
                }
                pN->GenDefaultValueExpr();
            pN = (node_param *) MemIter.GetNext();
            }
        while ( pN != 0 );
        // don't genereate any defaultvalue in c++ header at all 
        if ( !fReallyGenDefaultValueExpr )
            {
            MemIter.Init();
            while ( ( pN = (node_param *) MemIter.GetNext() ) != 0 )
                {
                pN->GenDefaultValueExpr( false );
                }
            }
        }

    if ( fHasPipeParam && fHasConfOrVaryingParam )
        {
        SemError( this, MyContext, PIPE_INCOMPATIBLE_PARAMS, 0 );
        }

    ///////////////////////////////////////////////////////////////////////

    if ( fHasExplicitHandle )
        {
        if ( fProcIsCallback )
            RpcSemError( this, MyContext, HANDLES_WITH_CALLBACK, NULL );
        }
    if ( !fHasExplicitHandle || fAddExplicitHandle )
        {
        if ( fExpHdlAttr )
            {
            // async handle should be first param,
            // programmer supplies IAsyncManager in ORPC
            // MIDL adds PRPC_ASYNC_STATE in RPC
            // if parent interface is is any IAdviseSink ignore async.
            if ( fObjectProc && fAsync && fHasAsyncManager )
                {
                AddExplicitHandle( &MyContext, 2 );
                }
            else
                {
                // MIDL will add async handle later
                AddExplicitHandle( &MyContext, 1 );
                }
            }
        else if ( !(pIntfCtxt->FInSummary( ATTR_IMPLICIT ) ) )
            {
            // no explicit handle, no implicit handle, use auto_handle
            if ( !fProcIsCallback &&
                    MyContext.AnyAncestorBits( IN_RPC ) &&
                    !fObjectProc )
                {
                if ( !pIntfCtxt->FInSummary( ATTR_AUTO ) )
                    RpcSemError( this, MyContext, NO_HANDLE_DEFINED_FOR_PROC, NULL );
                }
            }
        }

    if ( fObjectProc || MyContext.AnyAncestorBits( IN_LIBRARY ))
        {
        if (fHasExplicitHandle || 
            fExpHdlAttr ||
            MyContext.FInSummary( ATTR_IMPLICIT ) ||
            MyContext.FInSummary( ATTR_AUTO ) ||
            pIntfCtxt->FInSummary( ATTR_AUTO ) ||
            pIntfCtxt->FInSummary( ATTR_IMPLICIT ) ||
            pIntfCtxt->FInSummary( ATTR_EXPLICIT )  )
            {
            SemError( this, MyContext, HANDLES_WITH_OBJECT, NULL );
            }
        }

    // record whether there are any comm/fault statuses
    if ( ( Faultstat != NOT_SEEN ) || ( Commstat != NOT_SEEN ) )
        {
        fHasStatuses = TRUE;

        // [comm_status] and [fault_status] are supported in -Os.  Intrepreted
        // modes are only supported in NT 3.51 or later.  Hidden status 
        // params are only supported in interpreted mode post-Win2000.

        // REVIEW: We can get hidden status params to work for Win2000 by
        //         adding a line to the client stub that zero's the status
        //         before calling the interpreter.

        if ( GetOptimizationFlags() & OPTIMIZE_ANY_INTERPRETER )
            {
            if ( HasExtraStatusParam() 
                 && ( ! ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 )
                      || !pCommand->NeedsNDR64Run() ) )
                {
                // invisible fault/comm status are not supported in the V1
                // interpreter.  Switch to -Os

                // REVIEW: For now, only support hidden status params in the
                //         V2 interpreter in -protocol all and -protocol ndr64

                if (ForceNonInterpret())
                    RpcSemError( this, MyContext, NON_OI_ERR_STATS, NULL );
                }
            else
                pCommand->GetNdrVersionControl().SetHasCommFaultStatusInOi12();
            }
        }

    // record info for statuses on the return type
    if ( Faultstat == SEEN_ON_RETURN )
        RTStatuses |= STATUS_FAULT;
    if ( Commstat == SEEN_ON_RETURN )
        RTStatuses |= STATUS_COMM;

    if ( fHasPointer && !pCommand->IsSwitchDefined( SWITCH_MS_EXT ) )
        pIntf->SetHasProcsWithRpcSs();

    if ( ( OpBits & ( OPERATION_MAYBE | OPERATION_BROADCAST | OPERATION_IDEMPOTENT ) ) != 0 &&
           fObjectProc )
        {
        SemError(this, MyContext, ILLEGAL_COMBINATION_OF_ATTRIBUTES, NULL);
        }

    // [message] only allowed in ORPC interfaces and RPC procs.
    if ( fMessage && fObjectProc )
        {
        // [message] applied on proc.
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }
    if ( MyContext.AnyAncestorBits( HAS_MESSAGE ) )
        {
        // [message] applied on interface.
        if ( !fObjectProc )
            {
            SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
            }
        fMessage = TRUE;
        }

    if ( fMessage )
        {
        if (    OpBits & OPERATION_BROADCAST
            ||  OpBits & OPERATION_IDEMPOTENT
            ||  OpBits & OPERATION_INPUT_SYNC
            ||  fMaybe
            ||  fAsync
            ||  fProcIsCallback
            ||  pCallAs
            ||  HasPickle
            ||  pHC
            ||  pHSC
            ||  pID
            ||  pHelpStr
            ||  MyContext.FInSummary(ATTR_BYTE_COUNT)
            ||  MyContext.FInSummary(ATTR_COMMSTAT)
            ||  MyContext.FInSummary(ATTR_CONTEXT)
            ||  MyContext.FInSummary(ATTR_CUSTOM)
            ||  MyContext.FInSummary(ATTR_ENABLE_ALLOCATE)
            ||  MyContext.FInSummary(ATTR_ENTRY)
            ||  MyContext.FInSummary(ATTR_FAULTSTAT)
            ||  MyContext.FInSummary(ATTR_FUNCDESCATTR)
            ||  MyContext.FInSummary(ATTR_HIDDEN)
            ||  MyContext.FInSummary(ATTR_MEMBER)
            ||  MyContext.FInSummary(ATTR_PTR_KIND)
            ||  MyContext.FInSummary(ATTR_VARDESCATTR)
            ||  MyContext.FInSummary(ATTR_OBJECT)
            ||  MyContext.FInSummary(ATTR_TYPEDESCATTR)
            ||  MyContext.FInSummary(ATTR_TYPE)
           )
            {
            SemError(this, MyContext, ILLEGAL_COMBINATION_OF_ATTRIBUTES, NULL);
            }
        if ( HasAtLeastOneOut() )
            {
            SemError(this, MyContext, MAYBE_NO_OUT_RETVALS, NULL);
            }
        }

    if ( MyContext.AnyAncestorBits( HAS_OLEAUTOMATION ) )
        {
        char*       szRetTypeNonDefName = 0;
        node_skl*   pReturnType         = GetReturnType();
        if (pReturnType)
            {
            szRetTypeNonDefName = pReturnType->GetSymName();
            }
        if ( GetReturnType()->GetBasicType()->NodeKind() != NODE_VOID && 
             (  !szRetTypeNonDefName || 
                _stricmp(szRetTypeNonDefName, "HRESULT") ) )
            {
            SemError(this, MyContext, NOT_OLEAUTOMATION_INTERFACE, NULL);
            }
        }

    if ( fPropSomething && MyContext.AnyAncestorBits( IN_LIBRARY ) )
        {
        // propget can either return the property in an out parameter or
        // in the return value.
        if ( fPropGet && !HasAParameter() && !HasReturn() )
            {
            SemError(this, MyContext, INVALID_USE_OF_PROPGET, NULL);
            }
        // propput must set the property in a parameter
        else if ( !fPropGet && !HasAParameter() )  
            {   
            SemError(this, MyContext, INVALID_USE_OF_PROPPUT, NULL);
            }
        }

    if (MyContext.AnyAncestorBits( (ANCESTOR_FLAGS) IN_DISPINTERFACE ) && !pID)
        {
        SemError(this, MyContext, DISPATCH_ID_REQUIRED, NULL);
        }
    if ( fAsync )
        {
        if ( fForcedS                       ||
             pOptAttr                       ||
             fNotify                        ||
             HasPickle                      || 
             fProcIsCallback                ||
             fLocal                         ||
             fCode                          ||
             fNoCode                        ||
             fMaybe                         ||
             fMessage                       ||
             OpBits & OPERATION_INPUT_SYNC  ||
             pIntfCtxt->FInSummary( ATTR_AUTO ) )
            {
            SemError(this, MyContext, ILLEGAL_COMBINATION_OF_ATTRIBUTES, NULL);
            }

        // async handle should be first param,
        // programmer supplies IAsyncManager in ORPC
        // MIDL adds PRPC_ASYNC_STATE in RPC
        if ( fObjectProc )
            {
            if ( fHasAsyncManager )
                {
                SetHasAsyncHandle();
                }
            // if parent interface is is any IAdviseSink ignore.
            if ( !fParentIsAnyIAdviseSink )
                {
                if ( ulParamNumber == 0 )
                    {
                    SemError( this, MyContext, ASYNC_INCORRECT_TYPE, 0);
                    }
                pCommand->GetNdrVersionControl().SetHasAsyncHandleRpc();
                }
            }
        else
            {
            AddFullAsyncHandle( &MyContext, 0, RPC_ASYNC_HANDLE_NAME );
            if ( pAttrAsync && !pAttrAsync->IsAcfAttr() )
                {
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
                }
            if ( !pIntfCtxt->FInSummary( ATTR_IMPLICIT ) &&
                 !fExpHdlAttr &&
                 !fHasExplicitHandle )
                {
                SemError( this, MyContext, ASYNC_INCORRECT_BINDING_HANDLE, 0 );
                }
            pCommand->GetNdrVersionControl().SetHasAsyncHandleRpc();
            }

        if ( pCommand->IsSwitchDefined( SWITCH_OSF ) )
            {
            SemError( this, MyContext, INVALID_OSF_ATTRIBUTE, "[async]" );
            }
        // switch compiler modes
        if (ForceInterpret2())
            {
            RpcSemError( this, MyContext, ASYNC_REQUIRES_OI2, NULL );
            }
        }

    // I don't like this complex logic, but unfortunately this is the right logic. It's easier
    // to code this logic in mktyplib code structure but hard to do it here...
    if ( fLCID )
        {
        node_param* pLCID;
        // if there is a [retval], [lcid] must be the second last
        if ( fRetval)
            pLCID = p2LastParam;
        else
        {
            if (fPropSomething)
            {
                // in propget without a retval, the lcid must be the last.
                // in propput/propputref, lcid is second last.
                if (fPropGet)
                    pLCID = pLastParam;
                else
                    pLCID = p2LastParam;
            }
            // lcid should be the last if it's a regular method without propsomething & retval
            else
                pLCID = pLastParam;
        }
                
        if ( !pLCID || !pLCID->IsLCID() )
            {
            SemError( this, MyContext, INVALID_USE_OF_LCID, 0 );
            }
        }

    // we can only have one parameter after optioanl in propput/propget, other than lcid.
    if ( fLastParamWasOptional && fPropSomething && ( nAfterLastOptionalParam > 1 ) )
        SemError(this, MyContext , INVALID_PROP_PARAMS , 0);
        
    // Verify that a propput method is valid.
    // TODO: much of the above code relating to propput/get could be simplified
    //       with state driven logic and is redundent with the code below

    if ( fPropSomething & !fPropGet )
    {
        using namespace PropPut;

        State       state = NoParam;
        node_param *pParam;

        MemIter.Init();

        while ( NULL != (pParam = (node_param *) MemIter.GetNext()) )
        {
            if ( pParam->FInSummary( ATTR_DEFAULTVALUE ) )
                state = StateTable[state][Default];

            else if ( pParam->IsOptional() )
                state = StateTable[state][Optional];

            else if ( pParam->IsLCID() )
                state = StateTable[state][LCID];

            else
                state = StateTable[state][GeneralParam];
        }

        state = StateTable[state][NoParam];

        if ( Accept != state )
            SemError(this, MyContext , INVALID_PROPPUT , 0);
    }


    if ( fHasVarArg )
        {
        // [vararg]  [lcid]   [retval]
        //  last        0        0       
        //  2 last    last       0
        //  2 last      0       last
        //  3 last    2last     last
        node_param* pVarargParam = fRetval ? ( fLCID ? p3LastParam : p2LastParam ) : ( fLCID ? p2LastParam : pLastParam );

        if ( pVarargParam )
            {
            node_skl* pType = pVarargParam->GetChild();

            if ( pType->NodeKind() == NODE_POINTER )
                {
                pType = pType->GetChild();
                }
            pType = GetNonDefType( pType );
            if ( pType->NodeKind() != NODE_SAFEARRAY || 
                 strcmp( GetNonDefType( pType->GetChild() )->GetSymName(), "tagVARIANT" ) )
                {
                SemError( this, MyContext, NOT_VARARG_COMPATIBLE, 0 );
                }
            }
        else
            {
            SemError( this, MyContext, NOT_VARARG_COMPATIBLE, 0 );
            }
        }

    if ( pIntf->IsAsyncClone() )
        {
        SetHasAsyncUUID();
        ForceInterpret2();
        }

    if ( fNotify || fNotifyFlag )
        {
        unsigned short uOpt = GetOptimizationFlags();
        if ( !( uOpt & OPTIMIZE_SIZE ) )
            {
            pCommand->GetNdrVersionControl().SetHasInterpretedNotify();
            if ( IS_OLD_INTERPRETER(uOpt) )
                {
                if (ForceInterpret2())
                    RpcSemError( this, MyContext, NON_OI_NOTIFY, NULL );
                }
            }
        }

    if ( fHasInCSType && !fHasStag )
        SemError( this, MyContext, NO_TAGS_FOR_IN_CSTYPE, 0 );

    if ( fHasOutCSType && ( !fHasDRtag || !fHasRtag ) )
        SemError( this, MyContext, NO_TAGS_FOR_OUT_CSTYPE, 0 );

    if ( fHasInCSType || fHasOutCSType )
        {
        if ( NULL != pCSTagAttr )
            SetCSTagRoutine( pCSTagAttr->GetCSTagRoutine() );
        else
            MyContext.SetDescendantBits( HAS_IN_CSTYPE );
        }

    if ( HasPickle && MyContext.AnyDescendantBits( HAS_PARTIAL_IGNORE ) )
        {
        SemError( this, MyContext, PARTIAL_IGNORE_PICKLING, GetSymName() );
        }

    MyContext.SetDescendantBits( HAS_FUNC );
    pParentCtxt->ReturnValues( MyContext );
}

void
node_field::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    BOOL fLastField = ( GetSibling() == NULL );

    node_case * pCaseAttr;
    expr_list * pCaseExprList;
    expr_node * pCaseExpr;
    BOOL fHasCases = FALSE;
    node_su_base * pParent = (node_su_base *)
                             MyContext.GetParentContext()->GetParent();
    BOOL fInUnion = ( pParent->NodeKind() == NODE_UNION );
    node_switch_type * pSwTypeAttr = ( node_switch_type *)
                                     pParent->GetAttribute( ATTR_SWITCH_TYPE );
    node_skl * pSwType = NULL;
    char * pName = GetSymName();
    node_constant_attr * pID = (node_constant_attr *) MyContext.ExtractAttribute(ATTR_ID);
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRING);
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    if ( MyContext.ExtractAttribute(ATTR_IDLDESCATTR) )
        {
        SemError(this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, 0);
        }

    if ( MyContext.ExtractAttribute(ATTR_VARDESCATTR) )
        {
        SemError(this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, 0);
        }
    

    MyContext.ExtractAttribute(ATTR_HIDDEN); 
        

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }
            
    CheckDeclspecAlign( MyContext );

    if (pID)
    {
        SEM_ANALYSIS_CTXT * pIntfCtxt = (SEM_ANALYSIS_CTXT *)
                                    MyContext.GetInterfaceContext();
        node_interface * pIntf = (node_interface *) pIntfCtxt->GetParent();
        if (!pIntf->AddId(pID->GetExpr()->GetValue(), GetSymName()))
            SemError( this, MyContext, DUPLICATE_IID, NULL);
    }
    else
    {
        if ( MyContext.AnyAncestorBits( (ANCESTOR_FLAGS) IN_DISPINTERFACE ) &&
             pParent->NodeKind() == NODE_DISPINTERFACE)
            {
            SemError(this, MyContext, DISPATCH_ID_REQUIRED, NULL);
            }
    }

    node_entry_attr * pEntry = NULL;

    // check for illegal member attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_DEFAULTVTABLE:
            case MATTR_PREDECLID:
            case MATTR_READONLY:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_IMMEDIATEBIND:
            case MATTR_REPLACEABLE:
                break;
            case MATTR_SOURCE:
                {
                char * pAttrName = pMA->GetNodeNameString();
                if ( MyContext.AnyAncestorBits( IN_STRUCT | IN_UNION ) )
                    SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_OPTIONAL:
            case MATTR_RESTRICTED:
            case MATTR_RETVAL:
            case MATTR_VARARG:
            case MATTR_USESGETLASTERROR:
            default:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }


    if (MyContext.AnyAncestorBits( IN_MODULE ))
        pEntry = (node_entry_attr *) MyContext.ExtractAttribute( ATTR_ENTRY );

    if ( pSwTypeAttr )
        pSwType = pSwTypeAttr->GetType();

    // process all the cases and the default
    while ( ( pCaseAttr = (node_case *) MyContext.ExtractAttribute( ATTR_CASE ) ) != 0 )
        {
        if ( !fInUnion )
            TypeSemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, "[case]" );

        fHasCases = TRUE;
        if ( pSwType )
            {
            pCaseExprList = pCaseAttr->GetExprList();
            pCaseExprList->Init();
            while ( pCaseExprList->GetPeer( &pCaseExpr ) == STATUS_OK )
                {
                // make sure the expression has the proper type, so sign extension behaves
                node_skl * pCaseType = pCaseExpr->GetType();

                if ( ( !pCaseType )  ||
                       ( pCaseType->GetNonDefSelf()->IsBasicType() ) )
                    {
                    pCaseExpr->SetType( pSwType->GetBasicType() );
                    }
                // range/type checks
                __int64 CaseValue = pCaseExpr->GetValue();
                if ( !((node_base_type *)pSwType)->RangeCheck( CaseValue ) )
                    TypeSemError( this, MyContext, CASE_VALUE_OUT_OF_RANGE, NULL );
                }
            }
        }

    if ( MyContext.ExtractAttribute( ATTR_DEFAULT ) )
        {
        if ( !fInUnion )
            TypeSemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, "[default]" );

        fHasCases = TRUE;
        }

    // union fields in an RPC MUST have cases
    if ( fInUnion && !fHasCases )
        RpcSemError( this, MyContext, CASE_LABELS_MISSING_IN_UNION, NULL );

    // temp field names valid for: structs/enums/empty arms
    if ( IsTempName( pName ) )
        {
        NODE_T BaseType = GetBasicType()->NodeKind();
        if ( ( BaseType != NODE_UNION ) &&
                ( BaseType != NODE_STRUCT ) &&
                ( BaseType != NODE_ERROR ) )
            SemError( GetBasicType(), MyContext, BAD_CON_UNNAMED_FIELD_NO_STRUCT, NULL );
        }

    GetChild()->SemanticAnalysis( &MyContext );

    // allow conformant array or struct only as last field, and not in unions!
    if ( MyContext.AnyDescendantBits( HAS_CONF_ARRAY
            | HAS_CONF_VAR_ARRAY ) )
        {
        if ( fInUnion )
            {
            RpcSemError( this, MyContext, BAD_CON_UNION_FIELD_CONF , NULL );
            }
        else if (!fLastField )
            {
            SemError( this, MyContext, CONFORMANT_ARRAY_NOT_LAST, NULL );
            }
        }

    // disallow forward references as members
    if ( MyContext.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
        {
        if (! MyContext.AnyAncestorBits( IN_LIBRARY ))
            SemError( this, MyContext, UNDEFINED_SYMBOL, NULL );
        MyContext.ClearDescendantBits( HAS_INCOMPLETE_TYPE );
        }
    MyContext.ClearDescendantBits( HAS_RECURSIVE_DEF );

    // don't allow functions as fields
    if ( MyContext.AnyDescendantBits( HAS_FUNC ) &&
            MyContext.AllAncestorBits( IN_INTERFACE | IN_RPC ) )
        RpcSemError( this, MyContext, BAD_CON_FIELD_FUNC, NULL );

    if ( MyContext.AnyDescendantBits( HAS_UNSAT_REP_AS ) )
        SetHasUnknownRepAs();

    pParentCtxt->ReturnValues( MyContext );
}

void
node_bitfield::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
        
    CheckDeclspecAlign( MyContext );

    RpcSemError( this, MyContext, BAD_CON_BIT_FIELDS, NULL );

    if ( MyContext.AnyAncestorBits( IN_PARAM_LIST ) )
        {
        RpcSemError( this, MyContext, NON_RPC_PARAM_BIT_FIELDS, NULL );
        }
    else
        {
        RpcSemError( this, MyContext, NON_RPC_RTYPE_BIT_FIELDS, NULL );
        }

    GetChild()->SemanticAnalysis( &MyContext );

    node_skl * pType = GetBasicType();

    switch ( pType->NodeKind() )
        {
        case NODE_INT:
            break;
        case NODE_BOOLEAN:
        case NODE_SHORT:
        case NODE_CHAR:
        case NODE_LONG:
        case NODE_INT32:
        case NODE_INT3264:
        case NODE_INT64:
        case NODE_INT128:
        case NODE_HYPER:
            SemError( this, MyContext, BAD_CON_BIT_FIELD_NON_ANSI, NULL );
            break;
        default:
            SemError( this, MyContext, BAD_CON_BIT_FIELD_NOT_INTEGRAL, NULL );
            break;
        }

    // disallow forward references as members
    if ( MyContext.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
        {
        if (! MyContext.AnyAncestorBits( IN_LIBRARY ))
            SemError( this, MyContext, UNDEFINED_SYMBOL, NULL );
        MyContext.ClearDescendantBits( HAS_INCOMPLETE_TYPE );
        }
    MyContext.ClearDescendantBits( HAS_RECURSIVE_DEF );

    pParentCtxt->ReturnValues( MyContext );
}

void
node_su_base::CheckLegalParent(SEM_ANALYSIS_CTXT & MyContext)
{
    WALK_CTXT * pParentCtxt = MyContext.GetParentContext();
    node_file * pFile = GetDefiningFile();
    if (NULL == pFile)
    {
        node_skl * pParent = pParentCtxt->GetParent();
        if (NULL == pParent || pParent->NodeKind() == NODE_LIBRARY)
            SemError( this, MyContext, ILLEGAL_SU_DEFINITION, NULL );
    }
};

void
node_enum::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    MEM_ITER MemIter( this );
    node_skl * pN;
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    MyContext.ExtractAttribute( ATTR_V1_ENUM );
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    if ( MyContext.ExtractAttribute(ATTR_IDLDESCATTR) )
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    // check for illegal type attributes
    node_type_attr * pTA;
    while ( ( pTA = (node_type_attr *)MyContext.ExtractAttribute(ATTR_TYPE) ) != 0 )
        {
        switch (pTA->GetAttr())
            {
            // acceptable attributes
            case TATTR_PUBLIC:
                {
                char        *       pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }

    // check for illegal member attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_USESGETLASTERROR:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }
        

    CheckDeclspecAlign( MyContext );

    node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
    // make sure the UUID is unique
    if ( pGuid )
        {
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }

    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
        CheckLegalParent(MyContext);

    node_range_attr* pRange = ( node_range_attr* ) MyContext.ExtractAttribute(ATTR_RANGE);
    if ( pRange )
        {
        if ( pRange->GetMinExpr()->GetValue() > pRange->GetMaxExpr()->GetValue() )
            {
            SemError(this, MyContext, INCORRECT_RANGE_DEFN, 0);
            }
        }

    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        pN->SemanticAnalysis( &MyContext );
        }

    MyContext.SetDescendantBits( HAS_ENUM );
    pParentCtxt->ReturnValues( MyContext );
}

// structs are stringable if all the fields are "byte"
BOOL					
node_struct::IsStringableType()
{
	MEM_ITER	 			MemIter( this );
	node_skl		*		pBasic;
	node_skl		*		pN;

	// make sure all the fields are BYTE! with no attributes on the way
	while ( ( pN = (node_skl *) MemIter.GetNext() ) != 0 )
		{
		pBasic = pN->GetBasicType();
		do {
			if ( pN->HasAttributes() )
				return FALSE;
			pN = pN->GetChild();
			}
		while ( pN != pBasic );

		pBasic = pN->GetBasicType();

		if ( pBasic &&
			 (pBasic->NodeKind() != NODE_BYTE ) )
			{
			return FALSE;
			}
		}

	return TRUE;	
}

void
node_struct::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    MEM_ITER MemIter( this );
    node_skl * pN;
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );

    if ( fBeingAnalyzed )
        {
        // if we hit the same node more than once (it can only be through a ptr),
        // and the ptr type is ref, we flag an error; recursive defn. through a ref ptr.
        if ( !MyContext.AnyAncestorBits( IN_NON_REF_PTR ) &&
             MyContext.AnyAncestorBits( IN_RPC ) )
            {
            TypeSemError( this, MyContext, RECURSION_THRU_REF, NULL );
            }
        return;
        }
    fBeingAnalyzed = TRUE;
        
    CheckDeclspecAlign( MyContext );

    BOOL fString = (NULL != MyContext.ExtractAttribute( ATTR_STRING ));
    node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
    // make sure the UUID is unique
    if ( pGuid )
        {
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }

    MyContext.MarkImportantPosition();
    MyContext.SetAncestorBits( IN_STRUCT );

    // clear NE union flag
    MyContext.ClearAncestorBits( IN_UNION | IN_NE_UNION );
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute( ATTR_HELPSTRING );

    if ( MyContext.ExtractAttribute( ATTR_VERSION ) )
        {
        SemError(this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, 0);
        }
    
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    // clear member attributes
    while (MyContext.ExtractAttribute(ATTR_MEMBER));

    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
        CheckLegalParent(MyContext);

    // See if context_handle applied to param reached us
    if ( CheckContextHandle( MyContext ) )
        {
        MyContext.SetDescendantBits( HAS_HANDLE | HAS_CONTEXT_HANDLE );
        }

    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        pN->SemanticAnalysis( &MyContext );

        if ( MyContext.AnyDescendantBits( HAS_HANDLE ) )
            TypeSemError( pN, MyContext, BAD_CON_CTXT_HDL_FIELD, NULL );
        }

    if ( fString && !IsStringableType() )
        {
        TypeSemError( this, MyContext, WRONG_TYPE_IN_STRING_STRUCT, NULL );
        }

    // If a structure has an embedded array of pointers the back end gets 
    // really confused and generates bad pointer layouts.  Work around the
    // problem by forcing the structure to be complex.

    if ( MyContext.AnyDescendantBits( HAS_VAR_ARRAY | HAS_ARRAYOFPOINTERS ) )
        Complexity |= FLD_VAR;
    if ( MyContext.AnyDescendantBits( HAS_CONF_ARRAY ) )
        {
        Complexity |= FLD_CONF;
        fHasConformance = 1;
        }
    if ( MyContext.AnyDescendantBits( HAS_CONF_VAR_ARRAY ) )
        {
        Complexity |= FLD_CONF_VAR;
        fHasConformance = 1;
        }

    // don't pass up direct conformance characteristic
    MyContext.ClearDescendantBits( HAS_DIRECT_CONF_OR_VAR );

    // disallow direct forward references as struct members
    if ( MyContext.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
        {
        if (! MyContext.AnyAncestorBits( IN_LIBRARY ))
            SemError( this, MyContext, UNDEFINED_SYMBOL, NULL );
        MyContext.ClearDescendantBits( HAS_INCOMPLETE_TYPE );
        }
    MyContext.ClearDescendantBits( HAS_RECURSIVE_DEF );

    if ( MyContext.AnyDescendantBits( HAS_POINTER ) )
        SetHasAtLeastOnePointer( TRUE );

    // save info on complexity for code generation
    if ( MyContext.AnyDescendantBits( HAS_VAR_ARRAY |
            HAS_TRANSMIT_AS |
            HAS_REPRESENT_AS |
            HAS_INTERFACE_PTR |
            HAS_MULTIDIM_SIZING |
            HAS_ARRAY_OF_REF ) )
        {
        Complexity |= FLD_COMPLEX;
        }

    if ( pCommand->NeedsNDR64Run() )
        {
        if ( MyContext.AnyDescendantBits( HAS_UNSAT_REP_AS ) )
            {
            RpcSemError( this, MyContext, UNSPECIFIED_EMBEDDED_REPRESENT_AS_NOT_SUPPORTED, NULL );
            }        
        }

    MyContext.ClearDescendantBits( HAS_ARRAY | HAS_MULTIDIM_VECTOR );
    MyContext.SetDescendantBits( HAS_STRUCT );

    pParentCtxt->ReturnValues( MyContext );
    fBeingAnalyzed = FALSE;
}


// note: this lets HAS_UNION propogate up to any enclosing structs
void
node_en_struct::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    MEM_ITER MemIter( this );
    node_skl * pN;
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );

    if ( fBeingAnalyzed )
        {
        // if we hit the same node more than once (it can only be through a ptr),
        // and the ptr type is ref, we flag an error; recursive defn. through a ref ptr.
        if ( !MyContext.AnyAncestorBits( IN_NON_REF_PTR ) &&
             MyContext.AnyAncestorBits( IN_RPC ) )
            {
            TypeSemError( this, MyContext, RECURSION_THRU_REF, NULL );
            }
        return;
        }
    fBeingAnalyzed = TRUE;
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    CheckDeclspecAlign( MyContext );

    node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
    // make sure the UUID is unique
    if ( pGuid )
        {
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }

    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
        CheckLegalParent(MyContext);

    MyContext.SetAncestorBits( IN_STRUCT );
    // See if context_handle applied to param reached us
    if ( CheckContextHandle( MyContext ) )
        {
        MyContext.SetDescendantBits( HAS_HANDLE | HAS_CONTEXT_HANDLE );
        }

    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        pN->SemanticAnalysis( &MyContext );
        };

    if ( pCommand->NeedsNDR64Run() )
        {
        if ( MyContext.AnyDescendantBits( HAS_UNSAT_REP_AS ) )
            {
            RpcSemError( this, MyContext, UNSPECIFIED_EMBEDDED_REPRESENT_AS_NOT_SUPPORTED, NULL );
            }
        }

    if ( MyContext.AnyDescendantBits( HAS_POINTER ) )
        SetHasAtLeastOnePointer( TRUE );

    pParentCtxt->ReturnValues( MyContext );
    fBeingAnalyzed = FALSE;
}

void
node_union::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    MEM_ITER MemIter( this );
    node_field * pN;
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    BOOL fEncap  = IsEncapsulatedUnion();
    node_switch_type * pSwTypeAttr = (node_switch_type *) MyContext.ExtractAttribute( ATTR_SWITCH_TYPE );
    node_switch_is * pSwIsAttr = (node_switch_is *) MyContext.ExtractAttribute( ATTR_SWITCH_IS );
    BOOL NonEmptyArm = FALSE;
    BOOL HasCases = FALSE;
    BOOL HasBadExpr = FALSE;

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }

    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
        CheckLegalParent(MyContext);

    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    if ( MyContext.ExtractAttribute( ATTR_HIDDEN ) )
        {
        SemError(this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, 0);
        }    

    if ( MyContext.ExtractAttribute( ATTR_VERSION ) )
        {
        SemError(this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, 0);
        }    
    

    if ( fBeingAnalyzed )
        {
        // if we hit the same node more than once (it can only be through a ptr),
        // and the ptr type is ref, we flag an error; recursive defn. through a ref ptr.
        if ( !MyContext.AnyAncestorBits( IN_NON_REF_PTR ) &&
             MyContext.AnyAncestorBits( IN_RPC ) )
            {
            TypeSemError( this, MyContext, RECURSION_THRU_REF, NULL );
            }
        return;
        }
    fBeingAnalyzed = TRUE;
        
    CheckDeclspecAlign( MyContext );

    if ( pSwIsAttr )
        {
        EXPR_CTXT SwCtxt( &MyContext );
        expr_node * pSwIsExpr = pSwIsAttr->GetExpr();

        pSwIsExpr->ExprAnalyze( &SwCtxt );

        if ( SwCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
            {
            TypeSemError( this,
                MyContext,
                ATTRIBUTE_ID_UNRESOLVED,
                pSwIsAttr->GetNodeNameString() );
            HasBadExpr = TRUE;
            }

        if ( !SwCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
            {
            TypeSemError( this,
                MyContext,
                ATTRIBUTE_ID_MUST_BE_VAR,
                pSwIsAttr->GetNodeNameString() );
            HasBadExpr = TRUE;
            }
        }

    // if they left off the switch_type, take it from the switch_is type
    if ( !pSwTypeAttr && !fEncap && pSwIsAttr && !HasBadExpr )
        {
        node_skl * pSwIsType = pSwIsAttr->GetSwitchIsType();

        MIDL_ASSERT( pSwIsType || !"no type for switch_is expr");
        if ( ( pSwIsType->NodeKind() == NODE_FIELD ) ||
                ( pSwIsType->NodeKind() == NODE_PARAM ) )
            pSwIsType = pSwIsType->GetChild();

        pSwTypeAttr = new node_switch_type( pSwIsType );
        SetAttribute( pSwTypeAttr );
        }

    if ( pSwIsAttr && pSwTypeAttr && !HasBadExpr )
        {
        node_skl * pSwIsType = pSwIsAttr->GetSwitchIsType();
        node_skl * pSwType  = pSwTypeAttr->GetType();

        pSwIsType = pSwIsType->GetBasicType();
        if ( pSwIsType && pSwIsType->IsBasicType() && pSwType->IsBasicType() )
            {
            if ( !((node_base_type *)pSwType)
                    ->IsAssignmentCompatible( (node_base_type *) pSwIsType ) )
                TypeSemError( this, MyContext, SWITCH_TYPE_MISMATCH, NULL );
            }

        if ( !pSwType || !Xxx_Is_Type_OK( pSwType ) )
            {
            TypeSemError( this,
                MyContext,
                SWITCH_IS_TYPE_IS_WRONG,
                pSwType ? pSwType->GetSymName() : NULL );
            }

        if ( !pSwIsType || !Xxx_Is_Type_OK( pSwIsType ) )
            {
            TypeSemError( this,
                MyContext,
                SWITCH_IS_TYPE_IS_WRONG,
                pSwIsType ? pSwIsType->GetSymName() : NULL );
            }
        }

    // We don't care about local: it can be anything.
    if ( MyContext.AnyAncestorBits( IN_RPC ) )
        {
        if ( !fEncap && !pSwTypeAttr && !pSwIsAttr )
            {
            if ( MyContext.AnyAncestorBits( IN_PARAM_LIST ) )
                RpcSemError( this, MyContext, NON_RPC_UNION, NULL );
            else
                RpcSemError( this, MyContext, NON_RPC_RTYPE_UNION, NULL );
            }
        if ( !fEncap &&
                MyContext.AnyAncestorBits( IN_FUNCTION_RESULT ) &&
                !MyContext.AnyAncestorBits( IN_STRUCT | IN_UNION ) )
            RpcSemError( this, MyContext, RETURN_OF_UNIONS_ILLEGAL, NULL );

        if ( pSwTypeAttr && !pSwIsAttr )
            RpcSemError( this, MyContext, NO_SWITCH_IS, NULL );
        }

    // See if context_handle applied to param reached us
    if ( CheckContextHandle( MyContext ) )
        {
        MyContext.SetDescendantBits( HAS_HANDLE | HAS_CONTEXT_HANDLE );
        }

    MyContext.MarkImportantPosition();

    if ( MyContext.AllAncestorBits( IN_INTERFACE | IN_NE_UNION ) )
        {
        RpcSemError( this, MyContext, NE_UNION_FIELD_NE_UNION, NULL );
        }
    if ( ( MyContext.FindNonDefAncestorContext()->GetParent()
            ->NodeKind() == NODE_UNION ) &&
            MyContext.AnyAncestorBits( IN_INTERFACE ) )
        {
        RpcSemError( this, MyContext, ARRAY_OF_UNIONS_ILLEGAL, NULL );
        }

    MyContext.SetAncestorBits( IN_UNION | IN_NE_UNION );
    MyContext.SetDescendantBits( HAS_UNION );

    // eat the union flavor determiner
    MyContext.ExtractAttribute( ATTR_MS_UNION );

    while ( ( pN = (node_field *) MemIter.GetNext() ) != 0 )
        {
        // tbd - put cases into case database...
        // tbd - check type, range, and duplication
        pN->SemanticAnalysis( &MyContext );

        if ( !NonEmptyArm && !pN->IsEmptyArm() )
            NonEmptyArm = TRUE;

        if ( !HasCases && (pN->FInSummary( ATTR_CASE ) || pN->FInSummary( ATTR_DEFAULT ) ) )
            HasCases = TRUE;

        }

    // at least one arm should be non-empty
    if ( !NonEmptyArm )
        SemError( this, MyContext, UNION_NO_FIELDS, NULL );

    if ( !fEncap && !pSwTypeAttr && !HasCases )
        RpcSemError( this, MyContext, BAD_CON_NON_RPC_UNION, NULL );

    // disallow forward references as union members
    if ( MyContext.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
        {
        if (! MyContext.AnyAncestorBits( IN_LIBRARY ))
            SemError( this, MyContext, UNDEFINED_SYMBOL, NULL );
        MyC