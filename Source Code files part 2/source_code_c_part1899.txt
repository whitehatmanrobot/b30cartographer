eletedLogon)
#pragma alloc_text(PAGE,SepNotifyFileSystems)
#pragma alloc_text(PAGE,SeGetLogonIdDeviceMap)
#if DBG || TOKEN_LEAK_MONITOR
#pragma alloc_text(PAGE,SepAddTokenLogonSession)
#pragma alloc_text(PAGE,SepRemoveTokenLogonSession)
#endif
#endif



////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Local macros                                                           //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


//
// This macro is used to obtain an index into the logon session tracking
// array given a logon session ID (a LUID).
//

#define SepLogonSessionIndex( PLogonId ) (                                    \
     (PLogonId)->LowPart & SEP_LOGON_TRACK_INDEX_MASK                         \
     )



////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Exported Services                                                      //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

VOID
SepRmCreateLogonSessionWrkr(
    IN PRM_COMMAND_MESSAGE CommandMessage,
    OUT PRM_REPLY_MESSAGE ReplyMessage
    )

/*++

Routine Description:

    This function is the dispatch routine for the LSA --> RM
    "CreateLogonSession" call.

    The arguments passed to this routine are defined by the
    type SEP_RM_COMMAND_WORKER.


Arguments:

    CommandMessage - Points to structure containing RM command message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command number (RmComponentTestCommand) and a command-specific
        body.  The command-specific body of this parameter is a LUID of the
        logon session to be created.

    ReplyMessage - Pointer to structure containing LSA reply message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command ReturnedStatus field in which a status code from the
        command will be returned.

Return Value:

    VOID

--*/

{

    NTSTATUS Status;
    LUID LogonId;

    PAGED_CODE();

    //
    // Check that command is expected type
    //

    ASSERT( CommandMessage->CommandNumber == RmCreateLogonSession );


    //
    // Typecast the command parameter to what we expect.
    //

    LogonId = *((LUID UNALIGNED *) CommandMessage->CommandParams);



    //
    // Try to create the logon session tracking record
    //

    Status = SepCreateLogonSessionTrack( &LogonId );



    //
    // Set the reply status
    //

    ReplyMessage->ReturnedStatus = Status;


    return;
}



VOID
SepRmDeleteLogonSessionWrkr(
    IN PRM_COMMAND_MESSAGE CommandMessage,
    OUT PRM_REPLY_MESSAGE ReplyMessage
    )

/*++

Routine Description:

    This function is the dispatch routine for the LSA --> RM
    "DeleteLogonSession" call.

    The arguments passed to this routine are defined by the
    type SEP_RM_COMMAND_WORKER.


Arguments:

    CommandMessage - Points to structure containing RM command message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command number (RmComponentTestCommand) and a command-specific
        body.  The command-specific body of this parameter is a LUID of the
        logon session to be created.

    ReplyMessage - Pointer to structure containing LSA reply message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command ReturnedStatus field in which a status code from the
        command will be returned.

Return Value:

    VOID

--*/

{

    NTSTATUS Status;
    LUID LogonId;

    PAGED_CODE();

    //
    // Check that command is expected type
    //

    ASSERT( CommandMessage->CommandNumber == RmDeleteLogonSession );


    //
    // Typecast the command parameter to what we expect.
    //

    LogonId = *((LUID UNALIGNED *) CommandMessage->CommandParams);



    //
    // Try to create the logon session tracking record
    //

    Status = SepDeleteLogonSessionTrack( &LogonId );



    //
    // Set the reply status
    //

    ReplyMessage->ReturnedStatus = Status;


    return;
}


NTSTATUS
SepReferenceLogonSession(
    IN PLUID LogonId,
    OUT PSEP_LOGON_SESSION_REFERENCES *ReturnSession
    )

/*++

Routine Description:

    This routine increments the reference count of a logon session
    tracking record.



Arguments:

    LogonId - Pointer to the logon session ID whose logon track is
        to be incremented.

    ReturnSession - The found session is returned here on success.

Return Value:

    STATUS_SUCCESS - The reference count was successfully incremented.

    STATUS_NO_SUCH_LOGON_SESSION - The specified logon session doesn't
        exist in the reference monitor's database.

--*/

{

    ULONG SessionArrayIndex;
    PSEP_LOGON_SESSION_REFERENCES *Previous, Current;
    ULONG Refs;

    PAGED_CODE();

    SessionArrayIndex = SepLogonSessionIndex( LogonId );

    Previous = &SepLogonSessions[ SessionArrayIndex ];

    //
    // Protect modification of reference monitor database
    //

    SepRmAcquireDbWriteLock(SessionArrayIndex);


    //
    // Now walk the list for our logon session array hash index.
    //

    Current = *Previous;

    while (Current != NULL) {

        //
        // If we found it, increment the reference count and return
        //

        if (RtlEqualLuid( LogonId, &Current->LogonId) ) {

             Refs = InterlockedIncrement (&Current->ReferenceCount);

             SepRmReleaseDbWriteLock(SessionArrayIndex);

             *ReturnSession = Current;
             return STATUS_SUCCESS;
        }

        Current = Current->Next;
    }

    SepRmReleaseDbWriteLock(SessionArrayIndex);

    //
    // Bad news, someone asked us to increment the reference count of
    // a logon session we didn't know existed.  This might be a new
    // token being created, so return an error status and let the caller
    // decide if it warrants a bugcheck or not.
    //

    return STATUS_NO_SUCH_LOGON_SESSION;
}



NTSTATUS
SepCleanupLUIDDeviceMapDirectory(
    PLUID pLogonId
    )
/*++

Routine Description:

    Make the contents of the (LUID's device map)'s directory object 
    temporary so that their names go away.


Arguments:

    pLogonId - Pointer to the logon session ID whose device is to be
               cleaned up

Return Value:

    STATUS_SUCCESS - cleaned up the entire device map

    STATUS_INVALID_PARAMETER - pLogonId is a NULL pointer

    STATUS_NO_MEMORY - could not allocate memory to hold the handle
                       buffer

    appropriate NTSTATUS code

--*/
{
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING    UnicodeString;
    HANDLE            LinkHandle;
    POBJECT_DIRECTORY_INFORMATION DirInfo = NULL;
    BOOLEAN           RestartScan;
    WCHAR             szString[64]; // \Sessions\0\DosDevices\x-x = 10+1+12+(8)+1+(8)+1 = 41
    ULONG             Context = 0;
    ULONG             ReturnedLength;
    HANDLE            DosDevicesDirectory;
    HANDLE            *HandleArray;
    ULONG             Size = 100;
    ULONG             i, Count = 0;
    ULONG             dirInfoLength = 0;
    BOOLEAN           CallingProcessValid;
    KAPC_STATE        ApcState;

    PAGED_CODE();

    if (pLogonId == NULL) {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    // Attach to the system process if the current process has a reference count of 0 to
    // avoid recursive process deletion.
    //

    CallingProcessValid = ObReferenceObjectSafe(PsGetCurrentProcess());

    if (CallingProcessValid) {
        ObDereferenceObject(PsGetCurrentProcess());
    }
    else {
        KeStackAttachProcess(&PsInitialSystemProcess->Pcb, &ApcState);
    }

    //
    // Open a handle to the directory object for the LUID device map
    // Get a kernel handle
    //

    _snwprintf( szString,
                (sizeof(szString)/sizeof(WCHAR)) - 1,
                L"\\Sessions\\0\\DosDevices\\%08x-%08x",
                pLogonId->HighPart,
                pLogonId->LowPart );

#pragma prefast(suppress:53, "szString is correctly null-terminated.")
    RtlInitUnicodeString(&UnicodeString, szString);

    InitializeObjectAttributes(&Attributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    Status = ZwOpenDirectoryObject(&DosDevicesDirectory,
                                   DIRECTORY_QUERY,
                                   &Attributes);
    if (!NT_SUCCESS(Status)) {
        if (!CallingProcessValid) {
            KeUnstackDetachProcess(&ApcState);
        }

        return Status;
    }

Restart:

    //
    // Create an array of handles to close with each scan
    // of the directory
    //
    HandleArray = (HANDLE *)ExAllocatePoolWithTag(
                                PagedPool,
                                (Size * sizeof(HANDLE)),
                                'aHeS'
                                );

    if (HandleArray == NULL) {

        ZwClose(DosDevicesDirectory);
        if (DirInfo != NULL) {
            ExFreePool(DirInfo);
        }

        if (!CallingProcessValid) {
            KeUnstackDetachProcess(&ApcState);
        }

        return STATUS_NO_MEMORY;
    }

    RestartScan = TRUE;

    while (TRUE) {

        do {
            //
            // ZwQueryDirectoryObject returns one element at a time
            //
            Status = ZwQueryDirectoryObject( DosDevicesDirectory,
                                             (PVOID)DirInfo,
                                             dirInfoLength,
                                             TRUE,
                                             RestartScan,
                                             &Context,
                                             &ReturnedLength );

            if (Status == STATUS_BUFFER_TOO_SMALL) {
                dirInfoLength = ReturnedLength;
                if (DirInfo != NULL) {
                    ExFreePool(DirInfo);
                }
                DirInfo = ExAllocatePoolWithTag( PagedPool, dirInfoLength, 'bDeS' );
                if (DirInfo == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }while (Status == STATUS_BUFFER_TOO_SMALL);

        //
        //  Check the status of the operation.
        //
        if (!NT_SUCCESS(Status)) {

            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            break;
        }

        //
        // Check that the element is a symbolic link
        //
        if (!wcscmp(DirInfo->TypeName.Buffer, L"SymbolicLink")) {

            //
            // check if the handle array is full
            //
            if ( Count >= Size ) {

                //
                // empty the handle array by closing all the handles
                // and free the handle array so that we can create
                // a bigger handle array
                // Need to restart the directory scan
                //
                for (i = 0; i < Count ; i++) {
                    ZwClose (HandleArray[i]);
                }
                Size += 20;
                Count = 0;
                ExFreePool((PVOID)HandleArray);
                HandleArray = NULL;
                goto Restart;

            }

            InitializeObjectAttributes( &Attributes,
                                        &DirInfo->Name,
                                        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                        DosDevicesDirectory,
                                        NULL);

            Status = ZwOpenSymbolicLinkObject( &LinkHandle,
                                               SYMBOLIC_LINK_ALL_ACCESS,
                                               &Attributes);

            if (NT_SUCCESS(Status)) {

                //
                // Make the object temporary so that its name goes away from
                // the Object Manager's namespace
                //
                Status = ZwMakeTemporaryObject( LinkHandle );

                if (NT_SUCCESS( Status )) {
                    HandleArray[Count] = LinkHandle;
                    Count++;
                }
                else {
                    ZwClose( LinkHandle );
                }
            }
        }
        RestartScan = FALSE;
     }

     //
     // Close all the handles
     //
     
     for (i = 0; i < Count ; i++) {
         ZwClose (HandleArray[i]);
     }

     if (HandleArray != NULL) {
         ExFreePool((PVOID)HandleArray);
     }

     if (DirInfo != NULL) {
         ExFreePool(DirInfo);
     }

     if (DosDevicesDirectory != NULL) {
         ZwClose(DosDevicesDirectory);
     }

     if (!CallingProcessValid) {
         KeUnstackDetachProcess(&ApcState);
     }

     return Status;
}



VOID
SepDeReferenceLogonSession(
    IN PLUID LogonId
    )

/*++

Routine Description:

    This routine decrements the reference count of a logon session
    tracking record.

    If the reference count is decremented to zero, then there is no
    possibility for any more tokens to exist for the logon session.
    In this case, the LSA is notified that a logon session has
    terminated.



Arguments:

    LogonId - Pointer to the logon session ID whose logon track is
        to be decremented.

Return Value:

    None.

--*/

{

    ULONG SessionArrayIndex;
    PSEP_LOGON_SESSION_REFERENCES *Previous, Current;
    PDEVICE_MAP pDeviceMap = NULL;
    ULONG Refs;


    PAGED_CODE();

    SessionArrayIndex = SepLogonSessionIndex( LogonId );

    Previous = &SepLogonSessions[ SessionArrayIndex ];

    //
    // Protect modification of reference monitor database
    //

    SepRmAcquireDbWriteLock(SessionArrayIndex);


    //
    // Now walk the list for our logon session array hash index.
    //

    Current = *Previous;

    while (Current != NULL) {

        //
        // If we found it, decrement the reference count and return
        //

        if (RtlEqualLuid( LogonId, &Current->LogonId) ) {
            Refs = InterlockedDecrement (&Current->ReferenceCount);
            if (Refs == 0) {

                //
                // Pull it from the list
                //

                *Previous = Current->Next;

                //
                // No longer need to protect our pointer to this
                // record.
                //

                SepRmReleaseDbWriteLock(SessionArrayIndex);

                //
                // If the Device Map exist for this LUID,
                // dereference the pointer to the Device Map
                //
                if (Current->pDeviceMap != NULL) {

                    //
                    // Dereference our reference on the device map
                    // our reference should be the last reference,
                    // thus the system will delete the device map
                    // for the LUID
                    //
                    pDeviceMap = Current->pDeviceMap;
                    Current->pDeviceMap = NULL;
                }


                //
                // Make all the contents of the LUID's device map temporary,
                // so that the names go away from the Object Manager's
                // namespace
                // Remove our reference on the LUID's device map
                //
                if (pDeviceMap != NULL) {
                    SepCleanupLUIDDeviceMapDirectory( LogonId );
                    ObfDereferenceDeviceMap( pDeviceMap );
                }

                //
                // Asynchronoously inform file systems that this logon session
                // is going away, if at least one FS expressed interest in this
                // logon session.
                //

                if (Current->Flags & SEP_TERMINATION_NOTIFY) {
                    SepInformFileSystemsOfDeletedLogon( LogonId );
                }

                //
                // Deallocate the logon session track record.
                //

                ExFreePool( (PVOID)Current );

                //
                // Inform the LSA about the deletion of this logon session.
                //

                SepInformLsaOfDeletedLogon( LogonId );



                return;

            }

            //
            // reference count was decremented, but not to zero.
            //

            SepRmReleaseDbWriteLock(SessionArrayIndex);

            return;
        }

        Previous = &Current->Next;
        Current = *Previous;
    }

    SepRmReleaseDbWriteLock(SessionArrayIndex);

    //
    // Bad news, someone asked us to decrement the reference count of
    // a logon session we didn't know existed.
    //

    KeBugCheckEx( DEREF_UNKNOWN_LOGON_SESSION, 0, 0, 0, 0 );

    return;

}


NTSTATUS
SepCreateLogonSessionTrack(
    IN PLUID LogonId
    )

/*++

Routine Description:

    This routine creates a new logon session tracking record.

    This should only be called as a dispatch routine for a LSA->RM
    call (and once during system initialization).

    If the specified logon session already exists, then an error is returned.



Arguments:

    LogonId - Pointer to the logon session ID for which a new logon track is
        to be created.

Return Value:

    STATUS_SUCCESS - The logon session track was created successfully.

    STATUS_LOGON_SESSION_EXISTS - The logon session already exists.
        A new one has not been created.

--*/

{

    ULONG SessionArrayIndex;
    PSEP_LOGON_SESSION_REFERENCES *Previous, Current;
    PSEP_LOGON_SESSION_REFERENCES LogonSessionTrack;

    PAGED_CODE();

    
#if DBG || TOKEN_LEAK_MONITOR
    if (SepTokenLeakTracking) {
        DbgPrint("\nLOGON : 0x%x 0x%x\n\n", LogonId->HighPart, LogonId->LowPart);
    }
#endif


    //
    // Make sure we can allocate a new logon session track record
    //

    LogonSessionTrack = (PSEP_LOGON_SESSION_REFERENCES)
                        ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof(SEP_LOGON_SESSION_REFERENCES),
                            'sLeS'
                            );

    if (LogonSessionTrack == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(LogonSessionTrack, sizeof(SEP_LOGON_SESSION_REFERENCES));
    LogonSessionTrack->LogonId = (*LogonId);
    LogonSessionTrack->ReferenceCount = 0;
    LogonSessionTrack->pDeviceMap = NULL;

#if DBG || TOKEN_LEAK_MONITOR
    InitializeListHead(&LogonSessionTrack->TokenList);
#endif


    SessionArrayIndex = SepLogonSessionIndex( LogonId );

    Previous = &SepLogonSessions[ SessionArrayIndex ];

    //
    // Protect modification of reference monitor database
    //

    SepRmAcquireDbWriteLock(SessionArrayIndex);


    //
    // Now walk the list for our logon session array hash index
    // looking for a duplicate logon session ID.
    //

    Current = *Previous;

    while (Current != NULL) {

        if (RtlEqualLuid( LogonId, &Current->LogonId) ) {

            //
            // One already exists. Hmmm.
            //

            SepRmReleaseDbWriteLock(SessionArrayIndex);

            ExFreePool(LogonSessionTrack);
            return STATUS_LOGON_SESSION_EXISTS;

        }

        Current = Current->Next;
    }


    //
    // Reached the end of the list without finding a duplicate.
    // Add the new one.
    //

    LogonSessionTrack->Next = *Previous;
    *Previous = LogonSessionTrack;

    SepRmReleaseDbWriteLock(SessionArrayIndex);

    return STATUS_SUCCESS;

}


NTSTATUS
SepDeleteLogonSessionTrack(
    IN PLUID LogonId
    )

/*++

Routine Description:

    This routine creates a new logon session tracking record.

    This should only be called as a dispatch routine for a LSA->RM
    call (and once during system initialization).

    If the specified logon session already exists, then an error is returned.



Arguments:

    LogonId - Pointer to the logon session ID whose logon track is
        to be deleted.

Return Value:

    STATUS_SUCCESS - The logon session track was deleted successfully.

    STATUS_BAD_LOGON_SESSION_STATE - The logon session has a non-zero
        reference count and can not be deleted.

    STATUS_NO_SUCH_LOGON_SESSION - The specified logon session does not
        exist.


--*/

{

    ULONG SessionArrayIndex;
    PSEP_LOGON_SESSION_REFERENCES *Previous, Current;
    PDEVICE_MAP pDeviceMap = NULL;

    PAGED_CODE();

    SessionArrayIndex = SepLogonSessionIndex( LogonId );

    Previous = &SepLogonSessions[ SessionArrayIndex ];

    //
    // Protect modification of reference monitor database
    //

    SepRmAcquireDbWriteLock(SessionArrayIndex);


    //
    // Now walk the list for our logon session array hash index.
    //

    Current = *Previous;

    while (Current != NULL) {

        //
        // If we found it, make sure reference count is zero
        //

        if (RtlEqualLuid( LogonId, &Current->LogonId) ) {

            if (Current->ReferenceCount == 0) {

                //
                // Pull it from the list
                //

                *Previous = Current->Next;

                //
                // If the Device Map exist for this LUID,
                // dereference the pointer to the Device Map
                //
                if (Current->pDeviceMap != NULL) {

                    //
                    // Dereference our reference on the device map
                    // our reference should be the last reference,
                    // thus the system will delete the device map
                    // for the LUID
                    //
                    pDeviceMap = Current->pDeviceMap;
                    Current->pDeviceMap = NULL;
                }

                //
                // No longer need to protect our pointer to this
                // record.
                //

                SepRmReleaseDbWriteLock(SessionArrayIndex);

                //
                // Make all the contents of the LUID's device map temporary,
                // so that the names go away from the Object Manager's
                // namespace
                // Remove our reference on the LUID's device map
                //
                if (pDeviceMap != NULL) {
                    SepCleanupLUIDDeviceMapDirectory( LogonId );
                    ObfDereferenceDeviceMap( pDeviceMap );
                }

                //
                // Deallocate the logon session track record.
                //

                ExFreePool( (PVOID)Current );


                return STATUS_SUCCESS;

            }

            //
            // reference count was not zero.  This is not considered
            // a healthy situation.  Return an error and let someone
            // else declare the bugcheck.
            //

            SepRmReleaseDbWriteLock(SessionArrayIndex);
            return STATUS_BAD_LOGON_SESSION_STATE;
        }

        Previous = &Current->Next;
        Current = *Previous;
    }

    SepRmReleaseDbWriteLock(SessionArrayIndex);

    //
    // Someone asked us to delete a logon session that isn't
    // in the database.
    //

    return STATUS_NO_SUCH_LOGON_SESSION;

}


VOID
SepInformLsaOfDeletedLogon(
    IN PLUID LogonId
    )

/*++

Routine Description:

    This routine informs the LSA about the deletion of a logon session.

    Note that we can not be guaranteed that we are in a whole (or wholesome)
    thread, since we may be in the middle of process deletion and object
    rundown.  Therefore, we must queue the work off to a worker thread which
    can then make an LPC call to the LSA.




Arguments:

    LogonId - Pointer to the logon session ID which has been deleted.

Return Value:

    None.

--*/

{
    PSEP_LSA_WORK_ITEM DeleteLogonItem;

    PAGED_CODE();

    //
    // Pass the LUID value along with the work queue item.
    // Note that the worker thread is responsible for freeing the WorkItem data
    // structure.
    //

    DeleteLogonItem = ExAllocatePoolWithTag( PagedPool, sizeof(SEP_LSA_WORK_ITEM), 'wLeS' );
    if (DeleteLogonItem == NULL) {

        //
        // I don't know what to do here... we loose track of a logon session,
        // but the system isn't really harmed in any way.
        //

        ASSERT("Failed to allocate DeleteLogonItem." && FALSE);
        return;

    }

    DeleteLogonItem->CommandParams.LogonId   = (*LogonId);
    DeleteLogonItem->CommandNumber           = LsapLogonSessionDeletedCommand;
    DeleteLogonItem->CommandParamsLength     = sizeof( LUID );
    DeleteLogonItem->ReplyBuffer             = NULL;
    DeleteLogonItem->ReplyBufferLength       = 0;
    DeleteLogonItem->CleanupFunction         = NULL;
    DeleteLogonItem->CleanupParameter        = 0;
    DeleteLogonItem->Tag                     = SepDeleteLogon;
    DeleteLogonItem->CommandParamsMemoryType = SepRmImmediateMemory;

    if (!SepQueueWorkItem( DeleteLogonItem, TRUE )) {

        ExFreePool( DeleteLogonItem );
    }

    return;

}


NTSTATUS
SeRegisterLogonSessionTerminatedRoutine(
    IN PSE_LOGON_SESSION_TERMINATED_ROUTINE CallbackRoutine
    )

/*++

Routine Description:

    This routine is called by file systems that are interested in being
    notified when a logon session is being deleted.

Arguments:

    CallbackRoutine - Address of routine to call back when a logon session
        is being deleted.

Return Value:

    STATUS_SUCCESS - Successfully registered routine

    STATUS_INVALID_PARAMETER - CallbackRoutine is NULL

    STATUS_INSUFFICIENT_RESOURCE - Unable to allocate list entry.

--*/

{
    PSEP_LOGON_SESSION_TERMINATED_NOTIFICATION NewCallback;

    PAGED_CODE();

    if (CallbackRoutine == NULL) {
        return( STATUS_INVALID_PARAMETER );
    }

    NewCallback = ExAllocatePoolWithTag(
                        PagedPool | POOL_COLD_ALLOCATION,
                        sizeof(SEP_LOGON_SESSION_TERMINATED_NOTIFICATION),
                        'SFeS');

    if (NewCallback == NULL) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }
    
    SepRmAcquireNotifyLock();

    NewCallback->Next = SeFileSystemNotifyRoutinesHead.Next;

    NewCallback->CallbackRoutine = CallbackRoutine;

    SeFileSystemNotifyRoutinesHead.Next = NewCallback;

    SepRmReleaseNotifyLock();

    return( STATUS_SUCCESS );
}


NTSTATUS
SeUnregisterLogonSessionTerminatedRoutine(
    IN PSE_LOGON_SESSION_TERMINATED_ROUTINE CallbackRoutine
    )

/*++

Routine Description:

    This is the dual of SeRegisterLogonSessionTerminatedRoutine. A File System
    *MUST* call this before it is unloaded.

Arguments:

    CallbackRoutine - Address of routine that was originally passed in to
        SeRegisterLogonSessionTerminatedRoutine.

Return Value:

    STATUS_SUCCESS - Successfully removed callback routine

    STATUS_INVALID_PARAMETER - CallbackRoutine is NULL

    STATUS_NOT_FOUND - Didn't find and entry for CallbackRoutine

--*/
{
    NTSTATUS Status;
    PSEP_LOGON_SESSION_TERMINATED_NOTIFICATION PreviousEntry;
    PSEP_LOGON_SESSION_TERMINATED_NOTIFICATION NotifyEntry;

    PAGED_CODE();

    if (CallbackRoutine == NULL) {
        return( STATUS_INVALID_PARAMETER );
    }

    SepRmAcquireNotifyLock();

    for (PreviousEntry = &SeFileSystemNotifyRoutinesHead,
            NotifyEntry = SeFileSystemNotifyRoutinesHead.Next;
                NotifyEntry != NULL;
                    PreviousEntry = NotifyEntry,
                        NotifyEntry = NotifyEntry->Next) {

         if (NotifyEntry->CallbackRoutine == CallbackRoutine)
             break;

    }

    if (NotifyEntry != NULL) {

        PreviousEntry->Next = NotifyEntry->Next;

        SepRmReleaseNotifyLock();

        ExFreePool( NotifyEntry );

        Status = STATUS_SUCCESS;

    } else {

        SepRmReleaseNotifyLock();

        Status = STATUS_NOT_FOUND;

    }


    return( Status );

}


NTSTATUS
SeMarkLogonSessionForTerminationNotification(
    IN PLUID LogonId
    )

/*++

Routine Description:

    File systems that have registered for logon-termination notification
    can mark logon sessions they are interested in for callback by calling
    this routine.

Arguments:

    LogonId - The logon id for which the file system should be notified
        when the logon session is terminated.

Returns:

    Nothing.

--*/

{

    ULONG SessionArrayIndex;
    PSEP_LOGON_SESSION_REFERENCES *Previous, Current;

    PAGED_CODE();

    SessionArrayIndex = SepLogonSessionIndex( LogonId );

    Previous = &SepLogonSessions[ SessionArrayIndex ];

    //
    // Protect modification of reference monitor database
    //

    SepRmAcquireDbWriteLock(SessionArrayIndex);


    //
    // Now walk the list for our logon session array hash index.
    //

    Current = *Previous;

    while (Current != NULL) {

        //
        // If we found it, decrement the reference count and return
        //

        if (RtlEqualLuid( LogonId, &Current->LogonId) ) {
            Current->Flags |= SEP_TERMINATION_NOTIFY;
            break;
        }

        Current = Current->Next;
    }

    SepRmReleaseDbWriteLock(SessionArrayIndex);

    return( (Current != NULL) ? STATUS_SUCCESS : STATUS_NOT_FOUND );

}


VOID
SepInformFileSystemsOfDeletedLogon(
    IN PLUID LogonId
    )

/*++

Routine Description:

    This routine informs interested file systems of a deleted logon.

    Note that we can not be guaranteed that we are in a whole (or wholesome)
    thread, since we may be in the middle of process deletion and object
    rundown.  Therefore, we must queue the work off to a worker thread.


Arguments:

    LogonId - Pointer to the logon session ID which has been deleted.

Return Value:

    None.

--*/

{
    PSEP_FILE_SYSTEM_NOTIFY_CONTEXT FSNotifyContext;

    PAGED_CODE();

    FSNotifyContext = ExAllocatePoolWithTag(
                            NonPagedPool,
                            sizeof(SEP_FILE_SYSTEM_NOTIFY_CONTEXT),
                            'SFeS');

    if (FSNotifyContext == NULL) {

        //
        // I don't know what to do here... file systems will loose track of a
        // logon session, but the system isn't really harmed in any way.
        //

        ASSERT("Failed to allocate FSNotifyContext." && FALSE);
        return;

    }

    FSNotifyContext->LogonId = *LogonId;

    ExInitializeWorkItem( &FSNotifyContext->WorkItem,
                          (PWORKER_THREAD_ROUTINE) SepNotifyFileSystems,
                          (PVOID) FSNotifyContext);

    ExQueueWorkItem( &FSNotifyContext->WorkItem, DelayedWorkQueue );

}


VOID
SepNotifyFileSystems(
    IN PVOID Context
    )
{
    PSEP_FILE_SYSTEM_NOTIFY_CONTEXT FSNotifyContext =
        (PSEP_FILE_SYSTEM_NOTIFY_CONTEXT) Context;

    PSEP_LOGON_SESSION_TERMINATED_NOTIFICATION NextCallback;

    PAGED_CODE();

    //
    // Protect modification of the list of FS callbacks.
    //

    SepRmAcquireNotifyLock();

    NextCallback = SeFileSystemNotifyRoutinesHead.Next;

    while (NextCallback != NULL) {

        NextCallback->CallbackRoutine( &FSNotifyContext->LogonId );

        NextCallback = NextCallback->Next;
    }
    
    SepRmReleaseNotifyLock();

    ExFreePool( FSNotifyContext );
}


NTSTATUS
SeGetLogonIdDeviceMap(
    IN PLUID pLogonId,
    OUT PDEVICE_MAP* ppDevMap
    )

/*++

Routine Description:

    This routine is called by components that want a handle to the
    Device Map for the specified LUID

Arguments:

    LogonID - LUID of the user

Return Value:

    STATUS_SUCCESS - Successfully registered routine

    STATUS_INVALID_PARAMETER - invalid parameter

    STATUS_INSUFFICIENT_RESOURCE - Unable to allocate list entry.

--*/

{

    PSEP_LOGON_SESSION_REFERENCES *Previous, Current;
    ULONG SessionArrayIndex;
    LONG OldValue;

    PAGED_CODE();

    if( pLogonId == NULL ) {
        return( STATUS_INVALID_PARAMETER );
    }

    if( ppDevMap == NULL ) {
        return( STATUS_INVALID_PARAMETER );
    }

    SessionArrayIndex = SepLogonSessionIndex( pLogonId );

    Previous = &SepLogonSessions[ SessionArrayIndex ];

    //
    // Protect modification of reference monitor database
    //

    SepRmAcquireDbWriteLock(SessionArrayIndex);

    //
    // Now walk the list for our logon session array hash index.
    //

    Current = *Previous;

    while (Current != NULL) {

        //
        // If we found it, return a handle to the device map
        //

        if (RtlEqualLuid( pLogonId, &(Current->LogonId) )) {

            NTSTATUS Status;

            Status = STATUS_SUCCESS;

            //
            // Check if the Device Map does not exist for this LUID
            //
            if (Current->pDeviceMap == NULL) {

                WCHAR  szString[64]; // \Sessions\0\DosDevices\x-x = 10+1+12+(8)+1+(8)+1 = 41
                OBJECT_ATTRIBUTES Obja;
                UNICODE_STRING    UnicodeString, SymLinkUnicodeString;
                HANDLE hDevMap, hSymLink;
                PDEVICE_MAP pDeviceMap = NULL;

                //
                // Drop the lock while we create the devmap
                //
                InterlockedIncrement (&Current->ReferenceCount);
                SepRmReleaseDbWriteLock(SessionArrayIndex);

                _snwprintf( szString,
                            (sizeof(szString)/sizeof(WCHAR)) - 1,
                            L"\\Sessions\\0\\DosDevices\\%08x-%08x",
                            pLogonId->HighPart,
                            pLogonId->LowPart );

                RtlInitUnicodeString( &UnicodeString, szString );

                //
                // Device Map for LUID does not exist
                // Create the Device Map for the LUID
                //
                InitializeObjectAttributes( &Obja,
                                            &UnicodeString,
                                            OBJ_CASE_INSENSITIVE | OBJ_OPENIF | OBJ_KERNEL_HANDLE,
                                            NULL,
                                            NULL );

                Status = ZwCreateDirectoryObject( &hDevMap,
                                                  DIRECTORY_ALL_ACCESS,
                                                  &Obja );

                if (NT_SUCCESS( Status )) {

                    //
                    // Set the DeviceMap for this directory object
                    //
                    Status = ObSetDirectoryDeviceMap( &pDeviceMap,
                                                      hDevMap );

                    if (NT_SUCCESS( Status )) {

                        //
                        // Create the Global SymLink to the global DosDevices
                        //
                        RtlInitUnicodeString( &SymLinkUnicodeString, L"Global" );

                        RtlInitUnicodeString( &UnicodeString, L"\\Global??" );

                        InitializeObjectAttributes(
                                &Obja,
                                &SymLinkUnicodeString,
                                OBJ_PERMANENT | OBJ_CASE_INSENSITIVE | OBJ_OPENIF | OBJ_KERNEL_HANDLE,
                                hDevMap,
                                NULL );

                        Status = ZwCreateSymbolicLinkObject( &hSymLink,
                                                             SYMBOLIC_LINK_ALL_ACCESS,
                                                             &Obja,
                                                             &UnicodeString );
                        if (NT_SUCCESS( Status )) {
                            ZwClose( hSymLink );
                        }
                        else {
                            ObfDereferenceDeviceMap(pDeviceMap);
                        }
                    }

                    ZwClose( hDevMap );
                }

                //
                // Reaquire the lock and modify the LUID structures
                //
                SepRmAcquireDbWriteLock(SessionArrayIndex);

                if (!NT_SUCCESS( Status )) {
                    *ppDevMap = NULL;
                }
                else {
                    if(Current->pDeviceMap == NULL) {
                        Current->pDeviceMap = pDeviceMap;
                    }
                    else {
                        ObfDereferenceDeviceMap(pDeviceMap);
                    }
                    *ppDevMap = Current->pDeviceMap;
                }

                SepRmReleaseDbWriteLock(SessionArrayIndex);

                //
                // Remove the reference we just added
                //

                SepDeReferenceLogonSessionDirect(Current);

                return Status;


            }
            else {

                //
                // Device Map for LUID already exist
                // return the handle to the Device Map
                //

                *ppDevMap = Current->pDeviceMap;
            }

            SepRmReleaseDbWriteLock(SessionArrayIndex);

            return ( Status );
        }

        Current = Current->Next;
    }

    SepRmReleaseDbWriteLock(SessionArrayIndex);

    //
    // Bad news, someone asked us for a device map of
    // a logon session we didn't know existed.  This might be a new
    // token being created, so return an error status and let the caller
    // decide if it warrants a bugcheck or not.
    //

    return STATUS_NO_SUCH_LOGON_SESSION;
}

#if DBG || TOKEN_LEAK_MONITOR

VOID 
SepAddTokenLogonSession(
    IN PTOKEN Token
    )

/*++

Routine Description

    Adds SEP_LOGON_SESSION_TOKEN to a reference monitor track.
    
Arguments

    Token - token to add
    
Return Value

    None
    
--*/

{
    ULONG SessionArrayIndex;
    PSEP_LOGON_SESSION_REFERENCES Current;
    PSEP_LOGON_SESSION_TOKEN TokenTrack = NULL;
    PLUID LogonId = &Token->AuthenticationId;

    PAGED_CODE();

    SessionArrayIndex = SepLogonSessionIndex( LogonId );

    //
    // Protect modification of reference monitor database
    //

    SepRmAcquireDbWriteLock(SessionArrayIndex);

    Current = SepLogonSessions[ SessionArrayIndex ];

    //
    // Now walk the list for our logon session array hash index.
    //

    while (Current != NULL) {

        //
        // If we found it, increment the reference count and return
        //
                   
        if (RtlEqualLuid( LogonId, &Current->LogonId )) {

             // 
             // Stick the token address into the track.  Find the last in the list of tokens
             // for this session.
             //
                        
             TokenTrack = ExAllocatePoolWithTag(PagedPool, sizeof(SEP_LOGON_SESSION_TOKEN), 'sLeS');

             if (TokenTrack) {
                 RtlZeroMemory(TokenTrack, sizeof(SEP_LOGON_SESSION_TOKEN));
                 TokenTrack->Token = Token;
                 InsertTailList(&Current->TokenList, &TokenTrack->ListEntry);
             } 

             SepRmReleaseDbWriteLock(SessionArrayIndex);
             return;
        }

        Current = Current->Next;
    }

    ASSERT(FALSE && L"Failed to add logon session token track.");
    SepRmReleaseDbWriteLock(SessionArrayIndex );
}

VOID
SepRemoveTokenLogonSession(
    IN PTOKEN Token
    )

/*++

Routine Description

    Removes a SEP_LOGON_SESSION_TOKEN from a reference monitor logon track.  
    
Arguments

    Token - token to remove 
    
Return Value

    None.
    
--*/

{
    ULONG SessionArrayIndex;
    PSEP_LOGON_SESSION_REFERENCES Current;
    PSEP_LOGON_SESSION_TOKEN TokenTrack = NULL;
    PLUID LogonId = &Token->AuthenticationId;
    PLIST_ENTRY ListEntry;
    
    PAGED_CODE();

    if (Token->TokenFlags & TOKEN_SESSION_NOT_REFERENCED) {
        return;
    }

    SessionArrayIndex = SepLogonSessionIndex( LogonId );

    //
    // Protect modification of reference monitor database
    //

    SepRmAcquireDbWriteLock(SessionArrayIndex);

    Current = SepLogonSessions[ SessionArrayIndex ];

    //
    // Now walk the list for our logon session array hash index.
    //

    while (Current != NULL) {

        if (RtlEqualLuid( LogonId, &Current->LogonId )) {
            
            //
            // Remove the token from the token list for this session.
            //

            ListEntry = Current->TokenList.Flink;
            
            while (ListEntry != &Current->TokenList) {
                TokenTrack = CONTAINING_RECORD (ListEntry, SEP_LOGON_SESSION_TOKEN, ListEntry);
                if (TokenTrack->Token == Token) {
                    RemoveEntryList (ListEntry);
                    SepRmReleaseDbWriteLock(SessionArrayIndex);

                    ExFreePool(TokenTrack);
                    TokenTrack = NULL;
                    return;
                }
                ListEntry = ListEntry->Flink;
            }
        }

        Current = Current->Next;
    }

#if DBG
        DbgPrint("Failed to delete logon session token track.");
#endif

    SepRmReleaseDbWriteLock(SessionArrayIndex);
}

#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\rmmain.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    rmmain.c

Abstract:

    Security Reference Monitor - Init, Control and State Change

--*/

#include "pch.h"

#pragma hdrstop


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,SeRmInitPhase1)
#pragma alloc_text(PAGE,SepRmCommandServerThread)
#pragma alloc_text(PAGE,SepRmCommandServerThreadInit)
#pragma alloc_text(PAGE,SepRmCallLsa)
#pragma alloc_text(INIT,SepRmInitPhase0)
#endif

//
// Reference Monitor Command Worker Table
//

//
// Keep this in sync with RM_COMMAND_NUMBER in ntrmlsa.h
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

const SEP_RM_COMMAND_WORKER SepRmCommandDispatch[] = {
                          NULL,
                          SepRmSetAuditEventWrkr,
                          SepRmCreateLogonSessionWrkr,
                          SepRmDeleteLogonSessionWrkr
                          };


BOOLEAN
SeRmInitPhase1(
    )

/*++

Routine Description:

    This function is called by Phase 1 System Initialization to initialize
    the Security Reference Monitor.  Note that initialization of the
    Reference Monitor Global State has already been performed in Phase 0
    initialization to allow access validation routines to operate without
    having to check that Reference Monitor Initialization is complete.

    The steps listed below are performed in this routine.  The remainder
    of Reference Monitor initialization requires the LSA subsystem to have run,
    so that initialization is performed in a separate thread (the RM Command
    Server Thread, see below), so that the present thread can create the
    Session Manager which execs the LSA.

    o Create the Reference Monitor Command LPC port.  The LSA subsystem sends
      commands (e.g. turn on auditing) which change the Reference Monitor
      Global State.
    o Create an Event for use in synchronizing with the LSA subsystem.  The
      LSA will signal the event when the portion of LSA initialization upon
      with the Reference Monitor depends is complete.  The Reference Monitor
      uses another LPC port, called the LSA Command Port to send commands
      to the LSA, so the RM must know that this port has been created before
      trying to connect to it.
    o Create the Reference Monitor Command Server Thread.  This thread is
      a permanent thread of the System Init process that fields the Reference
      Monitor State Change commands described above.


Arguments:

    None.

Return Value:

    BOOLEAN - TRUE if Rm Initialization (Phase 1) succeeded, else FALSE

--*/

{
    NTSTATUS Status;
    UNICODE_STRING RmCommandPortName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING LsaInitEventName;
    OBJECT_ATTRIBUTES LsaInitEventObjectAttributes;
    SECURITY_DESCRIPTOR LsaInitEventSecurityDescriptor;
    ULONG AclSize;

    PAGED_CODE();

    //
    // Create an LPC port called the Reference Monitor Command Port.
    // This will be used by the LSA to send commands to the Reference
    // Monitor to update its state data.
    //

    RtlInitUnicodeString( &RmCommandPortName, L"\\SeRmCommandPort" );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &RmCommandPortName,
        0,
        NULL,
        NULL
        );

    Status = ZwCreatePort(
                 &SepRmState.RmCommandServerPortHandle,
                 &ObjectAttributes,
                 sizeof(SEP_RM_CONNECT_INFO),
                 sizeof(RM_COMMAND_MESSAGE),
                 sizeof(RM_COMMAND_MESSAGE) * 32
                 );

    if( !NT_SUCCESS(Status) ) {

        KdPrint(("Security: Rm Create Command Port failed 0x%lx\n", Status));
        return FALSE;
    }

    //
    // Prepare to create an event for synchronizing with the LSA.
    // First, build the Security Descriptor for the Init Event Object
    //

    Status = RtlCreateSecurityDescriptor(
                 &LsaInitEventSecurityDescriptor,
                 SECURITY_DESCRIPTOR_REVISION
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("Security:  Creating Lsa Init Event Desc failed 0x%lx\n",
                  Status));
        return FALSE;
    }

    //
    // Allocate a temporary buffer from the paged pool.  It is a fatal
    // system error if the allocation fails since security cannot be
    // enabled.
    //

    AclSize = sizeof(ACL) +
              sizeof(ACCESS_ALLOWED_ACE) +
              SeLengthSid(SeLocalSystemSid);
    LsaInitEventSecurityDescriptor.Dacl =
        ExAllocatePoolWithTag(PagedPool, AclSize, 'cAeS');

    if (LsaInitEventSecurityDescriptor.Dacl == NULL) {

        KdPrint(("Security LSA:  Insufficient resources to initialize\n"));
        return FALSE;
    }

    //
    // Now create the Discretionary ACL within the Security Descriptor
    //

    Status = RtlCreateAcl(
                 LsaInitEventSecurityDescriptor.Dacl,
                 AclSize,
                 ACL_REVISION2
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("Security:  Creating Lsa Init Event Dacl failed 0x%lx\n",
                  Status));
        return FALSE;
    }

    //
    // Now add an ACE giving GENERIC_ALL access to the User ID
    //

    Status = RtlAddAccessAllowedAce(
                 LsaInitEventSecurityDescriptor.Dacl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 SeLocalSystemSid
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("Security:  Adding Lsa Init Event ACE failed 0x%lx\n",
                  Status));
        return FALSE;
    }

    //
    // Set up the Object Attributes for the Lsa Initialization Event
    //

    RtlInitUnicodeString( &LsaInitEventName, L"\\SeLsaInitEvent" );

    InitializeObjectAttributes(
        &LsaInitEventObjectAttributes,
        &LsaInitEventName,
        0,
        NULL,
        &LsaInitEventSecurityDescriptor
        );

    //
    // Create an event for use in synchronizing with the LSA.  The LSA will
    // signal this event when LSA initialization has reached the point
    // where the LSA's Reference Monitor Server Port has been created.
    //

    Status = ZwCreateEvent(
                 &(SepRmState.LsaInitEventHandle),
                 EVENT_MODIFY_STATE,
                 &LsaInitEventObjectAttributes,
                 NotificationEvent,
                 FALSE);

    if (!NT_SUCCESS(Status)) {

        KdPrint(("Security: LSA init event creation failed.0x%xl\n",
            Status));
        return FALSE;
    }

    //
    // Deallocate the pool memory used for the Init Event DACL
    //

    ExFreePool( LsaInitEventSecurityDescriptor.Dacl );

    //
    // Create a permanent thread of the Sysinit Process, called the
    // Reference Monitor Server Thread.  This thread is dedicated to
    // receiving Reference Monitor commands and dispatching them.
    //

    Status = PsCreateSystemThread(
                 &SepRmState.SepRmThreadHandle,
                 THREAD_GET_CONTEXT |
                 THREAD_SET_CONTEXT |
                 THREAD_SET_INFORMATION,
                 NULL,
                 NULL,
                 NULL,
                 SepRmCommandServerThread,
                 NULL
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("Security: Rm Server Thread creation failed 0x%lx\n", Status));
        return FALSE;
    }

    //
    // Initialize data from the registry.  This must go here because all other
    // Se initialization takes place before the registry is initialized.
    //

    SepAdtInitializeCrashOnFail();
    SepAdtInitializePrivilegeAuditing();
    SepAdtInitializeAuditingOptions();
    
    //
    // Reference Monitor initialization is successful if we get to here.
    //

    ZwClose( SepRmState.SepRmThreadHandle );
    SepRmState.SepRmThreadHandle = NULL;
    return TRUE;
}


VOID
SepRmCommandServerThread(
    IN PVOID StartContext
)

/*++

Routine Description:

    This function is executed indefinitely by a dedicated permanent thread
    of the Sysinit Process, called the Reference Monitor Server Thread.
    This thread updates Reference Monitor Global State Data by dispatching
    commands sent from the LSA through the the Reference Monitor LPC Command
    Port.  The following steps are repeated indefinitely:

    o  Initialize RM Command receive and reply buffer headers
    o  Perform remaining Reference Monitor initialization involving LSA
    o  Wait for RM command sent from LSA, send reply to previous command
       (if any)
    o  Validate command
    o  Dispatch to command worker routine to execute command.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    PRM_REPLY_MESSAGE Reply;
    RM_COMMAND_MESSAGE CommandMessage;
    RM_REPLY_MESSAGE ReplyMessage;

    PAGED_CODE();

    //
    // Perform the rest of the Reference Monitor initialization, involving
    // synchronization with the LSA or dependency on the LSA having run.
    //

    if (!SepRmCommandServerThreadInit()) {

        KdPrint(("Security: Terminating Rm Command Server Thread\n"));
        return;
    }

    Status = PoRequestShutdownEvent (NULL);
    if (!NT_SUCCESS (Status)) {
        ZwClose (SepRmState.RmCommandPortHandle);
        ZwClose (SepRmState.RmCommandServerPortHandle);
        ZwClose (SepRmState.LsaCommandPortHandle);
        ZwClose (SepLsaHandle);
        SepRmState.RmCommandPortHandle = NULL;
        SepRmState.RmCommandServerPortHandle = NULL;
        SepRmState.LsaCommandPortHandle = NULL;
        SepLsaHandle = NULL;
        return;
    }

    //
    // Initialize LPC port message header type and length fields for the
    // received command message.
    //

    CommandMessage.MessageHeader.u2.ZeroInit = 0;
    CommandMessage.MessageHeader.u1.s1.TotalLength =
        (CSHORT) sizeof(RM_COMMAND_MESSAGE);
    CommandMessage.MessageHeader.u1.s1.DataLength =
    CommandMessage.MessageHeader.u1.s1.TotalLength -
        (CSHORT) sizeof(PORT_MESSAGE);

    //
    // Initialize the LPC port message header type and data sizes for
    // for the reply message.
    //

    ReplyMessage.MessageHeader.u2.ZeroInit = 0;
    ReplyMessage.MessageHeader.u1.s1.TotalLength =
        (CSHORT) sizeof(RM_COMMAND_MESSAGE);
    ReplyMessage.MessageHeader.u1.s1.DataLength =
    ReplyMessage.MessageHeader.u1.s1.TotalLength -
        (CSHORT) sizeof(PORT_MESSAGE);

    //
    // First time through, there is no reply.
    //

    Reply = NULL;

    //
    // Now loop indefinitely, processing incoming Rm commands from the LSA.
    //

    for(;;) {

        //
        // Wait for Command, send reply to previous command (if any)
        //

        Status = ZwReplyWaitReceivePort(
                    SepRmState.RmCommandPortHandle,
                    NULL,
                    (PPORT_MESSAGE) Reply,
                    (PPORT_MESSAGE) &CommandMessage
                    );

        if (!NT_SUCCESS(Status)) {

            //
            // malicious user apps can try to connect to this port.  We will
            // fail later, but if their thread vanishes, we'll get a failure
            // here.  Ignore it:
            //

            if (Status == STATUS_UNSUCCESSFUL ||
                Status == STATUS_INVALID_CID ||
                Status == STATUS_REPLY_MESSAGE_MISMATCH)
            {
                //
                // skip it:
                //

                Reply = NULL ;
                continue;
            }

            KdPrint(("Security: RM message receive from Lsa failed %lx\n",
                Status));

        }

        //
        // Now dispatch to a routine to handle the command.  Allow
        // command errors to occur without bringing system down just now.
        //

        CommandMessage.MessageHeader.u2.s2.Type &= ~LPC_KERNELMODE_MESSAGE;

        if ( CommandMessage.MessageHeader.u2.s2.Type == LPC_REQUEST ) {

            if ( (CommandMessage.CommandNumber >= RmAuditSetCommand) &&
                 (CommandMessage.CommandNumber <= RmDeleteLogonSession) ) {

                (*(SepRmCommandDispatch[CommandMessage.CommandNumber]))
                    (&CommandMessage, &ReplyMessage);
                
                //
                // Initialize the client thread info and message id for the
                // reply message.  First time through, the reply message structure
                // is not used.
                //

                ReplyMessage.MessageHeader.ClientId =
                    CommandMessage.MessageHeader.ClientId;
                ReplyMessage.MessageHeader.MessageId =
                    CommandMessage.MessageHeader.MessageId;

                Reply = &ReplyMessage;
                
            } else {

                ASSERT( (CommandMessage.CommandNumber >= RmAuditSetCommand) &&
                        (CommandMessage.CommandNumber <= RmDeleteLogonSession) );
                Reply = NULL;
            }

        } else if (CommandMessage.MessageHeader.u2.s2.Type == LPC_PORT_CLOSED ) {
            KEVENT Event;
            BOOLEAN Wait;

            KeInitializeEvent (&Event, NotificationEvent, FALSE);

            SepLockLsaQueue();

            SepAdtLsaDeadEvent = &Event;
            
            Wait = !SepWorkListEmpty ();

            SepUnlockLsaQueue();

            if (Wait) {
                KeWaitForSingleObject (&Event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
            }
            //
            // Our only client closed its handle. Tidy up and exit.
            //
            ZwClose (SepRmState.LsaCommandPortHandle);
            ZwClose (SepRmState.RmCommandPortHandle);
            ZwClose (SepRmState.RmCommandServerPortHandle);
            ZwClose (SepLsaHandle);
            SepRmState.LsaCommandPortHandle = NULL;
            SepRmState.RmCommandPortHandle = NULL;
            SepRmState.RmCommandServerPortHandle = NULL;
            SepLsaHandle = NULL;
            break;
        } else if (CommandMessage.MessageHeader.u2.s2.Type == LPC_CONNECTION_REQUEST) {
            HANDLE tmp;
            //
            // Reject extra connection attempts
            //
            Status = ZwAcceptConnectPort(&tmp,
                                         NULL,
                                         (PPORT_MESSAGE) &CommandMessage,
                                         FALSE,
                                         NULL,
                                         NULL);
        } else {

            Reply = NULL;
        }
    }  // end_for

    UNREFERENCED_PARAMETER( StartContext );

}


BOOLEAN
SepRmCommandServerThreadInit(
    VOID
    )

/*++

Routine Description:

    This function performs initialization of the Reference Monitor Server
    thread.  The following steps are performed.

    o  Wait on the LSA signaling the event.  When the event is signaled,
       the LSA has already created the LSA Command Server LPC Port
    o  Close the LSA Init Event Handle.  The event is not used again.
    o  Listen for the LSA to connect to the Port
    o  Accept the connection.
    o  Connect to the LSA Command Server LPC Port

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS Status;
    UNICODE_STRING LsaCommandPortName;
    PORT_MESSAGE ConnectionRequest;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PORT_VIEW ClientView;
    REMOTE_PORT_VIEW LsaClientView;
    BOOLEAN BooleanStatus = TRUE;

    PAGED_CODE();

    //
    // Save a pointer to our process so we can get back into this process
    // to send commands to the LSA (using a handle to an LPC port created
    // below).
    //

    SepRmLsaCallProcess = PsGetCurrentProcess();

    ObReferenceObject(SepRmLsaCallProcess);

    //
    // Wait on the LSA signaling the event.  This means that the LSA
    // has created its command port, not that LSA initialization is
    // complete.
    //

    Status = ZwWaitForSingleObject(
                 SepRmState.LsaInitEventHandle,
                 FALSE,
                 NULL);

    if ( !NT_SUCCESS(Status) ) {

        KdPrint(("Security Rm Init: Waiting for LSA Init Event failed 0x%lx\n", Status));
        goto RmCommandServerThreadInitError;
    }

    //
    // Close the LSA Init Event Handle.  The event is not used again.
    //

    ZwClose(SepRmState.LsaInitEventHandle);

    //
    // Listen for a connection to be made by the LSA to the Reference Monitor
    // Command Port.  This connection will be made by the LSA process.
    //

    ConnectionRequest.u1.s1.TotalLength = sizeof(ConnectionRequest);
    ConnectionRequest.u1.s1.DataLength = (CSHORT)0;
    Status = ZwListenPort(
                 SepRmState.RmCommandServerPortHandle,
                 &ConnectionRequest
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("Security Rm Init: Listen to Command Port failed 0x%lx\n",
            Status));
        goto RmCommandServerThreadInitError;
    }

    //
    // Obtain a handle to the LSA process for use when auditing.
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );

    Status = ZwOpenProcess(
                 &SepLsaHandle,
                 PROCESS_VM_OPERATION | PROCESS_VM_WRITE,
                 &ObjectAttributes,
                 &ConnectionRequest.ClientId
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("Security Rm Init: Open Listen to Command Port failed 0x%lx\n",
            Status));
        goto RmCommandServerThreadInitError;
    }

    //
    // Accept the connection made by the LSA process.
    //

    LsaClientView.Length = sizeof(LsaClientView);


    Status = ZwAcceptConnectPort(
                 &SepRmState.RmCommandPortHandle,
                 NULL,
                 &ConnectionRequest,
                 TRUE,
                 NULL,
                 &LsaClientView
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("Security Rm Init: Accept Connect to Command Port failed 0x%lx\n",
                Status));

        goto RmCommandServerThreadInitError;
    }

    //
    // Complete the connection.
    //

    Status = ZwCompleteConnectPort(SepRmState.RmCommandPortHandle);

    if (!NT_SUCCESS(Status)) {

        KdPrint(("Security Rm Init: Complete Connect to Command Port failed 0x%lx\n",
                Status));
        goto RmCommandServerThreadInitError;
    }

    //
    // Set up the security quality of service parameters to use over the
    // Lsa Command LPC port.  Use the most efficient (least overhead) - which
    // is dynamic rather than static tracking.
    //

    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;

    //
    // Create the section to be used as unnamed shared memory for
    // communication between the RM and LSA.
    //

    SepRmState.LsaCommandPortSectionSize.LowPart = PAGE_SIZE;
    SepRmState.LsaCommandPortSectionSize.HighPart = 0;

    Status = ZwCreateSection(
                 &SepRmState.LsaCommandPortSectionHandle,
                 SECTION_ALL_ACCESS,
                 NULL,                           // ObjectAttributes
                 &SepRmState.LsaCommandPortSectionSize,
                 PAGE_READWRITE,
                 SEC_COMMIT,
                 NULL                            // FileHandle
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("Security Rm Init: Create Memory Section for LSA port failed: %X\n", Status));
        goto RmCommandServerThreadInitError;
    }

    //
    // Set up for a call to NtConnectPort and connect to the LSA port.
    // This setup includes a description of the port memory section so that
    // the LPC connection logic can make the section visible to both the
    // client and server processes.
    //

    ClientView.Length = sizeof(ClientView);
    ClientView.SectionHandle = SepRmState.LsaCommandPortSectionHandle;
    ClientView.SectionOffset = 0;
    ClientView.ViewSize = SepRmState.LsaCommandPortSectionSize.LowPart;
    ClientView.ViewBase = 0;
    ClientView.ViewRemoteBase = 0;

    //
    // Set up the security quality of service parameters to use over the
    // port.  Use dynamic tracking so that XACTSRV will impersonate the
    // user that we are impersonating when we call NtRequestWaitReplyPort.
    // If we used static tracking, XACTSRV would impersonate the context
    // when the connection is made.
    //

    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;

    //
    // Connect to the Lsa Command LPC Port.  This port is used to send
    // commands from the RM to the LSA.
    //

    RtlInitUnicodeString( &LsaCommandPortName, L"\\SeLsaCommandPort" );

    Status = ZwConnectPort(
                 &SepRmState.LsaCommandPortHandle,
                 &LsaCommandPortName,
                 &DynamicQos,
                 &ClientView,
                 NULL,                           // ServerView
                 NULL,                           // MaxMessageLength
                 NULL,                           // ConnectionInformation
                 NULL                            // ConnectionInformationLength
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("Security Rm Init: Connect to LSA Port failed 0x%lx\n", Status));
        goto RmCommandServerThreadInitError;
    }

    //
    // Store information about the section so that we can create pointers
    // meaningful to LSA.
    //

    SepRmState.RmViewPortMemory = ClientView.ViewBase;
    SepRmState.LsaCommandPortMemoryDelta =
        (LONG)((ULONG_PTR)ClientView.ViewRemoteBase - (ULONG_PTR) ClientView.ViewBase );
    SepRmState.LsaViewPortMemory = ClientView.ViewRemoteBase;


RmCommandServerThreadInitFinish:

    //
    // Dont need this section handle any more, even if returning
    // success.
    //

    if ( SepRmState.LsaCommandPortSectionHandle != NULL ) {

       NtClose( SepRmState.LsaCommandPortSectionHandle );
       SepRmState.LsaCommandPortSectionHandle = NULL;
    }

    //
    // The Reference Monitor Thread has successfully initialized.
    //

    return BooleanStatus;

RmCommandServerThreadInitError:

    if ( SepRmState.LsaCommandPortHandle != NULL ) {

       NtClose( SepRmState.LsaCommandPortHandle );
       SepRmState.LsaCommandPortHandle = NULL;
    }

    BooleanStatus = FALSE;
    goto RmCommandServerThreadInitFinish;
}




NTSTATUS
SepRmCallLsa(
    PSEP_WORK_ITEM SepWorkItem
    )
/*++

Routine Description:

    This function sends a command to the LSA via the LSA Reference Monitor
    Server Command LPC Port.  If the command has parameters, they will be
    copied directly into a message structure and sent via LPC, therefore,
    the supplied parameters may not contain any absolute pointers.  A caller
    must remove pointers by "marshalling" them into the buffer CommandParams.

    This function will create a queue of requests.  This is in order to allow
    greater throughput for the majority if its callers.  If a thread enters
    this routine and finds the queue empty, it is the responsibility of that
    thread to service all requests that come in while it is working until the
    queue is empty again.  Other threads that enter will simply hook their work
    item onto the queue and exit.


    To implement a new LSA command, do the following:
    ================================================

    (1)  If the command takes no parameters, just call this routine directly
         and provide an LSA worker routine called Lsap<command>Wrkr.  See
         file lsa\server\lsarm.c for examples

    (2)  If the command takes parameters, provide a routine called
         SepRmSend<command>Command that takes the parameters in unmarshalled
         form and calls SepRmCallLsa() with the command id, marshalled
         parameters, length  of marshalled parameters and pointer to
         optional reply message.  The marshalled parameters are free format:
         the only restriction is that there must be no absolute address
         pointers.  These parameters are all placed in the passed LsaWorkItem
         structure.

    (3)  In file private\inc\ntrmlsa.h, append a command name  to the
         enumerated type LSA_COMMAND_NUMBER defined in file
         private\inc\ntrmlsa.h.  Change the #define for LsapMaximumCommand
         to reference the new command.

    (4)  Add the Lsap<command>Wrkr to the command dispatch table structure
         LsapCommandDispatch[] in file lsarm.c.

    (5)  Add function prototypes to lsap.h and sep.h.


Arguments:

    LsaWorkItem - Supplies a pointer to an SE_LSA_WORK_ITEM containing the
        information to be passed to LSA.  This structure will be freed
        asynchronously by some invocation of this routine, not necessarily
        in the current context.

        !THIS PARAMETER MUST BE ALLOCATED OUT OF NONPAGED POOL!

Return Value:

    NTSTATUS - Result Code.  This is either a result code returned from
        trying to send the command/receive the reply, or a status code
        from the command itself.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSA_COMMAND_MESSAGE CommandMessage;
    LSA_REPLY_MESSAGE ReplyMessage;
    PSEP_LSA_WORK_ITEM WorkQueueItem;
    ULONG LocalListLength = 0;
    SIZE_T RegionSize;
    PVOID CopiedCommandParams = NULL;
    PVOID LsaViewCopiedCommandParams = NULL;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( SepWorkItem );
    
    WorkQueueItem = SepWorkListHead();

    KeAttachProcess( &SepRmLsaCallProcess->Pcb );

    while ( WorkQueueItem ) {

        //
        // Construct a message for LPC.  First, fill in the message header
        // fields for LPC, specifying the message type and data sizes for
        // the outgoing CommandMessage and the incoming ReplyMessage.
        //

        CommandMessage.MessageHeader.u2.ZeroInit = 0;
        CommandMessage.MessageHeader.u1.s1.TotalLength =
            ((CSHORT) RM_COMMAND_MESSAGE_HEADER_SIZE +
            (CSHORT) WorkQueueItem->CommandParamsLength);
        CommandMessage.MessageHeader.u1.s1.DataLength =
            CommandMessage.MessageHeader.u1.s1.TotalLength -
            (CSHORT) sizeof(PORT_MESSAGE);

        ReplyMessage.MessageHeader.u2.ZeroInit = 0;
        ReplyMessage.MessageHeader.u1.s1.DataLength = (CSHORT) WorkQueueItem->ReplyBufferLength;
        ReplyMessage.MessageHeader.u1.s1.TotalLength =
            ReplyMessage.MessageHeader.u1.s1.DataLength +
            (CSHORT) sizeof(PORT_MESSAGE);

        //
        // Next, fill in the header info needed by the LSA.
        //

        CommandMessage.CommandNumber = WorkQueueItem->CommandNumber;
        ReplyMessage.ReturnedStatus = STATUS_SUCCESS;

        //
        // Set up the Command Parameters either in the LPC Command Message
        // itself, in the preallocated Lsa shared memory block, or in a
        // specially allocated block.  The parameters are either
        // immediate (i.e. in the WorkQueueItem itself, or are in a buffer
        // pointed to by the address in the WorkQueueItem.
        //

        switch (WorkQueueItem->CommandParamsMemoryType) {

        case SepRmImmediateMemory:

            //
            // The Command Parameters are in the CommandParams buffer
            // in the Work Queue Item.  Just copy them to the corresponding
            // buffer in the CommandMessage buffer.
            //

            CommandMessage.CommandParamsMemoryType = SepRmImmediateMemory;

            RtlCopyMemory(
                CommandMessage.CommandParams,
                &WorkQueueItem->CommandParams,
                WorkQueueItem->CommandParamsLength
                );

            break;

        case SepRmPagedPoolMemory:
        case SepRmUnspecifiedMemory:

            //
            // The Command Parameters are contained in paged pool memory.
            // Since this memory is is not accessible by the LSA, we must
            // copy of them either to the LPC Command Message Block, or
            // into LSA shared memory.
            //

            if (WorkQueueItem->CommandParamsLength <= LSA_MAXIMUM_COMMAND_PARAM_SIZE) {

                //
                // Parameters will fit into the LPC Command Message block.
                //

                CopiedCommandParams = CommandMessage.CommandParams;

                RtlCopyMemory(
                    CopiedCommandParams,
                    WorkQueueItem->CommandParams.BaseAddress,
                    WorkQueueItem->CommandParamsLength
                    );

                CommandMessage.CommandParamsMemoryType = SepRmImmediateMemory;

            } else {

                //
                // Parameters too large for LPC Command Message block.
                // If possible, copy them to the preallocated Lsa Shared
                // Memory block.  If they are too large to fit, copy them
                // to an individually allocated chunk of Shared Virtual
                // Memory.
                //

                if (WorkQueueItem->CommandParamsLength <= SEP_RM_LSA_SHARED_MEMORY_SIZE) {

                    RtlCopyMemory(
                        SepRmState.RmViewPortMemory,
                        WorkQueueItem->CommandParams.BaseAddress,
                        WorkQueueItem->CommandParamsLength
                        );

                    LsaViewCopiedCommandParams = SepRmState.LsaViewPortMemory;
                    CommandMessage.CommandParamsMemoryType = SepRmLsaCommandPortSharedMemory;

                } else {

                    Status = SepAdtCopyToLsaSharedMemory(
                                 SepLsaHandle,
                                 WorkQueueItem->CommandParams.BaseAddress,
                                 WorkQueueItem->CommandParamsLength,
                                 &LsaViewCopiedCommandParams
                                 );

                    if (!NT_SUCCESS(Status)) {

                        //
                        // An error occurred, most likely in allocating
                        // shared virtual memory.  For now, just ignore
                        // the error and discard the Audit Record.  Later,
                        // we may consider generating a warning record
                        // indicating some records lost.
                        //

                        break;

                    }

                    CommandMessage.CommandParamsMemoryType = SepRmLsaCustomSharedMemory;
                }

                //
                // Buffer has been successfully copied to a shared Lsa
                // memory buffer.  Place the address of the buffer valid in
                // the LSA's process context in the Command Message.
                //

                *((PVOID *) CommandMessage.CommandParams) =
                    LsaViewCopiedCommandParams;

                CommandMessage.MessageHeader.u1.s1.TotalLength =
                    ((CSHORT) RM_COMMAND_MESSAGE_HEADER_SIZE +
                    (CSHORT) sizeof( LsaViewCopiedCommandParams ));
                CommandMessage.MessageHeader.u1.s1.DataLength =
                    CommandMessage.MessageHeader.u1.s1.TotalLength -
                    (CSHORT) sizeof(PORT_MESSAGE);
            }

            //
            // Free input command params buffer if Paged Pool.
            //

            if (WorkQueueItem->CommandParamsMemoryType == SepRmPagedPoolMemory) {

                ExFreePool( WorkQueueItem->CommandParams.BaseAddress );
            }

            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (NT_SUCCESS(Status)) {

            //
            // Send Message to the LSA via the LSA Server Command LPC Port.
            // This must be done in the process in which the handle was created.
            //

            if( WorkQueueItem->CommandNumber == LsapLogonSessionDeletedCommand &&
                WorkQueueItem->ReplyBuffer == NULL
                )
            {
                //
                // send a datagram.
                //

                Status = ZwRequestPort(
                         SepRmState.LsaCommandPortHandle,
                         (PPORT_MESSAGE) &CommandMessage
                         );

                ReplyMessage.ReturnedStatus = STATUS_SUCCESS;

            } else {

                Status = ZwRequestWaitReplyPort(
                         SepRmState.LsaCommandPortHandle,
                         (PPORT_MESSAGE) &CommandMessage,
                         (PPORT_MESSAGE) &ReplyMessage
                         );
            }

            //
            // If the command was successful, copy the data back to the output
            // buffer.
            //

            if (NT_SUCCESS(Status)) {

                //
                // Move output from command (if any) to buffer.  Note that this
                // is done even if the command returns status, because some status
                // values are not errors.
                //

                if (ARGUMENT_PRESENT(WorkQueueItem->ReplyBuffer)) {

                    RtlCopyMemory(
                        WorkQueueItem->ReplyBuffer,
                        ReplyMessage.ReplyBuffer,
                        WorkQueueItem->ReplyBufferLength
                        );
                }

                //
                // Return status from command.
                //

                Status = ReplyMessage.ReturnedStatus;

                if (!NT_SUCCESS(Status)) {
                    KdPrint(("Security: Command sent from RM to LSA returned 0x%lx\n",
                        Status));
                }

            } else {

                KdPrint(("Security: Sending Command RM to LSA failed 0x%lx\n", Status));
            }

            //
            // On return from the LPC call to the LSA, we expect the called
            // LSA worker routine to have copied the Command Parameters
            // buffer (if any).  If a custom shared memory buffer was allocated,
            // free it now.
            //

            if (CommandMessage.CommandParamsMemoryType == SepRmLsaCustomSharedMemory) {

                RegionSize = 0;

                Status = ZwFreeVirtualMemory(
                             SepLsaHandle,
                             (PVOID *) &CommandMessage.CommandParams,
                             &RegionSize,
                             MEM_RELEASE
                             );

                ASSERT(NT_SUCCESS(Status));
            }

        }


        //
        // Clean up.  We must call the cleanup functions on its parameter
        // and then free the used WorkQueueItem itself.
        //

        if ( ARGUMENT_PRESENT( WorkQueueItem->CleanupFunction)) {

            (WorkQueueItem->CleanupFunction)(WorkQueueItem->CleanupParameter);
        }

        //
        // Determine if there is more work to do on this list
        //

        WorkQueueItem = SepDequeueWorkItem();
    }

    KeDetachProcess();

    if ( LocalListLength > SepLsaQueueLength ) {
        SepLsaQueueLength = LocalListLength;
    }

    return Status;
}





BOOLEAN
SepRmInitPhase0(
    )

/*++

Routine Description:

    This function performs Reference Monitor Phase 0 initialization.
    This includes initializing the reference monitor database to a state
    which allows access validation routines to operate (always granting
    access) prior to the main init of the Reference Monitor in Phase 1
    initialization, without having to check if the RM is initialized.


Arguments:

    None.

Return Value:

   BOOLEAN - TRUE if successful, else FALSE

--*/

{

    BOOLEAN CompletionStatus;

    PAGED_CODE();

    CompletionStatus = SepRmDbInitialization();

    return CompletionStatus;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\privileg.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Privileg.c

Abstract:

    This Module implements the privilege check procedures.

--*/

#include "pch.h"

#pragma hdrstop


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtPrivilegeCheck)
#pragma alloc_text(PAGE,SeCheckPrivilegedObject)
#pragma alloc_text(PAGE,SepPrivilegeCheck)
#pragma alloc_text(PAGE,SePrivilegeCheck)
#pragma alloc_text(PAGE,SeSinglePrivilegeCheck)
#endif


BOOLEAN
SepPrivilegeCheck(
    IN PTOKEN Token,
    IN OUT PLUID_AND_ATTRIBUTES RequiredPrivileges,
    IN ULONG RequiredPrivilegeCount,
    IN ULONG PrivilegeSetControl,
    IN KPROCESSOR_MODE PreviousMode
    )
/*++

Routine Description:

    Worker routine for SePrivilegeCheck

Arguments:

    Token - The user's effective token.

    RequiredPrivileges - A privilege set describing the required
        privileges.  The UsedForAccess bits will be set in any privilege
        that is actually used (usually all of them).

    RequiredPrivilegeCount - How many privileges are in the
        RequiredPrivileges set.

    PrivilegeSetControl - Describes how many privileges are required.

    PreviousMode - The previous processor mode.

Return Value:

    Returns TRUE if requested privileges are granted, FALSE otherwise.

--*/

{
    PLUID_AND_ATTRIBUTES CurrentRequiredPrivilege;
    PLUID_AND_ATTRIBUTES CurrentTokenPrivilege;

    BOOLEAN RequiredAll;

    ULONG TokenPrivilegeCount;
    ULONG MatchCount = 0;

    ULONG i;
    ULONG j;

    PAGED_CODE();

    //
    //   Take care of kernel callers first
    //

    if (PreviousMode == KernelMode) {

         return(TRUE);

    }

    TokenPrivilegeCount = Token->PrivilegeCount;

    //
    //   Save whether we require ALL of them or ANY
    //

    RequiredAll = (BOOLEAN)(PrivilegeSetControl & PRIVILEGE_SET_ALL_NECESSARY);

    SepAcquireTokenReadLock( Token );


    for ( i = 0 , CurrentRequiredPrivilege = RequiredPrivileges ;
          i < RequiredPrivilegeCount ;
          i++, CurrentRequiredPrivilege++ ) {

         for ( j = 0, CurrentTokenPrivilege = Token->Privileges;
               j < TokenPrivilegeCount ;
               j++, CurrentTokenPrivilege++ ) {

              if ((CurrentTokenPrivilege->Attributes & SE_PRIVILEGE_ENABLED) &&
                   (RtlEqualLuid(&CurrentTokenPrivilege->Luid,
                                 &CurrentRequiredPrivilege->Luid))
                 ) {

                       CurrentRequiredPrivilege->Attributes |=
                                                SE_PRIVILEGE_USED_FOR_ACCESS;
                       MatchCount++;
                       break;     // start looking for next one
              }

         }

    }

    SepReleaseTokenReadLock( Token );

    //
    //   If we wanted ANY and didn't get any, return failure.
    //

    if (!RequiredAll && (MatchCount == 0)) {

         return (FALSE);

    }

    //
    // If we wanted ALL and didn't get all, return failure.
    //

    if (RequiredAll && (MatchCount != RequiredPrivilegeCount)) {

         return(FALSE);
    }

    return(TRUE);

}




BOOLEAN
SePrivilegeCheck(
    __inout PPRIVILEGE_SET RequiredPrivileges,
    __in PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    __in KPROCESSOR_MODE AccessMode
    )
/*++

Routine Description:

    This routine checks to see if the token contains the specified
    privileges.

Arguments:

    RequiredPrivileges - Points to a set of privileges.  The subject's
        security context is to be checked to see which of the specified
        privileges are present.  The results will be indicated in the
        attributes associated with each privilege.  Note that
        flags in this parameter indicate whether all the privileges listed
        are needed, or any of the privileges.

    SubjectSecurityContext - A pointer to the subject's captured security
        context.

    AccessMode - Indicates the access mode to use for access check.  One of
        UserMode or KernelMode.  If the mode is kernel, then all privileges
        will be marked as being possessed by the subject, and successful
        completion status is returned.


Return Value:

    BOOLEAN - TRUE if all specified privileges are held by the subject,
    otherwise FALSE.


--*/

{
    BOOLEAN Status;

    PAGED_CODE();

    //
    // If we're impersonating a client, we have to be at impersonation level
    // of SecurityImpersonation or above.
    //

    if ( (SubjectSecurityContext->ClientToken != NULL) &&
         (SubjectSecurityContext->ImpersonationLevel < SecurityImpersonation)
       ) {

           return(FALSE);
    }

    //
    // SepPrivilegeCheck locks the passed token for read access
    //

    Status = SepPrivilegeCheck(
                 EffectiveToken( SubjectSecurityContext ),
                 RequiredPrivileges->Privilege,
                 RequiredPrivileges->PrivilegeCount,
                 RequiredPrivileges->Control,
                 AccessMode
                 );

    return(Status);
}



NTSTATUS
NtPrivilegeCheck(
    __in HANDLE ClientToken,
    __inout PPRIVILEGE_SET RequiredPrivileges,
    __out PBOOLEAN Result
    )

/*++

Routine Description:

    This routine tests the caller's client's security context to see if it
    contains the specified privileges.

Arguments:

    ClientToken - A handle to a token object representing a client
        attempting access.  This handle must be obtained from a
        communication session layer, such as from an LPC Port or Local
        Named Pipe, to prevent possible security policy violations.

    RequiredPrivileges - Points to a set of privileges.  The client's
        security context is to be checked to see which of the specified
        privileges are present.  The results will be indicated in the
        attributes associated with each privilege.  Note that
        flags in this parameter indicate whether all the privileges listed
        are needed, or any of the privileges.

    Result - Receives a boolean flag indicating whether the client has all
        the specified privileges or not.  A value of TRUE indicates the
        client has all the specified privileges.  Otherwise a value of
        FALSE is returned.



Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_PRIVILEGE_NOT_HELD - Indicates the caller does not have
        sufficient privilege to use this privileged system service.

--*/



{
    BOOLEAN BStatus;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PLUID_AND_ATTRIBUTES CapturedPrivileges = NULL;
    PTOKEN Token = NULL;
    ULONG CapturedPrivilegeCount = 0;
    ULONG CapturedPrivilegesLength = 0;
    ULONG ParameterLength = 0;
    ULONG PrivilegeSetControl = 0;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    Status = ObReferenceObjectByHandle(
         ClientToken,             // Handle
         TOKEN_QUERY,             // DesiredAccess
         SeTokenObjectType,      // ObjectType
         PreviousMode,            // AccessMode
         (PVOID *)&Token,         // Object
         NULL                     // GrantedAccess
         );

    if ( !NT_SUCCESS(Status) ) {
         return Status;

    }

    //
    // If the passed token is an impersonation token, make sure
    // it is at SecurityIdentification or above.
    //

    if (Token->TokenType == TokenImpersonation) {

        if (Token->ImpersonationLevel < SecurityIdentification) {

            ObDereferenceObject( (PVOID)Token );

            return( STATUS_BAD_IMPERSONATION_LEVEL );

        }
    }

    try  {

         //
         // Capture passed Privilege Set
         //

         ProbeForWriteSmallStructure(
             RequiredPrivileges,
             sizeof(PRIVILEGE_SET),
             sizeof(ULONG)
             );

         CapturedPrivilegeCount = RequiredPrivileges->PrivilegeCount;

         if (!IsValidElementCount(CapturedPrivilegeCount, LUID_AND_ATTRIBUTES)) {
             Status = STATUS_INVALID_PARAMETER;
             leave;
         }
         ParameterLength = (ULONG)sizeof(PRIVILEGE_SET) +
                           ((CapturedPrivilegeCount - ANYSIZE_ARRAY) *
                             (ULONG)sizeof(LUID_AND_ATTRIBUTES)  );

         ProbeForWrite(
             RequiredPrivileges,
             ParameterLength,
             sizeof(ULONG)
             );


         ProbeForWriteBoolean(Result);

         PrivilegeSetControl = RequiredPrivileges->Control;


    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS(Status)) {
        ObDereferenceObject( (PVOID)Token );
        return Status;

    }

    Status = SeCaptureLuidAndAttributesArray(
                    (RequiredPrivileges->Privilege),
                    CapturedPrivilegeCount,
                    UserMode,
                    NULL, 0,
                    PagedPool,
                    TRUE,
                    &CapturedPrivileges,
                    &CapturedPrivilegesLength
                    );

    if (!NT_SUCCESS(Status)) {

        ObDereferenceObject( (PVOID)Token );
        return Status;
    }

    BStatus = SepPrivilegeCheck(
                  Token,                   // Token,
                  CapturedPrivileges,      // RequiredPrivileges,
                  CapturedPrivilegeCount,  // RequiredPrivilegeCount,
                  PrivilegeSetControl,     // PrivilegeSetControl
                  PreviousMode             // PreviousMode
                  );

    ObDereferenceObject( Token );


    try {

        //
        // copy the modified privileges buffer back to user
        //

        RtlCopyMemory(
            RequiredPrivileges->Privilege,
            CapturedPrivileges,
            CapturedPrivilegesLength
            );

        *Result = BStatus;

        } except (EXCEPTION_EXECUTE_HANDLER) {

            SeReleaseLuidAndAttributesArray(
               CapturedPrivileges,
               PreviousMode,
               TRUE
               );

            return(GetExceptionCode());

        }

    SeReleaseLuidAndAttributesArray(
        CapturedPrivileges,
        PreviousMode,
        TRUE
        );

    return( STATUS_SUCCESS );
}



BOOLEAN
SeSinglePrivilegeCheck(
    __in LUID PrivilegeValue,
    __in KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This function will check for the passed privilege value in the
    current context.

Arguments:

    PrivilegeValue - The value of the privilege being checked.


Return Value:

    TRUE - The current subject has the desired privilege.

    FALSE - The current subject does not have the desired privilege.
--*/

{
    BOOLEAN AccessGranted;
    PRIVILEGE_SET RequiredPrivileges;
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;

    PAGED_CODE();

    //
    // Make sure the caller has the privilege to make this
    // call.
    //

    RequiredPrivileges.PrivilegeCount = 1;
    RequiredPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
    RequiredPrivileges.Privilege[0].Luid = PrivilegeValue;
    RequiredPrivileges.Privilege[0].Attributes = 0;

    SeCaptureSubjectContext( &SubjectSecurityContext );

    AccessGranted = SePrivilegeCheck(
                        &RequiredPrivileges,
                        &SubjectSecurityContext,
                        PreviousMode
                        );

    if ( PreviousMode != KernelMode ) {

        SePrivilegedServiceAuditAlarm (
            NULL,
            &SubjectSecurityContext,
            &RequiredPrivileges,
            AccessGranted
            );
    }


    SeReleaseSubjectContext( &SubjectSecurityContext );

    return( AccessGranted );

}


BOOLEAN
SeCheckPrivilegedObject(
    __in LUID PrivilegeValue,
    __in HANDLE ObjectHandle,
    __in ACCESS_MASK DesiredAccess,
    __in KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This function will check for the passed privilege value in the
    current context, and generate audits as appropriate.

Arguments:

    PrivilegeValue - The value of the privilege being checked.

    Object - Specifies a pointer to the object being accessed.

    ObjectHandle - Specifies the object handle being used.

    DesiredAccess - The desired access mask, if any

    PreviousMode - The previous processor mode


Return Value:

    TRUE - The current subject has the desired privilege.

    FALSE - The current subject does not have the desired privilege.
--*/

{
    BOOLEAN AccessGranted;
    PRIVILEGE_SET RequiredPrivileges;
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;

    PAGED_CODE();

    //
    // Make sure the caller has the privilege to make this
    // call.
    //

    RequiredPrivileges.PrivilegeCount = 1;
    RequiredPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
    RequiredPrivileges.Privilege[0].Luid = PrivilegeValue;
    RequiredPrivileges.Privilege[0].Attributes = 0;

    SeCaptureSubjectContext( &SubjectSecurityContext );

    AccessGranted = SePrivilegeCheck(
                        &RequiredPrivileges,
                        &SubjectSecurityContext,
                        PreviousMode
                        );

    if ( PreviousMode != KernelMode ) {

        SePrivilegeObjectAuditAlarm(
            ObjectHandle,
            &SubjectSecurityContext,
            DesiredAccess,
            &RequiredPrivileges,
            AccessGranted,
            PreviousMode
            );

    }


    SeReleaseSubjectContext( &SubjectSecurityContext );

    return( AccessGranted );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\rmvars.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    rmvars.c

Abstract:

   This module contains the variables used to implement the run-time
   reference monitor database.

--*/

#include "pch.h"

#pragma hdrstop


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,SepRmDbInitialization)
#endif


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  Read/Write Reference Monitor Variables                                    //
//                                                                            //
//  Access to these variables is protected by the SepRmDbLock.                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


//
//  Resource Locks  - These locks protect access to the modifiable fields of
//                    the reference monitor database. There is one lock for
//                    a set of hash buckets.
//

ERESOURCE SepRmDbLock[SEP_LOGON_TRACK_LOCK_ARRAY_SIZE] = {0};
                     
//
//  Resource Lock  - This mutex protects access to the file systems notify
//                   routines list
//

FAST_MUTEX SepRmNotifyMutex = {0};


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  Read Only Reference Monitor Variables                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


//
// The process within which the RM --> LSA command LPC port was established.
// All calls from the reference monitor to the LSA must be made in this
// process in order for the handle to be valid.

PEPROCESS SepRmLsaCallProcess = NULL;

//
// State of the reference monitor
//

SEP_RM_STATE SepRmState = {0};


//
// The following array is used as a hash bucket for tracking logon sessions.
// The sequence number of logon LUIDs is ANDed with 0x0F and then used as an
// index into this array.  This entry in the array serves as a listhead of
// logon session reference count records.
//

PSEP_LOGON_SESSION_REFERENCES *SepLogonSessions = NULL;



////////////////////////////////////////////////////////////////////////
//                                                                    //
//           Variable Initialization Routines                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////

BOOLEAN
SepRmDbInitialization(
    VOID
    )
/*++

Routine Description:

    This function initializes the reference monitor in-memory database.

Arguments:

    None.

Return Value:

    TRUE if database successfully initialized.
    FALSE if not successfully initialized.

--*/
{
    NTSTATUS Status;
    ULONG i;

    //
    // Create the reference monitor database lock
    //
    // Use SepRmAcquireDbReadLock()
    //     SepRmAcquireDbWriteLock()
    //     SepRmReleaseDbReadLock()
    //     SepRmReleaseDbWriteLock()
    //
    // to gain access to the reference monitor database.
    //

    for (i=0;i<SEP_LOGON_TRACK_LOCK_ARRAY_SIZE;i++) {
        ExInitializeResourceLite(&(SepRmDbLock[ i ]));
    }
    
    //
    // Create the file systems notify list mutex
    //
    //
    // Use SepRmAcquireNotifyLock()
    //     SepRmReleaseNotifyLock()
    //
    //
    // to safely access the file systems notify list.
    //

    ExInitializeFastMutex(&SepRmNotifyMutex);

    //
    // Initialize the Logon Session tracking array.
    //

    SepLogonSessions = ExAllocatePoolWithTag( PagedPool,
                                              sizeof( PSEP_LOGON_SESSION_REFERENCES ) * SEP_LOGON_TRACK_ARRAY_SIZE,
                                              'SLeS'
                                              );

    if (SepLogonSessions == NULL) {
        return( FALSE );
    }

    for (i=0;i<SEP_LOGON_TRACK_ARRAY_SIZE;i++) {

        SepLogonSessions[ i ] = NULL;
    }

    //
    // Now add in a record representing the system logon session.
    //

    Status = SepCreateLogonSessionTrack( (PLUID)&SeSystemAuthenticationId );
    ASSERT( NT_SUCCESS(Status) );
    if ( !NT_SUCCESS(Status)) {
        return FALSE;
    }

    //
    // Add one for the null session logon session
    //

    Status = SepCreateLogonSessionTrack( (PLUID)&SeAnonymousAuthenticationId );
    ASSERT( NT_SUCCESS(Status) );
    if ( !NT_SUCCESS(Status)) {
        return FALSE;
    }

    //
    // The correct RM state will be set when the local security policy
    // information is retrieved (by the LSA) and subsequently passed to
    // the reference monitor later on in initialization.  For now, initialize
    // the state to something that will work for the remainder of
    // system initialization.
    //

    SepRmState.AuditingEnabled = 0;    // auditing state disabled.
    SepRmState.OperationalMode = LSA_MODE_PASSWORD_PROTECTED;

    return TRUE;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\seastate.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    SeAstate.c

Abstract:

    This Module implements the privilege check procedures.

--*/

#include "pch.h"

#pragma hdrstop


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SeCreateAccessState)
#pragma alloc_text(PAGE,SeCreateAccessStateEx)
#pragma alloc_text(PAGE,SeDeleteAccessState)
#pragma alloc_text(PAGE,SeSetAccessStateGenericMapping)
#pragma alloc_text(PAGE,SeAppendPrivileges)
#pragma alloc_text(PAGE,SepConcatenatePrivileges)
#endif


//
// Define logical sum of all generic accesses.
//

#define GENERIC_ACCESS (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL)


//
// The PRIVILEGE_SET data structure includes an array including ANYSIZE_ARRAY
// elements.  This definition provides the size of an empty PRIVILEGE_SET
// (i.e., one with no privileges in it).
//

#define SEP_PRIVILEGE_SET_HEADER_SIZE           \
            ((ULONG)sizeof(PRIVILEGE_SET) -     \
                (ANYSIZE_ARRAY * (ULONG)sizeof(LUID_AND_ATTRIBUTES)))





NTSTATUS
SeCreateAccessState(
   __out PACCESS_STATE AccessState,
   __out PAUX_ACCESS_DATA AuxData,
   __in ACCESS_MASK DesiredAccess,
   __in_opt PGENERIC_MAPPING GenericMapping
   )

/*++
Routine Description:

    This routine initializes an ACCESS_STATE structure.  This consists
    of:

    - zeroing the entire structure

    - mapping generic access types in the passed DesiredAccess
    and putting it into the structure

    - "capturing" the Subject Context, which must be held for the
    duration of the access attempt (at least until auditing is performed).

    - Allocating an Operation ID, which is an LUID that will be used
    to associate different parts of the access attempt in the audit
    log.

Arguments:

    AccessState - a pointer to the structure to be initialized.

    AuxData - Supplies a buffer big enough for an AuxData structure
        so we don't have to allocate one.

    DesiredAccess - Access mask containing the desired access

    GenericMapping - Optionally supplies a pointer to a generic mapping
        that may be used to map any generic access requests that may
        have been passed in the DesiredAccess parameter.

        Note that if this parameter is not supplied, it must be filled
        in at some later point.  The IO system does this in IopParseDevice.

Return Value:

    Error if the attempt to allocate an LUID fails.

    Note that this error may be safely ignored if it is known that all
    security checks will be performed with PreviousMode == KernelMode.
    Know what you're doing if you choose to ignore this.

--*/

{
    return SeCreateAccessStateEx (PsGetCurrentThread (),
                                  PsGetCurrentProcess (),
                                  AccessState,
                                  AuxData,
                                  DesiredAccess,
                                  GenericMapping);
}

NTSTATUS
SeCreateAccessStateEx(
   __in_opt PETHREAD Thread,
   __in PEPROCESS Process,
   __out PACCESS_STATE AccessState,
   __out PAUX_ACCESS_DATA AuxData,
   __in ACCESS_MASK DesiredAccess,
   __in_opt PGENERIC_MAPPING GenericMapping
   )

/*++
Routine Description:

    This routine initializes an ACCESS_STATE structure.  This consists
    of:

    - zeroing the entire structure

    - mapping generic access types in the passed DesiredAccess
    and putting it into the structure

    - "capturing" the Subject Context, which must be held for the
    duration of the access attempt (at least until auditing is performed).

    - Allocating an Operation ID, which is an LUID that will be used
    to associate different parts of the access attempt in the audit
    log.

Arguments:

    Thread - Optional thread to capture impersonation token from. If
             NULL no impersonation token is captured.

    Process - Process to capture primary token from.

    AccessState - a pointer to the structure to be initialized.

    AuxData - Supplies a buffer big enough for an AuxData structure
        so we don't have to allocate one.

    DesiredAccess - Access mask containing the desired access

    GenericMapping - Optionally supplies a pointer to a generic mapping
        that may be used to map any generic access requests that may
        have been passed in the DesiredAccess parameter.

        Note that if this parameter is not supplied, it must be filled
        in at some later point.  The IO system does this in IopParseDevice.

Return Value:

    Error if the attempt to allocate an LUID fails.

    Note that this error may be safely ignored if it is known that all
    security checks will be performed with PreviousMode == KernelMode.
    Know what you're doing if you choose to ignore this.

--*/

{

    ACCESS_MASK MappedAccessMask;
    PSECURITY_DESCRIPTOR InputSecurityDescriptor = NULL;

    PAGED_CODE();

    //
    // Don't modify what he passed in
    //

    MappedAccessMask = DesiredAccess;

    //
    // Map generic access to object specific access iff generic access types
    // are specified and a generic access mapping table is provided.
    //

    if ( ((DesiredAccess & GENERIC_ACCESS) != 0) &&
         ARGUMENT_PRESENT(GenericMapping) ) {

        RtlMapGenericMask(
            &MappedAccessMask,
            GenericMapping
            );
    }

    RtlZeroMemory(AccessState, sizeof(ACCESS_STATE));
    RtlZeroMemory(AuxData, sizeof(AUX_ACCESS_DATA));

    //
    // Assume RtlZeroMemory has initialized these fields properly
    //

    ASSERT( AccessState->SecurityDescriptor == NULL );
    ASSERT( AccessState->PrivilegesAllocated == FALSE );

    AccessState->AuxData = AuxData;

    SeCaptureSubjectContextEx(Thread, Process, &AccessState->SubjectSecurityContext);

    if (((PTOKEN)EffectiveToken( &AccessState->SubjectSecurityContext ))->TokenFlags & TOKEN_HAS_TRAVERSE_PRIVILEGE ) {
        AccessState->Flags = TOKEN_HAS_TRAVERSE_PRIVILEGE;
    }

    AccessState->RemainingDesiredAccess = MappedAccessMask;
    AccessState->OriginalDesiredAccess = MappedAccessMask;
    AuxData->PrivilegesUsed = (PPRIVILEGE_SET)((ULONG_PTR)AccessState +
                              (FIELD_OFFSET(ACCESS_STATE, Privileges)));

    ExAllocateLocallyUniqueId(&AccessState->OperationID);

    if (ARGUMENT_PRESENT(GenericMapping)) {
        AuxData->GenericMapping = *GenericMapping;
    }

    return( STATUS_SUCCESS );

}


VOID
SeDeleteAccessState(
    __in PACCESS_STATE AccessState
    )

/*++

Routine Description:

    This routine deallocates any memory that may have been allocated as
    part of constructing the access state (normally only for an excessive
    number of privileges), and frees the Subject Context.

Arguments:

    AccessState - a pointer to the ACCESS_STATE structure to be
        deallocated.

Return Value:

    None.

--*/

{
    PAUX_ACCESS_DATA AuxData;

    PAGED_CODE();

    AuxData = (PAUX_ACCESS_DATA)AccessState->AuxData;

    if (AccessState->PrivilegesAllocated) {
        ExFreePool( (PVOID)AuxData->PrivilegesUsed );
    }

    if (AccessState->ObjectName.Buffer != NULL) {
        ExFreePool(AccessState->ObjectName.Buffer);
    }

    if (AccessState->ObjectTypeName.Buffer != NULL) {
        ExFreePool(AccessState->ObjectTypeName.Buffer);
    }

    SeReleaseSubjectContext(&AccessState->SubjectSecurityContext);

    return;
}

VOID
SeSetAccessStateGenericMapping (
    __inout PACCESS_STATE AccessState,
    __in PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    This routine sets the GenericMapping field in an AccessState structure.
    It must be called before access validation is performed if the GenericMapping
    is not passed in when the AccessState structure is created.

Arguments:

    AccessState - a pointer to the ACCESS_STATE structure to be modified.

    GenericMapping - a pointer to the GenericMapping to be copied into the AccessState.

Return Value:


--*/
{
    PAUX_ACCESS_DATA AuxData;

    PAGED_CODE();

    AuxData = (PAUX_ACCESS_DATA)AccessState->AuxData;

    AuxData->GenericMapping = *GenericMapping;

    return;
}



NTSTATUS
SeAppendPrivileges(
    __inout PACCESS_STATE AccessState,
    __in PPRIVILEGE_SET Privileges
    )
/*++

Routine Description:

    This routine takes a privilege set and adds it to the privilege set
    embedded in an ACCESS_STATE structure.

    An AccessState may contain up to three embedded privileges.  To
    add more, this routine will allocate a block of memory, copy
    the current privileges into it, and append the new privilege
    to that block.  A bit is set in the AccessState indicating that
    the pointer to the privilege set in the structure points to pool
    memory and must be deallocated.

Arguments:

    AccessState - The AccessState structure representing the current
        access attempt.

    Privileges - A pointer to a privilege set to be added.

Return Value:

    STATUS_INSUFFICIENT_RESOURCES - an attempt to allocate pool memory
        failed.

--*/

{
    ULONG NewPrivilegeSetSize;
    PPRIVILEGE_SET NewPrivilegeSet;
    PAUX_ACCESS_DATA AuxData;

    PAGED_CODE();

    AuxData = (PAUX_ACCESS_DATA)AccessState->AuxData;

    if (Privileges->PrivilegeCount + AuxData->PrivilegesUsed->PrivilegeCount >
        INITIAL_PRIVILEGE_COUNT) {

        //
        // Compute the total size of the two privilege sets
        //

        NewPrivilegeSetSize =  SepPrivilegeSetSize( Privileges ) +
                               SepPrivilegeSetSize( AuxData->PrivilegesUsed );

        NewPrivilegeSet = ExAllocatePoolWithTag( PagedPool, NewPrivilegeSetSize, 'rPeS' );

        if (NewPrivilegeSet == NULL) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }


        RtlCopyMemory(
            NewPrivilegeSet,
            AuxData->PrivilegesUsed,
            SepPrivilegeSetSize( AuxData->PrivilegesUsed )
            );

        //
        // Note that this will adjust the privilege count in the
        // structure for us.
        //

        SepConcatenatePrivileges(
            NewPrivilegeSet,
            NewPrivilegeSetSize,
            Privileges
            );

        if (AccessState->PrivilegesAllocated) {
            ExFreePool( AuxData->PrivilegesUsed );
        }

        AuxData->PrivilegesUsed = NewPrivilegeSet;

        //
        // Mark that we've allocated memory for the privilege set,
        // so we know to free it when we're cleaning up.
        //

        AccessState->PrivilegesAllocated = TRUE;

    } else {

        //
        // Note that this will adjust the privilege count in the
        // structure for us.
        //

        SepConcatenatePrivileges(
            AuxData->PrivilegesUsed,
            sizeof(INITIAL_PRIVILEGE_SET),
            Privileges
            );

    }

    return( STATUS_SUCCESS );

}


VOID
SepConcatenatePrivileges(
    IN PPRIVILEGE_SET TargetPrivilegeSet,
    IN ULONG TargetBufferSize,
    IN PPRIVILEGE_SET SourcePrivilegeSet
    )

/*++

Routine Description:

    Takes two privilege sets and appends the second to the end of the
    first.

    There must be enough space left at the end of the first privilege
    set to contain the second.

Arguments:

    TargetPrivilegeSet - Supplies a buffer containing a privilege set.
        The buffer must be large enough to contain the second privilege
        set.

    TargetBufferSize - Supplies the size of the target buffer.

    SourcePrivilegeSet - Supplies the privilege set to be copied
        into the target buffer.

Return Value:

    None

--*/

{
    PVOID Base;
    PVOID Source;
    ULONG Length;

    PAGED_CODE();

    ASSERT( ((ULONG)SepPrivilegeSetSize( TargetPrivilegeSet ) +
             (ULONG)SepPrivilegeSetSize( SourcePrivilegeSet ) -
             SEP_PRIVILEGE_SET_HEADER_SIZE  ) <=
            TargetBufferSize
          );

    Base = (PVOID)((ULONG_PTR)TargetPrivilegeSet + SepPrivilegeSetSize( TargetPrivilegeSet ));

    Source = (PVOID) ((ULONG_PTR)SourcePrivilegeSet + SEP_PRIVILEGE_SET_HEADER_SIZE);

    Length = SourcePrivilegeSet->PrivilegeCount * sizeof(LUID_AND_ATTRIBUTES);

    RtlMoveMemory(
        Base,
        Source,
        Length
        );

    TargetPrivilegeSet->PrivilegeCount += SourcePrivilegeSet->PrivilegeCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\rmp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    rmp.h

Abstract:

    Security Reference Monitor Private Data Types, Functions and Defines

--*/

#ifndef _RMP_H_
#define _RMP_H_

#include <nt.h>
#include <ntlsa.h>
#include "sep.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//  Reference Monitor Private defines                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
// Used to define the bounds of the array used to track logon session
// reference counts.
//

#define SEP_LOGON_TRACK_INDEX_MASK (0x0000000FL)
#define SEP_LOGON_TRACK_ARRAY_SIZE (0x00000010L)

//
// Used to define the bounds of the locks array used to reference the logon
// sessions. We use a hardcoded index of ZERO for when LogonId is not 
// available.
// The number of locks was chosen to be 4 based on performance tests on
// uniproc and 8-proc machines.
//

#define SEP_LOGON_TRACK_LOCK_INDEX_MASK (0x00000003L)
#define SEP_LOGON_TRACK_LOCK_ARRAY_SIZE (0x00000004L)



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//  Reference Monitor Private Macros                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
//  acquire exclusive access to a token
//

#define SepRmAcquireDbReadLock(i)  KeEnterCriticalRegion();         \
                                   ExAcquireResourceSharedLite(&(SepRmDbLock[(i) & SEP_LOGON_TRACK_LOCK_INDEX_MASK]), TRUE)

#define SepRmAcquireDbWriteLock(i) KeEnterCriticalRegion();         \
                                   ExAcquireResourceExclusiveLite(&(SepRmDbLock[(i) & SEP_LOGON_TRACK_LOCK_INDEX_MASK]), TRUE)

#define SepRmReleaseDbReadLock(i)  ExReleaseResourceLite(&(SepRmDbLock[(i) & SEP_LOGON_TRACK_LOCK_INDEX_MASK])); \
                                   KeLeaveCriticalRegion()

#define SepRmReleaseDbWriteLock(i) ExReleaseResourceLite(&(SepRmDbLock[(i) & SEP_LOGON_TRACK_LOCK_INDEX_MASK])); \
                                   KeLeaveCriticalRegion()

#define SepRmAcquireNotifyLock()  KeEnterCriticalRegion();         \
                                  ExAcquireFastMutexUnsafe(&SepRmNotifyMutex)

#define SepRmReleaseNotifyLock()  ExReleaseFastMutexUnsafe(&SepRmNotifyMutex); \
                                  KeLeaveCriticalRegion()


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//  Reference Monitor Private Data Types                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SEP_RM_LSA_SHARED_MEMORY_SIZE ((ULONG) PAGE_SIZE)

//
// Reference Monitor Private Global State Data Structure
//

typedef struct _SEP_RM_STATE {

    HANDLE LsaInitEventHandle;
    HANDLE LsaCommandPortHandle;
    HANDLE SepRmThreadHandle;
    HANDLE RmCommandPortHandle;
    HANDLE RmCommandServerPortHandle;
    ULONG AuditingEnabled;
    LSA_OPERATIONAL_MODE OperationalMode;
    HANDLE LsaCommandPortSectionHandle;
    LARGE_INTEGER LsaCommandPortSectionSize;
    PVOID LsaViewPortMemory;
    PVOID RmViewPortMemory;
    LONG LsaCommandPortMemoryDelta;
//    BOOLEAN LsaCommandPortResourceInitialized;
    BOOLEAN LsaCommandPortActive;
//    ERESOURCE LsaCommandPortResource;

} SEP_RM_STATE, *PSEP_RM_STATE;

//
// Reference Monitor Command Port Connection Info
//

typedef struct _SEP_RM_CONNECT_INFO {
    ULONG ConnectInfo;
} SEP_RM_CONNECT_INFO;

typedef struct SEP_RM_CONNECT_INFO *PSEP_RM_CONNECT_INFO;


//
// Reference Monitor Command Table Entry Format
//

#define SEP_RM_COMMAND_MAX 4

typedef VOID (*SEP_RM_COMMAND_WORKER)( PRM_COMMAND_MESSAGE, PRM_REPLY_MESSAGE );

typedef struct _SEP_LOGON_SESSION_TOKEN {
    LIST_ENTRY ListEntry;
    PTOKEN Token;
} SEP_LOGON_SESSION_TOKEN, *PSEP_LOGON_SESSION_TOKEN;


#define SEP_TERMINATION_NOTIFY  0x1

//
// File systems interested in being notified when a logon session is being
// terminated register a callback routine. The following data structure
// describes the callback routines.
//
// The global list of callback routines is pointed to by SeFileSystemNotifyRoutines.
// This list is protected by the RM database lock.
//

typedef struct _SEP_LOGON_SESSION_TERMINATED_NOTIFICATION {
    struct _SEP_LOGON_SESSION_TERMINATED_NOTIFICATION *Next;
    PSE_LOGON_SESSION_TERMINATED_ROUTINE CallbackRoutine;
} SEP_LOGON_SESSION_TERMINATED_NOTIFICATION, *PSEP_LOGON_SESSION_TERMINATED_NOTIFICATION;

extern SEP_LOGON_SESSION_TERMINATED_NOTIFICATION
SeFileSystemNotifyRoutinesHead;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//  Reference Monitor Private Function Prototypes                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOLEAN
SepRmDbInitialization(
    VOID
    );

VOID
SepRmCommandServerThread(
    IN PVOID StartContext
    );

BOOLEAN SepRmCommandServerThreadInit(
    );

VOID
SepRmComponentTestCommandWrkr(
    IN PRM_COMMAND_MESSAGE CommandMessage,
    OUT PRM_REPLY_MESSAGE ReplyMessage
    );

VOID
SepRmSetAuditEventWrkr(
    IN PRM_COMMAND_MESSAGE CommandMessage,
    OUT PRM_REPLY_MESSAGE ReplyMessage
    );

VOID
SepRmSendCommandToLsaWrkr(
    IN PRM_COMMAND_MESSAGE CommandMessage,
    OUT PRM_REPLY_MESSAGE ReplyMessage
    );

VOID
SepRmCreateLogonSessionWrkr(
    IN PRM_COMMAND_MESSAGE CommandMessage,
    OUT PRM_REPLY_MESSAGE ReplyMessage
    );

VOID
SepRmDeleteLogonSessionWrkr(
    IN PRM_COMMAND_MESSAGE CommandMessage,
    OUT PRM_REPLY_MESSAGE ReplyMessage
    ) ;


NTSTATUS
SepCreateLogonSessionTrack(
    IN PLUID LogonId
    );

NTSTATUS
SepDeleteLogonSessionTrack(
    IN PLUID LogonId
    );



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Reference Monitor Private Variables Declarations                          //
// These variables are defined in rmvars.c                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern PEPROCESS SepRmLsaCallProcess;
extern SEP_RM_STATE SepRmState;
extern ERESOURCE SepRmDbLock[];
extern FAST_MUTEX SepRmNotifyMutex;
extern PSEP_LOGON_SESSION_REFERENCES *SepLogonSessions;

#endif // _RMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\seassign.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Seassign.c

Abstract:

    This Module implements the SeAssignSecurity procedure.  For a description
    of the pool allocation strategy please see the comments in semethod.c

--*/


#include "pch.h"

#pragma hdrstop

//
//  Local macros and procedures
//

NTSTATUS
SepInheritAcl (
    IN PACL Acl,
    IN BOOLEAN IsDirectoryObject,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PSID ServerSid OPTIONAL,
    IN PSID ClientSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN POOL_TYPE PoolType,
    OUT PACL *NewAcl
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SeAssignSecurity)
#pragma alloc_text(PAGE,SeAssignSecurityEx)
#pragma alloc_text(PAGE,SeDeassignSecurity)
#pragma alloc_text(PAGE,SepInheritAcl)
#pragma alloc_text(PAGE,SeAssignWorldSecurityDescriptor)
#if DBG
#pragma alloc_text(PAGE,SepDumpSecurityDescriptor)
#pragma alloc_text(PAGE,SepPrintAcl)
#pragma alloc_text(PAGE,SepPrintSid)
#pragma alloc_text(PAGE,SepDumpTokenInfo)
#pragma alloc_text(PAGE,SepSidTranslation)
#endif //DBG
#endif


//
// These variables control whether security descriptors and token
// information are dumped by their dump routines.  This allows
// selective turning on and off of debugging output by both program
// control and via the kernel debugger.
//

#if DBG

BOOLEAN SepDumpSD = FALSE;
BOOLEAN SepDumpToken = FALSE;

#endif




NTSTATUS
SeAssignSecurity (
    __in_opt PSECURITY_DESCRIPTOR ParentDescriptor,
    __in_opt PSECURITY_DESCRIPTOR ExplicitDescriptor,
    __out PSECURITY_DESCRIPTOR *NewDescriptor,
    __in BOOLEAN IsDirectoryObject,
    __in PSECURITY_SUBJECT_CONTEXT SubjectContext,
    __in PGENERIC_MAPPING GenericMapping,
    __in POOL_TYPE PoolType
    )

/*++

Routine Description:

    This routine assumes privilege checking HAS NOT yet been performed
    and so will be performed by this routine.

    This procedure is used to build a security descriptor for a new object
    given the security descriptor of its parent directory and any originally
    requested security for the object.  The final security descriptor
    returned to the caller may contain a mix of information, some explicitly
    provided other from the new object's parent.


    See RtlpNewSecurityObject for a descriptor of how the NewDescriptor is
    built.


Arguments:

    ParentDescriptor - Optionally supplies the security descriptor of the
        parent directory under which this new object is being created.

    ExplicitDescriptor - Supplies the address of a pointer to the security
        descriptor as specified by the user that is to be applied to
        the new object.

    NewDescriptor - Returns the actual security descriptor for the new
        object that has been modified according to above rules.

    IsDirectoryObject - Specifies if the new object is itself a directory
        object.  A value of TRUE indicates the object is a container of other
        objects.

    SubjectContext - Supplies the security context of the subject creating the
        object. This is used to retrieve default security information for the
        new object, such as default owner, primary group, and discretionary
        access control.

    GenericMapping - Supplies a pointer to an array of access mask values
        denoting the mapping between each generic right to non-generic rights.

    PoolType - Specifies the pool type to use to when allocating a new
        security descriptor.

Return Value:

    STATUS_SUCCESS - indicates the operation was successful.

    STATUS_INVALID_OWNER - The owner SID provided as the owner of the
        target security descriptor is not one the caller is authorized
        to assign as the owner of an object.

    STATUS_PRIVILEGE_NOT_HELD - The caller does not have the privilege
        necessary to explicitly assign the specified system ACL.
        SeSecurityPrivilege privilege is needed to explicitly assign
        system ACLs to objects.
--*/

{
    NTSTATUS Status;
    ULONG AutoInherit = 0;
    PAGED_CODE();

#if DBG
    if ( ARGUMENT_PRESENT( ExplicitDescriptor) ) {
        SepDumpSecurityDescriptor( ExplicitDescriptor,
                                   "\nSeAssignSecurity: Input security descriptor = \n"
                                 );
    }

    if (ARGUMENT_PRESENT( ParentDescriptor )) {
        SepDumpSecurityDescriptor( ParentDescriptor,
                                   "\nSeAssignSecurity: Parent security descriptor = \n"
                                 );
    }
#endif // DBG

    //
    // If the Parent SD was created via AutoInheritance,
    //  and this object is being created with no explicit descriptor,
    //  then we can safely create this object as AutoInherit.
    //

    if ( ParentDescriptor != NULL ) {

        if ( (ExplicitDescriptor == NULL ||
              (((PISECURITY_DESCRIPTOR)ExplicitDescriptor)->Control & SE_DACL_PRESENT) == 0 ) &&
             (((PISECURITY_DESCRIPTOR)ParentDescriptor)->Control & SE_DACL_AUTO_INHERITED) != 0 ) {
            AutoInherit |= SEF_DACL_AUTO_INHERIT;
        }

        if ( (ExplicitDescriptor == NULL ||
             (((PISECURITY_DESCRIPTOR)ExplicitDescriptor)->Control & SE_SACL_PRESENT) == 0 ) &&
             (((PISECURITY_DESCRIPTOR)ParentDescriptor)->Control & SE_SACL_AUTO_INHERITED) != 0 ) {
            AutoInherit |= SEF_SACL_AUTO_INHERIT;
        }

    }


    Status = RtlpNewSecurityObject (
                    ParentDescriptor OPTIONAL,
                    ExplicitDescriptor OPTIONAL,
                    NewDescriptor,
                    NULL,   // No object type
                    0,
                    IsDirectoryObject,
                    AutoInherit,
                    (HANDLE) SubjectContext,
                    GenericMapping );

#if DBG
    if ( NT_SUCCESS(Status)) {
        SepDumpSecurityDescriptor( *NewDescriptor,
                                   "SeAssignSecurity: Final security descriptor = \n"
                                 );
    }
#endif

    return Status;


    // RtlpNewSecurityObject always uses PagedPool.
    UNREFERENCED_PARAMETER( PoolType );

}


NTSTATUS
SeAssignSecurityEx (
    __in_opt PSECURITY_DESCRIPTOR ParentDescriptor,
    __in_opt PSECURITY_DESCRIPTOR ExplicitDescriptor,
    __out PSECURITY_DESCRIPTOR *NewDescriptor,
    __in_opt GUID *ObjectType,
    __in BOOLEAN IsDirectoryObject,
    __in ULONG AutoInheritFlags,
    __in PSECURITY_SUBJECT_CONTEXT SubjectContext,
    __in PGENERIC_MAPPING GenericMapping,
    __in POOL_TYPE PoolType
    )

/*++

Routine Description:

    This routine assumes privilege checking HAS NOT yet been performed
    and so will be performed by this routine.

    This procedure is used to build a security descriptor for a new object
    given the security descriptor of its parent directory and any originally
    requested security for the object.  The final security descriptor
    returned to the caller may contain a mix of information, some explicitly
    provided other from the new object's parent.


    See RtlpNewSecurityObject for a descriptor of how the NewDescriptor is
    built.


Arguments:

    ParentDescriptor - Optionally supplies the security descriptor of the
        parent directory under which this new object is being created.

    ExplicitDescriptor - Supplies the address of a pointer to the security
        descriptor as specified by the user that is to be applied to
        the new object.

    NewDescriptor - Returns the actual security descriptor for the new
        object that has been modified according to above rules.

    ObjectType - GUID of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    IsDirectoryObject - Specifies if the new object is itself a directory
        object.  A value of TRUE indicates the object is a container of other
        objects.

    AutoInheritFlags - Controls automatic inheritance of ACES from the Parent
        Descriptor.  Valid values are a bits mask of the logical OR of
        one or more of the following bits:

        SEF_DACL_AUTO_INHERIT - If set, inherit ACEs from the
            DACL ParentDescriptor are inherited to NewDescriptor in addition
            to any explicit ACEs specified by the CreatorDescriptor.

        SEF_SACL_AUTO_INHERIT - If set, inherit ACEs from the
            SACL ParentDescriptor are inherited to NewDescriptor in addition
            to any explicit ACEs specified by the CreatorDescriptor.

        SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT - If set, the CreatorDescriptor
            is the default descriptor for ObjectType.  As such, the
            CreatorDescriptor will be ignored if any ObjectType specific
            ACEs are inherited from the parent.  If no such ACEs are inherited,
            the CreatorDescriptor is handled as though this flag were not
            specified.

        SEF_AVOID_PRIVILEGE_CHECK - If set, no privilege checking is done by this
            routine.  This flag is useful while implementing automatic inheritance
            to avoid checking privileges on each child updated.

    SubjectContext - Supplies the security context of the subject creating the
        object. This is used to retrieve default security information for the
        new object, such as default owner, primary group, and discretionary
        access control.

    GenericMapping - Supplies a pointer to an array of access mask values
        denoting the mapping between each generic right to non-generic rights.

    PoolType - Specifies the pool type to use to when allocating a new
        security descriptor.

Return Value:

    STATUS_SUCCESS - indicates the operation was successful.

    STATUS_INVALID_OWNER - The owner SID provided as the owner of the
        target security descriptor is not one the caller is authorized
        to assign as the owner of an object.

    STATUS_PRIVILEGE_NOT_HELD - The caller does not have the privilege
        necessary to explicitly assign the specified system ACL.
        SeSecurityPrivilege privilege is needed to explicitly assign
        system ACLs to objects.
--*/

{
    NTSTATUS Status;
    PAGED_CODE();

#if DBG
    if ( ARGUMENT_PRESENT( ExplicitDescriptor) ) {
        SepDumpSecurityDescriptor( ExplicitDescriptor,
                                   "\nSeAssignSecurityEx: Input security descriptor = \n"
                                 );
    }

    if (ARGUMENT_PRESENT( ParentDescriptor )) {
        SepDumpSecurityDescriptor( ParentDescriptor,
                                   "\nSeAssignSecurityEx: Parent security descriptor = \n"
                                 );
    }
#endif // DBG


    Status = RtlpNewSecurityObject (
                    ParentDescriptor OPTIONAL,
                    ExplicitDescriptor OPTIONAL,
                    NewDescriptor,
                    ObjectType ? &ObjectType : NULL,
                    ObjectType ? 1 : 0,
                    IsDirectoryObject,
                    AutoInheritFlags,
                    (HANDLE) SubjectContext,
                    GenericMapping );

#if DBG
    if ( NT_SUCCESS(Status)) {
        SepDumpSecurityDescriptor( *NewDescriptor,
                                   "SeAssignSecurityEx: Final security descriptor = \n"
                                 );
    }
#endif

    return Status;


    // RtlpNewSecurityObject always uses PagedPool.
    UNREFERENCED_PARAMETER( PoolType );

}


NTSTATUS
SeDeassignSecurity (
    __deref_inout PSECURITY_DESCRIPTOR *SecurityDescriptor
    )

/*++

Routine Description:

    This routine deallocates the memory associated with a security descriptor
    that was assigned using SeAssignSecurity.


Arguments:

    SecurityDescriptor - Supplies the address of a pointer to the security
        descriptor  being deleted.

Return Value:

    STATUS_SUCCESS - The deallocation was successful.

--*/

{
    PAGED_CODE();

    if ((*SecurityDescriptor) != NULL) {
        ExFreePool( (*SecurityDescriptor) );
    }

    //
    //  And zero out the pointer to it for safety sake
    //

    (*SecurityDescriptor) = NULL;

    return( STATUS_SUCCESS );

}



NTSTATUS
SepInheritAcl (
    IN PACL Acl,
    IN BOOLEAN IsDirectoryObject,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN POOL_TYPE PoolType,
    OUT PACL *NewAcl
    )

/*++

Routine Description:

    This is a private routine that produces an inherited acl from
    a parent acl according to the rules of inheritance

Arguments:

    Acl - Supplies the acl being inherited.

    IsDirectoryObject - Specifies if the new acl is for a directory.

    OwnerSid - Specifies the owner Sid to use.

    GroupSid - Specifies the group SID to use.

    ServerSid - Specifies the Server SID to use.

    ClientSid - Specifies the Client SID to use.

    GenericMapping - Specifies the generic mapping to use.

    PoolType - Specifies the pool type for the new acl.

    NewAcl - Receives a pointer to the new (inherited) acl.

Return Value:

    STATUS_SUCCESS - An inheritable ACL was successfully generated.

    STATUS_NO_INHERITANCE - An inheritable ACL was not successfully generated.
        This is a warning completion status.

    STATUS_BAD_INHERITANCE_ACL - Indicates the acl built was not a valid ACL.
        This can be caused by a number of things.  One of the more probable
        causes is the replacement of a CreatorId with an SID that didn't fit
        into the ACE or ACL.

    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that
        is unknown to this routine.

--*/

{
//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//   The logic in the ACL inheritance code must mirror the code for         //
//   inheritance in the user mode runtime (in sertl.c). Do not make changes //
//   here without also making changes in that module.                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


    NTSTATUS Status;
    ULONG NewAclLength;
    BOOLEAN NewAclExplicitlyAssigned;
    ULONG NewGenericControl;

    PAGED_CODE();
    ASSERT( PoolType == PagedPool ); // RtlpInheritAcl assumes paged pool

    //
    //  First check if the acl is null
    //

    if (Acl == NULL) {

        return STATUS_NO_INHERITANCE;
    }

    //
    // Generating an inheritable ACL.
    //
    // Pass all parameters as though there is no auto inheritance.
    //

    Status = RtlpInheritAcl(
                 Acl,
                 NULL,  // No child ACL since no auto inheritance
                 0,     // No child control since no auto inheritance
                 IsDirectoryObject,
                 FALSE, // Not AutoInherit since no auto inheritance
                 FALSE, // Not DefaultDescriptor since no auto inheritance
                 ClientOwnerSid,
                 ClientGroupSid,
                 ServerOwnerSid,
                 ServerGroupSid,
                 GenericMapping,
                 FALSE, // Isn't a SACL
                 NULL,  // No object GUID
                 0,
                 NewAcl,
                 &NewAclExplicitlyAssigned,
                 &NewGenericControl );

    return Status;
}



NTSTATUS
SeAssignWorldSecurityDescriptor(
    __inout_bcount_part( *Length, *Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
    __inout PULONG Length,
    __in PSECURITY_INFORMATION SecurityInformation
    )

/*++

Routine Description:

    This routine is called by the I/O system to properly initialize a
    security descriptor for a FAT file.  It will take a pointer to a
    buffer containing an emptry security descriptor, and create in the
    buffer a self-relative security descriptor with

        Owner = WorldSid,

        Group = WorldSid.

    Thus, a FAT file is accessable to all.

Arguments:

    SecurityDescriptor - Supplies a pointer to a buffer in which will be
        created a self-relative security descriptor as described above.

    Length - The length in bytes of the buffer.  If the length is too
        small, it will contain the minimum size required upon exit.


Return Value:

    STATUS_BUFFER_TOO_SMALL - The buffer was not big enough to contain
        the requested information.


--*/

{

    PCHAR Field;
    PCHAR Base;
    ULONG WorldSidLength;
    PISECURITY_DESCRIPTOR_RELATIVE ISecurityDescriptor;
    ULONG MinSize;
    NTSTATUS Status;

    PAGED_CODE();

    if ( !ARGUMENT_PRESENT( SecurityInformation )) {

        return( STATUS_ACCESS_DENIED );
    }

    WorldSidLength = SeLengthSid( SeWorldSid );

    MinSize = sizeof( SECURITY_DESCRIPTOR_RELATIVE ) + 2 * WorldSidLength;

    if ( *Length < MinSize ) {

        *Length = MinSize;
        return( STATUS_BUFFER_TOO_SMALL );
    }

    *Length = MinSize;

    ISecurityDescriptor = (SECURITY_DESCRIPTOR_RELATIVE *)SecurityDescriptor;

    Status = RtlCreateSecurityDescriptorRelative( ISecurityDescriptor,
                                          SECURITY_DESCRIPTOR_REVISION );

    if (!NT_SUCCESS( Status )) {
        return( Status );
    }

    Base = (PCHAR)(ISecurityDescriptor);
    Field =  Base + sizeof(SECURITY_DESCRIPTOR_RELATIVE);

    if ( *SecurityInformation & OWNER_SECURITY_INFORMATION ) {

        RtlCopyMemory( Field, SeWorldSid, WorldSidLength );
        ISecurityDescriptor->Owner = RtlPointerToOffset(Base,Field);
        Field += WorldSidLength;
    }

    if ( *SecurityInformation & GROUP_SECURITY_INFORMATION ) {

        RtlCopyMemory( Field, SeWorldSid, WorldSidLength );
        ISecurityDescriptor->Group = RtlPointerToOffset(Base,Field);
    }

    if ( *SecurityInformation & DACL_SECURITY_INFORMATION ) {
        RtlpSetControlBits( ISecurityDescriptor, SE_DACL_PRESENT );
    }

    if ( *SecurityInformation & SACL_SECURITY_INFORMATION ) {
        RtlpSetControlBits( ISecurityDescriptor, SE_SACL_PRESENT );
    }

    RtlpSetControlBits( ISecurityDescriptor, SE_SELF_RELATIVE );

    return( STATUS_SUCCESS );

}



#if DBG

VOID
SepDumpSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSZ TitleString
    )

/*++

Routine Description:

    Private routine to dump a security descriptor to the debug
    screen.

Arguments:

    SecurityDescriptor - Supplies the security descriptor to be dumped.

    TitleString - A null terminated string to print before dumping
        the security descriptor.


Return Value:

    None.


--*/
{
    PISECURITY_DESCRIPTOR ISecurityDescriptor;
    UCHAR Revision;
    SECURITY_DESCRIPTOR_CONTROL Control;
    PSID Owner;
    PSID Group;
    PACL Sacl;
    PACL Dacl;

    PAGED_CODE();


    if (!SepDumpSD) {
        return;
    }

    if (!ARGUMENT_PRESENT( SecurityDescriptor )) {
        return;
    }

    DbgPrint(TitleString);

    ISecurityDescriptor = ( PISECURITY_DESCRIPTOR )SecurityDescriptor;

    Revision = ISecurityDescriptor->Revision;
    Control  = ISecurityDescriptor->Control;

    Owner    = RtlpOwnerAddrSecurityDescriptor( ISecurityDescriptor );
    Group    = RtlpGroupAddrSecurityDescriptor( ISecurityDescriptor );
    Sacl     = RtlpSaclAddrSecurityDescriptor( ISecurityDescriptor );
    Dacl     = RtlpDaclAddrSecurityDescriptor( ISecurityDescriptor );

    DbgPrint("\nSECURITY DESCRIPTOR\n");

    DbgPrint("Revision = %d\n",Revision);

    //
    // Print control info
    //

    if (Control & SE_OWNER_DEFAULTED) {
        DbgPrint("Owner defaulted\n");
    }
    if (Control & SE_GROUP_DEFAULTED) {
        DbgPrint("Group defaulted\n");
    }
    if (Control & SE_DACL_PRESENT) {
        DbgPrint("Dacl present\n");
    }
    if (Control & SE_DACL_DEFAULTED) {
        DbgPrint("Dacl defaulted\n");
    }
    if (Control & SE_SACL_PRESENT) {
        DbgPrint("Sacl present\n");
    }
    if (Control & SE_SACL_DEFAULTED) {
        DbgPrint("Sacl defaulted\n");
    }
    if (Control & SE_SELF_RELATIVE) {
        DbgPrint("Self relative\n");
    }
    if (Control & SE_DACL_UNTRUSTED) {
        DbgPrint("Dacl untrusted\n");
    }
    if (Control & SE_SERVER_SECURITY) {
        DbgPrint("Server security\n");
    }

    DbgPrint("Owner ");
    SepPrintSid( Owner );

    DbgPrint("Group ");
    SepPrintSid( Group );

    DbgPrint("Sacl");
    SepPrintAcl( Sacl );

    DbgPrint("Dacl");
    SepPrintAcl( Dacl );
}



VOID
SepPrintAcl (
    IN PACL Acl
    )

/*++

Routine Description:

    This routine dumps via (DbgPrint) an Acl for debug purposes.  It is
    specialized to dump standard aces.

Arguments:

    Acl - Supplies the Acl to dump

Return Value:

    None

--*/


{
    ULONG i;
    PKNOWN_ACE Ace;
    BOOLEAN KnownType;

    PAGED_CODE();

    DbgPrint("@ %8lx\n", Acl);

    //
    //  Check if the Acl is null
    //

    if (Acl == NULL) {

        return;

    }

    //
    //  Dump the Acl header
    //

    DbgPrint(" Revision: %02x", Acl->AclRevision);
    DbgPrint(" Size: %04x", Acl->AclSize);
    DbgPrint(" AceCount: %04x\n", Acl->AceCount);

    //
    //  Now for each Ace we want do dump it
    //

    for (i = 0, Ace = FirstAce(Acl);
         i < Acl->AceCount;
         i++, Ace = NextAce(Ace) ) {

        //
        //  print out the ace header
        //

        DbgPrint("\n AceHeader: %08lx ", *(PULONG)Ace);

        //
        //  special case on the standard ace types
        //

        if ((Ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ||
            (Ace->Header.AceType == ACCESS_DENIED_ACE_TYPE) ||
            (Ace->Header.AceType == SYSTEM_AUDIT_ACE_TYPE) ||
            (Ace->Header.AceType == SYSTEM_ALARM_ACE_TYPE) ||
            (Ace->Header.AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE)) {

            //
            //  The following array is indexed by ace types and must
            //  follow the allowed, denied, audit, alarm sequence
            //

            PCHAR AceTypes[] = { "Access Allowed",
                                 "Access Denied ",
                                 "System Audit  ",
                                 "System Alarm  ",
                                 "Compound Grant",
                               };

            DbgPrint(AceTypes[Ace->Header.AceType]);
            DbgPrint("\n Access Mask: %08lx ", Ace->Mask);
            KnownType = TRUE;

        } else {

            DbgPrint(" Unknown Ace Type\n");
            KnownType = FALSE;
        }

        DbgPrint("\n");

        DbgPrint(" AceSize = %d\n",Ace->Header.AceSize);

        DbgPrint(" Ace Flags = ");
        if (Ace->Header.AceFlags & OBJECT_INHERIT_ACE) {
            DbgPrint("OBJECT_INHERIT_ACE\n");
            DbgPrint("                   ");
        }

        if (Ace->Header.AceFlags & CONTAINER_INHERIT_ACE) {
            DbgPrint("CONTAINER_INHERIT_ACE\n");
            DbgPrint("                   ");
        }

        if (Ace->Header.AceFlags & NO_PROPAGATE_INHERIT_ACE) {
            DbgPrint("NO_PROPAGATE_INHERIT_ACE\n");
            DbgPrint("                   ");
        }

        if (Ace->Header.AceFlags & INHERIT_ONLY_ACE) {
            DbgPrint("INHERIT_ONLY_ACE\n");
            DbgPrint("                   ");
        }


        if (Ace->Header.AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) {
            DbgPrint("SUCCESSFUL_ACCESS_ACE_FLAG\n");
            DbgPrint("            ");
        }

        if (Ace->Header.AceFlags & FAILED_ACCESS_ACE_FLAG) {
            DbgPrint("FAILED_ACCESS_ACE_FLAG\n");
            DbgPrint("            ");
        }

        DbgPrint("\n");

        if (KnownType != TRUE) {
            continue;
        }

        if (Ace->Header.AceType != ACCESS_ALLOWED_COMPOUND_ACE_TYPE) {
            DbgPrint(" Sid = ");
            SepPrintSid(&Ace->SidStart);
        } else {
            DbgPrint(" Server Sid = ");
            SepPrintSid(RtlCompoundAceServerSid(Ace));
            DbgPrint("\n Client Sid = ");
            SepPrintSid(RtlCompoundAceClientSid( Ace ));
        }
    }
}



VOID
SepPrintSid(
    IN PSID Sid
    )

/*++

Routine Description:

    Prints a formatted Sid

Arguments:

    Sid - Provides a pointer to the sid to be printed.


Return Value:

    None.

--*/

{
    UCHAR i;
    ULONG Tmp;
    PISID ISid;
    STRING AccountName;
    UCHAR Buffer[128];

    PAGED_CODE();

    if (Sid == NULL) {
        DbgPrint("Sid is NULL\n");
        return;
    }

    Buffer[0] = 0;

    AccountName.MaximumLength = 127;
    AccountName.Length = 0;
    AccountName.Buffer = (PVOID)&Buffer[0];

    if (SepSidTranslation( Sid, &AccountName )) {

        DbgPrint("%s   ", AccountName.Buffer );
    }

    ISid = (PISID)Sid;

    DbgPrint("S-%lu-", (USHORT)ISid->Revision );
    if (  (ISid->IdentifierAuthority.Value[0] != 0)  ||
          (ISid->IdentifierAuthority.Value[1] != 0)     ){
        DbgPrint("0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)ISid->IdentifierAuthority.Value[0],
                    (USHORT)ISid->IdentifierAuthority.Value[1],
                    (USHORT)ISid->IdentifierAuthority.Value[2],
                    (USHORT)ISid->IdentifierAuthority.Value[3],
                    (USHORT)ISid->IdentifierAuthority.Value[4],
                    (USHORT)ISid->IdentifierAuthority.Value[5] );
    } else {
        Tmp = (ULONG)ISid->IdentifierAuthority.Value[5]          +
              (ULONG)(ISid->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(ISid->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(ISid->IdentifierAuthority.Value[2] << 24);
        DbgPrint("%lu", Tmp);
    }


    for (i=0;i<ISid->SubAuthorityCount ;i++ ) {
        DbgPrint("-%lu", ISid->SubAuthority[i]);
    }
    DbgPrint("\n");
}




VOID
SepDumpTokenInfo(
    IN PACCESS_TOKEN Token
    )

/*++

Routine Description:

    Prints interesting information in a token.

Arguments:

    Token - Provides the token to be examined.


Return Value:

    None.

--*/

{
    ULONG UserAndGroupCount;
    PSID_AND_ATTRIBUTES TokenSid;
    ULONG i;
    PTOKEN IToken;

    PAGED_CODE();

    if (!SepDumpToken) {
        return;
    }

    IToken = (TOKEN *)Token;

    UserAndGroupCount = IToken->UserAndGroupCount;

    DbgPrint("\n\nToken Address=%lx\n",IToken);
    DbgPrint("Token User and Groups Array:\n\n");

    for ( i = 0 , TokenSid = IToken->UserAndGroups;
          i < UserAndGroupCount ;
          i++, TokenSid++
        ) {

        SepPrintSid( TokenSid->Sid );

        }

    if ( IToken->RestrictedSids ) {
        UserAndGroupCount = IToken->RestrictedSidCount;

        DbgPrint("Restricted Sids Array:\n\n");

        for ( i = 0 , TokenSid = IToken->RestrictedSids;
              i < UserAndGroupCount ;
              i++, TokenSid++
            ) {

            SepPrintSid( TokenSid->Sid );

            }
    }
}



BOOLEAN
SepSidTranslation(
    PSID Sid,
    PSTRING AccountName
    )

/*++

Routine Description:

    This routine translates well-known SIDs into English names.

Arguments:

    Sid - Provides the sid to be examined.

    AccountName - Provides a string buffer in which to place the
        translated name.

Return Value:

    None

--*/

// AccountName is expected to have a large maximum length

{
    PAGED_CODE();

    if (RtlEqualSid(Sid, SeWorldSid)) {
        RtlInitString( AccountName, "WORLD         ");
        return(TRUE);
    }

    if (RtlEqualSid(Sid, SeLocalSid)) {
        RtlInitString( AccountName, "LOCAL         ");
        return(TRUE);
    }

    if (RtlEqualSid(Sid, SeNetworkSid)) {
        RtlInitString( AccountName, "NETWORK       ");
        return(TRUE);
    }

    if (RtlEqualSid(Sid, SeBatchSid)) {
        RtlInitString( AccountName, "BATCH         ");
        return(TRUE);
    }

    if (RtlEqualSid(Sid, SeInteractiveSid)) {
        RtlInitString( AccountName, "INTERACTIVE   ");
        return(TRUE);
    }

    if (RtlEqualSid(Sid, SeLocalSystemSid)) {
        RtlInitString( AccountName, "SYSTEM        ");
        return(TRUE);
    }

    if (RtlEqualSid(Sid, SeCreatorOwnerSid)) {
        RtlInitString( AccountName, "CREATOR_OWNER ");
        return(TRUE);
    }

    if (RtlEqualSid(Sid, SeCreatorGroupSid)) {
        RtlInitString( AccountName, "CREATOR_GROUP ");
        return(TRUE);
    }

    if (RtlEqualSid(Sid, SeCreatorOwnerServerSid)) {
        RtlInitString( AccountName, "CREATOR_OWNER_SERVER ");
        return(TRUE);
    }

    if (RtlEqualSid(Sid, SeCreatorGroupServerSid)) {
        RtlInitString( AccountName, "CREATOR_GROUP_SERVER ");
        return(TRUE);
    }

    return(FALSE);
}

//
//  End debug only routines
//
#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\seaudit.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    seaudit.c

Abstract:

    This Module implements the audit and alarm procedures.

--*/

#include "pch.h"

#pragma hdrstop

VOID
SepProbeAndCaptureString_U (
    IN PUNICODE_STRING SourceString,
    OUT PUNICODE_STRING *DestString
    );

VOID
SepFreeCapturedString(
    IN PUNICODE_STRING CapturedString
    );

VOID
SepAuditTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PNTSTATUS AccessStatus,
    IN ULONG StartIndex,
    OUT PBOOLEAN GenerateSuccessAudit,
    OUT PBOOLEAN GenerateFailureAudit
    );

VOID
SepExamineSaclEx(
    IN PACL Sacl,
    IN PACCESS_TOKEN Token,
    IN ACCESS_MASK DesiredAccess,
    IN PIOBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN BOOLEAN ReturnResultList,
    IN PNTSTATUS AccessStatus,
    IN PACCESS_MASK GrantedAccess,
    IN PSID PrincipalSelfSid,
    OUT PBOOLEAN GenerateSuccessAudit,
    OUT PBOOLEAN GenerateFailureAudit
    );

NTSTATUS
SepAccessCheckAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN PHANDLE ClientToken OPTIONAL,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose,
    IN BOOLEAN ReturnResultList
    );

#ifdef ALLOC_PRAGMA
VOID
SepSetAuditInfoForObjectType(
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK AccessMask,
    IN  ACCESS_MASK DesiredAccess,
    IN  PIOBJECT_TYPE_LIST ObjectTypeList,
    IN  ULONG ObjectTypeListLength,
    IN  BOOLEAN ReturnResultList,
    IN  ULONG ObjectTypeIndex,
    IN  PNTSTATUS AccessStatus,
    IN  PACCESS_MASK GrantedAccess,
    OUT PBOOLEAN GenerateSuccessAudit,
    OUT PBOOLEAN GenerateFailureAudit
    );
#pragma alloc_text(PAGE,SepSinglePrivilegeCheck)
#pragma alloc_text(PAGE,SeCheckAuditPrivilege)
#pragma alloc_text(PAGE,SepProbeAndCaptureString_U)
#pragma alloc_text(PAGE,SepFreeCapturedString)
#pragma alloc_text(PAGE,NtPrivilegeObjectAuditAlarm)
#pragma alloc_text(PAGE,SePrivilegeObjectAuditAlarm)
#pragma alloc_text(PAGE,NtPrivilegedServiceAuditAlarm)
#pragma alloc_text(PAGE,SePrivilegedServiceAuditAlarm)
#pragma alloc_text(PAGE,SepAccessCheckAndAuditAlarm)
#pragma alloc_text(PAGE,NtAccessCheckAndAuditAlarm)
#pragma alloc_text(PAGE,NtAccessCheckByTypeAndAuditAlarm)
#pragma alloc_text(PAGE,NtAccessCheckByTypeResultListAndAuditAlarm)
#pragma alloc_text(PAGE,NtAccessCheckByTypeResultListAndAuditAlarmByHandle)
#pragma alloc_text(PAGE,NtOpenObjectAuditAlarm)
#pragma alloc_text(PAGE,NtCloseObjectAuditAlarm)
#pragma alloc_text(PAGE,NtDeleteObjectAuditAlarm)
#pragma alloc_text(PAGE,SeOpenObjectAuditAlarm)
#pragma alloc_text(PAGE,SeOpenObjectForDeleteAuditAlarm)
#pragma alloc_text(PAGE,SeObjectReferenceAuditAlarm)
#pragma alloc_text(PAGE,SeAuditHandleCreation)
#pragma alloc_text(PAGE,SeCloseObjectAuditAlarm)
#pragma alloc_text(PAGE,SeDeleteObjectAuditAlarm)
#pragma alloc_text(PAGE,SepExamineSacl)
#pragma alloc_text(PAGE,SepAuditTypeList)
#pragma alloc_text(PAGE,SepSetAuditInfoForObjectType)
#pragma alloc_text(PAGE,SepExamineSaclEx)
#pragma alloc_text(INIT,SepInitializePrivilegeFilter)
#pragma alloc_text(PAGE,SepFilterPrivilegeAudits)
#pragma alloc_text(PAGE,SeAuditingFileOrGlobalEvents)
#pragma alloc_text(PAGE,SeAuditingFileEvents)
#pragma alloc_text(PAGE,SeAuditingFileEventsWithContext)
#pragma alloc_text(PAGE,SeAuditingHardLinkEvents)
#pragma alloc_text(PAGE,SeAuditingHardLinkEventsWithContext)
#endif


//
//  Private useful routines
//

//
// This routine is to be called to do simple checks of single privileges
// against the passed token.
//
// DO NOT CALL THIS TO CHECK FOR SeTcbPrivilege SINCE THAT MUST
// BE CHECKED AGAINST THE PRIMARY TOKEN ONLY!
//

BOOLEAN
SepSinglePrivilegeCheck (
   LUID DesiredPrivilege,
   IN PACCESS_TOKEN Token,
   IN KPROCESSOR_MODE PreviousMode
   )

/*++

Routine Description:

    Determines if the passed token has the passed privilege.

Arguments:

    DesiredPrivilege - The privilege to be tested for.

    Token - The token being examined.

    PreviousMode - The previous processor mode.

Return Value:

    Returns TRUE of the subject has the passed privilege, FALSE otherwise.

--*/

{

   LUID_AND_ATTRIBUTES Privilege;
   BOOLEAN Result;

   PAGED_CODE();
   
   //
   // Don't let anyone call this to test for SeTcbPrivilege
   //

   ASSERT(!((DesiredPrivilege.LowPart == SeTcbPrivilege.LowPart) &&
            (DesiredPrivilege.HighPart == SeTcbPrivilege.HighPart)));

   Privilege.Luid = DesiredPrivilege;
   Privilege.Attributes = 0;

   Result = SepPrivilegeCheck(
               Token,
               &Privilege,
               1,
               PRIVILEGE_SET_ALL_NECESSARY,
               PreviousMode
               );

   return(Result);
}


BOOLEAN
SeCheckAuditPrivilege (
   __in PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
   __in KPROCESSOR_MODE PreviousMode
   )
/*++

Routine Description:

    This routine specifically searches the primary token (rather than
    the effective token) of the calling process for SeAuditPrivilege.
    In order to do this it must call the underlying worker
    SepPrivilegeCheck directly, to ensure that the correct token is
    searched

Arguments:

    SubjectSecurityContext - The subject being examined.

    PreviousMode - The previous processor mode.

Return Value:

    Returns TRUE if the subject has SeAuditPrivilege, FALSE otherwise.

--*/
{

    PRIVILEGE_SET RequiredPrivileges;
    BOOLEAN AccessGranted;

    PAGED_CODE();

    RequiredPrivileges.PrivilegeCount = 1;
    RequiredPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
    RequiredPrivileges.Privilege[0].Luid = SeAuditPrivilege;
    RequiredPrivileges.Privilege[0].Attributes = 0;

    AccessGranted = SepPrivilegeCheck(
                        SubjectSecurityContext->PrimaryToken,     // token
                        RequiredPrivileges.Privilege,             // privilege set
                        RequiredPrivileges.PrivilegeCount,        // privilege count
                        PRIVILEGE_SET_ALL_NECESSARY,              // privilege control
                        PreviousMode                              // previous mode
                        );

    if ( PreviousMode != KernelMode ) {

        SePrivilegedServiceAuditAlarm (
            NULL,
            SubjectSecurityContext,
            &RequiredPrivileges,
            AccessGranted
            );
    }

    return( AccessGranted );
}


VOID
SepProbeAndCaptureString_U (
    IN PUNICODE_STRING SourceString,
    OUT PUNICODE_STRING *DestString
    )
/*++

Routine Description:

    Helper routine to probe and capture a Unicode string argument.

    This routine may fail due to lack of memory, in which case,
    it will return a NULL pointer in the output parameter.

Arguments:

    SourceString - Pointer to a Unicode string to be captured.

    DestString - Returns a pointer to a captured Unicode string.  This
        will be one contiguous structure, and thus may be freed by
        a single call to ExFreePool().

Return Value:

    None.

--*/
{

    UNICODE_STRING InputString;
    ULONG Length;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Initialize the object name descriptor and capture the specified name
    // string.
    //

    *DestString = NULL;

    Status = STATUS_SUCCESS;
    try {

        //
        // Probe and capture the name string descriptor and probe the
        // name string, if necessary.
        //

        ProbeAndReadUnicodeStringEx(&InputString, SourceString);
        ProbeForRead(InputString.Buffer,
                     InputString.Length,
                     sizeof(WCHAR));



        //
        // If the length of the string is not an even multiple of the
        // size of a UNICODE character or cannot be zero terminated,
        // then return an error.
        //

        Length = InputString.Length;
        if (((Length & (sizeof(WCHAR) - 1)) != 0) ||
            (Length == (MAXUSHORT - sizeof(WCHAR) + 1))) {
            Status = STATUS_INVALID_PARAMETER;

        } else {

            //
            // Allocate a buffer for the specified name string.
            //

            *DestString = ExAllocatePoolWithTag(
                            PagedPool,
                            InputString.Length + sizeof(UNICODE_STRING),
                            'sUeS');

            if (*DestString == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {
                (*DestString)->Length = InputString.Length;
                (*DestString)->MaximumLength = InputString.Length;
                (*DestString)->Buffer = (PWSTR) ((*DestString) + 1);

                if (InputString.Length != 0) {

                    RtlCopyMemory(
                        (*DestString)->Buffer,
                        InputString.Buffer,
                        InputString.Length);
                }

            }
        }

    } except(ExSystemExceptionFilter()) {
        Status = GetExceptionCode();
        if (*DestString != NULL) {
            ExFreePool(*DestString);
            *DestString = NULL;
        }
    }

    return;

}


VOID
SepFreeCapturedString(
    IN PUNICODE_STRING CapturedString
    )

/*++

Routine Description:

    Frees a string captured by SepProbeAndCaptureString.

Arguments:

    CapturedString - Supplies a pointer to a string previously captured
        by SepProbeAndCaptureString.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ExFreePool( CapturedString );
    return;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                  Privileged Object Audit Alarms                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////


NTSTATUS
NtPrivilegeObjectAuditAlarm (
    __in PUNICODE_STRING SubsystemName,
    __in_opt PVOID HandleId,
    __in HANDLE ClientToken,
    __in ACCESS_MASK DesiredAccess,
    __in PPRIVILEGE_SET Privileges,
    __in BOOLEAN AccessGranted
    )
/*++

Routine Description:

    This routine is used to generate audit and alarm messages when an
    attempt is made to perform privileged operations on a protected
    subsystem object after the object is already opened.  This routine may
    result in several messages being generated and sent to Port objects.
    This may result in a significant latency before returning.  Design of
    routines that must call this routine must take this potential latency
    into account.  This may have an impact on the approach taken for data
    structure mutex locking, for example.

    This API requires the caller have SeAuditPrivilege privilege.  The test
    for this privilege is always against the primary token of the calling
    process, allowing the caller to be impersonating a client during the
    call with no ill effects.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.

    ClientToken - A handle to a token object representing the client that
        requested the operation.  This handle must be obtained from a
        communication session layer, such as from an LPC Port or Local
        Named Pipe, to prevent possible security policy violations.

    DesiredAccess - The desired access mask.  This mask must have been
        previously mapped to contain no generic accesses.

    Privileges - The set of privileges required for the requested
        operation.  Those privileges that were held by the subject are
        marked using the UsedForAccess flag of the attributes
        associated with each privilege.

    AccessGranted - Indicates whether the requested access was granted or
        not.  A value of TRUE indicates the access was granted.  A value of
        FALSE indicates the access was not granted.

Return value:

--*/
{

    KPROCESSOR_MODE PreviousMode;
    PUNICODE_STRING CapturedSubsystemName = NULL;
    PPRIVILEGE_SET CapturedPrivileges = NULL;
    ULONG PrivilegeParameterLength;
    ULONG PrivilegeCount;
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    BOOLEAN Result;
    PTOKEN Token;
    NTSTATUS Status;
    BOOLEAN AuditPerformed;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    ASSERT(PreviousMode != KernelMode);

    Status = ObReferenceObjectByHandle(
         ClientToken,             // Handle
         TOKEN_QUERY,             // DesiredAccess
         SeTokenObjectType,      // ObjectType
         PreviousMode,            // AccessMode
         (PVOID *)&Token,         // Object
         NULL                     // GrantedAccess
         );

    if (!NT_SUCCESS( Status )) {
        return( Status );
    }

    //
    // If the passed token is an impersonation token, make sure
    // it is at SecurityIdentification or above.
    //

    if (Token->TokenType == TokenImpersonation) {

        if (Token->ImpersonationLevel < SecurityIdentification) {

            ObDereferenceObject( (PVOID)Token );

            return( STATUS_BAD_IMPERSONATION_LEVEL );

        }
    }

    //
    // Check for SeAuditPrivilege
    //

    SeCaptureSubjectContext ( &SubjectSecurityContext );

    Result = SeCheckAuditPrivilege (
                 &SubjectSecurityContext,
                 PreviousMode
                 );

    if (!Result) {

        ObDereferenceObject( (PVOID)Token );
        SeReleaseSubjectContext ( &SubjectSecurityContext );
        return(STATUS_PRIVILEGE_NOT_HELD);

    }

    try {

        SepProbeAndCaptureString_U ( SubsystemName,
                                     &CapturedSubsystemName );

        ProbeForReadSmallStructure(
            Privileges,
            sizeof(PRIVILEGE_SET),
            sizeof(ULONG)
            );
        PrivilegeCount = Privileges->PrivilegeCount;

        if (!IsValidPrivilegeCount(PrivilegeCount)) {
            Status= STATUS_INVALID_PARAMETER;
            leave ;
        }
        PrivilegeParameterLength = (ULONG)sizeof(PRIVILEGE_SET) +
                          ((PrivilegeCount - ANYSIZE_ARRAY) *
                            (ULONG)sizeof(LUID_AND_ATTRIBUTES)  );

        ProbeForRead(
            Privileges,
            PrivilegeParameterLength,
            sizeof(ULONG)
            );

        CapturedPrivileges = ExAllocatePoolWithTag( PagedPool,
                                                    PrivilegeParameterLength,
                                                    'rPeS'
                                                  );

        if (CapturedPrivileges != NULL) {

            RtlCopyMemory ( CapturedPrivileges,
                            Privileges,
                            PrivilegeParameterLength );
            CapturedPrivileges->PrivilegeCount = PrivilegeCount;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
    }
    if (!NT_SUCCESS(Status)) {

        if (CapturedPrivileges != NULL) {
            ExFreePool( CapturedPrivileges );
        }

        if (CapturedSubsystemName != NULL) {
            SepFreeCapturedString ( CapturedSubsystemName );
        }

        SeReleaseSubjectContext ( &SubjectSecurityContext );

        ObDereferenceObject( (PVOID)Token );

        return Status;

    }

    //
    // No need to lock the token, because the only thing we're going
    // to reference in it is the User's Sid, which cannot be changed.
    //

    //
    // SepPrivilegeObjectAuditAlarm will check the global flags
    // to determine if we're supposed to be auditing here.
    //

    AuditPerformed = SepAdtPrivilegeObjectAuditAlarm (
                         CapturedSubsystemName,
                         HandleId,
                         Token,                                // ClientToken
                         SubjectSecurityContext.PrimaryToken,  // PrimaryToken
                         SubjectSecurityContext.ProcessAuditId,
                         DesiredAccess,
                         CapturedPrivileges,
                         AccessGranted
                         );

    if (CapturedPrivileges != NULL) {
        ExFreePool( CapturedPrivileges );
    }

    if (CapturedSubsystemName != NULL) {
        SepFreeCapturedString ( CapturedSubsystemName );
    }

    SeReleaseSubjectContext ( &SubjectSecurityContext );

    ObDereferenceObject( (PVOID)Token );

    return(STATUS_SUCCESS);
}



VOID
SePrivilegeObjectAuditAlarm(
    __in HANDLE Handle,
    __in PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    __in ACCESS_MASK DesiredAccess,
    __in PPRIVILEGE_SET Privileges,
    __in BOOLEAN AccessGranted,
    __in KPROCESSOR_MODE AccessMode
    )

/*++

Routine Description:

    This routine is used by object methods that perform privileged
    operations to generate audit and alarm messages related to the use
    of privileges, or attempts to use privileges.

Arguments:

    Object - Address of the object accessed.  This value will not be
    used as a pointer (referenced).  It is necessary only to enter
    into log messages.

    Handle - Provides the handle value assigned for the open.

    SecurityDescriptor - A pointer to the security descriptor of the
    object being accessed.

    SubjectSecurityContext - A pointer to the captured security
    context of the subject attempting to open the object.

    DesiredAccess - The desired access mask.  This mask must have been
    previously mapped to contain no generic accesses.

    Privileges - Points to a set of privileges required for the access
    attempt.  Those privileges that were held by the subject are
    marked using the UsedForAccess flag of the PRIVILEGE_ATTRIBUTES
    associated with each privilege.

    AccessGranted - Indicates whether the access was granted or
    denied.  A value of TRUE indicates the access was allowed.  A
    value of FALSE indicates the access was denied.

    AccessMode - Indicates the access mode used for the access check.
    Messages will not be generated by kernel mode accesses.

Return Value:

    None.

--*/

{
    BOOLEAN AuditPerformed;

    PAGED_CODE();

    if (AccessMode != KernelMode) {

        AuditPerformed = SepAdtPrivilegeObjectAuditAlarm (
                             (PUNICODE_STRING)&SeSubsystemName,
                             Handle,
                             SubjectSecurityContext->ClientToken,
                             SubjectSecurityContext->PrimaryToken,
                             SubjectSecurityContext->ProcessAuditId,
                             DesiredAccess,
                             Privileges,
                             AccessGranted
                             );
    }
}


////////////////////////////////////////////////////////////////////////
//                                                                    //
//                  Privileged Service Audit Alarms                   //
//                                                                    //
////////////////////////////////////////////////////////////////////////


NTSTATUS
NtPrivilegedServiceAuditAlarm (
    __in PUNICODE_STRING SubsystemName,
    __in PUNICODE_STRING ServiceName,
    __in HANDLE ClientToken,
    __in PPRIVILEGE_SET Privileges,
    __in BOOLEAN AccessGranted
    )

/*++

Routine Description:

    This routine is used to generate audit and alarm messages when an
    attempt is made to perform privileged system service operations.  This
    routine may result in several messages being generated and sent to Port
    objects.  This may result in a significant latency before returning.
    Design of routines that must call this routine must take this potential
    latency into account.  This may have an impact on the approach taken
    for data structure mutex locking, for example.

    This API requires the caller have SeAuditPrivilege privilege.  The test
    for this privilege is always against the primary token of the calling
    process, allowing the caller to be impersonating a client during the
    call with no ill effects

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    ServiceName - Supplies a name of the privileged subsystem service.  For
        example, "RESET RUNTIME LOCAL SECURITY POLICY" might be specified
        by a Local Security Authority service used to update the local
        security policy database.

    ClientToken - A handle to a token object representing the client that
        requested the operation.  This handle must be obtained from a
        communication session layer, such as from an LPC Port or Local
        Named Pipe, to prevent possible security policy violations.

    Privileges - Points to a set of privileges required to perform the
        privileged operation.  Those privileges that were held by the
        subject are marked using the UsedForAccess flag of the
        attributes associated with each privilege.

    AccessGranted - Indicates whether the requested access was granted or
        not.  A value of TRUE indicates the access was granted.  A value of
        FALSE indicates the access was not granted.

Return value:

--*/

{

    PPRIVILEGE_SET CapturedPrivileges = NULL;
    ULONG PrivilegeParameterLength = 0;
    BOOLEAN Result;
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    KPROCESSOR_MODE PreviousMode;
    PUNICODE_STRING CapturedSubsystemName = NULL;
    PUNICODE_STRING CapturedServiceName = NULL;
    NTSTATUS Status;
    PTOKEN Token;
    ULONG PrivilegeCount;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    ASSERT(PreviousMode != KernelMode);

    Status = ObReferenceObjectByHandle(
                 ClientToken,             // Handle
                 TOKEN_QUERY,             // DesiredAccess
                 SeTokenObjectType,      // ObjectType
                 PreviousMode,            // AccessMode
                 (PVOID *)&Token,         // Object
                 NULL                     // GrantedAccess
                 );

    if ( !NT_SUCCESS( Status )) {
        return( Status );
    }

    //
    // If the passed token is an impersonation token, make sure
    // it is at SecurityIdentification or above.
    //

    if (Token->TokenType == TokenImpersonation) {

        if (Token->ImpersonationLevel < SecurityIdentification) {

            ObDereferenceObject( (PVOID)Token );

            return( STATUS_BAD_IMPERSONATION_LEVEL );

        }
    }

    //
    // Check for SeAuditPrivilege
    //

    SeCaptureSubjectContext ( &SubjectSecurityContext );

    Result = SeCheckAuditPrivilege (
                 &SubjectSecurityContext,
                 PreviousMode
                 );

    if (!Result) {

        ObDereferenceObject( (PVOID)Token );

        SeReleaseSubjectContext ( &SubjectSecurityContext );

        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    try {

        if ( ARGUMENT_PRESENT( SubsystemName )) {
            SepProbeAndCaptureString_U ( SubsystemName,
                                         &CapturedSubsystemName );
        }

        if ( ARGUMENT_PRESENT( ServiceName )) {
            SepProbeAndCaptureString_U ( ServiceName,
                                         &CapturedServiceName );

        }

        ProbeForReadSmallStructure(
            Privileges,
            sizeof(PRIVILEGE_SET),
            sizeof(ULONG)
            );

        PrivilegeCount = Privileges->PrivilegeCount;

        if (!IsValidPrivilegeCount( PrivilegeCount ) ) {
            Status = STATUS_INVALID_PARAMETER;
            leave ;
        }
        PrivilegeParameterLength = (ULONG)sizeof(PRIVILEGE_SET) +
                          ((PrivilegeCount - ANYSIZE_ARRAY) *
                            (ULONG)sizeof(LUID_AND_ATTRIBUTES)  );

        ProbeForRead(
            Privileges,
            PrivilegeParameterLength,
            sizeof(ULONG)
            );

        CapturedPrivileges = ExAllocatePoolWithTag( PagedPool,
                                                    PrivilegeParameterLength,
                                                    'rPeS'
                                                  );

        //
        // If ExAllocatePool has failed, too bad.  Carry on and do as much of the
        // audit as we can.
        //

        if (CapturedPrivileges != NULL) {

            RtlCopyMemory ( CapturedPrivileges,
                            Privileges,
                            PrivilegeParameterLength );
            CapturedPrivileges->PrivilegeCount = PrivilegeCount;

        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS(Status)) {

        if (CapturedSubsystemName != NULL) {
            SepFreeCapturedString ( CapturedSubsystemName );
        }

        if (CapturedServiceName != NULL) {
            SepFreeCapturedString ( CapturedServiceName );
        }

        if (CapturedPrivileges != NULL) {
            ExFreePool ( CapturedPrivileges );
        }

        SeReleaseSubjectContext ( &SubjectSecurityContext );

        ObDereferenceObject( (PVOID)Token );

        return Status;

    }

    //
    // The AuthenticationId is in the read-only part of the token,
    // so we may reference it without having the token read-locked.
    //

    SepAdtPrivilegedServiceAuditAlarm ( &SubjectSecurityContext,
                                        CapturedSubsystemName,
                                        CapturedServiceName,
                                        Token,
                                        SubjectSecurityContext.PrimaryToken,
                                        CapturedPrivileges,
                                        AccessGranted );

    if (CapturedSubsystemName != NULL) {
        SepFreeCapturedString ( CapturedSubsystemName );
    }

    if (CapturedServiceName != NULL) {
        SepFreeCapturedString ( CapturedServiceName );
    }

    if (CapturedPrivileges != NULL) {
        ExFreePool ( CapturedPrivileges );
    }

    ObDereferenceObject( (PVOID)Token );

    SeReleaseSubjectContext ( &SubjectSecurityContext );

    return(STATUS_SUCCESS);
}


VOID
SePrivilegedServiceAuditAlarm (
    __in_opt PUNICODE_STRING ServiceName,
    __in PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    __in PPRIVILEGE_SET Privileges,
    __in BOOLEAN AccessGranted
    )
/*++

Routine Description:

    This routine is to be called whenever a privileged system service
    is attempted.  It should be called immediately after the privilege
    check regardless of whether or not the test succeeds.

Arguments:

    ServiceName - Supplies the name of the privileged system service.

    SubjectSecurityContext - The subject security context representing
        the caller of the system service.

    Privileges - Supplies a privilege set containing the privilege(s)
        required for the access.

    AccessGranted - Supplies the results of the privilege test.

Return Value:

    None.

--*/

{
    PTOKEN Token;

    PAGED_CODE();

#if DBG
    if ( Privileges )
    {
        ASSERT( IsValidPrivilegeCount(Privileges->PrivilegeCount) );
    }
#endif
    
    Token = (PTOKEN)EffectiveToken( SubjectSecurityContext );

    if ( RtlEqualSid( SeLocalSystemSid, SepTokenUserSid( Token ))) {
        return;
    }
                    
    if (RtlEqualSid(SeExports->SeNetworkServiceSid, SepTokenUserSid(Token)) ||
        RtlEqualSid(SeExports->SeLocalServiceSid, SepTokenUserSid(Token))) {
        
        if (!SepFilterPrivilegeAudits(SEP_SERVICES_FILTER, Privileges))
        {
            return;
        }
    }

    SepAdtPrivilegedServiceAuditAlarm (
        SubjectSecurityContext,
        (PUNICODE_STRING)&SeSubsystemName,
        ServiceName,
        SubjectSecurityContext->ClientToken,
        SubjectSecurityContext->PrimaryToken,
        Privileges,
        AccessGranted
        );

    return;
}


NTSTATUS
SepAccessCheckAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN PHANDLE ClientToken OPTIONAL,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose,
    IN BOOLEAN ReturnResultList
    )
/*++

Routine Description:

    This system service is used to perform both an access validation and
    generate the corresponding audit and alarm messages.  This service may
    only be used by a protected server that chooses to impersonate its
    client and thereby specifies the client security context implicitly.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value that will be used to represent the client's
        handle to the object.  This value is ignored (and may be re-used)
        if the access is denied.

    ClientToken - Supplies the client token so that the caller does not have
        to impersonate before making the kernel call.

    ObjectTypeName - Supplies the name of the type of the object being
        created or accessed.

    ObjectName - Supplies the name of the object being created or accessed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        access is to be checked.

    DesiredAccess - The desired access mask.  This mask must have been
        previously mapped to contain no generic accesses.

    AuditType - Specifies the type of audit to be generated.  Valid value
        is: AuditEventObjectAccess

    Flags - Flags modifying the execution of the API:

        AUDIT_ALLOW_NO_PRIVILEGE - If the called does not have AuditPrivilege,
            the call will silently continue to check access and will
            generate no audit.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

    ObjectCreation - A boolean flag indicated whether the access will
        result in a new object being created if granted.  A value of TRUE
        indicates an object will be created, FALSE indicates an existing
        object will be opened.

    GrantedAccess - Receives a masking indicating which accesses have been
        granted.

    AccessStatus - Receives an indication of the success or failure of the
        access check.  If access is granted, STATUS_SUCCESS is returned.
        If access is denied, a value appropriate for return to the client
        is returned.  This will be STATUS_ACCESS_DENIED or, when mandatory
        access controls are implemented, STATUS_OBJECT_NOT_FOUND.

    GenerateOnClose - Points to a boolean that is set by the audity
        generation routine and must be passed to NtCloseObjectAuditAlarm
        when the object handle is closed.

    ReturnResultList - If true, GrantedAccess and AccessStatus are actually
        arrays of entries ObjectTypeListLength elements long.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.  In this
        case, ClientStatus receives the result of the access check.

    STATUS_PRIVILEGE_NOT_HELD - Indicates the caller does not have
        sufficient privilege to use this privileged system service.

--*/

{

    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;

    NTSTATUS Status = STATUS_SUCCESS;

    ACCESS_MASK LocalGrantedAccess = (ACCESS_MASK)0;
    PACCESS_MASK LocalGrantedAccessPointer = NULL;
    BOOLEAN LocalGrantedAccessAllocated = FALSE;
    NTSTATUS LocalAccessStatus = STATUS_UNSUCCESSFUL;
    PNTSTATUS LocalAccessStatusPointer = NULL;
    BOOLEAN LocalGenerateOnClose = FALSE;
    POLICY_AUDIT_EVENT_TYPE NtAuditType;

    KPROCESSOR_MODE PreviousMode;

    PUNICODE_STRING CapturedSubsystemName = (PUNICODE_STRING) NULL;
    PUNICODE_STRING CapturedObjectTypeName = (PUNICODE_STRING) NULL;
    PUNICODE_STRING CapturedObjectName = (PUNICODE_STRING) NULL;
    PSECURITY_DESCRIPTOR CapturedSecurityDescriptor = (PSECURITY_DESCRIPTOR) NULL;
    PSID CapturedPrincipalSelfSid = NULL;
    PIOBJECT_TYPE_LIST LocalObjectTypeList = NULL;

    ACCESS_MASK PreviouslyGrantedAccess = (ACCESS_MASK)0;
    GENERIC_MAPPING LocalGenericMapping;

    PPRIVILEGE_SET PrivilegeSet = NULL;

    BOOLEAN Result;

    BOOLEAN AccessGranted;
    BOOLEAN AccessDenied;
    BOOLEAN GenerateSuccessAudit = FALSE;
    BOOLEAN GenerateFailureAudit = FALSE;
    LUID OperationId;
    BOOLEAN AuditPerformed;
    BOOLEAN AvoidAudit = FALSE;

    PTOKEN NewToken = NULL;
    PTOKEN OldToken = NULL;
    BOOLEAN TokenSwapped = FALSE;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    ASSERT( PreviousMode != KernelMode );

    //
    // Capture the subject Context
    //

    SeCaptureSubjectContext ( &SubjectSecurityContext );

    //
    // Convert AuditType
    //

    if ( AuditType == AuditEventObjectAccess ) {
        NtAuditType = AuditCategoryObjectAccess;
    } else if ( AuditType == AuditEventDirectoryServiceAccess ) {
        NtAuditType = AuditCategoryDirectoryServiceAccess;
    } else {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Impersonation checks should be done only if the ClientToken is NULL.
    //

    if ( !ARGUMENT_PRESENT( ClientToken ) ) {

        //
        // Make sure we're impersonating a client...
        //

        if ( (SubjectSecurityContext.ClientToken == NULL) ) {
            Status = STATUS_NO_IMPERSONATION_TOKEN;
            goto Cleanup;
        }


        //
        // ...and at a high enough impersonation level
        //

        if (SubjectSecurityContext.ImpersonationLevel < SecurityIdentification) {
            Status = STATUS_BAD_IMPERSONATION_LEVEL;
            goto Cleanup;
        }
    }

    try {

        if ( ReturnResultList ) {

            if ( ObjectTypeListLength == 0 ) {
                Status = STATUS_INVALID_PARAMETER;
                leave;
            }

            if (!IsValidObjectTypeListCount( ObjectTypeListLength )) {

                Status = STATUS_INVALID_PARAMETER;
                leave;
            }
    
            ProbeForWrite(
                AccessStatus,
                sizeof(NTSTATUS) * ObjectTypeListLength,
                sizeof(ULONG)
                );

            ProbeForWrite(
                GrantedAccess,
                sizeof(ACCESS_MASK) * ObjectTypeListLength,
                sizeof(ULONG)
                );

        } else {
            ProbeForWriteUlong((PULONG)AccessStatus);
            ProbeForWriteUlong((PULONG)GrantedAccess);
        }

        ProbeForReadSmallStructure(
            GenericMapping,
            sizeof(GENERIC_MAPPING),
            sizeof(ULONG)
            );

        LocalGenericMapping = *GenericMapping;

    } except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    if ( ARGUMENT_PRESENT( ClientToken ) ) {

        Status = ObReferenceObjectByHandle(
                     *ClientToken,                 // Handle
                     (ACCESS_MASK)TOKEN_QUERY,     // DesiredAccess
                     SeTokenObjectType,           // ObjectType
                     PreviousMode,                 // AccessMode
                     (PVOID *)&NewToken,           // Object
                     NULL                          // GrantedAccess
                     );

        if (!NT_SUCCESS(Status)) {
            NewToken = NULL;
            goto Cleanup;
        }

        //
        // Save the old token so that it can be recovered before
        // SeReleaseSubjectContext.
        //

        OldToken = SubjectSecurityContext.ClientToken;

        //
        // Set the impersonation token to the one that has been obtained thru
        // ClientToken handle. This must be freed later in Cleanup.
        //

        SubjectSecurityContext.ClientToken = NewToken;

        TokenSwapped = TRUE;
    }

    //
    // Check for SeAuditPrivilege
    //

    Result = SeCheckAuditPrivilege (
                 &SubjectSecurityContext,
                 PreviousMode
                 );

    if (!Result) {
        if ( Flags & AUDIT_ALLOW_NO_PRIVILEGE ) {
            AvoidAudit = TRUE;
        } else {
            Status = STATUS_PRIVILEGE_NOT_HELD;
            goto Cleanup;
        }
    }

    if (DesiredAccess &
        ( GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL )) {

        Status = STATUS_GENERIC_NOT_MAPPED;
        goto Cleanup;
    }

    //
    // Capture the passed security descriptor.
    //
    // SeCaptureSecurityDescriptor probes the input security descriptor,
    // so we don't have to
    //

    Status = SeCaptureSecurityDescriptor (
                SecurityDescriptor,
                PreviousMode,
                PagedPool,
                FALSE,
                &CapturedSecurityDescriptor
                );

    if (!NT_SUCCESS(Status) ) {
        CapturedSecurityDescriptor = NULL;
        goto Cleanup;
    }

    if ( CapturedSecurityDescriptor == NULL ) {
        Status = STATUS_INVALID_SECURITY_DESCR;
        goto Cleanup;
    }

    //
    // A valid security descriptor must have an owner and a group
    //

    if ( RtlpOwnerAddrSecurityDescriptor(
                (PISECURITY_DESCRIPTOR)CapturedSecurityDescriptor
                ) == NULL ||
         RtlpGroupAddrSecurityDescriptor(
                (PISECURITY_DESCRIPTOR)CapturedSecurityDescriptor
                ) == NULL ) {

        Status = STATUS_INVALID_SECURITY_DESCR;
        goto Cleanup;
    }

    //
    //  Probe and capture the STRING arguments
    //

    try {

        ProbeForWriteBoolean(GenerateOnClose);

        SepProbeAndCaptureString_U ( SubsystemName, &CapturedSubsystemName );

        SepProbeAndCaptureString_U ( ObjectTypeName, &CapturedObjectTypeName );

        SepProbeAndCaptureString_U ( ObjectName, &CapturedObjectName );

    } except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
        goto Cleanup;

    }

    //
    // Capture the PrincipalSelfSid.
    //

    if ( PrincipalSelfSid != NULL ) {
        Status = SeCaptureSid(
                     PrincipalSelfSid,
                     PreviousMode,
                     NULL, 0,
                     PagedPool,
                     TRUE,
                     &CapturedPrincipalSelfSid );

        if (!NT_SUCCESS(Status)) {
            CapturedPrincipalSelfSid = NULL;
            goto Cleanup;
        }
    }

    //
    // Capture any Object type list
    //

    Status = SeCaptureObjectTypeList( ObjectTypeList,
                                      ObjectTypeListLength,
                                      PreviousMode,
                                      &LocalObjectTypeList );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // See if anything (or everything) in the desired access can be
    // satisfied by privileges.
    //

    Status = SePrivilegePolicyCheck(
                 &DesiredAccess,
                 &PreviouslyGrantedAccess,
                 &SubjectSecurityContext,
                 NULL,
                 &PrivilegeSet,
                 PreviousMode
                 );

    SeLockSubjectContext( &SubjectSecurityContext );

    if (!NT_SUCCESS( Status )) {
        AccessGranted = FALSE;
        AccessDenied = TRUE;
        LocalAccessStatus = Status;

        if ( ReturnResultList ) {
            ULONG ResultListIndex;
            LocalGrantedAccessPointer =
                ExAllocatePoolWithTag( PagedPool, (sizeof(ACCESS_MASK)+sizeof(NTSTATUS)) * ObjectTypeListLength, 'aGeS' );

            if (LocalGrantedAccessPointer == NULL) {
                SeUnlockSubjectContext( &SubjectSecurityContext );
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            LocalGrantedAccessAllocated = TRUE;
            LocalAccessStatusPointer = (PNTSTATUS)(LocalGrantedAccessPointer + ObjectTypeListLength);

            for ( ResultListIndex=0; ResultListIndex<ObjectTypeListLength; ResultListIndex++ ) {
                LocalGrantedAccessPointer[ResultListIndex] = LocalGrantedAccess;
                LocalAccessStatusPointer[ResultListIndex] = LocalAccessStatus;
            }

        } else {
        LocalGrantedAccessPointer = &LocalGrantedAccess;
        LocalAccessStatusPointer =  &LocalAccessStatus;
        }

    } else {

        //
        // If the user in the token is the owner of the object, we
        // must automatically grant ReadControl and WriteDac access
        // if desired.  If the DesiredAccess mask is empty after
        // these bits are turned off, we don't have to do any more
        // access checking (ref section 4, DSA ACL Arch)
        //

        if ( DesiredAccess & (WRITE_DAC | READ_CONTROL | MAXIMUM_ALLOWED) ) {

            if (SepTokenIsOwner( SubjectSecurityContext.ClientToken, CapturedSecurityDescriptor, TRUE )) {

                if ( DesiredAccess & MAXIMUM_ALLOWED ) {

                    PreviouslyGrantedAccess |= ( WRITE_DAC | READ_CONTROL );

                } else {

                    PreviouslyGrantedAccess |= (DesiredAccess & (WRITE_DAC | READ_CONTROL));
                }

                DesiredAccess &= ~(WRITE_DAC | READ_CONTROL);
            }

        }

        if (DesiredAccess == 0) {

            LocalGrantedAccess = PreviouslyGrantedAccess;
            if (PreviouslyGrantedAccess == 0){
                AccessGranted = FALSE;
                AccessDenied = TRUE;
                LocalAccessStatus = STATUS_ACCESS_DENIED;
            } else {
                AccessGranted = TRUE;
                AccessDenied = FALSE;
                LocalAccessStatus = STATUS_SUCCESS;
            }

            if ( ReturnResultList ) {
                ULONG ResultListIndex;
                LocalGrantedAccessPointer =
                    ExAllocatePoolWithTag( PagedPool, (sizeof(ACCESS_MASK)+sizeof(NTSTATUS)) * ObjectTypeListLength, 'aGeS' );

                if (LocalGrantedAccessPointer == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    SeUnlockSubjectContext( &SubjectSecurityContext );
                    goto Cleanup;
                }
                LocalGrantedAccessAllocated = TRUE;
                LocalAccessStatusPointer = (PNTSTATUS)(LocalGrantedAccessPointer + ObjectTypeListLength);

                for ( ResultListIndex=0; ResultListIndex<ObjectTypeListLength; ResultListIndex++ ) {
                    LocalGrantedAccessPointer[ResultListIndex] = LocalGrantedAccess;
                    LocalAccessStatusPointer[ResultListIndex] = LocalAccessStatus;
                }

            } else {
            LocalGrantedAccessPointer = &LocalGrantedAccess;
            LocalAccessStatusPointer =  &LocalAccessStatus;
            }

        } else {

            //
            // Finally, do the access check
            //

            if ( ReturnResultList ) {
                LocalGrantedAccessPointer =
                    ExAllocatePoolWithTag( PagedPool, (sizeof(ACCESS_MASK)+sizeof(NTSTATUS)) * ObjectTypeListLength, 'aGeS' );

                if (LocalGrantedAccessPointer == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    SeUnlockSubjectContext( &SubjectSecurityContext );
                    goto Cleanup;
                }
                LocalGrantedAccessAllocated = TRUE;
                LocalAccessStatusPointer = (PNTSTATUS)(LocalGrantedAccessPointer + ObjectTypeListLength);

            } else {
                LocalGrantedAccessPointer = &LocalGrantedAccess;
                LocalAccessStatusPointer =  &LocalAccessStatus;
            }


            //
            // This does not ask for privilege set to be returned so we can ignore
            // the return value of the call.
            //

            (VOID) SepAccessCheck (
                        CapturedSecurityDescriptor,
                        CapturedPrincipalSelfSid,
                        SubjectSecurityContext.PrimaryToken,
                        SubjectSecurityContext.ClientToken,
                        DesiredAccess,
                        LocalObjectTypeList,
                        ObjectTypeListLength,
                        &LocalGenericMapping,
                        PreviouslyGrantedAccess,
                        PreviousMode,
                        LocalGrantedAccessPointer,
                        NULL,       // Privileges already checked
                        LocalAccessStatusPointer,
                        ReturnResultList,
                        &AccessGranted,
                        &AccessDenied
                        );

        }
    }

    //
    // sound the alarms...
    //

    if ( !AvoidAudit ) {
        if ( SepAdtAuditThisEventWithContext( NtAuditType, AccessGranted, AccessDenied, &SubjectSecurityContext )) {

            SepExamineSaclEx(
                RtlpSaclAddrSecurityDescriptor( (PISECURITY_DESCRIPTOR)CapturedSecurityDescriptor ),
                EffectiveToken( &SubjectSecurityContext ),
                DesiredAccess | PreviouslyGrantedAccess,
                LocalObjectTypeList,
                ObjectTypeListLength,
                ReturnResultList,
                LocalAccessStatusPointer,
                LocalGrantedAccessPointer,
                CapturedPrincipalSelfSid,
                &GenerateSuccessAudit,
                &GenerateFailureAudit
                );
        }

        if ( GenerateSuccessAudit ||
             GenerateFailureAudit ) {

            //
            // Save this to a local here, so we don't
            // have to risk accessing user memory and
            // potentially having to exit before the audit
            //

            if ( AccessGranted ) {

                //
                // SAM calls NtCloseObjectAuditAlarm despite the fact that it may not
                // have successfully opened the object, causing a spurious close audit.
                // Since no one should rely on this anyway if their access attempt
                // failed, make sure it's false and SAM will work properly.
                //

                LocalGenerateOnClose = TRUE;
            }

            //
            // Generate the success audit if needed.
            //
            if ( GenerateSuccessAudit ) {
                ExAllocateLocallyUniqueId( &OperationId );

                // ??
                ASSERT( AccessGranted );
                AuditPerformed = SepAdtOpenObjectAuditAlarm (
                                     CapturedSubsystemName,
                                     AccessGranted ? &HandleId : NULL, // Don't audit handle if failure
                                     CapturedObjectTypeName,
                                     CapturedObjectName,
                                     SubjectSecurityContext.ClientToken,
                                     SubjectSecurityContext.PrimaryToken,
                                     *LocalGrantedAccessPointer,
                                     *LocalGrantedAccessPointer,
                                     &OperationId,
                                     PrivilegeSet,
                                     TRUE,  // Generate success case
                                     PsProcessAuditId( PsGetCurrentProcess() ),
                                     NtAuditType,
                                     LocalObjectTypeList,
                                     ObjectTypeListLength,
                                     ReturnResultList ? LocalGrantedAccessPointer : NULL
                                     );

            }

            //
            // Generate failure audit if it is needed.
            //
            if ( GenerateFailureAudit ) {
                ExAllocateLocallyUniqueId( &OperationId );

                // ??
                ASSERT( AccessDenied );
                AuditPerformed = SepAdtOpenObjectAuditAlarm (
                                     CapturedSubsystemName,
                                     AccessGranted ? &HandleId : NULL, // Don't audit handle if failure
                                     CapturedObjectTypeName,
                                     CapturedObjectName,
                                     SubjectSecurityContext.ClientToken,
                                     SubjectSecurityContext.PrimaryToken,
                                     DesiredAccess,
                                     DesiredAccess,
                                     &OperationId,
                                     PrivilegeSet,
                                     FALSE, // Generate failure case
                                     PsProcessAuditId( PsGetCurrentProcess() ),
                                     NtAuditType,
                                     LocalObjectTypeList,
                                     ObjectTypeListLength,
                                     ReturnResultList ? LocalGrantedAccessPointer : NULL
                                     );
            }
        } else {

            //
            // We didn't generate an audit due to the SACL.  If privileges were used, we need
            // to audit that.  Only audit successful privilege use for opens.
            //

            if ( PrivilegeSet != NULL ) {

                if ( SepAdtAuditThisEventWithContext( AuditCategoryPrivilegeUse, AccessGranted, FALSE, &SubjectSecurityContext) ) {

                    AuditPerformed = SepAdtPrivilegeObjectAuditAlarm ( CapturedSubsystemName,
                                                                       &HandleId,
                                                                       SubjectSecurityContext.ClientToken,
                                                                       SubjectSecurityContext.PrimaryToken,
                                                                       PsProcessAuditId( PsGetCurrentProcess() ),
                                                                       DesiredAccess,
                                                                       PrivilegeSet,
                                                                       AccessGranted
                                                                       );

                    //
                    // We don't want close audits to be generated.  May need to revisit this.
                    //

                    LocalGenerateOnClose = FALSE;
                }
            }
        }
    }

    SeUnlockSubjectContext( &SubjectSecurityContext );

    try {
            if ( ReturnResultList ) {
                ULONG ResultListIndex;
                if ( LocalAccessStatusPointer == NULL ) {
                    for ( ResultListIndex=0; ResultListIndex<ObjectTypeListLength; ResultListIndex++ ) {
                        AccessStatus[ResultListIndex] = LocalAccessStatus;
                        GrantedAccess[ResultListIndex] = LocalGrantedAccess;
                    }
                } else {
                    for ( ResultListIndex=0; ResultListIndex<ObjectTypeListLength; ResultListIndex++ ) {
                        AccessStatus[ResultListIndex] = LocalAccessStatusPointer[ResultListIndex];
                        GrantedAccess[ResultListIndex] = LocalGrantedAccessPointer[ResultListIndex];
                    }
                }

            } else {
                *AccessStatus = LocalAccessStatus;
                *GrantedAccess = LocalGrantedAccess;
            }
            *GenerateOnClose    = LocalGenerateOnClose;
            Status = STATUS_SUCCESS;

    } except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
    }

    //
    // Free locally used resources.
    //
Cleanup:

    if ( TokenSwapped ) {

        //
        // Decrement the reference count for the ClientToken that was passed in.
        //

        ObDereferenceObject( (PVOID)NewToken );

        //
        // Reset the value of the token from saved value.
        //

        SubjectSecurityContext.ClientToken = OldToken;
    }

    //
    // Free any privileges allocated as part of the access check
    //

    if (PrivilegeSet != NULL) {
        ExFreePool( PrivilegeSet );
    }

    SeReleaseSubjectContext ( &SubjectSecurityContext );

    SeReleaseSecurityDescriptor ( CapturedSecurityDescriptor,
                                  PreviousMode,
                                  FALSE );

    if (CapturedSubsystemName != NULL) {
      SepFreeCapturedString( CapturedSubsystemName );
    }

    if (CapturedObjectTypeName != NULL) {
      SepFreeCapturedString( CapturedObjectTypeName );
    }

    if (CapturedObjectName != NULL) {
      SepFreeCapturedString( CapturedObjectName );
    }

    if (CapturedPrincipalSelfSid != NULL) {
        SeReleaseSid( CapturedPrincipalSelfSid, PreviousMode, TRUE);
    }

    if ( LocalObjectTypeList != NULL ) {
        SeFreeCapturedObjectTypeList( LocalObjectTypeList );
    }

    if ( LocalGrantedAccessAllocated ) {
        if ( LocalGrantedAccessPointer != NULL ) {
            ExFreePool( LocalGrantedAccessPointer );
        }
    }

    return Status;
}


NTSTATUS
NtAccessCheckAndAuditAlarm (
    __in PUNICODE_STRING SubsystemName,
    __in_opt PVOID HandleId,
    __in PUNICODE_STRING ObjectTypeName,
    __in PUNICODE_STRING ObjectName,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in ACCESS_MASK DesiredAccess,
    __in PGENERIC_MAPPING GenericMapping,
    __in BOOLEAN ObjectCreation,
    __out PACCESS_MASK GrantedAccess,
    __out PNTSTATUS AccessStatus,
    __out PBOOLEAN GenerateOnClose
    )
/*++

Routine Description:

    See SepAccessCheckAndAuditAlarm.

Arguments:

    See SepAccessCheckAndAuditAlarm.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.  In this
        case, ClientStatus receives the result of the access check.

    STATUS_PRIVILEGE_NOT_HELD - Indicates the caller does not have
        sufficient privilege to use this privileged system service.

--*/

{
    PAGED_CODE();

    UNREFERENCED_PARAMETER( ObjectCreation );
    
    return SepAccessCheckAndAuditAlarm(
            SubsystemName,
            HandleId,
            NULL,
            ObjectTypeName,
            ObjectName,
            SecurityDescriptor,
            NULL,       // No Principal Self sid
            DesiredAccess,
            AuditEventObjectAccess,  // Default to ObjectAccess
            0,          // No Flags
            NULL,       // No ObjectType List
            0,          // No ObjectType List
            GenericMapping,
            GrantedAccess,
            AccessStatus,
            GenerateOnClose,
            FALSE );    // Return a single GrantedAccess and AccessStatus

}


NTSTATUS
NtAccessCheckByTypeAndAuditAlarm (
    __in PUNICODE_STRING SubsystemName,
    __in_opt PVOID HandleId,
    __in PUNICODE_STRING ObjectTypeName,
    __in PUNICODE_STRING ObjectName,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSID PrincipalSelfSid,
    __in ACCESS_MASK DesiredAccess,
    __in AUDIT_EVENT_TYPE AuditType,
    __in ULONG Flags,
    __in_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in ULONG ObjectTypeListLength,
    __in PGENERIC_MAPPING GenericMapping,
    __in BOOLEAN ObjectCreation,
    __out PACCESS_MASK GrantedAccess,
    __out PNTSTATUS AccessStatus,
    __out PBOOLEAN GenerateOnClose
    )
/*++

Routine Description:

    See SepAccessCheckAndAuditAlarm.

Arguments:

    See SepAccessCheckAndAuditAlarm.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.  In this
        case, ClientStatus receives the result of the access check.

    STATUS_PRIVILEGE_NOT_HELD - Indicates the caller does not have
        sufficient privilege to use this privileged system service.

--*/

{
    PAGED_CODE();

    UNREFERENCED_PARAMETER( ObjectCreation );
    
    return SepAccessCheckAndAuditAlarm(
            SubsystemName,
            HandleId,
            NULL,
            ObjectTypeName,
            ObjectName,
            SecurityDescriptor,
            PrincipalSelfSid,
            DesiredAccess,
            AuditType,
            Flags,
            ObjectTypeList,
            ObjectTypeListLength,
            GenericMapping,
            GrantedAccess,
            AccessStatus,
            GenerateOnClose,
            FALSE );  // Return a single GrantedAccess and AccessStatus

}


NTSTATUS
NtAccessCheckByTypeResultListAndAuditAlarm (
    __in PUNICODE_STRING SubsystemName,
    __in_opt PVOID HandleId,
    __in PUNICODE_STRING ObjectTypeName,
    __in PUNICODE_STRING ObjectName,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSID PrincipalSelfSid,
    __in ACCESS_MASK DesiredAccess,
    __in AUDIT_EVENT_TYPE AuditType,
    __in ULONG Flags,
    __in_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in ULONG ObjectTypeListLength,
    __in PGENERIC_MAPPING GenericMapping,
    __in BOOLEAN ObjectCreation,
    __out_ecount(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    __out_ecount(ObjectTypeListLength) PNTSTATUS AccessStatus,
    __out PBOOLEAN GenerateOnClose
    )
/*++

Routine Description:

    See SepAccessCheckAndAuditAlarm.

Arguments:

    See SepAccessCheckAndAuditAlarm.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.  In this
        case, ClientStatus receives the result of the access check.

    STATUS_PRIVILEGE_NOT_HELD - Indicates the caller does not have
        sufficient privilege to use this privileged system service.

--*/

{
    PAGED_CODE();

    UNREFERENCED_PARAMETER( ObjectCreation );
    
    return SepAccessCheckAndAuditAlarm(
            SubsystemName,
            HandleId,
            NULL,
            ObjectTypeName,
            ObjectName,
            SecurityDescriptor,
            PrincipalSelfSid,
            DesiredAccess,
            AuditType,
            Flags,
            ObjectTypeList,
            ObjectTypeListLength,
            GenericMapping,
            GrantedAccess,
            AccessStatus,
            GenerateOnClose,
            TRUE );  // Return an array of GrantedAccess and AccessStatus

}


NTSTATUS
NtAccessCheckByTypeResultListAndAuditAlarmByHandle (
    __in PUNICODE_STRING SubsystemName,
    __in_opt PVOID HandleId,
    __in HANDLE ClientToken,
    __in PUNICODE_STRING ObjectTypeName,
    __in PUNICODE_STRING ObjectName,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSID PrincipalSelfSid,
    __in ACCESS_MASK DesiredAccess,
    __in AUDIT_EVENT_TYPE AuditType,
    __in ULONG Flags,
    __in_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in ULONG ObjectTypeListLength,
    __in PGENERIC_MAPPING GenericMapping,
    __in BOOLEAN ObjectCreation,
    __out_ecount(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    __out_ecount(ObjectTypeListLength) PNTSTATUS AccessStatus,
    __out PBOOLEAN GenerateOnClose
    )
/*++

Routine Description:

    See SepAccessCheckAndAuditAlarm.

Arguments:

    See SepAccessCheckAndAuditAlarm.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.  In this
        case, ClientStatus receives the result of the access check.

    STATUS_PRIVILEGE_NOT_HELD - Indicates the caller does not have
        sufficient privilege to use this privileged system service.

--*/

{
    PAGED_CODE();

    UNREFERENCED_PARAMETER( ObjectCreation );
    
    return SepAccessCheckAndAuditAlarm(
            SubsystemName,
            HandleId,
            &ClientToken,
            ObjectTypeName,
            ObjectName,
            SecurityDescriptor,
            PrincipalSelfSid,
            DesiredAccess,
            AuditType,
            Flags,
            ObjectTypeList,
            ObjectTypeListLength,
            GenericMapping,
            GrantedAccess,
            AccessStatus,
            GenerateOnClose,
            TRUE );  // Return an array of GrantedAccess and AccessStatus

}


NTSTATUS
NtOpenObjectAuditAlarm (
    __in PUNICODE_STRING SubsystemName,
    __in_opt PVOID HandleId,
    __in PUNICODE_STRING ObjectTypeName,
    __in PUNICODE_STRING ObjectName,
    __in_opt PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in HANDLE ClientToken,
    __in ACCESS_MASK DesiredAccess,
    __in ACCESS_MASK GrantedAccess,
    __in_opt PPRIVILEGE_SET Privileges,
    __in BOOLEAN ObjectCreation,
    __in BOOLEAN AccessGranted,
    __out PBOOLEAN GenerateOnClose
    )
/*++

    Routine Description:

    This routine is used to generate audit and alarm messages when an
    attempt is made to access an existing protected subsystem object or
    create a new one.  This routine may result in several messages being
    generated and sent to Port objects.  This may result in a significant
    latency before returning.  Design of routines that must call this
    routine must take this potential latency into account.  This may have
    an impact on the approach taken for data structure mutex locking, for
    example.

    This routine may not be able to generate a complete audit record
    due to memory restrictions.

    This API requires the caller have SeAuditPrivilege privilege.  The test
    for this privilege is always against the primary token of the calling
    process, not the impersonation token of the thread.

Arguments:

    SubsystemName - Supplies a name string identifying the
        subsystem calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.  If the access attempt was not successful (AccessGranted is
        FALSE), then this parameter is ignored.

    ObjectTypeName - Supplies the name of the type of object being
        accessed.

    ObjectName - Supplies the name of the object the client
        accessed or attempted to access.

    SecurityDescriptor - An optional pointer to the security descriptor of
        the object being accessed.

    ClientToken - A handle to a token object representing the client that
        requested the operation.  This handle must be obtained from a
        communication session layer, such as from an LPC Port or Local
        Named Pipe, to prevent possible security policy violations.

    DesiredAccess - The desired access mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GrantedAccess - The mask of accesses that were actually granted.

    Privileges - Optionally points to a set of privileges that were
        required for the access attempt.  Those privileges that were held
        by the subject are marked using the UsedForAccess flag of the
        attributes associated with each privilege.

    ObjectCreation - A boolean flag indicating whether the access will
        result in a new object being created if granted.  A value of TRUE
        indicates an object will be created, FALSE indicates an existing
        object will be opened.

    AccessGranted - Indicates whether the requested access was granted or
        not.  A value of TRUE indicates the access was granted.  A value of
        FALSE indicates the access was not granted.

    GenerateOnClose - Points to a boolean that is set by the audit
        generation routine and must be passed to NtCloseObjectAuditAlarm()
        when the object handle is closed.

Return Value:

--*/
{

    KPROCESSOR_MODE PreviousMode;
    ULONG PrivilegeParameterLength;
    PUNICODE_STRING CapturedSubsystemName = (PUNICODE_STRING) NULL;
    PUNICODE_STRING CapturedObjectTypeName = (PUNICODE_STRING) NULL;
    PUNICODE_STRING CapturedObjectName = (PUNICODE_STRING) NULL;
    PSECURITY_DESCRIPTOR CapturedSecurityDescriptor = (PSECURITY_DESCRIPTOR) NULL;
    PPRIVILEGE_SET CapturedPrivileges = NULL;
    BOOLEAN LocalGenerateOnClose = FALSE;
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    BOOLEAN Result;
    NTSTATUS Status;
    BOOLEAN GenerateAudit = FALSE;
    BOOLEAN GenerateAlarm = FALSE;
    PLUID ClientAuthenticationId = NULL;
    HANDLE CapturedHandleId = NULL;
    BOOLEAN AuditPerformed;
    ULONG PrivilegeCount;

    PTOKEN Token;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( ObjectCreation );
    
    PreviousMode = KeGetPreviousMode();

    ASSERT( PreviousMode != KernelMode );

    Status = ObReferenceObjectByHandle( ClientToken,             // Handle
                                        TOKEN_QUERY,             // DesiredAccess
                                        SeTokenObjectType,      // ObjectType
                                        PreviousMode,            // AccessMode
                                        (PVOID *)&Token,         // Object
                                        NULL                     // GrantedAccess
                                        );

    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    //
    // If the passed token is an impersonation token, make sure
    // it is at SecurityIdentification or above.
    //

    if (Token->TokenType == TokenImpersonation) {

        if (Token->ImpersonationLevel < SecurityIdentification) {

            ObDereferenceObject( (PVOID)Token );

            return( STATUS_BAD_IMPERSONATION_LEVEL );

        }
    }

    //
    // Check for SeAuditPrivilege.  This must be tested against
    // the caller's primary token.
    //

    SeCaptureSubjectContext ( &SubjectSecurityContext );

    Result = SeCheckAuditPrivilege (
                 &SubjectSecurityContext,
                 PreviousMode
                 );

    if (!Result) {

        ObDereferenceObject( (PVOID)Token );

        SeReleaseSubjectContext ( &SubjectSecurityContext );

        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    //
    // This will just return NULL if the input descriptor is NULL
    //

    Status = SeCaptureSecurityDescriptor ( SecurityDescriptor,
                                           PreviousMode,
                                           PagedPool,
                                           FALSE,
                                           &CapturedSecurityDescriptor
                                           );

    //
    // At this point in time, if there's no security descriptor, there's
    // nothing to do.  Return success.
    //

    if (!NT_SUCCESS( Status ) || CapturedSecurityDescriptor == NULL) {

        ObDereferenceObject( (PVOID)Token );

        SeReleaseSubjectContext ( &SubjectSecurityContext );

        return( Status );
    }

    try {

        //
        // Only capture the privileges if we've completed a successful
        // access check.  Otherwise they don't mean anything.
        //

        if (AccessGranted && ARGUMENT_PRESENT(Privileges)) {

            ProbeForReadSmallStructure(
                Privileges,
                sizeof(PRIVILEGE_SET),
                sizeof(ULONG)
                );

            PrivilegeCount = Privileges->PrivilegeCount;

            if (!IsValidPrivilegeCount( PrivilegeCount )) {
                Status = STATUS_INVALID_PARAMETER;
                leave;
            }

            PrivilegeParameterLength = (ULONG)sizeof(PRIVILEGE_SET) +
                              ((PrivilegeCount - ANYSIZE_ARRAY) *
                                (ULONG)sizeof(LUID_AND_ATTRIBUTES)  );

            ProbeForRead(
                Privileges,
                PrivilegeParameterLength,
                sizeof(ULONG)
                );

            CapturedPrivileges = ExAllocatePoolWithTag( PagedPool,
                                                        PrivilegeParameterLength,
                                                        'rPeS'
                                                      );

            if (CapturedPrivileges != NULL) {

                RtlCopyMemory ( CapturedPrivileges,
                                Privileges,
                                PrivilegeParameterLength );
                CapturedPrivileges->PrivilegeCount = PrivilegeCount;
            } else {

                SeReleaseSecurityDescriptor ( CapturedSecurityDescriptor,
                                              PreviousMode,
                                              FALSE );

                ObDereferenceObject( (PVOID)Token );
                SeReleaseSubjectContext ( &SubjectSecurityContext );
                return( STATUS_INSUFFICIENT_RESOURCES );
            }


        }

        if (ARGUMENT_PRESENT( HandleId )) {

            ProbeForReadSmallStructure( (PHANDLE)HandleId, sizeof(PVOID), sizeof(PVOID) );
            CapturedHandleId = *(PHANDLE)HandleId;
        }

        ProbeForWriteBoolean(GenerateOnClose);

        //
        // Probe and Capture the parameter strings.
        // If we run out of memory attempting to capture
        // the strings, the returned pointer will be
        // NULL and we will continue with the audit.
        //

        SepProbeAndCaptureString_U ( SubsystemName,
                                     &CapturedSubsystemName );

        SepProbeAndCaptureString_U ( ObjectTypeName,
                                     &CapturedObjectTypeName );

        SepProbeAndCaptureString_U ( ObjectName,
                                     &CapturedObjectName );

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS(Status)) {

        if (CapturedSubsystemName != NULL) {
          SepFreeCapturedString( CapturedSubsystemName );
        }

        if (CapturedObjectTypeName != NULL) {
          SepFreeCapturedString( CapturedObjectTypeName );
        }

        if (CapturedObjectName != NULL) {
          SepFreeCapturedString( CapturedObjectName );
        }

        if (CapturedPrivileges != NULL) {
          ExFreePool( CapturedPrivileges );
        }

        if (CapturedSecurityDescriptor != NULL) {

            SeReleaseSecurityDescriptor ( CapturedSecurityDescriptor,
                                          PreviousMode,
                                          FALSE );
        }

        ObDereferenceObject( (PVOID)Token );

        SeReleaseSubjectContext ( &SubjectSecurityContext );

        return Status;

    }

    if ( SepAdtAuditThisEventWithContext( AuditCategoryObjectAccess, AccessGranted, !AccessGranted, &SubjectSecurityContext ) ) {

        SepExamineSacl(
            RtlpSaclAddrSecurityDescriptor( (PISECURITY_DESCRIPTOR)CapturedSecurityDescriptor ),
            Token,
            DesiredAccess | GrantedAccess,
            AccessGranted,
            &GenerateAudit,
            &GenerateAlarm
            );

        if (GenerateAudit || GenerateAlarm) {

            LocalGenerateOnClose = TRUE;

            AuditPerformed = SepAdtOpenObjectAuditAlarm ( CapturedSubsystemName,
                                                          ARGUMENT_PRESENT(HandleId) ? (PVOID)&CapturedHandleId : NULL,
                                                          CapturedObjectTypeName,
                                                          CapturedObjectName,
                                                          Token,
                                                          SubjectSecurityContext.PrimaryToken,
                                                          DesiredAccess,
                                                          GrantedAccess,
                                                          NULL,
                                                          CapturedPrivileges,
                                                          AccessGranted,
                                                          PsProcessAuditId( PsGetCurrentProcess() ),
                                                          AuditCategoryObjectAccess,
                                                          NULL,
                                                          0,
                                                          NULL
                                                          );

            LocalGenerateOnClose = AuditPerformed;
        }
    }

    if ( !(GenerateAudit || GenerateAlarm) ) {

        //
        // We didn't attempt to generate an audit above, so if privileges were used,
        // see if we should generate an audit here.
        //

        if ( ARGUMENT_PRESENT(Privileges) ) {

            if ( SepAdtAuditThisEventWithContext( AuditCategoryPrivilegeUse, AccessGranted, FALSE, &SubjectSecurityContext ) ) {

                AuditPerformed = SepAdtPrivilegeObjectAuditAlarm ( CapturedSubsystemName,
                                                                   CapturedHandleId,
                                                                   Token,
                                                                   SubjectSecurityContext.PrimaryToken,
                                                                   PsProcessAuditId( PsGetCurrentProcess() ),
                                                                   DesiredAccess,
                                                                   CapturedPrivileges,
                                                                   AccessGranted
                                                                   );
                //
                // If we generate an audit due to use of privilege, don't set generate on close,
                // because then we'll have a close audit without a corresponding open audit.
                //

                LocalGenerateOnClose = FALSE;
            }
        }
    }

    if (CapturedSecurityDescriptor != NULL) {

        SeReleaseSecurityDescriptor ( CapturedSecurityDescriptor,
                                      PreviousMode,
                                      FALSE );
    }

    if (CapturedSubsystemName != NULL) {
      SepFreeCapturedString( CapturedSubsystemName );
    }

    if (CapturedObjectTypeName != NULL) {
      SepFreeCapturedString( CapturedObjectTypeName );
    }

    if (CapturedObjectName != NULL) {
      SepFreeCapturedString( CapturedObjectName );
    }

    if (CapturedPrivileges != NULL) {
      ExFreePool( CapturedPrivileges );
    }

    ObDereferenceObject( (PVOID)Token );

    SeReleaseSubjectContext ( &SubjectSecurityContext );

    try {

        *GenerateOnClose = LocalGenerateOnClose;

    } except (EXCEPTION_EXECUTE_HANDLER) {

            return GetExceptionCode();
    }

    return(STATUS_SUCCESS);
}



NTSTATUS
NtCloseObjectAuditAlarm (
    __in PUNICODE_STRING SubsystemName,
    __in_opt PVOID HandleId,
    __in BOOLEAN GenerateOnClose
    )

/*++

Routine Description:

    This routine is used to generate audit and alarm messages when a handle
    to a protected subsystem object is deleted.  This routine may result in
    several messages being generated and sent to Port objects.  This may
    result in a significant latency before returning.  Design of routines
    that must call this routine must take this potential latency into
    account.  This may have an impact on the approach taken for data
    structure mutex locking, for example.

    This API requires the caller have SeAuditPrivilege privilege.  The test
    for this privilege is always against the primary token of the calling
    process, allowing the caller to be impersonating a client during the
    call with no ill effects.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.

    GenerateOnClose - Is a boolean value returned from a corresponding
        NtAccessCheckAndAuditAlarm() call or NtOpenObjectAuditAlarm() call
        when the object handle was created.

Return value:

--*/

{
    BOOLEAN Result;
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    KPROCESSOR_MODE PreviousMode;
    PUNICODE_STRING CapturedSubsystemName = NULL;
    PSID UserSid;
    PSID CapturedUserSid = NULL;
    NTSTATUS Status;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    ASSERT(PreviousMode != KernelMode);

    if (!GenerateOnClose) {
        return( STATUS_SUCCESS );
    }

    //
    // Check for SeAuditPrivilege
    //

    SeCaptureSubjectContext ( &SubjectSecurityContext );

    Result = SeCheckAuditPrivilege (
                 &SubjectSecurityContext,
                 PreviousMode
                 );

    if (!Result) {
        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;
    }

    UserSid = SepTokenUserSid( EffectiveToken (&SubjectSecurityContext));

    CapturedUserSid = ExAllocatePoolWithTag(
                          PagedPool,
                          SeLengthSid( UserSid ),
                          'iSeS'
                          );

    if ( CapturedUserSid == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status =  RtlCopySid (
                  SeLengthSid( UserSid ),
                  CapturedUserSid,
                  UserSid
                  );

    ASSERT( NT_SUCCESS( Status ));


    try {

        SepProbeAndCaptureString_U ( SubsystemName,
                                   &CapturedSubsystemName );

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        goto Cleanup;
    }

    //
    // This routine will check to see if auditing is enabled
    //

    SepAdtCloseObjectAuditAlarm( CapturedSubsystemName, HandleId, CapturedUserSid );

    Status = STATUS_SUCCESS;

Cleanup:
    if ( CapturedSubsystemName != NULL ) {
        SepFreeCapturedString( CapturedSubsystemName );
    }

    if ( CapturedUserSid != NULL ) {
        ExFreePool( CapturedUserSid );
    }

    SeReleaseSubjectContext ( &SubjectSecurityContext );

    return Status;
}


NTSTATUS
NtDeleteObjectAuditAlarm (
    __in PUNICODE_STRING SubsystemName,
    __in_opt PVOID HandleId,
    __in BOOLEAN GenerateOnClose
    )

/*++

Routine Description:

    This routine is used to generate audit and alarm messages when an object
    in a protected subsystem object is deleted.  This routine may result in
    several messages being generated and sent to Port objects.  This may
    result in a significant latency before returning.  Design of routines
    that must call this routine must take this potential latency into
    account.  This may have an impact on the approach taken for data
    structure mutex locking, for example.

    This API requires the caller have SeAuditPrivilege privilege.  The test
    for this privilege is always against the primary token of the calling
    process, allowing the caller to be impersonating a client during the
    call with no ill effects.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.

    GenerateOnClose - Is a boolean value returned from a corresponding
        NtAccessCheckAndAuditAlarm() call or NtOpenObjectAuditAlarm() call
        when the object handle was created.

Return value:

--*/

{
    BOOLEAN Result;
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    KPROCESSOR_MODE PreviousMode;
    PUNICODE_STRING CapturedSubsystemName = NULL;
    PSID UserSid;
    PSID CapturedUserSid;
    NTSTATUS Status;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    ASSERT(PreviousMode != KernelMode);

    if (!GenerateOnClose) {
        return( STATUS_SUCCESS );
    }

    //
    // Check for SeAuditPrivilege
    //

    SeCaptureSubjectContext ( &SubjectSecurityContext );

    Result = SeCheckAuditPrivilege (
                 &SubjectSecurityContext,
                 PreviousMode
                 );

    if (!Result) {

        SeReleaseSubjectContext ( &SubjectSecurityContext );
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    UserSid = SepTokenUserSid( EffectiveToken (&SubjectSecurityContext));

    CapturedUserSid = ExAllocatePoolWithTag(
                          PagedPool,
                          SeLengthSid( UserSid ),
                          'iSeS'
                          );

    if ( CapturedUserSid == NULL ) {
        SeReleaseSubjectContext ( &SubjectSecurityContext );
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    Status =  RtlCopySid (
                  SeLengthSid( UserSid ),
                  CapturedUserSid,
                  UserSid
                  );

    ASSERT( NT_SUCCESS( Status ));


    try {

        SepProbeAndCaptureString_U ( SubsystemName,
                                   &CapturedSubsystemName );

    } except (EXCEPTION_EXECUTE_HANDLER) {

        if ( CapturedSubsystemName != NULL ) {
            SepFreeCapturedString( CapturedSubsystemName );
        }

        ExFreePool( CapturedUserSid );
        SeReleaseSubjectContext ( &SubjectSecurityContext );
        return GetExceptionCode();

    }

    //
    // This routine will check to see if auditing is enabled
    //

    SepAdtDeleteObjectAuditAlarm ( CapturedSubsystemName,
                               HandleId,
                               CapturedUserSid
                               );

    SeReleaseSubjectContext ( &SubjectSecurityContext );

    if ( CapturedSubsystemName != NULL ) {
        SepFreeCapturedString( CapturedSubsystemName );
    }

    ExFreePool( CapturedUserSid );

    return(STATUS_SUCCESS);
}


VOID
SeOpenObjectAuditAlarm (
    __in PUNICODE_STRING ObjectTypeName,
    __in_opt PVOID Object,
    __in_opt PUNICODE_STRING AbsoluteObjectName,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in PACCESS_STATE AccessState,
    __in BOOLEAN ObjectCreated,
    __in BOOLEAN AccessGranted,
    __in KPROCESSOR_MODE AccessMode,
    __out PBOOLEAN GenerateOnClose
    )
/*++

Routine Description:

    SeOpenObjectAuditAlarm is used by the object manager that open objects
    to generate any necessary audit or alarm messages.  The open may be to
    existing objects or for newly created objects.  No messages will be
    generated for Kernel mode accesses.

    This routine is used to generate audit and alarm messages when an
    attempt is made to open an object.

    This routine may result in several messages being generated and sent to
    Port objects.  This may result in a significant latency before
    returning.  Design of routines that must call this routine must take
    this potential latency into account.  This may have an impact on the
    approach taken for data structure mutex locking, for example.

Arguments:

    ObjectTypeName - Supplies the name of the type of object being
        accessed.  This must be the same name provided to the
        ObCreateObjectType service when the object type was created.

    Object - Address of the object accessed.  This value will not be used
        as a pointer (referenced).  It is necessary only to enter into log
        messages.  If the open was not successful, then this argument is
        ignored.  Otherwise, it must be provided.

    AbsoluteObjectName - Supplies the name of the object being accessed.
        If the object doesn't have a name, then this field is left null.
        Otherwise, it must be provided.

    SecurityDescriptor - A pointer to the security descriptor of the
        object being accessed.

    AccessState - A pointer to an access state structure containing the
        subject context, the remaining desired access types, the granted
        access types, and optionally a privilege set to indicate which
        privileges were used to permit the access.

    ObjectCreated - A boolean flag indicating whether the access resulted
        in a new object being created.  A value of TRUE indicates an object
        was created, FALSE indicates an existing object was opened.

    AccessGranted - Indicates if the access was granted or denied based on
        the access check or privilege check.

    AccessMode - Indicates the access mode used for the access check.  One
        of UserMode or KernelMode.  Messages will not be generated by
        kernel mode accesses.

    GenerateOnClose - Points to a boolean that is set by the audit
        generation routine and must be passed to SeCloseObjectAuditAlarm()
        when the object handle is closed.

Return value:

    None.

--*/
{
    BOOLEAN GenerateAudit = FALSE;
    BOOLEAN GenerateAlarm = FALSE;
    ACCESS_MASK RequestedAccess;
    POBJECT_NAME_INFORMATION ObjectNameInfo = NULL;
    PUNICODE_STRING ObjectTypeNameInfo = NULL;
    PUNICODE_STRING ObjectName = NULL;
    PUNICODE_STRING LocalObjectTypeName = NULL;
    PLUID PrimaryAuthenticationId = NULL;
    PLUID ClientAuthenticationId = NULL;
    BOOLEAN AuditPrivileges = FALSE;
    BOOLEAN AuditPerformed;
    PTOKEN Token;
    ACCESS_MASK MappedGrantMask = (ACCESS_MASK)0;
    ACCESS_MASK MappedDenyMask = (ACCESS_MASK)0;
    PAUX_ACCESS_DATA AuxData;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( ObjectCreated );
    
    if ( AccessMode == KernelMode ) {
        return;
    }

    AuxData = (PAUX_ACCESS_DATA)AccessState->AuxData;

    Token = EffectiveToken( &AccessState->SubjectSecurityContext );

    if (ARGUMENT_PRESENT(Token->AuditData)) {

        MappedGrantMask = Token->AuditData->GrantMask;

        RtlMapGenericMask(
            &MappedGrantMask,
            &AuxData->GenericMapping
            );

        MappedDenyMask = Token->AuditData->DenyMask;

        RtlMapGenericMask(
            &MappedDenyMask,
            &AuxData->GenericMapping
            );
    }

    if (SecurityDescriptor != NULL) {

        RequestedAccess = AccessState->RemainingDesiredAccess |
                          AccessState->PreviouslyGrantedAccess;

        if ( SepAdtAuditThisEventWithContext( AuditCategoryObjectAccess, AccessGranted, !AccessGranted, &AccessState->SubjectSecurityContext )) {

            if ( RequestedAccess & (AccessGranted ? MappedGrantMask : MappedDenyMask)) {

                GenerateAudit = TRUE;

            } else {

                SepExamineSacl(
                    RtlpSaclAddrSecurityDescriptor( (PISECURITY_DESCRIPTOR)SecurityDescriptor ),
                    Token,
                    RequestedAccess,
                    AccessGranted,
                    &GenerateAudit,
                    &GenerateAlarm
                    );
            }

            //
            // Only generate an audit on close of we're auditing from SACL
            // settings.
            //

            if (GenerateAudit) {

                *GenerateOnClose = TRUE;

                //
                // Construct the audit mask that will be placed into the handle.
                //

                if (AccessGranted) {

                    SeMaximumAuditMask(
                        RtlpSaclAddrSecurityDescriptor( (PISECURITY_DESCRIPTOR)SecurityDescriptor ),
                        RequestedAccess,
                        Token,
                        &AuxData->MaximumAuditMask
                        );
                }
            }
        }
    }

    //
    // If we don't generate an audit via the SACL, see if we need to generate
    // one for privilege use.
    //
    // Note that we only audit privileges successfully used to open objects,
    // so we don't care about a failed privilege use here.  Therefore, only
    // do this test of access has been granted.
    //

    if (!GenerateAudit && AccessGranted) {

        if ( SepAdtAuditThisEventWithContext( AuditCategoryPrivilegeUse, AccessGranted, FALSE, &AccessState->SubjectSecurityContext )) {

            if ((AuxData->PrivilegesUsed != NULL) &&
                (AuxData->PrivilegesUsed->PrivilegeCount > 0) ) {

                //
                // Make sure these are actually privileges that we want to audit
                //

                if (SepFilterPrivilegeAudits( 0, AuxData->PrivilegesUsed )) {

                    GenerateAudit = TRUE;

                    //
                    // When we finally try to generate this audit, this flag
                    // will tell us that we need to audit the fact that we
                    // used a privilege, as opposed to audit due to the SACL.
                    //

                    AccessState->AuditPrivileges = TRUE;
                }
            }
        }
    }

    //
    // Set up either to generate an audit (if the access check has failed), or save
    // the stuff that we're going to audit later into the AccessState structure.
    //

    if (GenerateAudit || GenerateAlarm) {

        AccessState->GenerateAudit = TRUE;

        //
        // Figure out what we've been passed, and obtain as much
        // missing information as possible.
        //

        if ( !ARGUMENT_PRESENT( AbsoluteObjectName )) {

            if ( ARGUMENT_PRESENT( Object )) {

                ObjectNameInfo = SepQueryNameString( Object  );

                if ( ObjectNameInfo != NULL ) {

                    ObjectName = &ObjectNameInfo->Name;
                }
            }

        } else {

            ObjectName = AbsoluteObjectName;
        }

        if ( !ARGUMENT_PRESENT( ObjectTypeName )) {

            if ( ARGUMENT_PRESENT( Object )) {

                ObjectTypeNameInfo = SepQueryTypeString( Object );

                if ( ObjectTypeNameInfo != NULL ) {

                    LocalObjectTypeName = ObjectTypeNameInfo;
                }
            }

        } else {

            LocalObjectTypeName = ObjectTypeName;
        }

        //
        // If the access attempt failed, do the audit here.  If it succeeded,
        // we'll do the audit later, when the handle is allocated.
        //
        //

        if (!AccessGranted) {

            AuditPerformed = SepAdtOpenObjectAuditAlarm ( (PUNICODE_STRING)&SeSubsystemName,
                                                          NULL,
                                                          LocalObjectTypeName,
                                                          ObjectName,
                                                          AccessState->SubjectSecurityContext.ClientToken,
                                                          AccessState->SubjectSecurityContext.PrimaryToken,
                                                          AccessState->OriginalDesiredAccess,
                                                          AccessState->PreviouslyGrantedAccess,
                                                          &AccessState->OperationID,
                                                          AuxData->PrivilegesUsed,
                                                          FALSE,
                                                          AccessState->SubjectSecurityContext.ProcessAuditId,
                                                          AuditCategoryObjectAccess,
                                                          NULL,
                                                          0,
                                                          NULL );
        } else {

            //
            // Copy all the stuff we're going to need into the
            // AccessState and return.
            //

            if ( ObjectName != NULL ) {

                 if ( AccessState->ObjectName.Buffer != NULL ) {

                     ExFreePool( AccessState->ObjectName.Buffer );
                     AccessState->ObjectName.Length = 0;
                     AccessState->ObjectName.MaximumLength = 0;
                 }

                AccessState->ObjectName.Buffer = ExAllocatePool( PagedPool,ObjectName->MaximumLength );
                if (AccessState->ObjectName.Buffer != NULL) {

                    AccessState->ObjectName.MaximumLength = ObjectName->MaximumLength;
                    RtlCopyUnicodeString( &AccessState->ObjectName, ObjectName );
                }
            }

            if ( LocalObjectTypeName != NULL ) {

                 if ( AccessState->ObjectTypeName.Buffer != NULL ) {

                     ExFreePool( AccessState->ObjectTypeName.Buffer );
                     AccessState->ObjectTypeName.Length = 0;
                     AccessState->ObjectTypeName.MaximumLength = 0;
                 }

                AccessState->ObjectTypeName.Buffer = ExAllocatePool( PagedPool, LocalObjectTypeName->MaximumLength );
                if (AccessState->ObjectTypeName.Buffer != NULL) {

                    AccessState->ObjectTypeName.MaximumLength = LocalObjectTypeName->MaximumLength;
                    RtlCopyUnicodeString( &AccessState->ObjectTypeName, LocalObjectTypeName );
                }
            }
        }

        if ( ObjectNameInfo != NULL ) {

            ExFreePool( ObjectNameInfo );
        }

        if ( ObjectTypeNameInfo != NULL ) {

            ExFreePool( ObjectTypeNameInfo );
        }
    }

    return;
}


VOID
SeOpenObjectForDeleteAuditAlarm (
    __in PUNICODE_STRING ObjectTypeName,
    __in_opt PVOID Object,
    __in_opt PUNICODE_STRING AbsoluteObjectName,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in PACCESS_STATE AccessState,
    __in BOOLEAN ObjectCreated,
    __in BOOLEAN AccessGranted,
    __in KPROCESSOR_MODE AccessMode,
    __out PBOOLEAN GenerateOnClose
    )
/*++

Routine Description:

    SeOpenObjectForDeleteAuditAlarm is used by the object manager that open
    objects to generate any necessary audit or alarm messages.  The open may
    be to existing objects or for newly created objects.  No messages will be
    generated for Kernel mode accesses.

    This routine is used to generate audit and alarm messages when an
    attempt is made to open an object with the intent to delete it.
    Specifically, this is used by file systems when the flag
    FILE_DELETE_ON_CLOSE is specified.

    This routine may result in several messages being generated and sent to
    Port objects.  This may result in a significant latency before
    returning.  Design of routines that must call this routine must take
    this potential latency into account.  This may have an impact on the
    approach taken for data structure mutex locking, for example.

Arguments:

    ObjectTypeName - Supplies the name of the type of object being
        accessed.  This must be the same name provided to the
        ObCreateObjectType service when the object type was created.

    Object - Address of the object accessed.  This value will not be used
        as a pointer (referenced).  It is necessary only to enter into log
        messages.  If the open was not successful, then this argument is
        ignored.  Otherwise, it must be provided.

    AbsoluteObjectName - Supplies the name of the object being accessed.
        If the object doesn't have a name, then this field is left null.
        Otherwise, it must be provided.

    SecurityDescriptor - A pointer to the security descriptor of the
        object being accessed.

    AccessState - A pointer to an access state structure containing the
        subject context, the remaining desired access types, the granted
        access types, and optionally a privilege set to indicate which
        privileges were used to permit the access.

    ObjectCreated - A boolean flag indicating whether the access resulted
        in a new object being created.  A value of TRUE indicates an object
        was created, FALSE indicates an existing object was opened.

    AccessGranted - Indicates if the access was granted or denied based on
        the access check or privilege check.

    AccessMode - Indicates the access mode used for the access check.  One
        of UserMode or KernelMode.  Messages will not be generated by
        kernel mode accesses.

    GenerateOnClose - Points to a boolean that is set by the audit
        generation routine and must be passed to SeCloseObjectAuditAlarm()
        when the object handle is closed.

Return value:

    None.

--*/
{
    BOOLEAN GenerateAudit = FALSE;
    BOOLEAN GenerateAlarm = FALSE;
    ACCESS_MASK RequestedAccess;
    POBJECT_NAME_INFORMATION ObjectNameInfo = NULL;
    PUNICODE_STRING ObjectTypeNameInfo = NULL;
    PUNICODE_STRING ObjectName = NULL;
    PUNICODE_STRING LocalObjectTypeName = NULL;
    PLUID PrimaryAuthenticationId = NULL;
    PLUID ClientAuthenticationId = NULL;
    BOOLEAN AuditPrivileges = FALSE;
    BOOLEAN AuditPerformed;
    PTOKEN Token;
    ACCESS_MASK MappedGrantMask = (ACCESS_MASK)0;
    ACCESS_MASK MappedDenyMask = (ACCESS_MASK)0;
    PAUX_ACCESS_DATA AuxData;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( ObjectCreated );
    
    if ( AccessMode == KernelMode ) {
        return;
    }

    AuxData = (PAUX_ACCESS_DATA)AccessState->AuxData;

    Token = EffectiveToken( &AccessState->SubjectSecurityContext );

    if (ARGUMENT_PRESENT(Token->AuditData)) {

        MappedGrantMask = Token->AuditData->GrantMask;

        RtlMapGenericMask(
            &MappedGrantMask,
            &AuxData->GenericMapping
            );

        MappedDenyMask = Token->AuditData->DenyMask;

        RtlMapGenericMask(
            &MappedDenyMask,
            &AuxData->GenericMapping
            );
    }

    if (SecurityDescriptor != NULL) {

        RequestedAccess = AccessState->RemainingDesiredAccess |
                          AccessState->PreviouslyGrantedAccess;

        if ( SepAdtAuditThisEventWithContext( AuditCategoryObjectAccess, AccessGranted, !AccessGranted, &AccessState->SubjectSecurityContext )) {

            if ( RequestedAccess & (AccessGranted ? MappedGrantMask : MappedDenyMask)) {

                GenerateAudit = TRUE;

            } else {

                SepExamineSacl(
                    RtlpSaclAddrSecurityDescriptor( (PISECURITY_DESCRIPTOR)SecurityDescriptor ),
                    Token,
                    RequestedAccess,
                    AccessGranted,
                    &GenerateAudit,
                    &GenerateAlarm
                    );
            }

            //
            // Only generate an audit on close of we're auditing from SACL
            // settings.
            //

            if (GenerateAudit) {
                *GenerateOnClose = TRUE;
            }
        }
    }

    //
    // If we don't generate an audit via the SACL, see if we need to generate
    // one for privilege use.
    //
    // Note that we only audit privileges successfully used to open objects,
    // so we don't care about a failed privilege use here.  Therefore, only
    // do this test of access has been granted.
    //

    if (!GenerateAudit && (AccessGranted == TRUE)) {

        if ( SepAdtAuditThisEventWithContext( AuditCategoryPrivilegeUse, AccessGranted, FALSE, &AccessState->SubjectSecurityContext )) {

            if ((AuxData->PrivilegesUsed != NULL) &&
                (AuxData->PrivilegesUsed->PrivilegeCount > 0) ) {

                //
                // Make sure these are actually privileges that we want to audit
                //

                if (SepFilterPrivilegeAudits( 0, AuxData->PrivilegesUsed )) {

                    GenerateAudit = TRUE;

                    //
                    // When we finally try to generate this audit, this flag
                    // will tell us that we need to audit the fact that we
                    // used a privilege, as opposed to audit due to the SACL.
                    //

                    AccessState->AuditPrivileges = TRUE;
                }
            }
        }
    }

    //
    // Set up either to generate an audit (if the access check has failed), or save
    // the stuff that we're going to audit later into the AccessState structure.
    //

    if (GenerateAudit || GenerateAlarm) {

        AccessState->GenerateAudit = TRUE;

        //
        // Figure out what we've been passed, and obtain as much
        // missing information as possible.
        //

        if ( !ARGUMENT_PRESENT( AbsoluteObjectName )) {

            if ( ARGUMENT_PRESENT( Object )) {

                ObjectNameInfo = SepQueryNameString( Object  );

                if ( ObjectNameInfo != NULL ) {

                    ObjectName = &ObjectNameInfo->Name;
                }
            }

        } else {

            ObjectName = AbsoluteObjectName;
        }

        if ( !ARGUMENT_PRESENT( ObjectTypeName )) {

            if ( ARGUMENT_PRESENT( Object )) {

                ObjectTypeNameInfo = SepQueryTypeString( Object );

                if ( ObjectTypeNameInfo != NULL ) {

                    LocalObjectTypeName = ObjectTypeNameInfo;
                }
            }

        } else {

            LocalObjectTypeName = ObjectTypeName;
        }

        //
        // If the access attempt failed, do the audit here.  If it succeeded,
        // we'll do the audit later, when the handle is allocated.
        //
        //

        if (!AccessGranted) {

            AuditPerformed = SepAdtOpenObjectAuditAlarm ( (PUNICODE_STRING)&SeSubsystemName,
                                                          NULL,
                                                          LocalObjectTypeName,
                                                          ObjectName,
                                                          AccessState->SubjectSecurityContext.ClientToken,
                                                          AccessState->SubjectSecurityContext.PrimaryToken,
                                                          AccessState->OriginalDesiredAccess,
                                                          AccessState->PreviouslyGrantedAccess,
                                                          &AccessState->OperationID,
                                                          AuxData->PrivilegesUsed,
                                                          FALSE,
                                                          AccessState->SubjectSecurityContext.ProcessAuditId,
                                                          AuditCategoryObjectAccess,
                                                          NULL,
                                                          0,
                                                          NULL );
        } else {

            //
            // Generate the delete audit first
            //

            SepAdtOpenObjectForDeleteAuditAlarm ( (PUNICODE_STRING)&SeSubsystemName,
                                                  NULL,
                                                  LocalObjectTypeName,
                                                  ObjectName,
                                                  AccessState->SubjectSecurityContext.ClientToken,
                                                  AccessState->SubjectSecurityContext.PrimaryToken,
                                                  AccessState->OriginalDesiredAccess,
                                                  AccessState->PreviouslyGrantedAccess,
                                                  &AccessState->OperationID,
                                                  AuxData->PrivilegesUsed,
                                                  TRUE,
                                                  AccessState->SubjectSecurityContext.ProcessAuditId );

            //
            // Copy all the stuff we're going to need into the
            // AccessState and return.
            //

            if ( ObjectName != NULL ) {

                 if ( AccessState->ObjectName.Buffer != NULL ) {

                     ExFreePool( AccessState->ObjectName.Buffer );
                     AccessState->ObjectName.Length = 0;
                     AccessState->ObjectName.MaximumLength = 0;
                 }

                AccessState->ObjectName.Buffer = ExAllocatePool( PagedPool,ObjectName->MaximumLength );
                if (AccessState->ObjectName.Buffer != NULL) {

                    AccessState->ObjectName.MaximumLength = ObjectName->MaximumLength;
                    RtlCopyUnicodeString( &AccessState->ObjectName, ObjectName );
                }
            }

            if ( LocalObjectTypeName != NULL ) {

                 if ( AccessState->ObjectTypeName.Buffer != NULL ) {

                     ExFreePool( AccessState->ObjectTypeName.Buffer );
                     AccessState->ObjectTypeName.Length = 0;
                     AccessState->ObjectTypeName.MaximumLength = 0;
                 }

                AccessState->ObjectTypeName.Buffer = ExAllocatePool( PagedPool, LocalObjectTypeName->MaximumLength );
                if (AccessState->ObjectTypeName.Buffer != NULL) {

                    AccessState->ObjectTypeName.MaximumLength = LocalObjectTypeName->MaximumLength;
                    RtlCopyUnicodeString( &AccessState->ObjectTypeName, LocalObjectTypeName );
                }
            }
        }

        if ( ObjectNameInfo != NULL ) {

            ExFreePool( ObjectNameInfo );
        }

        if ( ObjectTypeNameInfo != NULL ) {

            ExFreePool( ObjectTypeNameInfo );
        }
    }

    return;
}


VOID
SeObjectReferenceAuditAlarm(
    __in_opt PLUID OperationID,
    __in PVOID Object,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    __in ACCESS_MASK DesiredAccess,
    __in_opt PPRIVILEGE_SET Privileges,
    __in BOOLEAN AccessGranted,
    __in KPROCESSOR_MODE AccessMode
    )

/*++
Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    BOOLEAN GenerateAudit = FALSE;
    BOOLEAN GenerateAlarm = FALSE;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( OperationID );
    UNREFERENCED_PARAMETER( Privileges );
    
    if (AccessMode == KernelMode) {
        return;
    }

    if ( SecurityDescriptor != NULL ) {

        if ( SepAdtAuditThisEventWithContext( AuditCategoryDetailedTracking, AccessGranted, FALSE, SubjectSecurityContext )) {

            SepExamineSacl(
                RtlpSaclAddrSecurityDescriptor( (PISECURITY_DESCRIPTOR)SecurityDescriptor ),
                EffectiveToken( SubjectSecurityContext ),
                DesiredAccess,
                AccessGranted,
                &GenerateAudit,
                &GenerateAlarm
                );

            if ( GenerateAudit || GenerateAlarm ) {

                SepAdtObjectReferenceAuditAlarm(
                    Object,
                    SubjectSecurityContext,
                    DesiredAccess,
                    AccessGranted
                    );
            }
        }
    }

    return;

}



VOID
SeAuditHandleCreation(
    __in PACCESS_STATE AccessState,
    __in HANDLE Handle
    )

/*++

Routine Description:

    This function audits the creation of a handle.

    It will examine the AuditHandleCreation field in the passed AccessState,
    which will indicate whether auditing was performed when the object
    was found or created.

    This routine is necessary because object name decoding and handle
    allocation occur in widely separate places, preventing us from
    auditing everything at once.

Arguments:

    AccessState - Supplies a pointer to the AccessState structure
        representing this access attempt.

    Handle - The newly allocated handle value.

Return Value:

    None.

--*/

{
    BOOLEAN AuditPerformed = FALSE;
    PAUX_ACCESS_DATA AuxData;
    PAGED_CODE();

    AuxData = (PAUX_ACCESS_DATA)AccessState->AuxData;

#if DBG
    if ( AuxData->PrivilegesUsed )
    {
        ASSERT( IsValidPrivilegeCount(AuxData->PrivilegesUsed->PrivilegeCount) );
    }
#endif
    

    if ( AccessState->GenerateAudit ) {

        if ( AccessState->AuditPrivileges ) {

            //
            // ignore the result of the call below so that we
            // do not incorrectly set the value of AuditPerformed
            // which is later assigned to AccessState->GenerateOnClose
            //

            (VOID) SepAdtPrivilegeObjectAuditAlarm (
                       (PUNICODE_STRING)&SeSubsystemName,
                       Handle,
                       (PTOKEN)AccessState->SubjectSecurityContext.ClientToken,
                       (PTOKEN)AccessState->SubjectSecurityContext.PrimaryToken,
                       AccessState->SubjectSecurityContext.ProcessAuditId,
                       AccessState->PreviouslyGrantedAccess,
                       AuxData->PrivilegesUsed,
                       TRUE
                       );
        } else {

            AuditPerformed = SepAdtOpenObjectAuditAlarm (
                                 (PUNICODE_STRING)&SeSubsystemName,
                                 &Handle,
                                 &AccessState->ObjectTypeName,
                                 &AccessState->ObjectName,
                                 AccessState->SubjectSecurityContext.ClientToken,
                                 AccessState->SubjectSecurityContext.PrimaryToken,
                                 AccessState->OriginalDesiredAccess,
                                 AccessState->PreviouslyGrantedAccess,
                                 &AccessState->OperationID,
                                 AuxData->PrivilegesUsed,
                                 TRUE,
                                 PsGetCurrentProcessId(),
                                 AuditCategoryObjectAccess,
                                 NULL,
                                 0,
                                 NULL );
        }
    }

    //
    // If we generated an 'open' audit, make sure we generate a close
    //

    AccessState->GenerateOnClose = AuditPerformed;

    return;
}


VOID
SeCloseObjectAuditAlarm(
    __in PVOID Object,
    __in HANDLE Handle,
    __in BOOLEAN GenerateOnClose
    )

/*++

Routine Description:

    This routine is used to generate audit and alarm messages when a handle
    to an object is deleted.

    This routine may result in several messages being generated and sent to
    Port objects.  This may result in a significant latency before
    returning.  Design of routines that must call this routine must take
    this potential latency into account.  This may have an impact on the
    approach taken for data structure mutex locking, for example.

Arguments:

    Object - Address of the object being accessed.  This value will not be
        used as a pointer (referenced).  It is necessary only to enter into
        log messages.

    Handle - Supplies the handle value assigned to the open.

    GenerateOnClose - Is a boolean value returned from a corresponding
        SeOpenObjectAuditAlarm() call when the object handle was created.

Return Value:

    None.

--*/

{
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    PSID UserSid;
    NTSTATUS Status;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( Object );
    
    if (GenerateOnClose) {

        SeCaptureSubjectContext ( &SubjectSecurityContext );

        UserSid = SepTokenUserSid( EffectiveToken (&SubjectSecurityContext));


        SepAdtCloseObjectAuditAlarm( (PUNICODE_STRING) &SeSubsystemName,
                                     Handle,
                                     UserSid );

        SeReleaseSubjectContext ( &SubjectSecurityContext );
    }

    return;
}


VOID
SeDeleteObjectAuditAlarm(
    __in PVOID Object,
    __in HANDLE Handle
    )

/*++

Routine Description:

    This routine is used to generate audit and alarm messages when an object
    is marked for deletion.

    This routine may result in several messages being generated and sent to
    Port objects.  This may result in a significant latency before
    returning.  Design of routines that must call this routine must take
    this potential latency into account.  This may have an impact on the
    approach taken for data structure mutex locking, for example.

Arguments:

    Object - Address of the object being accessed.  This value will not be
        used as a pointer (referenced).  It is necessary only to enter into
        log messages.

    Handle - Supplies the handle value assigned to the open.

Return Value:

    None.

--*/

{
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    PSID UserSid;
    NTSTATUS Status;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( Object );
    
    SeCaptureSubjectContext ( &SubjectSecurityContext );

    UserSid = SepTokenUserSid( EffectiveToken (&SubjectSecurityContext));



    SepAdtDeleteObjectAuditAlarm (
        (PUNICODE_STRING)&SeSubsystemName,
        (PVOID)Handle,
        UserSid
        );

    SeReleaseSubjectContext ( &SubjectSecurityContext );

    return;
}


VOID
SepExamineSacl(
    IN PACL Sacl,
    IN PACCESS_TOKEN Token,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN AccessGranted,
    OUT PBOOLEAN GenerateAudit,
    OUT PBOOLEAN GenerateAlarm
    )

/*++

Routine Description:

    This routine will examine the passed Sacl and determine what
    if any action is required based its contents.

    Note that this routine is not aware of any system state, ie,
    whether or not auditing is currently enabled for either the
    system or this particular object type.

Arguments:

    Sacl - Supplies a pointer to the Sacl to be examined.

    Token - Supplies the effective token of the caller

    AccessGranted - Supplies whether or not the access attempt
        was successful.

    GenerateAudit - Returns a boolean indicating whether or not
        we should generate an audit.

    GenerateAlarm - Returns a boolean indicating whether or not
        we should generate an alarm.

Return Value:

    STATUS_SUCCESS - The operation completed successfully.

--*/

{

    ULONG i;
    PVOID Ace;
    ULONG AceCount;
    ACCESS_MASK AccessMask;
    UCHAR AceFlags;
    UCHAR MaximumAllowed;
    PSID AceSid;
    ULONG WorldSidLength = 0;

    PAGED_CODE();

    *GenerateAudit = FALSE;
    *GenerateAlarm = FALSE;


    //
    // If the Sacl is null or empty, do nothing and return
    //

    if (Sacl == NULL) {

        return;
    }

    AceCount = Sacl->AceCount;

    if (AceCount == 0) {
        return;
    }


    //
    // Generate an audit if the user asked for maximum allowed and
    // we find any allowed or deny ace with a sid that matches one
    // of the sids in the user's token.
    //

    MaximumAllowed = 0;
    if (DesiredAccess & MAXIMUM_ALLOWED) {

        if (AccessGranted) {
            MaximumAllowed = SUCCESSFUL_ACCESS_ACE_FLAG;
        } else {
            MaximumAllowed = FAILED_ACCESS_ACE_FLAG;
        }
    }


    //
    // Test whether we are dealing with the anonymous user.
    // To speed things up, we use WorldSidLength for two purposes:
    // - to indicate that the user is anonymous
    // - to hold the length of the world sid
    //

    if (*(PUSHORT)((PTOKEN)Token)->UserAndGroups->Sid == *(PUSHORT)SeAnonymousLogonSid &&
        RtlEqualMemory(
            ((PTOKEN)Token)->UserAndGroups->Sid,
            SeAnonymousLogonSid,
            SeLengthSid(SeAnonymousLogonSid))) {

        WorldSidLength = SeLengthSid(SeWorldSid);
    }


    //
    // Iterate through the ACEs on the Sacl until either we reach
    // the end or discover that we have to take all possible actions,
    // in which case it doesn't pay to look any further
    //

    for ( i = 0, Ace = FirstAce( Sacl ) ;
          (i < AceCount) && !(*GenerateAudit && *GenerateAlarm);
          i++, Ace = NextAce( Ace ) ) {

        if ( !(((PACE_HEADER)Ace)->AceFlags & INHERIT_ONLY_ACE)) {

            if ( (((PACE_HEADER)Ace)->AceType == SYSTEM_AUDIT_ACE_TYPE) ) {

                AceSid = &((PSYSTEM_AUDIT_ACE)Ace)->SidStart;

                if ( SepSidInToken( (PACCESS_TOKEN)Token, NULL, AceSid, FALSE ) ||
                     (WorldSidLength &&
                     *(PUSHORT)SeWorldSid == *(PUSHORT)AceSid &&
                     RtlEqualMemory(SeWorldSid, AceSid, WorldSidLength)) ) {

                    AccessMask = ((PSYSTEM_AUDIT_ACE)Ace)->Mask;
                    AceFlags   = ((PACE_HEADER)Ace)->AceFlags;

                    if ( AccessMask & DesiredAccess ) {

                        if (((AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) && AccessGranted) ||
                              ((AceFlags & FAILED_ACCESS_ACE_FLAG) && !AccessGranted)) {

                            *GenerateAudit = TRUE;
                        }

                    } else if ( MaximumAllowed & AceFlags ) {
                            *GenerateAudit = TRUE;
                    }
                }

            }

        }
    }

    return;
}


VOID
SepAuditTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PNTSTATUS AccessStatus,
    IN ULONG StartIndex,
    OUT PBOOLEAN GenerateSuccessAudit,
    OUT PBOOLEAN GenerateFailureAudit
    )
/*++

Routine Description:

    This routine determines if any children of the object represented by
    StartIndex have a different degree of success than the StartIndex element.

Arguments:

    ObjectTypeList - The object type list to update.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    AccessStatus - Specifies STATUS_SUCCESS or other error code to be
        propagated back to the caller

    StartIndex - Index to the target element to update.

    GenerateSuccessAudit - Returns a boolean indicating whether or not
        we should generate a success audit.

    GenerateFailureAudit - Returns a boolean indicating whether or not
        we should generate a failure audit.

Return Value:

    None.

--*/

{
    ULONG Index;
    BOOLEAN WasSuccess;

    PAGED_CODE();

    //
    // Determine if the target was successful.
    //

    WasSuccess = NT_SUCCESS( AccessStatus[StartIndex] );

    //
    // Loop handling all children of the target.
    //

    for ( Index=StartIndex+1; Index < ObjectTypeListLength; Index++ ) {

        //
        // By definition, the children of an object are all those entries
        // immediately following the target.  The list of children (or
        // grandchildren) stops as soon as we reach an entry the has the
        // same level as the target (a sibling) or lower than the target
        // (an uncle).
        //

        if ( ObjectTypeList[Index].Level <= ObjectTypeList[StartIndex].Level ) {
            break;
        }

        //
        // If the child has different access than the target,
        //  mark the child.
        //

        if ( WasSuccess && !NT_SUCCESS( AccessStatus[Index]) ) {

            *GenerateFailureAudit = TRUE;
            ObjectTypeList[Index].Flags |= OBJECT_FAILURE_AUDIT;

        } else if ( !WasSuccess && NT_SUCCESS( AccessStatus[Index]) ) {

            *GenerateSuccessAudit = TRUE;
            ObjectTypeList[Index].Flags |= OBJECT_SUCCESS_AUDIT;
        }
    }
}


VOID
SepSetAuditInfoForObjectType(
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK AccessMask,
    IN  ACCESS_MASK DesiredAccess,
    IN  PIOBJECT_TYPE_LIST ObjectTypeList,
    IN  ULONG ObjectTypeListLength,
    IN  BOOLEAN ReturnResultList,
    IN  ULONG ObjectTypeIndex,
    IN  PNTSTATUS AccessStatus,
    IN  PACCESS_MASK GrantedAccess,
    OUT PBOOLEAN GenerateSuccessAudit,
    OUT PBOOLEAN GenerateFailureAudit
    )
/*++

Routine Description:

    Determine if success/failure audit needs to be generated for
    object at ObjectTypeIndex in ObjectTypeList.

    This helper function is called only by SepExamineSaclEx.

Arguments:

    please refer to arg help for function SepExamineSaclEx

Return Value:

    None.

--*/
{
    UCHAR MaximumAllowed = 0;

    PAGED_CODE();

    if (DesiredAccess & MAXIMUM_ALLOWED) {

        if (NT_SUCCESS(AccessStatus[ObjectTypeIndex])) {
            MaximumAllowed = SUCCESSFUL_ACCESS_ACE_FLAG;
        } else {
            MaximumAllowed = FAILED_ACCESS_ACE_FLAG;
        }
    }

    if ( AccessMask & (DesiredAccess|GrantedAccess[ObjectTypeIndex]) ) {

        if ( ( AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG ) &&
             NT_SUCCESS(AccessStatus[ObjectTypeIndex]) ) {

                *GenerateSuccessAudit = TRUE;

                if ( ObjectTypeListLength != 0 ) {

                    ObjectTypeList[ObjectTypeIndex].Flags |= OBJECT_SUCCESS_AUDIT;

                    if ( ReturnResultList ) {

                        SepAuditTypeList( ObjectTypeList,
                                          ObjectTypeListLength,
                                          AccessStatus,
                                          ObjectTypeIndex,
                                          GenerateSuccessAudit,
                                          GenerateFailureAudit );
                    }
                }
        } else if ( ( AceFlags & FAILED_ACCESS_ACE_FLAG ) &&
                    !NT_SUCCESS(AccessStatus[ObjectTypeIndex]) ) {

                *GenerateFailureAudit = TRUE;

                if ( ObjectTypeListLength != 0 ) {

                    ObjectTypeList[ObjectTypeIndex].Flags |= OBJECT_FAILURE_AUDIT;

                    if ( ReturnResultList ) {

                        SepAuditTypeList( ObjectTypeList,
                                          ObjectTypeListLength,
                                          AccessStatus,
                                          ObjectTypeIndex,
                                          GenerateSuccessAudit,
                                          GenerateFailureAudit );
                    }
                }
        }

    } else if ( MaximumAllowed & AceFlags ) {
        if (MaximumAllowed == FAILED_ACCESS_ACE_FLAG) {
            *GenerateFailureAudit = TRUE;
            if ( ObjectTypeListLength != 0 ) {
                ObjectTypeList[ObjectTypeIndex].Flags |= OBJECT_FAILURE_AUDIT;
            }
        } else {
            *GenerateSuccessAudit = TRUE;
            if ( ObjectTypeListLength != 0 ) {
                ObjectTypeList[ObjectTypeIndex].Flags |= OBJECT_SUCCESS_AUDIT;
            }
        }
    }
}


VOID
SepExamineSaclEx(
    IN PACL Sacl,
    IN PACCESS_TOKEN Token,
    IN ACCESS_MASK DesiredAccess,
    IN PIOBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN BOOLEAN ReturnResultList,
    IN PNTSTATUS AccessStatus,
    IN PACCESS_MASK GrantedAccess,
    IN PSID PrincipalSelfSid,
    OUT PBOOLEAN GenerateSuccessAudit,
    OUT PBOOLEAN GenerateFailureAudit
    )

/*++

Routine Description:

    This routine will examine the passed Sacl and determine what
    if any action is required based its contents.

    Note that this routine is not aware of any system state, ie,
    whether or not auditing is currently enabled for either the
    system or this particular object type.

Arguments:

    Sacl - Supplies a pointer to the Sacl to be examined.

    Token - Supplies the effective token of the caller

    DesiredAccess - Access that the caller wanted to the object

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    ReturnResultList - If true, AccessStatus and GrantedAccess is actually
        an array of entries ObjectTypeListLength elements long.

    AccessStatus - Specifies STATUS_SUCCESS or other error code to be
        propagated back to the caller

    PrincipalSelfSid - If the security descriptor is associated with an object 
        that represents a principal (for example, a user object), 
        the PrincipalSelfSid parameter should be the SID of the object. 
        When evaluating access, this SID logically replaces the SID in any ACE 
        containing the well-known PRINCIPAL_SELF SID (S-1-5-10). 

    GrantedAccess - Specifies the access granted to the caller.

    GenerateSuccessAudit - Returns a boolean indicating whether or not
        we should generate a success audit.

    GenerateFailureAudit - Returns a boolean indicating whether or not
        we should generate a failure audit.

Return Value:

    STATUS_SUCCESS - The operation completed successfully.

--*/

{

    ULONG i, j;
    PVOID Ace;
    ULONG AceCount;
    ACCESS_MASK AccessMask=0;
    UCHAR AceFlags;
    UCHAR MaximumAllowed;
    PSID AceSid;
    ULONG WorldSidLength = 0;
    ULONG Index;
    ULONG SuccessIndex;
#define INVALID_OBJECT_TYPE_LIST_INDEX 0xFFFFFFFF

    PAGED_CODE();

    *GenerateSuccessAudit = FALSE;
    *GenerateFailureAudit = FALSE;


    //
    // If the Sacl is null, do nothing and return
    //

    if (Sacl == NULL) {
        return;
    }

    AceCount = Sacl->AceCount;

    if (AceCount == 0) {
        return;
    }


    //
    // Generate an audit if the user asked for maximum allowed and
    // we find any allowed or deny ace with a sid that matches one
    // of the sids in the user's token.
    //

    MaximumAllowed = 0;
    if (DesiredAccess & MAXIMUM_ALLOWED) {

        if (NT_SUCCESS(*AccessStatus)) {
            MaximumAllowed = SUCCESSFUL_ACCESS_ACE_FLAG;
        } else {
            MaximumAllowed = FAILED_ACCESS_ACE_FLAG;
        }
    }


    //
    // Test whether we are dealing with the anonymous user.
    // To speed things up, we use WorldSidLength for two purposes:
    // - to indicate that the user is anonymous
    // - to hold the length of the world sid
    //

    if (*(PUSHORT)((PTOKEN)Token)->UserAndGroups->Sid == *(PUSHORT)SeAnonymousLogonSid &&
        RtlEqualMemory(
            ((PTOKEN)Token)->UserAndGroups->Sid,
            SeAnonymousLogonSid,
            SeLengthSid(SeAnonymousLogonSid))) {

        WorldSidLength = SeLengthSid(SeWorldSid);
    }


    //
    // Iterate through the ACEs on the Sacl until either we reach
    // the end or discover that we have to take all possible actions,
    // in which case it doesn't pay to look any further
    //

    for ( i = 0, Ace = FirstAce( Sacl ) ;
          (i < AceCount) && !((*GenerateSuccessAudit || *GenerateFailureAudit) && ObjectTypeListLength <= 1 );
          i++, Ace = NextAce( Ace ) ) {

        AceFlags = ((PACE_HEADER)Ace)->AceFlags;
        
        if ( AceFlags & INHERIT_ONLY_ACE ) {

            continue;
        }


        Index = INVALID_OBJECT_TYPE_LIST_INDEX;

        if ( (((PACE_HEADER)Ace)->AceType == SYSTEM_AUDIT_ACE_TYPE) ) {

            AceSid = &((PSYSTEM_AUDIT_ACE)Ace)->SidStart;

            if ( SepSidInToken( Token, PrincipalSelfSid, AceSid, (BOOLEAN) ((AceFlags & FAILED_ACCESS_ACE_FLAG) != 0) ) ||
                 (WorldSidLength &&
                 *(PUSHORT)SeWorldSid == *(PUSHORT)AceSid &&
                 RtlEqualMemory(SeWorldSid, AceSid, WorldSidLength)) ) {

                AccessMask = ((PSYSTEM_AUDIT_ACE)Ace)->Mask;

                if (ObjectTypeListLength == 0) {

                    if ( NT_SUCCESS(AccessStatus[0]) ) {

                        if ( ( AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG ) &&
                             (( AccessMask & GrantedAccess[0] ) || ( MaximumAllowed == SUCCESSFUL_ACCESS_ACE_FLAG )) ) {

                            *GenerateSuccessAudit = TRUE;

                        } 

                    } else {

                        if ( ( AceFlags & FAILED_ACCESS_ACE_FLAG ) &&
                             (( AccessMask & DesiredAccess ) || ( MaximumAllowed == FAILED_ACCESS_ACE_FLAG )) ) {

                            *GenerateFailureAudit = TRUE;
                        }
                    }
                } else {
                    for (j=0; j < ObjectTypeListLength; j++)
                    {
                        SepSetAuditInfoForObjectType(AceFlags,
                                                     AccessMask,
                                                     DesiredAccess,
                                                     ObjectTypeList,
                                                     ObjectTypeListLength,
                                                     ReturnResultList,
                                                     j,
                                                     AccessStatus,
                                                     GrantedAccess,
                                                     GenerateSuccessAudit,
                                                     GenerateFailureAudit
                                                     );
                    }
                    Index = INVALID_OBJECT_TYPE_LIST_INDEX;
                }
            }

            //
            // Handle an object specific audit ACE
            //
        } else if ( (((PACE_HEADER)Ace)->AceType == SYSTEM_AUDIT_OBJECT_ACE_TYPE) ) {
            GUID *ObjectTypeInAce;

            //
            // If no object type is in the ACE,
            //  treat this as a normal audit ACE.
            //

            AccessMask = ((PSYSTEM_AUDIT_OBJECT_ACE)Ace)->Mask;
            ObjectTypeInAce = RtlObjectAceObjectType(Ace);
            AceSid = RtlObjectAceSid(Ace);

            if ( ObjectTypeInAce == NULL ) {

                if ( SepSidInToken( Token, PrincipalSelfSid, AceSid, (BOOLEAN)((AceFlags & FAILED_ACCESS_ACE_FLAG) != 0) ) ||
                     (WorldSidLength &&
                     *(PUSHORT)SeWorldSid == *(PUSHORT)AceSid &&
                     RtlEqualMemory(SeWorldSid, AceSid, WorldSidLength)) ) {

                    for (j=0; j < ObjectTypeListLength; j++)
                    {
                        SepSetAuditInfoForObjectType(AceFlags,
                                                     AccessMask,
                                                     DesiredAccess,
                                                     ObjectTypeList,
                                                     ObjectTypeListLength,
                                                     ReturnResultList,
                                                     j,
                                                     AccessStatus,
                                                     GrantedAccess,
                                                     GenerateSuccessAudit,
                                                     GenerateFailureAudit
                                                     );
                    }
                    Index = INVALID_OBJECT_TYPE_LIST_INDEX;
                }

                //
                // If an object type is in the ACE,
                //   Find it in the LocalTypeList before using the ACE.
                //
            } else {

                if ( SepSidInToken( Token, PrincipalSelfSid, AceSid, (BOOLEAN)((AceFlags & FAILED_ACCESS_ACE_FLAG) != 0) ) ||
                     (WorldSidLength &&
                     *(PUSHORT)SeWorldSid == *(PUSHORT)AceSid &&
                     RtlEqualMemory(SeWorldSid, AceSid, WorldSidLength)) ) {

                    if ( !SepObjectInTypeList( ObjectTypeInAce,
                                               ObjectTypeList,
                                               ObjectTypeListLength,
                                               &Index ) ) {

                        Index = INVALID_OBJECT_TYPE_LIST_INDEX;
                    }
                }
            }

        }

        //
        // If the ACE has a matched SID and a matched GUID,
        //  handle it.
        //

        if ( Index != INVALID_OBJECT_TYPE_LIST_INDEX ) {

            //
            // ASSERT: we have an ACE to be audited.
            //
            // Index is an index into ObjectTypeList of the entry to mark
            //  as the GUID needs auditing.
            //
            // SuccessIndex is an index into AccessStatus to determine if
            //  a success or failure audit is to be generated
            //

            SepSetAuditInfoForObjectType(AceFlags,
                                         AccessMask,
                                         DesiredAccess,
                                         ObjectTypeList,
                                         ObjectTypeListLength,
                                         ReturnResultList,
                                         Index,
                                         AccessStatus,
                                         GrantedAccess,
                                         GenerateSuccessAudit,
                                         GenerateFailureAudit
                                         );
        }

    }

    return;
}



/******************************************************************************
*                                                                             *
*    The following list of privileges is checked at high frequency            *
*    during normal operation, and tend to clog up the audit log when          *
*    privilege auditing is enabled.  The use of these privileges will         *
*    not be audited when they are checked singly or in combination with       *
*    each other.                                                              *
*                                                                             *
*    When adding new privileges, be careful to preserve the NULL              *
*    privilege pointer marking the end of the array.                          *
*                                                                             *
*    Be sure to update the corresponding array in LSA when adding new         *
*    privileges to this list (LsaFilterPrivileges).                           *
*                                                                             *
******************************************************************************/

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#pragma const_seg("PAGECONST")
#endif          

const PLUID SepFilterPrivilegesLong[] =
    {
        &SeChangeNotifyPrivilege,
        &SeAuditPrivilege,
        &SeCreateTokenPrivilege,
        &SeAssignPrimaryTokenPrivilege,
        &SeBackupPrivilege,
        &SeRestorePrivilege,
        &SeDebugPrivilege,
        NULL
    };

/******************************************************************************
*                                                                             *
*  The following list of privileges is the same as the above list, except     *
*  is missing backup and restore privileges.  This allows for auditing        *
*  the use of those privileges at the time they are used.                     *
*                                                                             *
*  The use of this list or the one above is determined by settings in         *
*  the registry.                                                              *
*                                                                             *
******************************************************************************/

const PLUID SepFilterPrivilegesShort[] =
    {
        &SeChangeNotifyPrivilege,
        &SeAuditPrivilege,
        &SeCreateTokenPrivilege,
        &SeAssignPrimaryTokenPrivilege,
        &SeDebugPrivilege,
        NULL
    };

//
// This list contains the privileges which are not audited for the service 
// accounts.  There should be no duplicates between this list and the 
// other filter lists.
//

const PLUID SepServicesFilterPrivileges[] =
    {      
        &SeSystemtimePrivilege,
        NULL
    };

PLUID const * SepFilterPrivileges = SepFilterPrivilegesShort;

BOOLEAN
SepInitializePrivilegeFilter(
    BOOLEAN Verbose
    )
/*++

Routine Description:

    Initializes SepFilterPrivileges for either normal or verbose auditing.

Arguments:

    Verbose - Whether we want to filter by the short or long privileges
    list.  Verbose == TRUE means use the short list.

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    if (Verbose) {
        SepFilterPrivileges = SepFilterPrivilegesShort;
    } else {
        SepFilterPrivileges = SepFilterPrivilegesLong;
    }

    return( TRUE );
}


BOOLEAN
SepFilterPrivilegeAudits(
    IN ULONG Flags,
    IN PPRIVILEGE_SET PrivilegeSet
    )

/*++

Routine Description:

    This routine will filter out a list of privileges as listed in the
    SepFilterPrivileges array.

Arguments:

    Privileges - The privilege set to be audited

Return Value:

    FALSE means that this use of privilege is not to be audited.
    TRUE means that the audit should continue normally.

--*/

{
    PLUID const *Privilege;
    ULONG Match = 0;
    ULONG i;

    PAGED_CODE();

    if ( !ARGUMENT_PRESENT(PrivilegeSet) ||
        (PrivilegeSet->PrivilegeCount == 0) ) {
        return( FALSE );
    }

    for (i=0; i<PrivilegeSet->PrivilegeCount; i++) {

        Privilege = SepFilterPrivileges;

        do {

            if ( RtlEqualLuid( &PrivilegeSet->Privilege[i].Luid, *Privilege )) {

                Match++;
                break;
            }

        } while ( *++Privilege != NULL  );
    }

    if (Flags & SEP_SERVICES_FILTER) {
        
        //
        // Additionally, check the privileges against those that are not 
        // audited for service accounts.
        //

        for (i=0; i<PrivilegeSet->PrivilegeCount; i++) {

            Privilege = SepServicesFilterPrivileges;

            do {

                if ( RtlEqualLuid( &PrivilegeSet->Privilege[i].Luid, *Privilege )) {

                    Match++;
                    break;
                }

            } while ( *++Privilege != NULL  );
        }
    }
    
    if ( Match == PrivilegeSet->PrivilegeCount ) {

        return( FALSE );

    } else {

        return( TRUE );
    }
}


BOOLEAN
SeAuditingFileOrGlobalEvents(
    __in BOOLEAN AccessGranted,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext
    )

/*++

Routine Description:

    This routine is to be called by a file system to quickly determine
    if we are auditing file open events.  This allows the file system
    to avoid the often considerable setup involved in generating an audit.

Arguments:

    AccessGranted - Supplies whether the access attempt was successful
        or a failure.

Return Value:

    Boolean - TRUE if events of type AccessGranted are being audited, FALSE
        otherwise.

--*/

{
    PISECURITY_DESCRIPTOR ISecurityDescriptor = (PISECURITY_DESCRIPTOR) SecurityDescriptor;

    PAGED_CODE();

    if ( ((PTOKEN)EffectiveToken( SubjectSecurityContext ))->AuditData != NULL) {
        return( TRUE );
    }

    if ( RtlpSaclAddrSecurityDescriptor( ISecurityDescriptor ) == NULL ) {

        return( FALSE );
    }

    return( SepAdtAuditThisEventWithContext(AuditCategoryObjectAccess, AccessGranted, !AccessGranted, SubjectSecurityContext) ||
            SepAdtAuditThisEventWithContext(AuditCategoryPrivilegeUse, AccessGranted, !AccessGranted, SubjectSecurityContext) );
}


BOOLEAN
SeAuditingFileEvents(
    __in BOOLEAN AccessGranted,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine is to be called by a file system to quickly determine
    if we are auditing file open events.  This allows the file system
    to avoid the often considerable setup involved in generating an audit.

Arguments:

    AccessGranted - Supplies whether the access attempt was successful
        or a failure.

Return Value:

    Boolean - TRUE if events of type AccessGranted are being audited, FALSE
        otherwise.

--*/

{
    PAGED_CODE();

    UNREFERENCED_PARAMETER( SecurityDescriptor );

    return( SepAdtAuditThisEvent( AuditCategoryObjectAccess, &AccessGranted ) || 
            SepAdtAuditThisEvent( AuditCategoryPrivilegeUse, &AccessGranted ));
}


BOOLEAN
SeAuditingFileEventsWithContext(
    __in BOOLEAN AccessGranted,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext
    )

/*++

Routine Description:

    This routine is to be called by a file system to quickly determine
    if we are auditing file open events.  This allows the file system
    to avoid the often considerable setup involved in generating an audit.

Arguments:

    AccessGranted - Supplies whether the access attempt was successful
        or a failure.

    SecurityDescriptor - SD to check sacl                                          
    
    SubjectSecurityContext - context to verify per user auditing from
    
Return Value:

    Boolean - TRUE if events of type AccessGranted are being audited, FALSE
        otherwise.

--*/

{
    PAGED_CODE();

    UNREFERENCED_PARAMETER( SecurityDescriptor );

    return( SepAdtAuditThisEventWithContext(AuditCategoryObjectAccess, AccessGranted, !AccessGranted, SubjectSecurityContext) ||
            SepAdtAuditThisEventWithContext(AuditCategoryPrivilegeUse, AccessGranted, !AccessGranted, SubjectSecurityContext) );
}



BOOLEAN                                  
SeAuditingHardLinkEvents(                                
    __in BOOLEAN AccessGranted,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine is to be called by a file system to quickly determine
    if we are auditing hard link creation.

Arguments:

    AccessGranted - Supplies whether the access attempt was successful
        or a failure.
        
    SecurityDescriptor - SD of the linked file.
    
Return Value:

    Boolean - TRUE if events of type AccessGranted are being audited, FALSE
        otherwise.

--*/

{
    PISECURITY_DESCRIPTOR pSD;
    PACL                  Sacl;

    PAGED_CODE();
   
    pSD  = (PISECURITY_DESCRIPTOR) SecurityDescriptor;                    
    Sacl = RtlpSaclAddrSecurityDescriptor( pSD ); 
    
    //
    // Audit hard link creation if object access auditing is on and the original file
    // has a non empty SACL.
    //

    if ( (NULL != Sacl)        && 
         (0 != Sacl->AceCount) &&
         (SepAdtAuditThisEvent( AuditCategoryObjectAccess, &AccessGranted ))) {

        return TRUE;
    }
    
    return FALSE;
}


BOOLEAN                                  
SeAuditingHardLinkEventsWithContext(                                
    __in BOOLEAN AccessGranted,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext
    )

/*++

Routine Description:

    This routine is to be called by a file system to quickly determine
    if we are auditing hard link creation.

Arguments:

    AccessGranted - Supplies whether the access attempt was successful
        or a failure.
        
    SecurityDescriptor - SD of the linked file.
    
Return Value:

    Boolean - TRUE if events of type AccessGranted are being audited, FALSE
        otherwise.

--*/

{
    PISECURITY_DESCRIPTOR pSD;
    PACL                  Sacl;

    PAGED_CODE();
   
    pSD  = (PISECURITY_DESCRIPTOR) SecurityDescriptor;                    
    Sacl = RtlpSaclAddrSecurityDescriptor( pSD ); 
   
    //
    // Audit hard link creation if object access auditing is on and the original file
    // has a non empty SACL.
    //

    if ( (NULL != Sacl) && 
         (0 != Sacl->AceCount) && 
         (SepAdtAuditThisEventWithContext( AuditCategoryObjectAccess, AccessGranted, !AccessGranted, SubjectSecurityContext ))) {
        
        return TRUE;
    }

    return FALSE;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\seglobal.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    seglobal.c

Abstract:

   This module contains the global variables used and exported by the security
   component.

--*/

#include "pch.h"

#pragma hdrstop

#include "adt.h"

VOID
SepInitializePrivilegeSets( VOID );


VOID
SepInitSystemDacls( VOID );

VOID
SepInitProcessAuditSd( VOID );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,SepVariableInitialization)
#pragma alloc_text(INIT,SepInitSystemDacls)
#pragma alloc_text(INIT,SepInitializePrivilegeSets)
#pragma alloc_text(PAGE,SepAssemblePrivileges)
#pragma alloc_text(INIT,SepInitializeWorkList)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#pragma const_seg("PAGECONST")
#endif

#ifdef    SE_DIAGNOSTICS_ENABLED

//
// Used to control the active SE diagnostic support provided
//

ULONG SeGlobalFlag = 0;

#endif // SE_DIAGNOSTICS_ENABLED



////////////////////////////////////////////////////////////////////////
//                                                                    //
//           Global, READ ONLY, Security variables                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  Authentication ID and source name used for system processes
//

const TOKEN_SOURCE SeSystemTokenSource = {"*SYSTEM*", 0};
const LUID SeSystemAuthenticationId = SYSTEM_LUID;
const LUID SeAnonymousAuthenticationId = ANONYMOUS_LOGON_LUID;


//
// Universal well known SIDs
//

PSID  SeNullSid = NULL;
PSID  SeWorldSid = NULL;
PSID  SeLocalSid = NULL;
PSID  SeCreatorOwnerSid = NULL;
PSID  SeCreatorGroupSid = NULL;
PSID  SeCreatorGroupServerSid = NULL;
PSID  SeCreatorOwnerServerSid = NULL;

//
// Sids defined by NT
//

PSID SeNtAuthoritySid = NULL;

PSID SeDialupSid = NULL;
PSID SeNetworkSid = NULL;
PSID SeBatchSid = NULL;
PSID SeInteractiveSid = NULL;
PSID SeServiceSid = NULL;
PSID SePrincipalSelfSid = NULL;
PSID SeLocalSystemSid = NULL;
PSID SeAuthenticatedUsersSid = NULL;
PSID SeAliasAdminsSid = NULL;
PSID SeRestrictedSid = NULL;
PSID SeAliasUsersSid = NULL;
PSID SeAliasGuestsSid = NULL;
PSID SeAliasPowerUsersSid = NULL;
PSID SeAliasAccountOpsSid = NULL;
PSID SeAliasSystemOpsSid = NULL;
PSID SeAliasPrintOpsSid = NULL;
PSID SeAliasBackupOpsSid = NULL;
PSID SeAnonymousLogonSid = NULL;
PSID SeLocalServiceSid = NULL;
PSID SeNetworkServiceSid = NULL;

//
// Well known tokens
//

PACCESS_TOKEN SeAnonymousLogonToken = NULL;
PACCESS_TOKEN SeAnonymousLogonTokenNoEveryone = NULL;

//
// System default DACLs & Security Descriptors
//
//  SePublicDefaultDacl     - Protects objects so that WORLD:E, Admins:ALL, System: ALL.
//                            Not inherited by sub-objects.
//
//  SePublicDefaultUnrestrictedDacl - Protects objects so that WORLD:E, Admins:ALL, System: ALL, Restricted:E
//                            Not inherited by sub-objects.
//
//  SePublicOpenDacl        - Protects so that WORLD:RWE, Admins: All, System: ALL
//                            Not inherited by sub-objects.
//
//  SePublicOpenUnrestrictedDacl - Protects so that WORLD:RWE, Admins: All, System: ALL, Restricted:RE
//                            Not inherited by sub-objects.
//
//  SeSystemDefaultDacl     - Protects objects so that SYSTEM (All) & ADMIN (RE + ReadControl) can use them.
//                            Not inherited by subobjects.
//

PSECURITY_DESCRIPTOR SePublicDefaultSd = NULL;
SECURITY_DESCRIPTOR  SepPublicDefaultSd = {0};
PSECURITY_DESCRIPTOR SePublicDefaultUnrestrictedSd = NULL;
SECURITY_DESCRIPTOR  SepPublicDefaultUnrestrictedSd = {0};
PSECURITY_DESCRIPTOR SePublicOpenUnrestrictedSd = NULL;
SECURITY_DESCRIPTOR  SepPublicOpenUnrestrictedSd = {0};
PSECURITY_DESCRIPTOR SePublicOpenSd = NULL;
SECURITY_DESCRIPTOR  SepPublicOpenSd = {0};
PSECURITY_DESCRIPTOR SeSystemDefaultSd = NULL;
SECURITY_DESCRIPTOR  SepSystemDefaultSd = {0};
PSECURITY_DESCRIPTOR SeLocalServicePublicSd = NULL;
SECURITY_DESCRIPTOR  SepLocalServicePublicSd = {0};

//
// security descriptor with a SACL to be used for adding
// a SACL on system processes
//

PSECURITY_DESCRIPTOR SepProcessAuditSd = NULL;

//
// Access mask used for constructing the SACL in SepProcessAuditSd
//

ACCESS_MASK SepProcessAccessesToAudit = 0;

//
// security descriptor to check if a given token has any one of
// following sids in it:
// -- SeLocalSystemSid
// -- SeLocalServiceSid
// -- SeNetworkServiceSid
//

PSECURITY_DESCRIPTOR SepImportantProcessSd = NULL;

//
// used with SepImportantProcessSd
//

GENERIC_MAPPING GenericMappingForMembershipCheck = {
    STANDARD_RIGHTS_READ,
    STANDARD_RIGHTS_EXECUTE,
    STANDARD_RIGHTS_WRITE,
    STANDARD_RIGHTS_ALL };


PACL SePublicDefaultDacl = NULL;
PACL SePublicDefaultUnrestrictedDacl = NULL;
PACL SePublicOpenDacl = NULL;
PACL SePublicOpenUnrestrictedDacl = NULL;
PACL SeSystemDefaultDacl = NULL;
PACL SeLocalServicePublicDacl = NULL;


//
// Sid of primary domain, and admin account in that domain
//

PSID SepPrimaryDomainSid = NULL;
PSID SepPrimaryDomainAdminSid = NULL;



//
//  Well known privilege values
//


LUID SeCreateTokenPrivilege = {0};
LUID SeAssignPrimaryTokenPrivilege = {0};
LUID SeLockMemoryPrivilege = {0};
LUID SeIncreaseQuotaPrivilege = {0};
LUID SeUnsolicitedInputPrivilege = {0};
LUID SeTcbPrivilege = {0};
LUID SeSecurityPrivilege = {0};
LUID SeTakeOwnershipPrivilege = {0};
LUID SeLoadDriverPrivilege = {0};
LUID SeCreatePagefilePrivilege = {0};
LUID SeIncreaseBasePriorityPrivilege = {0};
LUID SeSystemProfilePrivilege = {0};
LUID SeSystemtimePrivilege = {0};
LUID SeProfileSingleProcessPrivilege = {0};
LUID SeCreatePermanentPrivilege = {0};
LUID SeBackupPrivilege = {0};
LUID SeRestorePrivilege = {0};
LUID SeShutdownPrivilege = {0};
LUID SeDebugPrivilege = {0};
LUID SeAuditPrivilege = {0};
LUID SeSystemEnvironmentPrivilege = {0};
LUID SeChangeNotifyPrivilege = {0};
LUID SeRemoteShutdownPrivilege = {0};
LUID SeUndockPrivilege = {0};
LUID SeSyncAgentPrivilege = {0};
LUID SeEnableDelegationPrivilege = {0};
LUID SeManageVolumePrivilege = { 0 };
LUID SeImpersonatePrivilege = { 0 };
LUID SeCreateGlobalPrivilege = { 0 };

//
// This is for optimizing SepAdtAuditThisEventWithContext and SeDetailedAuditingWithContext.
// If no per user policy for any token has been set in the system for a specific
// category then we never need to do the more expensive token policy checks.  This counter
// is incremented by NtSetInformationToken, SepDuplicateToken, and SepFilterToken.
// SepTokenDeleteMethod and NtSetInformationToken can decrement this counter.
//

LONG SepTokenPolicyCounter[POLICY_AUDIT_EVENT_TYPE_COUNT];

// Define the following structures for export from the kernel.
// This will allow us to export pointers to these structures
// rather than a pointer for each element in the structure.
//

PSE_EXPORTS  SeExports = NULL;
SE_EXPORTS SepExports = {0};


static const SID_IDENTIFIER_AUTHORITY    SepNullSidAuthority    = SECURITY_NULL_SID_AUTHORITY;
static const SID_IDENTIFIER_AUTHORITY    SepWorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
static const SID_IDENTIFIER_AUTHORITY    SepLocalSidAuthority   = SECURITY_LOCAL_SID_AUTHORITY;
static const SID_IDENTIFIER_AUTHORITY    SepCreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
static const SID_IDENTIFIER_AUTHORITY    SepNtAuthority = SECURITY_NT_AUTHORITY;



//
// Some variables we are going to use to help speed up access
// checking.
//

static ULONG SinglePrivilegeSetSize = 0;
static ULONG DoublePrivilegeSetSize = 0;

static PPRIVILEGE_SET SepSystemSecurityPrivilegeSet = NULL;
static PPRIVILEGE_SET SepTakeOwnershipPrivilegeSet = NULL;
static PPRIVILEGE_SET SepDoublePrivilegeSet = NULL;


//
// Array containing information describing what is to be audited
//

SE_AUDITING_STATE SeAuditingState[POLICY_AUDIT_EVENT_TYPE_COUNT] =
    {
        { FALSE, FALSE },
        { FALSE, FALSE },
        { FALSE, FALSE },
        { FALSE, FALSE },
        { FALSE, FALSE },
        { FALSE, FALSE },
        { FALSE, FALSE },
        { FALSE, FALSE },
        { FALSE, FALSE }
    };

//
// Boolean indicating whether or not auditing is enabled for the system
//

BOOLEAN SepAdtAuditingEnabled = FALSE;

//
// Boolean to hold whether or not the user wants the system to crash when
// an audit fails.
//

BOOLEAN SepCrashOnAuditFail = FALSE;

//
// Handle to the LSA process
//

HANDLE SepLsaHandle = NULL;

#define SE_SUBSYSTEM_NAME L"Security"
const UNICODE_STRING SeSubsystemName = {
    sizeof(SE_SUBSYSTEM_NAME) - sizeof(WCHAR),
    sizeof(SE_SUBSYSTEM_NAME),
    SE_SUBSYSTEM_NAME
};


//
// Doubly linked list of work items queued to worker threads.
//

LIST_ENTRY SepLsaQueue = {NULL};

//
// Count to tell us how long the queue gets in SepRmCallLsa
//

ULONG SepLsaQueueLength = 0;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

//
// Mutex protecting the queue of work being passed to LSA
//

ERESOURCE SepLsaQueueLock = {0};

SEP_WORK_ITEM SepExWorkItem = {0};

#if DBG || TOKEN_LEAK_MONITOR
LONG    SepTokenLeakMethodCount = 0;
LONG    SepTokenLeakBreakCount  = 0;
LONG    SepTokenLeakMethodWatch = 0;
PVOID   SepTokenLeakToken       = NULL;
HANDLE  SepTokenLeakProcessCid  = NULL;
BOOLEAN SepTokenLeakTracking    = FALSE;
#endif


////////////////////////////////////////////////////////////////////////
//                                                                    //
//           Variable Initialization Routines                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////

BOOLEAN
SepVariableInitialization()
/*++

Routine Description:

    This function initializes the global variables used by and exposed
    by security.

Arguments:

    None.

Return Value:

    TRUE if variables successfully initialized.
    FALSE if not successfully initialized.

--*/
{

    ULONG SidWithZeroSubAuthorities;
    ULONG SidWithOneSubAuthority;
    ULONG SidWithTwoSubAuthorities;
    ULONG SidWithThreeSubAuthorities;

    SID_IDENTIFIER_AUTHORITY NullSidAuthority;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority;
    SID_IDENTIFIER_AUTHORITY LocalSidAuthority;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority;
    SID_IDENTIFIER_AUTHORITY SeNtAuthority;

    PAGED_CODE();

    NullSidAuthority         = SepNullSidAuthority;
    WorldSidAuthority        = SepWorldSidAuthority;
    LocalSidAuthority        = SepLocalSidAuthority;
    CreatorSidAuthority      = SepCreatorSidAuthority;
    SeNtAuthority            = SepNtAuthority;


    //
    //  The following SID sizes need to be allocated
    //

    SidWithZeroSubAuthorities  = RtlLengthRequiredSid( 0 );
    SidWithOneSubAuthority     = RtlLengthRequiredSid( 1 );
    SidWithTwoSubAuthorities   = RtlLengthRequiredSid( 2 );
    SidWithThreeSubAuthorities = RtlLengthRequiredSid( 3 );

    //
    //  Allocate and initialize the universal SIDs
    //

    SeNullSid         = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');
    SeWorldSid        = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');
    SeLocalSid        = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');
    SeCreatorOwnerSid = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');
    SeCreatorGroupSid = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');
    SeCreatorOwnerServerSid = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');
    SeCreatorGroupServerSid = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');

    //
    // Fail initialization if we didn't get enough memory for the universal
    // SIDs.
    //

    if ( (SeNullSid         == NULL)        ||
         (SeWorldSid        == NULL)        ||
         (SeLocalSid        == NULL)        ||
         (SeCreatorOwnerSid == NULL)        ||
         (SeCreatorGroupSid == NULL)        ||
         (SeCreatorOwnerServerSid == NULL ) ||
         (SeCreatorGroupServerSid == NULL )
       ) {

        return( FALSE );
    }

    RtlInitializeSid( SeNullSid,         &NullSidAuthority, 1 );
    RtlInitializeSid( SeWorldSid,        &WorldSidAuthority, 1 );
    RtlInitializeSid( SeLocalSid,        &LocalSidAuthority, 1 );
    RtlInitializeSid( SeCreatorOwnerSid, &CreatorSidAuthority, 1 );
    RtlInitializeSid( SeCreatorGroupSid, &CreatorSidAuthority, 1 );
    RtlInitializeSid( SeCreatorOwnerServerSid, &CreatorSidAuthority, 1 );
    RtlInitializeSid( SeCreatorGroupServerSid, &CreatorSidAuthority, 1 );

    *(RtlSubAuthoritySid( SeNullSid, 0 ))         = SECURITY_NULL_RID;
    *(RtlSubAuthoritySid( SeWorldSid, 0 ))        = SECURITY_WORLD_RID;
    *(RtlSubAuthoritySid( SeLocalSid, 0 ))        = SECURITY_LOCAL_RID;
    *(RtlSubAuthoritySid( SeCreatorOwnerSid, 0 )) = SECURITY_CREATOR_OWNER_RID;
    *(RtlSubAuthoritySid( SeCreatorGroupSid, 0 )) = SECURITY_CREATOR_GROUP_RID;
    *(RtlSubAuthoritySid( SeCreatorOwnerServerSid, 0 )) = SECURITY_CREATOR_OWNER_SERVER_RID;
    *(RtlSubAuthoritySid( SeCreatorGroupServerSid, 0 )) = SECURITY_CREATOR_GROUP_SERVER_RID;

    //
    // Allocate and initialize the NT defined SIDs
    //

    SeNtAuthoritySid  = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithZeroSubAuthorities,'iSeS');
    SeDialupSid       = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');
    SeNetworkSid      = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');
    SeBatchSid        = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');
    SeInteractiveSid  = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');
    SeServiceSid      = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');
    SePrincipalSelfSid = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');
    SeLocalSystemSid  = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');
    SeAuthenticatedUsersSid  = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');
    SeRestrictedSid   = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');
    SeAnonymousLogonSid = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');
    SeLocalServiceSid = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');
    SeNetworkServiceSid = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithOneSubAuthority,'iSeS');

    SeAliasAdminsSid     = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithTwoSubAuthorities,'iSeS');
    SeAliasUsersSid      = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithTwoSubAuthorities,'iSeS');
    SeAliasGuestsSid     = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithTwoSubAuthorities,'iSeS');
    SeAliasPowerUsersSid = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithTwoSubAuthorities,'iSeS');
    SeAliasAccountOpsSid = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithTwoSubAuthorities,'iSeS');
    SeAliasSystemOpsSid  = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithTwoSubAuthorities,'iSeS');
    SeAliasPrintOpsSid   = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithTwoSubAuthorities,'iSeS');
    SeAliasBackupOpsSid  = (PSID)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE,SidWithTwoSubAuthorities,'iSeS');

    //
    // Fail initialization if we didn't get enough memory for the NT SIDs.
    //

    if ( (SeNtAuthoritySid          == NULL) ||
         (SeDialupSid               == NULL) ||
         (SeNetworkSid              == NULL) ||
         (SeBatchSid                == NULL) ||
         (SeInteractiveSid          == NULL) ||
         (SeServiceSid              == NULL) ||
         (SePrincipalSelfSid        == NULL) ||
         (SeLocalSystemSid          == NULL) ||
         (SeAuthenticatedUsersSid   == NULL) ||
         (SeRestrictedSid           == NULL) ||
         (SeAnonymousLogonSid       == NULL) ||
         (SeLocalServiceSid         == NULL) ||
         (SeNetworkServiceSid       == NULL) ||
         (SeAliasAdminsSid          == NULL) ||
         (SeAliasUsersSid           == NULL) ||
         (SeAliasGuestsSid          == NULL) ||
         (SeAliasPowerUsersSid      == NULL) ||
         (SeAliasAccountOpsSid      == NULL) ||
         (SeAliasSystemOpsSid       == NULL) ||
         (SeAliasPrintOpsSid        == NULL) ||
         (SeAliasBackupOpsSid       == NULL)
       ) {

        return( FALSE );
    }

    RtlInitializeSid( SeNtAuthoritySid,         &SeNtAuthority, 0 );
    RtlInitializeSid( SeDialupSid,              &SeNtAuthority, 1 );
    RtlInitializeSid( SeNetworkSid,             &SeNtAuthority, 1 );
    RtlInitializeSid( SeBatchSid,               &SeNtAuthority, 1 );
    RtlInitializeSid( SeInteractiveSid,         &SeNtAuthority, 1 );
    RtlInitializeSid( SeServiceSid,             &SeNtAuthority, 1 );
    RtlInitializeSid( SePrincipalSelfSid,       &SeNtAuthority, 1 );
    RtlInitializeSid( SeLocalSystemSid,         &SeNtAuthority, 1 );
    RtlInitializeSid( SeAuthenticatedUsersSid,  &SeNtAuthority, 1 );
    RtlInitializeSid( SeRestrictedSid,          &SeNtAuthority, 1 );
    RtlInitializeSid( SeAnonymousLogonSid,      &SeNtAuthority, 1 );
    RtlInitializeSid( SeLocalServiceSid,        &SeNtAuthority, 1 );
    RtlInitializeSid( SeNetworkServiceSid,      &SeNtAuthority, 1 );

    RtlInitializeSid( SeAliasAdminsSid,     &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasUsersSid,      &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasGuestsSid,     &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasPowerUsersSid, &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasAccountOpsSid, &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasSystemOpsSid,  &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasPrintOpsSid,   &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasBackupOpsSid,  &SeNtAuthority, 2);

    *(RtlSubAuthoritySid( SeDialupSid,              0 )) = SECURITY_DIALUP_RID;
    *(RtlSubAuthoritySid( SeNetworkSid,             0 )) = SECURITY_NETWORK_RID;
    *(RtlSubAuthoritySid( SeBatchSid,               0 )) = SECURITY_BATCH_RID;
    *(RtlSubAuthoritySid( SeInteractiveSid,         0 )) = SECURITY_INTERACTIVE_RID;
    *(RtlSubAuthoritySid( SeServiceSid,             0 )) = SECURITY_SERVICE_RID;
    *(RtlSubAuthoritySid( SePrincipalSelfSid,       0 )) = SECURITY_PRINCIPAL_SELF_RID;
    *(RtlSubAuthoritySid( SeLocalSystemSid,         0 )) = SECURITY_LOCAL_SYSTEM_RID;
    *(RtlSubAuthoritySid( SeAuthenticatedUsersSid,  0 )) = SECURITY_AUTHENTICATED_USER_RID;
    *(RtlSubAuthoritySid( SeRestrictedSid,          0 )) = SECURITY_RESTRICTED_CODE_RID;
    *(RtlSubAuthoritySid( SeAnonymousLogonSid,      0 )) = SECURITY_ANONYMOUS_LOGON_RID;
    *(RtlSubAuthoritySid( SeLocalServiceSid,        0 )) = SECURITY_LOCAL_SERVICE_RID;
    *(RtlSubAuthoritySid( SeNetworkServiceSid,      0 )) = SECURITY_NETWORK_SERVICE_RID;


    *(RtlSubAuthoritySid( SeAliasAdminsSid,     0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasUsersSid,      0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasGuestsSid,     0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasPowerUsersSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasAccountOpsSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasSystemOpsSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasPrintOpsSid,   0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasBackupOpsSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;

    *(RtlSubAuthoritySid( SeAliasAdminsSid,     1 )) = DOMAIN_ALIAS_RID_ADMINS;
    *(RtlSubAuthoritySid( SeAliasUsersSid,      1 )) = DOMAIN_ALIAS_RID_USERS;
    *(RtlSubAuthoritySid( SeAliasGuestsSid,     1 )) = DOMAIN_ALIAS_RID_GUESTS;
    *(RtlSubAuthoritySid( SeAliasPowerUsersSid, 1 )) = DOMAIN_ALIAS_RID_POWER_USERS;
    *(RtlSubAuthoritySid( SeAliasAccountOpsSid, 1 )) = DOMAIN_ALIAS_RID_ACCOUNT_OPS;
    *(RtlSubAuthoritySid( SeAliasSystemOpsSid,  1 )) = DOMAIN_ALIAS_RID_SYSTEM_OPS;
    *(RtlSubAuthoritySid( SeAliasPrintOpsSid,   1 )) = DOMAIN_ALIAS_RID_PRINT_OPS;
    *(RtlSubAuthoritySid( SeAliasBackupOpsSid,  1 )) = DOMAIN_ALIAS_RID_BACKUP_OPS;



    //
    // Initialize system default dacl
    //

    SepInitSystemDacls();


    //
    // Initialize the well known privilege values
    //

    SeCreateTokenPrivilege =
        RtlConvertLongToLuid(SE_CREATE_TOKEN_PRIVILEGE);
    SeAssignPrimaryTokenPrivilege =
        RtlConvertLongToLuid(SE_ASSIGNPRIMARYTOKEN_PRIVILEGE);
    SeLockMemoryPrivilege =
        RtlConvertLongToLuid(SE_LOCK_MEMORY_PRIVILEGE);
    SeIncreaseQuotaPrivilege =
        RtlConvertLongToLuid(SE_INCREASE_QUOTA_PRIVILEGE);
    SeUnsolicitedInputPrivilege =
        RtlConvertLongToLuid(SE_UNSOLICITED_INPUT_PRIVILEGE);
    SeTcbPrivilege =
        RtlConvertLongToLuid(SE_TCB_PRIVILEGE);
    SeSecurityPrivilege =
        RtlConvertLongToLuid(SE_SECURITY_PRIVILEGE);
    SeTakeOwnershipPrivilege =
        RtlConvertLongToLuid(SE_TAKE_OWNERSHIP_PRIVILEGE);
    SeLoadDriverPrivilege =
        RtlConvertLongToLuid(SE_LOAD_DRIVER_PRIVILEGE);
    SeCreatePagefilePrivilege =
        RtlConvertLongToLuid(SE_CREATE_PAGEFILE_PRIVILEGE);
    SeIncreaseBasePriorityPrivilege =
        RtlConvertLongToLuid(SE_INC_BASE_PRIORITY_PRIVILEGE);
    SeSystemProfilePrivilege =
        RtlConvertLongToLuid(SE_SYSTEM_PROFILE_PRIVILEGE);
    SeSystemtimePrivilege =
        RtlConvertLongToLuid(SE_SYSTEMTIME_PRIVILEGE);
    SeProfileSingleProcessPrivilege =
        RtlConvertLongToLuid(SE_PROF_SINGLE_PROCESS_PRIVILEGE);
    SeCreatePermanentPrivilege =
        RtlConvertLongToLuid(SE_CREATE_PERMANENT_PRIVILEGE);
    SeBackupPrivilege =
        RtlConvertLongToLuid(SE_BACKUP_PRIVILEGE);
    SeRestorePrivilege =
        RtlConvertLongToLuid(SE_RESTORE_PRIVILEGE);
    SeShutdownPrivilege =
        RtlConvertLongToLuid(SE_SHUTDOWN_PRIVILEGE);
    SeDebugPrivilege =
        RtlConvertLongToLuid(SE_DEBUG_PRIVILEGE);
    SeAuditPrivilege =
        RtlConvertLongToLuid(SE_AUDIT_PRIVILEGE);
    SeSystemEnvironmentPrivilege =
        RtlConvertLongToLuid(SE_SYSTEM_ENVIRONMENT_PRIVILEGE);
    SeChangeNotifyPrivilege =
        RtlConvertLongToLuid(SE_CHANGE_NOTIFY_PRIVILEGE);
    SeRemoteShutdownPrivilege =
        RtlConvertLongToLuid(SE_REMOTE_SHUTDOWN_PRIVILEGE);
    SeUndockPrivilege =
        RtlConvertLongToLuid(SE_UNDOCK_PRIVILEGE);
    SeSyncAgentPrivilege =
        RtlConvertLongToLuid(SE_SYNC_AGENT_PRIVILEGE);
    SeEnableDelegationPrivilege =
        RtlConvertLongToLuid(SE_ENABLE_DELEGATION_PRIVILEGE);
    SeManageVolumePrivilege =
        RtlConvertLongToLuid(SE_MANAGE_VOLUME_PRIVILEGE);
    SeImpersonatePrivilege = 
        RtlConvertLongToLuid(SE_IMPERSONATE_PRIVILEGE);
    SeCreateGlobalPrivilege =
        RtlConvertLongToLuid(SE_CREATE_GLOBAL_PRIVILEGE);


    //
    // Initialize the SeExports structure for exporting all
    // of the information we've created out of the kernel.
    //

    //
    // Package these together for export
    //


    SepExports.SeNullSid         = SeNullSid;
    SepExports.SeWorldSid        = SeWorldSid;
    SepExports.SeLocalSid        = SeLocalSid;
    SepExports.SeCreatorOwnerSid = SeCreatorOwnerSid;
    SepExports.SeCreatorGroupSid = SeCreatorGroupSid;


    SepExports.SeNtAuthoritySid         = SeNtAuthoritySid;
    SepExports.SeDialupSid              = SeDialupSid;
    SepExports.SeNetworkSid             = SeNetworkSid;
    SepExports.SeBatchSid               = SeBatchSid;
    SepExports.SeInteractiveSid         = SeInteractiveSid;
    SepExports.SeLocalSystemSid         = SeLocalSystemSid;
    SepExports.SeAuthenticatedUsersSid  = SeAuthenticatedUsersSid;
    SepExports.SeRestrictedSid          = SeRestrictedSid;
    SepExports.SeAnonymousLogonSid      = SeAnonymousLogonSid;
    SepExports.SeLocalServiceSid        = SeLocalServiceSid;
    SepExports.SeNetworkServiceSid      = SeNetworkServiceSid;
    SepExports.SeAliasAdminsSid         = SeAliasAdminsSid;
    SepExports.SeAliasUsersSid          = SeAliasUsersSid;
    SepExports.SeAliasGuestsSid         = SeAliasGuestsSid;
    SepExports.SeAliasPowerUsersSid     = SeAliasPowerUsersSid;
    SepExports.SeAliasAccountOpsSid     = SeAliasAccountOpsSid;
    SepExports.SeAliasSystemOpsSid      = SeAliasSystemOpsSid;
    SepExports.SeAliasPrintOpsSid       = SeAliasPrintOpsSid;
    SepExports.SeAliasBackupOpsSid      = SeAliasBackupOpsSid;



    SepExports.SeCreateTokenPrivilege          = SeCreateTokenPrivilege;
    SepExports.SeAssignPrimaryTokenPrivilege   = SeAssignPrimaryTokenPrivilege;
    SepExports.SeLockMemoryPrivilege           = SeLockMemoryPrivilege;
    SepExports.SeIncreaseQuotaPrivilege        = SeIncreaseQuotaPrivilege;
    SepExports.SeUnsolicitedInputPrivilege     = SeUnsolicitedInputPrivilege;
    SepExports.SeTcbPrivilege                  = SeTcbPrivilege;
    SepExports.SeSecurityPrivilege             = SeSecurityPrivilege;
    SepExports.SeTakeOwnershipPrivilege        = SeTakeOwnershipPrivilege;
    SepExports.SeLoadDriverPrivilege           = SeLoadDriverPrivilege;
    SepExports.SeCreatePagefilePrivilege       = SeCreatePagefilePrivilege;
    SepExports.SeIncreaseBasePriorityPrivilege = SeIncreaseBasePriorityPrivilege;
    SepExports.SeSystemProfilePrivilege        = SeSystemProfilePrivilege;
    SepExports.SeSystemtimePrivilege           = SeSystemtimePrivilege;
    SepExports.SeProfileSingleProcessPrivilege = SeProfileSingleProcessPrivilege;
    SepExports.SeCreatePermanentPrivilege      = SeCreatePermanentPrivilege;
    SepExports.SeBackupPrivilege               = SeBackupPrivilege;
    SepExports.SeRestorePrivilege              = SeRestorePrivilege;
    SepExports.SeShutdownPrivilege             = SeShutdownPrivilege;
    SepExports.SeDebugPrivilege                = SeDebugPrivilege;
    SepExports.SeAuditPrivilege                = SeAuditPrivilege;
    SepExports.SeSystemEnvironmentPrivilege    = SeSystemEnvironmentPrivilege;
    SepExports.SeChangeNotifyPrivilege         = SeChangeNotifyPrivilege;
    SepExports.SeRemoteShutdownPrivilege       = SeRemoteShutdownPrivilege;
    SepExports.SeUndockPrivilege               = SeUndockPrivilege;
    SepExports.SeSyncAgentPrivilege            = SeSyncAgentPrivilege;
    SepExports.SeEnableDelegationPrivilege     = SeEnableDelegationPrivilege;
    SepExports.SeManageVolumePrivilege         = SeManageVolumePrivilege;
    SepExports.SeImpersonatePrivilege          = SeImpersonatePrivilege ;
    SepExports.SeCreateGlobalPrivilege         = SeCreateGlobalPrivilege;


    SeExports = &SepExports;

    //
    // Initialize frequently used privilege sets to speed up access
    // validation.
    //

    SepInitializePrivilegeSets();

    return TRUE;

}


VOID
SepInitProcessAuditSd( VOID )
/*++

Routine Description:

    This function initializes SepProcessAuditSd -- a security descriptor
    that is used by SepAddSaclToProcess to add SACL to the existing
    security descriptor on a system process.

    A system process is defined as the one whose token has at least
    one of the following sids.
    -- SeLocalSystemSid
    -- SeLocalServiceSid
    -- SeNetworkServiceSid

Arguments:

    None.

Return Value:

    None.


--*/
{
#define PROCESS_ACCESSES_TO_AUDIT ( PROCESS_CREATE_THREAD   |\
                                    PROCESS_SET_INFORMATION |\
                                    PROCESS_SET_PORT        |\
                                    PROCESS_SUSPEND_RESUME )

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AclLength, TotalSdLength;
    PISECURITY_DESCRIPTOR Sd = NULL;
    PISECURITY_DESCRIPTOR Sd2 = NULL;
    PACL Acl = NULL;

    //
    // free earlier instance if present
    //

    if ( SepProcessAuditSd != NULL ) {

        ExFreePool( SepProcessAuditSd );
        SepProcessAuditSd = NULL;
    }

    //
    // Don't initialize SeProcessAuditSd if SepProcessAccessesToAudit is 0
    // This effectively disables process access auditing
    //

    if ( SepProcessAccessesToAudit == 0 ) {

        goto Cleanup;
    }

    AclLength = (ULONG)sizeof(ACL) +
        ((ULONG)sizeof(SYSTEM_AUDIT_ACE) - sizeof(ULONG)) +
        SeLengthSid( SeWorldSid );

    TotalSdLength = sizeof(SECURITY_DESCRIPTOR) + AclLength;

    Sd = (PSECURITY_DESCRIPTOR) ExAllocatePoolWithTag(
                                    NonPagedPool,
                                    TotalSdLength,
                                    'cAeS');

    if ( Sd == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Acl = (PACL) (Sd + 1);

    Status = RtlCreateAcl( Acl, AclLength, ACL_REVISION2 );

    if ( NT_SUCCESS( Status )) {

        Status = RtlAddAuditAccessAce(
                     Acl,
                     ACL_REVISION2,
                     SepProcessAccessesToAudit,
                     SeWorldSid,
                     TRUE,
                     TRUE
                     );

        if ( NT_SUCCESS( Status )) {

            Status = RtlCreateSecurityDescriptor( Sd,
                                                  SECURITY_DESCRIPTOR_REVISION1 );
            if ( NT_SUCCESS( Status )) {

                Status = RtlSetSaclSecurityDescriptor( Sd,
                                                       TRUE, Acl, FALSE );
                if ( NT_SUCCESS( Status )) {

                    SepProcessAuditSd = Sd;
                }
            }
        }
    }

    ASSERT( NT_SUCCESS(Status) );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // create and initialize SepImportantProcessSd
    //

    AclLength = (ULONG)sizeof(ACL) +
        (3*((ULONG)sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) +
        SeLengthSid( SeLocalSystemSid ) +
        SeLengthSid( SeLocalServiceSid ) +
        SeLengthSid( SeNetworkServiceSid );

    TotalSdLength = sizeof(SECURITY_DESCRIPTOR) + AclLength;

    Sd2 = (PSECURITY_DESCRIPTOR) ExAllocatePoolWithTag(
                                    NonPagedPool,
                                    TotalSdLength,
                                    'cAeS');

    if ( Sd2 == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Acl = (PACL) (Sd2 + 1);

    Status = RtlCreateAcl( Acl, AclLength, ACL_REVISION2 );

    if ( NT_SUCCESS( Status )) {

        Status = RtlAddAccessAllowedAce(
                     Acl,
                     ACL_REVISION2,
                     SEP_QUERY_MEMBERSHIP,
                     SeLocalSystemSid
                     );

        if ( !NT_SUCCESS( Status )) {

            goto Cleanup;
        }

        Status = RtlAddAccessAllowedAce(
                     Acl,
                     ACL_REVISION2,
                     SEP_QUERY_MEMBERSHIP,
                     SeLocalServiceSid
                     );

        if ( !NT_SUCCESS( Status )) {

            goto Cleanup;
        }


        Status = RtlAddAccessAllowedAce(
                     Acl,
                     ACL_REVISION2,
                     SEP_QUERY_MEMBERSHIP,
                     SeNetworkServiceSid
                     );

        if ( !NT_SUCCESS( Status )) {

            goto Cleanup;
        }

        Status = RtlCreateSecurityDescriptor( Sd2, SECURITY_DESCRIPTOR_REVISION1 );

        if ( NT_SUCCESS( Status )) {

            Status = RtlSetDaclSecurityDescriptor( Sd2, TRUE, Acl, FALSE );

            if ( NT_SUCCESS( Status )) {

                SepImportantProcessSd = Sd2;
            }
        }
    }


 Cleanup:

    if ( !NT_SUCCESS( Status )) {

        ASSERT( FALSE && L"SepInitProcessAuditSd failed" );

        //
        // this will bugcheck if SepCrashOnAuditFail is TRUE
        //

        SepAuditFailed( Status );

        if ( Sd ) {

            ExFreePool( Sd );
            Sd = NULL;
            SepProcessAuditSd = NULL;
        }
        if ( Sd2 ) {

            ExFreePool( Sd2 );
            Sd2 = NULL;
            SepImportantProcessSd = NULL;
        }
    }
}



VOID
SepInitSystemDacls( VOID )
/*++

Routine Description:

    This function initializes the system's default dacls & security
    descriptors.

Arguments:

    None.

Return Value:

    None.


--*/
{

    NTSTATUS
        Status;

    ULONG
        PublicLength,
        PublicUnrestrictedLength,
        SystemLength,
        PublicOpenLength,
        LocalServiceLength;



    PAGED_CODE();

    //
    // Set up a default ACLs
    //
    //    Public:       WORLD:execute, SYSTEM:all, ADMINS:all
    //    PublicUnrestricted: WORLD:execute, SYSTEM:all, ADMINS:all, Restricted:execute
    //    Public Open:  WORLD:(Read|Write|Execute), ADMINS:(all), SYSTEM:all
    //    System:       SYSTEM:all, ADMINS:(read|execute|read_control)
    //    Unrestricted: WORLD:(all), Restricted:(all)

    SystemLength = (ULONG)sizeof(ACL) +
                   (2*((ULONG)sizeof(ACCESS_ALLOWED_ACE))) +
                   SeLengthSid( SeLocalSystemSid ) +
                   SeLengthSid( SeAliasAdminsSid );

    PublicLength = SystemLength +
                   ((ULONG)sizeof(ACCESS_ALLOWED_ACE)) +
                   SeLengthSid( SeWorldSid );

    PublicUnrestrictedLength = PublicLength +
                   ((ULONG)sizeof(ACCESS_ALLOWED_ACE)) +
                   SeLengthSid( SeRestrictedSid );

    PublicOpenLength = PublicLength;

    LocalServiceLength = (ULONG)sizeof(ACL) +
                         4 * (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
                         SeLengthSid(SeWorldSid) +
                         SeLengthSid(SeLocalSystemSid) +
                         SeLengthSid(SeLocalServiceSid) +
                         SeLengthSid(SeAliasAdminsSid);


    SePublicDefaultDacl = (PACL)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE, PublicLength, 'cAeS');
    SePublicDefaultUnrestrictedDacl = (PACL)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE, PublicUnrestrictedLength, 'cAeS');
    SePublicOpenDacl = (PACL)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE, PublicOpenLength, 'cAeS');
    SePublicOpenUnrestrictedDacl = (PACL)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE, PublicUnrestrictedLength, 'cAeS');
    SeSystemDefaultDacl = (PACL)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE, SystemLength, 'cAeS');
    SeLocalServicePublicDacl = (PACL)ExAllocatePoolWithTag(PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE, LocalServiceLength, 'cAeS');
    ASSERT(SePublicDefaultDacl != NULL);
    ASSERT(SePublicDefaultUnrestrictedDacl != NULL);
    ASSERT(SePublicOpenDacl    != NULL);
    ASSERT(SePublicOpenUnrestrictedDacl    != NULL);
    ASSERT(SeSystemDefaultDacl != NULL);
    ASSERT(SeLocalServicePublicDacl != NULL);



    Status = RtlCreateAcl( SePublicDefaultDacl, PublicLength, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );
    Status = RtlCreateAcl( SePublicDefaultUnrestrictedDacl, PublicUnrestrictedLength, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );
    Status = RtlCreateAcl( SePublicOpenDacl, PublicOpenLength, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );
    Status = RtlCreateAcl( SePublicOpenUnrestrictedDacl, PublicUnrestrictedLength, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );
    Status = RtlCreateAcl( SeSystemDefaultDacl, SystemLength, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );
    Status = RtlCreateAcl( SeLocalServicePublicDacl, LocalServiceLength, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );


    //
    // WORLD access (Public DACLs and OpenUnrestricted only)
    //

    Status = RtlAddAccessAllowedAce (
                 SePublicDefaultDacl,
                 ACL_REVISION2,
                 GENERIC_EXECUTE,
                 SeWorldSid
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAccessAllowedAce (
                 SePublicDefaultUnrestrictedDacl,
                 ACL_REVISION2,
                 GENERIC_EXECUTE,
                 SeWorldSid
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAccessAllowedAce (
                 SePublicOpenDacl,
                 ACL_REVISION2,
                 (GENERIC_READ | GENERIC_WRITE  | GENERIC_EXECUTE),
                 SeWorldSid
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAccessAllowedAce (
                 SePublicOpenUnrestrictedDacl,
                 ACL_REVISION2,
                 (GENERIC_READ | GENERIC_WRITE  | GENERIC_EXECUTE),
                 SeWorldSid
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAccessAllowedAce (
                 SeLocalServicePublicDacl,
                 ACL_REVISION2,
                 GENERIC_EXECUTE,
                 SeWorldSid
                 );
    ASSERT( NT_SUCCESS(Status) );

    //
    // SYSTEM access  (PublicDefault, PublicOpen, and SystemDefault)
    //


    Status = RtlAddAccessAllowedAce (
                 SePublicDefaultDacl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 SeLocalSystemSid
                 );
    ASSERT( NT_SUCCESS(Status) );


    Status = RtlAddAccessAllowedAce (
                 SePublicDefaultUnrestrictedDacl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 SeLocalSystemSid
                 );
    ASSERT( NT_SUCCESS(Status) );


    Status = RtlAddAccessAllowedAce (
                 SePublicOpenDacl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 SeLocalSystemSid
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAccessAllowedAce (
                 SePublicOpenUnrestrictedDacl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 SeLocalSystemSid
                 );
    ASSERT( NT_SUCCESS(Status) );


    Status = RtlAddAccessAllowedAce (
                 SeSystemDefaultDacl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 SeLocalSystemSid
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAccessAllowedAce (
                 SeLocalServicePublicDacl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 SeLocalSystemSid
                 );
    ASSERT( NT_SUCCESS(Status) );

    //
    // ADMINISTRATORS access  (PublicDefault, PublicOpen, and SystemDefault)
    //

    Status = RtlAddAccessAllowedAce (
                 SePublicDefaultDacl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 SeAliasAdminsSid
                 );
    ASSERT( NT_SUCCESS(Status) );


    Status = RtlAddAccessAllowedAce (
                 SePublicDefaultUnrestrictedDacl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 SeAliasAdminsSid
                 );
    ASSERT( NT_SUCCESS(Status) );


    Status = RtlAddAccessAllowedAce (
                 SePublicOpenDacl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 SeAliasAdminsSid
                 );
    ASSERT( NT_SUCCESS(Status) );


    Status = RtlAddAccessAllowedAce (
                 SePublicOpenUnrestrictedDacl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 SeAliasAdminsSid
                 );
    ASSERT( NT_SUCCESS(Status) );


    Status = RtlAddAccessAllowedAce (
                 SeSystemDefaultDacl,
                 ACL_REVISION2,
                 GENERIC_READ | GENERIC_EXECUTE | READ_CONTROL,
                 SeAliasAdminsSid
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAccessAllowedAce (
                 SeLocalServicePublicDacl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 SeAliasAdminsSid
                 );
    ASSERT( NT_SUCCESS(Status) );

    //
    // RESTRICTED access  (PublicDefaultUnrestricted and OpenUnrestricted)
    //

    Status = RtlAddAccessAllowedAce (
                 SePublicDefaultUnrestrictedDacl,
                 ACL_REVISION2,
                 GENERIC_EXECUTE,
                 SeRestrictedSid
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAccessAllowedAce (
                 SePublicOpenUnrestrictedDacl,
                 ACL_REVISION2,
                 GENERIC_EXECUTE | GENERIC_READ,
                 SeRestrictedSid
                 );
    ASSERT( NT_SUCCESS(Status) );


    //
    // Local Service
    //

    Status = RtlAddAccessAllowedAce (
                 SeLocalServicePublicDacl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 SeLocalServiceSid
                 );
    ASSERT( NT_SUCCESS(Status) );


    //
    // Now initialize security descriptors
    // that export this protection
    //


    SePublicDefaultSd = (PSECURITY_DESCRIPTOR)&SepPublicDefaultSd;
    Status = RtlCreateSecurityDescriptor(
                 SePublicDefaultSd,
                 SECURITY_DESCRIPTOR_REVISION1
                 );
    ASSERT( NT_SUCCESS(Status) );
    Status = RtlSetDaclSecurityDescriptor(
                 SePublicDefaultSd,
                 TRUE,                       // DaclPresent
                 SePublicDefaultDacl,
                 FALSE                       // DaclDefaulted
                 );
    ASSERT( NT_SUCCESS(Status) );


    SePublicDefaultUnrestrictedSd = (PSECURITY_DESCRIPTOR)&SepPublicDefaultUnrestrictedSd;
    Status = RtlCreateSecurityDescriptor(
                 SePublicDefaultUnrestrictedSd,
                 SECURITY_DESCRIPTOR_REVISION1
                 );
    ASSERT( NT_SUCCESS(Status) );
    Status = RtlSetDaclSecurityDescriptor(
                 SePublicDefaultUnrestrictedSd,
                 TRUE,                       // DaclPresent
                 SePublicDefaultUnrestrictedDacl,
                 FALSE                       // DaclDefaulted
                 );
    ASSERT( NT_SUCCESS(Status) );


    SePublicOpenSd = (PSECURITY_DESCRIPTOR)&SepPublicOpenSd;
    Status = RtlCreateSecurityDescriptor(
                 SePublicOpenSd,
                 SECURITY_DESCRIPTOR_REVISION1
                 );
    ASSERT( NT_SUCCESS(Status) );
    Status = RtlSetDaclSecurityDescriptor(
                 SePublicOpenSd,
                 TRUE,                       // DaclPresent
                 SePublicOpenDacl,
                 FALSE                       // DaclDefaulted
                 );
    ASSERT( NT_SUCCESS(Status) );


    SePublicOpenUnrestrictedSd = (PSECURITY_DESCRIPTOR)&SepPublicOpenUnrestrictedSd;
    Status = RtlCreateSecurityDescriptor(
                 SePublicOpenUnrestrictedSd,
                 SECURITY_DESCRIPTOR_REVISION1
                 );
    ASSERT( NT_SUCCESS(Status) );
    Status = RtlSetDaclSecurityDescriptor(
                 SePublicOpenUnrestrictedSd,
                 TRUE,                       // DaclPresent
                 SePublicOpenUnrestrictedDacl,
                 FALSE                       // DaclDefaulted
                 );
    ASSERT( NT_SUCCESS(Status) );


    SeSystemDefaultSd = (PSECURITY_DESCRIPTOR)&SepSystemDefaultSd;
    Status = RtlCreateSecurityDescriptor(
                 SeSystemDefaultSd,
                 SECURITY_DESCRIPTOR_REVISION1
                 );
    ASSERT( NT_SUCCESS(Status) );
    Status = RtlSetDaclSecurityDescriptor(
                 SeSystemDefaultSd,
                 TRUE,                       // DaclPresent
                 SeSystemDefaultDacl,
                 FALSE                       // DaclDefaulted
                 );
    ASSERT( NT_SUCCESS(Status) );

    SeLocalServicePublicSd = (PSECURITY_DESCRIPTOR)&SepLocalServicePublicSd;
    Status = RtlCreateSecurityDescriptor(
                 SeLocalServicePublicSd,
                 SECURITY_DESCRIPTOR_REVISION1
                 );
    ASSERT( NT_SUCCESS(Status) );
    Status = RtlSetDaclSecurityDescriptor(
                 SeLocalServicePublicSd,
                 TRUE,                       // DaclPresent
                 SeLocalServicePublicDacl,
                 FALSE                       // DaclDefaulted
                 );
    ASSERT( NT_SUCCESS(Status) );



    return;

}


VOID
SepInitializePrivilegeSets( VOID )
/*++

Routine Description:

    This routine is called once during system initialization to pre-allocate
    and initialize some commonly used privilege sets.

Arguments:

    None

Return Value:

    None.

--*/
{
    PAGED_CODE();

    SinglePrivilegeSetSize = sizeof( PRIVILEGE_SET );
    DoublePrivilegeSetSize = sizeof( PRIVILEGE_SET ) +
                                (ULONG)sizeof( LUID_AND_ATTRIBUTES );

    SepSystemSecurityPrivilegeSet = ExAllocatePoolWithTag( PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE, SinglePrivilegeSetSize, 'rPeS' );
    SepTakeOwnershipPrivilegeSet  = ExAllocatePoolWithTag( PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE, SinglePrivilegeSetSize, 'rPeS' );
    SepDoublePrivilegeSet         = ExAllocatePoolWithTag( PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE, DoublePrivilegeSetSize, 'rPeS' );

    SepSystemSecurityPrivilegeSet->PrivilegeCount = 1;
    SepSystemSecurityPrivilegeSet->Control = 0;
    SepSystemSecurityPrivilegeSet->Privilege[0].Luid = SeSecurityPrivilege;
    SepSystemSecurityPrivilegeSet->Privilege[0].Attributes = SE_PRIVILEGE_USED_FOR_ACCESS;

    SepTakeOwnershipPrivilegeSet->PrivilegeCount = 1;
    SepTakeOwnershipPrivilegeSet->Control = 0;
    SepTakeOwnershipPrivilegeSet->Privilege[0].Luid = SeTakeOwnershipPrivilege;
    SepTakeOwnershipPrivilegeSet->Privilege[0].Attributes = SE_PRIVILEGE_USED_FOR_ACCESS;

    SepDoublePrivilegeSet->PrivilegeCount = 2;
    SepDoublePrivilegeSet->Control = 0;

    SepDoublePrivilegeSet->Privilege[0].Luid = SeSecurityPrivilege;
    SepDoublePrivilegeSet->Privilege[0].Attributes = SE_PRIVILEGE_USED_FOR_ACCESS;

    SepDoublePrivilegeSet->Privilege[1].Luid = SeTakeOwnershipPrivilege;
    SepDoublePrivilegeSet->Privilege[1].Attributes = SE_PRIVILEGE_USED_FOR_ACCESS;

}



VOID
SepAssemblePrivileges(
    IN ULONG PrivilegeCount,
    IN BOOLEAN SystemSecurity,
    IN BOOLEAN WriteOwner,
    OUT PPRIVILEGE_SET *Privileges
    )
/*++

Routine Description:

    This routine takes the results of the various privilege checks
    in SeAccessCheck and returns an appropriate privilege set.

Arguments:

    PrivilegeCount - The number of privileges granted.

    SystemSecurity - Provides a boolean indicating whether to put
        SeSecurityPrivilege into the output privilege set.

    WriteOwner - Provides a boolean indicating whether to put
        SeTakeOwnershipPrivilege into the output privilege set.

    Privileges - Supplies a pointer that will return the privilege
        set.  Should be freed with ExFreePool when no longer needed.

Return Value:

    None.

--*/
{
    PPRIVILEGE_SET PrivilegeSet;
    ULONG SizeRequired;

    PAGED_CODE();

    ASSERT( (PrivilegeCount != 0) && (PrivilegeCount <= 2) );

    if ( !ARGUMENT_PRESENT( Privileges ) ) {
        return;
    }

    if ( PrivilegeCount == 1 ) {

        SizeRequired = SinglePrivilegeSetSize;

        if ( SystemSecurity ) {

            PrivilegeSet = SepSystemSecurityPrivilegeSet;

        } else {

            ASSERT( WriteOwner );

            PrivilegeSet = SepTakeOwnershipPrivilegeSet;
        }

    } else {

        SizeRequired = DoublePrivilegeSetSize;
        PrivilegeSet = SepDoublePrivilegeSet;
    }

    *Privileges = ExAllocatePoolWithTag( PagedPool, SizeRequired, 'rPeS' );

    if ( *Privileges != NULL ) {

        RtlCopyMemory (
           *Privileges,
           PrivilegeSet,
           SizeRequired
           );
    }
}





BOOLEAN
SepInitializeWorkList(
    VOID
    )

/*++

Routine Description:

    Initializes the mutex and list head used to queue work from the
    Executive to LSA.  This mechanism operates on top of the normal ExWorkerThread
    mechanism by capturing the first thread to perform LSA work and keeping it
    until all the current work is done.

    The reduces the number of worker threads that are blocked on I/O to LSA.

Arguments:

    None.


Return Value:

    TRUE if successful, FALSE otherwise.

--*/

{
    PAGED_CODE();

    ExInitializeResourceLite(&SepLsaQueueLock);
    InitializeListHead(&SepLsaQueue);
    return( TRUE );
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\seclient.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    seclient.c

Abstract:

   This module implements routines providing client impersonation to
   communication session layers (such as LPC Ports).

        WARNING: The following notes apply to the use of these services:

        (1)  No synchronization of operations to a security context block are
             performed by these services.  The caller of these services must
             ensure that use of an individual security context block is
             serialized to prevent simultaneous, incompatible updates.

        (2)  Any or all of these services may create, open, or operate on a
             token object.  This may result in a mutex being acquired at
             MUTEXT_LEVEL_SE_TOKEN level.  The caller must ensure that no
             mutexes are held at levels that conflict with this action.

--*/

#include "pch.h"

#pragma hdrstop


#ifdef ALLOC_PRAGMA
NTSTATUS
SepCreateClientSecurity(
    IN PACCESS_TOKEN Token,
    IN PSECURITY_QUALITY_OF_SERVICE ClientSecurityQos,
    IN BOOLEAN ServerIsRemote,
    TOKEN_TYPE TokenType,
    BOOLEAN ThreadEffectiveOnly,
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    OUT PSECURITY_CLIENT_CONTEXT ClientContext
    );
#pragma alloc_text(PAGE,SepCreateClientSecurity)
#pragma alloc_text(PAGE,SeCreateClientSecurity)
#pragma alloc_text(PAGE,SeUpdateClientSecurity)
#pragma alloc_text(PAGE,SeImpersonateClient)
#pragma alloc_text(PAGE,SeImpersonateClientEx)
#pragma alloc_text(PAGE,SeCreateClientSecurityFromSubjectContext)
#endif


////////////////////////////////////////////////////////////////////////
//                                                                    //
//           Routines                                                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////


NTSTATUS
SepCreateClientSecurity(
    IN PACCESS_TOKEN Token,
    IN PSECURITY_QUALITY_OF_SERVICE ClientSecurityQos,
    IN BOOLEAN ServerIsRemote,
    TOKEN_TYPE TokenType,
    BOOLEAN ThreadEffectiveOnly,
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    OUT PSECURITY_CLIENT_CONTEXT ClientContext
    )

/*++

Routine Description

    This routine creates a context block to represent the passed token.  The token
    is expected to be properly referenced when passed to the function.  If the call 
    is unsuccessful, the caller is responsible to dereference the token.  Also, if the 
    call succeeds but the caller requested SECURITY_STATIC_TRACKING, then we have duplicated
    the token and the caller is again responsible to dereference the passed token.
    
Arguments

    Token - The effective token for which the context is constructed.
    
    ClientSecurityQos - Points to the security quality of service
        parameters specified by the client for this communication
        session.

    ServerIsRemote - Provides an indication as to whether the session
        this context block is being used for is an inter-system
        session or intra-system session.  This is reconciled with the
        impersonation level of the client thread's token (in case the
        client has a client of his own that didn't specify delegation).
    
   TokenType - specifies the type of the passed token.
   
   ThreadEffectiveOnly - if the token is an impersonation token, then this 
        is the thread's ImpersonationInfo->EffectiveOnly field value.
    
    ImpersonationLevel - the impersonation level of the token.
    
    ClientContext - Points to the client security context block to be
        initialized.
        
Return Value

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PACCESS_TOKEN DuplicateToken;

    PAGED_CODE();

    if ( !VALID_IMPERSONATION_LEVEL(ClientSecurityQos->ImpersonationLevel) ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure the client is not trying to abuse use of a
    // client of its own by attempting an invalid impersonation.
    // Also set the ClientContext->DirectAccessEffectiveOnly flag
    // appropriately if the impersonation is legitimate.  The
    // DirectAccessEffectiveOnly flag value will end up being ignored
    // if STATIC mode is requested, but this is the most efficient
    // place to calculate it, and we are optimizing for DYNAMIC mode.
    //

    if (TokenType == TokenImpersonation) {

        if ( ClientSecurityQos->ImpersonationLevel > ImpersonationLevel) {

            return STATUS_BAD_IMPERSONATION_LEVEL;
        }

        if ( SepBadImpersonationLevel(ImpersonationLevel,ServerIsRemote)) {

            return STATUS_BAD_IMPERSONATION_LEVEL;

        } else {

            //
            // TokenType is TokenImpersonation and the impersonation is legit.
            // Set the DirectAccessEffectiveOnly flag to be the minimum of
            // the current thread value and the caller specified value.
            //

            ClientContext->DirectAccessEffectiveOnly =
                ( (ThreadEffectiveOnly || (ClientSecurityQos->EffectiveOnly)) ?
                  TRUE : FALSE );
        }

    } else {

        //
        // TokenType is TokenPrimary.  In this case, the client specified
        // EffectiveOnly value is always used.
        //

        ClientContext->DirectAccessEffectiveOnly =
            ClientSecurityQos->EffectiveOnly;
    }

    //
    // Copy the token if necessary (i.e., static tracking requested)
    //

    if (ClientSecurityQos->ContextTrackingMode == SECURITY_STATIC_TRACKING) {

        ClientContext->DirectlyAccessClientToken = FALSE;

        Status = SeCopyClientToken(
                     Token,
                     ClientSecurityQos->ImpersonationLevel,
                     KernelMode,
                     &DuplicateToken
                     );

        Token = DuplicateToken;

        //
        // If there was an error, we're done.
        //
        if (!NT_SUCCESS(Status)) {
            return Status;
        }

    } else {

        ClientContext->DirectlyAccessClientToken = TRUE;

        if (ServerIsRemote) {
            //
            // Get a copy of the client token's control information
            // so that we can tell if it changes in the future.
            //

            SeGetTokenControlInformation( Token,
                                          &ClientContext->ClientTokenControl
                                          );

        }

    }

    ClientContext->SecurityQos.Length =
        (ULONG)sizeof(SECURITY_QUALITY_OF_SERVICE);

    ClientContext->SecurityQos.ImpersonationLevel =
        ClientSecurityQos->ImpersonationLevel;

    ClientContext->SecurityQos.ContextTrackingMode =
        ClientSecurityQos->ContextTrackingMode;

    ClientContext->SecurityQos.EffectiveOnly =
        ClientSecurityQos->EffectiveOnly;

    ClientContext->ServerIsRemote = ServerIsRemote;

    ClientContext->ClientToken = Token;

    return STATUS_SUCCESS;
}

NTSTATUS
SeCreateClientSecurity (
    __in PETHREAD ClientThread,
    __in PSECURITY_QUALITY_OF_SERVICE ClientSecurityQos,
    __in BOOLEAN ServerIsRemote,
    __out PSECURITY_CLIENT_CONTEXT ClientContext
    )

/*++

Routine Description:

    This service initializes a context block to represent a client's
    security context.  This may simply result in a reference to the
    client's token, or may cause the client's token to be duplicated,
    depending upon the security quality of service information specified.

                               NOTE

        The code in this routine is optimized for DYNAMIC context
        tracking.  This is only mode in which direct access to a
        caller's token is allowed, and the mode expected to be used
        most often.  STATIC context tracking always requires the
        caller's token to be copied.


Arguments:

    ClientThread - Points to the client's thread.  This is used to
        locate the client's security context (token).

    ClientSecurityQos - Points to the security quality of service
        parameters specified by the client for this communication
        session.

    ServerIsRemote - Provides an indication as to whether the session
        this context block is being used for is an inter-system
        session or intra-system session.  This is reconciled with the
        impersonation level of the client thread's token (in case the
        client has a client of his own that didn't specify delegation).

    ClientContext - Points to the client security context block to be
        initialized.


Return Value:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_BAD_IMPERSONATION_LEVEL - The client is currently
        impersonating either an Anonymous or Identification level
        token, which can not be passed on for use by another server.
        This status may also be returned if the security context
        block is for an inter-system communication session and the
        client thread is impersonating a client of its own using
        other than delegation impersonation level.


--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PACCESS_TOKEN Token;
    TOKEN_TYPE TokenType;
    BOOLEAN ThreadEffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    PACCESS_TOKEN DuplicateToken;

    PAGED_CODE();

    //
    // Gain access to the client thread's effective token
    //

    Token = PsReferenceEffectiveToken(
                ClientThread,
                &TokenType,
                &ThreadEffectiveOnly,
                &ImpersonationLevel
                );


    Status = SepCreateClientSecurity(
                Token,
                ClientSecurityQos,
                ServerIsRemote,
                TokenType,
                ThreadEffectiveOnly,
                ImpersonationLevel,
                ClientContext );

    //
    // If failed, or if a token was copied internally, then deref our token.
    //

    if ((!NT_SUCCESS( Status )) || (ClientSecurityQos->ContextTrackingMode == SECURITY_STATIC_TRACKING)) {

        ObDereferenceObject( Token );
    }

    return Status;
}




VOID
SeImpersonateClient(
    __in PSECURITY_CLIENT_CONTEXT ClientContext,
    __in_opt PETHREAD ServerThread
    )
/*++

Routine Description:

    This service is used to cause the calling thread to impersonate a
    client.  The client security context in ClientContext is assumed to
    be up to date.


Arguments:

    ClientContext - Points to client security context block.

    ServerThread - (Optional) Specifies the thread which is to be made to
        impersonate the client.  If not specified, the calling thread is
        used.


Return Value:

    None.


--*/


{

    PAGED_CODE();

#if DBG
    DbgPrint("SE:  Obsolete call:  SeImpersonateClient\n");
#endif

    (VOID) SeImpersonateClientEx( ClientContext, ServerThread );
}


NTSTATUS
SeImpersonateClientEx(
    __in PSECURITY_CLIENT_CONTEXT ClientContext,
    __in_opt PETHREAD ServerThread
    )
/*++

Routine Description:

    This service is used to cause the calling thread to impersonate a
    client.  The client security context in ClientContext is assumed to
    be up to date.


Arguments:

    ClientContext - Points to client security context block.

    ServerThread - (Optional) Specifies the thread which is to be made to
        impersonate the client.  If not specified, the calling thread is
        used.


Return Value:

    None.


--*/


{

    BOOLEAN EffectiveValueToUse;
    PETHREAD Thread;
    NTSTATUS Status ;

    PAGED_CODE();

    if (ClientContext->DirectlyAccessClientToken) {
        EffectiveValueToUse = ClientContext->DirectAccessEffectiveOnly;
    } else {
        EffectiveValueToUse = ClientContext->SecurityQos.EffectiveOnly;
    }



    //
    // if a ServerThread wasn't specified, then default to the current
    // thread.
    //

    if (!ARGUMENT_PRESENT(ServerThread)) {
        Thread = PsGetCurrentThread();
    } else {
        Thread = ServerThread;
    }



    //
    // Assign the context to the calling thread
    //

    Status = PsImpersonateClient( Thread,
                         ClientContext->ClientToken,
                         TRUE,
                         EffectiveValueToUse,
                         ClientContext->SecurityQos.ImpersonationLevel
                         );

    return Status ;

}


NTSTATUS
SeCreateClientSecurityFromSubjectContext (
    __in PSECURITY_SUBJECT_CONTEXT SubjectContext,
    __in PSECURITY_QUALITY_OF_SERVICE ClientSecurityQos,
    __in BOOLEAN ServerIsRemote,
    __out PSECURITY_CLIENT_CONTEXT ClientContext
    )                              
/*++

Routine Description:

    This service initializes a context block to represent a client's
    security context.  This may simply result in a reference to the
    client's token, or may cause the client's token to be duplicated,
    depending upon the security quality of service information specified.

                               NOTE

        The code in this routine is optimized for DYNAMIC context
        tracking.  This is only mode in which direct access to a
        caller's token is allowed, and the mode expected to be used
        most often.  STATIC context tracking always requires the
        caller's token to be copied.


Arguments:

    SubjectContext - Points to the SubjectContext that should serve
        as the basis for this client context.

    ClientSecurityQos - Points to the security quality of service
        parameters specified by the client for this communication
        session.

    ServerIsRemote - Provides an indication as to whether the session
        this context block is being used for is an inter-system
        session or intra-system session.  This is reconciled with the
        impersonation level of the client thread's token (in case the
        client has a client of his own that didn't specify delegation).

    ClientContext - Points to the client security context block to be
        initialized.


Return Value:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_BAD_IMPERSONATION_LEVEL - The client is currently
        impersonating either an Anonymous or Identification level
        token, which can not be passed on for use by another server.
        This status may also be returned if the security context
        block is for an inter-system communication session and the
        client thread is impersonating a client of its own using
        other than delegation impersonation level.


--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PACCESS_TOKEN Token;
    TOKEN_TYPE Type;
    BOOLEAN ThreadEffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    PACCESS_TOKEN DuplicateToken;

    PAGED_CODE();

    Token = SeQuerySubjectContextToken(
                SubjectContext
                );

    ObReferenceObject( Token );

    if ( SubjectContext->ClientToken )
    {
        Type = TokenImpersonation ;
    }
    else 
    {
        Type = TokenPrimary ;
    }

    Status = SepCreateClientSecurity(
                Token,
                ClientSecurityQos,
                ServerIsRemote,
                Type,
                FALSE,
                SubjectContext->ImpersonationLevel,
                ClientContext
                );

    //
    // If failed, or if a token was copied internally, then deref our token.
    //

    if ((!NT_SUCCESS( Status )) || (ClientSecurityQos->ContextTrackingMode == SECURITY_STATIC_TRACKING)) {
        ObDereferenceObject( Token );
    }
    
    return Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\seinit.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    seinit.c

Abstract:

    Executive security components Initialization.

--*/

#include "pch.h"

#pragma hdrstop

#include "adt.h"
#include <string.h>

//
// Security Database Constants
//

#define SEP_INITIAL_KEY_COUNT 15
#define SEP_INITIAL_LEVEL_COUNT 6L

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,SeInitSystem)
#pragma alloc_text(INIT,SepInitializationPhase0)
#pragma alloc_text(INIT,SepInitializationPhase1)
#endif

BOOLEAN
SeInitSystem( VOID )

/*++

Routine Description:

    Perform security related system initialization functions.

Arguments:

    None.

Return Value:

    TRUE - Initialization succeeded.

    FALSE - Initialization failed.

--*/

{
    PAGED_CODE();

    switch ( InitializationPhase ) {

    case 0 :
        return SepInitializationPhase0();
    case 1 :
        return SepInitializationPhase1();
    default:
        KeBugCheckEx(UNEXPECTED_INITIALIZATION_CALL, 0, InitializationPhase, 0, 0);
    }
}

VOID
SepInitProcessAuditSd( VOID );


BOOLEAN
SepInitializationPhase0( VOID )

/*++

Routine Description:

    Perform phase 0 security initialization.

    This includes:

        - Initialize LUID allocation
        - Initialize security global variables
        - initialize the token object.
        - Initialize the necessary security components of the boot thread/process


Arguments:

    None.

Return Value:

    TRUE - Initialization was successful.

    FALSE - Initialization Failed.

--*/

{

    PAGED_CODE();

    //
    //  LUID allocation services are needed by security prior to phase 0
    //  Executive initialization.  So, LUID initialization is performed
    //  here
    //

    if (ExLuidInitialization() == FALSE) {
        KdPrint(("Security: Locally Unique ID initialization failed.\n"));
        return FALSE;
    }

    //
    // Initialize security global variables
    //

    if (!SepVariableInitialization()) {
        KdPrint(("Security: Global variable initialization failed.\n"));
        return FALSE;
    }

    //
    // Perform Phase 0 Reference Monitor Initialization.
    //

    if (!SepRmInitPhase0()) {
        KdPrint(("Security: Ref Mon state initialization failed.\n"));
        return FALSE;
    }

    //
    // Initialize the token object type.
    //

    if (!SepTokenInitialization()) {
        KdPrint(("Security: Token object initialization failed.\n"));
        return FALSE;
    }

//    //
//    // Initialize auditing structures
//    //
//
//    if (!SepAdtInitializePhase0()) {
//        KdPrint(("Security: Auditing initialization failed.\n"));
//        return FALSE;
//    }
//
    //
    // Initialize SpinLock and list for the LSA worker thread
    //

    //
    // Initialize the work queue spinlock, list head, and semaphore
    // for each of the work queues.
    //

    if (!SepInitializeWorkList()) {
        KdPrint(("Security: Unable to initialize work queue\n"));
        return FALSE;
    }

    //
    // Initialize the security fields of the boot thread.
    //
    PsGetCurrentThread()->ImpersonationInfo = NULL;
    PS_CLEAR_BITS (&PsGetCurrentThread()->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_IMPERSONATING);
    ObInitializeFastReference (&PsGetCurrentProcess()->Token, NULL);

    ObInitializeFastReference (&PsGetCurrentProcess()->Token, SeMakeSystemToken());

    return ( !ExFastRefObjectNull (PsGetCurrentProcess()->Token) );
}


BOOLEAN
SepInitializationPhase1( VOID )

/*++

Routine Description:

    Perform phase 1 security initialization.

    This includes:

        - Create an object directory for security related objects.
          (\Security).

        - Create an event to be signaled after the LSA has initialized.
          (\Security\LSA_Initialized)




Arguments:

    None.

Return Value:

    TRUE - Initialization was successful.

    FALSE - Initialization Failed.

--*/

{

    NTSTATUS Status;
    STRING Name;
    UNICODE_STRING UnicodeName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE SecurityRoot, TemporaryHandle;
    PSECURITY_DESCRIPTOR SD ;
    UCHAR SDBuffer[ SECURITY_DESCRIPTOR_MIN_LENGTH ];
    PACL Dacl ;

    PAGED_CODE();

    //
    // Insert the system token
    //

    Status = ObInsertObject( ExFastRefGetObject (PsGetCurrentProcess()->Token),
                             NULL,
                             0,
                             0,
                             NULL,
                             NULL );

    ASSERT( NT_SUCCESS(Status) );

    SeAnonymousLogonToken = SeMakeAnonymousLogonToken();
    ASSERT(SeAnonymousLogonToken != NULL);

    SeAnonymousLogonTokenNoEveryone = SeMakeAnonymousLogonTokenNoEveryone();
    ASSERT(SeAnonymousLogonTokenNoEveryone != NULL);

    //
    // Create the security object directory.
    //

    RtlInitString( &Name, "\\Security" );
    Status = RtlAnsiStringToUnicodeString(
                 &UnicodeName,
                 &Name,
                 TRUE );
    ASSERT( NT_SUCCESS(Status) );

    //
    // Build up the security descriptor
    //

    SD = (PSECURITY_DESCRIPTOR) SDBuffer ;

    RtlCreateSecurityDescriptor( SD,
                                 SECURITY_DESCRIPTOR_REVISION );

    Dacl = ExAllocatePool(
                NonPagedPool,
                256 );

    if ( !Dacl )
    {
        return FALSE ;
    }

    Status = RtlCreateAcl( Dacl, 256, ACL_REVISION );

    ASSERT( NT_SUCCESS(Status) );
    
    Status = RtlAddAccessAllowedAce( Dacl,
                                     ACL_REVISION,
                                     DIRECTORY_ALL_ACCESS,
                                     SeLocalSystemSid );

    ASSERT( NT_SUCCESS(Status) );
    
    Status = RtlAddAccessAllowedAce( Dacl,
                                     ACL_REVISION,
                                     DIRECTORY_QUERY | DIRECTORY_TRAVERSE |
                                         READ_CONTROL,
                                     SeAliasAdminsSid );

    ASSERT( NT_SUCCESS(Status) );
    
    Status = RtlAddAccessAllowedAce( Dacl,
                                     ACL_REVISION,
                                     DIRECTORY_TRAVERSE,
                                     SeWorldSid );

    ASSERT( NT_SUCCESS(Status) );
    
    Status = RtlSetDaclSecurityDescriptor(
                                     SD,
                                     TRUE,
                                     Dacl,
                                     FALSE );

    ASSERT( NT_SUCCESS(Status) );
    
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeName,
        (OBJ_PERMANENT | OBJ_CASE_INSENSITIVE),
        NULL,
        SD
        );

    Status = NtCreateDirectoryObject(
                 &SecurityRoot,
                 DIRECTORY_ALL_ACCESS,
                 &ObjectAttributes
                 );

    RtlFreeUnicodeString( &UnicodeName );
    ASSERTMSG("Security root object directory creation failed.",NT_SUCCESS(Status));

    ExFreePool( Dacl );

    //
    // Create an event in the security directory
    //

    RtlInitString( &Name, "LSA_AUTHENTICATION_INITIALIZED" );
    Status = RtlAnsiStringToUnicodeString(
                 &UnicodeName,
                 &Name,
                 TRUE );  
    
    ASSERT( NT_SUCCESS(Status) );
    
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeName,
        (OBJ_PERMANENT | OBJ_CASE_INSENSITIVE),
        SecurityRoot,
        SePublicDefaultSd
        );

    Status = NtCreateEvent(
                 &TemporaryHandle,
                 GENERIC_WRITE,
                 &ObjectAttributes,
                 NotificationEvent,
                 FALSE
                 );
    RtlFreeUnicodeString( &UnicodeName );
    ASSERTMSG("LSA Initialization Event Creation Failed.",NT_SUCCESS(Status));

    Status = NtClose( SecurityRoot );
    ASSERTMSG("Security object directory handle closure Failed.",NT_SUCCESS(Status));
    Status = NtClose( TemporaryHandle );
    ASSERTMSG("LSA Initialization Event handle closure Failed.",NT_SUCCESS(Status));

    //
    // Initialize the default SACL to use for auditing
    // accesses to system processes. This initializes SepProcessSacl
    //

    SepInitProcessAuditSd();
    
#ifndef SETEST

    return TRUE;

#else

    return SepDevelopmentTest();

#endif  //SETEST
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\sep.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Sep.c

Abstract:

    This Module implements the private security routine that are defined
    in sep.h

--*/

#include "pch.h"

#pragma hdrstop


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SepCheckAcl)
#endif



BOOLEAN
SepCheckAcl (
    IN PACL Acl,
    IN ULONG Length
    )

/*++

Routine Description:

    This is a private routine that checks that an acl is well formed.

Arguments:

    Acl - Supplies the acl to check

    Length - Supplies the real size of the acl.  The internal acl size
        must agree.

Return Value:

    BOOLEAN - TRUE if the acl is well formed and FALSE otherwise

--*/
{
    if ((Length < sizeof(ACL)) || (Length != Acl->AclSize)) {
        return FALSE;
    }
    return RtlValidAcl( Acl );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\semethod.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Semethod.c

Abstract:

    This Module implements the SeDefaultObjectMethod procedure.  This
    procedure and SeAssignSecurity are the only two procedures that will
    place a security descriptor on an object.  Therefore they must understand
    and agree on how a descriptor is allocated from pool so that they can
    deallocate and reallocate pool as necessary. Any security descriptor
    that is attached to an object by these procedures has the following
    pool allocation plan.

    1. if the objects security descriptor is null then there is no pool
       allocated

    2. otherwise there is at least one pool allocation for the security
       descriptor header.  if its ACL fields are null then there are no
       other pool allocations (this should never happen).

    3. There is a separate pool allocation for each ACL in the descriptor.
       So a maximum of three pool allocations can occur for each attached
       security descriptor.

    4  Everytime an acl is replace in a descriptor we see if we can use
       the old ACL and if so then we try and keep the ACL size as large
       as possible.

    Note that this is different from the algorithm used to capture
    a security descriptor (which puts everything in one pool allocation).
    Also note that this can be easily optimized at a later time (if necessary)
    to use only one allocation.



--*/

#include "pch.h"

#pragma hdrstop


NTSTATUS
SepDefaultDeleteMethod (
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor
    );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SeSetSecurityAccessMask)
#pragma alloc_text(PAGE,SeQuerySecurityAccessMask)
#pragma alloc_text(PAGE,SeDefaultObjectMethod)
#pragma alloc_text(PAGE,SeSetSecurityDescriptorInfo)
#pragma alloc_text(PAGE,SeSetSecurityDescriptorInfoEx)
#pragma alloc_text(PAGE,SeQuerySecurityDescriptorInfo)
#pragma alloc_text(PAGE,SepDefaultDeleteMethod)
#endif




VOID
SeSetSecurityAccessMask(
    __in SECURITY_INFORMATION SecurityInformation,
    __out PACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine builds an access mask representing the accesses necessary
    to set the object security information specified in the SecurityInformation
    parameter.  While it is not difficult to determine this information,
    the use of a single routine to generate it will ensure minimal impact
    when the security information associated with an object is extended in
    the future (to include mandatory access control information).

Arguments:

    SecurityInformation - Identifies the object's security information to be
        modified.

    DesiredAccess - Points to an access mask to be set to represent the
        accesses necessary to modify the information specified in the
        SecurityInformation parameter.

Return Value:

    None.

--*/

{

    PAGED_CODE();

    //
    // Figure out accesses needed to perform the indicated operation(s).
    //

    (*DesiredAccess) = 0;

    if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
        (SecurityInformation & GROUP_SECURITY_INFORMATION)   ) {
        (*DesiredAccess) |= WRITE_OWNER;
    }

    if (SecurityInformation & DACL_SECURITY_INFORMATION) {
        (*DesiredAccess) |= WRITE_DAC;
    }

    if (SecurityInformation & SACL_SECURITY_INFORMATION) {
        (*DesiredAccess) |= ACCESS_SYSTEM_SECURITY;
    }

    return;

}


VOID
SeQuerySecurityAccessMask(
    __in SECURITY_INFORMATION SecurityInformation,
    __out PACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine builds an access mask representing the accesses necessary
    to query the object security information specified in the
    SecurityInformation parameter.  While it is not difficult to determine
    this information, the use of a single routine to generate it will ensure
    minimal impact when the security information associated with an object is
    extended in the future (to include mandatory access control information).

Arguments:

    SecurityInformation - Identifies the object's security information to be
        queried.

    DesiredAccess - Points to an access mask to be set to represent the
        accesses necessary to query the information specified in the
        SecurityInformation parameter.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // Figure out accesses needed to perform the indicated operation(s).
    //

    (*DesiredAccess) = 0;

    if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
        (SecurityInformation & GROUP_SECURITY_INFORMATION) ||
        (SecurityInformation & DACL_SECURITY_INFORMATION)) {
        (*DesiredAccess) |= READ_CONTROL;
    }

    if ((SecurityInformation & SACL_SECURITY_INFORMATION)) {
        (*DesiredAccess) |= ACCESS_SYSTEM_SECURITY;
    }

    return;

}



NTSTATUS
SeDefaultObjectMethod (
    __in PVOID Object,
    __in SECURITY_OPERATION_CODE OperationCode,
    __in PSECURITY_INFORMATION SecurityInformation,
    __inout PSECURITY_DESCRIPTOR SecurityDescriptor,
    __inout_opt PULONG CapturedLength,
    __deref_inout PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    __in POOL_TYPE PoolType,
    __in PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    This is the default security method for objects.  It is responsible
    for either retrieving, setting, and deleting the security descriptor of
    an object.  It is not used to assign the original security descriptor
    to an object (use SeAssignSecurity for that purpose).


    IT IS ASSUMED THAT THE OBJECT MANAGER HAS ALREADY DONE THE ACCESS
    VALIDATIONS NECESSARY TO ALLOW THE REQUESTED OPERATIONS TO BE PERFORMED.

Arguments:

    Object - Supplies a pointer to the object being used.

    OperationCode - Indicates if the operation is for setting, querying, or
        deleting the object's security descriptor.

    SecurityInformation - Indicates which security information is being
        queried or set.  This argument is ignored for the delete operation.

    SecurityDescriptor - The meaning of this parameter depends on the
        OperationCode:

        QuerySecurityDescriptor - For the query operation this supplies the
            buffer to copy the descriptor into.  The security descriptor is
            assumed to have been probed up to the size passed in in Length.
            Since it still points into user space, it must always be
            accessed in a try clause in case it should suddenly disappear.

        SetSecurityDescriptor - For a set operation this supplies the
            security descriptor to copy into the object.  The security
            descriptor must be captured before this routine is called.

        DeleteSecurityDescriptor - It is ignored when deleting a security
            descriptor.

        AssignSecurityDescriptor - For assign operations this is the
            security descriptor that will be assigned to the object.
            It is assumed to be in kernel space, and is therefore not
            probed or captured.

    CapturedLength - For the query operation this specifies the length, in
        bytes, of the security descriptor buffer, and upon return contains
        the number of bytes needed to store the descriptor.  If the length
        needed is greater than the length supplied the operation will fail.
        It is ignored in the set and delete operation.

        This parameter is assumed to be captured and probed as appropriate.

    ObjectsSecurityDescriptor - For the Set operation this supplies the address
        of a pointer to the object's current security descriptor.  This routine
        will either modify the security descriptor in place or allocate a new
        security descriptor and use this variable to indicate its new location.
        For the query operation it simply supplies the security descriptor
        being queried.  The caller is responsible for freeing the old security
        descriptor.

    PoolType - For the set operation this specifies the pool type to use if
        a new security descriptor needs to be allocated.  It is ignored
        in the query and delete operation.

        the mapping of generic to specific/standard access types for the object
        being accessed.  This mapping structure is expected to be safe to
        access (i.e., captured if necessary) prior to be passed to this routine.

Return Value:

    NTSTATUS - STATUS_SUCCESS if the operation is successful and an
        appropriate error status otherwise.

--*/

{
    PAGED_CODE();

    //
    // If the object's security descriptor is null, then object is not
    // one that has security information associated with it.  Return
    // an error.
    //

    //
    //  Make sure the common parts of our input are proper
    //

    ASSERT( (OperationCode == SetSecurityDescriptor) ||
            (OperationCode == QuerySecurityDescriptor) ||
            (OperationCode == AssignSecurityDescriptor) ||
            (OperationCode == DeleteSecurityDescriptor) );

    //
    //  This routine simply cases off of the operation code to decide
    //  which support routine to call
    //

    switch (OperationCode) {

    case SetSecurityDescriptor:

        ASSERT( (PoolType == PagedPool) || (PoolType == NonPagedPool) );

        return ObSetSecurityDescriptorInfo( Object,
                                            SecurityInformation,
                                            SecurityDescriptor,
                                            ObjectsSecurityDescriptor,
                                            PoolType,
                                            GenericMapping
                                            );



    case QuerySecurityDescriptor:

        //
        //  check the rest of our input and call the default query security
        //  method
        //

        ASSERT( CapturedLength != NULL );

        return ObQuerySecurityDescriptorInfo( Object,
                                              SecurityInformation,
                                              SecurityDescriptor,
                                              CapturedLength,
                                              ObjectsSecurityDescriptor );

    case DeleteSecurityDescriptor:

        //
        //  call the default delete security method
        //

        return SepDefaultDeleteMethod( ObjectsSecurityDescriptor );

    case AssignSecurityDescriptor:

        ObAssignObjectSecurityDescriptor( Object, SecurityDescriptor, PoolType );
        return( STATUS_SUCCESS );

    default:

        //
        //  Bugcheck on any other operation code,  We won't get here if
        //  the earlier asserts are still checked.
        //

        KeBugCheckEx( SECURITY_SYSTEM, 0, STATUS_INVALID_PARAMETER, 0, 0 );
    }

}




NTSTATUS
SeSetSecurityDescriptorInfo (
    __in_opt PVOID Object,
    __in PSECURITY_INFORMATION SecurityInformation,
    __in PSECURITY_DESCRIPTOR ModificationDescriptor,
    __inout PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    __in POOL_TYPE PoolType,
    __in PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    This routine will set an object's security descriptor.  The input
    security descriptor must be previously captured.

Arguments:

    Object - Optionally supplies the object whose security is
        being adjusted.  This is used to update security quota
        information.

    SecurityInformation - Indicates which security information is
        to be applied to the object.  The value(s) to be assigned are
        passed in the SecurityDescriptor parameter.

    ModificationDescriptor - Supplies the input security descriptor to be
        applied to the object.  The caller of this routine is expected
        to probe and capture the passed security descriptor before calling
        and release it after calling.

    ObjectsSecurityDescriptor - Supplies the address of a pointer to
        the objects security descriptor that is going to be altered by
        this procedure.  This structure must be deallocated by the caller.

    PoolType - Specifies the type of pool to allocate for the objects
        security descriptor.

    GenericMapping - This argument provides the mapping of generic to
        specific/standard access types for the object being accessed.
        This mapping structure is expected to be safe to access
        (i.e., captured if necessary) prior to be passed to this routine.

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        value otherwise.

--*/

{



    //
    // Make sure the object already has a security descriptor.
    // Objects that 'may' have security descriptors 'must' have security
    // descriptors.  If this one doesn't already have one, then we can't
    // assign one to it.
    //

    if ((*ObjectsSecurityDescriptor) == NULL) {
        return(STATUS_NO_SECURITY_ON_OBJECT);
    }


    //
    // Pass this call to the common Rtlp routine.
    //

    return RtlpSetSecurityObject (
                    Object,
                    *SecurityInformation,
                    ModificationDescriptor,
                    ObjectsSecurityDescriptor,
                    0,  // No Auto Inheritance
                    PoolType,
                    GenericMapping,
                    NULL ); // No Token


}




NTSTATUS
SeSetSecurityDescriptorInfoEx (
    __in_opt PVOID Object,
    __in PSECURITY_INFORMATION SecurityInformation,
    __in PSECURITY_DESCRIPTOR ModificationDescriptor,
    __inout PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    __in ULONG AutoInheritFlags,
    __in POOL_TYPE PoolType,
    __in PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    This routine will set an object's security descriptor.  The input
    security descriptor must be previously captured.

Arguments:

    Object - Optionally supplies the object whose security is
        being adjusted.  This is used to update security quota
        information.

    SecurityInformation - Indicates which security information is
        to be applied to the object.  The value(s) to be assigned are
        passed in the SecurityDescriptor parameter.

    ModificationDescriptor - Supplies the input security descriptor to be
        applied to the object.  The caller of this routine is expected
        to probe and capture the passed security descriptor before calling
        and release it after calling.

    ObjectsSecurityDescriptor - Supplies the address of a pointer to
        the objects security descriptor that is going to be altered by
        this procedure.  This structure must be deallocated by the caller.

    AutoInheritFlags - Controls automatic inheritance of ACES.
        Valid values are a bits mask of the logical OR of
        one or more of the following bits:

        SEF_DACL_AUTO_INHERIT - If set, inherited ACEs from the
            DACL in the ObjectsSecurityDescriptor are preserved and inherited ACEs from
            the ModificationDescriptor are ignored. Inherited ACEs are not supposed
            to be modified; so preserving them across this call is appropriate.
            If a protected server does not itself implement auto inheritance, it should
            not set this bit.  The caller of the protected server may implement
            auto inheritance and my indeed be modifying inherited ACEs.

        SEF_SACL_AUTO_INHERIT - If set, inherited ACEs from the
            SACL in the ObjectsSecurityDescriptor are preserved and inherited ACEs from
            the ModificationDescriptor are ignored. Inherited ACEs are not supposed
            to be modified; so preserving them across this call is appropriate.
            If a protected server does not itself implement auto inheritance, it should
            not set this bit.  The caller of the protected server may implement
            auto inheritance and my indeed be modifying inherited ACEs.

    PoolType - Specifies the type of pool to allocate for the objects
        security descriptor.

    GenericMapping - This argument provides the mapping of generic to
        specific/standard access types for the object being accessed.
        This mapping structure is expected to be safe to access
        (i.e., captured if necessary) prior to be passed to this routine.

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        value otherwise.

--*/

{

    PAGED_CODE();


    //
    // Make sure the object already has a security descriptor.
    // Objects that 'may' have security descriptors 'must' have security
    // descriptors.  If this one doesn't already have one, then we can't
    // assign one to it.
    //

    if ((*ObjectsSecurityDescriptor) == NULL) {
        return(STATUS_NO_SECURITY_ON_OBJECT);
    }


    //
    // Pass this call to the common Rtlp routine.
    //

    return RtlpSetSecurityObject (
                    Object,
                    *SecurityInformation,
                    ModificationDescriptor,
                    ObjectsSecurityDescriptor,
                    AutoInheritFlags,
                    PoolType,
                    GenericMapping,
                    NULL ); // No Token


}



NTSTATUS
SeQuerySecurityDescriptorInfo (
    __in PSECURITY_INFORMATION SecurityInformation,
    __out_bcount(*Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
    __inout PULONG Length,
    __deref_inout PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor
    )

/*++

Routine Description:

    This routine will extract the desired information from the
    passed security descriptor and return the information in
    the passed buffer as a security descriptor in self-relative
    format.

Arguments:

    SecurityInformation - Specifies what information is being queried.

    SecurityDescriptor - Supplies the buffer to output the requested
        information into.

        This buffer has been probed only to the size indicated by
        the Length parameter.  Since it still points into user space,
        it must always be accessed in a try clause.

    Length - Supplies the address of a variable containing the length of
        the security descriptor buffer.  Upon return this variable will
        contain the length needed to store the requested information.

    ObjectsSecurityDescriptor - Supplies the address of a pointer to
        the objects security descriptor.  The passed security descriptor
        must be in self-relative format.

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error value
        otherwise

--*/

{
    ULONG BufferLength;

    ULONG Size;
    ULONG OwnerLength=0;
    ULONG GroupLength=0;
    ULONG DaclLength=0;
    ULONG SaclLength=0;
    PUCHAR NextFree;
    SECURITY_DESCRIPTOR IObjectSecurity;

    //
    // Note that IObjectSecurity is not a pointer to a pointer
    // like ObjectsSecurityDescriptor is.
    //

    SECURITY_DESCRIPTOR_RELATIVE *ISecurityDescriptor = SecurityDescriptor;

    PAGED_CODE();

    //
    //  We will be accessing user memory throughout this routine,
    //  therefore do everything in a try-except clause.
    //

    try {

        BufferLength = *Length;

        //
        //  Check if the object's descriptor is null, and if it is then
        //  we only need to return a blank security descriptor record
        //

        if (*ObjectsSecurityDescriptor == NULL) {

            *Length = sizeof(SECURITY_DESCRIPTOR_RELATIVE);

            //
            //  Now make sure it's large enough for the security descriptor
            //  record
            //

            if (BufferLength < sizeof(SECURITY_DESCRIPTOR_RELATIVE)) {

                return STATUS_BUFFER_TOO_SMALL;

            }

            //
            //  It's large enough to make a blank security descriptor record
            //
            //  Note that this parameter has been probed for write by the
            //  object manager, however, we still have to be careful when
            //  writing to it.
            //

            //
            // We do not have to probe this here, because the object
            // manager has probed it for length=BufferLength, which we
            // know at this point is at least as large as a security
            // descriptor.
            //

            RtlCreateSecurityDescriptorRelative( SecurityDescriptor,
                                                 SECURITY_DESCRIPTOR_REVISION );

            //
            // Mark it as self-relative
            //

            RtlpSetControlBits( ISecurityDescriptor, SE_SELF_RELATIVE );

            //
            //  And return to our caller
            //

            return STATUS_SUCCESS;

        }

        //
        // Create an absolute format SD on the stack pointing into
        // user space to simplify the following code
        //

        RtlCopyMemory( (&IObjectSecurity),
                      *ObjectsSecurityDescriptor,
                      sizeof(SECURITY_DESCRIPTOR_RELATIVE) );

        IObjectSecurity.Owner = RtlpOwnerAddrSecurityDescriptor(
                    (SECURITY_DESCRIPTOR *) *ObjectsSecurityDescriptor );
        IObjectSecurity.Group = RtlpGroupAddrSecurityDescriptor(
                    (SECURITY_DESCRIPTOR *) *ObjectsSecurityDescriptor );
        IObjectSecurity.Dacl = RtlpDaclAddrSecurityDescriptor(
                    (SECURITY_DESCRIPTOR *) *ObjectsSecurityDescriptor );
        IObjectSecurity.Sacl = RtlpSaclAddrSecurityDescriptor(
                    (SECURITY_DESCRIPTOR *) *ObjectsSecurityDescriptor );

        IObjectSecurity.Control &= ~SE_SELF_RELATIVE;

        //
        //  This is not a blank descriptor so we need to determine the size
        //  needed to store the requested information.  It is the size of the
        //  descriptor record plus the size of each requested component.
        //

        Size = sizeof(SECURITY_DESCRIPTOR_RELATIVE);

        if ( (((*SecurityInformation) & OWNER_SECURITY_INFORMATION)) &&
             (IObjectSecurity.Owner != NULL) ) {

            OwnerLength = SeLengthSid( IObjectSecurity.Owner );
            Size += (ULONG)LongAlignSize(OwnerLength);

        }

        if ( (((*SecurityInformation) & GROUP_SECURITY_INFORMATION)) &&
             (IObjectSecurity.Group != NULL) ) {

            GroupLength = SeLengthSid( IObjectSecurity.Group );
            Size += (ULONG)LongAlignSize(GroupLength);

        }

        if ( (((*SecurityInformation) & DACL_SECURITY_INFORMATION)) &&
             (IObjectSecurity.Control & SE_DACL_PRESENT) &&
             (IObjectSecurity.Dacl != NULL) ) {


            DaclLength = (ULONG)LongAlignSize((IObjectSecurity.Dacl)->AclSize);
            Size += DaclLength;

        }

        if ( (((*SecurityInformation) & SACL_SECURITY_INFORMATION)) &&
             (IObjectSecurity.Control & SE_SACL_PRESENT) &&
             (IObjectSecurity.Sacl != NULL) ) {

            SaclLength = (ULONG)LongAlignSize((IObjectSecurity.Sacl)->AclSize);
            Size += SaclLength;

        }

        //
        //  Tell the caller how much space this will require
        //  (whether we actually fit or not)
        //

        *Length = Size;

        //
        //  Now make sure the size is less than or equal to the length
        //  we were passed
        //

        if (Size > BufferLength) {

            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        //  The length is fine.
        //
        //  Fill in the length and flags part of the security descriptor.
        //  The real addresses of each acl will be filled in later when we
        //  copy the ACLs over.
        //
        //  Note that we only set a flag in the descriptor if the information
        //  was requested, which is a simple copy of the requested information
        //  input variable
        //
        //  The output buffer has already been probed to the passed size,
        //  so we can just write to it.
        //

        RtlCreateSecurityDescriptorRelative( SecurityDescriptor,
                                             SECURITY_DESCRIPTOR_REVISION );

        //
        // Mark the returned Security Descriptor as being in
        // self-relative format
        //

        RtlpSetControlBits( ISecurityDescriptor, SE_SELF_RELATIVE );

        //
        //  NextFree is used to point to the next free spot in the
        //  returned security descriptor.
        //

        NextFree = LongAlignPtr((PUCHAR)SecurityDescriptor +
                                        sizeof(SECURITY_DESCRIPTOR_RELATIVE));

        //
        //  Copy the Owner SID if necessary and update the NextFree pointer,
        //  keeping it longword aligned.
        //

        if ( ((*SecurityInformation) & OWNER_SECURITY_INFORMATION) &&
             ((IObjectSecurity.Owner) != NULL) ) {

                RtlMoveMemory( NextFree,
                               IObjectSecurity.Owner,
                               OwnerLength );

                ISecurityDescriptor->Owner = (ULONG)((PUCHAR)NextFree - (PUCHAR)SecurityDescriptor);

                RtlpPropagateControlBits(
                    ISecurityDescriptor,
                    &IObjectSecurity,
                    SE_OWNER_DEFAULTED
                    );

                NextFree += (ULONG)LongAlignSize(OwnerLength);

        }


        //
        //  Copy the Group SID if necessary and update the NextFree pointer,
        //  keeping it longword aligned.
        //

        if ( ((*SecurityInformation) & GROUP_SECURITY_INFORMATION) &&
             (IObjectSecurity.Group != NULL) ) {

                RtlMoveMemory( NextFree,
                               IObjectSecurity.Group,
                               GroupLength );

                ISecurityDescriptor->Group = (ULONG)((PUCHAR)NextFree - (PUCHAR)SecurityDescriptor);

                RtlpPropagateControlBits(
                    ISecurityDescriptor,
                    &IObjectSecurity,
                    SE_GROUP_DEFAULTED
                    );

                NextFree += (ULONG)LongAlignSize(GroupLength);

        }


        //
        //  Set discretionary acl information if requested.
        //  If not set in object's security,
        //  then everything is already set properly.
        //

        if ( (*SecurityInformation) & DACL_SECURITY_INFORMATION) {

            RtlpPropagateControlBits(
                ISecurityDescriptor,
                &IObjectSecurity,
                SE_DACL_PRESENT | SE_DACL_DEFAULTED | SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED
                );

            //
            // Copy the acl if non-null  and update the NextFree pointer,
            // keeping it longword aligned.
            //

            if ( (IObjectSecurity.Control & SE_DACL_PRESENT) != 0 &&
                 IObjectSecurity.Dacl != NULL) {

                RtlMoveMemory( NextFree,
                               IObjectSecurity.Dacl,
                               (IObjectSecurity.Dacl)->AclSize );

                ISecurityDescriptor->Dacl = (ULONG)((PUCHAR)NextFree - (PUCHAR)SecurityDescriptor);

                NextFree += DaclLength;

            }
        }


        //
        //  Set system acl information if requested.
        //  If not set in object's security,
        //  then everything is already set properly.
        //

        if ( (*SecurityInformation) & SACL_SECURITY_INFORMATION) {

            RtlpPropagateControlBits(
                ISecurityDescriptor,
                &IObjectSecurity,
                SE_SACL_PRESENT | SE_SACL_DEFAULTED | SE_SACL_PROTECTED | SE_SACL_AUTO_INHERITED
                );

            //
            // Copy the acl if non-null  and update the NextFree pointer,
            // keeping it longword aligned.
            //
            if ( (IObjectSecurity.Control & SE_SACL_PRESENT) != 0 &&
                 IObjectSecurity.Sacl != NULL) {

                RtlMoveMemory( NextFree,
                               IObjectSecurity.Sacl,
                               (IObjectSecurity.Sacl)->AclSize );

                ISecurityDescriptor->Sacl = (ULONG)((PUCHAR)NextFree - (PUCHAR)SecurityDescriptor);

            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        return(GetExceptionCode());
    }

    return STATUS_SUCCESS;

}


NTSTATUS
SepDefaultDeleteMethod (
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor
    )

/*++

Routine Description:

    This is a private procedure to delete the security descriptor for
    an object.  It cleans up any pool allocations that have occured
    as part of the descriptor.

Arguments:

    ObjectsSecurityDescriptor - Supplies the address of a pointer
        to the security descriptor being deleted.

Return Value:

    NTSTATUS - STATUS_SUCCESS

--*/

{
    PAGED_CODE();

    return (ObDeassignSecurity ( ObjectsSecurityDescriptor ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\sep.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    sep.h

Abstract:

    This module contains the internal (private) declarations needed by the
    Kernel mode security routines.

--*/

#ifndef _SEP_
#define _SEP_

#include "ntos.h"
#include <ntrmlsa.h>
#include "seopaque.h"



/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                SE Diagnostics                                       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////



#if DBG
#define SE_DIAGNOSTICS_ENABLED 1
#endif // DBG


//
// These definitions are useful diagnostics aids
//

#if SE_DIAGNOSTICS_ENABLED

//
// Test for enabled diagnostic
//

#define IF_SE_GLOBAL( FlagName ) \
    if (SeGlobalFlag & (SE_DIAG_##FlagName))

//
// Diagnostics print statement
//

#define SeDiagPrint( FlagName, _Text_ )                               \
    IF_SE_GLOBAL( FlagName )                                          \
        DbgPrint _Text_


#else

//
// diagnostics not enabled - No diagnostics included in build
//


//
// Test for diagnostics enabled
//

#define IF_SE_GLOBAL( FlagName ) if (FALSE)

//
// Diagnostics print statement (expands to no-op)
//

#define SeDiagPrint( FlagName, _Text_ )     ;

#endif // SE_DIAGNOSTICS_ENABLED




//
// The following flags enable or disable various diagnostic
// capabilities within SE code.  These flags are set in
// SeGlobalFlag (only available within a DBG system).
//
//      SD_TRACKING - Display information about create/deletion of
//          shared security descriptors
//
//

#define SE_DIAG_SD_TRACKING          ((ULONG) 0x00000001L)





//
// Control flag manipulation macros
//

//
//  Macro to query whether or not control flags ALL on
//  or not (ie, returns FALSE if any of the flags are not set)
//

#define SepAreFlagsSet( Mask, Bits )                                           \
            (                                                                  \
            ((Mask) & ( Bits )) == ( Bits )                                    \
            )

//
//  Macro to set the specified control bits in the given Security Descriptor
//

#define SepSetFlags( Mask, Bits )                                              \
            (                                                                  \
            ( Mask ) |= ( Bits )                                               \
            )

//
//  Macro to clear the passed control bits in the given Security Descriptor
//

#define SepClearFlags( Mask, Bits )                                            \
            (                                                                  \
            ( Mask ) &= ~( Bits )                                              \
            )




//
// Macro to determine the size of a PRIVILEGE_SET
//

#define SepPrivilegeSetSize( PrivilegeSet )                                    \
        ( ( PrivilegeSet ) == NULL ? 0 :                                       \
        ((( PrivilegeSet )->PrivilegeCount > 0)                                \
         ?                                                                     \
         ((ULONG)sizeof(PRIVILEGE_SET) +                                       \
           (                                                                   \
             (( PrivilegeSet )->PrivilegeCount  -  ANYSIZE_ARRAY) *            \
             (ULONG)sizeof(LUID_AND_ATTRIBUTES)                                \
           )                                                                   \
         )                                                                     \
         : ((ULONG)sizeof(PRIVILEGE_SET) - (ULONG)sizeof(LUID_AND_ATTRIBUTES)) \
        ))


//
//      Return the effective token from a SecurityContext
//

#define EffectiveToken( SubjectSecurityContext ) (                            \
                 (SubjectSecurityContext)->ClientToken ?                      \
                 (SubjectSecurityContext)->ClientToken :                      \
                 (SubjectSecurityContext)->PrimaryToken                       \
                 )                                                            \


//
//      Return a pointer to the Sid of the User of a given token
//

#define SepTokenUserSid( Token )   ((PTOKEN)(Token))->UserAndGroups->Sid


//
//      Return the AuthenticationId from a given token
//

#define SepTokenAuthenticationId( Token )   (((PTOKEN)(Token))->AuthenticationId)



//
//
// BOOLEAN
// SepBadImpersonationLevel(
//     IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
//     IN BOOLEAN ServerIsRemote
//     )
//
// Routine Description:
//
//     Determine whether a client is trying to impersonate inappropriately
//     This routine should only be called if a thread requesting impersonation
//     is itself already impersonating a client of its own.  This routine
//     indicates whether the client is attempting to violate the level of
//     impersonation granted to it by its client.
//
// Arguments:
//
//     ImpersonationLevel - Is the impersonation level of the client's
//         effective token.
//
//     ServerIsRemote - Is a boolean flag indicating whether the client
//         is requesting impersonation services to a remote system.  TRUE
//         indicates the session is a remote session, FALSE indicates the
//         session is a local session.  Delegation level is necessary to
//         achieve a remote session.
//
// Return Value:
//
//     TRUE - Indicates that the impersonation level of the client's client
//         token is inappropriate for the attempted impersonation.
//         An error (STATUS_BAD_IMPERSONATION_LEVEL) should be generated.
//
//     FALSE - Indicates the impersonation attempt is not bad, and should
//         be allowed.
//
//

#define SepBadImpersonationLevel(IL,SIR)  ((                                   \
            ((IL) == SecurityAnonymous) || ((IL) == SecurityIdentification) || \
            ( (SIR) && ((IL) != SecurityDelegation) )                          \
            ) ? TRUE : FALSE )



//++
//
// BOOL
// IsValidElementCount(
//      IN ULONG Count,
//      IN <STRUCTURE>
//      );
//
//--

#define IsValidElementCount( Count, STRUCTURE ) \
    ( Count < ( (ULONG_PTR) ( (PUCHAR) ( (PUCHAR) (LONG_PTR)(LONG)0xFFFFFFFF - (PUCHAR) MM_SYSTEM_RANGE_START ) + 1 ) \
        / sizeof( STRUCTURE ) ) )


#define SEP_MAX_PRIVILEGE_COUNT (SE_MAX_WELL_KNOWN_PRIVILEGE-SE_MIN_WELL_KNOWN_PRIVILEGE+32)

#define IsValidPrivilegeCount( count ) ((count == 0) || \
                                        ((count > 0) && \
                                         (count <= SEP_MAX_PRIVILEGE_COUNT)))

//
// the object type list limit is chosen arbitrarily 
//
#define SEP_MAX_OBJECT_TYPE_LIST_COUNT 4096 

#define IsValidObjectTypeListCount( count ) \
          ((count == 0) || \
           (count <= SEP_MAX_OBJECT_TYPE_LIST_COUNT))

#define IsInRange(item,min_val,max_val) \
            (((item) >= min_val) && ((item) <= max_val))

//       
// see msaudite.mc for def. of valid category-id
//
#define IsValidCategoryId(c) \
            (IsInRange((c), SE_ADT_MIN_CATEGORY_ID, SE_ADT_MAX_CATEGORY_ID))

//
// see msaudite.mc for def. of valid audit-id
//

#define IsValidAuditId(a) \
            (IsInRange((a), SE_ADT_MIN_AUDIT_ID, SE_ADT_MAX_AUDIT_ID))

//
// check for reasonable value of parameter count. we must have atleast
// 2 parameters in the audit-params array. Thus the min limit is 3.
// The max limit is determined by the value in ntlsa.h
//

#define IsValidParameterCount(p) \
            (IsInRange((p), 2, SE_MAX_AUDIT_PARAMETERS))





///////////////////////////////////////////////////////////////////////////
//                                                                       //
//  Constants                                                            //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

#define SEP_MAX_GROUP_COUNT 4096


///////////////////////////////////////////////////////////////////////////
//                                                                       //
//  Private Data types                                                   //
//                                                                       //
///////////////////////////////////////////////////////////////////////////


extern HANDLE SepLsaHandle;

//extern BOOLEAN SepAuditShutdownEvents;

//
// Spinlock protecting the queue of work being passed to LSA
//

extern ERESOURCE SepLsaQueueLock;

extern ULONG SepLsaQueueLength;

//
// Doubly linked list of work items queued to worker threads.
//

extern LIST_ENTRY SepLsaQueue;


extern LONG SepTokenPolicyCounter[POLICY_AUDIT_EVENT_TYPE_COUNT];

// #define SepAcquireTokenReadLock(T)  KeEnterCriticalRegion();          \
//                                     ExAcquireResourceSharedLite(&SepTokenLock, TRUE)

#define SepLockLsaQueue()  KeEnterCriticalRegion();                           \
                           ExAcquireResourceExclusiveLite(&SepLsaQueueLock, TRUE)

#define SepUnlockLsaQueue() ExReleaseResourceLite(&SepLsaQueueLock);              \
                            KeLeaveCriticalRegion()

#define  SepWorkListHead()  ((PSEP_LSA_WORK_ITEM)(&SepLsaQueue)->Flink)

#define  SepWorkListEmpty() (IsListEmpty (&SepLsaQueue))

#ifndef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'  eS')
#endif
#ifndef ExAllocatePoolWithQuota
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,'  eS')
#endif

typedef
VOID
(*PSEP_LSA_WORKER_CLEANUP_ROUTINE)(
    IN PVOID Parameter
    );


typedef enum _SEP_LSA_WORK_ITEM_TAG {
    SepDeleteLogon,
    SepAuditRecord
} SEP_LSA_WORK_ITEM_TAG, *PSEP_LSA_WORK_ITEM_TAG;





typedef struct _SEP_LSA_WORK_ITEM {

    //
    // This field must be the first field of this structure
    //

    LIST_ENTRY                      List;

    //
    // Command Params Memory type
    //

    SEP_RM_LSA_MEMORY_TYPE          CommandParamsMemoryType;

    //
    // Tag describing what kind of structure we've got
    //

    SEP_LSA_WORK_ITEM_TAG           Tag;

    //
    // The following union contains the data to be passed
    // to LSA.
    //

    union {

        PVOID                       BaseAddress;
        LUID                        LogonId;

    } CommandParams;

    //
    // These fields must be filled in by the caller of SepRmCallLsa
    //

    LSA_COMMAND_NUMBER              CommandNumber;
    ULONG                           CommandParamsLength;
    PVOID                           ReplyBuffer;
    ULONG                           ReplyBufferLength;

    //
    // CleanupFunction (if specified) will be called with CleanupParameter
    // as its argument before the SEP_LSA_WORK_ITEM is freed by SepRmCallLsa
    //

    PSEP_LSA_WORKER_CLEANUP_ROUTINE CleanupFunction;
    PVOID                           CleanupParameter;

} SEP_LSA_WORK_ITEM, *PSEP_LSA_WORK_ITEM;


typedef struct _SEP_WORK_ITEM {

    WORK_QUEUE_ITEM  WorkItem;

} SEP_WORK_ITEM, *PSEP_WORK_ITEM;

//
// Each logon session active in the system has a corresponding record of
// the following type...
//

typedef struct _SEP_LOGON_SESSION_REFERENCES {
    struct _SEP_LOGON_SESSION_REFERENCES *Next;
    LUID LogonId;
    ULONG ReferenceCount;
    ULONG Flags;
    PDEVICE_MAP pDeviceMap;
#if DBG || TOKEN_LEAK_MONITOR
    LIST_ENTRY TokenList;
#endif
} SEP_LOGON_SESSION_REFERENCES, *PSEP_LOGON_SESSION_REFERENCES;


extern SEP_WORK_ITEM SepExWorkItem;






///////////////////////////////////////////////////////////////////////////
//                                                                       //
//  Private Routines                                                     //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

BOOLEAN
SepDevelopmentTest( VOID );      //Used only for development testing


BOOLEAN
SepInitializationPhase0( VOID );

BOOLEAN
SepInitializationPhase1( VOID );

BOOLEAN
SepVariableInitialization( VOID );

NTSTATUS
SepCreateToken(
    OUT PHANDLE TokenHandle,
    IN KPROCESSOR_MODE RequestorMode,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN TOKEN_TYPE TokenType,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel OPTIONAL,
    IN PLUID AuthenticationId,
    IN PLARGE_INTEGER ExpirationTime,
    IN PSID_AND_ATTRIBUTES User,
    IN ULONG GroupCount,
    IN PSID_AND_ATTRIBUTES Groups,
    IN ULONG GroupsLength,
    IN ULONG PrivilegeCount,
    IN PLUID_AND_ATTRIBUTES Privileges,
    IN PSID Owner OPTIONAL,
    IN PSID PrimaryGroup,
    IN PACL DefaultDacl OPTIONAL,
    IN PTOKEN_SOURCE TokenSource,
    IN BOOLEAN SystemToken,
    IN PSECURITY_TOKEN_PROXY_DATA ProxyData OPTIONAL,
    IN PSECURITY_TOKEN_AUDIT_DATA AuditData OPTIONAL
    );

NTSTATUS
SepReferenceLogonSession(
    IN PLUID LogonId,
    OUT PSEP_LOGON_SESSION_REFERENCES *ReturnSession
    );

VOID
SepDeReferenceLogonSession(
    IN PLUID LogonId
    );

#define TOKEN_LEAK_MONITOR 0
#if DBG || TOKEN_LEAK_MONITOR

VOID 
SepAddTokenLogonSession(
    IN PACCESS_TOKEN Token
    );

VOID
SepRemoveTokenLogonSession(
    IN PACCESS_TOKEN Token
    );

extern LONG    SepTokenLeakMethodCount;
extern LONG    SepTokenLeakBreakCount;
extern LONG    SepTokenLeakMethodWatch;
extern PVOID   SepTokenLeakToken;
extern HANDLE  SepTokenLeakProcessCid;
extern BOOLEAN SepTokenLeakTracking;

#endif

VOID
SepLockSubjectContext(
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext
    );

VOID
SepFreeSubjectContext(
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext
    );

VOID
SepGetDefaultsSubjectContext(
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext,
    OUT PSID *Owner,
    OUT PSID *Group,
    OUT PSID *ServerOwner,
    OUT PSID *ServerGroup,
    OUT PACL *Dacl
    );

BOOLEAN
SepValidOwnerSubjectContext(
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext,
    IN PSID Owner,
    IN BOOLEAN ServerObject
    );

BOOLEAN
SepIdAssignableAsGroup(
    IN PACCESS_TOKEN Token,
    IN PSID Group
    );

BOOLEAN
SepCheckAcl (
    IN PACL Acl,
    IN ULONG Length
    );

BOOLEAN
SepAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN ObjectCreation,
    IN ACCESS_MASK GrantedAccess,
    OUT PBOOLEAN GenerateOnClose
    );

BOOLEAN
SepSinglePrivilegeCheck (
   LUID DesiredPrivilege,
   IN PACCESS_TOKEN EffectiveToken,
   IN KPROCESSOR_MODE PreviousMode
   );

NTSTATUS
SepRmCallLsa(
    PSEP_WORK_ITEM SepWorkItem
    );

BOOLEAN
SepInitializeWorkList(
    VOID
    );

BOOLEAN
SepRmInitPhase0(
    );

VOID
SepConcatenatePrivileges(
    IN PPRIVILEGE_SET TargetPrivilegeSet,
    IN ULONG TargetBufferSize,
    IN PPRIVILEGE_SET SourcePrivilegeSet
    );

BOOLEAN
SepTokenIsOwner(
    IN PACCESS_TOKEN Token,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOLEAN TokenLocked
    );

#if DBG
VOID
SepPrintAcl (
    IN PACL Acl
    );

VOID
SepPrintSid(
    IN PSID Sid
    );

VOID
SepDumpSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSZ TitleString
    );

BOOLEAN
SepSidTranslation(
    PSID Sid,
    PSTRING AccountName
    );

VOID
SepDumpTokenInfo(
    IN PACCESS_TOKEN Token
    );

VOID
SepDumpString(
    IN PUNICODE_STRING String
    );
#endif //DBG

BOOLEAN
SepSidInToken (
    IN PACCESS_TOKEN Token,
    IN PSID PrincipalSelfSid,
    IN PSID Sid,
    IN BOOLEAN DenyAce
    );


VOID
SepExamineSacl(
    IN PACL Sacl,
    IN PACCESS_TOKEN Token,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN AccessGranted,
    OUT PBOOLEAN GenerateAudit,
    OUT PBOOLEAN GenerateAlarm
    );


VOID
SepCopyString (
    IN PUNICODE_STRING SourceString,
    OUT PUNICODE_STRING *DestString
    );

VOID
SepAssemblePrivileges(
    IN ULONG PrivilegeCount,
    IN BOOLEAN SystemSecurity,
    IN BOOLEAN WriteOwner,
    OUT PPRIVILEGE_SET *Privileges
    );


PUNICODE_STRING
SepQueryTypeString(
    IN PVOID Object
    );


POBJECT_NAME_INFORMATION
SepQueryNameString(
    IN PVOID Object
    );
                        
#define SEP_SERVICES_FILTER 0x1

BOOLEAN
SepFilterPrivilegeAudits(
    IN ULONG Flags,
    IN PPRIVILEGE_SET PrivilegeSet
    );

BOOLEAN
SepQueueWorkItem(
    IN PSEP_LSA_WORK_ITEM LsaWorkItem,
    IN BOOLEAN ForceQueue
    );

PSEP_LSA_WORK_ITEM
SepDequeueWorkItem(
    VOID
    );

VOID
SepAdtGenerateDiscardAudit(
    VOID
    );

BOOLEAN
SepAdtValidateAuditBounds(
    ULONG Upper,
    ULONG Lower
    );

NTSTATUS
SepAdtInitializeCrashOnFail(
    VOID
    );

BOOLEAN
SepAdtInitializePrivilegeAuditing(
    VOID
    );

NTSTATUS
SepCopyProxyData (
    OUT PSECURITY_TOKEN_PROXY_DATA * DestProxyData,
    IN PSECURITY_TOKEN_PROXY_DATA SourceProxyData
    );

VOID
SepFreeProxyData (
    IN PSECURITY_TOKEN_PROXY_DATA ProxyData
    );

NTSTATUS
SepProbeAndCaptureQosData(
    IN PSECURITY_ADVANCED_QUALITY_OF_SERVICE CapturedSecurityQos
    );

VOID
SepAuditAssignPrimaryToken(
    IN PEPROCESS Process,
    IN PACCESS_TOKEN NewAccessToken
    );

BOOLEAN
SepAdtAuditThisEventWithContext(
    IN POLICY_AUDIT_EVENT_TYPE Category,
    IN BOOLEAN AccessGranted,
    IN BOOLEAN AccessDenied,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext OPTIONAL
    );

#endif // _SEP_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\tokenadj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    tokenadj.c

Abstract:

   This module implements the services that perform individual adjustments
   on token objects.

--*/

#include "pch.h"

#pragma hdrstop


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtAdjustPrivilegesToken)
#pragma alloc_text(PAGE,NtAdjustGroupsToken)
#pragma alloc_text(PAGE,SepAdjustPrivileges)
#pragma alloc_text(PAGE,SepAdjustGroups)
#endif


////////////////////////////////////////////////////////////////////////
//                                                                    //
//           Token Object Routines & Methods                          //
//                                                                    //
////////////////////////////////////////////////////////////////////////


NTSTATUS
NtAdjustPrivilegesToken (
    __in HANDLE TokenHandle,
    __in BOOLEAN DisableAllPrivileges,
    __in_opt PTOKEN_PRIVILEGES NewState,
    __in ULONG BufferLength,
    __out_bcount_part_opt(BufferLength,*ReturnLength) PTOKEN_PRIVILEGES PreviousState,
    __out_opt PULONG ReturnLength
    )


/*++


Routine Description:

    This routine is used to disable or enable privileges in the
    specified token.  The absence of some of the privileges listed to
    be changed won't effect the successful modification of the
    privileges that are in the token.  The previous enabled/disabled
    state of changed privileges may optionally be capture (for
    resetting later).

    TOKEN_ADJUST_PRIVILEGES access is required to enable or disable
    privileges in a token.


Arguments:

    TokenHandle - Provides a handle to the token to operate on.

    DisableAllPrivileges - This boolean parameter may be
        used to disable all privileges assigned to the token.  If
        this parameter is specified as TRUE, then the NewState parameter is
        ignored.

    NewState - This (optional) parameter points to a TOKEN_PRIVILEGES
        data structure containing the privileges whose states are to
        be adjusted (disabled or enabled).  Only the Enabled flag of
        the attributes associated with each privilege is used.  It
        provides the new value that is to be assigned to the
        privilege in the token.

    BufferLength - This optional parameter indicates the length (in
        bytes) of the PreviousState buffer.  This value must be
        provided if the PreviousState parameter is provided.

    PreviousState - This (optional) parameter points to a buffer to
        receive the state of any privileges actually changed by this
        request.  This information is formated as a TOKEN_PRIVILEGES
        data structure which may be passed as the NewState parameter
        in a subsequent call to this routine to restore the original
        state of those privileges.  TOKEN_QUERY access is needed to
        use this parameter.

        If this buffer does not contain enough space to receive the
        complete list of modified privileges, then no privilege
        states are changed and STATUS_BUFFER_TOO_SMALL is returned.
        In this case, the ReturnLength OUT parameter will
        contain the actual number of bytes needed to hold the
        information.

    ReturnLength - Indicates the actual number of bytes needed to
        contain the previous privilege state information.
        This parameter is ignored if the PreviousState argument is not
        passed.

Return Value:

    STATUS_SUCCESS - The service successfully completed the requested
        operation.

    STATUS_NOT_ALL_ASSIGNED - This NT_SUCCESS severity return status
        indicates that not all the specified privileges are currently
        assigned to the caller.  All specified privileges that are
        currently assigned have been successfully adjusted.

    STATUS_BUFFER_TOO_SMALL - Indicates the optional buffer provided
        to receive the previous states of changed privileges wasn't
        large enough to receive that information.  No changes to
        privilege states has been made.  The number of bytes needed
        to hold the state change information is returned via the
        ReturnLength parameter.

    STATUS_INVALID_PARAMETER - Indicates neither the DisableAllPrivileges
        parameter was specified as true, nor was an explicit NewState
        provided.

--*/

{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    PTOKEN Token;

    ACCESS_MASK DesiredAccess;

    ULONG CapturedPrivilegeCount = 0;
    PLUID_AND_ATTRIBUTES CapturedPrivileges = NULL;
    ULONG CapturedPrivilegesLength = 0;

    ULONG LocalReturnLength = 0;
    ULONG ChangeCount = 0;
    BOOLEAN ChangesMade = FALSE;

    ULONG ParameterLength = 0;

    PAGED_CODE();

    //
    //  The semantics of the PreviousState parameter leads to a two-pass
    //  approach to adjusting privileges.  The first pass simply checks
    //  to see which privileges will change and counts them.  This allows
    //  the amount of space needed to be calculated and returned.  If
    //  the caller's PreviousState return buffer is not large enough, then
    //  an error is returned without making any modifications.  Otherwise,
    //  a second pass is made to actually make the changes.
    //
    //

    if (!DisableAllPrivileges && !ARGUMENT_PRESENT(NewState)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Get previous processor mode and probe parameters if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {

            //
            // Make sure we can see all of the new state
            //

            if (!DisableAllPrivileges) {

                ProbeForReadSmallStructure(
                    NewState,
                    sizeof(TOKEN_PRIVILEGES),
                    sizeof(ULONG)
                    );

                CapturedPrivilegeCount = NewState->PrivilegeCount;
                ParameterLength = (ULONG)sizeof(TOKEN_PRIVILEGES) +
                                  ( (CapturedPrivilegeCount - ANYSIZE_ARRAY) *
                                  (ULONG)sizeof(LUID_AND_ATTRIBUTES)  );

                ProbeForRead(
                    NewState,
                    ParameterLength,
                    sizeof(ULONG)
                    );

            }


            //
            // Check the PreviousState buffer for writeability
            //

            if (ARGUMENT_PRESENT(PreviousState)) {

                ProbeForWrite(
                    PreviousState,
                    BufferLength,
                    sizeof(ULONG)
                    );

                ProbeForWriteUlong(ReturnLength);
            }


        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

    } else {

        if (!DisableAllPrivileges) {

            CapturedPrivilegeCount = NewState->PrivilegeCount;
        }
    }



    //
    // Capture NewState if passed.
    //

    if (!DisableAllPrivileges) {

        try {


            Status = SeCaptureLuidAndAttributesArray(
                         (NewState->Privileges),
                         CapturedPrivilegeCount,
                         PreviousMode,
                         NULL, 0,
                         PagedPool,
                         TRUE,
                         &CapturedPrivileges,
                         &CapturedPrivilegesLength
                         );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            return GetExceptionCode();

        }

        if (!NT_SUCCESS(Status)) {

            return Status;

        }

    }


    //
    // Reference the token object and validate the caller's right
    // to adjust the privileges.
    //

    if (ARGUMENT_PRESENT(PreviousState)) {
        DesiredAccess = (TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY);
    } else {
        DesiredAccess = TOKEN_ADJUST_PRIVILEGES;
    }

    Status = ObReferenceObjectByHandle(
             TokenHandle,             // Handle
             DesiredAccess,           // DesiredAccess
             SeTokenObjectType,      // ObjectType
             PreviousMode,            // AccessMode
             (PVOID *)&Token,         // Object
             NULL                     // GrantedAccess
             );

    if ( !NT_SUCCESS(Status) ) {

        if (CapturedPrivileges != NULL) {
            SeReleaseLuidAndAttributesArray(
                CapturedPrivileges,
                PreviousMode,
                TRUE
                );
        }

        return Status;
    }

    //
    //  Gain exclusive access to the token.
    //

    SepAcquireTokenWriteLock( Token );

    //
    // First pass through the privileges list - just count the changes
    //


    Status = SepAdjustPrivileges(
                Token,
                FALSE,                // Don't make changes this pass
                DisableAllPrivileges,
                CapturedPrivilegeCount,
                CapturedPrivileges,
                PreviousState,
                &LocalReturnLength,
                &ChangeCount,
                &ChangesMade
                );

    if (ARGUMENT_PRESENT(PreviousState)) {

        try {

            (*ReturnLength) = LocalReturnLength;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenWriteLock( Token, FALSE );
            ObDereferenceObject( Token );

            if (CapturedPrivileges != NULL) {
                SeReleaseLuidAndAttributesArray(
                    CapturedPrivileges,
                    PreviousMode,
                    TRUE
                    );
            }

            return GetExceptionCode();
        }

    }


    //
    // Make sure there is enough room to return any  requested
    // information.
    //

    if (ARGUMENT_PRESENT(PreviousState)) {
        if (LocalReturnLength > BufferLength) {

            SepReleaseTokenWriteLock( Token, FALSE );
            ObDereferenceObject( Token );

            if (CapturedPrivileges != NULL) {
                SeReleaseLuidAndAttributesArray(
                    CapturedPrivileges,
                    PreviousMode,
                    TRUE
                    );
            }

            return STATUS_BUFFER_TOO_SMALL;
        }
    }

    //
    // Second pass through the privileges list - Make the changes.
    //
    // Note that the internal routine attempts to write the previous
    // state directly to the caller's buffer - and so may get an exception.
    //

    try {

        Status = SepAdjustPrivileges(
                    Token,
                    TRUE,                 // Make the changes this pass
                    DisableAllPrivileges,
                    CapturedPrivilegeCount,
                    CapturedPrivileges,
                    PreviousState,
                    &LocalReturnLength,
                    &ChangeCount,
                    &ChangesMade
                    );


        if (ARGUMENT_PRESENT(PreviousState)) {

            PreviousState->PrivilegeCount = ChangeCount;
                        
            if (ChangeCount == 0) {

                RtlZeroMemory(
                    PreviousState->Privileges, 
                    sizeof(LUID_AND_ATTRIBUTES)
                    );
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        SepReleaseTokenWriteLock( Token, TRUE );
        ObDereferenceObject( Token );
        if (CapturedPrivileges != NULL) {
            SeReleaseLuidAndAttributesArray(
                CapturedPrivileges,
                PreviousMode,
                TRUE
                );
        }
        return GetExceptionCode();

    }


    SepReleaseTokenWriteLock( Token, ChangesMade );
    ObDereferenceObject( Token );
    if (CapturedPrivileges != NULL) {
        SeReleaseLuidAndAttributesArray(
            CapturedPrivileges,
            PreviousMode,
            TRUE
            );
    }

    return Status;

}


NTSTATUS
NtAdjustGroupsToken (
    __in HANDLE TokenHandle,
    __in BOOLEAN ResetToDefault,
    __in PTOKEN_GROUPS NewState,
    __in ULONG BufferLength,
    __out_bcount_part_opt(BufferLength, *ReturnLength) PTOKEN_GROUPS PreviousState,
    __out PULONG ReturnLength
    )

/*++


Routine Description:

    This routine is used to disable or enable groups in the specified
    token.  The absence of some of the groups listed to be changed
    won't effect the successful modification of the groups that are in
    the token.  The previous enabled/disabled state of changed groups
    may optionally be capture (for resetting later).

    TOKEN_ADJUST_GROUPS access is required to enable or disable groups
    in a token

    Note that mandatory groups can not be disabled.  An attempt
    disable any mandatory groups will cause the call to fail, leaving
    the state of all groups unchanged.


Arguments:

    TokenHandle - Provides a handle to the token to operate on.

    ResetToDefault - The parameter indicates whether all the groups
        in the token are to be reset to their default enabled/disabled
        state.

    NewState - This parameter points to a TOKEN_GROUPS data structure
        containing the groups whose states are to be adjusted
        (disabled or enabled).  Only the Enabled flag of the
        attributes associated with each group is used.  It provides
        the new value that is to be assigned to the group in the
        token.  If the ResetToDefault argument is specified as TRUE,
        then this argument is ignored.  Otherwise, it must be passed.

    BufferLength - This optional parameter indicates the length (in
        bytes) of the PreviousState buffer.  This value must be
        provided if the PreviousState parameter is provided.

    PreviousState - This (optional) parameter points to a buffer to
        receive the state of any groups actually changed by this
        request.  This information is formated as a TOKEN_GROUPS data
        structure which may be passed as the NewState parameter in a
        subsequent call to NtAdjustGroups to restore the original state
        of those groups.  TOKEN_QUERY access is needed to use this
        parameter.

        If this buffer does not contain enough space to receive the
        complete list of modified groups, then no group states are
        changed and STATUS_BUFFER_TOO_SMALL is returned.  In this
        case, the ReturnLength return parameter will contain the
        actual number of bytes needed to hold the information.

    ReturnLength - Indicates the actual number of bytes needed to
        contain the previous group state information.
        This parameter is ignored if the PreviousState argument is not
        passed.


Return Value:

    STATUS_SUCCESS - The service successfully completed the requested
        operation.

    STATUS_NOT_ALL_ASSIGNED - This NT_SUCCESS severity return status
        indicates that not all the specified groups are currently
        assigned to the caller.  All specified groups that are
        currently assigned have been successfully adjusted.

    STATUS_CANT_DISABLE_MANDATORY - Indicates an attempt was made to
        disable a mandatory group.  The states of all groups remains
        unchanged.

    STATUS_BUFFER_TOO_SMALL - Indicates the optional buffer provided
        to receive the previous states of changed group wasn't large
        enough to receive that information.  No changes to group
        states has been made.  The number of bytes needed to hold the
        state change information is returned via the ReturnLength
        parameter.

    STATUS_INVALID_PARAMETER - Indicates neither the ResetToDefault
        parameter was specified as true, nor was an explicit NewState
        provided.

--*/
{

    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    PTOKEN Token;

    ACCESS_MASK DesiredAccess;

    ULONG CapturedGroupCount = 0;
    PSID_AND_ATTRIBUTES CapturedGroups = NULL;
    ULONG CapturedGroupsLength = 0;

    ULONG LocalReturnLength;
    ULONG ChangeCount;
    BOOLEAN ChangesMade;
    PSID SidBuffer = NULL;

    PAGED_CODE();

    //
    //  The semantics of the PreviousState parameter and the
    //  STATUS_CANT_DISABLE_MANDATORY completion status leads to a two-pass
    //  approach to adjusting groups.  The first pass simply checks
    //  to see which groups will change and counts them.  This allows
    //  the amount of space needed to be calculated and returned.  If
    //  the caller's PreviousState return buffer is not large enough, or
    //  one of the specified groups is a mandatory group, then an error
    //  is returned without making any modifications.  Otherwise, a second
    //  pass is made to actually make the changes.
    //

    if (!ResetToDefault && !ARGUMENT_PRESENT(NewState)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Get previous processor mode and probe parameters if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {

            if (!ResetToDefault) {
                ProbeForReadSmallStructure(
                    NewState,
                    sizeof(TOKEN_GROUPS),
                    sizeof(ULONG)
                    );
            }

            if (ARGUMENT_PRESENT(PreviousState)) {

                ProbeForWrite(
                    PreviousState,
                    BufferLength,
                    sizeof(ULONG)
                    );

                //
                // This parameter is only used if PreviousState
                // is present
                //

                ProbeForWriteUlong(ReturnLength);

            }


        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Capture NewState.
    //

    if (!ResetToDefault) {

        try {

            CapturedGroupCount = NewState->GroupCount;
            Status = SeCaptureSidAndAttributesArray(
                         &(NewState->Groups[0]),
                         CapturedGroupCount,
                         PreviousMode,
                         NULL, 0,
                         PagedPool,
                         TRUE,
                         &CapturedGroups,
                         &CapturedGroupsLength
                         );

            if (!NT_SUCCESS(Status)) {

                return Status;

            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            return GetExceptionCode();

        } // endtry
    } // endif !ResetToDefault


    //
    // Reference the token object and validate the caller's right
    // to adjust the groups.
    //

    if (ARGUMENT_PRESENT(PreviousState)) {
        DesiredAccess = (TOKEN_ADJUST_GROUPS | TOKEN_QUERY);
    } else {
        DesiredAccess = TOKEN_ADJUST_GROUPS;
    }

    Status = ObReferenceObjectByHandle(
             TokenHandle,             // Handle
             DesiredAccess,           // DesiredAccess
             SeTokenObjectType,      // ObjectType
             PreviousMode,            // AccessMode
             (PVOID *)&Token,         // Object
             NULL                     // GrantedAccess
             );

    if ( !NT_SUCCESS(Status) ) {

        if (ARGUMENT_PRESENT(CapturedGroups)) {
            SeReleaseSidAndAttributesArray( CapturedGroups, PreviousMode, TRUE );
        }

        return Status;
    }

    //
    //  Gain exclusive access to the token.
    //

    SepAcquireTokenWriteLock( Token );

    //
    // First pass through the groups list.
    //
    // This pass is always necessary for groups to make sure the caller
    // isn't trying to do anything illegal to mandatory groups.
    //

    Status = SepAdjustGroups(
                 Token,
                 FALSE,                // Don't make changes this pass
                 ResetToDefault,
                 CapturedGroupCount,
                 CapturedGroups,
                 PreviousState,
                 NULL,                // Not returning SIDs this call
                 &LocalReturnLength,
                 &ChangeCount,
                 &ChangesMade
                 );

    if (ARGUMENT_PRESENT(PreviousState)) {

        try {

            (*ReturnLength) = LocalReturnLength;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenWriteLock( Token, FALSE );
            ObDereferenceObject( Token );

            if (ARGUMENT_PRESENT(CapturedGroups)) {
                SeReleaseSidAndAttributesArray(
                    CapturedGroups,
                    PreviousMode,
                    TRUE
                    );
            }

            return GetExceptionCode();
        }
    }

    //
    // Make sure we didn't encounter an error
    //

    if (!NT_SUCCESS(Status)) {

        SepReleaseTokenWriteLock( Token, FALSE );
        ObDereferenceObject( Token );

        if (ARGUMENT_PRESENT(CapturedGroups)) {
            SeReleaseSidAndAttributesArray(
                CapturedGroups,
                PreviousMode,
                TRUE
                );
        }

        return Status;

    }

    //
    // Make sure there is enough room to return requested information.
    // Also go on to calculate where the SID values go.
    //

    if (ARGUMENT_PRESENT(PreviousState)) {
        if (LocalReturnLength > BufferLength) {

            SepReleaseTokenWriteLock( Token, FALSE );
            ObDereferenceObject( Token );

            if (ARGUMENT_PRESENT(CapturedGroups)) {
                SeReleaseSidAndAttributesArray(
                    CapturedGroups,
                    PreviousMode,
                    TRUE
                    );
            }


            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        // Calculate where the SIDs can be placed in the PreviousState
        // buffer.
        //

        SidBuffer = (PSID)(LongAlignPtr(
                            (PCHAR)PreviousState + (ULONG)sizeof(TOKEN_GROUPS) +
                            (ChangeCount * (ULONG)sizeof(SID_AND_ATTRIBUTES)) -
                            (ANYSIZE_ARRAY * (ULONG)sizeof(SID_AND_ATTRIBUTES))
                            ) );

    }

    //
    // Second pass through the groups list.
    //

    try {

        Status = SepAdjustGroups(
                     Token,
                     TRUE,                 // Make changes in this pass
                     ResetToDefault,
                     CapturedGroupCount,
                     CapturedGroups,
                     PreviousState,
                     SidBuffer,
                     &LocalReturnLength,
                     &ChangeCount,
                     &ChangesMade
                     );

        if (ARGUMENT_PRESENT(PreviousState)) {

            PreviousState->GroupCount = ChangeCount;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        SepReleaseTokenWriteLock( Token, TRUE );
        ObDereferenceObject( Token );
        if (ARGUMENT_PRESENT(CapturedGroups)) {
            SeReleaseSidAndAttributesArray( CapturedGroups, PreviousMode, TRUE );
        }
        return GetExceptionCode();

    }

    SepReleaseTokenWriteLock( Token, ChangesMade );
    ObDereferenceObject( Token );

    if (ARGUMENT_PRESENT(CapturedGroups)) {
        SeReleaseSidAndAttributesArray( CapturedGroups, PreviousMode, TRUE );
    }

    return Status;

}

NTSTATUS
SepAdjustPrivileges(
    IN PTOKEN Token,
    IN BOOLEAN MakeChanges,
    IN BOOLEAN DisableAllPrivileges,
    IN ULONG PrivilegeCount OPTIONAL,
    IN PLUID_AND_ATTRIBUTES NewState OPTIONAL,
    OUT PTOKEN_PRIVILEGES PreviousState OPTIONAL,
    OUT PULONG ReturnLength,
    OUT PULONG ChangeCount,
    OUT PBOOLEAN ChangesMade
    )

/*++


Routine Description:

    This routine is used to walk the privileges array in a token as a
    result of a request to adjust privileges.

    If the MakeChanges parameter is FALSE, this routine simply determines
    what changes are needed and how much space is necessary to save the
    current state of changed privileges.

    If the MakeChanges parameter is TRUE, this routine will not only
    calculate the space necessary to save the current state, but will
    actually make the changes.

    This routine makes the following assumptions:

      1) The token is locked for exclusive access.

      2) The PrivilegeCount and NewState parameters (if passed) are captured
         and accesses to them will not result in access violations.

      4) Any access violations encountered may leave the request
         partially completed.  It is the calling routine's responsibility
         to catch exceptions.

      5) The calling routine is responsible for inrementing the token's
         ModifiedId field.

Arguments:

    Token - Pointer to the token to act upon.

    MakeChanges - A boolean value indicating whether the changes should
        actually be made, or just evaluated.  A value of TRUE indicates
        the changes should be made.

    DisableAllPrivilegs - A boolean value indicating whether all privileges
        are to be disabled, or only select, specified privileges.  A value
        of TRUE indicates all privileges are to be disabled.

    PrivilegeCount - This parameter is required only if the NewState parameter
        is used.  In that case, this parameter indicates how many entries are
        in the NewState parameter.

    NewState - This parameter is ignored if the DisableAllPrivileges
        argument is TRUE.  If the DisableAllPrivileges argument is FALSE,
        then this parameter must be provided and specifies the new state
        to set privileges to (enabled or disabled).

    PreviousState - This (optional) parameter points to a buffer to
        receive the state of any privileges actually changed by this
        request.  This information is formated as a TOKEN_PRIVILEGES data
        structure which may be passed as the NewState parameter in a
        subsequent call to NtAdjustPrivileges to restore the original state
        of those privileges.  It is the caller's responsibility to make
        sure this buffer is large enough to receive all the state
        information.

    ReturnLength - Points to a buffer to receive the number of bytes needed
        to retrieve the previous state information of changed privileges.
        This parameter is ignored if the PreviousState argument is not
        passed.

    ChangeCount - Points to a ULONG to receive the number of privileges
        which were adjusted (or would be adjusted, if changes are made).

    ChangesMade - Points to a boolean flag which is to receive an indication
        as to whether any changes were made as a result of this call.  This
        is expected to be used to decide whether or not to increment the
        token's ModifiedId field.

Return Value:

    STATUS_SUCCESS - Call completed successfully.

    STATUS_NOT_ALL_ASSIGNED - Indicates not all the specified adjustments
        have been made (or could be made, if update wasn't requested).

--*/
{
    NTSTATUS CompletionStatus = STATUS_SUCCESS;

    ULONG OldIndex;
    ULONG NewIndex;
    BOOLEAN Found;
    ULONG MatchCount = 0;

    LUID_AND_ATTRIBUTES CurrentPrivilege;

    PAGED_CODE();

    //
    //  Walk through the privileges array to determine which need to be
    //  adjusted.
    //

    OldIndex = 0;
    (*ChangeCount) = 0;
    (*ChangesMade) = FALSE;

    while (OldIndex < Token->PrivilegeCount) {

        CurrentPrivilege = (Token->Privileges)[OldIndex];

        if (DisableAllPrivileges) {

            if (SepTokenPrivilegeAttributes(Token,OldIndex) &
               SE_PRIVILEGE_ENABLED ) {

                //
                // Change, if necessary (saving previous state if
                // appropriate).
                //

                if (MakeChanges) {

                    if (ARGUMENT_PRESENT(PreviousState)) {

                        PreviousState->Privileges[(*ChangeCount)] =
                            CurrentPrivilege;
                    }

                    SepTokenPrivilegeAttributes(Token,OldIndex) &=
                        ~SE_PRIVILEGE_ENABLED;



                } //endif make changes

                //
                // increment the number of changes
                //

                (*ChangeCount) += 1;

            } // endif privilege enabled

        } else {

            //
            //  Selective adjustments - this is a little trickier
            //  Compare the current privilege to each of those in
            //  the NewState array.  If a match is found, then adjust
            //  the current privilege appropriately.
            //

            NewIndex = 0;
            Found = FALSE;

            while ( (NewIndex < PrivilegeCount) && !Found)  {

                //
                // Look for a comparison
                //

                if (RtlEqualLuid(&CurrentPrivilege.Luid,&NewState[NewIndex].Luid)) {

                    Found = TRUE;
                    MatchCount += 1;

                    //
                    // Check if the caller wants the privilege removed. We give
                    // SE_PRIVILEGE_REMOVED a preferance over any other flags.
                    //

                    if ( (SepArrayPrivilegeAttributes( NewState, NewIndex ) &
                          SE_PRIVILEGE_REMOVED) ) {

                        //
                        // Change, if necessary. There is no need to save the 
                        // previous state. This is a one way journey.
                        //

                        if (MakeChanges) {

                            //
                            // if this is one of the recorded privileges, then
                            // delete its corresponding bit in TokenFlags
                            //

                            if (RtlEqualLuid(&CurrentPrivilege.Luid,
                                              &SeChangeNotifyPrivilege)) {
                                Token->TokenFlags &= ~TOKEN_HAS_TRAVERSE_PRIVILEGE;
                            } else if (RtlEqualLuid(&CurrentPrivilege.Luid,
                                              &SeBackupPrivilege)) {
                                Token->TokenFlags &= ~TOKEN_HAS_BACKUP_PRIVILEGE;
                            } else if (RtlEqualLuid(&CurrentPrivilege.Luid,
                                              &SeRestorePrivilege)) {
                                Token->TokenFlags &= ~TOKEN_HAS_RESTORE_PRIVILEGE;
                            } else if (RtlEqualLuid( &CurrentPrivilege.Luid, 
                                              &SeImpersonatePrivilege)) {
                                Token->TokenFlags &= ~TOKEN_HAS_IMPERSONATE_PRIVILEGE;
                                
                            }

                            //
                            // Swap this privilege with the last one.
                            //

                            if (OldIndex + 1 != Token->PrivilegeCount) {
                                LUID_AND_ATTRIBUTES TempLuidAttr;
                                TempLuidAttr = Token->Privileges[OldIndex];
                                Token->Privileges[OldIndex] = Token->Privileges[Token->PrivilegeCount-1];
                                Token->Privileges[Token->PrivilegeCount-1] = TempLuidAttr;
                            }

                            //
                            // We just lost a privilege. Make note of it.
                            //

                            Token->PrivilegeCount--;
                            OldIndex--;
                            (*ChangesMade) = TRUE;


                        } //endif make changes

                        //
                        // Note: Do NOT increment the number of changes
                        //


                   //
                   // Check if there is a state change from/to enabled to/from 
                   // disabled
                   //

                    } else if ( (SepArrayPrivilegeAttributes( NewState, NewIndex ) &
                          SE_PRIVILEGE_ENABLED)
                        !=
                         (SepTokenPrivilegeAttributes(Token,OldIndex) &
                          SE_PRIVILEGE_ENABLED)  ) {

                        //
                        // Change, if necessary (saving previous state if
                        // appropriate).
                        //

                        if (MakeChanges) {

                            if (ARGUMENT_PRESENT(PreviousState)) {

                                PreviousState->Privileges[(*ChangeCount)] =
                                    CurrentPrivilege;
                            }

                            SepTokenPrivilegeAttributes(Token,OldIndex) &=
                                ~(SepTokenPrivilegeAttributes(Token,OldIndex)
                                  & SE_PRIVILEGE_ENABLED);
                            SepTokenPrivilegeAttributes(Token,OldIndex) |=
                                 (SepArrayPrivilegeAttributes(NewState,NewIndex)
                                  & SE_PRIVILEGE_ENABLED);

                            //
                            // if this is SeChangeNotifyPrivilege, then
                            // change its corresponding bit in TokenFlags
                            // Note that Backup and Restore privileges do not
                            // care about Enabled/Disabled state.
                            //

                            if (RtlEqualLuid(&CurrentPrivilege.Luid,
                                              &SeChangeNotifyPrivilege)) {
                                Token->TokenFlags ^= TOKEN_HAS_TRAVERSE_PRIVILEGE;
                            } else if ( RtlEqualLuid( &CurrentPrivilege.Luid,
                                              &SeImpersonatePrivilege)) {
                                Token->TokenFlags ^= TOKEN_HAS_IMPERSONATE_PRIVILEGE ;
                                
                            }

                        } //endif make changes

                        //
                        // increment the number of changes
                        //

                        (*ChangeCount) += 1;


                    } 

                } // endif found

                NewIndex += 1;

            } // endwhile searching NewState

        } // endelse

        OldIndex += 1;

    } // endwhile privileges in token

    //
    // If we disabled all privileges, then clear the TokenFlags flag
    // corresponding to the SeChangeNotifyPrivilege privilege.
    //


    if (DisableAllPrivileges) {
        Token->TokenFlags &= ~TOKEN_HAS_TRAVERSE_PRIVILEGE;
        Token->TokenFlags &= ~TOKEN_HAS_IMPERSONATE_PRIVILEGE;
    }

    //
    // Set completion status appropriately if some not assigned
    //

    if (!DisableAllPrivileges) {

        if (MatchCount < PrivilegeCount) {
            CompletionStatus = STATUS_NOT_ALL_ASSIGNED;
        }
    }

    //
    //  Indicate whether changes were made
    //

    if ((*ChangeCount) > 0  &&  MakeChanges) {
        (*ChangesMade) = TRUE;
    } 

    //
    // Calculate the space needed to return previous state information
    //

    if (ARGUMENT_PRESENT(PreviousState)) {

        (*ReturnLength) = (ULONG)sizeof(TOKEN_PRIVILEGES) + ((*ChangeCount > ANYSIZE_ARRAY) ?
                          (*ChangeCount - ANYSIZE_ARRAY) * (ULONG)sizeof(LUID_AND_ATTRIBUTES) : 0);
    }

   return CompletionStatus;
}

NTSTATUS
SepAdjustGroups(
    IN PTOKEN Token,
    IN BOOLEAN MakeChanges,
    IN BOOLEAN ResetToDefault,
    IN ULONG GroupCount,
    IN PSID_AND_ATTRIBUTES NewState OPTIONAL,
    OUT PTOKEN_GROUPS PreviousState OPTIONAL,
    OUT PSID SidBuffer OPTIONAL,
    OUT PULONG ReturnLength,
    OUT PULONG ChangeCount,
    OUT PBOOLEAN ChangesMade
    )

/*++


Routine Description:

    This routine is used to walk the groups array in a token as a
    result of a request to adjust groups.

    If the MakeChanges parameter is FALSE, this routine simply determines
    what changes are needed and how much space is necessary to save the
    current state of changed groups.

    If the MakeChanges parameter is TRUE, this routine will not only
    calculate the space necessary to save the current state, but will
    actually make the changes.

    This routine makes the following assumptions:

      1) The token is locked for exclusive access.

      2) The NewState parameter is captured and accesses
         to it will not result in access violations.

      4) Any access violations encountered may leave the request
         partially completed.  It is the calling routine's responsibility
         to catch exceptions.

      5) The calling routine is responsible for inrementing the token's
         ModifiedId field.

Arguments:

    Token - Pointer to the token to act upon.

    MakeChanges - A boolean value indicating whether the changes should
        actually be made, or just evaluated.  A value of TRUE indicates
        the changes should be made.

    ResetToDefault - Indicates that the groups are to be reset to their
        default enabled/disabled state.

    GroupCount - This parameter is required only if the NewState parameter
        is used.  In that case, this parameter indicates how many entries are
        in the NewState parameter.

    NewState - This parameter points to a SID_AND_ATTRIBUTES array
        containing the groups whose states are to be adjusted
        (disabled or enabled).  Only the Enabled flag of the
        attributes associated with each group is used.  It provides
        the new value that is to be assigned to the group in the
        token.  If the ResetToDefault argument is specified as TRUE,
        then this argument is ignored.  Otherwise, it must be passed.

    PreviousState - This (optional) parameter points to a buffer to
        receive the state of any groups actually changed by this
        request.  This information is formated as a TOKEN_GROUPS data
        structure which may be passed as the NewState parameter in a
        subsequent call to NtAdjustGroups to restore the original state
        of those groups.  It is the caller's responsibility to make
        sure this buffer is large enough to receive all the state
        information.

    SidBuffer - Pointer to buffer to receive the SID values corresponding
        to the groups returned in the PreviousState argument.

    ReturnLength - Points to a buffer to receive the number of bytes needed
        to retrieve the previous state information of changed privileges.
        This parameter is ignored if the PreviousState argument is not
        passed.

    ChangeCount - Points to a ULONG to receive the number of groups
        which were adjusted (or would be adjusted, if changes are made).

    ChangesMade - Points to a boolean flag which is to receive an indication
        as to whether any changes were made as a result of this call.  This
        is expected to be used to decide whether or not to increment the
        token's ModifiedId field.

Return Value:

    STATUS_SUCCESS - Call completed successfully.

    STATUS_NOT_ALL_ASSIGNED - Indicates not all the specified adjustments
        have been made (or could be made, if update wasn't requested).

    STATUS_CANT_DISABLE_MANDATORY - Not all adjustments were made (or could
        be made, if update not requested) because an attempt was made to
        disable a mandatory group.  The state of the groups is left
        in an nondeterministic state if update was requested.


--*/
{

    NTSTATUS CompletionStatus = STATUS_SUCCESS;

    ULONG OldIndex;
    ULONG NewIndex;
    ULONG SidLength;
    ULONG LocalReturnLength = 0;
    PSID NextSid;
    BOOLEAN Found;
    ULONG MatchCount = 0;
    BOOLEAN EnableGroup;
    BOOLEAN DisableGroup;
    ULONG TokenGroupAttributes;

    SID_AND_ATTRIBUTES CurrentGroup;

    PAGED_CODE();

    //
    // NextSid is used to copy group SID values if asked for previous state.
    //

    NextSid = SidBuffer;


    //
    //  Walk through the groups array to determine which need to be
    //  adjusted.
    //

    OldIndex = 1;             // Don't evaluate the 0th entry (user ID)
    (*ChangeCount) = 0;

    while (OldIndex < Token->UserAndGroupCount) {

        CurrentGroup = Token->UserAndGroups[OldIndex];

        if (ResetToDefault) {

            TokenGroupAttributes = SepTokenGroupAttributes(Token,OldIndex);

            //
            // If the group is enabled by default and currently disabled,
            // then we must enable it.
            //

            EnableGroup = (BOOLEAN)( (TokenGroupAttributes & SE_GROUP_ENABLED_BY_DEFAULT)
                && !(TokenGroupAttributes & SE_GROUP_ENABLED));

            //
            // If the group is disabled by default and currently enabled,
            // then we must disable it.
            //

            DisableGroup = (BOOLEAN)( !(TokenGroupAttributes & SE_GROUP_ENABLED_BY_DEFAULT)
                && (TokenGroupAttributes & SE_GROUP_ENABLED));

            if ( EnableGroup || DisableGroup ) {

                SidLength = SeLengthSid( CurrentGroup.Sid );
                SidLength = (ULONG)LongAlignSize(SidLength);
                LocalReturnLength += SidLength;

                //
                // Change, if necessary (saving previous state if
                // appropriate).
                //

                if (MakeChanges) {

                    if (ARGUMENT_PRESENT(PreviousState)) {

                        (*(PreviousState)).Groups[(*ChangeCount)].Attributes =
                            CurrentGroup.Attributes;

                        (*(PreviousState)).Groups[(*ChangeCount)].Sid =
                            NextSid;

                        RtlCopySid( SidLength, NextSid, CurrentGroup.Sid );
                        NextSid = (PSID)((ULONG_PTR)NextSid + SidLength);
                    }

                    if (EnableGroup) {
                        SepTokenGroupAttributes(Token,OldIndex) |= SE_GROUP_ENABLED;
                    } else {
                        SepTokenGroupAttributes(Token,OldIndex) &= ~SE_GROUP_ENABLED;
                    }



                } //endif make changes

                //
                // increment the number of changes
                //

                (*ChangeCount) += 1;

            } // endif group enabled

        } else {

            //
            //  Selective adjustments - this is a little trickier
            //  Compare the current group to each of those in
            //  the NewState array.  If a match is found, then adjust
            //  the current group appropriately.
            //

            NewIndex = 0;
            Found = FALSE;

            while ( (NewIndex < GroupCount) && !Found)  {

                //
                // Look for a comparison
                //

                if (RtlEqualSid(
                        CurrentGroup.Sid,
                        NewState[NewIndex].Sid
                        ) ) {

                    Found = TRUE;
                    MatchCount += 1;


                    //
                    // See if it needs to be changed
                    //

                    if ( (SepArrayGroupAttributes( NewState, NewIndex ) &
                            SE_GROUP_ENABLED ) !=
                         (SepTokenGroupAttributes(Token,OldIndex) &
                            SE_GROUP_ENABLED ) ) {

                        //
                        // Make sure group is not mandatory
                        //

                        if (SepTokenGroupAttributes(Token,OldIndex) &
                              SE_GROUP_MANDATORY ) {
                            return STATUS_CANT_DISABLE_MANDATORY;
                        }

                        //
                        // Make sure group is not deny-only
                        //


                        if (SepTokenGroupAttributes(Token,OldIndex) &
                              SE_GROUP_USE_FOR_DENY_ONLY ) {
                            return STATUS_CANT_ENABLE_DENY_ONLY;
                        }

                        SidLength = SeLengthSid( CurrentGroup.Sid );
                        SidLength = (ULONG)LongAlignSize(SidLength);
                        LocalReturnLength += SidLength;

                        //
                        // Change, if necessary (saving previous state if
                        // appropriate).
                        //

                        if (MakeChanges) {

                            if (ARGUMENT_PRESENT(PreviousState)) {

                                PreviousState->Groups[(*ChangeCount)].Attributes =
                                    CurrentGroup.Attributes;

                                PreviousState->Groups[(*ChangeCount)].Sid =
                                    NextSid;

                                RtlCopySid( SidLength, NextSid, CurrentGroup.Sid );

                                NextSid = (PSID)((ULONG_PTR)NextSid + SidLength);
                            }

                            SepTokenGroupAttributes(Token,OldIndex) &=
                                ~(SepTokenGroupAttributes(Token,OldIndex)
                                  & SE_GROUP_ENABLED);
                            SepTokenGroupAttributes(Token,OldIndex) |=
                                 (SepArrayGroupAttributes(NewState,NewIndex)
                                  & SE_GROUP_ENABLED);



                        } //endif make changes

                        //
                        // increment the number of changes
                        //

                        (*ChangeCount) += 1;


                    } // endif change needed

                } // endif found

                NewIndex += 1;

            } // endwhile searching NewState

        } // endelse

        OldIndex += 1;

    } // endwhile more groups in token

    //
    // Set completion status appropriately if some not assigned
    //

    if (!ResetToDefault) {

        if (MatchCount < GroupCount) {
            CompletionStatus = STATUS_NOT_ALL_ASSIGNED;
        }
    }

    //
    //  Indicate whether changes were made
    //

    if ((*ChangeCount) > 0  &&  MakeChanges) {
        (*ChangesMade) = TRUE;
    } else {
        (*ChangesMade) = FALSE;
    }

    //
    // Calculate the space needed to return previous state information
    // (The SID lengths have already been added up in LocalReturnLength).
    //

    if (ARGUMENT_PRESENT(PreviousState)) {

        (*ReturnLength) = LocalReturnLength +
                          (ULONG)sizeof(TOKEN_GROUPS) +
                          ((*ChangeCount) *  (ULONG)sizeof(SID_AND_ATTRIBUTES)) -
                          (ANYSIZE_ARRAY * (ULONG)sizeof(SID_AND_ATTRIBUTES));
    }

   return CompletionStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\token.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    token.c

Abstract:

   This module implements the initialization, open, duplicate and other
   services of the executive token object.

--*/

#include "pch.h"

#pragma hdrstop


BOOLEAN
SepComparePrivilegeAndAttributeArrays(
    IN PLUID_AND_ATTRIBUTES PrivilegeArray1,
    IN ULONG Count1,
    IN PLUID_AND_ATTRIBUTES PrivilegeArray2,
    IN ULONG Count2
    );

BOOLEAN
SepCompareSidAndAttributeArrays(
    IN PSID_AND_ATTRIBUTES SidArray1,
    IN ULONG Count1,
    IN PSID_AND_ATTRIBUTES SidArray2,
    IN ULONG Count2
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SeTokenType)
#pragma alloc_text(PAGE,SeTokenIsAdmin)
#pragma alloc_text(PAGE,SeTokenIsRestricted)
#pragma alloc_text(PAGE,SeTokenImpersonationLevel)
#pragma alloc_text(PAGE,SeAssignPrimaryToken)
#pragma alloc_text(PAGE,SeDeassignPrimaryToken)
#pragma alloc_text(PAGE,SeExchangePrimaryToken)
#pragma alloc_text(PAGE,SeGetTokenControlInformation)
#pragma alloc_text(INIT,SeMakeSystemToken)
#pragma alloc_text(INIT,SeMakeAnonymousLogonToken)
#pragma alloc_text(INIT,SeMakeAnonymousLogonTokenNoEveryone)
#pragma alloc_text(PAGE,SeSubProcessToken)
#pragma alloc_text(INIT,SepTokenInitialization)
#pragma alloc_text(PAGE,NtCreateToken)
#pragma alloc_text(PAGE,SepTokenDeleteMethod)
#pragma alloc_text(PAGE,SepCreateToken)
#pragma alloc_text(PAGE,SepIdAssignableAsOwner)
#pragma alloc_text(PAGE,SeIsChildToken)
#pragma alloc_text(PAGE,SeIsChildTokenByPointer)
#pragma alloc_text(PAGE,SeIsSiblingToken)
#pragma alloc_text(PAGE,SeIsSiblingTokenByPointer)
#pragma alloc_text(PAGE,NtImpersonateAnonymousToken)
#pragma alloc_text(PAGE,NtCompareTokens)
#pragma alloc_text(PAGE,SepComparePrivilegeAndAttributeArrays)
#pragma alloc_text(PAGE,SepCompareSidAndAttributeArrays)
#pragma alloc_text(PAGE,SeAddSaclToProcess)
#endif


////////////////////////////////////////////////////////////////////////
//                                                                    //
//           Global Variables                                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////


//
// Generic mapping of access types
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#pragma const_seg("INITCONST")
#endif

const GENERIC_MAPPING SepTokenMapping = { TOKEN_READ,
                                    TOKEN_WRITE,
                                    TOKEN_EXECUTE,
                                    TOKEN_ALL_ACCESS
                                  };

//
// Address of token object type descriptor.
//

POBJECT_TYPE SeTokenObjectType = NULL;


//
// Used to track whether or not a system token has been created or not.
//

#if DBG
BOOLEAN SystemTokenCreated = FALSE;
#endif //DBG


//
// Used to control the active token diagnostic support provided
//

#ifdef    TOKEN_DIAGNOSTICS_ENABLED
ULONG TokenGlobalFlag = 0;
#endif // TOKEN_DIAGNOSTICS_ENABLED




////////////////////////////////////////////////////////////////////////
//                                                                    //
//           Token Object Routines & Methods                          //
//                                                                    //
////////////////////////////////////////////////////////////////////////




TOKEN_TYPE
SeTokenType(
    __in PACCESS_TOKEN Token
    )

/*++

Routine Description:

    This function returns the type of an instance of a token (TokenPrimary,
    or TokenImpersonation).


Arguments:

    Token - Points to the token whose type is to be returned.

Return Value:

    The token's type.

--*/

{
    PAGED_CODE();

    return (((PTOKEN)Token)->TokenType);
}



NTKERNELAPI
BOOLEAN
SeTokenIsAdmin(
    __in PACCESS_TOKEN Token
    )

/*++

Routine Description:

    Returns if the token is a member of the local admin group.

Arguments:

    Token - Points to the token.

Return Value:

    TRUE - Token contains the local admin group
    FALSE - no admin.

--*/

{
    PAGED_CODE();

    return ((((PTOKEN)Token)->TokenFlags & TOKEN_HAS_ADMIN_GROUP) != 0 );
}


NTKERNELAPI
NTSTATUS
SeTokenCanImpersonate(
    __in PACCESS_TOKEN ProcessToken,
    __in PACCESS_TOKEN Token,
    __in SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )

/*++

Routine Description:

    Determines if the process token is allowed to impersonate the 
    second token, assuming that the access rights check has already passed.
    
Arguments:

    Token - Points to the token.

Return Value:

    TRUE - Token contains the local admin group
    FALSE - no admin.

--*/

{
    PTOKEN PrimaryToken = (PTOKEN) ProcessToken ;
    PTOKEN ImpToken = (PTOKEN) Token ;
    PSID PrimaryUserSid ;
    PSID ImpUserSid ;
    NTSTATUS Status ;

    PAGED_CODE();

    if ( ImpersonationLevel < SecurityImpersonation )
    {
        return STATUS_SUCCESS ;
    }

    //
    // allow impersonating anonymous tokens
    //

    if (RtlEqualLuid(&ImpToken->AuthenticationId, &SeAnonymousAuthenticationId)) 
    {
        return STATUS_SUCCESS ;
    }

    SepAcquireTokenReadLock( PrimaryToken );

    if ((PrimaryToken->TokenFlags & TOKEN_HAS_IMPERSONATE_PRIVILEGE) != 0 )
    {
        SepReleaseTokenReadLock( PrimaryToken );

        return STATUS_SUCCESS ;
    }

    SepAcquireTokenReadLock( ImpToken );

    Status = STATUS_PRIVILEGE_NOT_HELD ;

    if ( RtlEqualLuid( &PrimaryToken->AuthenticationId, &ImpToken->OriginatingLogonSession ) )
    {
        Status = STATUS_SUCCESS ;

    }
    else
    {
        PrimaryUserSid = PrimaryToken->UserAndGroups[0].Sid ;
        ImpUserSid = ImpToken->UserAndGroups[0].Sid ;

        if ( RtlEqualSid( PrimaryUserSid, ImpUserSid ) )
        {
            //
            // The tokens are representing the same user.  If the primary token
            // is restricted and the impersonation token is not, then the process
            // is attempting to elevate to the nonrestricted version of itself.  Do
            // not allow this.
            //
            if (SeTokenIsRestricted(PrimaryToken) && !SeTokenIsRestricted(ImpToken) ) {
                Status = STATUS_PRIVILEGE_NOT_HELD;
            } else {
                Status = STATUS_SUCCESS ;
            }

        }

    }

    SepReleaseTokenReadLock( ImpToken );
    SepReleaseTokenReadLock( PrimaryToken );

#if DBG
    if ( !NT_SUCCESS( Status ) )
    {
        DbgPrint( "Process %x.%x not allowed to impersonate!  Returning %x\n", PsGetCurrentThread()->Cid.UniqueProcess,
            PsGetCurrentThread()->Cid.UniqueThread, Status );
        
    }
#endif 

    return Status ;
}



NTKERNELAPI
BOOLEAN
SeTokenIsRestricted(
    __in PACCESS_TOKEN Token
    )

/*++

Routine Description:

    Returns if the token is a restricted token.

Arguments:

    Token - Points to the token.

Return Value:

    TRUE - Token contains restricted sids
    FALSE - no admin.

--*/

{
    PAGED_CODE();

    return ((((PTOKEN)Token)->TokenFlags & TOKEN_IS_RESTRICTED) != 0 );
}



SECURITY_IMPERSONATION_LEVEL
SeTokenImpersonationLevel(
    __in PACCESS_TOKEN Token
    )

/*++

Routine Description:

    This function returns the impersonation level of a token.  The token
    is assumed to be a TokenImpersonation type token.


Arguments:

    Token - Points to the token whose impersonation level is to be returned.

Return Value:

    The token's impersonation level.

--*/

{
    PAGED_CODE();

    return ((PTOKEN)Token)->ImpersonationLevel;
}


BOOLEAN
SepCheckTokenForCoreSystemSids(
    __in PACCESS_TOKEN Token
    )
/*++

Routine Description:

    Perform an access-check against SepImportantProcessSd to
    determine if the passed token has at least one of the sids present
    in the ACEs of SepImportantProcessSd.

Arguments:

    Token - a token

Return Value:

    TRUE if Token has at least one of the required SIDs,
    FALSE otherwise

Notes:

--*/
{
    ACCESS_MASK GrantedAccess = 0;
    NTSTATUS AccessStatus = STATUS_ACCESS_DENIED;
    
    PAGED_CODE();
    
    (void) SepAccessCheck(
               SepImportantProcessSd,
               NULL,
               Token,
               NULL,
               SEP_QUERY_MEMBERSHIP,
               NULL,
               0,
               &GenericMappingForMembershipCheck,
               0,
               KernelMode,
               &GrantedAccess,
               NULL,
               &AccessStatus,
               0,
               NULL,
               NULL
               );

    return AccessStatus == STATUS_SUCCESS;
}


VOID
SeAddSaclToProcess(
    __in PEPROCESS Process,
    __in PACCESS_TOKEN Token,
    __in PVOID Reserved
    )
/*++

Routine Description:

    If 'Token' has at least one of the sids present in the ACEs
    of SepImportantProcessSd, add a SACL to the security descriptor
    of 'Process' as defined by SepProcessAuditSd.

Arguments:

    Process - process to add SACL to

    Token - token to examine

Return Value:

    None

Notes:

--*/
{
    NTSTATUS Status;
    SECURITY_INFORMATION SecurityInformationSacl = SACL_SECURITY_INFORMATION;
    POBJECT_HEADER ObjectHeader;

    PAGED_CODE();


    // quickly return if this feature is disabled
    // (indicated by SeProcessAuditSd == NULL)
    //

    if ( SepProcessAuditSd == NULL ) {
        return;
    }

    //
    // if the token does not have core system sids then return
    // without adding SACL.
    // (see comment on SepImportantProcessSd in seglobal.c for more info)
    //

    if (!SepCheckTokenForCoreSystemSids( Token )) {
        return;
    }
    
    ObjectHeader = OBJECT_TO_OBJECT_HEADER( Process );

    //
    // add SACL to existing security descriptor on 'Process'
    //

    Status = ObSetSecurityDescriptorInfo(
                 Process,
                 &SecurityInformationSacl,
                 SepProcessAuditSd,
                 &ObjectHeader->SecurityDescriptor,
                 NonPagedPool,
                 &ObjectHeader->Type->TypeInfo.GenericMapping
                 );

    if (!NT_SUCCESS( Status )) {

        //
        // STATUS_NO_SECURITY_ON_OBJECT should be returned only once during
        // boot when the initial system process is created.
        //

        if ( Status != STATUS_NO_SECURITY_ON_OBJECT ) {
            
            ASSERT( L"SeAddSaclToProcess: ObSetSecurityDescriptorInfo failed" &&
                    FALSE );

            //
            // this will bugcheck if SepCrashOnAuditFail is TRUE
            //

            SepAuditFailed( Status );
        }
    }
}


VOID
SeAssignPrimaryToken(
    __in PEPROCESS Process,
    __in PACCESS_TOKEN Token
    )


/*++

Routine Description:

    This function establishes a primary token for a process.

Arguments:

    Token - Points to the new primary token.

Return Value:

    None.

--*/

{
    NTSTATUS
        Status;

    PTOKEN
        NewToken = (PTOKEN)Token;

    PAGED_CODE();

    ASSERT(NewToken->TokenType == TokenPrimary);
    ASSERT( !NewToken->TokenInUse );


    //
    // audit the assignment of a primary token, if requested
    //

    if (SeDetailedAuditingWithToken(NULL)) {
        SepAuditAssignPrimaryToken( Process, Token );
    }

    //
    // If the token being assigned to the child process has
    // any one of the following SIDs, then the process
    // is considered to be a system process:
    // -- SeLocalSystemSid
    // -- SeLocalServiceSid
    // -- SeNetworkServiceSid
    //
    // For such a process, add SACL to its security descriptor
    // if that option is enabled. If the option is disabled,
    // this function returns very quickly.
    //

    //
    // Dereference the old token if there is one.
    //
    // Processes typically already have a token that must be
    // dereferenced.  There are two cases where this may not
    // be the situation.  First, during phase 0 system initialization,
    // the initial system process starts out without a token.  Second,
    // if an error occurs during process creation, we may be cleaning
    // up a process that hasn't yet had a primary token assigned.
    //

    if (!ExFastRefObjectNull (Process->Token)) {
        SeDeassignPrimaryToken( Process );
    }

    ObReferenceObject(NewToken);
    NewToken->TokenInUse = TRUE;

    ObInitializeFastReference (&Process->Token, Token);
    return;
}



VOID
SeDeassignPrimaryToken(
    __in PEPROCESS Process
    )


/*++

Routine Description:

    This function causes a process reference to a token to be
    dropped.

Arguments:

    Process - Points to the process whose primary token is no longer needed.
        This is probably only the case at process deletion or when
        a primary token is being replaced.

Return Value:

    None.

--*/

{

    PTOKEN
        OldToken = (PTOKEN) ObFastReplaceObject (&Process->Token, NULL);

    PAGED_CODE();

    ASSERT(OldToken->TokenType == TokenPrimary);
    ASSERT(OldToken->TokenInUse);

    OldToken->TokenInUse = FALSE;
    ObDereferenceObject( OldToken );


    return;
}



NTSTATUS
SeExchangePrimaryToken(
    __in PEPROCESS Process,
    __in PACCESS_TOKEN NewAccessToken,
    __deref_out PACCESS_TOKEN *OldAccessToken
    )


/*++

Routine Description:

    This function is used to perform the portions of changing a primary
    token that reference the internals of token structures.

    The new token is checked to make sure it is not already in use.


Arguments:

    Process - Points to the process whose primary token is being exchanged.

    NewAccessToken - Points to the process's new primary token.

    OldAccessToken - Receives a pointer to the process's current token.
        The caller is responsible for dereferencing this token when
        it is no longer needed.  This can't be done while the process
        security locks are held.


Return Value:

    STATUS_SUCCESS - Everything has been updated.

    STATUS_TOKEN_ALREADY_IN_USE - A primary token can only be used by a
        single process.  That is, each process must have its own primary
        token.  The token passed to  be assigned as the primary token is
        already in use as a primary token.

    STATUS_BAD_TOKEN_TYPE - The new token is not a primary token.

    STATUS_NO_TOKEN - The process did not have any existing token. This should never happen.

--*/

{
    NTSTATUS
        Status;

    PTOKEN
        OldToken;

    PTOKEN
        NewToken = (PTOKEN)NewAccessToken;

    ULONG SessionId;

    PAGED_CODE();


    //
    // Make sure the new token is a primary token...
    //

    if (NewToken->TokenType != TokenPrimary) {
        return (STATUS_BAD_TOKEN_TYPE);
    }

    SessionId = MmGetSessionId (Process);

    //
    // Lock the new token so we can atomically test and set the InUse flag
    //

    SepAcquireTokenWriteLock (NewToken);

    //
    // and that it is not already in use...
    //

    if (NewToken->TokenInUse) {
        SepReleaseTokenWriteLock (NewToken, FALSE);
        return (STATUS_TOKEN_ALREADY_IN_USE);
    }

    NewToken->TokenInUse = TRUE;

    //
    // Ensure SessionId consistent for hydra
    //

    NewToken->SessionId = SessionId;

    SepReleaseTokenWriteLock (NewToken, FALSE);

    //
    // audit the assignment of a primary token, if requested
    //

    if (SeDetailedAuditingWithToken (NULL)) {
        SepAuditAssignPrimaryToken (Process, NewToken);
    }

    //
    // If the token being assigned to this process has
    // any one of the following SIDs, then the process
    // is considered to be a system process:
    // -- SeLocalSystemSid
    // -- SeLocalServiceSid
    // -- SeNetworkServiceSid
    //

    //
    // Switch the tokens
    //

    ObReferenceObject (NewToken);

    OldToken = ObFastReplaceObject (&Process->Token, NewToken);

    if (NULL == OldToken){
        return (STATUS_NO_TOKEN);
    }

    ASSERT (OldToken->TokenType == TokenPrimary);

    //
    // Lock the old token to clkear the InUse flag
    //

    SepAcquireTokenWriteLock (OldToken);

    ASSERT (OldToken->TokenInUse);

    //
    // Mark the token as "NOT USED"
    //

    OldToken->TokenInUse = FALSE;

    SepReleaseTokenWriteLock (OldToken, FALSE);

    //
    // Return the pointer to the old token.  The caller
    // is responsible for dereferencing it if they don't need it.
    //

    (*OldAccessToken) = OldToken;

    return (STATUS_SUCCESS);
}





VOID
SeGetTokenControlInformation (
    __in PACCESS_TOKEN Token,
    __out PTOKEN_CONTROL TokenControl
    )

/*++

Routine Description:

    This routine is provided for communication session layers, or
    any other executive component that needs to keep track of
    whether a caller's security context has changed between calls.
    Communication session layers will need to check this, for some
    security quality of service modes, to determine whether or not
    a server's security context needs to be updated to reflect
    changes in the client's security context.

    This routine will also be useful to communications subsystems
    that need to retrieve client' authentication information from
    the local security authority in order to perform a remote
    authentication.


Parameters:

    Token - Points to the token whose information is to be retrieved.

    TokenControl - Points to the buffer to receive the token control
        information.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // Fetch readonly fields outside of the lock.
    //

    TokenControl->AuthenticationId = ((TOKEN *)Token)->AuthenticationId;
    TokenControl->TokenId = ((TOKEN *)Token)->TokenId;
    TokenControl->TokenSource = ((TOKEN *)Token)->TokenSource;

    //
    //  Acquire shared access to the token
    //

    SepAcquireTokenReadLock( (PTOKEN)Token );

    //
    //  Fetch data that may change
    //

    TokenControl->ModifiedId = ((TOKEN *)Token)->ModifiedId;

    SepReleaseTokenReadLock( (PTOKEN)Token );

    return;

}

PACCESS_TOKEN
SeMakeSystemToken ()

/*++

Routine Description:

    This routine is provided for use by executive components
    DURING SYSTEM INITIALIZATION ONLY.  It creates a token for
    use by system components.

    A system token has the following characteristics:

         - It has LOCAL_SYSTEM as its user ID

         - It has the following groups with the corresponding
           attributes:

               ADMINS_ALIAS      EnabledByDefault |
                                 Enabled          |
                                 Owner

               WORLD             EnabledByDefault |
                                 Enabled          |
                                 Mandatory

               ADMINISTRATORS (alias)  Owner   (disabled)

               AUTHENTICATED_USER
                                EnabledByDefault  |
                                Enabled           |
                                Mandatory


         - It has LOCAL_SYSTEM as its primary group.

         - It has the privileges shown in comments below.


         - It has protection that provides TOKEN_ALL_ACCESS to
           the LOCAL_SYSTEM ID.


         - It has a default ACL that grants GENERIC_ALL access
           to LOCAL_SYSTEM and GENERIC_EXECUTE to WORLD.


Parameters:

    None.

Return Value:

    Pointer to a system token.

--*/

{
    NTSTATUS Status;

    PVOID Token;

    SID_AND_ATTRIBUTES UserId;
    TOKEN_PRIMARY_GROUP PrimaryGroup;
    PSID_AND_ATTRIBUTES GroupIds;
    ULONG GroupIdsLength;
    LUID_AND_ATTRIBUTES Privileges[30];
    PACL TokenAcl;
    PSID Owner;
    ULONG NormalGroupAttributes;
    ULONG OwnerGroupAttributes;
    ULONG Length;
    OBJECT_ATTRIBUTES TokenObjectAttributes;
    PSECURITY_DESCRIPTOR TokenSecurityDescriptor;
    ULONG BufferLength;
    PVOID Buffer;

    ULONG_PTR GroupIdsBuffer[128 * sizeof(ULONG) / sizeof(ULONG_PTR)];

    TIME_FIELDS TimeFields;
    LARGE_INTEGER NoExpiration;

    PAGED_CODE();


    //
    // Make sure only one system token gets created.
    //

#if DBG
    ASSERT( !SystemTokenCreated );
    SystemTokenCreated = TRUE;
#endif //DBG


    //
    // Set up expiration times
    //

    TimeFields.Year = 3000;
    TimeFields.Month = 1;
    TimeFields.Day = 1;
    TimeFields.Hour = 1;
    TimeFields.Minute = 1;
    TimeFields.Second = 1;
    TimeFields.Milliseconds = 1;
    TimeFields.Weekday = 1;

    RtlTimeFieldsToTime( &TimeFields, &NoExpiration );


//    //
//    //  The amount of memory used in the following is gross overkill, but
//    //  it is freed up immediately after creating the token.
//    //
//
//    GroupIds = (PSID_AND_ATTRIBUTES)ExAllocatePool( NonPagedPool, 512 );

    GroupIds = (PSID_AND_ATTRIBUTES)GroupIdsBuffer;


    //
    // Set up the attributes to be assigned to groups
    //

    NormalGroupAttributes =    (SE_GROUP_MANDATORY          |
                                SE_GROUP_ENABLED_BY_DEFAULT |
                                SE_GROUP_ENABLED
                                );

    OwnerGroupAttributes  =    (SE_GROUP_ENABLED_BY_DEFAULT |
                                SE_GROUP_ENABLED            |
                                SE_GROUP_OWNER
                                );

    //
    // Set up the user ID
    //

    UserId.Sid = SeLocalSystemSid;
    UserId.Attributes = 0;

    //
    // Set up the groups
    //


    GroupIds->Sid  = SeAliasAdminsSid;
    (GroupIds+1)->Sid  = SeWorldSid;
    (GroupIds+2)->Sid  = SeAuthenticatedUsersSid;

    GroupIds->Attributes  = OwnerGroupAttributes;
    (GroupIds+1)->Attributes  = NormalGroupAttributes;
    (GroupIds+2)->Attributes  = NormalGroupAttributes;

    GroupIdsLength = (ULONG)LongAlignSize(SeLengthSid(GroupIds->Sid)) +
                     (ULONG)LongAlignSize(SeLengthSid((GroupIds+1)->Sid)) +
                     (ULONG)LongAlignSize(SeLengthSid((GroupIds+2)->Sid)) +
                     sizeof(SID_AND_ATTRIBUTES);

    ASSERT( GroupIdsLength <= 128 * sizeof(ULONG) );


    //
    // Privileges
    //

    //
    // The privileges in the system token are as follows:
    //
    //    Privilege Name                           Attributes
    //    --------------                           ----------
    //
    // SeTcbPrivilege                        enabled/enabled by default
    // SeCreateTokenPrivilege                DISabled/NOT enabled by default
    // SeTakeOwnershipPrivilege              DISabled/NOT enabled by default
    // SeCreatePagefilePrivilege             enabled/enabled by default
    // SeLockMemoryPrivilege                 enabled/enabled by default
    // SeAssignPrimaryTokenPrivilege         DISabled/NOT enabled by default
    // SeIncreaseQuotaPrivilege              DISabled/NOT enabled by default
    // SeIncreaseBasePriorityPrivilege       enabled/enabled by default
    // SeCreatePermanentPrivilege            enabled/enabled by default
    // SeDebugPrivilege                      enabled/enabled by default
    // SeAuditPrivilege                      enabled/enabled by default
    // SeSecurityPrivilege                   DISabled/NOT enabled by default
    // SeSystemEnvironmentPrivilege          DISabled/NOT enabled by default
    // SeChangeNotifyPrivilege               enabled/enabled by default
    // SeBackupPrivilege                     DISabled/NOT enabled by default
    // SeRestorePrivilege                    DISabled/NOT enabled by default
    // SeShutdownPrivilege                   DISabled/NOT enabled by default
    // SeLoadDriverPrivilege                 DISabled/NOT enabled by default
    // SeProfileSingleProcessPrivilege       enabled/enabled by default
    // SeSystemtimePrivilege                 DISabled/NOT enabled by default
    // SeUndockPrivilege                     DISabled/NOT enabled by default
    //
    // The following privileges are not present, and should never be present in
    // the local system token:
    //
    // SeRemoteShutdownPrivilege             no one can come in as local system
    // SeSyncAgentPrivilege                  only users specified by the admin can
    //                                       be sync agents
    // SeEnableDelegationPrivilege           only users specified by the admin can
    //                                       enable delegation on accounts.
    //

    Privileges[0].Luid = SeTcbPrivilege;
    Privileges[0].Attributes =
        (SE_PRIVILEGE_ENABLED_BY_DEFAULT |    // Enabled by default
         SE_PRIVILEGE_ENABLED);               // Enabled

    Privileges[1].Luid = SeCreateTokenPrivilege;
    Privileges[1].Attributes = 0;     // Only the LSA should enable this.

    Privileges[2].Luid = SeTakeOwnershipPrivilege;
    Privileges[2].Attributes = 0;

    Privileges[3].Luid = SeCreatePagefilePrivilege;
    Privileges[3].Attributes =
        (SE_PRIVILEGE_ENABLED_BY_DEFAULT |    // Enabled by default
         SE_PRIVILEGE_ENABLED);               // Enabled

    Privileges[4].Luid = SeLockMemoryPrivilege;
    Privileges[4].Attributes =
        (SE_PRIVILEGE_ENABLED_BY_DEFAULT |    // Enabled by default
         SE_PRIVILEGE_ENABLED);               // Enabled

    Privileges[5].Luid = SeAssignPrimaryTokenPrivilege;
    Privileges[5].Attributes = 0;    // disabled, not enabled by default

    Privileges[6].Luid = SeIncreaseQuotaPrivilege;
    Privileges[6].Attributes = 0;    // disabled, not enabled by default

    Privileges[7].Luid = SeIncreaseBasePriorityPrivilege;
    Privileges[7].Attributes =
        (SE_PRIVILEGE_ENABLED_BY_DEFAULT |    // Enabled by default
         SE_PRIVILEGE_ENABLED);               // Enabled

    Privileges[8].Luid = SeCreatePermanentPrivilege;
    Privileges[8].Attributes =
        (SE_PRIVILEGE_ENABLED_BY_DEFAULT |    // Enabled by default
         SE_PRIVILEGE_ENABLED);               // Enabled

    Privileges[9].Luid = SeDebugPrivilege;
    Privileges[9].Attributes =
        (SE_PRIVILEGE_ENABLED_BY_DEFAULT |   // Enabled by default
         SE_PRIVILEGE_ENABLED);               // Enabled

    Privileges[10].Luid = SeAuditPrivilege;
    Privileges[10].Attributes =
        (SE_PRIVILEGE_ENABLED_BY_DEFAULT |    // Enabled by default
         SE_PRIVILEGE_ENABLED);               // Enabled

    Privileges[11].Luid = SeSecurityPrivilege;
    Privileges[11].Attributes = 0;    // disabled, not enabled by default

    Privileges[12].Luid = SeSystemEnvironmentPrivilege;
    Privileges[12].Attributes = 0;    // disabled, not enabled by default

    Privileges[13].Luid = SeChangeNotifyPrivilege;
    Privileges[13].Attributes =
        (SE_PRIVILEGE_ENABLED_BY_DEFAULT |    // Enabled by default
         SE_PRIVILEGE_ENABLED);               // Enabled


    Privileges[14].Luid = SeBackupPrivilege;
    Privileges[14].Attributes = 0;    // disabled, not enabled by default

    Privileges[15].Luid = SeRestorePrivilege;
    Privileges[15].Attributes = 0;    // disabled, not enabled by default

    Privileges[16].Luid = SeShutdownPrivilege;
    Privileges[16].Attributes = 0;    // disabled, not enabled by default

    Privileges[17].Luid = SeLoadDriverPrivilege;
    Privileges[17].Attributes = 0;    // disabled, not enabled by default

    Privileges[18].Luid = SeProfileSingleProcessPrivilege;
    Privileges[18].Attributes =
        (SE_PRIVILEGE_ENABLED_BY_DEFAULT |    // Enabled by default
         SE_PRIVILEGE_ENABLED);               // Enabled

    Privileges[19].Luid = SeSystemtimePrivilege;
    Privileges[19].Attributes = 0;    // disabled, not enabled by default

    Privileges[20].Luid = SeUndockPrivilege ;
    Privileges[20].Attributes = 0 ;   // disabled, not enabled by default

    Privileges[21].Luid = SeManageVolumePrivilege ;
    Privileges[21].Attributes = 0 ;   // disabled, not enabled by default

    Privileges[22].Luid = SeImpersonatePrivilege ;
    Privileges[22].Attributes = 
        (SE_PRIVILEGE_ENABLED_BY_DEFAULT |
         SE_PRIVILEGE_ENABLED);

    Privileges[23].Luid = SeCreateGlobalPrivilege ;
    Privileges[23].Attributes = 
        (SE_PRIVILEGE_ENABLED_BY_DEFAULT |
         SE_PRIVILEGE_ENABLED );

    //BEFORE ADDING ANOTHER PRIVILEGE ^^ HERE ^^ CHECK THE ARRAY BOUND
    //ALSO INCREMENT THE PRIVILEGE COUNT IN THE SepCreateToken() call


    //
    // Establish the primary group and default owner
    //

    PrimaryGroup.PrimaryGroup = SeLocalSystemSid;  // Primary group
    Owner = SeAliasAdminsSid;                      // Default owner





    //
    // Set up an ACL to protect token as well ...
    // give system full reign of terror.  This includes user-mode components
    // running as part of the system.
    //

    Length = (ULONG)sizeof(ACL) +
             ((ULONG)sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG)) +
             SeLengthSid( SeLocalSystemSid ) ;

    TokenAcl = (PACL)ExAllocatePoolWithTag(PagedPool, Length, 'cAeS');

    if ( TokenAcl == NULL ) {

        return NULL ;
    }

    Status = RtlCreateAcl( TokenAcl, Length, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAccessAllowedAce (
                 TokenAcl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 SeLocalSystemSid
                 );
    ASSERT( NT_SUCCESS(Status) );

    TokenSecurityDescriptor =
    (PSECURITY_DESCRIPTOR)ExAllocatePoolWithTag(
                              PagedPool,
                              sizeof(SECURITY_DESCRIPTOR),
                              'dSeS'
                              );

    if ( TokenSecurityDescriptor == NULL ) {

        ExFreePool( TokenAcl );

        return NULL ;
    }

    Status = RtlCreateSecurityDescriptor(
                 TokenSecurityDescriptor,
                 SECURITY_DESCRIPTOR_REVISION
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlSetDaclSecurityDescriptor (
                 TokenSecurityDescriptor,
                 TRUE,
                 TokenAcl,
                 FALSE
                 );
    ASSERT( NT_SUCCESS(Status) );


    Status = RtlSetOwnerSecurityDescriptor (
                 TokenSecurityDescriptor,
                 SeAliasAdminsSid,
                 FALSE // Owner defaulted
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlSetGroupSecurityDescriptor (
                 TokenSecurityDescriptor,
                 SeAliasAdminsSid,
                 FALSE // Group defaulted
                 );
    ASSERT( NT_SUCCESS(Status) );


    //
    // Create the system token
    //

    InitializeObjectAttributes(
        &TokenObjectAttributes,
        NULL,
        0,
        NULL,
        TokenSecurityDescriptor
        );



    ASSERT(SeSystemDefaultDacl != NULL);
    Status = SepCreateToken(
                 (PHANDLE)&Token,
                 KernelMode,
                 0,               // No handle created for system token
                 &TokenObjectAttributes,
                 TokenPrimary,
                 (SECURITY_IMPERSONATION_LEVEL)0,
                 (PLUID)&SeSystemAuthenticationId,
                 &NoExpiration,
                 &UserId,
                 3,                         // GroupCount
                 GroupIds,
                 GroupIdsLength,
                 24,                        // privileges
                 Privileges,
                 Owner,
                 PrimaryGroup.PrimaryGroup,
                 SeSystemDefaultDacl,
                 (PTOKEN_SOURCE)&SeSystemTokenSource,
                 TRUE,                        // System token
                 NULL,
                 NULL
                 );

     ASSERT(NT_SUCCESS(Status));

    //
    // We can free the old one now.
    //

    ExFreePool( TokenAcl );
    ExFreePool( TokenSecurityDescriptor );

    return  (PACCESS_TOKEN)Token;

}


PACCESS_TOKEN
SeMakeAnonymousLogonTokenNoEveryone (
    VOID
    )

/*++

Routine Description:

    This routine is provided for use by executive components
    DURING SYSTEM INITIALIZATION ONLY.  It creates a token for
    use by system components.

    A system token has the following characteristics:

         - It has ANONYMOUS_LOGON as its user ID

         - It has no privileges

         - It has protection that provides TOKEN_ALL_ACCESS to
           the WORLD ID.

         - It has a default ACL that grants GENERIC_ALL access
           to WORLD.


Parameters:

    None.

Return Value:

    Pointer to a system token.

--*/

{
    NTSTATUS Status;

    PVOID Token;

    SID_AND_ATTRIBUTES UserId;
    TOKEN_PRIMARY_GROUP PrimaryGroup;
    PACL TokenAcl;
    PSID Owner;
    ULONG Length;
    OBJECT_ATTRIBUTES TokenObjectAttributes;
    PSECURITY_DESCRIPTOR TokenSecurityDescriptor;

    TIME_FIELDS TimeFields;
    LARGE_INTEGER NoExpiration;

    PAGED_CODE();

    //
    // Set up expiration times
    //

    TimeFields.Year = 3000;
    TimeFields.Month = 1;
    TimeFields.Day = 1;
    TimeFields.Hour = 1;
    TimeFields.Minute = 1;
    TimeFields.Second = 1;
    TimeFields.Milliseconds = 1;
    TimeFields.Weekday = 1;

    RtlTimeFieldsToTime( &TimeFields, &NoExpiration );

    //
    // Set up the user ID
    //

    UserId.Sid = SeAnonymousLogonSid;
    UserId.Attributes = 0;

    //
    // Establish the primary group and default owner
    //

    PrimaryGroup.PrimaryGroup = SeAnonymousLogonSid;  // Primary group

    //
    // Set up an ACL to protect token as well ...
    // Let everyone read/write.  However, the token is dup'ed before we given
    // anyone a handle to it.
    //

    Length = (ULONG)sizeof(ACL) +
             (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
             SeLengthSid( SeWorldSid ) +
             (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
             SeLengthSid( SeAnonymousLogonSid );
    ASSERT( Length < 200 );

    TokenAcl = (PACL)ExAllocatePoolWithTag(PagedPool, 200, 'cAeS');

    if ( !TokenAcl ) {

        return NULL ;
    }

    Status = RtlCreateAcl( TokenAcl, Length, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAccessAllowedAce (
                 TokenAcl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 SeWorldSid
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAccessAllowedAce (
                 TokenAcl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 SeAnonymousLogonSid
                 );
    ASSERT( NT_SUCCESS(Status) );

    TokenSecurityDescriptor =
    (PSECURITY_DESCRIPTOR)ExAllocatePoolWithTag(
                              PagedPool,
                              SECURITY_DESCRIPTOR_MIN_LENGTH,
                              'dSeS'
                              );

    if ( !TokenSecurityDescriptor ) {

        ExFreePool( TokenAcl );

        return NULL ;
    }

    Status = RtlCreateSecurityDescriptor(
                 TokenSecurityDescriptor,
                 SECURITY_DESCRIPTOR_REVISION
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlSetDaclSecurityDescriptor (
                 TokenSecurityDescriptor,
                 TRUE,
                 TokenAcl,
                 FALSE
                 );
    ASSERT( NT_SUCCESS(Status) );


    Status = RtlSetOwnerSecurityDescriptor (
                 TokenSecurityDescriptor,
                 SeWorldSid,
                 FALSE // Owner defaulted
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlSetGroupSecurityDescriptor (
                 TokenSecurityDescriptor,
                 SeWorldSid,
                 FALSE // Group defaulted
                 );
    ASSERT( NT_SUCCESS(Status) );

    //
    // Create the system token
    //

    InitializeObjectAttributes(
        &TokenObjectAttributes,
        NULL,
        0,
        NULL,
        TokenSecurityDescriptor
        );

    Status = SepCreateToken(
                 (PHANDLE)&Token,
                 KernelMode,
                 0,               // No handle created for system token
                 &TokenObjectAttributes,
                 TokenPrimary,
                 (SECURITY_IMPERSONATION_LEVEL)0,
                 (PLUID)&SeAnonymousAuthenticationId,
                 &NoExpiration,
                 &UserId,
                 0,                         // GroupCount
                 NULL,                      // Group IDs
                 0,                         // Group byte count
                 0,                         // no privileges
                 NULL,                      // no Privileges,
                 NULL,
                 PrimaryGroup.PrimaryGroup,
                 TokenAcl,
                 (PTOKEN_SOURCE)&SeSystemTokenSource,
                 TRUE,                        // System token
                 NULL,
                 NULL
                 );

     ASSERT(NT_SUCCESS(Status));

    //
    // We can free the old one now.
    //

    ExFreePool( TokenAcl );
    ExFreePool( TokenSecurityDescriptor );

    return  (PACCESS_TOKEN)Token;

}


PACCESS_TOKEN
SeMakeAnonymousLogonToken (
    VOID
    )

/*++

Routine Description:

    This routine is provided for use by executive components
    DURING SYSTEM INITIALIZATION ONLY.  It creates a token for
    use by system components.

    A system token has the following characteristics:

         - It has ANONYMOUS_LOGON as its user ID

         - It has the following groups with the corresponding
           attributes:


               WORLD             EnabledByDefault |
                                 Enabled          |
                                 Mandatory

         - It has WORLD as its primary group.

         - It has no privileges

         - It has protection that provides TOKEN_ALL_ACCESS to
           the WORLD ID.

         - It has a default ACL that grants GENERIC_ALL access
           to WORLD.


Parameters:

    None.

Return Value:

    Pointer to a system token.

--*/

{
    NTSTATUS Status;

    PVOID Token;

    SID_AND_ATTRIBUTES UserId;
    PSID_AND_ATTRIBUTES GroupIds;
    TOKEN_PRIMARY_GROUP PrimaryGroup;
    ULONG GroupIdsLength;
    PACL TokenAcl;
    PSID Owner;
    ULONG NormalGroupAttributes;
    ULONG Length;
    OBJECT_ATTRIBUTES TokenObjectAttributes;
    PSECURITY_DESCRIPTOR TokenSecurityDescriptor;

    ULONG_PTR GroupIdsBuffer[128 * sizeof(ULONG) / sizeof(ULONG_PTR)];

    TIME_FIELDS TimeFields;
    LARGE_INTEGER NoExpiration;

    PAGED_CODE();

    //
    // Set up expiration times
    //

    TimeFields.Year = 3000;
    TimeFields.Month = 1;
    TimeFields.Day = 1;
    TimeFields.Hour = 1;
    TimeFields.Minute = 1;
    TimeFields.Second = 1;
    TimeFields.Milliseconds = 1;
    TimeFields.Weekday = 1;

    RtlTimeFieldsToTime( &TimeFields, &NoExpiration );

    GroupIds = (PSID_AND_ATTRIBUTES)GroupIdsBuffer;

    //
    // Set up the attributes to be assigned to groups
    //

    NormalGroupAttributes =    (SE_GROUP_MANDATORY          |
                                SE_GROUP_ENABLED_BY_DEFAULT |
                                SE_GROUP_ENABLED
                                );

    //
    // Set up the user ID
    //

    UserId.Sid = SeAnonymousLogonSid;
    UserId.Attributes = 0;

    //
    // Set up the groups
    //

    GroupIds->Sid  = SeWorldSid;
    GroupIds->Attributes = NormalGroupAttributes;


    GroupIdsLength = (ULONG)LongAlignSize(SeLengthSid(GroupIds->Sid)) +
                                                    sizeof(SID_AND_ATTRIBUTES);

    ASSERT( GroupIdsLength <= 128 * sizeof(ULONG) );

    //
    // Establish the primary group and default owner
    //

    PrimaryGroup.PrimaryGroup = SeAnonymousLogonSid;  // Primary group

    //
    // Set up an ACL to protect token as well ...
    // give system full reign of terror.  This includes user-mode components
    // running as part of the system.
    // Let everyone read/write.  However, the token is dup'ed before we given
    // anyone a handle to it.
    //

    Length = (ULONG)sizeof(ACL) +
             (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
             SeLengthSid( SeWorldSid ) +
             (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
             SeLengthSid( SeAnonymousLogonSid );
    ASSERT( Length < 200 );

    TokenAcl = (PACL)ExAllocatePoolWithTag(PagedPool, 200, 'cAeS');

    if ( !TokenAcl ) {

        return NULL ;
    }

    Status = RtlCreateAcl( TokenAcl, Length, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAccessAllowedAce (
                 TokenAcl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 SeWorldSid
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAccessAllowedAce (
                 TokenAcl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 SeAnonymousLogonSid
                 );
    ASSERT( NT_SUCCESS(Status) );

    TokenSecurityDescriptor =
    (PSECURITY_DESCRIPTOR)ExAllocatePoolWithTag(
                              PagedPool,
                              SECURITY_DESCRIPTOR_MIN_LENGTH,
                              'dSeS'
                              );

    if ( !TokenSecurityDescriptor ) {

        ExFreePool( TokenAcl );

        return NULL ;
    }


    Status = RtlCreateSecurityDescriptor(
                 TokenSecurityDescriptor,
                 SECURITY_DESCRIPTOR_REVISION
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlSetDaclSecurityDescriptor (
                 TokenSecurityDescriptor,
                 TRUE,
                 TokenAcl,
                 FALSE
                 );
    ASSERT( NT_SUCCESS(Status) );


    Status = RtlSetOwnerSecurityDescriptor (
                 TokenSecurityDescriptor,
                 SeWorldSid,
                 FALSE // Owner defaulted
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlSetGroupSecurityDescriptor (
                 TokenSecurityDescriptor,
                 SeWorldSid,
                 FALSE // Group defaulted
                 );
    ASSERT( NT_SUCCESS(Status) );


    //
    // Create the system token
    //

    InitializeObjectAttributes(
        &TokenObjectAttributes,
        NULL,
        0,
        NULL,
        TokenSecurityDescriptor
        );



    Status = SepCreateToken(
                 (PHANDLE)&Token,
                 KernelMode,
                 0,               // No handle created for system token
                 &TokenObjectAttributes,
                 TokenPrimary,
                 (SECURITY_IMPERSONATION_LEVEL)0,
                 (PLUID)&SeAnonymousAuthenticationId,
                 &NoExpiration,
                 &UserId,
                 1,                         // GroupCount
                 GroupIds,
                 GroupIdsLength,
                 0,                         // no privileges
                 NULL,                      // no Privileges,
                 0,                         // no privileges
                 PrimaryGroup.PrimaryGroup,
                 TokenAcl,
                 (PTOKEN_SOURCE)&SeSystemTokenSource,
                 TRUE,                        // System token
                 NULL,
                 NULL
                 );

     ASSERT(NT_SUCCESS(Status));

    //
    // We can free the old one now.
    //

    ExFreePool( TokenAcl );
    ExFreePool( TokenSecurityDescriptor );

    return  (PACCESS_TOKEN)Token;

}


NTSTATUS
SeSubProcessToken (
    __in PACCESS_TOKEN ParentToken,
    __deref_out PACCESS_TOKEN *ChildToken,
    __in BOOLEAN MarkAsActive,
    __in ULONG SessionId
    )

/*++

Routine Description:

    This routine makes a token for a sub-process that is a duplicate
    of the parent process's token.



Parameters:

    ParentToken - Pointer to the parent token

    ChildToken - Receives a pointer to the child process's token.

    MarkAsActive - Mark the token as active

    SessionId - Create the token with this session ID

Return Value:

    STATUS_SUCCESS - Indicates the sub-process's token has been created
        successfully.

    Other status values may be returned from memory allocation or object
    creation services used and typically indicate insufficient resources
    or quota on the requestor's part.



--*/

{
    PTOKEN NewToken;
    OBJECT_ATTRIBUTES PrimaryTokenAttributes;

    NTSTATUS Status;
    NTSTATUS IgnoreStatus;

    PAGED_CODE();

    InitializeObjectAttributes(
        &PrimaryTokenAttributes,
        NULL,
        0,
        NULL,
        NULL
        );

    Status = SepDuplicateToken(
                ParentToken,                         // ExistingToken
                &PrimaryTokenAttributes,             // ObjectAttributes
                FALSE,                               // EffectiveOnly
                TokenPrimary,                        // TokenType
                (SECURITY_IMPERSONATION_LEVEL)0,     // ImpersonationLevel
                KernelMode,                          // RequestorMode
                &NewToken                            // NewToken
                );

    if (NT_SUCCESS(Status)) {

        NewToken->SessionId = SessionId;

        //
        // Insert the new token object, up its ref count but don't create a handle.
        //

        Status = ObInsertObject(
                     NewToken,
                     NULL,
                     0,
                     0,
                     NULL,
                     NULL);

        if (NT_SUCCESS(Status)) {

            NewToken->TokenInUse = MarkAsActive;
            *ChildToken = NewToken;

        } else {

            //
            // ObInsertObject dereferences the passed object if it
            // fails, so we don't have to do any cleanup on NewToken
            // here.
            //
        }
    }

    return Status;
}


BOOLEAN
SepTokenInitialization ( VOID )

/*++

Routine Description:

    This function creates the token object type descriptor at system
    initialization and stores the address of the object type descriptor
    in global storage.  It also created token related global variables.

    Furthermore, some number of pseudo tokens are created during system
    initialization.  These tokens are tracked down and replaced with
    real tokens.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the object type descriptor is
    successfully initialized. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    PAGED_CODE();

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Token");


    //
    // Create object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer,sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = SepTokenMapping;
    ObjectTypeInitializer.SecurityRequired = TRUE;
    ObjectTypeInitializer.UseDefaultObject = TRUE;
    ObjectTypeInitializer.PoolType = PagedPool;
    ObjectTypeInitializer.ValidAccessMask = TOKEN_ALL_ACCESS;
    ObjectTypeInitializer.DeleteProcedure = SepTokenDeleteMethod;

    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &SeTokenObjectType
                                );

    //
    // If the object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)NT_SUCCESS(Status);
}


NTSTATUS
NtCreateToken(
    __out PHANDLE TokenHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in TOKEN_TYPE TokenType,
    __in PLUID AuthenticationId,
    __in PLARGE_INTEGER ExpirationTime,
    __in PTOKEN_USER User,
    __in PTOKEN_GROUPS Groups,
    __in PTOKEN_PRIVILEGES Privileges,
    __in_opt PTOKEN_OWNER Owner,
    __in PTOKEN_PRIMARY_GROUP PrimaryGroup,
    __in_opt PTOKEN_DEFAULT_DACL DefaultDacl,
    __in PTOKEN_SOURCE TokenSource
    )

/*++

Routine Description:

    Create a token object and return a handle opened for access to
    that token.  This API requires SeCreateTokenPrivilege privilege.

Arguments:

    TokenHandle - Receives the handle of the newly created token.

    DesiredAccess - Is an access mask indicating which access types
        the handle is to provide to the new object.

    ObjectAttributes - Points to the standard object attributes data
        structure.  Refer to the NT Object Management
        Specification for a description of this data structure.

        If the token type is TokenImpersonation, then this parameter
        must specify the impersonation level of the token.

    TokenType - Type of token to be created.  Privilege is required
        to create any type of token.

    AuthenticationId - Points to a LUID (or LUID) providing a unique
        identifier associated with the authentication.  This is used
        within security only, for audit purposes.

    ExpirationTime - Time at which the token becomes invalid.  If this
        value is specified as zero, then the token has no expiration
        time.

    User - Is the user SID to place in the token.

    Groups - Are the group SIDs to place in the token. The API assumes that 
        the caller has not supplied duplicate group sids.

    Privileges - Are the privileges to place in the token. The API assumes that
        the caller has not supplied duplicate privileges.

    Owner - (Optionally) identifies an identifier that is to be used
        as the default owner for the token.  If not provided, the
        user ID is made the default owner.

    PrimaryGroup - Identifies which of the group IDs is to be the
        primary group of the token.

    DefaultDacl - (optionally) establishes an ACL to be used as the
        default discretionary access protection for the token.

    TokenSource - Identifies the token source name string and
        identifier to be assigned to the token.

Return Value:

    STATUS_SUCCESS - Indicates the operation was successful.

    STATUS_INVALID_OWNER - Indicates the ID provided to be assigned
        as the default owner of the token does not have an attribute
        indicating it may be assigned as an owner.

    STATUS_INVALID_PRIMARY_GROUP - Indicates the group ID provided
        via the PrimaryGroup parameter was not among those assigned
        to the token in the Groups parameter.

    STATUS_BAD_IMPERSONATION_LEVEL - Indicates no impersonation level
        was provided when attempting to create a token of type
        TokenImpersonation.

--*/

{

    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    ULONG Ignore;


    HANDLE LocalHandle = NULL;

    BOOLEAN SecurityQosPresent = FALSE;
    SECURITY_ADVANCED_QUALITY_OF_SERVICE CapturedSecurityQos;

    LUID CapturedAuthenticationId;
    LARGE_INTEGER CapturedExpirationTime;

    PSID_AND_ATTRIBUTES CapturedUser = NULL;
    ULONG CapturedUserLength = 0;

    ULONG CapturedGroupCount = 0;
    PSID_AND_ATTRIBUTES CapturedGroups = NULL;
    ULONG CapturedGroupsLength = 0;

    ULONG CapturedPrivilegeCount = 0;
    PLUID_AND_ATTRIBUTES CapturedPrivileges = NULL;
    ULONG CapturedPrivilegesLength = 0;

    PSID CapturedOwner = NULL;

    PSID CapturedPrimaryGroup = NULL;

    PACL CapturedDefaultDacl = NULL;

    TOKEN_SOURCE CapturedTokenSource;

    PVOID CapturedAddress;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        //
        // Probe everything necessary for input to the capture subroutines.
        //

        try {

            ProbeForWriteHandle(TokenHandle);


            ProbeForReadSmallStructure( ExpirationTime, sizeof(LARGE_INTEGER),    sizeof(ULONG) );
            ProbeForReadSmallStructure( Groups,         sizeof(TOKEN_GROUPS),     sizeof(ULONG) );
            ProbeForReadSmallStructure( Privileges,     sizeof(TOKEN_PRIVILEGES), sizeof(ULONG) );
            ProbeForReadSmallStructure( TokenSource,    sizeof(TOKEN_SOURCE),     sizeof(ULONG) );


            if ( ARGUMENT_PRESENT(Owner) ) {
                ProbeForReadSmallStructure( Owner, sizeof(TOKEN_OWNER), sizeof(ULONG) );
            }


            ProbeForReadSmallStructure(
                PrimaryGroup,
                sizeof(TOKEN_PRIMARY_GROUP),
                sizeof(ULONG)
                );


            if ( ARGUMENT_PRESENT(DefaultDacl) ) {
                ProbeForReadSmallStructure(
                    DefaultDacl,
                    sizeof(TOKEN_DEFAULT_DACL),
                    sizeof(ULONG)
                    );
             }

            ProbeForReadSmallStructure(
                AuthenticationId,
                sizeof(LUID),
                sizeof(ULONG)
                );

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }  // end_try

    } //end_if

    //
    // Make sure the TokenType is valid
    //

    if ( (TokenType < TokenPrimary) || (TokenType > TokenImpersonation) ) {
        return(STATUS_BAD_TOKEN_TYPE);
    }


    //
    //  Capture the security quality of service.
    //  This capture routine necessarily does some probing of its own.
    //

    Status = SeCaptureSecurityQos(
                 ObjectAttributes,
                 PreviousMode,
                 &SecurityQosPresent,
                 &CapturedSecurityQos
                 );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (TokenType == TokenImpersonation) {

        if (!SecurityQosPresent) {
            return STATUS_BAD_IMPERSONATION_LEVEL;
        } // endif

        //
        // Allow only valid impersonation levels.
        //

        switch (CapturedSecurityQos.ImpersonationLevel) {
        case SecurityAnonymous:
        case SecurityIdentification:
        case SecurityImpersonation:
        case SecurityDelegation:
            break;
        default:
            SeFreeCapturedSecurityQos( &CapturedSecurityQos );
            return STATUS_BAD_IMPERSONATION_LEVEL;
        }
    }

    //
    //  Capture the rest of the arguments.
    //  These arguments have already been probed.
    //

    try {

        Status = STATUS_SUCCESS;

        //
        //  Capture and validate AuthenticationID
        //

        RtlCopyLuid( &CapturedAuthenticationId, AuthenticationId );

        //
        //  Capture ExpirationTime
        //

        CapturedExpirationTime = (*ExpirationTime);

        //
        //  Capture User
        //

        if (NT_SUCCESS(Status)) {
            Status = SeCaptureSidAndAttributesArray(
                         &(User->User),
                         1,
                         PreviousMode,
                         NULL, 0,
                         PagedPool,
                         TRUE,
                         &CapturedUser,
                         &CapturedUserLength
                         );
        }


        //
        //  Capture Groups
        //

        if (NT_SUCCESS(Status)) {
            CapturedGroupCount = Groups->GroupCount;
            Status = SeCaptureSidAndAttributesArray(
                         (Groups->Groups),
                         CapturedGroupCount,
                         PreviousMode,
                         NULL, 0,
                         PagedPool,
                         TRUE,
                         &CapturedGroups,
                         &CapturedGroupsLength
                         );
        }


        //
        //  Capture Privileges
        //

        if (NT_SUCCESS(Status)) {
            CapturedPrivilegeCount = Privileges->PrivilegeCount;
            Status = SeCaptureLuidAndAttributesArray(
                         (Privileges->Privileges),
                         CapturedPrivilegeCount,
                         PreviousMode,
                         NULL, 0,
                         PagedPool,
                         TRUE,
                         &CapturedPrivileges,
                         &CapturedPrivilegesLength
                         );
        }


        //
        //  Capture Owner
        //

        if ( ARGUMENT_PRESENT(Owner) && NT_SUCCESS(Status)) {
            CapturedAddress = Owner->Owner;
            Status = SeCaptureSid(
                         (PSID)CapturedAddress,
                         PreviousMode,
                         NULL, 0,
                         PagedPool,
                         TRUE,
                         &CapturedOwner
                         );
        }


        //
        //  Capture PrimaryGroup
        //
        if (NT_SUCCESS(Status)) {
            CapturedAddress = PrimaryGroup->PrimaryGroup;
            Status = SeCaptureSid(
                         (PSID)CapturedAddress,
                         PreviousMode,
                         NULL, 0,
                         PagedPool,
                         TRUE,
                         &CapturedPrimaryGroup
                         );
        }


        //
        //  Capture DefaultDacl
        //

        if ( ARGUMENT_PRESENT(DefaultDacl) && NT_SUCCESS(Status) ) {
            CapturedAddress = DefaultDacl->DefaultDacl;
            if (CapturedAddress != NULL) {
                Status = SeCaptureAcl(
                             (PACL)CapturedAddress,
                             PreviousMode,
                             NULL, 0,
                             NonPagedPool,
                             TRUE,
                             &CapturedDefaultDacl,
                             &Ignore
                             );
            }
        }

        //
        //  Capture TokenSource
        //

        CapturedTokenSource = (*TokenSource);


    } except(EXCEPTION_EXECUTE_HANDLER) {

        if (CapturedUser != NULL) {
            SeReleaseSidAndAttributesArray(
                CapturedUser,
                PreviousMode,
                TRUE
                );
        }

        if (CapturedGroups != NULL) {
            SeReleaseSidAndAttributesArray(
                CapturedGroups,
                PreviousMode,
                TRUE
                );
        }

        if (CapturedPrivileges != NULL) {
            SeReleaseLuidAndAttributesArray(
                CapturedPrivileges,
                PreviousMode,
                TRUE
                );
        }

        if (CapturedOwner != NULL) {
            SeReleaseSid( CapturedOwner, PreviousMode, TRUE);
        }

        if (CapturedPrimaryGroup != NULL) {
            SeReleaseSid( CapturedPrimaryGroup, PreviousMode, TRUE);
        }

        if (CapturedDefaultDacl != NULL) {
            SeReleaseAcl( CapturedDefaultDacl, PreviousMode, TRUE);
        }

        if (SecurityQosPresent == TRUE) {
            SeFreeCapturedSecurityQos( &CapturedSecurityQos );
        }

        return GetExceptionCode();

    }  // end_try{}

    //
    //  Create the token
    //

    if (NT_SUCCESS(Status)) {
        Status = SepCreateToken(
                                &LocalHandle,
                                PreviousMode,
                                DesiredAccess,
                                ObjectAttributes,
                                TokenType,
                                CapturedSecurityQos.ImpersonationLevel,
                                &CapturedAuthenticationId,
                                &CapturedExpirationTime,
                                CapturedUser,
                                CapturedGroupCount,
                                CapturedGroups,
                                CapturedGroupsLength,
                                CapturedPrivilegeCount,
                                CapturedPrivileges,
                                CapturedOwner,
                                CapturedPrimaryGroup,
                                CapturedDefaultDacl,
                                &CapturedTokenSource,
                                FALSE,                       // Not a system token
                                SecurityQosPresent ? CapturedSecurityQos.ProxyData : NULL,
                                SecurityQosPresent ? CapturedSecurityQos.AuditData : NULL
                                );
    }

    //
    //  Clean up the temporary capture buffers
    //

    if (CapturedUser != NULL) {
        SeReleaseSidAndAttributesArray( CapturedUser, PreviousMode, TRUE);
    }
    if (CapturedGroups != NULL) {
        SeReleaseSidAndAttributesArray( CapturedGroups, PreviousMode, TRUE);
    }

    if (CapturedPrivileges != NULL) {
        SeReleaseLuidAndAttributesArray( CapturedPrivileges, PreviousMode, TRUE);
    }

    if (CapturedOwner != NULL) {
        SeReleaseSid( CapturedOwner, PreviousMode, TRUE);
    }

    if (CapturedPrimaryGroup != NULL) {
        SeReleaseSid( CapturedPrimaryGroup, PreviousMode, TRUE);
    }

    if (CapturedDefaultDacl != NULL) {
        SeReleaseAcl( CapturedDefaultDacl, PreviousMode, TRUE);
    }

    if (SecurityQosPresent == TRUE) {
        SeFreeCapturedSecurityQos( &CapturedSecurityQos );
    }

    //
    //  Return the handle to this new token
    //

    if (NT_SUCCESS(Status)) {
        try { *TokenHandle = LocalHandle; }
            except(EXCEPTION_EXECUTE_HANDLER) { return GetExceptionCode(); }
    }

    return Status;

}



////////////////////////////////////////////////////////////////////////
//                                                                    //
//           Token Private Routines                                   //
//                                                                    //
////////////////////////////////////////////////////////////////////////


VOID
SepTokenDeleteMethod (
    IN  PVOID   Token
    )

/*++

Routine Description:

    This function is the token object type-specific delete method.
    It is needed to ensure that all memory allocated for the token
    gets deallocated.

Arguments:

    Token - Points to the token object being deleted.

Return Value:

    None.

--*/

{
    PAGED_CODE();

#if DBG || TOKEN_LEAK_MONITOR
    SepRemoveTokenLogonSession( Token );
#endif

    //
    // De-reference the logon session referenced by this token object
    //

    if ((((TOKEN *)Token)->TokenFlags & TOKEN_SESSION_NOT_REFERENCED ) == 0 ) {
        SepDeReferenceLogonSessionDirect( (((TOKEN *)Token)->LogonSession) );
    } 

    //
    // If this token had an active SEP_AUDIT_POLICY then decrement the Token audit counter
    // because this token is going byebye.
    //

    if ( ((PTOKEN)Token)->AuditPolicy.Overlay ) {
        
        SepModifyTokenPolicyCounter(&((PTOKEN)Token)->AuditPolicy, FALSE);
        ASSERT(SepTokenPolicyCounter >= 0);
    }

    //
    // If the token has an associated Dynamic part, deallocate it.
    //

    if (ARGUMENT_PRESENT( ((TOKEN *)Token)->DynamicPart)) {
        ExFreePool( ((TOKEN *)Token)->DynamicPart );
    }

    //
    // Free the Proxy and Global audit structures if present.
    //

    if (ARGUMENT_PRESENT(((TOKEN *) Token)->ProxyData)) {
        SepFreeProxyData( ((TOKEN *)Token)->ProxyData );
    }

    if (ARGUMENT_PRESENT(((TOKEN *)Token)->AuditData )) {
        ExFreePool( (((TOKEN *)Token)->AuditData) );
    }

    if (ARGUMENT_PRESENT(((TOKEN *)Token)->TokenLock )) {
        ExDeleteResourceLite(((TOKEN *)Token)->TokenLock );
        ExFreePool(((TOKEN *)Token)->TokenLock );
    }

    return;
}

NTSTATUS
SepCreateToken(
    OUT PHANDLE TokenHandle,
    IN KPROCESSOR_MODE RequestorMode,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN TOKEN_TYPE TokenType,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel OPTIONAL,
    IN PLUID AuthenticationId,
    IN PLARGE_INTEGER ExpirationTime,
    IN PSID_AND_ATTRIBUTES User,
    IN ULONG GroupCount,
    IN PSID_AND_ATTRIBUTES Groups,
    IN ULONG GroupsLength,
    IN ULONG PrivilegeCount,
    IN PLUID_AND_ATTRIBUTES Privileges,
    IN PSID Owner OPTIONAL,
    IN PSID PrimaryGroup,
    IN PACL DefaultDacl OPTIONAL,
    IN PTOKEN_SOURCE TokenSource,
    IN BOOLEAN SystemToken,
    IN PSECURITY_TOKEN_PROXY_DATA ProxyData OPTIONAL,
    IN PSECURITY_TOKEN_AUDIT_DATA AuditData OPTIONAL
    )

/*++

Routine Description:

    Create a token object and return a handle opened for access to
    that token.  This API implements the bulk of the work needed
    for NtCreateToken.

    All parameters except DesiredAccess and ObjectAttributes are assumed
    to have been probed and captured.

    The output parameter (TokenHandle) is expected to be returned to a
    safe address, rather than to a user mode address that may cause an
    exception.

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    NOTE: This routine is also used to create the initial system token.
          In that case, the SystemToken parameter is TRUE and no handle
          is established to the token.  Instead, a pointer to the token
          is returned via the TokenHandle parameter.
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


Arguments:

    TokenHandle - Receives the handle of the newly created token.  If the
        SystemToken parameter is specified is true, then this parameter
        receives a pointer to the token instead of a handle to the token.

    RequestorMode - The mode of the caller on whose behalf the token
        is being created.

    DesiredAccess - Is an access mask indicating which access types
        the handle is to provide to the new object.

    ObjectAttributes - Points to the standard object attributes data
        structure.  Refer to the NT Object Management
        Specification for a description of this data structure.

    TokenType - Type of token to be created.  Privilege is required
        to create any type of token.

    ImpersonationLevel - If the token type is TokenImpersonation, then
        this parameter is used to specify the impersonation level of
        the token.

    AuthenticationId - Points to a LUID (or LUID) providing a unique
        identifier associated with the authentication.  This is used
        within security only, for audit purposes.

    ExpirationTime - Time at which the token becomes invalid.  If this
        value is specified as zero, then the token has no expiration
        time.

    User - Is the user SID to place in the token.

    GroupCount - Indicates the number of groups in the 'Groups' parameter.
        This value may be zero, in which case the 'Groups' parameter is
        ignored.

    Groups - Are the group SIDs, and their corresponding attributes,
        to place in the token.

    GroupsLength - Indicates the length, in bytes, of the array of groups
        to place in the token.

    PrivilegeCount - Indicates the number of privileges in the 'Privileges'
        parameter.  This value may be zero, in which case the 'Privileges'
        parameter is ignored.

    Privileges - Are the privilege LUIDs, and their corresponding attributes,
        to place in the token.

    PrivilegesLength - Indicates the length, in bytes, of the array of
        privileges to place in the token.

    Owner - (Optionally) identifies an identifier that is to be used
        as the default owner for the token.  If not provided, the
        user ID is made the default owner.

    PrimaryGroup - Identifies which of the group IDs is to be the
        primary group of the token.

    DefaultDacl - (optionally) establishes an ACL to be used as the
        default discretionary access protection for the token.

    TokenSource - Identifies the token source name string and
        identifier to be assigned to the token.

Return Value:

    STATUS_SUCCESS - Indicates the operation was successful.

    STATUS_INVALID_OWNER - Indicates the ID provided to be assigned
        as the default owner of the token does not have an attribute
        indicating it may be assigned as an owner.

    STATUS_INVALID_PRIMARY_GROUP - Indicates the group ID provided
        via the PrimaryGroup parameter was not among those assigned
        to the token in the Groups parameter.

    STATUS_INVALID_PARAMETER - Indicates that a required parameter,
        such as User or PrimaryGroup, was not provided with a legitimate
        value.

--*/

{

    PTOKEN Token;
    NTSTATUS Status;

    ULONG PagedPoolSize;

    ULONG PrimaryGroupLength;

    ULONG TokenBodyLength;
    ULONG VariableLength;

    ULONG DefaultOwnerIndex = 0;
    PUCHAR Where;
    ULONG ComputedPrivLength;

    PSID NextSidFree;

    ULONG DynamicLength;
    ULONG DynamicLengthUsed;

    ULONG SubAuthorityCount;
    ULONG GroupIndex;
    ULONG PrivilegeIndex;
    BOOLEAN OwnerFound;

    UCHAR TokenFlags = 0;

    ACCESS_STATE AccessState;
    AUX_ACCESS_DATA AuxData;
    LUID NewModifiedId;

    PERESOURCE TokenLock;

#if DBG || TOKEN_LEAK_MONITOR
    ULONG Frames;
#endif
    
    PAGED_CODE();

    ASSERT( sizeof(SECURITY_IMPERSONATION_LEVEL) <= sizeof(ULONG) );

    //
    // Make sure the Enabled and Enabled-by-default bits are set on every
    // mandatory group.
    //
    // Also, check to see if the local administrators alias is present.
    // if so, turn on the flag so that we can do restrictions later
    //

    for (GroupIndex=0; GroupIndex < GroupCount; GroupIndex++) {
        if (Groups[GroupIndex].Attributes & SE_GROUP_MANDATORY) {
            Groups[GroupIndex].Attributes |= (SE_GROUP_ENABLED | SE_GROUP_ENABLED_BY_DEFAULT);
        }
    }
    
    for (GroupIndex=0; GroupIndex < GroupCount; GroupIndex++) {
        if (RtlEqualSid( SeAliasAdminsSid, Groups[GroupIndex].Sid )) {
            TokenFlags |= TOKEN_HAS_ADMIN_GROUP;
            break;
        }
    }

    //
    // Check to see if the token being created is going to be granted
    // SeChangeNotifyPrivilege.  If so, set a flag in the TokenFlags field
    // so we can find this out quickly.
    //

    for (PrivilegeIndex = 0; PrivilegeIndex < PrivilegeCount; PrivilegeIndex++) {

        if (((RtlEqualLuid(&Privileges[PrivilegeIndex].Luid,&SeChangeNotifyPrivilege))
                &&
            (Privileges[PrivilegeIndex].Attributes & SE_PRIVILEGE_ENABLED))) {

            TokenFlags |= TOKEN_HAS_TRAVERSE_PRIVILEGE;
        }
        if (((RtlEqualLuid(&Privileges[PrivilegeIndex].Luid, &SeImpersonatePrivilege)) &&
                ( Privileges[PrivilegeIndex].Attributes & SE_PRIVILEGE_ENABLED))) {

            TokenFlags |= TOKEN_HAS_IMPERSONATE_PRIVILEGE ;
            
        }
    }


    //
    // Get a ModifiedId to use
    //

    ExAllocateLocallyUniqueId( &NewModifiedId );

    //
    // Validate the owner ID, if provided and establish the default
    // owner index.
    //

    if (!ARGUMENT_PRESENT(Owner)) {

        DefaultOwnerIndex = 0;

    } else {


        if ( RtlEqualSid( Owner, User->Sid )  ) {

            DefaultOwnerIndex = 0;

        } else {

            GroupIndex = 0;
            OwnerFound = FALSE;

            while ((GroupIndex < GroupCount) && (!OwnerFound)) {

                if ( RtlEqualSid( Owner, (Groups[GroupIndex].Sid) )  ) {

                    //
                    // Found a match - make sure it is assignable as owner.
                    //

                    if ( SepArrayGroupAttributes( Groups, GroupIndex ) &
                         SE_GROUP_OWNER ) {

                        DefaultOwnerIndex = GroupIndex + 1;
                        OwnerFound = TRUE;

                    } else {

                        return STATUS_INVALID_OWNER;

                    } // endif Owner attribute set

                } // endif owner = group

                GroupIndex += 1;

            }  // endwhile

            if (!OwnerFound) {

                return STATUS_INVALID_OWNER;

            } // endif !OwnerFound
        } // endif owner = user
    } // endif owner specified




    TokenLock = (PERESOURCE)ExAllocatePoolWithTag( NonPagedPool, sizeof( ERESOURCE ), 'dTeS' );

    if (TokenLock == NULL) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  Calculate the length needed for the variable portion of the token
    //  This includes the User ID, Group IDs, and Privileges
    //
    //
    // Align the privilege chunk by pointer alignment so that the SIDs will
    // be correctly aligned.  Align the Groups Length so that the SID_AND_ATTR
    // array (which is
    //

    ComputedPrivLength = PrivilegeCount * sizeof( LUID_AND_ATTRIBUTES ) ;

    ComputedPrivLength = ALIGN_UP( ComputedPrivLength, PVOID );

    GroupsLength = ALIGN_UP( GroupsLength, PVOID );


    VariableLength  = GroupsLength + ComputedPrivLength +
                       ALIGN_UP( (GroupCount * sizeof( SID_AND_ATTRIBUTES )), PVOID ) ;

    SubAuthorityCount = ((SID *)(User->Sid))->SubAuthorityCount;
    VariableLength += sizeof(SID_AND_ATTRIBUTES) +
                      (ULONG)LongAlignSize(RtlLengthRequiredSid( SubAuthorityCount ));



    //
    //  Calculate the length needed for the dynamic portion of the token
    //  This includes the default Dacl and the primary group.
    //

    SubAuthorityCount = ((SID *)PrimaryGroup)->SubAuthorityCount;
    DynamicLengthUsed = (ULONG)LongAlignSize(RtlLengthRequiredSid( SubAuthorityCount ));

    if (ARGUMENT_PRESENT(DefaultDacl)) {
        DynamicLengthUsed += (ULONG)LongAlignSize(DefaultDacl->AclSize);
    }

    DynamicLength = DynamicLengthUsed;

    //
    // Now create the token body
    //

    TokenBodyLength = FIELD_OFFSET(TOKEN, VariablePart) + VariableLength;

    if (DynamicLength < TOKEN_DEFAULT_DYNAMIC_CHARGE) {
        PagedPoolSize = TokenBodyLength + TOKEN_DEFAULT_DYNAMIC_CHARGE;
    } else {
        PagedPoolSize = TokenBodyLength + DynamicLength;
    }


    Status = ObCreateObject(
                 RequestorMode,      // ProbeMode
                 SeTokenObjectType, // ObjectType
                 ObjectAttributes,   // ObjectAttributes
                 UserMode,           // OwnershipMode
                 NULL,               // ParseContext
                 TokenBodyLength,    // ObjectBodySize
                 PagedPoolSize,      // PagedPoolCharge
                 0,                  // NonPagedPoolCharge
                 (PVOID *)&Token     // Return pointer to object
                 );

    if (!NT_SUCCESS(Status)) {
        ExFreePool( TokenLock );
        return Status;
    }


    //
    // Main Body initialization
    //

    Token->TokenLock = TokenLock;
    ExInitializeResourceLite( Token->TokenLock );

    ExAllocateLocallyUniqueId( &(Token->TokenId) );
    Token->ParentTokenId = RtlConvertLongToLuid(0);
    Token->OriginatingLogonSession = RtlConvertLongToLuid(0);
    Token->AuthenticationId = (*AuthenticationId);
    Token->TokenInUse = FALSE;
    Token->ModifiedId = NewModifiedId;
    Token->ExpirationTime = (*ExpirationTime);
    Token->TokenType = TokenType;
    Token->ImpersonationLevel = ImpersonationLevel;
    Token->TokenSource = (*TokenSource);

    Token->TokenFlags = TokenFlags;
    Token->SessionId = 0;

    Token->DynamicCharged  = PagedPoolSize - TokenBodyLength;
    Token->DynamicAvailable = 0;

    Token->DefaultOwnerIndex = DefaultOwnerIndex;
    Token->DefaultDacl = NULL;

    Token->VariableLength = VariableLength;
    Token->AuditPolicy.Overlay = 0;

    // Ensure SepTokenDeleteMethod knows the buffers aren't allocated yet.
    
    Token->ProxyData = NULL;
    Token->AuditData = NULL;
    Token->DynamicPart = NULL;

    //
    // Increment the reference count for this logon session
    // (fail if there is no corresponding logon session.)
    //

    Status = SepReferenceLogonSession (AuthenticationId,
                                       &Token->LogonSession);
    if (!NT_SUCCESS (Status)) {
        Token->TokenFlags |= TOKEN_SESSION_NOT_REFERENCED;
        Token->LogonSession = NULL;
        ObDereferenceObject (Token);
        return Status;
    }

#if DBG || TOKEN_LEAK_MONITOR

    Token->ProcessCid      = PsGetCurrentThread()->Cid.UniqueProcess;
    Token->ThreadCid       = PsGetCurrentThread()->Cid.UniqueThread;
    Token->CreateMethod    = 0xC; // Create
    Token->Count           = 0;
    Token->CaptureCount    = 0;

    RtlCopyMemory(
        Token->ImageFileName,
        PsGetCurrentProcess()->ImageFileName, 
        min(sizeof(Token->ImageFileName), sizeof(PsGetCurrentProcess()->ImageFileName))
        );

    Frames = RtlWalkFrameChain(
                 (PVOID)Token->CreateTrace,
                 TRACE_SIZE,
                 0
                 );

    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
        
        RtlWalkFrameChain(
            (PVOID)&Token->CreateTrace[Frames],
            TRACE_SIZE - Frames,
            1
            );
    }

    SepAddTokenLogonSession(Token);

#endif
    
    if (ARGUMENT_PRESENT( ProxyData )) {

        Status = SepCopyProxyData(
                    &Token->ProxyData,
                    ProxyData
                    );

        if (!NT_SUCCESS(Status)) {
            ObDereferenceObject( Token );
            return( STATUS_NO_MEMORY );
        }

    } else {

        Token->ProxyData = NULL;
    }

    if (ARGUMENT_PRESENT( AuditData )) {

        Token->AuditData = ExAllocatePool( PagedPool, sizeof( SECURITY_TOKEN_AUDIT_DATA ));

        if (Token->AuditData == NULL) {
            ObDereferenceObject( Token );
            return( STATUS_NO_MEMORY );
        }

        *(Token->AuditData) = *AuditData;

    } else {

        Token->AuditData = NULL;
    }


    //
    //  Variable part initialization
    //  Data is in the following order:
    //
    //               Privileges array
    //               User (SID_AND_ATTRIBUTES)
    //               Groups (SID_AND_ATTRIBUTES)
    //               Restricted Sids (SID_AND_ATTRIBUTES)
    //               SIDs
    //

    Where = (PUCHAR) & Token->VariablePart ;

    Token->Privileges = (PLUID_AND_ATTRIBUTES) Where ;
    Token->PrivilegeCount = PrivilegeCount ;

    RtlCopyMemory(
        Where,
        Privileges,
        PrivilegeCount * sizeof(LUID_AND_ATTRIBUTES) );

    ASSERT( ComputedPrivLength >= PrivilegeCount * sizeof( LUID_AND_ATTRIBUTES ) );

    Where += ComputedPrivLength ;
    VariableLength -= ComputedPrivLength ;

    ASSERT( (((ULONG_PTR) Where ) & (sizeof(PVOID) - 1)) == 0 );

    //
    // Now, copy the sid and attributes arrays.
    //

    NextSidFree = (PSID) (Where + (sizeof( SID_AND_ATTRIBUTES ) *
                                   (GroupCount + 1) ) );

    Token->UserAndGroups = (PSID_AND_ATTRIBUTES) Where ;
    Token->UserAndGroupCount = GroupCount + 1 ;


    ASSERT(VariableLength >= ((GroupCount + 1) * (ULONG)sizeof(SID_AND_ATTRIBUTES)));

    VariableLength -= ((GroupCount + 1) * (ULONG)sizeof(SID_AND_ATTRIBUTES));
    Status = RtlCopySidAndAttributesArray(
                 1,
                 User,
                 VariableLength,
                 (PSID_AND_ATTRIBUTES)Where,
                 NextSidFree,
                 &NextSidFree,
                 &VariableLength
                 );

    Where += sizeof( SID_AND_ATTRIBUTES );

    ASSERT( (((ULONG_PTR) Where ) & (sizeof(PVOID) - 1)) == 0 );

    Status = RtlCopySidAndAttributesArray(
                 GroupCount,
                 Groups,
                 VariableLength,
                 (PSID_AND_ATTRIBUTES)Where,
                 NextSidFree,
                 &NextSidFree,
                 &VariableLength
                 );


    ASSERT(NT_SUCCESS(Status));


    Token->RestrictedSids = NULL;
    Token->RestrictedSidCount = 0;


    //
    //  Dynamic part initialization
    //  Data is in the following order:
    //
    //                  PrimaryGroup (SID)
    //                  Default Discreationary Acl (ACL)
    //

    Token->DynamicPart = (PULONG)ExAllocatePoolWithTag( PagedPool, DynamicLength, 'dTeS' );

    //
    // The attempt to allocate the DynamicPart of the token may have
    // failed.  Dereference the created object and exit with an error.
    //

    if (Token->DynamicPart == NULL) {
        ObDereferenceObject( Token );
        return( STATUS_NO_MEMORY );
    }


    Where = (PUCHAR) Token->DynamicPart;

    Token->PrimaryGroup = (PSID) Where;
    PrimaryGroupLength = RtlLengthRequiredSid( ((SID *)PrimaryGroup)->SubAuthorityCount );
    RtlCopySid( PrimaryGroupLength, (PSID)Where, PrimaryGroup );
    Where += (ULONG)LongAlignSize(PrimaryGroupLength);

    if (ARGUMENT_PRESENT(DefaultDacl)) {
        Token->DefaultDacl = (PACL)Where;

        RtlCopyMemory( (PVOID)Where,
                      (PVOID)DefaultDacl,
                      DefaultDacl->AclSize
                      );
    }

    //
    //  Insert the token unless it is a system token.
    //

    if (!SystemToken) {

        Status = SeCreateAccessState(
                     &AccessState,
                     &AuxData,
                     DesiredAccess,
                     &SeTokenObjectType->TypeInfo.GenericMapping
                     );

        if ( NT_SUCCESS(Status) ) {
            BOOLEAN PrivilegeHeld;

            PrivilegeHeld = SeSinglePrivilegeCheck(
                            SeCreateTokenPrivilege,
                            KeGetPreviousMode()
                            );

            if (PrivilegeHeld) {

                Status = ObInsertObject( Token,
                                         &AccessState,
                                         0,
                                         0,
                                         (PVOID *)NULL,
                                         TokenHandle
                                         );

            } else {

                Status = STATUS_PRIVILEGE_NOT_HELD;
                ObDereferenceObject( Token );
            }

            SeDeleteAccessState( &AccessState );

        } else {

            ObDereferenceObject( Token );
        }
    } else {

        ASSERT( NT_SUCCESS( Status ) );

        //
        // Insert the token unless this is phase0 initialization. The system token is inserted later.
        //
        if (!ExFastRefObjectNull (PsGetCurrentProcess()->Token)) {
            Status = ObInsertObject( Token,
                                     NULL,
                                     0,
                                     0,
                                     NULL,
                                     NULL
                                     );
        }
        if (NT_SUCCESS (Status)) {
            //
            // Return pointer instead of handle.
            //

            (*TokenHandle) = (HANDLE)Token;
        } else {
            (*TokenHandle) = NULL;
        }
    }

#if DBG || TOKEN_LEAK_MONITOR
    if (SepTokenLeakTracking && SepTokenLeakMethodWatch == 0xC && PsGetCurrentProcess()->UniqueProcessId == SepTokenLeakProcessCid) {
        
        Token->Count = InterlockedIncrement(&SepTokenLeakMethodCount);
        if (Token->Count >= SepTokenLeakBreakCount) {

            DbgPrint("\nToken number 0x%x = 0x%x\n", Token->Count, Token);
            DbgBreakPoint();
        }
    }
#endif

    return Status;

}

BOOLEAN
SepIdAssignableAsOwner(
    IN PTOKEN Token,
    IN ULONG Index
    )

/*++


Routine Description:

    This routine returns a boolean value indicating whether the user
    or group ID in the specified token with the specified index is
    assignable as the owner of an object.

    If the index is 0, which is always the USER ID, then the ID is
    assignable as owner.  Otherwise, the ID is that of a group, and
    it must have the "Owner" attribute set to be assignable.



Arguments:

    Token - Pointer to a locked Token to use.

    Index - Index into the Token's UserAndGroupsArray.  This value
        is assumed to be valid.

Return Value:

    TRUE  - Indicates the index corresponds to an ID that may be assigned
            as the owner of objects.

    FALSE - Indicates the index does not correspond to an ID that may be
            assigned as the owner of objects.

--*/
{
    PAGED_CODE();

    if (Index == 0) {

        return TRUE;

    } else {

        return (BOOLEAN)
                   ( (SepTokenGroupAttributes(Token,Index) & SE_GROUP_OWNER)
                     != 0
                   );
    }
}


NTSTATUS
SeIsChildToken(
    __in HANDLE Token,
    __out PBOOLEAN IsChild
    )
/*++

Routine Description:

    This routine returns TRUE if the supplied token is a child of the caller's
    process token. This is done by comparing the ParentTokenId field of the
    supplied token to the TokenId field of the token from the current subject
    context.

Arguments:

    Token - Token to check for childhood

    IsChild - Contains results of comparison.

        TRUE - The supplied token is a child of the caller's token
        FALSE- The supplied token is not a child of the caller's token

Returns:

    Status codes from any NT services called.

--*/
{
    PTOKEN CallerToken;
    PTOKEN SuppliedToken;
    LUID CallerTokenId;
    LUID SuppliedParentTokenId;
    NTSTATUS Status = STATUS_SUCCESS;
    PEPROCESS Process;

    *IsChild = FALSE;

    //
    // Capture the caller's token and get the token id
    //

    Process = PsGetCurrentProcess();
    CallerToken = (PTOKEN) PsReferencePrimaryToken(Process);

    if (CallerToken == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    CallerTokenId = CallerToken->TokenId;

    PsDereferencePrimaryTokenEx(Process, CallerToken);

    //
    // Reference the supplied token and get the parent token id.
    //

    Status = ObReferenceObjectByHandle(
                Token,                   // Handle
                0,                       // DesiredAccess
                SeTokenObjectType,      // ObjectType
                KeGetPreviousMode(),     // AccessMode
                (PVOID *)&SuppliedToken, // Object
                NULL                     // GrantedAccess
                );

    if (NT_SUCCESS(Status))
    {
        SuppliedParentTokenId = SuppliedToken->ParentTokenId;

        ObDereferenceObject(SuppliedToken);

        //
        // Check to see if the supplied token's parent ID is the ID
        // of the caller.
        //

        if (RtlEqualLuid(
                &SuppliedParentTokenId,
                &CallerTokenId
                )) {

            *IsChild = TRUE;
        }

    }
    return(Status);
}


NTSTATUS
SeIsChildTokenByPointer(
    __in PACCESS_TOKEN Token,
    __out PBOOLEAN IsChild
    )
/*++

Routine Description:

    This routine returns TRUE if the supplied token is a child of the caller's
    token. This is done by comparing the ParentTokenId field of the supplied
    token to the TokenId field of the token from the current subject context.

Arguments:

    Token - Token to check for childhood

    IsChild - Contains results of comparison.

        TRUE - The supplied token is a child of the caller's token
        FALSE- The supplied token is not a child of the caller's token

Returns:

    Status codes from any NT services called.

--*/
{
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    PTOKEN CallerToken;
    PTOKEN SuppliedToken;
    LUID CallerTokenId;
    LUID SuppliedParentTokenId;
    NTSTATUS Status = STATUS_SUCCESS;
    PEPROCESS Process;

    *IsChild = FALSE;

    //
    // Capture the caller's token and get the token id
    //

    Process = PsGetCurrentProcess();
    CallerToken = (PTOKEN) PsReferencePrimaryToken(Process);

    if (CallerToken == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    CallerTokenId = CallerToken->TokenId;

    PsDereferencePrimaryTokenEx(Process, CallerToken);

    SuppliedToken = (PTOKEN) Token;

    SuppliedParentTokenId = SuppliedToken->ParentTokenId;

    //
    // Check to see if the supplied token's parent ID is the ID
    // of the caller.
    //

    if (RtlEqualLuid(
            &SuppliedParentTokenId,
            &CallerTokenId
            )) {

        *IsChild = TRUE;
    }



    return(Status);
}

NTSTATUS
SeIsSiblingToken(
    __in HANDLE Token,
    __out PBOOLEAN IsSibling
    )

/*++

Routine Description:

    This routine returns TRUE if the supplied token is a sibling of the caller's
    process token. This is done by comparing the ParentTokenId field of the
    supplied token to the ParentTokenId field of the token from the current subject
    context. The authentication IDs of the tokens are also compared for equality.

Arguments:

    Token - Token to check for sibling relationship.

    IsSibling - Contains results of comparison.

        TRUE - The supplied token is a sibling of the caller's token
        FALSE- The supplied token is not a sibling of the caller's token

Returns:

    Status codes from any NT services called.

--*/
{
    PTOKEN CallerToken;
    PTOKEN SuppliedToken;
    LUID CallerParentTokenId;
    LUID SuppliedParentTokenId;
    LUID CallerAuthId;
    LUID SuppliedAuthId;
    NTSTATUS Status;
    PEPROCESS Process;

    Status     = STATUS_SUCCESS;
    *IsSibling = FALSE;

    //
    // Capture the caller's token and get the ParentTokenId.
    //

    Process             = PsGetCurrentProcess();
    CallerToken         = (PTOKEN)PsReferencePrimaryToken(Process);

    if (CallerToken == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    CallerParentTokenId = CallerToken->ParentTokenId;
    CallerAuthId        = CallerToken->AuthenticationId;
    
    PsDereferencePrimaryTokenEx(
        Process, 
        CallerToken
        );

    //
    // Reference the supplied token and get the parent token id.
    //

    Status = ObReferenceObjectByHandle(
                Token,                   // Handle
                0,                       // DesiredAccess
                SeTokenObjectType,      // ObjectType
                KeGetPreviousMode(),     // AccessMode
                (PVOID *)&SuppliedToken, // Object
                NULL                     // GrantedAccess
                );

    if (NT_SUCCESS(Status))
    {
        SuppliedParentTokenId = SuppliedToken->ParentTokenId;
        SuppliedAuthId = SuppliedToken->AuthenticationId;
        ObDereferenceObject(SuppliedToken);

        //
        // If the tokens have identical parent token Id fields and
        // identical authentication ids then one of the tokens is a 
        // duplicate of the other.
        //

        if (RtlEqualLuid(
                &SuppliedParentTokenId,
                &CallerParentTokenId
                )) {

            if (RtlEqualLuid(
                    &SuppliedAuthId,
                    &CallerAuthId
                    )) {
                
                *IsSibling = TRUE;
            }
        }
    }

    return Status;
}


NTSTATUS
SeIsSiblingTokenByPointer(
    __in PACCESS_TOKEN Token,
    __out PBOOLEAN IsSibling
    )

/*++

Routine Description:

    This routine returns TRUE if the supplied token is a sibling of the caller's
    process token. This is done by comparing the ParentTokenId field of the
    supplied token to the ParentTokenId field of the token from the current subject
    context.  The authentication IDs are also compared for equality.  

Arguments:

    Token - Token to check for sibling relationship.

    IsSibling - Contains results of comparison.

        TRUE - The supplied token is a sibling of the caller's token
        FALSE- The supplied token is not a sibling of the caller's token

Returns:

    Status codes from any NT services called.

--*/

{
    PTOKEN CallerToken;
    PTOKEN SuppliedToken;
    LUID CallerParentTokenId;
    LUID SuppliedParentTokenId;
    LUID CallerAuthId;
    LUID SuppliedAuthId;
    NTSTATUS Status = STATUS_SUCCESS;
    PEPROCESS Process;

    *IsSibling = FALSE;

    //
    // Capture the caller's token and get the token id
    //

    Process = PsGetCurrentProcess();
    CallerToken = (PTOKEN) PsReferencePrimaryToken(Process);

    if (CallerToken == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    CallerParentTokenId = CallerToken->ParentTokenId;
    CallerAuthId        = CallerToken->AuthenticationId;

    PsDereferencePrimaryTokenEx(
        Process, 
        CallerToken
        );

    SuppliedToken         = (PTOKEN)Token;
    SuppliedParentTokenId = SuppliedToken->ParentTokenId;
    SuppliedAuthId        = SuppliedToken->AuthenticationId;

    //
    // If the tokens have identical parent token Id fields then 
    // one of the tokens is a duplicate of the other.
    //

    if (RtlEqualLuid(
            &SuppliedParentTokenId,
            &CallerParentTokenId
            )) {

        if (RtlEqualLuid(
                &SuppliedAuthId,
                &CallerAuthId
                )) {

            *IsSibling = TRUE;
        }
    }

    return Status;
}

NTSTATUS
NtImpersonateAnonymousToken(
    __in HANDLE ThreadHandle
    )

/*++

Routine Description:

    Impersonates the system's anonymous logon token on this thread.

Arguments:

    ThreadHandle - Handle to the thread to do the impersonation.

Return Value:

    STATUS_SUCCESS - Indicates the operation was successful.

    STATUS_INVALID_HANDLE - the thread handle is invalid.

    STATUS_ACCESS_DENIED - The thread handle is not open for impersonation
        access.
--*/
{
    PETHREAD CallerThread = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PACCESS_TOKEN Token = NULL;
    PEPROCESS Process;
    HANDLE hAnonymousToken = NULL;
    ULONG RegValue;

#define EVERYONE_INCLUDES_ANONYMOUS 1

    //
    // Reference the caller's thread to make sure we can impersonate
    //

    Status = ObReferenceObjectByHandle(
                 ThreadHandle,
                 THREAD_IMPERSONATE,
                 PsThreadType,
                 KeGetPreviousMode(),
                 (PVOID *)&CallerThread,
                 NULL
                 );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Check the AnonymousIncludesEveryone reg key setting.
    //

    Status = SepRegQueryDwordValue(
                 L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa",
                 L"EveryoneIncludesAnonymous",
                 &RegValue
                 );
    
    if ( NT_SUCCESS( Status ) && ( RegValue == EVERYONE_INCLUDES_ANONYMOUS )) {

        hAnonymousToken = SeAnonymousLogonToken;
        
    } else {
        
        hAnonymousToken = SeAnonymousLogonTokenNoEveryone;

    };

    //
    // Reference the impersonation token to make sure we are allowed to
    // impersonate it.
    //

    Status = ObReferenceObjectByPointer(
                hAnonymousToken,
                TOKEN_IMPERSONATE,
                SeTokenObjectType,
                KeGetPreviousMode()
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    ObDereferenceObject(hAnonymousToken);

    Process = PsGetCurrentProcess();
    Token = PsReferencePrimaryToken(Process);

    if (Token == NULL) {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Do not allow anonymous impersonation if the primary token is restricted.
    //

    if (SeTokenIsRestricted(Token)) {
        PsDereferencePrimaryToken(Token);
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    PsDereferencePrimaryTokenEx(Process, Token);

    //
    // Do the impersonation. We want copy on open so the caller can't
    // actually modify this system's copy of this token.
    //

    Status = PsImpersonateClient(
                CallerThread,
                hAnonymousToken,
                TRUE,                   // copy on open
                FALSE,                  // no effective only
                SecurityImpersonation
                );
Cleanup:

    if (CallerThread != NULL) {
        ObDereferenceObject(CallerThread);
    }
    return(Status);
}


#define SepEqualSidAndAttribute(a, b)                                          \
        ((RtlEqualSid((a).Sid, (b).Sid)) &&                                    \
         ((((a).Attributes ^ (b).Attributes) &                                 \
           (SE_GROUP_ENABLED | SE_GROUP_USE_FOR_DENY_ONLY)) == 0)              \
        )

#define SepEqualLuidAndAttribute(a, b)                                         \
        ((RtlEqualLuid(&(a).Luid, &(b).Luid)) &&                               \
         ((((a).Attributes ^ (b).Attributes) &  SE_PRIVILEGE_ENABLED) == 0)    \
        )

BOOLEAN
SepComparePrivilegeAndAttributeArrays(
    IN PLUID_AND_ATTRIBUTES PrivilegeArray1,
    IN ULONG Count1,
    IN PLUID_AND_ATTRIBUTES PrivilegeArray2,
    IN ULONG Count2
    )

/*++

Routine Description:

    This routine decides whether the given two privilege arrays are equivalent
    from AccessCheck perspective.

Arguments:

    PrivilegeArray1 - Privilege and attribute array from the first token.

    Count1 - Number of elements from the first array.

    PrivilegeArray2 - Privilege and attribute array from the second token.

    Count2 - Number of elements from the second array.


Return Value:

    TRUE - if the two arrays are equivalent
    FALSE - otherwise

--*/

{
    ULONG i = 0;
    ULONG j = 0;
    ULONG k = 0;

    //
    // If the number of privileges are not equal return FALSE.
    //

    if ( Count1 != Count2 ) {
        return FALSE;
    }

    //
    // In most cases when the privilege arrays are the same, the elements will
    // be ordered in the same manner. Walk the two arrays till we get a mismatch
    // or exhaust the number of entries in the array.
    //

    for ( k = 0; k < Count1; k++ ) {
        if ( !SepEqualLuidAndAttribute(PrivilegeArray1[k], PrivilegeArray2[k]) ) {
            break;
        }
    }

    //
    // If the arrays are identical return TRUE.
    //

    if ( k == Count1 ) {
        return TRUE;
    }

    //
    // Check if all the elements in the first array are present in the second.
    //

    for ( i = k; i < Count1; i++ ) {
        for ( j = k; j < Count2; j++ ) {
            if ( SepEqualLuidAndAttribute(PrivilegeArray1[i], PrivilegeArray2[j]) ) {
                break;
            }
        }

        //
        // The second array does not contain ith element from the first.
        //

        if ( j == Count2 ) {
            return FALSE;
        }
    }

    //
    // Check if all the elements in the second array are present in the first.
    //

    for ( i = k; i < Count2; i++ ) {
        for ( j = k; j < Count1; j++ ) {
            if ( SepEqualLuidAndAttribute(PrivilegeArray2[i], PrivilegeArray1[j]) ) {
                break;
            }
        }

        //
        // The first array does not contain ith element from the second.
        //

        if ( j == Count1 ) {
            return FALSE;
        }
    }

    //
    // If we are here, one array is a permutation of the other. Return TRUE.
    //

    return TRUE;
}

BOOLEAN
SepCompareSidAndAttributeArrays(
    IN PSID_AND_ATTRIBUTES SidArray1,
    IN ULONG Count1,
    IN PSID_AND_ATTRIBUTES SidArray2,
    IN ULONG Count2
    )
/*++

Routine Description:

    This routine decides whether the given two sid and attribute arrays are
    equivalentfrom AccessCheck perspective.

Arguments:

    SidArray1 - Sid and attribute array from the first token.

    Count1 - Number of elements from the first array.

    SidArray2 - Sid and attribute array from the second token.

    Count2 - Number of elements from the second array.


Return Value:

    TRUE - if the two arrays are equivalent
    FALSE - otherwise

--*/

{

    ULONG i = 0;
    ULONG j = 0;
    ULONG k = 0;

    //
    // If the number of groups sids are not equal return FALSE.
    //

    if ( Count1 != Count2 ) {
        return FALSE;
    }

    //
    // In most cases when the sid arrays are the same, the elements will
    // be ordered in the same manner. Walk the two arrays till we get a mismatch
    // or exhaust the number of entries in the array.
    //

    for ( k = 0; k < Count1; k++ ) {
        if ( !SepEqualSidAndAttribute(SidArray1[k], SidArray2[k]) ) {
            break;
        }
    }

    //
    // If the arrays are identical return TRUE.
    //

    if ( k == Count1 ) {
        return TRUE;
    }

    //
    // Check if all the elements in the first array are present in the second.
    //

    for ( i = k; i < Count1; i++ ) {
        for ( j = k; j < Count2; j++ ) {
            if ( SepEqualSidAndAttribute(SidArray1[i], SidArray2[j]) ) {
                break;
            }
        }

        //
        // The second array does not contain ith element from the first.
        //

        if ( j == Count2 ) {
            return FALSE;
        }
    }

    //
    // Check if all the elements in the second array are present in the first.
    //

    for ( i = k; i < Count2; i++ ) {
        for ( j = k; j < Count1; j++ ) {
            if ( SepEqualSidAndAttribute(SidArray2[i], SidArray1[j]) ) {
                break;
            }
        }

        //
        // The first array does not contain ith element from the second.
        //

        if ( j == Count1 ) {
            return FALSE;
        }
    }

    //
    // If we are here, one array is a permutation of the other. Return TRUE.
    //

    return TRUE;
}


NTSTATUS
NtCompareTokens(
    __in HANDLE FirstTokenHandle,
    __in HANDLE SecondTokenHandle,
    __out PBOOLEAN Equal
    )

/*++

Routine Description:

    This routine decides whether the given two tokens are equivalent from
    AccessCheck perspective.

    Two tokens are considered equal if all of the below are true.
      1. Every sid present in one token is the present in the other and vice-versa.
         The access check attributes (SE_GROUP_ENABLED and SE_GROUP_USE_FOR_DENY_ONLY)
         for these sids should match too.
      2. Either none or both the tokens are restricted.
      3. If both tokens are restricted then 1 should hold true for RestrictedSids.
      4. Every privilege present in the one token should be present in the other
         and vice-versa.


Arguments:

    FirstTokenHandle - Handle to the first token. The caller must have TOKEN_QUERY
        access to the token.

    SecondTokenHandle - Handle to the second token. The caller must have TOKEN_QUERY
        access to the token.

    Equal - To return whether the two tokens are equivalent from AccessCheck
        viewpoint.

Return Value:

    STATUS_SUCCESS - Indicates the operation was successful.

--*/

{

    PTOKEN TokenOne = NULL;
    PTOKEN TokenTwo = NULL;
    BOOLEAN RetVal = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    KPROCESSOR_MODE PreviousMode;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForWriteBoolean(Equal);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }  // end_try

    } //end_if

    //
    // If its the same handle, return TRUE.
    //

    if ( FirstTokenHandle == SecondTokenHandle ) {
        RetVal = TRUE;
        goto Cleanup;
    }

    //
    // Reference the first token handle with TOKEN_QUERY access so that it does
    // not go away.
    //

    Status = ObReferenceObjectByHandle(
                 FirstTokenHandle,         // Handle
                 TOKEN_QUERY,              // DesiredAccess
                 SeTokenObjectType,       // ObjectType
                 PreviousMode,             // AccessMode
                 (PVOID *)&TokenOne,       // Object
                 NULL                      // GrantedAccess
                 );

    if (!NT_SUCCESS(Status)) {
        TokenOne = NULL;
        goto Cleanup;
    }


    //
    // Reference the second token handle with TOKEN_QUERY access so that it does
    // not go away.
    //

    Status = ObReferenceObjectByHandle(
                 SecondTokenHandle,        // Handle
                 TOKEN_QUERY,              // DesiredAccess
                 SeTokenObjectType,       // ObjectType
                 PreviousMode,             // AccessMode
                 (PVOID *)&TokenTwo,       // Object
                 NULL                      // GrantedAccess
                 );

    if (!NT_SUCCESS(Status)) {
        TokenTwo = NULL;
        goto Cleanup;
    }

    //
    // Acquire read lock on the first token.
    //

    SepAcquireTokenReadLock( TokenOne );

    //
    // Acquire read lock on the second token.
    //

    SepAcquireTokenReadLock( TokenTwo );


    //
    // Compare the user sid as well as its relevant attributes.
    //

    if ( !SepEqualSidAndAttribute(TokenOne->UserAndGroups[0], TokenTwo->UserAndGroups[0]) ) {
        goto Cleanup1;
    }

    //
    // Continue if both tokens are unrestricted OR
    //          if both tokens are restricted and Restricted arrays are equal.
    // Else return UNEQUAL.
    //

    if ( SeTokenIsRestricted( (PACCESS_TOKEN) TokenOne )) {
        if ( !SeTokenIsRestricted( (PACCESS_TOKEN) TokenTwo )) {
            goto Cleanup1;
        }

        RetVal = SepCompareSidAndAttributeArrays(
                     TokenOne->RestrictedSids,
                     TokenOne->RestrictedSidCount,
                     TokenTwo->RestrictedSids,
                     TokenTwo->RestrictedSidCount
                     );

        if (!RetVal) {
            goto Cleanup1;
        }

    } else {
        if ( SeTokenIsRestricted( (PACCESS_TOKEN) TokenTwo )) {
            goto Cleanup1;
        }
    }

    //
    // Compare the sid arrays.
    //

    RetVal = SepCompareSidAndAttributeArrays(
                 TokenOne->UserAndGroups+1,
                 TokenOne->UserAndGroupCount-1,
                 TokenTwo->UserAndGroups+1,
                 TokenTwo->UserAndGroupCount-1
                 );

    if (!RetVal) {
        goto Cleanup1;
    }

    //
    // Compare the privilege arrays.
    //

    RetVal = SepComparePrivilegeAndAttributeArrays(
                 TokenOne->Privileges,
                 TokenOne->PrivilegeCount,
                 TokenTwo->Privileges,
                 TokenTwo->PrivilegeCount
                 );
Cleanup1:

    SepReleaseTokenReadLock( TokenOne );
    SepReleaseTokenReadLock( TokenTwo );

Cleanup:

    if ( TokenOne != NULL) {
        ObDereferenceObject( TokenOne );
    }

    if ( TokenTwo != NULL) {
        ObDereferenceObject( TokenTwo );
    }

    try {
        *Equal = RetVal;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    return Status;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\sepaudit.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    sepaudit.c

Abstract:

    This Module implements the audit and alarm procedures that are
    private to the security component.

--*/

#include "pch.h"

#pragma hdrstop

#include <msaudite.h>
#include <string.h>

//
// Socket address, internet style.
//
struct in_addr {
        union {
                struct { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { USHORT s_w1,s_w2; } S_un_w;
                ULONG  S_addr;
        } S_un;
#define s_addr  S_un.S_addr
                                /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
                                /* host on imp */
#define s_net   S_un.S_un_b.s_b1
                                /* network */
#define s_imp   S_un.S_un_w.s_w2
                                /* imp */
#define s_impno S_un.S_un_b.s_b4
                                /* imp # */
#define s_lh    S_un.S_un_b.s_b3
                                /* logical host */
};

typedef struct sockaddr_in {
        short   sin_family;
        USHORT  sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
} SOCKADDR_IN, *PSOCKADDR_IN;


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SepAdtPrivilegeObjectAuditAlarm)
#pragma alloc_text(PAGE,SepAdtPrivilegedServiceAuditAlarm)
#pragma alloc_text(PAGE,SepAdtOpenObjectAuditAlarm)
#pragma alloc_text(PAGE,SepAdtOpenObjectForDeleteAuditAlarm)
#pragma alloc_text(PAGE,SepAdtCloseObjectAuditAlarm)
#pragma alloc_text(PAGE,SepAdtDeleteObjectAuditAlarm)
#pragma alloc_text(PAGE,SepAdtObjectReferenceAuditAlarm)
#pragma alloc_text(PAGE,SepQueryNameString)
#pragma alloc_text(PAGE,SepQueryTypeString)
#pragma alloc_text(PAGE,SeAuditProcessCreation)
#pragma alloc_text(PAGE,SeAuditHandleDuplication)
#pragma alloc_text(PAGE,SeAuditProcessExit)
#pragma alloc_text(PAGE,SeAuditSystemTimeChange)
#pragma alloc_text(PAGE,SepAdtGenerateDiscardAudit)
#pragma alloc_text(PAGE,SeLocateProcessImageName)
#pragma alloc_text(PAGE,SeInitializeProcessAuditName)
#pragma alloc_text(PAGE,SepAuditAssignPrimaryToken)
#pragma alloc_text(PAGE,SeAuditLPCInvalidUse)
#pragma alloc_text(PAGE,SeAuditHardLinkCreation)
#pragma alloc_text(PAGE,SeOperationAuditAlarm)
#pragma alloc_text(PAGE,SeDetailedAuditingWithToken)
#pragma alloc_text(PAGE,SepAdtAuditThisEventWithContext)
#endif


#define SepSetParmTypeSid( AuditParameters, Index, Sid )                       \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeSid;         \
        (AuditParameters).Parameters[(Index)].Length = SeLengthSid( (Sid) );   \
        (AuditParameters).Parameters[(Index)].Address = (Sid);                 \
    }


#define SepSetParmTypeString( AuditParameters, Index, String )                 \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeString;      \
        (AuditParameters).Parameters[(Index)].Length =                         \
                sizeof(UNICODE_STRING)+(String)->Length;                       \
        (AuditParameters).Parameters[(Index)].Address = (String);              \
    }

#define SepSetParmTypeFileSpec( AuditParameters, Index, String )               \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeFileSpec;    \
        (AuditParameters).Parameters[(Index)].Length =                         \
                sizeof(UNICODE_STRING)+(String)->Length;                       \
        (AuditParameters).Parameters[(Index)].Address = (String);              \
    }

#define SepSetParmTypeUlong( AuditParameters, Index, Ulong )                   \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeUlong;       \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( (Ulong) );     \
        (AuditParameters).Parameters[(Index)].Data[0] = (ULONG)(Ulong);        \
    }

#define SepSetParmTypeHexUlong( AuditParameters, Index, Ulong )                \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeHexUlong;    \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( (Ulong) );     \
        (AuditParameters).Parameters[(Index)].Data[0] = (ULONG)(Ulong);        \
    }

#define SepSetParmTypePtr( AuditParameters, Index, Ptr )                       \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypePtr;         \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( ULONG_PTR );   \
        (AuditParameters).Parameters[(Index)].Data[0] = (ULONG_PTR)(Ptr);      \
    }

#define SepSetParmTypeNoLogon( AuditParameters, Index )                        \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeNoLogonId;   \
    }

#define SepSetParmTypeLogonId( AuditParameters, Index, LogonId )             \
    {                                                                        \
        LUID * TmpLuid;                                                      \
                                                                             \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeLogonId;   \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( (LogonId) ); \
        TmpLuid = (LUID *)(&(AuditParameters).Parameters[(Index)].Data[0]);  \
        *TmpLuid = (LogonId);                                                \
    }

#define SepSetParmTypeAccessMask( AuditParameters, Index, AccessMask, ObjectTypeIndex )  \
    {                                                                        \
        ASSERT( (ObjectTypeIndex < Index) && L"SepSetParmTypeAccessMask" );  \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeAccessMask;\
        (AuditParameters).Parameters[(Index)].Length = sizeof( ACCESS_MASK );\
        (AuditParameters).Parameters[(Index)].Data[0] = (AccessMask);        \
        (AuditParameters).Parameters[(Index)].Data[1] = (ObjectTypeIndex);   \
    }


#define SepSetParmTypePrivileges( AuditParameters, Index, Privileges )                      \
    {                                                                                       \
        ASSERT( Privileges->PrivilegeCount <= SEP_MAX_PRIVILEGE_COUNT ); \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypePrivs;                    \
        (AuditParameters).Parameters[(Index)].Length = SepPrivilegeSetSize( (Privileges) ); \
        (AuditParameters).Parameters[(Index)].Address = (Privileges);                       \
    }

#define SepSetParmTypeObjectTypes( AuditParameters, Index, ObjectTypes, ObjectTypeCount, ObjectTypeIndex )             \
    {                                                                               \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeObjectTypes;            \
        (AuditParameters).Parameters[(Index)].Length = sizeof( SE_ADT_OBJECT_TYPE ) * (ObjectTypeCount);\
        (AuditParameters).Parameters[(Index)].Address = (ObjectTypes);                    \
        (AuditParameters).Parameters[(Index)].Data[1] = (ObjectTypeIndex);               \
    }


#define SepSetParmTypeTime( AuditParameters, Index, Time )                            \
    {                                                                                 \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeTime;               \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( (Time) );             \
        *((PLARGE_INTEGER)(&(AuditParameters).Parameters[(Index)].Data[0])) = Time;   \
    }

BOOLEAN
FASTCALL
SeDetailedAuditingWithToken(
    __in_opt PACCESS_TOKEN AccessToken
    )

/*++

Routine Description

    This routine computes whether or not a detailed tracking audit should be 
    generated for a given token or context.  If no token is passed then the 
    current effective token will be captured.

    The caller is responsible for referencing and dereferencing AccessToken.
    
Arguments

    AccessToken - token for which to query audit policy 

Return Value

    BOOLEAN.

--*/

{
    PTOKEN Token;
    ULONG Mask;
    SECURITY_SUBJECT_CONTEXT LocalSecurityContext;
    BOOLEAN AuditThisEvent;

    PAGED_CODE();

    AuditThisEvent = SeAuditingState[AuditCategoryDetailedTracking].AuditOnSuccess;

    if (SepTokenPolicyCounter[AuditCategoryDetailedTracking] == 0) {

        return AuditThisEvent;
    }


    //
    // We cannot decide quickly whether or not to audit (there exist tokens
    // with per user policy settings), so continue with examining the token's 
    // policy. If no token was passed in then capture the context.
    //

    if (ARGUMENT_PRESENT(AccessToken)) {
        
        Token = (PTOKEN)AccessToken;
    
    } else {

        SeCaptureSubjectContext( &LocalSecurityContext );
        Token = EffectiveToken( &LocalSecurityContext );
    }

    if (Token == NULL) {

        //
        // Take whatever action SepAuditFailed takes and return the auditing
        // option we have from the system audit policy
        // 

        SepAuditFailed(STATUS_NO_TOKEN);
        goto Cleanup;
    }

    //
    // Audit if the token specifies success auditing (there is not a detailed tracking failure concept)
    // or if global audit policy specifies detailed tracking auditing and this token is not excluded.
    //

    Mask = Token->AuditPolicy.PolicyElements.DetailedTracking;

    if ( (Mask & TOKEN_AUDIT_SUCCESS_INCLUDE) || 
         (AuditThisEvent && (0 == (Mask & TOKEN_AUDIT_SUCCESS_EXCLUDE))) ) {
        
        AuditThisEvent = TRUE;

    } else {

        AuditThisEvent = FALSE;
    }

Cleanup:

    if (AccessToken == NULL) {
        
        //
        // if AccessToken is NULL then we had to capture the context.  Release
        // it.
        //

        SeReleaseSubjectContext( &LocalSecurityContext );
    }

    return AuditThisEvent;
}


BOOLEAN
SepAdtAuditThisEventWithContext(
    IN POLICY_AUDIT_EVENT_TYPE Category,
    IN BOOLEAN AccessGranted,
    IN BOOLEAN AccessDenied,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext OPTIONAL
    )

/*++

Routine Description

    Determines if an audit should be generated based upon current policy
    settings and the per user audit policy set in the effective token of 
    the context.  If no context is passed in then the current context is 
    captured and examined.
    
Arguments

    Category - the category for which we determine whether or not
        to generate an audit
        
    AccessGranted - whether or not access was granted
        
    AccessDenied - whether or not access was denied
    
    SubjectSecurityContext - the context to query for per user settings
    
Return Value

    BOOLEAN.
    
--*/

{
    ULONG Mask;
    PTOKEN Token;
    SECURITY_SUBJECT_CONTEXT LocalSecurityContext;
    PSECURITY_SUBJECT_CONTEXT pLocalSecurityContext;
    BOOLEAN AuditThisEvent = FALSE;

    PAGED_CODE();

    if ((SeAuditingState[Category].AuditOnSuccess && AccessGranted) ||
        (SeAuditingState[Category].AuditOnFailure && AccessDenied)) {

        AuditThisEvent = TRUE;

    } else {

        AuditThisEvent = FALSE;
    }

    if (SepTokenPolicyCounter[Category] == 0) {
        
        return AuditThisEvent;
    }

    //
    // We cannot decide quickly whether or not to audit (there exist tokens
    // with per user policy settings), so continue with
    // examining the token's policy.
    //

    if (!ARGUMENT_PRESENT(SubjectSecurityContext)) {
        
        pLocalSecurityContext = &LocalSecurityContext;
        SeCaptureSubjectContext( pLocalSecurityContext );
    
    } else {

        pLocalSecurityContext = SubjectSecurityContext;
    }

    Token = EffectiveToken( pLocalSecurityContext );

    if (Token == NULL) {

        //
        // Take whatever action SepAuditFailed takes and return the auditing
        // option we have from the system audit policy
        // 

        SepAuditFailed(STATUS_NO_TOKEN);
        goto Cleanup;
    }

    //
    // Now we have to check the token audit mask because the token may 
    // override the policy and say 'do not audit,' even though the array claims we 
    // must (or vice versa)
    //

    switch (Category) {
    
    case AuditCategorySystem:
        Mask = Token->AuditPolicy.PolicyElements.System;
        break;
    case AuditCategoryLogon:
        Mask = Token->AuditPolicy.PolicyElements.Logon;
        break;
    case AuditCategoryObjectAccess:
        Mask = Token->AuditPolicy.PolicyElements.ObjectAccess;
        break;
    case AuditCategoryPrivilegeUse:
        Mask = Token->AuditPolicy.PolicyElements.PrivilegeUse;
        break;
    case AuditCategoryDetailedTracking:
        Mask = Token->AuditPolicy.PolicyElements.DetailedTracking;
        break;
    case AuditCategoryPolicyChange:
        Mask = Token->AuditPolicy.PolicyElements.PolicyChange;
        break;
    case AuditCategoryAccountManagement:
        Mask = Token->AuditPolicy.PolicyElements.AccountManagement;
        break;
    case AuditCategoryDirectoryServiceAccess:
        Mask = Token->AuditPolicy.PolicyElements.DirectoryServiceAccess;
        break;
    case AuditCategoryAccountLogon:
        Mask = Token->AuditPolicy.PolicyElements.AccountLogon;
        break;
    default:
        ASSERT(FALSE && "Illegal audit category");
        Mask = 0;
        break;
    }

    if (Mask) {

        //
        // If granted and the token is marked for success_include OR
        // if not granted and token is marked for failure_include then
        // audit the event.
        //

        if (( AccessGranted && (Mask & TOKEN_AUDIT_SUCCESS_INCLUDE) ) ||
            ( AccessDenied && (Mask & TOKEN_AUDIT_FAILURE_INCLUDE) )) {
            
            AuditThisEvent = TRUE;
        }

        //
        // If granted and the token is marked for success_exclude OR
        // if not granted and token is marked for failure_exclude then
        // do not audit the event.
        //

        else if (( AccessGranted && (Mask & TOKEN_AUDIT_SUCCESS_EXCLUDE) ) ||
            ( AccessDenied && (Mask & TOKEN_AUDIT_FAILURE_EXCLUDE) )) {
            
            AuditThisEvent = FALSE;
        
        } 
    }

Cleanup:

    if (!ARGUMENT_PRESENT(SubjectSecurityContext)) {

        SeReleaseSubjectContext( pLocalSecurityContext );
    }

    return AuditThisEvent;
}


BOOLEAN
SepAdtPrivilegeObjectAuditAlarm (
    IN PUNICODE_STRING CapturedSubsystemName OPTIONAL,
    IN PVOID HandleId,
    IN PTOKEN ClientToken OPTIONAL,
    IN PTOKEN PrimaryToken,
    IN PVOID ProcessId,
    IN ACCESS_MASK DesiredAccess,
    IN PPRIVILEGE_SET CapturedPrivileges,
    IN BOOLEAN AccessGranted
    )

/*++

Routine Description:

    Implements NtPrivilegeObjectAuditAlarm after parameters have been
    captured.

    This routine is used to generate audit and alarm messages when an
    attempt is made to perform privileged operations on a protected
    subsystem object after the object is already opened.  This routine may
    result in several messages being generated and sent to Port objects.
    This may result in a significant latency before returning.  Design of
    routines that must call this routine must take this potential latency
    into account.  This may have an impact on the approach taken for data
    structure mutex locking, for example.

    This routine will create an SE_ADT_PARAMETERS array organized as follows:

    Parameter[0] - User Sid

    Parameter[1] - Subsystem name (if available)

    Parameter[2] - Subsystem name (if available)

    Parameter[3] - New handle ID

    Parameter[4] - Subject's process id

    Parameter[5] - Subject's primary authentication ID

    Parameter[6] - Subject's client authentication ID

    Parameter[7] - Privileges used for open

Arguments:

    CapturedSubsystemName - Supplies a name string identifying the
        subsystem calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.

    ClientToken - Optionally provides a pointer to the client token
        (only if the caller is currently impersonating)

    PrimaryToken - Provides a pointer to the caller's primary token.

    DesiredAccess - The desired access mask.  This mask must have been
        previously mapped to contain no generic accesses.

    CapturedPrivileges - The set of privileges required for the requested
        operation.  Those privileges that were held by the subject are
        marked using the UsedForAccess flag of the attributes
        associated with each privilege.

    AccessGranted - Indicates whether the requested access was granted or
        not.  A value of TRUE indicates the access was granted.  A value of
        FALSE indicates the access was not granted.

Return value:

--*/
{
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    PSID CapturedUserSid;
    LUID ClientAuthenticationId;
    LUID PrimaryAuthenticationId;
    PUNICODE_STRING SubsystemName;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( DesiredAccess );
    
    //
    // Determine if we are auditing the use of privileges
    //

    if ( SepAdtAuditThisEventWithContext( AuditCategoryPrivilegeUse, AccessGranted, !AccessGranted, NULL ) &&
         SepFilterPrivilegeAudits( 0, CapturedPrivileges )) {

        if ( ARGUMENT_PRESENT( ClientToken )) {

            CapturedUserSid = SepTokenUserSid( ClientToken );

        } else {

            CapturedUserSid = SepTokenUserSid( PrimaryToken );
        }

        if ( RtlEqualSid( SeLocalSystemSid, CapturedUserSid )) {

            return (FALSE);
        }

        PrimaryAuthenticationId = SepTokenAuthenticationId( PrimaryToken );

        if ( !ARGUMENT_PRESENT( CapturedSubsystemName )) {

            SubsystemName = (PUNICODE_STRING)&SeSubsystemName;

        } else {

            SubsystemName = CapturedSubsystemName;
        }

        //
        // A completely zero'd entry will be interpreted
        // as a "null string" or not supplied parameter.
        //
        // Initializing the entire array up front will allow
        // us to avoid filling in each not supplied entry.
        //

        RtlZeroMemory (
           (PVOID) &AuditParameters,
           sizeof( AuditParameters )
           );

        ASSERT( SeAdtParmTypeNone == 0 );

        AuditParameters.CategoryId = SE_CATEGID_PRIVILEGE_USE;
        AuditParameters.AuditId = SE_AUDITID_PRIVILEGED_OBJECT;
        AuditParameters.ParameterCount = 0;

        if ( AccessGranted ) {

            AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;

        } else {

            AuditParameters.Type = EVENTLOG_AUDIT_FAILURE;
        }

        //
        //    Parameter[0] - User Sid
        //

        SepSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, CapturedUserSid );

        AuditParameters.ParameterCount++;

        //
        //    Parameter[1] - Subsystem name
        //

        SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, SubsystemName );

        AuditParameters.ParameterCount++;

        //
        //    Parameter[2] - Subsystem name (if available)
        //

        if (ARGUMENT_PRESENT( CapturedSubsystemName )) {
            
            SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, CapturedSubsystemName );
        }

        AuditParameters.ParameterCount++;

        //
        //    Parameter[3] - New handle ID
        //

        SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, HandleId );

        AuditParameters.ParameterCount++;

        //
        //    Parameter[4] - Subject's process id
        //

        SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, ProcessId );

        AuditParameters.ParameterCount++;

        //
        //    Parameter[5] - Subject's primary authentication ID
        //

        SepSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, PrimaryAuthenticationId );

        AuditParameters.ParameterCount++;

        //
        //    Parameter[6] - Subject's client authentication ID
        //

        if ( ARGUMENT_PRESENT( ClientToken )) {

            ClientAuthenticationId = SepTokenAuthenticationId( ClientToken );
            SepSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, ClientAuthenticationId );

        } else {

            SepSetParmTypeNoLogon( AuditParameters, AuditParameters.ParameterCount );
        }

        AuditParameters.ParameterCount++;

        //
        //    Parameter[7] - Privileges used for open
        //

        if ( (CapturedPrivileges != NULL) && (CapturedPrivileges->PrivilegeCount > 0) ) {

            SepSetParmTypePrivileges( AuditParameters, AuditParameters.ParameterCount, CapturedPrivileges );
        }

        AuditParameters.ParameterCount++;

        SepAdtLogAuditRecord( &AuditParameters );

        return ( TRUE );

    }

    return ( FALSE );
}


VOID
SepAdtPrivilegedServiceAuditAlarm (
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN PUNICODE_STRING CapturedSubsystemName,
    IN PUNICODE_STRING CapturedServiceName,
    IN PTOKEN ClientToken OPTIONAL,
    IN PTOKEN PrimaryToken,
    IN PPRIVILEGE_SET CapturedPrivileges,
    IN BOOLEAN AccessGranted
    )

/*++

Routine Description:

    This routine is the active part of NtPrivilegedServiceAuditAlarm.

    This routine is used to generate audit and alarm messages when an
    attempt is made to perform privileged system service operations.  This
    routine may result in several messages being generated and sent to Port
    objects.  This may result in a significant latency before returning.
    Design of routines that must call this routine must take this potential
    latency into account.  This may have an impact on the approach taken
    for data structure mutex locking, for example.

    This routine will create an SE_ADT_PARAMETERS array organized as follows:

    Parameter[0] - User Sid

    Parameter[1] - Subsystem name (if available)

    Parameter[2] - object server (same as Subsystem name)

    Parameter[3] - Subject's primary authentication ID

    Parameter[4] - Subject's client authentication ID

    Parameter[5] - Privileges used for open

Arguments:

    SubjectSecurityContext - The subject security context representing
        the caller of the system service.

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    ServiceName - Supplies a name of the privileged subsystem service.  For
        example, "RESET RUNTIME LOCAL SECURITY" might be specified
        by a Local Security Authority service used to update the local
        security policy database.

    ClientToken - Optionally provides a pointer to the client token
        (only if the caller is currently impersonating)

    PrimaryToken - Provides a pointer to the caller's primary token.

    Privileges - Points to a set of privileges required to perform the
        privileged operation.  Those privileges that were held by the
        subject are marked using the UsedForAccess flag of the
        attributes associated with each privilege.

    AccessGranted - Indicates whether the requested access was granted or
        not.  A value of TRUE indicates the access was granted.  A value of
        FALSE indicates the access was not granted.


Return value:


--*/

{

    SE_ADT_PARAMETER_ARRAY AuditParameters;
    PSID CapturedUserSid;
    LUID ClientAuthenticationId;
    LUID PrimaryAuthenticationId;
    PUNICODE_STRING SubsystemName;

    PAGED_CODE();

    //
    // Determine if we are auditing privileged services
    //

    if ( !(SepAdtAuditThisEventWithContext( AuditCategoryPrivilegeUse, AccessGranted, !AccessGranted, SubjectSecurityContext ) &&
           SepFilterPrivilegeAudits( 0, CapturedPrivileges ))) {

        return;
    }
    

    if ( ARGUMENT_PRESENT( ClientToken )) {

        CapturedUserSid = SepTokenUserSid( ClientToken );

    } else {

        CapturedUserSid = SepTokenUserSid( PrimaryToken );
    }

    PrimaryAuthenticationId = SepTokenAuthenticationId( PrimaryToken );

    if ( !ARGUMENT_PRESENT( CapturedSubsystemName )) {

        SubsystemName = (PUNICODE_STRING)&SeSubsystemName;

    } else {

        SubsystemName = CapturedSubsystemName;
    }

    //
    // A completely zero'd entry will be interpreted
    // as a "null string" or not supplied parameter.
    //
    // Initializing the entire array up front will allow
    // us to avoid filling in each not supplied entry.
    //

    RtlZeroMemory (
        (PVOID) &AuditParameters,
        sizeof( AuditParameters )
        );

    ASSERT( SeAdtParmTypeNone == 0 );

    AuditParameters.CategoryId = SE_CATEGID_PRIVILEGE_USE;
    AuditParameters.AuditId = SE_AUDITID_PRIVILEGED_SERVICE;
    AuditParameters.ParameterCount = 0;

    if ( AccessGranted ) {

        AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;

    } else {

        AuditParameters.Type = EVENTLOG_AUDIT_FAILURE;
    }


    //
    //    Parameter[0] - User Sid
    //

    SepSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, CapturedUserSid );

    AuditParameters.ParameterCount++;

    //
    //    Parameter[1] - Subsystem name
    //

    SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, SubsystemName );

    AuditParameters.ParameterCount++;


    //
    //    Parameter[2] - Server
    //

    SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, SubsystemName );

    AuditParameters.ParameterCount++;


    //
    //    Parameter[3] - Service name (if available)
    //

    if ( ARGUMENT_PRESENT( CapturedServiceName )) {

        SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, CapturedServiceName );
    }

    AuditParameters.ParameterCount++;

    //
    //    Parameter[3] - Subject's primary authentication ID
    //


    SepSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, PrimaryAuthenticationId );

    AuditParameters.ParameterCount++;


    //
    //    Parameter[4] - Subject's client authentication ID
    //

    if ( ARGUMENT_PRESENT( ClientToken )) {

        ClientAuthenticationId =  SepTokenAuthenticationId( ClientToken );
        SepSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, ClientAuthenticationId );

    } else {

        SepSetParmTypeNoLogon( AuditParameters, AuditParameters.ParameterCount );
    }

    AuditParameters.ParameterCount++;


    //
    //    Parameter[5] - Privileges used for open
    //

    if ( (CapturedPrivileges != NULL) && (CapturedPrivileges->PrivilegeCount > 0) ) {

        SepSetParmTypePrivileges( AuditParameters, AuditParameters.ParameterCount, CapturedPrivileges );
    }

    AuditParameters.ParameterCount++;


    SepAdtLogAuditRecord( &AuditParameters );


}






BOOLEAN
SepAdtOpenObjectAuditAlarm (
    IN PUNICODE_STRING CapturedSubsystemName,
    IN PVOID *HandleId OPTIONAL,
    IN PUNICODE_STRING CapturedObjectTypeName,
    IN PUNICODE_STRING CapturedObjectName OPTIONAL,
    IN PTOKEN ClientToken OPTIONAL,
    IN PTOKEN PrimaryToken,
    IN ACCESS_MASK DesiredAccess,
    IN ACCESS_MASK GrantedAccess,
    IN PLUID OperationId,
    IN PPRIVILEGE_SET CapturedPrivileges OPTIONAL,
    IN BOOLEAN AccessGranted,
    IN HANDLE ProcessID,
    IN POLICY_AUDIT_EVENT_TYPE AuditType,
    IN PIOBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PACCESS_MASK GrantedAccessArray OPTIONAL
    )

/*++

    Routine Description:

    Implements NtOpenObjectAuditAlarm after parameters have been captured.

    This routine is used to generate audit and alarm messages when an
    attempt is made to access an existing protected subsystem object or
    create a new one.  This routine may result in several messages being
    generated and sent to Port objects.  This may result in a significant
    latency before returning.  Design of routines that must call this
    routine must take this potential latency into account.  This may have
    an impact on the approach taken for data structure mutex locking, for
    example.  This API requires the caller have SeTcbPrivilege privilege.
    The test for this privilege is always against the primary token of the
    calling process, not the impersonation token of the thread.


    This routine will create an SE_ADT_PARAMETERS array organized as follows:

    Parameter[0] - User Sid

    Parameter[1] - Subsystem name (if available)

    Parameter[2] - Server name (if available)

    Parameter[3] - Object Type Name

    Parameter[4] - Object Name

    Parameter[5] - New handle ID

    Parameter[6] - Subject's process id

    Parameter[7] - Subject's image file name

    Parameter[8] - Subject's primary authentication ID

    Parameter[9] - Subject's client authentication ID

    Parameter[10] - DesiredAccess mask

    Parameter[11] - Privileges used for open

    Parameter[12] - Guid/Level/AccessMask of objects/property sets/properties accesses.

    Parameter[13] - Number of restricted SIDs in the token

Arguments:

    CapturedSubsystemName - Supplies a name string identifying the
        subsystem calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.  If the access attempt was not successful (AccessGranted is
        FALSE), then this parameter is ignored.

    CapturedObjectTypeName - Supplies the name of the type of object being
        accessed.

    CapturedObjectName - Supplies the name of the object the client
        accessed or attempted to access.

    CapturedSecurityDescriptor - A pointer to the security descriptor of
        the object being accessed.

    ClientToken - Optionally provides a pointer to the client token
        (only if the caller is currently impersonating)

    PrimaryToken - Provides a pointer to the caller's primary token.

    DesiredAccess - The desired access mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GrantedAccess - The mask of accesses that were actually granted.

    CapturedPrivileges - Optionally points to a set of privileges that were
        required for the access attempt.  Those privileges that were held
        by the subject are marked using the UsedForAccess flag of the
        attributes associated with each privilege.

    ObjectCreation - A boolean flag indicating whether the access will
        result in a new object being created if granted.  A value of TRUE
        indicates an object will be created, FALSE indicates an existing
        object will be opened.

    AccessGranted - Indicates whether the requested access was granted or
        not.  A value of TRUE indicates the access was granted.  A value of
        FALSE indicates the access was not granted.

    GenerateOnClose - Points to a boolean that is set by the audit
        generation routine and must be passed to NtCloseObjectAuditAlarm()
        when the object handle is closed.

    GenerateAudit - Indicates if we should generate an audit for this operation.

    GenerateAlarm - Indicates if we should generate an alarm for this operation.

    AuditType - Specifies the type of audit to be generated.  Valid values
        are: AuditCategoryObjectAccess and AuditCategoryDirectoryServiceAccess.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GrantedAccessArray - If non NULL, specifies an array of access mask granted
        to each object in ObjectTypeList.

Return Value:

    Returns TRUE if audit is generated, FALSE otherwise.

--*/

{
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    ULONG ObjectTypeIndex;
    PSID CapturedUserSid;
    LUID PrimaryAuthenticationId = { 0 };
    LUID ClientAuthenticationId = { 0 };
    PSE_ADT_OBJECT_TYPE AdtObjectTypeBuffer = NULL;
    PEPROCESS Process = NULL;
    PUNICODE_STRING ImageFileName;
    UNICODE_STRING NullString = {0};
    NTSTATUS Status;
    PUNICODE_STRING SubsystemName;

    PAGED_CODE();

    Process = PsGetCurrentProcess();
    
    Status = SeLocateProcessImageName( Process, &ImageFileName );

    if ( !NT_SUCCESS(Status) ) {
        ImageFileName = &NullString;

        //
        // ignore this failure
        //

        Status = STATUS_SUCCESS;
    }

    if ( ARGUMENT_PRESENT( ClientToken )) {

        CapturedUserSid = SepTokenUserSid( ClientToken );
        ClientAuthenticationId =  SepTokenAuthenticationId( ClientToken );

    } else {

        CapturedUserSid = SepTokenUserSid( PrimaryToken );
    }

    PrimaryAuthenticationId = SepTokenAuthenticationId( PrimaryToken );

    //
    // A completely zero'd entry will be interpreted
    // as a "null string" or not supplied parameter.
    //
    // Initializing the entire array up front will allow
    // us to avoid filling in each not supplied entry.
    //

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    ASSERT( SeAdtParmTypeNone == 0 );

    ASSERT( ( AuditType == AuditCategoryObjectAccess ) ||
            ( AuditType == AuditCategoryDirectoryServiceAccess ) );

    if (AuditType == AuditCategoryObjectAccess) {

        AuditParameters.CategoryId = SE_CATEGID_OBJECT_ACCESS;

    } else {

        AuditParameters.CategoryId = SE_CATEGID_DS_ACCESS;
    }

    AuditParameters.AuditId = SE_AUDITID_OPEN_HANDLE;
    AuditParameters.ParameterCount = 0;

    if ( AccessGranted ) {

        AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;

    } else {

        AuditParameters.Type = EVENTLOG_AUDIT_FAILURE;
    }

    if ( !ARGUMENT_PRESENT( CapturedSubsystemName )) {

        SubsystemName = (PUNICODE_STRING)&SeSubsystemName;

    } else {

        SubsystemName = CapturedSubsystemName;
    }

    //
    //  Parameter[0] - User Sid
    //

    SepSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, CapturedUserSid );

    AuditParameters.ParameterCount++;

    //
    //  Parameter[1] - Subsystem name
    //

    SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, SubsystemName );

    AuditParameters.ParameterCount++;

    //
    //  Parameter[2] - Object Server (if available)
    //

    if ( ARGUMENT_PRESENT( CapturedSubsystemName )) {

        SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, CapturedSubsystemName );
    }

    AuditParameters.ParameterCount++;

    //
    //  Parameter[3] - Object Type Name
    //

    if ( !ARGUMENT_PRESENT( CapturedObjectTypeName )) {

        //
        // We have to have an ObjectTypeName for the audit to succeed.
        //

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, CapturedObjectTypeName );
    ObjectTypeIndex = AuditParameters.ParameterCount;
    AuditParameters.ParameterCount++;

    //
    //  Parameter[4] - Object Name
    //

    if ( ARGUMENT_PRESENT( CapturedObjectName )) {

        SepSetParmTypeFileSpec( AuditParameters, AuditParameters.ParameterCount, CapturedObjectName );
    }

    AuditParameters.ParameterCount++;

    //
    //  Parameter[5] - New handle ID
    //

    if ( ARGUMENT_PRESENT( HandleId )) {

        SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, *HandleId );
    }

    AuditParameters.ParameterCount++;

    if ( ARGUMENT_PRESENT( OperationId )) {

        SepSetParmTypeUlong( AuditParameters, AuditParameters.ParameterCount, (*OperationId).HighPart );

        AuditParameters.ParameterCount++;

        SepSetParmTypeUlong( AuditParameters, AuditParameters.ParameterCount, (*OperationId).LowPart );

        AuditParameters.ParameterCount++;

    } else {

        AuditParameters.ParameterCount += 2;
    }

    //
    //  Parameter[6] - Subject's process id
    //

    SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, ProcessID );

    AuditParameters.ParameterCount++;


    //
    //    Parameter[7] - Subject's Image Name
    //

    SepSetParmTypeFileSpec( AuditParameters, AuditParameters.ParameterCount, ImageFileName );
    AuditParameters.ParameterCount ++;

    //
    //  Parameter[8] - Subject's primary authentication ID
    //

    SepSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, PrimaryAuthenticationId );

    AuditParameters.ParameterCount++;

    //
    //  Parameter[9] - Subject's client authentication ID
    //

    if ( ARGUMENT_PRESENT( ClientToken )) {

        SepSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, ClientAuthenticationId );

    } else {

        SepSetParmTypeNoLogon( AuditParameters, AuditParameters.ParameterCount  );
    }

    AuditParameters.ParameterCount++;

    //
    //  Parameter[10] - DesiredAccess mask
    //

    if ( AccessGranted ) {

        SepSetParmTypeAccessMask( AuditParameters, AuditParameters.ParameterCount, GrantedAccess, ObjectTypeIndex );

    } else {

        SepSetParmTypeAccessMask( AuditParameters, AuditParameters.ParameterCount, DesiredAccess, ObjectTypeIndex );
    }

    AuditParameters.ParameterCount++;

    //
    //    Parameter[11] - Privileges used for open
    //

    if ( (CapturedPrivileges != NULL) && (CapturedPrivileges->PrivilegeCount > 0) ) {

        SepSetParmTypePrivileges( AuditParameters, AuditParameters.ParameterCount, CapturedPrivileges );
    }

    AuditParameters.ParameterCount++;

    //
    //    Parameter[12] - ObjectTypes of Audited objects/parameter sets/parameters
    //

    if ( ObjectTypeListLength != 0 ) {
        ULONG GuidCount;
        ULONG i;
        USHORT FlagMask = AccessGranted ? OBJECT_SUCCESS_AUDIT : OBJECT_FAILURE_AUDIT;

        //
        // Count the number of GUIDs to audit.
        //

        GuidCount = 0;
        for ( i=0; i<ObjectTypeListLength; i++ ) {

            if ( i == 0 ) {
                GuidCount++;
            } else if ( ObjectTypeList[i].Flags & FlagMask ) {
                GuidCount ++;
            }
        }

        //
        // If there are any Guids to audit,
        //  copy them into a locally allocated buffer.
        //

        if ( GuidCount > 0 ) {

            AdtObjectTypeBuffer = ExAllocatePoolWithTag( PagedPool, GuidCount * sizeof(SE_ADT_OBJECT_TYPE), 'pAeS' );

            //
            // If the buffer can be allocated,
            //  fill it in.
            // If not,
            //  generate a truncated audit.
            //

            if ( AdtObjectTypeBuffer != NULL ) {

                //
                // Copy the GUIDs and optional access masks to the buffer.
                //

                GuidCount = 0;
                for ( i=0; i<ObjectTypeListLength; i++ ) {

                    if ( ( i > 0 ) && !( ObjectTypeList[i].Flags & FlagMask ) ) {

                        continue;

                    } else {

                        AdtObjectTypeBuffer[GuidCount].ObjectType = ObjectTypeList[i].ObjectType;
                        AdtObjectTypeBuffer[GuidCount].Level      = ObjectTypeList[i].Level;

                        if ( i == 0 ) {
                            //
                            // Always copy the GUID representing the object itself.
                            //  Mark it as a such to avoid including it in the audit.
                            //
                            AdtObjectTypeBuffer[GuidCount].Flags      = SE_ADT_OBJECT_ONLY;
                            AdtObjectTypeBuffer[GuidCount].AccessMask = 0;

                        } else  {

                            AdtObjectTypeBuffer[GuidCount].Flags = 0;
                            if ( ARGUMENT_PRESENT(GrantedAccessArray) && AccessGranted ) {

                                AdtObjectTypeBuffer[GuidCount].AccessMask = GrantedAccessArray[i];
                            }
                        }
                        GuidCount ++;
                    }
                }

                //
                // Store the Object Types.
                //

                SepSetParmTypeObjectTypes( AuditParameters, AuditParameters.ParameterCount, AdtObjectTypeBuffer, GuidCount, ObjectTypeIndex );
                AuditParameters.ParameterCount ++;
                AuditParameters.AuditId = SE_AUDITID_OPEN_HANDLE_OBJECT_TYPE;
            }
        }

    }

    //
    //    Parameter[13] - Restricted Sids in token
    //

    SepSetParmTypeUlong( AuditParameters, AuditParameters.ParameterCount, PrimaryToken->RestrictedSidCount );
    AuditParameters.ParameterCount ++;


    //
    //    Parameter[14] - AccessMask in hex
    //

    if ( AccessGranted ) {

        SepSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, GrantedAccess );

    } else {

        SepSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, DesiredAccess );
    }
    AuditParameters.ParameterCount ++;


    //
    // Audit it.
    //
    SepAdtLogAuditRecord( &AuditParameters );

Cleanup:

    if ( AdtObjectTypeBuffer != NULL ) {
        ExFreePool( AdtObjectTypeBuffer );
    }

    if ( ImageFileName != &NullString ) {
        ExFreePool( ImageFileName );
    }

    return( NT_SUCCESS(Status) );
}


BOOLEAN
SepAdtOpenObjectForDeleteAuditAlarm (
    IN PUNICODE_STRING CapturedSubsystemName,
    IN PVOID *HandleId OPTIONAL,
    IN PUNICODE_STRING CapturedObjectTypeName,
    IN PUNICODE_STRING CapturedObjectName OPTIONAL,
    IN PTOKEN ClientToken OPTIONAL,
    IN PTOKEN PrimaryToken,
    IN ACCESS_MASK DesiredAccess,
    IN ACCESS_MASK GrantedAccess,
    IN PLUID OperationId,
    IN PPRIVILEGE_SET CapturedPrivileges OPTIONAL,
    IN BOOLEAN AccessGranted,
    IN HANDLE ProcessID
    )

/*++

    Routine Description:

    Implements SeOpenObjectForDeleteAuditAlarm after parameters have been
    captured.

    This routine is used to generate audit and alarm messages when an
    attempt is made to access an existing protected subsystem object or
    create a new one.  This routine may result in several messages being
    generated and sent to Port objects.  This may result in a significant
    latency before returning.  Design of routines that must call this
    routine must take this potential latency into account.  This may have
    an impact on the approach taken for data structure mutex locking, for
    example.  This API requires the caller have SeTcbPrivilege privilege.
    The test for this privilege is always against the primary token of the
    calling process, not the impersonation token of the thread.


    This routine will create an SE_ADT_PARAMETERS array organized as follows:

    Parameter[0] - User Sid

    Parameter[1] - Subsystem name (if available)

    Parameter[2] - Server name (if available)

    Parameter[3] - Object Type Name

    Parameter[4] - Object Name

    Parameter[5] - New handle ID

    Parameter[6] - Subject's process id

    Parameter[7] - Subject's primary authentication ID

    Parameter[8] - Subject's client authentication ID

    Parameter[9] - DesiredAccess mask

    Parameter[10] - Privileges used for open

Arguments:

    CapturedSubsystemName - Supplies a name string identifying the
        subsystem calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.  If the access attempt was not successful (AccessGranted is
        FALSE), then this parameter is ignored.

    CapturedObjectTypeName - Supplies the name of the type of object being
        accessed.

    CapturedObjectName - Supplies the name of the object the client
        accessed or attempted to access.

    CapturedSecurityDescriptor - A pointer to the security descriptor of
        the object being accessed.

    ClientToken - Optionally provides a pointer to the client token
        (only if the caller is currently impersonating)

    PrimaryToken - Provides a pointer to the caller's primary token.

    DesiredAccess - The desired access mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GrantedAccess - The mask of accesses that were actually granted.

    CapturedPrivileges - Optionally points to a set of privileges that were
        required for the access attempt.  Those privileges that were held
        by the subject are marked using the UsedForAccess flag of the
        attributes associated with each privilege.

    ObjectCreation - A boolean flag indicating whether the access will
        result in a new object being created if granted.  A value of TRUE
        indicates an object will be created, FALSE indicates an existing
        object will be opened.

    AccessGranted - Indicates whether the requested access was granted or
        not.  A value of TRUE indicates the access was granted.  A value of
        FALSE indicates the access was not granted.

    GenerateOnClose - Points to a boolean that is set by the audit
        generation routine and must be passed to NtCloseObjectAuditAlarm()
        when the object handle is closed.

    GenerateAudit - Indicates if we should generate an audit for this operation.

    GenerateAlarm - Indicates if we should generate an alarm for this operation.

Return Value:

    Returns TRUE if audit is generated, FALSE otherwise.

--*/

{
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    ULONG ObjectTypeIndex;
    PSID CapturedUserSid;
    LUID PrimaryAuthenticationId;
    LUID ClientAuthenticationId;
    PUNICODE_STRING SubsystemName;

    PAGED_CODE();

    if ( ARGUMENT_PRESENT( ClientToken )) {

        CapturedUserSid = SepTokenUserSid( ClientToken );

    } else {

        CapturedUserSid = SepTokenUserSid( PrimaryToken );
    }

    PrimaryAuthenticationId = SepTokenAuthenticationId( PrimaryToken );

    //
    // A completely zero'd entry will be interpreted
    // as a "null string" or not supplied parameter.
    //
    // Initializing the entire array up front will allow
    // us to avoid filling in each not supplied entry.
    //

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    ASSERT( SeAdtParmTypeNone == 0 );

    AuditParameters.CategoryId = SE_CATEGID_OBJECT_ACCESS;
    AuditParameters.AuditId = SE_AUDITID_OPEN_OBJECT_FOR_DELETE;
    AuditParameters.ParameterCount = 0;

    if ( AccessGranted ) {

        AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;

    } else {

        AuditParameters.Type = EVENTLOG_AUDIT_FAILURE;
    }

    if ( !ARGUMENT_PRESENT( CapturedSubsystemName )) {

        SubsystemName = (PUNICODE_STRING)&SeSubsystemName;

    } else {

        SubsystemName = CapturedSubsystemName;
    }

    //
    //  Parameter[0] - User Sid
    //

    SepSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, CapturedUserSid );

    AuditParameters.ParameterCount++;

    //
    //  Parameter[1] - Subsystem name
    //

    SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, SubsystemName );

    AuditParameters.ParameterCount++;

    //
    //  Parameter[2] - Object Server (if available)
    //

    if ( ARGUMENT_PRESENT( CapturedSubsystemName )) {

        SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, CapturedSubsystemName );
    }

    AuditParameters.ParameterCount++;

    //
    //  Parameter[3] - Object Type Name
    //

    if ( ARGUMENT_PRESENT( CapturedObjectTypeName )) {

        SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, CapturedObjectTypeName );
    }

    ObjectTypeIndex = AuditParameters.ParameterCount;
    AuditParameters.ParameterCount++;

    //
    //  Parameter[4] - Object Name
    //

    if ( ARGUMENT_PRESENT( CapturedObjectName )) {

        SepSetParmTypeFileSpec( AuditParameters, AuditParameters.ParameterCount, CapturedObjectName );
    }

    AuditParameters.ParameterCount++;

    //
    //  Parameter[5] - New handle ID
    //

    if ( ARGUMENT_PRESENT( HandleId )) {

        SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, *HandleId );
    }

    AuditParameters.ParameterCount++;

    if ( ARGUMENT_PRESENT( OperationId )) {

        SepSetParmTypeUlong( AuditParameters, AuditParameters.ParameterCount, (*OperationId).HighPart );

        AuditParameters.ParameterCount++;

        SepSetParmTypeUlong( AuditParameters, AuditParameters.ParameterCount, (*OperationId).LowPart );

        AuditParameters.ParameterCount++;

    } else {

        AuditParameters.ParameterCount += 2;
    }

    //
    //  Parameter[6] - Subject's process id
    //

    SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, ProcessID );

    AuditParameters.ParameterCount++;

    //
    //  Parameter[7] - Subject's primary authentication ID
    //

    SepSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, PrimaryAuthenticationId );

    AuditParameters.ParameterCount++;

    //
    //  Parameter[8] - Subject's client authentication ID
    //

    if ( ARGUMENT_PRESENT( ClientToken )) {

        ClientAuthenticationId =  SepTokenAuthenticationId( ClientToken );
        SepSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, ClientAuthenticationId );

    } else {

        SepSetParmTypeNoLogon( AuditParameters, AuditParameters.ParameterCount  );
    }

    AuditParameters.ParameterCount++;

    //
    //  Parameter[9] - DesiredAccess mask
    //

    if ( AccessGranted ) {

        SepSetParmTypeAccessMask( AuditParameters, AuditParameters.ParameterCount, GrantedAccess, ObjectTypeIndex );

    } else {

        SepSetParmTypeAccessMask( AuditParameters, AuditParameters.ParameterCount, DesiredAccess, ObjectTypeIndex );
    }

    AuditParameters.ParameterCount++;

    //
    //    Parameter[10] - Privileges used for open
    //

    if ( (CapturedPrivileges != NULL) && (CapturedPrivileges->PrivilegeCount > 0) ) {

        SepSetParmTypePrivileges( AuditParameters, AuditParameters.ParameterCount, CapturedPrivileges );
    }

    AuditParameters.ParameterCount++;

    //
    //  Parameter[11] - DesiredAccess mask in hex
    //

    if ( AccessGranted ) {

        SepSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, GrantedAccess );

    } else {

        SepSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, DesiredAccess );
    }

    AuditParameters.ParameterCount++;

    SepAdtLogAuditRecord( &AuditParameters );

    return( TRUE );
}




VOID
SepAdtCloseObjectAuditAlarm (
    IN PUNICODE_STRING CapturedSubsystemName,
    IN PVOID HandleId,
    IN PSID UserSid
    )

/*++

Routine Description:

    This routine implements NtCloseObjectAuditAlarm after parameters have
    been captured.

    This routine is used to generate audit and alarm messages when a handle
    to a protected subsystem object is deleted.  This routine may result in
    several messages being generated and sent to Port objects.  This may
    result in a significant latency before returning.  Design of routines
    that must call this routine must take this potential latency into
    account.  This may have an impact on the approach taken for data
    structure mutex locking, for example.

    This API requires the caller have SeTcbPrivilege privilege.  The test
    for this privilege is always against the primary token of the calling
    process, allowing the caller to be impersonating a client during the
    call with no ill effects.  It is assumed that this privilege has been
    tested at a higher level.

    This routine will create an SE_ADT_PARAMETERS array organized as follows:

    Parameter[0] - User Sid

    Parameter[1] - Subsystem name (if available)

    Parameter[2] - object server name (same as subsystem name)

    Parameter[3] - New handle ID

    Parameter[4] - Subject's process id

    Parameter[5] - Image file name

Arguments:

    CapturedSubsystemName - Supplies a name string identifying the
        subsystem calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.

    Object - The address of the object being closed

    UserSid - The Sid identifying the current caller.



Return value:

    None.


--*/

{

    SE_ADT_PARAMETER_ARRAY AuditParameters;
    HANDLE ProcessId;
    PEPROCESS Process = NULL;
    PUNICODE_STRING ImageFileName;
    UNICODE_STRING NullString = {0};
    NTSTATUS Status;
    PUNICODE_STRING SubsystemName;

    PAGED_CODE();

    if ( SepAuditOptions.DoNotAuditCloseObjectEvents ) {

        return;
    }

    if ( SepAdtAuditThisEventWithContext( AuditCategoryObjectAccess, TRUE, FALSE, NULL ) ) {

        Process = PsGetCurrentProcess();
        ProcessId = PsProcessAuditId( Process );

        Status = SeLocateProcessImageName( Process, &ImageFileName );
        
        if ( !NT_SUCCESS(Status) ) {
            ImageFileName = &NullString;
        }

        //
        // A completely zero'd entry will be interpreted
        // as a "null string" or not supplied parameter.
        //
        // Initializing the entire array up front will allow
        // us to avoid filling in each not supplied entry.
        //

        RtlZeroMemory (
           (PVOID) &AuditParameters,
           sizeof( AuditParameters )
           );

        ASSERT( SeAdtParmTypeNone == 0 );

        AuditParameters.CategoryId = SE_CATEGID_OBJECT_ACCESS;
        AuditParameters.AuditId = SE_AUDITID_CLOSE_HANDLE;
        AuditParameters.ParameterCount = 0;
        AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;

        if ( !ARGUMENT_PRESENT( CapturedSubsystemName )) {

            SubsystemName = (PUNICODE_STRING)&SeSubsystemName;

        } else {

            SubsystemName = CapturedSubsystemName;
        }

        //
        //  Parameter[0] - User Sid
        //

        SepSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, UserSid );

        AuditParameters.ParameterCount++;


        //
        //  Parameter[1] - Subsystem name
        //

        SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, SubsystemName );

        AuditParameters.ParameterCount++;

        //
        //  Parameter[2] - Object server name (if available)
        //

        if ( ARGUMENT_PRESENT( CapturedSubsystemName )) {

            SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, CapturedSubsystemName );
        }

        AuditParameters.ParameterCount++;

        //
        //    Parameter[3] - New handle ID
        //

        SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, HandleId );

        AuditParameters.ParameterCount++;

        //
        //    Parameter[4] - Subject's process id
        //

        SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, ProcessId );

        AuditParameters.ParameterCount++;

        //
        //    Parameter[5] - Subject's Image Name
        //

        SepSetParmTypeFileSpec( AuditParameters, AuditParameters.ParameterCount, ImageFileName );
        AuditParameters.ParameterCount ++;

        SepAdtLogAuditRecord( &AuditParameters );

        if ( ImageFileName != &NullString ) {
            ExFreePool( ImageFileName );
        }

    }
}



VOID
SepAdtDeleteObjectAuditAlarm (
    IN PUNICODE_STRING CapturedSubsystemName,
    IN PVOID HandleId,
    IN PSID UserSid
    )

/*++

Routine Description:

    This routine implements NtDeleteObjectAuditAlarm after parameters have
    been captured.

    This routine is used to generate audit and alarm messages when an object
    in a protected subsystem object is deleted.  This routine may result in
    several messages being generated and sent to Port objects.  This may
    result in a significant latency before returning.  Design of routines
    that must call this routine must take this potential latency into
    account.  This may have an impact on the approach taken for data
    structure mutex locking, for example.

    This routine will create an SE_ADT_PARAMETERS array organized as follows:

    Parameter[0] - User Sid

    Parameter[1] - Subsystem name

    Parameter[2] - Object server (same as Subsystem name)

    Parameter[3] - Handle ID

    Parameter[4] - Subject's process id

    Parameter[5] - Subject's process image name

Arguments:

    CapturedSubsystemName - Supplies a name string identifying the
        subsystem calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.

    Object - The address of the object being closed

    UserSid - The Sid identifying the current caller.



Return value:

    None.


--*/

{

    SE_ADT_PARAMETER_ARRAY AuditParameters;
    HANDLE ProcessId;
    PUNICODE_STRING ImageFileName = NULL;
    UNICODE_STRING NullString = {0};
    PEPROCESS Process = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING SubsystemName;

    PAGED_CODE();

    if ( SepAdtAuditThisEventWithContext( AuditCategoryObjectAccess, TRUE, FALSE, NULL ) ) {

        Process = PsGetCurrentProcess();
        Status = SeLocateProcessImageName( Process, &ImageFileName );

        if ( !NT_SUCCESS(Status) ) {
            ImageFileName = &NullString;
        }
        
        //
        // A completely zero'd entry will be interpreted
        // as a "null string" or not supplied parameter.
        //
        // Initializing the entire array up front will allow
        // us to avoid filling in each not supplied entry.
        //

        RtlZeroMemory (
           (PVOID) &AuditParameters,
           sizeof( AuditParameters )
           );

        ASSERT( SeAdtParmTypeNone == 0 );

        AuditParameters.CategoryId = SE_CATEGID_OBJECT_ACCESS;
        AuditParameters.AuditId = SE_AUDITID_DELETE_OBJECT;
        AuditParameters.ParameterCount = 0;
        AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;

        if ( !ARGUMENT_PRESENT( CapturedSubsystemName )) {

            SubsystemName = (PUNICODE_STRING)&SeSubsystemName;

        } else {

            SubsystemName = CapturedSubsystemName;
        }

        //
        //  Parameter[0] - User Sid
        //

        SepSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, UserSid );

        AuditParameters.ParameterCount++;


        //
        //  Parameter[1] - Subsystem name
        //

        SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, SubsystemName );

        AuditParameters.ParameterCount++;

        //
        //  Parameter[2] - Subsystem name (if available)
        //

        if ( ARGUMENT_PRESENT( CapturedSubsystemName )) {

            SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, CapturedSubsystemName );
        }

        AuditParameters.ParameterCount++;

        //
        //    Parameter[3] - New handle ID
        //

        SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, HandleId );

        AuditParameters.ParameterCount++;

        //
        //    Parameter[4] - Subject's process id
        //

        ProcessId =  PsProcessAuditId( PsGetCurrentProcess() );

        SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, ProcessId );

        AuditParameters.ParameterCount++;
        
        //
        //    Parameter[5] - Subject's Image Name
        //

        SepSetParmTypeFileSpec( AuditParameters, AuditParameters.ParameterCount, ImageFileName );
        AuditParameters.ParameterCount ++;

        SepAdtLogAuditRecord( &AuditParameters );

        if (ImageFileName != &NullString) {
            ExFreePool(ImageFileName);
        }
    }
}

VOID
SeOperationAuditAlarm (
    __in_opt PUNICODE_STRING CapturedSubsystemName,
    __in PVOID HandleId,
    __in PUNICODE_STRING ObjectTypeName,
    __in ACCESS_MASK AuditMask,
    __in_opt PSID UserSid
    )

/*++

Routine Description:

    This routine generates an "operation-based" audit.

    This routine may result in several messages being generated and sent
    to Port objects.  This may result in a significant latency before
    returning.  Design of routines that must call this routine must take
    this potential latency into account.  This may have an impact on the
    approach taken for data structure mutex locking, for example.

    This routine will create an SE_ADT_PARAMETERS array organized as follows:

    Parameter[0] - User Sid

    Parameter[1] - Subsystem name (if available)

    Parameter[2] - Object server (same as Subsystem name)

    Parameter[3] - Handle ID

    Parameter[4] - object type name

    Parameter[5] - Subject's process id

    Parameter[6] - Subject's process image name

    Parameter[7] - Audit mask

Arguments:

    CapturedSubsystemName - Supplies a name string identifying the
        subsystem calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.

    ObjectTypeName - The type of the object being accessed.

    AuditMask - Mask of bits being audited.

    UserSid - Optionally supplies the user sid.

Return value:

    None.


--*/

{

    SE_ADT_PARAMETER_ARRAY AuditParameters;
    BOOLEAN AccessGranted = TRUE;
    HANDLE ProcessId;
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    ULONG ObjectTypeIndex;
    PUNICODE_STRING SubsystemName;
    NTSTATUS Status;
    UNICODE_STRING NullString = {0};
    PUNICODE_STRING ImageFileName = NULL;
    PEPROCESS Process = NULL;

    PAGED_CODE();

    Process = PsGetCurrentProcess();
    ProcessId = PsProcessAuditId( Process );

    Status = SeLocateProcessImageName( Process, &ImageFileName );

    if ( !NT_SUCCESS(Status) ) {
        ImageFileName = &NullString;
    }
    
    //
    // A completely zero'd entry will be interpreted
    // as a "null string" or not supplied parameter.
    //
    // Initializing the entire array up front will allow
    // us to avoid filling in each not supplied entry.
    //

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    ASSERT( SeAdtParmTypeNone == 0 );

    AuditParameters.CategoryId     = SE_CATEGID_OBJECT_ACCESS;
    AuditParameters.AuditId        = SE_AUDITID_OBJECT_ACCESS;
    AuditParameters.ParameterCount = 0;
    AuditParameters.Type           = EVENTLOG_AUDIT_SUCCESS;

    //
    //  If the user's SID was not passed, get it out of the current
    //  subject context
    //

    SeCaptureSubjectContext( &SubjectSecurityContext );

    if ( !ARGUMENT_PRESENT( UserSid )) {
        
        UserSid = SepTokenUserSid( EffectiveToken( &SubjectSecurityContext ));

    }
    

    if ( !ARGUMENT_PRESENT( CapturedSubsystemName )) {

        SubsystemName = (PUNICODE_STRING)&SeSubsystemName;

    } else {

        SubsystemName = CapturedSubsystemName;
    }

    //
    //  Parameter[0] - User Sid
    //

    SepSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, UserSid );

    AuditParameters.ParameterCount++;


    //
    //  Parameter[1] - Subsystem name
    //

    SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, SubsystemName );

    AuditParameters.ParameterCount++;

    //
    //  Parameter[2] - object server (same as subsystem name)
    //

    SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, SubsystemName );

    AuditParameters.ParameterCount++;

    //
    //    Parameter[3] - New handle ID
    //

    SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, HandleId );

    AuditParameters.ParameterCount++;

    //
    //    Parameter[4] - Object Type Name
    //

    SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, ObjectTypeName );
    ObjectTypeIndex = AuditParameters.ParameterCount;

    AuditParameters.ParameterCount++;

    //
    //    Parameter[5] - Subject's process id
    //

    SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, ProcessId );

    AuditParameters.ParameterCount++;


    //
    //    Parameter[6] - Subject's process name
    //

    SepSetParmTypeFileSpec( AuditParameters, AuditParameters.ParameterCount, ImageFileName );

    AuditParameters.ParameterCount++;

    //
    //    Parameter[7] - Audit Mask
    //

    SepSetParmTypeAccessMask( AuditParameters, AuditParameters.ParameterCount, AuditMask, ObjectTypeIndex );

    AuditParameters.ParameterCount++;

    //
    //    Parameter[8] - Access Mask (hex)
    //

    SepSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, AuditMask );

    AuditParameters.ParameterCount++;

    SepAdtLogAuditRecord( &AuditParameters );

    if ( ImageFileName != &NullString ) {
        ExFreePool( ImageFileName );
    }

    SeReleaseSubjectContext( &SubjectSecurityContext );

}



VOID
SepAdtObjectReferenceAuditAlarm(
    IN PVOID Object,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN AccessGranted
    )

/*++

Routine Description:

    Note: the caller (SeObjectReferenceAuditAlarm) checks audit policy.

    description-of-function.

    This routine will create an SE_ADT_PARAMETERS array organized as follows:

    Parameter[0] - User Sid

    Parameter[1] - Subsystem name (if available)

    Parameter[2] - Object Type Name

    Parameter[3] - Object Name

    Parameter[4] - Subject's process id

    Parameter[5] - Subject's primary authentication ID

    Parameter[6] - Subject's client authentication ID

    Parameter[7] - DesiredAccess mask


Arguments:

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    ULONG ObjectTypeIndex;
    POBJECT_NAME_INFORMATION ObjectNameInformation;
    PUNICODE_STRING ObjectTypeInformation;
    PSID UserSid;
    LUID PrimaryAuthenticationId;
    LUID ClientAuthenticationId;

    PTOKEN ClientToken = (PTOKEN)SubjectSecurityContext->ClientToken;
    PTOKEN PrimaryToken = (PTOKEN)SubjectSecurityContext->PrimaryToken;

    PAGED_CODE();


    if ( ARGUMENT_PRESENT( ClientToken )) {

        UserSid = SepTokenUserSid( ClientToken );

    } else {

        UserSid = SepTokenUserSid( PrimaryToken );
    }

    PrimaryAuthenticationId = SepTokenAuthenticationId( PrimaryToken );

    //
    // A completely zero'd entry will be interpreted
    // as a "null string" or not supplied parameter.
    //
    // Initializing the entire array up front will allow
    // us to avoid filling in each not supplied entry.
    //

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    ASSERT( SeAdtParmTypeNone == 0 );

    AuditParameters.CategoryId = SE_CATEGID_DETAILED_TRACKING;
    AuditParameters.AuditId = SE_AUDITID_INDIRECT_REFERENCE;
    AuditParameters.ParameterCount = 9;

    if ( AccessGranted ) {

        AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;

    } else {

        AuditParameters.Type = EVENTLOG_AUDIT_FAILURE;
    }

    //
    // Obtain the object name and object type name from the object.
    //

    ObjectNameInformation = SepQueryNameString( Object );


    ObjectTypeInformation = SepQueryTypeString( Object );




    //
    //  Parameter[0] - User Sid
    //

    SepSetParmTypeSid( AuditParameters, 0, UserSid );


    //
    //  Parameter[1] - Subsystem name
    //

    SepSetParmTypeString( AuditParameters, 1, (PUNICODE_STRING)&SeSubsystemName );


    //
    //  Parameter[2] - Object Type Name
    //

    if ( ObjectTypeInformation != NULL ) {

        SepSetParmTypeString( AuditParameters, 2, ObjectTypeInformation );
    }

    ObjectTypeIndex = 2;


    //
    //  Parameter[3] - Object Name
    //

    if ( ObjectNameInformation != NULL ) {

        SepSetParmTypeString( AuditParameters, 3, &ObjectNameInformation->Name );
    }




    //
    //  Parameter[4] - Subject's process id
    //

    SepSetParmTypePtr( AuditParameters, 4, SubjectSecurityContext->ProcessAuditId );




    //
    //  Parameter[5] - Subject's primary authentication ID
    //


    SepSetParmTypeLogonId( AuditParameters, 5, PrimaryAuthenticationId );




    //
    //  Parameter[6] - Subject's client authentication ID
    //

    if ( ARGUMENT_PRESENT( ClientToken )) {

        ClientAuthenticationId =  SepTokenAuthenticationId( ClientToken );
        SepSetParmTypeLogonId( AuditParameters, 6, ClientAuthenticationId );

    } else {

        SepSetParmTypeNoLogon( AuditParameters, 6 );

    }

    //
    //  Parameter[7] - DesiredAccess mask
    //

    SepSetParmTypeAccessMask( AuditParameters, 7, DesiredAccess, ObjectTypeIndex );

    //
    //  Parameter[8] - DesiredAccess mask
    //

    SepSetParmTypeHexUlong( AuditParameters, 8, DesiredAccess );


    SepAdtLogAuditRecord( &AuditParameters );

    if ( ObjectNameInformation != NULL ) {
        ExFreePool( ObjectNameInformation );
    }

    if ( ObjectTypeInformation != NULL ) {
        ExFreePool( ObjectTypeInformation );
    }

}






POBJECT_NAME_INFORMATION
SepQueryNameString(
    IN PVOID Object
    )

/*++

Routine Description:

    Takes a pointer to an object and returns the name of the object.

Arguments:

    Object - a pointer to an object.


Return Value:

    A pointer to a buffer containing a POBJECT_NAME_INFORMATION
    structure containing the name of the object.  The string is
    allocated out of paged pool and should be freed by the caller.

    NULL may also be returned.


--*/

{
    NTSTATUS Status;
    ULONG ReturnLength = 0;
    POBJECT_NAME_INFORMATION ObjectNameInfo = NULL;
    PUNICODE_STRING ObjectName = NULL;

    PAGED_CODE();

    Status = ObQueryNameString(
                 Object,
                 ObjectNameInfo,
                 0,
                 &ReturnLength
                 );

    if ( Status == STATUS_INFO_LENGTH_MISMATCH ) {

        ObjectNameInfo = ExAllocatePoolWithTag( PagedPool, ReturnLength, 'nOeS' );

        if ( ObjectNameInfo != NULL ) {

            Status = ObQueryNameString(
                        Object,
                        ObjectNameInfo,
                        ReturnLength,
                        &ReturnLength
                        );

            if ( NT_SUCCESS( Status ) && (ObjectNameInfo->Name.Length != 0) ) {

                return( ObjectNameInfo );

            } else {

                ExFreePool( ObjectNameInfo );
                return( NULL );
            }
        }
    }

    return( NULL );
}




PUNICODE_STRING
SepQueryTypeString(
    IN PVOID Object
    )
/*++

Routine Description:

    Takes a pointer to an object and returns the type of the object.

Arguments:

    Object - a pointer to an object.


Return Value:

    A pointer to a UNICODE_STRING that contains the name of the object
    type.  The string is allocated out of paged pool and should be freed
    by the caller.

    NULL may also be returned.


--*/

{

    NTSTATUS Status;
    PUNICODE_STRING TypeName;
    UNICODE_STRING ObjectTypeName = { 0 };
    ULONG ReturnLength;


    PAGED_CODE();

    Status = ObQueryTypeName(
                 Object,
                 &ObjectTypeName,
                 0,
                 &ReturnLength
                 );

    if ( Status == STATUS_INFO_LENGTH_MISMATCH ) {

        TypeName = ExAllocatePoolWithTag( PagedPool, ReturnLength, 'nTeS' );

        if ( TypeName != NULL ) {

            Status = ObQueryTypeName(
                        Object,
                        TypeName,
                        ReturnLength,
                        &ReturnLength
                        );

            if ( NT_SUCCESS( Status )) {

                return( TypeName );
                
            } else {

                ExFreePool( TypeName );
            }
        }
    }

    return( NULL );
}


VOID
SeAuditProcessCreation(
    __in PEPROCESS Process
    )
/*++

Routine Description:

    Audits the creation of a process.  It is the caller's responsibility
    to determine if process auditing is in progress.

Arguments:

    Process - Points to the new process object.

Return Value:

    None.

--*/

{
    LUID UserAuthenticationId;
    NTSTATUS Status;
    PSID UserSid;
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    HANDLE ProcessId;
    HANDLE ParentProcessId;
    PUNICODE_STRING ImageFileName;
    UNICODE_STRING NullString = {0};

    PAGED_CODE();

    //
    // Set up the various data that will be needed for the audit:
    // - process id
    // - parent's process id
    // - image file name (unicode)
    //

    ProcessId = Process->UniqueProcessId;
    ParentProcessId = Process->InheritedFromUniqueProcessId;

    Status = SeLocateProcessImageName( Process, &ImageFileName );

    if ( !NT_SUCCESS(Status) ) {
        ImageFileName = &NullString;
    }

    //
    // NtCreateProcess with no section will cause this to be NULL
    // fork() for posix will do this, or someone calling NtCreateProcess
    // directly.
    //

    SeCaptureSubjectContext( &SubjectSecurityContext );

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    ASSERT( SeAdtParmTypeNone == 0 );

    AuditParameters.CategoryId = SE_CATEGID_DETAILED_TRACKING;
    AuditParameters.AuditId = SE_AUDITID_PROCESS_CREATED;
    AuditParameters.ParameterCount = 0;
    AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;

    //
    // Use the primary token here, because that's what's going to show up
    // when the created process exits.
    //

    UserSid = SepTokenUserSid( SubjectSecurityContext.PrimaryToken );

    UserAuthenticationId = SepTokenAuthenticationId( SubjectSecurityContext.PrimaryToken );

    //
    // Fill in the AuditParameters structure.
    //

    SepSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, UserSid );
    AuditParameters.ParameterCount++;

    SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, (PUNICODE_STRING)&SeSubsystemName );
    AuditParameters.ParameterCount++;

    SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, ProcessId );
    AuditParameters.ParameterCount++;

    SepSetParmTypeFileSpec( AuditParameters, AuditParameters.ParameterCount, ImageFileName );
    AuditParameters.ParameterCount++;

    SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, ParentProcessId );
    AuditParameters.ParameterCount++;

    SepSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, UserAuthenticationId );
    AuditParameters.ParameterCount++;

    SepAdtLogAuditRecord( &AuditParameters );

    SeReleaseSubjectContext( &SubjectSecurityContext );

    if ( ImageFileName != &NullString ) {
        ExFreePool( ImageFileName );
    }

    return;
}


VOID
SeAuditHandleDuplication(
    __in PVOID SourceHandle,
    __in PVOID NewHandle,
    __in PEPROCESS SourceProcess,
    __in PEPROCESS TargetProcess
    )

/*++

Routine Description:

    This routine generates a handle duplication audit.  It is up to the caller
    to determine if this routine should be called or not.

Arguments:

    SourceHandle -  Original handle

    NewHandle - New handle

    SourceProcess - Process containing SourceHandle

    TargetProcess - Process containing NewHandle

Return Value:

    None.

--*/

{
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    PSID UserSid;

    PAGED_CODE();

    SeCaptureSubjectContext( &SubjectSecurityContext );

    UserSid = SepTokenUserSid( EffectiveToken( &SubjectSecurityContext ));

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );


    ASSERT( SeAdtParmTypeNone == 0 );

    AuditParameters.CategoryId = SE_CATEGID_DETAILED_TRACKING;
    AuditParameters.AuditId = SE_AUDITID_DUPLICATE_HANDLE;
    AuditParameters.ParameterCount = 0;
    AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;

    SepSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, UserSid );
    AuditParameters.ParameterCount++;

    SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, (PUNICODE_STRING)&SeSubsystemName );
    AuditParameters.ParameterCount++;

    SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, SourceHandle );
    AuditParameters.ParameterCount++;

    SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, PsProcessAuditId( SourceProcess ));
    AuditParameters.ParameterCount++;

    SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, NewHandle );
    AuditParameters.ParameterCount++;

    SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, PsProcessAuditId( TargetProcess ));
    AuditParameters.ParameterCount++;


    SepAdtLogAuditRecord( &AuditParameters );

    SeReleaseSubjectContext( &SubjectSecurityContext );
}


VOID
SeAuditProcessExit(
    __in PEPROCESS Process
    )
/*++

Routine Description:

    Audits the exit of a process.  The caller is responsible for
    determining if this should be called.

Arguments:

    Process - Pointer to the process object that is exiting.

Return Value:

    None.

--*/

{
    PTOKEN Token;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    PSID UserSid;
    LUID LogonId;
    HANDLE ProcessId;
    PUNICODE_STRING ImageFileName;
    UNICODE_STRING NullString = {0};
    NTSTATUS Status;
    
    PAGED_CODE();

    Token = (PTOKEN) PsReferencePrimaryToken (Process);

    UserSid = SepTokenUserSid( Token );
    LogonId = SepTokenAuthenticationId( Token );

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    ASSERT( SeAdtParmTypeNone == 0 );

    Status = SeLocateProcessImageName( Process, &ImageFileName );

    if ( !NT_SUCCESS(Status) ) {
        ImageFileName = &NullString;
    }
    
    AuditParameters.CategoryId = SE_CATEGID_DETAILED_TRACKING;
    AuditParameters.AuditId = SE_AUDITID_PROCESS_EXIT;
    AuditParameters.ParameterCount = 0;
    AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;

    SepSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, UserSid );
    AuditParameters.ParameterCount++;

    SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, (PUNICODE_STRING)&SeSubsystemName );
    AuditParameters.ParameterCount++;

    ProcessId =  PsProcessAuditId( Process );

    SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, ProcessId );
    AuditParameters.ParameterCount++;

    SepSetParmTypeFileSpec( AuditParameters, AuditParameters.ParameterCount, ImageFileName );
    AuditParameters.ParameterCount++;

    SepSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, LogonId );
    AuditParameters.ParameterCount++;

    SepAdtLogAuditRecord( &AuditParameters );
   
    PsDereferencePrimaryToken( Token );
    
    if ( ImageFileName != &NullString ) {
        ExFreePool( ImageFileName );
    }

}



VOID
SepAdtGenerateDiscardAudit(
    VOID
    )

/*++

Routine Description:

    Generates an 'audits discarded' audit.

Arguments:

    none

Return Value:

    None.

--*/

{

    SE_ADT_PARAMETER_ARRAY AuditParameters;
    PSID UserSid;

    PAGED_CODE();

    UserSid = SeLocalSystemSid;

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );


    ASSERT( SeAdtParmTypeNone == 0 );

    AuditParameters.CategoryId = SE_CATEGID_SYSTEM;
    AuditParameters.AuditId = SE_AUDITID_AUDITS_DISCARDED;
    AuditParameters.ParameterCount = 0;
    AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;

    SepSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, UserSid );
    AuditParameters.ParameterCount++;

    SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, (PUNICODE_STRING)&SeSubsystemName );
    AuditParameters.ParameterCount++;

    SepSetParmTypeUlong( AuditParameters, AuditParameters.ParameterCount, SepAdtCountEventsDiscarded );
    AuditParameters.ParameterCount++;

    SepAdtLogAuditRecord( &AuditParameters );
}


NTSTATUS
SeInitializeProcessAuditName (
    __in __typefix(PFILE_OBJECT) PVOID FileObject,
    __in BOOLEAN bIgnoreAuditPolicy,
    __deref_out POBJECT_NAME_INFORMATION *pAuditName
    )

/*++

Routine Description:

    This routine initializes the executable name for auditing purposes.  It allocates memory for the 
    image file name.  This memory is pointed to by pAuditName.  

Arguments:

    FileObject - Supplies a pointer to a file object for the image being
                 executed.
                 
    bIgnoreAuditPolicy - boolean that indicates that the call should proceed without
        regard to the system's auditing policy.         

    pAuditName - Supplies a pointer to a pointer for the object name information.

Return value:

    NTSTATUS.

Environment:

    KeAttached to the target process so not all system services are available.

--*/

{
    NTSTATUS Status;
    OBJECT_NAME_INFORMATION TempNameInfo;
    ULONG ObjectNameInformationLength;
    POBJECT_NAME_INFORMATION pInternalAuditName;
    PFILE_OBJECT FilePointer;

    PAGED_CODE();

    ASSERT (pAuditName != NULL);
    *pAuditName = NULL;

    //
    // Check if the caller would like to get the process name, even if auditing does not 
    // require it.
    //

    if (FALSE == bIgnoreAuditPolicy) {
        //
        // At the time of process creation, this routine should only proceed when Object Access or 
        // Detailed Tracking auditing is enabled.  In all other cases, the process name is acquired
        // when it is requested.
        //

        if (!SepAdtAuditThisEventWithContext( AuditCategoryObjectAccess, TRUE, FALSE, NULL ) &&
            !SepAdtAuditThisEventWithContext( AuditCategoryDetailedTracking, TRUE, FALSE, NULL )) {

            return STATUS_SUCCESS;
        }
    }

    FilePointer = (PFILE_OBJECT) FileObject;

    //
    // Compute full path for imagefile.
    // This first call to ObQueryNameString is guaranteed to fail.
    // The ObjectNameInformationLength contains only a
    // UNICODE_STRING, so if this call succeeded it would indicate
    // an imagefile name of length 0.  That is bad, so all return
    // values except STATUS_BUFFER_OVERFLOW (from NTFS) and
    // STATUS_BUFFER_TOO_SMALL (from DFS).  This call gives 
    // me the buffer size that I need to store the image name.
    //

    pInternalAuditName = &TempNameInfo;
    ObjectNameInformationLength = sizeof(OBJECT_NAME_INFORMATION);

    Status = ObQueryNameString (FilePointer,
                                pInternalAuditName,
                                ObjectNameInformationLength,
                                &ObjectNameInformationLength);

    if ((Status == STATUS_BUFFER_OVERFLOW) ||
        (Status == STATUS_BUFFER_TOO_SMALL)) {
    
        //
        // Sanity check ObQueryNameString.  Different filesystems
        // may be buggy, so make sure that the return length makes
        // sense (that it has room for a non-NULL Buffer in the
        // UNICODE_STRING).
        //
    
        if (ObjectNameInformationLength > sizeof(OBJECT_NAME_INFORMATION)) {
            pInternalAuditName = ExAllocatePoolWithTag (NonPagedPool, 
                                                        ObjectNameInformationLength, 
                                                        'aPeS');

            if (pInternalAuditName != NULL) {
                Status = ObQueryNameString (FilePointer,
                                            pInternalAuditName,
                                            ObjectNameInformationLength,
                                            &ObjectNameInformationLength);
            
                if (!NT_SUCCESS(Status)) {
                
#if DBG
                    DbgPrint("\n** ObqueryNameString failed with 0x%x.\n", Status);
#endif //DBG

                    //
                    // If the second call to ObQueryNameString did not succeed, then
                    // something is very wrong.  Set the image name to NULL string.
                    //                                           
                    // Free the memory that the first call to ObQueryNameString requested,
                    // and allocate enough space to store an empty UNICODE_STRING.
                    //

                    ExFreePool (pInternalAuditName); 
                    ObjectNameInformationLength = sizeof(OBJECT_NAME_INFORMATION);
                    pInternalAuditName = ExAllocatePoolWithTag (NonPagedPool, 
                                                                ObjectNameInformationLength, 
                                                                'aPeS');
                
                    if (pInternalAuditName != NULL) {
                        RtlZeroMemory(pInternalAuditName, ObjectNameInformationLength);
                    
                        //
                        // Status = STATUS_SUCCESS to allow the process creation to continue.
                        //

                        Status = STATUS_SUCCESS;
                    } else {
                        Status = STATUS_NO_MEMORY;
                    }
                }
            } else {
                Status = STATUS_NO_MEMORY;
            }
        } else {
        
            //
            // If this happens, then ObQueryNameString is broken for the FS on which
            // it was called.
            //

#if DBG
            DbgPrint("\n** ObqueryNameString failed with 0x%x.\n", Status);
#endif //DBG

            ObjectNameInformationLength = sizeof(OBJECT_NAME_INFORMATION);
            pInternalAuditName = ExAllocatePoolWithTag (NonPagedPool, 
                                                        ObjectNameInformationLength, 
                                                        'aPeS');

            if (pInternalAuditName != NULL) {
                RtlZeroMemory(pInternalAuditName, ObjectNameInformationLength);
            
                //
                // Status = STATUS_SUCCESS to allow the process creation to continue.
                //

                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_NO_MEMORY;
            }
        }
    } else {

        //
        // If ObQueryNameString returns some other error code, we cannot
        // be certain of which action to take, or whether it has properly
        // set the ReturnLength.  For example, ObQueryNameString has slightly 
        // different semantics under DFS than NTFS.  Additionally, 3rd 
        // party file systems may also behave unpredictably.  For these reasons,
        // in the case of an unexpected error code from ObQueryNameString 
        // we set AuditName to zero length unicode string and allow process
        // creation to continue.
        //
    
#if DBG
        DbgPrint("\n** ObqueryNameString failed with 0x%x.\n", Status);
#endif //DBG

        ObjectNameInformationLength = sizeof(OBJECT_NAME_INFORMATION);
        pInternalAuditName = ExAllocatePoolWithTag(NonPagedPool, ObjectNameInformationLength, 'aPeS');

        if (pInternalAuditName != NULL) {
            RtlZeroMemory(pInternalAuditName, ObjectNameInformationLength);

            //
            // Status = STATUS_SUCCESS to allow the process creation to continue.
            //

            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_NO_MEMORY;
        }
    }

    *pAuditName = pInternalAuditName;

    return Status;
}



NTSTATUS
SeLocateProcessImageName(
    __in PEPROCESS Process,
    __deref_out PUNICODE_STRING *pImageFileName
    )

/*++

Routine Description
    
    This routine returns the ImageFileName information from the process, if available.  This is a "lazy evaluation" wrapper 
    around SeInitializeProcessAuditName.  If the image file name information has already been computed, then this call simply
    allocates and returns a UNICODE_STRING with this information.  Otherwise, the function determines the name, stores the name in the 
    EPROCESS structure, and then allocates and returns a UNICODE_STRING.  Caller must free the memory returned in pImageFileName.
    
Arguments

    Process - process for which to acquire the name
    
    pImageFileName - output parameter to return name to caller
    
Return Value

    NTSTATUS. 
    
--*/

{
    NTSTATUS                 Status            = STATUS_SUCCESS;
    PVOID                    FilePointer       = NULL;
    PVOID                    PreviousValue     = NULL;
    POBJECT_NAME_INFORMATION pProcessImageName = NULL;
    PUNICODE_STRING          pTempUS           = NULL;
    ULONG                    NameLength        = 0;

    PAGED_CODE();

    *pImageFileName = NULL;
    
    if (NULL == Process->SeAuditProcessCreationInfo.ImageFileName) {

        //
        // The name has not been predetermined.  We must determine the process name.   First, reference the 
        // PFILE_OBJECT and lookup the name.  Then again check the process image name pointer against NULL.  
        // Finally, set the name.
        //

        Status = PsReferenceProcessFilePointer( Process, &FilePointer );
        
        if (NT_SUCCESS(Status)) {

            //
            // Get the process name information.  
            //

            Status = SeInitializeProcessAuditName( 
                          FilePointer,
                          TRUE, // skip audit policy
                          &pProcessImageName // to be allocated in nonpaged pool
                          );

            if (NT_SUCCESS(Status)) {

                //
                // Only use the pProcessImageName if the field in the process is currently NULL.
                //

                PreviousValue = InterlockedCompareExchangePointer(
                                    (PVOID *) &Process->SeAuditProcessCreationInfo.ImageFileName,
                                    (PVOID) pProcessImageName,
                                    (PVOID) NULL
                                    );
                
                if (NULL != PreviousValue) {
                    ExFreePool(pProcessImageName); // free what we caused to be allocated.
                }
            }
            ObDereferenceObject( FilePointer );
        }
    }
    
    
    if (NT_SUCCESS(Status)) {
        
        //
        // Allocate space for a buffer to contain the name for returning to the caller.
        //

        NameLength = sizeof(UNICODE_STRING) + Process->SeAuditProcessCreationInfo.ImageFileName->Name.MaximumLength;
        pTempUS = ExAllocatePoolWithTag( NonPagedPool, NameLength, 'aPeS' );

        if (NULL != pTempUS) {

            RtlCopyMemory( 
                pTempUS, 
                &Process->SeAuditProcessCreationInfo.ImageFileName->Name, 
                NameLength 
                );

            pTempUS->Buffer = (PWSTR)(((PUCHAR) pTempUS) + sizeof(UNICODE_STRING));
            *pImageFileName = pTempUS;

        } else {
            
            Status = STATUS_NO_MEMORY;
        }
    }

    return Status;
}



VOID
SepAuditAssignPrimaryToken(
    IN PEPROCESS Process,
    IN PACCESS_TOKEN AccessToken
    )

/*++

Routine Description:

    This routine generates an assign primary token audit.  It is up to the caller
    to determine if this routine should be called or not.

Arguments:

    Process - process which gets the new token

    AccessToken - new primary token for the process

Return Value:

    None.

--*/

{
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS TmpStatus;
    PSID UserSid;
    PTOKEN Token;
    HANDLE ProcessId;
    
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    PTOKEN CurrentToken;
    PEPROCESS CurrentProcess;
    HANDLE CurrentProcessId;
    PUNICODE_STRING CurrentImageFileName = NULL;
    PUNICODE_STRING ImageFileName = NULL;
    UNICODE_STRING NullString = {0};

    PAGED_CODE();

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    //
    // Get information about the current process, that is, the process
    // that is assigning a new primary token.
    //

    CurrentProcess = PsGetCurrentProcess();
    CurrentProcessId = PsProcessAuditId( CurrentProcess );
    SeCaptureSubjectContext( &SubjectSecurityContext );
    CurrentToken = EffectiveToken( &SubjectSecurityContext );

    if (CurrentToken == NULL) {
        Status = STATUS_NO_TOKEN;
        goto Cleanup;
    }

    UserSid = SepTokenUserSid( CurrentToken );
    TmpStatus = SeLocateProcessImageName( CurrentProcess, &CurrentImageFileName );
    
    if (!NT_SUCCESS(TmpStatus)) {
        CurrentImageFileName = &NullString;
    }
    
    //
    // Retrieve information about the process receiving the new token.
    //

    Token = (PTOKEN) AccessToken;
    ProcessId =  PsProcessAuditId( Process );

    TmpStatus = SeLocateProcessImageName( Process, &ImageFileName );

    if ( !NT_SUCCESS(TmpStatus) ) {
        ImageFileName = &NullString;
    }

    ASSERT( SeAdtParmTypeNone == 0 );

    AuditParameters.CategoryId = SE_CATEGID_DETAILED_TRACKING;
    AuditParameters.AuditId = SE_AUDITID_ASSIGN_TOKEN;
    AuditParameters.ParameterCount = 0;
    AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;

    SepSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, UserSid );
    AuditParameters.ParameterCount++;

    SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, (PUNICODE_STRING)&SeSubsystemName );
    AuditParameters.ParameterCount++;

    //
    // Information regarding the assigning process
    //

    SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, CurrentProcessId );
    AuditParameters.ParameterCount++;

    SepSetParmTypeFileSpec( AuditParameters, AuditParameters.ParameterCount, CurrentImageFileName );
    AuditParameters.ParameterCount++;

    SepSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, SepTokenAuthenticationId( CurrentToken ) );
    AuditParameters.ParameterCount++;

    //
    // Information about the process receiving the new primary token.
    //

    SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, ProcessId );
    AuditParameters.ParameterCount++;

    SepSetParmTypeFileSpec( AuditParameters, AuditParameters.ParameterCount, ImageFileName );
    AuditParameters.ParameterCount++;

    SepSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, SepTokenAuthenticationId( Token ) );
    AuditParameters.ParameterCount++;

    SepAdtLogAuditRecord( &AuditParameters );

Cleanup:

    if ( ImageFileName && ImageFileName != &NullString ) {
        ExFreePool( ImageFileName );
    }

    if ( CurrentImageFileName && CurrentImageFileName != &NullString ) {
        ExFreePool( CurrentImageFileName );
    }

    SeReleaseSubjectContext( &SubjectSecurityContext );

    if (!NT_SUCCESS(Status)) {
        SepAuditFailed(Status);
    }
}

VOID
SeAuditLPCInvalidUse(
    __in PUNICODE_STRING LpcCallName,
    __in PUNICODE_STRING LpcServerPort
    )

/*++

Routine Description:

    Audits the invalid use of an LPC port.

Arguments:

    LpcCallName - type of call: impersonation or reply
    
    LpcServerPort - name of port
    
Return Value:

    None.

--*/

{
    LUID UserAuthenticationId;
    PSID UserSid;
    LUID ThreadAuthenticationId;
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    PEPROCESS Process;
    HANDLE ProcessID;
    PUNICODE_STRING ImageFileName;
    UNICODE_STRING NullString = {0};
    NTSTATUS Status;

    PAGED_CODE();


    if ( SepAdtAuditThisEventWithContext( AuditCategorySystem, TRUE, FALSE, NULL )) {

        RtlZeroMemory (
           (PVOID) &AuditParameters,
           sizeof( AuditParameters )
           );

        Process   = PsGetCurrentProcess();
        ProcessID = PsProcessAuditId( Process );
        Status    = SeLocateProcessImageName( Process, &ImageFileName );

        if ( !NT_SUCCESS(Status) ) {
            ImageFileName = &NullString;
        }

        ASSERT( SeAdtParmTypeNone == 0 );

        AuditParameters.CategoryId     = SE_CATEGID_SYSTEM;
        AuditParameters.AuditId        = SE_AUDITID_LPC_INVALID_USE;
        AuditParameters.ParameterCount = 0;
        AuditParameters.Type           = EVENTLOG_AUDIT_SUCCESS;

        SeCaptureSubjectContext( &SubjectSecurityContext );
        
        UserSid              = SepTokenUserSid( SubjectSecurityContext.PrimaryToken );
        UserAuthenticationId = SepTokenAuthenticationId( SubjectSecurityContext.PrimaryToken );
        
        //
        // Fill in the AuditParameters structure.
        //

        SepSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, UserSid );
        AuditParameters.ParameterCount++;

        SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, (PUNICODE_STRING)&SeSubsystemName );
        AuditParameters.ParameterCount++;

        SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, ProcessID );
        AuditParameters.ParameterCount++;

        SepSetParmTypeFileSpec( AuditParameters, AuditParameters.ParameterCount, ImageFileName );
        AuditParameters.ParameterCount++;

        SepSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, UserAuthenticationId );
        AuditParameters.ParameterCount++;

        if ( SubjectSecurityContext.ClientToken ) {

            SepSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, SepTokenAuthenticationId( SubjectSecurityContext.ClientToken ));
        } else {

            SepSetParmTypeNoLogon( AuditParameters, AuditParameters.ParameterCount );
        }

        AuditParameters.ParameterCount++;

        SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, LpcCallName );
        AuditParameters.ParameterCount++;

        SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, LpcServerPort );
        AuditParameters.ParameterCount++;

        SepAdtLogAuditRecord( &AuditParameters );

        SeReleaseSubjectContext( &SubjectSecurityContext );

        if ( ImageFileName != &NullString ) {
            ExFreePool( ImageFileName );
        }
    }
    return;
}


VOID
SeAuditSystemTimeChange(
    __in LARGE_INTEGER OldTime,
    __in LARGE_INTEGER NewTime
    )
/*++

Routine Description:

    Audits the modification of system time.

Arguments:

    OldTime - Time before modification.
    NewTime - Time after modification.

Return Value:

    None.

--*/

{
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    PSID UserSid;
    LUID LogonId;
    HANDLE ProcessId;
    PEPROCESS Process;
    PUNICODE_STRING ImageFileName;
    UNICODE_STRING NullString = {0};
    NTSTATUS Status;
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    
    PAGED_CODE();

    SeCaptureSubjectContext( &SubjectSecurityContext );

    //
    // Make sure that we care to audit system events.
    //

    if (SepAdtAuditThisEventWithContext(AuditCategorySystem, TRUE, FALSE, &SubjectSecurityContext)) {
        
        UserSid = SepTokenUserSid( EffectiveToken(&SubjectSecurityContext) );
        LogonId = SepTokenAuthenticationId( SubjectSecurityContext.PrimaryToken );
        
        Process = PsGetCurrentProcess();

        RtlZeroMemory (
           (PVOID) &AuditParameters,
           sizeof( AuditParameters )
           );

        Status = SeLocateProcessImageName( Process, &ImageFileName );

        if ( !NT_SUCCESS(Status) ) {
            ImageFileName = &NullString;
        }

        ASSERT( SeAdtParmTypeNone == 0 );

        AuditParameters.CategoryId = SE_CATEGID_SYSTEM;
        AuditParameters.AuditId = SE_AUDITID_SYSTEM_TIME_CHANGE;
        AuditParameters.ParameterCount = 0;
        AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;

        SepSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, UserSid );
        AuditParameters.ParameterCount++;

        SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, (PUNICODE_STRING)&SeSubsystemName );
        AuditParameters.ParameterCount++;

        ProcessId = PsProcessAuditId( Process );

        SepSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, ProcessId );
        AuditParameters.ParameterCount++;

        SepSetParmTypeFileSpec( AuditParameters, AuditParameters.ParameterCount, ImageFileName );
        AuditParameters.ParameterCount++;

        SepSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, LogonId );
        AuditParameters.ParameterCount++;

        if ( SubjectSecurityContext.ClientToken ) {

            SepSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, SepTokenAuthenticationId( SubjectSecurityContext.ClientToken ));
        } else {

            SepSetParmTypeNoLogon( AuditParameters, AuditParameters.ParameterCount );
        }

        AuditParameters.ParameterCount++;
        SepSetParmTypeTime( AuditParameters, AuditParameters.ParameterCount, OldTime );
        AuditParameters.ParameterCount++;

        SepSetParmTypeTime( AuditParameters, AuditParameters.ParameterCount, NewTime );
        AuditParameters.ParameterCount++;

        SepAdtLogAuditRecord( &AuditParameters );
        
        if ( ImageFileName != &NullString ) {
            ExFreePool( ImageFileName );
        }
    }
    SeReleaseSubjectContext( &SubjectSecurityContext );
}


VOID
SeAuditHardLinkCreation(
    __in PUNICODE_STRING FileName,
    __in PUNICODE_STRING LinkName,
    __in BOOLEAN bSuccess
    )

/*++

Routine Description:

    Audits the attempted creation of a hard link.

    The caller checks audit policy.

Arguments:

    FileName - Name of the original file.
    
    LinkName - The name of the hard link.
    
    bSuccess - Boolean indicating if the hard link creation attempt was successful or not.
    
Return Value:

    None.

--*/

{
    LUID UserAuthenticationId;
    PSID UserSid;
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    SE_ADT_PARAMETER_ARRAY AuditParameters = { 0 };

    PAGED_CODE();

    ASSERT( SeAdtParmTypeNone == 0 );

    AuditParameters.CategoryId     = SE_CATEGID_OBJECT_ACCESS;
    AuditParameters.AuditId        = SE_AUDITID_HARDLINK_CREATION;
    AuditParameters.ParameterCount = 0;
    AuditParameters.Type           = bSuccess ? EVENTLOG_AUDIT_SUCCESS : EVENTLOG_AUDIT_FAILURE;

    //
    // Use the effective token.
    //

    SeCaptureSubjectContext( &SubjectSecurityContext );
    UserSid              = SepTokenUserSid( EffectiveToken( &SubjectSecurityContext ));
    UserAuthenticationId = SepTokenAuthenticationId( EffectiveToken( &SubjectSecurityContext ));

    //
    // Fill in the AuditParameters structure.
    //

    SepSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, UserSid );
    AuditParameters.ParameterCount++;

    SepSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, (PUNICODE_STRING)&SeSubsystemName );
    AuditParameters.ParameterCount++;

    SepSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, UserAuthenticationId );
    AuditParameters.ParameterCount++;

    SepSetParmTypeFileSpec( AuditParameters, AuditParameters.ParameterCount, FileName );
    AuditParameters.ParameterCount++;

    SepSetParmTypeFileSpec( AuditParameters, AuditParameters.ParameterCount, LinkName );
    AuditParameters.ParameterCount++;

    SepAdtLogAuditRecord( &AuditParameters );

    SeReleaseSubjectContext( &SubjectSecurityContext );

    return;
}


NTSTATUS
SeSetAuditParameter(
    __inout PSE_ADT_PARAMETER_ARRAY AuditParameters,
    __in SE_ADT_PARAMETER_TYPE Type,
    __in ULONG Index,
    __in PVOID Data
    )

/*++

Routine Description:

    This sets a parameter in the passed AuditParameters.
    
Arguments:

    AuditParameters - describes an audit to build.
    Type - the type of the parameter.
    Index - the index into the AuditParameters->Parameters to place the data.
    Data - The audit data.
    
Return Value:

    NTSTATUS.
    
--*/

{
    NTSTATUS Status;
    ULONG Length;

    Status = STATUS_SUCCESS;
    Length = 0;

    if (AuditParameters == NULL) {

        return STATUS_INVALID_PARAMETER;
    }

    switch (Type) {
        
        default:
            Status = STATUS_INVALID_PARAMETER;
            break;
        
        case SeAdtParmTypeNone:
        case SeAdtParmTypeNoLogonId:
            AuditParameters->Parameters[Index].Length = 0;
            break;

        case SeAdtParmTypeUserAccountControl:
        case SeAdtParmTypeNoUac:
        case SeAdtParmTypeAccessMask:
        case SeAdtParmTypeObjectTypes:
        case SeAdtParmTypeStringList:
        case SeAdtParmTypeSidList:
            Status = STATUS_NOT_IMPLEMENTED;
            break;

        case SeAdtParmTypeFileSpec:
        case SeAdtParmTypeString:
            Length = sizeof(UNICODE_STRING) + ((PUNICODE_STRING)Data)->Length;
            AuditParameters->Parameters[Index].Address = Data;
            break;

        case SeAdtParmTypeSid:
            Length = SeLengthSid((PSID)Data);
            AuditParameters->Parameters[Index].Address = Data;
            break;

        case SeAdtParmTypePrivs:
            Length = SepPrivilegeSetSize((PPRIVILEGE_SET)Data);
            AuditParameters->Parameters[Index].Address = Data;
            break;

        case SeAdtParmTypeGuid:
            Length = sizeof(GUID);
            AuditParameters->Parameters[Index].Address = Data;
            break;

        case SeAdtParmTypeSockAddr:
            Length = sizeof(SOCKADDR_IN);
            AuditParameters->Parameters[Index].Address = Data;
            break;

        case SeAdtParmTypeUlong:
        case SeAdtParmTypeHexUlong:
        case SeAdtParmTypeMessage:
            Length = sizeof(ULONG);
            AuditParameters->Parameters[Index].Data[0] = (ULONG_PTR)*(PULONG)Data;
            break;

        case SeAdtParmTypePtr:
            Length = sizeof(ULONG_PTR);
            AuditParameters->Parameters[Index].Data[0] = (ULONG_PTR)Data;
            break;

        case SeAdtParmTypeLuid:
        case SeAdtParmTypeLogonId:
            Length = sizeof(LUID);
            RtlCopyMemory(
                &AuditParameters->Parameters[Index].Data[0],
                Data,
                Length
                );
            break;

        case SeAdtParmTypeDuration:
        case SeAdtParmTypeHexInt64:
        case SeAdtParmTypeDateTime:
        case SeAdtParmTypeTime:
            Length = sizeof(LARGE_INTEGER);
            RtlCopyMemory(
                &AuditParameters->Parameters[Index].Data[0],
                Data,
                Length
                );
            break;
    }

    if (NT_SUCCESS(Status)) {
        
        AuditParameters->Parameters[Index].Type = Type;
        AuditParameters->Parameters[Index].Length = Length;
    }

    return Status;
}


NTSTATUS
SeReportSecurityEvent(
    __in ULONG Flags,
    __in PUNICODE_STRING SourceName,
    __in_opt PSID UserSid,
    __in PSE_ADT_PARAMETER_ARRAY AuditParameters
    )

/*++

Routine Description

    This routine generates an audit which will be logged in the security event 
    log.
    
    The event will only be generated if allowed by audit policy.
    
Arguments

    Flags - None defined.
    SourceName - The source that is generating the audit.  The source must be 
        registered with the event log service via AuthzInstallSecurityEventSource.
    UserSid - optional Sid that will be specified as the user generating the 
        audit in the event log headers.  If left NULL then the effective token
        is queried for the user Sid.
    AuditParameters - pointer to an SE_ADT_PARAMETER_ARRAY.  The following fields
        of the structure should be specified by the caller:
            CategoryId - SE_CATEGID_* from msaudite.h
            AuditId - the ID of the audit to be generated.
            ParameterCount - the number of entries in the Parameters array.
            Type - EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE.
            Parameters - To initialize each entry in the array please use the
                provided helper macros named SeSetParmType*.  A macro exists
                for each type enumerated in SE_ADT_PARAMETER_TYPE.  A caller 
                can specify at most SE_MAX_GENERIC_AUDIT_PARAMETERS in this
                array.  The Se component must reserve space in the structure
                for additional information.
                
Return Value

    NTSTATUS.

--*/

{
    NTSTATUS Status;
    SE_ADT_PARAMETER_ARRAY CompleteParameters;
    PSID AuditSid;
    SECURITY_SUBJECT_CONTEXT Context;

    if (Flags != 0                 ||
        SourceName == NULL         || 
        SourceName->Buffer == NULL || 
        SourceName->Length == 0    ||
        AuditParameters == NULL    ||
        AuditParameters->ParameterCount > SE_MAX_GENERIC_AUDIT_PARAMETERS) {

        return STATUS_INVALID_PARAMETER;
    }

#if DBG
    Status = RtlValidateUnicodeString(0, SourceName);

    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    if (UserSid != NULL && 
        RtlValidSid(UserSid) == FALSE) {

        return STATUS_INVALID_PARAMETER;
    }
#endif

    //
    // Determine which Sid to specify as the User.  If the UserSid was provided
    // then use that.  Otherwise get the user Sid from the effective token.
    //

    if (UserSid != NULL) {

        AuditSid = UserSid;

    } else {

        SeCaptureSubjectContext(&Context);
        AuditSid = SepTokenUserSid(EffectiveToken(&Context));
    }

    //
    // Query the policy for the given category.
    //

    if (!SepAdtAuditThisEventWithContext( 
             AuditParameters->CategoryId - 1,
             AuditParameters->Type == EVENTLOG_AUDIT_SUCCESS ? TRUE : FALSE, 
             AuditParameters->Type == EVENTLOG_AUDIT_FAILURE ? TRUE : FALSE, 
             AuditSid == UserSid ? NULL : &Context
             )) {

        goto Cleanup;
    }

    //
    // Build up the CompleteParameters structure.  This is the 
    // structure we will send to the LSA.  The LSA and the eventlog
    // will parse this as user defined audit.
    //

    RtlZeroMemory(
        &CompleteParameters,
        sizeof(CompleteParameters)
        );

    CompleteParameters.AuditId        = SE_AUDITID_GENERIC_AUDIT_EVENT;
    CompleteParameters.CategoryId     = AuditParameters->CategoryId;
    CompleteParameters.Type           = AuditParameters->Type;
    CompleteParameters.ParameterCount = 0;
    
    //
    // The first two entries in an audit are always the Sid and
    // the Security source name.
    //

    SepSetParmTypeSid( 
        CompleteParameters, 
        CompleteParameters.ParameterCount, 
        AuditSid
        );

    CompleteParameters.ParameterCount++;

    SepSetParmTypeString( 
        CompleteParameters, 
        CompleteParameters.ParameterCount, 
        (PUNICODE_STRING)&SeSubsystemName 
        );

    CompleteParameters.ParameterCount++;

    //
    // To generate a non system security event, we actually generate
    // an audit of type SE_AUDITID_GENERIC_AUDIT_EVENT.  In this 
    // audit, the third parameter is the caller specified Source name.  
    // The fourth parameter is the specified Audit Id.  The event log 
    // knows how to parse this special audit.
    //

    SepSetParmTypeString( 
        CompleteParameters,
        CompleteParameters.ParameterCount,
        SourceName
        );

    CompleteParameters.ParameterCount++;

    SepSetParmTypeUlong(
        CompleteParameters,
        CompleteParameters.ParameterCount,
        AuditParameters->AuditId
        );

    CompleteParameters.ParameterCount++;

    //
    // Now copy over the remainder of the caller provided data.
    //

    RtlCopyMemory(
        &CompleteParameters.Parameters[CompleteParameters.ParameterCount],
        &AuditParameters->Parameters[0],
        sizeof(SE_ADT_PARAMETER_ARRAY_ENTRY) * AuditParameters->ParameterCount
        );

    CompleteParameters.ParameterCount += AuditParameters->ParameterCount;

    ASSERT(CompleteParameters.ParameterCount <= SE_MAX_AUDIT_PARAMETERS);

    SepAdtLogAuditRecord(&CompleteParameters);

Cleanup:

    if (AuditSid != UserSid) {

        SeReleaseSubjectContext(&Context);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\tokenopn.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    tokenopn.c

Abstract:

   This module implements the open thread and process token services.

--*/

#include "pch.h"

#pragma hdrstop


NTSTATUS
SepCreateImpersonationTokenDacl(
    IN PTOKEN Token,
    IN PACCESS_TOKEN PrimaryToken,
    OUT PACL *Acl
    );

#ifdef ALLOC_PRAGMA
NTSTATUS
SepOpenTokenOfThread(
    IN HANDLE ThreadHandle,
    IN BOOLEAN OpenAsSelf,
    OUT PACCESS_TOKEN *Token,
    OUT PETHREAD *Thread,
    OUT PBOOLEAN CopyOnOpen,
    OUT PBOOLEAN EffectiveOnly,
    OUT PSECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );
#pragma alloc_text(PAGE,SepCreateImpersonationTokenDacl)
#pragma alloc_text(PAGE,NtOpenProcessToken)
#pragma alloc_text(PAGE,NtOpenProcessTokenEx)
#pragma alloc_text(PAGE,SepOpenTokenOfThread)
#pragma alloc_text(PAGE,NtOpenThreadToken)
#pragma alloc_text(PAGE,NtOpenThreadTokenEx)
#endif



NTSTATUS
SepCreateImpersonationTokenDacl(
    __in PTOKEN Token,
    __in PACCESS_TOKEN PrimaryToken,
    __deref_out PACL *Acl
    )
/*++

Routine Description:

    This routine modifies the DACL protecting the passed token to allow
    the current user (described by the PrimaryToken parameter) full access.
    This permits callers of NtOpenThreadToken to call with OpenAsSelf==TRUE
    and succeed.

    The new DACL placed on the token is as follows:

    ACE 0 - Server gets TOKEN_ALL_ACCESS

    ACE 1 - Client gets TOKEN_ALL_ACCESS

    ACE 2 - Admins gets TOKEN_ALL_ACCESS

    ACE 3 - System gets TOKEN_ALL_ACCESS

    ACE 4 - Restricted gets TOKEN_ALL_ACCESS


Arguments:

    Token - The token whose protection is to be modified.

    PrimaryToken - Token representing the subject to be granted access.

    Acl - Returns the modified ACL, allocated out of PagedPool.


Return Value:


--*/

{
    PSID ServerUserSid;
    PSID ClientUserSid;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AclLength;
    PACL NewDacl;
    PSECURITY_DESCRIPTOR OldDescriptor;
    BOOLEAN MemoryAllocated;
    PACL OldDacl;
    BOOLEAN DaclPresent;
    BOOLEAN DaclDefaulted;

    PAGED_CODE();

    ServerUserSid = ((PTOKEN)PrimaryToken)->UserAndGroups[0].Sid;

    ClientUserSid = Token->UserAndGroups[0].Sid;

    //
    // Compute how much space we'll need for the new DACL.
    //

    AclLength = 5 * sizeof( ACCESS_ALLOWED_ACE ) - 5 * sizeof( ULONG ) +
                SeLengthSid( ServerUserSid ) + SeLengthSid( SeLocalSystemSid ) +
                SeLengthSid( ClientUserSid ) + SeLengthSid( SeAliasAdminsSid ) +
                SeLengthSid( SeRestrictedSid ) + sizeof( ACL );

    NewDacl = ExAllocatePool( PagedPool, AclLength );

    if (NewDacl == NULL) {

        *Acl = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = RtlCreateAcl( NewDacl, AclLength, ACL_REVISION2 );
    ASSERT(NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 ServerUserSid
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 ClientUserSid
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 SeAliasAdminsSid
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 SeLocalSystemSid
                 );
    ASSERT( NT_SUCCESS( Status ));

    if(ARGUMENT_PRESENT(((PTOKEN)PrimaryToken)->RestrictedSids) ||
       ARGUMENT_PRESENT(Token->RestrictedSids)) {
        Status = RtlAddAccessAllowedAce (
                     NewDacl,
                     ACL_REVISION2,
                     TOKEN_ALL_ACCESS,
                     SeRestrictedSid
                     );
        ASSERT( NT_SUCCESS( Status ));
    }

    *Acl = NewDacl;
    return STATUS_SUCCESS;
}



NTSTATUS
NtOpenProcessToken(
    __in HANDLE ProcessHandle,
    __in ACCESS_MASK DesiredAccess,
    __out PHANDLE TokenHandle
    )

/*++

Routine Description:

    Open a token object associated with a process and return a handle
    that may be used to access that token.

Arguments:

    ProcessHandle - Specifies the process whose token is to be
        opened.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the token.  These access types are reconciled
        with the Discretionary Access Control list of the token to
        determine whether the accesses will be granted or denied.

    TokenHandle - Receives the handle of the newly opened token.

Return Value:

    STATUS_SUCCESS - Indicates the operation was successful.

--*/
{
    return NtOpenProcessTokenEx (ProcessHandle,
                                 DesiredAccess,
                                 0,
                                 TokenHandle);
}

NTSTATUS
NtOpenProcessTokenEx(
    __in HANDLE ProcessHandle,
    __in ACCESS_MASK DesiredAccess,
    __in ULONG HandleAttributes,
    __out PHANDLE TokenHandle
    )

/*++

Routine Description:

    Open a token object associated with a process and return a handle
    that may be used to access that token.

Arguments:

    ProcessHandle - Specifies the process whose token is to be
        opened.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the token.  These access types are reconciled
        with the Discretionary Access Control list of the token to
        determine whether the accesses will be granted or denied.

    HandleAttributes - Attributes for the created handle. Only OBJ_KERNEL_HANDLE at present.

    TokenHandle - Receives the handle of the newly opened token.

Return Value:

    STATUS_SUCCESS - Indicates the operation was successful.

--*/
{

    PVOID Token;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    HANDLE LocalHandle;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    //
    // Sanitize the handle attribute flags
    //
    HandleAttributes = ObSanitizeHandleAttributes (HandleAttributes, PreviousMode);

    //
    //  Probe parameters
    //

    if (PreviousMode != KernelMode) {

        try {

            ProbeForWriteHandle(TokenHandle);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }  // end_try

    } //end_if


    //
    // Validate access to the process and obtain a pointer to the
    // process's token.  If successful, this will cause the token's
    // reference count to be incremented.
    //

    Status = PsOpenTokenOfProcess( ProcessHandle, ((PACCESS_TOKEN *)&Token));

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    //  Now try to open the token for the specified desired access
    //

    Status = ObOpenObjectByPointer(
                 (PVOID)Token,         // Object
                 HandleAttributes,     // HandleAttributes
                 NULL,                 // AccessState
                 DesiredAccess,        // DesiredAccess
                 SeTokenObjectType,   // ObjectType
                 PreviousMode,         // AccessMode
                 &LocalHandle          // Handle
                 );

    //
    //  And decrement the reference count of the token to counter
    //  the action performed by PsOpenTokenOfProcess().  If the open
    //  was successful, the handle will have caused the token's
    //  reference count to have been incremented.
    //

    ObDereferenceObject( Token );

    //
    //  Return the new handle
    //

    if (NT_SUCCESS(Status)) {

        try {

            *TokenHandle = LocalHandle;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            return GetExceptionCode();

        }
    }

    return Status;

}

NTSTATUS
SepOpenTokenOfThread(
    __in HANDLE ThreadHandle,
    __in BOOLEAN OpenAsSelf,
    __deref_out PACCESS_TOKEN *Token,
    __deref_out PETHREAD *Thread,
    __out PBOOLEAN CopyOnOpen,
    __out PBOOLEAN EffectiveOnly,
    __out PSECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )

/*++

Routine Description:

    This function does the thread specific processing of
    an NtOpenThreadToken() service.

    The service validates that the handle has appropriate access
    to reference the thread.  If so, it goes on to increment
    the reference count of the token object to prevent it from
    going away while the rest of the NtOpenThreadToken() request
    is processed.

    NOTE: If this call completes successfully, the caller is responsible
          for decrementing the reference count of the target token.
          This must be done using PsDereferenceImpersonationToken().

Arguments:

    ThreadHandle - Supplies a handle to a thread object.

    OpenAsSelf - Is a boolean value indicating whether the access should
        be made using the calling thread's current security context, which
        may be that of a client (if impersonating), or using the caller's
        process-level security context.  A value of FALSE indicates the
        caller's current context should be used un-modified.  A value of
        TRUE indicates the request should be fulfilled using the process
        level security context.

    Token - If successful, receives a pointer to the thread's token
        object.

    CopyOnOpen - The current value of the Thread->Client->CopyOnOpen field.

    EffectiveOnly - The current value of the Thread->Client->EffectiveOnly field.

    ImpersonationLevel - The current value of the Thread->Client->ImpersonationLevel
        field.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_NO_TOKEN - Indicates the referenced thread is not currently
        impersonating a client.

    STATUS_CANT_OPEN_ANONYMOUS - Indicates the client requested anonymous
        impersonation level.  An anonymous token can not be opened.

    status may also be any value returned by an attempt the reference
    the thread object for THREAD_QUERY_INFORMATION access.

--*/

{

    NTSTATUS
        Status;

    KPROCESSOR_MODE
        PreviousMode;

    SE_IMPERSONATION_STATE
        DisabledImpersonationState;

    BOOLEAN
        RestoreImpersonationState = FALSE;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();


    //
    //  Make sure the handle grants the appropriate access to the specified
    //  thread.
    //

    Status = ObReferenceObjectByHandle(
                 ThreadHandle,
                 THREAD_QUERY_INFORMATION,
                 PsThreadType,
                 PreviousMode,
                 (PVOID *)Thread,
                 NULL
                 );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    //  Reference the impersonation token, if there is one
    //

    (*Token) = PsReferenceImpersonationToken( *Thread,
                                              CopyOnOpen,
                                              EffectiveOnly,
                                              ImpersonationLevel
                                              );




    //
    // Make sure there is a token
    //

    if ((*Token) == NULL) {
        ObDereferenceObject( *Thread );
        (*Thread) = NULL;
        return STATUS_NO_TOKEN;
    }


    //
    //  Make sure the ImpersonationLevel is high enough to allow
    //  the token to be opened.
    //

    if ((*ImpersonationLevel) <= SecurityAnonymous) {
        PsDereferenceImpersonationToken( (*Token) );
        ObDereferenceObject( *Thread );
        (*Thread) = NULL;
        (*Token) = NULL;
        return STATUS_CANT_OPEN_ANONYMOUS;
    }


    return STATUS_SUCCESS;

}


NTSTATUS
NtOpenThreadToken(
    __in HANDLE ThreadHandle,
    __in ACCESS_MASK DesiredAccess,
    __in BOOLEAN OpenAsSelf,
    __out PHANDLE TokenHandle
    )

/*++


Routine Description:

Open a token object associated with a thread and return a handle that
may be used to access that token.

Arguments:

    ThreadHandle - Specifies the thread whose token is to be opened.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the token.  These access types are reconciled
        with the Discretionary Access Control list of the token to
        determine whether the accesses will be granted or denied.

    OpenAsSelf - Is a boolean value indicating whether the access should
        be made using the calling thread's current security context, which
        may be that of a client if impersonating, or using the caller's
        process-level security context.  A value of FALSE indicates the
        caller's current context should be used un-modified.  A value of
        TRUE indicates the request should be fulfilled using the process
        level security context.

        This parameter is necessary to allow a server process to open
        a client's token when the client specified IDENTIFICATION level
        impersonation.  In this case, the caller would not be able to
        open the client's token using the client's context (because you
        can't create executive level objects using IDENTIFICATION level
        impersonation).

    TokenHandle - Receives the handle of the newly opened token.

Return Value:

    STATUS_SUCCESS - Indicates the operation was successful.

    STATUS_NO_TOKEN - Indicates an attempt has been made to open a
        token associated with a thread that is not currently
        impersonating a client.

    STATUS_CANT_OPEN_ANONYMOUS - Indicates the client requested anonymous
        impersonation level.  An anonymous token can not be opened.

--*/
{
    return NtOpenThreadTokenEx (ThreadHandle,
                                DesiredAccess,
                                OpenAsSelf,
                                0,
                                TokenHandle);
}

NTSTATUS
NtOpenThreadTokenEx(
    __in HANDLE ThreadHandle,
    __in ACCESS_MASK DesiredAccess,
    __in BOOLEAN OpenAsSelf,
    __in ULONG HandleAttributes,
    __out PHANDLE TokenHandle
    )

/*++


Routine Description:

Open a token object associated with a thread and return a handle that
may be used to access that token.

Arguments:

    ThreadHandle - Specifies the thread whose token is to be opened.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the token.  These access types are reconciled
        with the Discretionary Access Control list of the token to
        determine whether the accesses will be granted or denied.

    OpenAsSelf - Is a boolean value indicating whether the access should
        be made using the calling thread's current security context, which
        may be that of a client if impersonating, or using the caller's
        process-level security context.  A value of FALSE indicates the
        caller's current context should be used un-modified.  A value of
        TRUE indicates the request should be fulfilled using the process
        level security context.

        This parameter is necessary to allow a server process to open
        a client's token when the client specified IDENTIFICATION level
        impersonation.  In this case, the caller would not be able to
        open the client's token using the client's context (because you
        can't create executive level objects using IDENTIFICATION level
        impersonation).

    HandleAttributes - Attributes applied to the handle OBJ_KERNEL_HANDLE

    TokenHandle - Receives the handle of the newly opened token.

Return Value:

    STATUS_SUCCESS - Indicates the operation was successful.

    STATUS_NO_TOKEN - Indicates an attempt has been made to open a
        token associated with a thread that is not currently
        impersonating a client.

    STATUS_CANT_OPEN_ANONYMOUS - Indicates the client requested anonymous
        impersonation level.  An anonymous token can not be opened.

--*/
{

    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    PVOID Token;
    PTOKEN NewToken = NULL;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SE_IMPERSONATION_STATE DisabledImpersonationState;
    BOOLEAN RestoreImpersonationState = FALSE;

    HANDLE LocalHandle = NULL;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PACL NewAcl = NULL;
    PETHREAD Thread = NULL;
    PETHREAD OriginalThread = NULL;
    PACCESS_TOKEN PrimaryToken;
    SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    //
    // Sanitize the handle attribute flags
    //

    HandleAttributes = ObSanitizeHandleAttributes (HandleAttributes, PreviousMode);

    //
    //  Probe parameters
    //

    if (PreviousMode != KernelMode) {

        try {

            ProbeForWriteHandle(TokenHandle);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }  // end_try

    } //end_if

    //
    // Validiate access to the thread and obtain a pointer to the
    // thread's token (if there is one).  If successful, this will
    // cause the token's reference count to be incremented.
    //
    // This routine disabled impersonation as necessary to properly
    // honor the OpenAsSelf flag.
    //

    Status = SepOpenTokenOfThread( ThreadHandle,
                                  OpenAsSelf,
                                  ((PACCESS_TOKEN *)&Token),
                                  &OriginalThread,
                                  &CopyOnOpen,
                                  &EffectiveOnly,
                                  &ImpersonationLevel
                                  );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }


    //
    //  The token was successfully referenced.
    //

    //
    // We need to create and/or open a token object, so disable impersonation
    // if necessary.
    //

    if (OpenAsSelf) {
         RestoreImpersonationState = PsDisableImpersonation(
                                         PsGetCurrentThread(),
                                         &DisabledImpersonationState
                                         );
    }

    //
    //  If the CopyOnOpen flag is not set, then the token can be
    //  opened directly.  Otherwise, the token must be duplicated,
    //  and a handle to the duplicate returned.
    //

    if (CopyOnOpen) {

        //
        // Create the new security descriptor for the token.
        //
        // We must obtain the correct SID to put into the Dacl.  Do this
        // by finding the process associated with the passed thread
        // and grabbing the User SID out of that process's token.
        // If we just use the current SubjectContext, we'll get the
        // SID of whoever is calling us, which isn't what we want.
        //

        Status = ObReferenceObjectByHandle(
                     ThreadHandle,
                     THREAD_ALL_ACCESS,
                     PsThreadType,
                     KernelMode,
                     (PVOID)&Thread,
                     NULL
                     );

        //
        // Verify that the handle is still pointer to the same thread
        //

        if (NT_SUCCESS(Status) && (Thread != OriginalThread)) {
            Status = STATUS_OBJECT_TYPE_MISMATCH;
        }

        if (NT_SUCCESS(Status)) {
            PEPROCESS Process = THREAD_TO_PROCESS(Thread);

            PrimaryToken = PsReferencePrimaryToken(Process);

            Status = SepCreateImpersonationTokenDacl(
                         (PTOKEN)Token,
                         PrimaryToken,
                         &NewAcl
                         );

            PsDereferencePrimaryTokenEx( Process, PrimaryToken );

            if (NT_SUCCESS( Status )) {

                if (NewAcl != NULL) {

                    //
                    // There exist tokens that either do not have security descriptors at all,
                    // or have security descriptors, but do not have DACLs.  In either case, do
                    // nothing.
                    //

                    Status = RtlCreateSecurityDescriptor ( &SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );
                    ASSERT( NT_SUCCESS( Status ));

                    Status = RtlSetDaclSecurityDescriptor (
                                 &SecurityDescriptor,
                                 TRUE,
                                 NewAcl,
                                 FALSE
                                 );

                    ASSERT( NT_SUCCESS( Status ));
                }

                InitializeObjectAttributes(
                    &ObjectAttributes,
                    NULL,
                    HandleAttributes,
                    NULL,
                    NewAcl == NULL ? NULL : &SecurityDescriptor
                    );

                //
                // Open a copy of the token
                //

                Status = SepDuplicateToken(
                             (PTOKEN)Token,        // ExistingToken
                             &ObjectAttributes,    // ObjectAttributes
                             EffectiveOnly,        // EffectiveOnly
                             TokenImpersonation,   // TokenType
                             ImpersonationLevel,   // ImpersonationLevel
                             KernelMode,           // RequestorMode must be kernel mode
                             &NewToken
                             );

                if (NT_SUCCESS( Status )) {

                    //
                    // Reference the token so it doesn't go away
                    //

                    ObReferenceObject(NewToken);

                    //
                    //  Insert the new token
                    //

                    Status = ObInsertObject( NewToken,
                                             NULL,
                                             DesiredAccess,
                                             0,
                                             (PVOID *)NULL,
                                             &LocalHandle
                                             );
                }
            }
        }


    } else {

        //
        // We do not have to modify the security on the token in the static case,
        // because in all the places in the system where impersonation takes place
        // over a secure transport (e.g., LPC), CopyOnOpen is set.  The only reason
        // we'be be here is if the impersonation is taking place because someone did
        // an NtSetInformationThread and passed in a token.
        //
        // In that case, we absolutely do not want to give the caller guaranteed
        // access, because that would allow anyone who has access to a thread to
        // impersonate any of that thread's clients for any access.
        //

        //
        //  Open the existing token
        //

        Status = ObOpenObjectByPointer(
                     (PVOID)Token,         // Object
                     HandleAttributes,     // HandleAttributes
                     NULL,                 // AccessState
                     DesiredAccess,        // DesiredAccess
                     SeTokenObjectType,   // ObjectType
                     PreviousMode,         // AccessMode
                     &LocalHandle          // Handle
                     );
    }

    if (NewAcl != NULL) {
        ExFreePool( NewAcl );
    }

    if (RestoreImpersonationState) {
        PsRestoreImpersonation(
            PsGetCurrentThread(),
            &DisabledImpersonationState
            );
    }

    //
    //  And decrement the reference count of the existing token to counter
    //  the action performed by PsOpenTokenOfThread.  If the open
    //  was successful, the handle will have caused the token's
    //  reference count to have been incremented.
    //

    ObDereferenceObject( Token );

    if (NT_SUCCESS( Status ) && CopyOnOpen) {

        //
        // Assign the newly duplicated token to the thread.
        //

        PsImpersonateClient( Thread,
                             NewToken,
                             FALSE,  // turn off CopyOnOpen flag
                             EffectiveOnly,
                             ImpersonationLevel
                             );

    }

    //
    // We've impersonated the token so let go of our reference
    //

    if (NewToken != NULL) {
        ObDereferenceObject( NewToken );
    }

    if (CopyOnOpen && (Thread != NULL)) {

        ObDereferenceObject( Thread );
    }

    if (OriginalThread != NULL) {
        ObDereferenceObject(OriginalThread);
    }

    //
    //  Return the new handle
    //

    if (NT_SUCCESS(Status)) {
        try {
            *TokenHandle = LocalHandle;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\tokenp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    tokenp.h

Abstract:

    This module contains the internal (private) declarations needed by the
    TOKEN object routines.

    It also contains global variables needed by the TOKEN object routines.

--*/

#ifndef _TOKENP_
#define _TOKENP_

#include "ntos.h"
#include "sep.h"
#include "seopaque.h"



/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                Token Diagnostics                                    //
//                                                                     //
/////////////////////////////////////////////////////////////////////////



#if DBG
#define TOKEN_DIAGNOSTICS_ENABLED 1
#endif // DBG


//
// These definitions are useful diagnostics aids
//

#if TOKEN_DIAGNOSTICS_ENABLED

//
// Test for enabled diagnostic
//

#define IF_TOKEN_GLOBAL( FlagName ) \
    if (TokenGlobalFlag & (TOKEN_DIAG_##FlagName))

//
// Diagnostics print statement
//

#define TokenDiagPrint( FlagName, _Text_ )                               \
    IF_TOKEN_GLOBAL( FlagName )                                          \
        DbgPrint _Text_



#else  // !TOKEN_DIAGNOSTICS_ENABLED

//
// No diagnostics included in build
//


//
// Test for diagnostics enabled
//

#define IF_TOKEN_GLOBAL( FlagName ) if (FALSE)

//
// Diagnostics print statement (expands to no-op)
//

#define TokenDiagPrint( FlagName, _Text_ )     ;

#endif // TOKEN_DIAGNOSTICS_ENABLED


//
// The following flags enable or disable various diagnostic
// capabilities within token code.  These flags are set in
// TokenGlobalFlag (only available within a DBG system).
//
//
//      TOKEN_LOCKS - Display information about acquisition and freeing
//          of token locks.
//

#define TOKEN_DIAG_TOKEN_LOCKS          ((ULONG) 0x00000001L)


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                Token Related Constants                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
// By default, a token is charged the following for its dynamic component.
// The dynamic component houses the default ACL and primary group ID.
// If the size of these parameters passed upon token creation are larger
// than this default, then the larger value will be charged.
//

#define TOKEN_DEFAULT_DYNAMIC_CHARGE 500

//
// AuditPolicy bit array is arranged with 4 bits for each audit category.
// The bit ordering for each category is:
//     Success Include, Success Exclude, Failure Include, Failure Exclude
// The number of tokens that have audit policies
// are tracked in SepTokenPolicyCounter.  This is done so that when all tokens
// with policies are gone (ie SepTokenPolicyCounter == 0) the routines that
// decide if an audit should be generated can execute faster.
//
    
typedef struct _SEP_AUDIT_POLICY_CATEGORIES {
    ULONG System : 4;
    ULONG Logon : 4;
    ULONG ObjectAccess : 4;
    ULONG PrivilegeUse : 4;
    ULONG DetailedTracking : 4;
    ULONG PolicyChange : 4;
    ULONG AccountManagement : 4;
    ULONG DirectoryServiceAccess : 4;
    ULONG AccountLogon : 4;
} SEP_AUDIT_POLICY_CATEGORIES, *PSEP_AUDIT_POLICY_CATEGORIES;

typedef struct _SEP_AUDIT_POLICY_OVERLAY {
    ULONGLONG PolicyBits : 36;
    ULONGLONG SetBit : 1;
} SEP_AUDIT_POLICY_OVERLAY, *PSEP_AUDIT_POLICY_OVERLAY;

typedef struct _SEP_AUDIT_POLICY {
    union {
        SEP_AUDIT_POLICY_CATEGORIES PolicyElements;
        SEP_AUDIT_POLICY_OVERLAY PolicyOverlay;
        ULONGLONG Overlay;
    };
} SEP_AUDIT_POLICY, *PSEP_AUDIT_POLICY;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                Token Object Body                                    //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//          
// Tokens have three parts:
//
//               Fixed part of body,
//               Variable part of body,
//               Dynamic part (not in body).
//
// The fixed and variable parts are allocated in a single block of memory.
// The dynamic part is a separately allocated block of memory.
//
// The fixed part of the body contains the fixed length fields.  These
// are defined in the TOKEN data type.
//
// The variable part of the body is variable in length and contains
// privileges and user/group SIDs.  This part is variable in length
// between different token objects, but does not change once established
// for an individual token.
//
// The dynamic part is used to house default discretionary ACL information
// and the primary group ID.
//
// Pictorially, a token looks like:
//
//    ==============      +---------------+
//          ^             |               |
//          |             |               |
//          |             |               |
//          |             | DynamicPart   o-----------+
//          |             |- - - - - - - -|           |
//                  +-----o Privileges    |           |
//        Token     |     |- - - - - - - -|           |
//        Body      |  +--o UserAndGroups |           |
//          |       |  |  |- - - - - - - -|           |
//          |       |  +--o RestrictedSids|          \|/
//          |       |  |  |- - - - - - - -|        +---------------------+
//          |       |  |  | PrimaryGroup  o------->| [Primary Group SID] |
//          |       |  |  |- - - - - - - -|        |         o           |
//          |       |  |  | DefaultAcl    o---+    |         o           |
//          |       |  |  |- - - - - - - -|   |    |         o           |
//          |       |  |  |      o        |   |    |- - - - - - - - - - -|
//          |       |  |  |      o        |   +--->| [  Default Acl  ]   |
//          v       |  |  |      o        |        |         o           |
//    ==============|  |  |===============|        |         o           |
//          ^       |  +->| SIDs  Array   |        |         o           |
//          |       |     | [User  SID ]  |        +---------------------+
//          |       |     | [Group SID ]  |
//                  |     | [Group SID ]  |
//        Variable  |     | [Rest. Sid ]  |
//         Part     |     |     o         |
//                  |     |- - - - - - - -|
//          |       +---->| Privileges    |
//          |             | Array         |
//          v             |               |
//    ==============      +---------------+
//
//     WARNING: The positions of fields illustrated in this picture are not
//              intented to reflect their actual or even relative positions
//              within the real data structures.  The exception to this is
//              that THE USER SID IS THE FIRST SID IN THE UserAndGroups
//              ARRAY.
//


//
//             ! ! ! !     IMPORTANT     ! ! ! !
//
//      The access validation routines assume the SIDs are arranged
//      in a particular order within the variable part of the token.
//      Any changes to the order of the SIDs must be coordinated with
//      corresponding changes to the access validation routines.
//
//                   ! ! ! ! ! ! ! ! ! ! !



typedef struct _TOKEN {

    //
    // Fields arranged by size to preserve alignment.
    // Large fields before small fields.
    //


    //
    //  The following fields are either ReadOnly or ReadWrite.
    //  ReadOnly fields may be referenced any time a pointer to the
    //  token is still valid.  ReadWrite fields may only be referenced
    //  when the TokenLock is held.

    //  The dynamic part of the token (pointed to by the DynamicPart field)
    //  is also protected by the token lock.
    //
    //  ReadOnly  fields are marked Ro: in their comment.
    //  ReadWrite fields are marked Wr: in their comment.
    //

    TOKEN_SOURCE TokenSource;                           // Ro: 16-Bytes

    LUID TokenId;                                       // Ro: 8-Bytes
    LUID AuthenticationId;                              // Ro: 8-Bytes
    LUID ParentTokenId;                                 // Ro: 8-Bytes
    LARGE_INTEGER ExpirationTime;                       // Ro: 8-Bytes
    PERESOURCE TokenLock;                               // Ro:

    SEP_AUDIT_POLICY AuditPolicy;                       // RW: 8 bytes

    //
    // Each time the security information in a token is changed, the
    // following ID is changed.  Fields that cause this field to be
    // updated are marked as (Mod) in their comment field.
    //

    LUID ModifiedId;                                    // Wr: 8-Bytes

    ULONG SessionId;                                    // Wr: 4-bytes
    ULONG UserAndGroupCount;                            // Ro: 4-Bytes
    ULONG RestrictedSidCount;                           // Ro: 4-Bytes
    ULONG PrivilegeCount;                               // Ro: 4-Bytes
    ULONG VariableLength;                               // Ro: 4-Bytes
    ULONG DynamicCharged;                               // Ro: 4-Bytes

    ULONG DynamicAvailable;                             // Wr: 4-Bytes (Mod)
    ULONG DefaultOwnerIndex;                            // Wr: 4-Bytes (Mod)
    PSID_AND_ATTRIBUTES UserAndGroups;                  // Wr: 4-Bytes (Mod)
    PSID_AND_ATTRIBUTES RestrictedSids;                 // Ro: 4-Bytes
    PSID PrimaryGroup;                                  // Wr: 4-Bytes (Mod)
    PLUID_AND_ATTRIBUTES Privileges;                    // Wr: 4-Bytes (Mod)
    PULONG DynamicPart;                                 // Wr: 4-Bytes (Mod)
    PACL DefaultDacl;                                   // Wr: 4-Bytes (Mod)

    TOKEN_TYPE TokenType;                               // Ro: 1-Byte
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;    // Ro: 1-Byte

    UCHAR TokenFlags;                                   // Rw: 4-Bytes
    BOOLEAN TokenInUse;                                 // Wr: 1-Byte

    PSECURITY_TOKEN_PROXY_DATA ProxyData;               // Ro: 4-Bytes
    PSECURITY_TOKEN_AUDIT_DATA AuditData;               // Ro: 4-Bytes

    //
    // Pointer to the referenced logon session. Protected by the token
    // lock and only valid when TOKEN_SESSION_NOT_REFERENCED is clear.
    //
    PSEP_LOGON_SESSION_REFERENCES LogonSession;         // Rw: Ptr

    //
    // Originating information for allowing certain impersonation operations
    // later
    //
    LUID OriginatingLogonSession ;                      // Rw: 8 bytes (set by LSA)



#if DBG || TOKEN_LEAK_MONITOR
#define TRACE_SIZE 30

    //
    // This code is for tracking token leaks, in conjunction with !obtrace.
    //

    HANDLE ProcessCid;                          // Cid of creator process
    HANDLE ThreadCid;                           // Cid of creator thread
    UCHAR  ImageFileName[16];                   // Image name of creator process
    ULONG  CreateMethod;                        // Either 0xC (SepCreateToken) 0xD (SepDuplicateToken) or 0xF (SepFilterToken)
    ULONG_PTR CreateTrace[TRACE_SIZE];          // Stack backtrace that created this token (usermode part is first 20 nonzero stack entries)
    LONG Count;                                 // This is the nth token created with watch method
    LONG CaptureCount;                          // This is the # of SeCaptureSubjectContext - SeReleaseSubjectContext

#endif
    
    //
    // This marks the beginning of the variable part of the token.
    // It must follow all other fields in the token.
    //

    ULONG VariablePart;                                 // Wr: 4-Bytes (Mod)

} TOKEN, * PTOKEN;

//
// Where:
//
//    TokenSource - Information provided by the executive component that
//                  requested the logon that the token represents.
//
//
//    TokenId - Is an LUID value.  Each token object has a uniquely
//        assigned LUID.
//
//
//    AuthenticationId - Is the LUID assigned by the domain controller for
//        the logon session.
//
//
//    ExpirationTime - Not yet supported in NT.
//
//
//    ModifiedId - Is an LUID which is changed each time a modification is
//        made to this token which changes the security semantics of the
//        token.  This includes enabling/disabling privileges and groups
//        and changing default ACLs, et cetera.  Any token which is a
//        duplicate of this token will have the same ModifiedId (until
//        one or the other is changed).  This does not cover changes to
//        non-security semantics fields, like TokenInUse.
//
//
//    UserAndGroupCount - Indicates the number of user/group IDs in this token.
//        This value must be at least 1.  A value of 1 indicates a user
//        ID with no supplemental group IDs.  A value of 5 indicates a
//        user ID and 4 supplemental group IDs.
//
//    PrivilegeCount - Indicates how many privileges are included in
//        this token.  May be zero or larger.
//
//    TokenType - Indicates which type of token this token object is.
//
//    ImpersonationLevel - For TokenImpersonation type tokens, this field
//        indicates the impersonation level.  For TokenPrimary type tokens,
//        this field is ignored.
//
//    DynamicCharged - Indicates how much pool quota has been charged
//        for the dynamic portion of this token.
//
//    DynamicAvailable - Indicates how much of the charged quota is still
//        available for use.  This is modified when  pool associated
//        with the dynamic portion of the token is allocated or freed,
//        such as when the default DACL or primary group is replaced.
//
//
//    DefaultOwnerIndex - If non-zero, identifies an ID that has explicitly
//        been established as the default owner for this token.  If it is zero,
//        the standard default (user ID) is used as the default owner.
//
//    UserAndGroups - Points to an array of SID_AND_ATTRIBUTES.  The first
//        element in this array is the token's user ID.  Any additional
//        elements are those of groups.  The number of entries in this
//        array is one greater than
//
//    PrimaryGroup - Points to an SID that is to be used as the primary
//        group of the token.  There are no value restrictions
//        placed upon what can be used as a primary group.  This
//        SID is not one of user or group IDs (although it may have the
//        same value as one of those IDs).
//
//    Privileges - Points to an array of privileges represented as
//        LUID_AND_ATTRIBUTES.  The number of elements in this array
//        is contained in the PrivilegesCount field.
//
//    TokenInUse - Is a boolean that indicates whether a primary token
//        is already in use by a process.  This field value is only
//        valid for primary tokens.
//
//    ProxyData - Optionally points to a Proxy data structure, containing
//        the information to be passed to AVR routines by file systems.
//        This field being non-null identifies the token as a proxy token.
//
//    AuditData - Optionally points to an Audit data structure, containing
//         global auditing data for this subject.
//
//        NOTE:  Access to this field is guarded by the global
//               PROCESS SECURITY FIELDS LOCK.
//    VariablePart - Is the beginning of the variable part of the token.
//


////////////////////////////////////////////////////////////////////////
//
// Internal version of Object Type list
//
////////////////////////////////////////////////////////////////////////

typedef struct _IOBJECT_TYPE_LIST {
    USHORT Level;
    USHORT Flags;
#define OBJECT_SUCCESS_AUDIT 0x1
#define OBJECT_FAILURE_AUDIT 0x2
    GUID ObjectType;
    LONG ParentIndex;
    ULONG Remaining;
    ULONG CurrentGranted;
    ULONG CurrentDenied;
} IOBJECT_TYPE_LIST, *PIOBJECT_TYPE_LIST;

NTSTATUS
SeCaptureObjectTypeList (
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN KPROCESSOR_MODE RequestorMode,
    OUT PIOBJECT_TYPE_LIST *CapturedObjectTypeList
    );

VOID
SeFreeCapturedObjectTypeList(
    IN PVOID ObjectTypeList
    );


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                Token Specific Macros                                //
//                                                                     //
/////////////////////////////////////////////////////////////////////////







#ifndef TOKEN_DIAGNOSTICS_ENABLED

#define SepAcquireTokenReadLock(T)  KeEnterCriticalRegion();          \
                                    ExAcquireResourceSharedLite((T)->TokenLock, TRUE)

#define SepAcquireTokenWriteLock(T) KeEnterCriticalRegion();          \
                                    ExAcquireResourceExclusiveLite((T)->TokenLock, TRUE)

#define SepReleaseTokenReadLock(T)  ExReleaseResourceLite((T)->TokenLock);  \
                                    KeLeaveCriticalRegion()

#else  // TOKEN_DIAGNOSTICS_ENABLED

#define SepAcquireTokenReadLock(T)  if (TokenGlobalFlag & TOKEN_DIAG_TOKEN_LOCKS) { \
                                        DbgPrint("SE (Token):  Acquiring Token READ Lock for access to token 0x%lx\n", (T)); \
                                    }                                 \
                                    KeEnterCriticalRegion();          \
                                    ExAcquireResourceSharedLite((T)->TokenLock, TRUE)

#define SepAcquireTokenWriteLock(T) if (TokenGlobalFlag & TOKEN_DIAG_TOKEN_LOCKS) { \
                                        DbgPrint("SE (Token):  Acquiring Token WRITE Lock for access to token 0x%lx    ********************* EXCLUSIVE *****\n", (T)); \
                                    }                                 \
                                    KeEnterCriticalRegion();          \
                                    ExAcquireResourceExclusiveLite((T)->TokenLock, TRUE)

#define SepReleaseTokenReadLock(T)  if (TokenGlobalFlag & TOKEN_DIAG_TOKEN_LOCKS) { \
                                        DbgPrint("SE (Token):  Releasing Token Lock for access to token 0x%lx\n", (T)); \
                                    }                                 \
                                    ExReleaseResourceLite((T)->TokenLock); \
                                    KeLeaveCriticalRegion()

#endif // TOKEN_DIAGNOSTICS_ENABLED

#define SepReleaseTokenWriteLock(T,M)                                    \
    {                                                                    \
      if ((M)) {                                                         \
          ExAllocateLocallyUniqueId( &((PTOKEN)(T))->ModifiedId  );      \
      }                                                                  \
      SepReleaseTokenReadLock( T );                                      \
    }

//
// Reference individual privilege attribute flags of any privilege array
//
//  P - is a pointer to an array of privileges (PLUID_AND_ATTRIBUTES)
//  I - is the index of the privilege
//  A - is the name of the attribute desired (e.g., Enabled, EnabledByDefault, etc. )
//

#define SepArrayPrivilegeAttributes(P,I) ( (P)[I].Attributes )

//
// Reference individual privilege attribute flags of token privileges
//
//  T - is a pointer to a token
//  I - is the index of the privilege
//  A - is the name of the attribute desired (e.g., Enabled, EnabledByDefault, etc. )
//

#define SepTokenPrivilegeAttributes(T,I) ( (T)->Privileges[I].Attributes )

//
// Reference individual group attribute flags of any group array
//
//  G - is a pointer to the array of groups  (SID_AND_ATTRIBUTES[])
//  I - is the index of the group
//

#define SepArrayGroupAttributes(G,I)   ( (G)[I].Attributes )


//
// Reference individual group attribute flags of token groups
//
//  T - is a pointer to a token
//  I - is the index of the group
//

#define SepTokenGroupAttributes(T,I) ( (T)->UserAndGroups[I].Attributes )




////////////////////////////////////////////////////////////////////////
//                                                                    //
//           Private Routine Declarations                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
SepAdjustGroups(
    IN PTOKEN Token,
    IN BOOLEAN MakeChanges,
    IN BOOLEAN ResetToDefault,
    IN ULONG GroupCount OPTIONAL,
    IN PSID_AND_ATTRIBUTES NewState OPTIONAL,
    OUT PTOKEN_GROUPS PreviousState OPTIONAL,
    OUT PSID SidBuffer OPTIONAL,
    OUT PULONG ReturnLength,
    OUT PULONG ChangeCount,
    OUT PBOOLEAN ChangesMade
    );

NTSTATUS
SepAdjustPrivileges(
    IN PTOKEN Token,
    IN BOOLEAN MakeChanges,
    IN BOOLEAN DisableAllPrivileges,
    IN ULONG PrivilegeCount OPTIONAL,
    IN PLUID_AND_ATTRIBUTES NewState OPTIONAL,
    OUT PTOKEN_PRIVILEGES PreviousState OPTIONAL,
    OUT PULONG ReturnLength,
    OUT PULONG ChangeCount,
    OUT PBOOLEAN ChangesMade
    );

VOID
SepAppendDefaultDacl(
    IN PTOKEN Token,
    IN PACL PAcl
    );

VOID
SepAppendPrimaryGroup(
    IN PTOKEN Token,
    IN PSID PSid
    );

NTSTATUS
SepDuplicateToken(
    IN PTOKEN ExistingToken,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN EffectiveOnly,
    IN TOKEN_TYPE TokenType,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel OPTIONAL,
    IN KPROCESSOR_MODE RequestorMode,
    OUT PTOKEN *DuplicateToken
    );

NTSTATUS
SepFilterToken(
    IN PTOKEN ExistingToken,
    IN KPROCESSOR_MODE RequestorMode,
    IN ULONG Flags,
    IN ULONG GroupCount,
    IN PSID_AND_ATTRIBUTES GroupsToDisable OPTIONAL,
    IN ULONG PrivilegeCount,
    IN PLUID_AND_ATTRIBUTES PrivilegesToDelete OPTIONAL,
    IN ULONG SidCount,
    IN PSID_AND_ATTRIBUTES RestrictedSids OPTIONAL,
    IN ULONG SidLength,
    OUT PTOKEN * FilteredToken
    );

BOOLEAN
SepSidInSidAndAttributes (
    IN PSID_AND_ATTRIBUTES SidAndAttributes,
    IN ULONG SidCount,
    IN PSID PrincipalSelfSid,
    IN PSID Sid
    );

VOID
SepRemoveDisabledGroupsAndPrivileges(
    IN PTOKEN Token,
    IN ULONG Flags,
    IN ULONG GroupCount,
    IN PSID_AND_ATTRIBUTES GroupsToDisable,
    IN ULONG PrivilegeCount,
    IN PLUID_AND_ATTRIBUTES PrivilegesToDelete
    );


VOID
SepFreeDefaultDacl(
    IN PTOKEN Token
    );

VOID
SepFreePrimaryGroup(
    IN PTOKEN Token
    );

NTSTATUS
SepExpandDynamic(
    IN PTOKEN Token,
    IN ULONG NewLength
    );

BOOLEAN
SepIdAssignableAsOwner(
    IN PTOKEN Token,
    IN ULONG Index
    );

VOID
SepMakeTokenEffectiveOnly(
    IN PTOKEN Token
    );

BOOLEAN
SepTokenInitialization( VOID );


VOID
SepTokenDeleteMethod (
    IN  PVOID   Token
    );

//
// These are here because if they are placed in sep.h, we don't
// have the PTOKEN datatype available.
//

BOOLEAN
SepPrivilegeCheck(
    IN PTOKEN Token,
    IN OUT PLUID_AND_ATTRIBUTES RequiredPrivileges,
    IN ULONG RequiredPrivilegeCount,
    IN ULONG PrivilegeSetControl,
    IN KPROCESSOR_MODE PreviousMode
    );

BOOLEAN
SepAccessCheck (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN PTOKEN PrimaryToken,
    IN PTOKEN ClientToken OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN PIOBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN ACCESS_MASK PreviouslyGrantedAccess,
    IN KPROCESSOR_MODE PreviousMode,
    OUT PACCESS_MASK GrantedAccess,
    OUT PPRIVILEGE_SET *Privileges OPTIONAL,
    OUT PNTSTATUS AccessStatus,
    IN BOOLEAN ReturnResultList,
    OUT PBOOLEAN ReturnSomeAccessGranted,
    OUT PBOOLEAN ReturnSomeAccessDenied
    );

BOOLEAN
SepObjectInTypeList (
    IN GUID *ObjectType,
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    OUT PULONG ReturnedIndex
    );

VOID
SepModifyTokenPolicyCounter(
    PSEP_AUDIT_POLICY TokenPolicy,
    BOOLEAN bIncrement
    );

NTSTATUS
FORCEINLINE
SepDuplicateLogonSessionReference(
    IN PTOKEN NewToken,
    IN PTOKEN ExistingToken
    )
{
    PSEP_LOGON_SESSION_REFERENCES LogonSession;
    LONG NewRef;
    NTSTATUS Status;

    //
    // Obtain the logon session reference. If the existing token
    // has a reference then use that to obtain a new one. Otherwise
    // Look up the session the slow way.
    //
    if ((ExistingToken->TokenFlags & TOKEN_SESSION_NOT_REFERENCED) == 0) {
        LogonSession = ExistingToken->LogonSession;
        NewToken->LogonSession = LogonSession;
        NewRef = InterlockedIncrement (&LogonSession->ReferenceCount);
        ASSERT (NewRef > 1);
        return STATUS_SUCCESS;
    } else {
        Status = SepReferenceLogonSession (&ExistingToken->AuthenticationId,
                                           &NewToken->LogonSession);
        if (!NT_SUCCESS (Status)) {
            NewToken->TokenFlags |= TOKEN_SESSION_NOT_REFERENCED;
            NewToken->LogonSession = NULL;
        }
        return Status;
    }
}

VOID
FORCEINLINE
SepDeReferenceLogonSessionDirect(
    IN PSEP_LOGON_SESSION_REFERENCES LogonSession
    )
{
    LONG OldValue;
    LUID LogonId;

    while (1) {
        OldValue = LogonSession->ReferenceCount;
        ASSERT (OldValue > 0);
        if (OldValue == 1) {
            LogonId = LogonSession->LogonId;
            SepDeReferenceLogonSession (&LogonId);
            break;
        }

        if (InterlockedCompareExchange (&LogonSession->ReferenceCount, OldValue-1, OldValue) == OldValue) {
            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////
//                                                                    //
//           Global Variables                                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////


extern const GENERIC_MAPPING  SepTokenMapping;
extern POBJECT_TYPE     SeTokenObjectType;

//extern ERESOURCE        SepTokenLock;


#ifdef    TOKEN_DIAGNOSTICS_ENABLED
extern ULONG            TokenGlobalFlag;
#endif // TOKEN_DIAGNOSTICS_ENABLED

#endif // _TOKENP_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\subject.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Subject.c

Abstract:

    This Module implements services related to subject security context.
    These services are part of the services provided by the Reference Monitor
    component.

    FOR PERFORMANCE SAKE, THIS MODULE IS AWARE OF INTERNAL TOKEN OBJECT
    FORMATS.

--*/

#include "pch.h"

#pragma hdrstop


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SeCaptureSubjectContext)
#pragma alloc_text(PAGE,SeCaptureSubjectContextEx)
#pragma alloc_text(PAGE,SeLockSubjectContext)
#pragma alloc_text(PAGE,SeUnlockSubjectContext)
#pragma alloc_text(PAGE,SeReleaseSubjectContext)
#pragma alloc_text(PAGE,SepGetDefaultsSubjectContext)
#pragma alloc_text(PAGE,SepIdAssignableAsGroup)
#pragma alloc_text(PAGE,SepValidOwnerSubjectContext)
//#pragma alloc_text(PAGE,SeQueryAuthenticationIdSubjectContext)
#endif


VOID
SeCaptureSubjectContext (
    __out PSECURITY_SUBJECT_CONTEXT SubjectContext
    )

/*++

Routine Description:

    This routine takes a snapshot of the calling thread's security
    context (locking tokens as necessary to do so).  This function
    is intended to support the object manager and other components
    that utilize the reference monitor's access validation,
    privilege test, and audit generation services.

    A subject's security context should be captured before initiating
    access validation and should be released after audit messages
    are generated.  This is necessary to provide a consistent security
    context to all those services.

    After calling access validation, privilege test, and audit generation
    services, the captured context should be released as soon as possible
    using the SeReleaseSubjectContext() service.

Arguments:

    SubjectContext - Points to a SECURITY_SUBJECT_CONTEXT data structure
        to be filled in with a snapshot of the calling thread's security
        profile.

Return Value:

    none.

--*/

{
    SeCaptureSubjectContextEx (PsGetCurrentThread (),
                               PsGetCurrentProcess (),
                               SubjectContext);
}


VOID
SeCaptureSubjectContextEx (
    __in PETHREAD Thread,
    __in PEPROCESS Process,
    __out PSECURITY_SUBJECT_CONTEXT SubjectContext
    )

/*++

Routine Description:

    This routine takes a snapshot of the calling thread's security
    context (locking tokens as necessary to do so).  This function
    is intended to support the object manager and other components
    that utilize the reference monitor's access validation,
    privilege test, and audit generation services.

    A subject's security context should be captured before initiating
    access validation and should be released after audit messages
    are generated.  This is necessary to provide a consistent security
    context to all those services.

    After calling access validation, privilege test, and audit generation
    services, the captured context should be released as soon as possible
    using the SeReleaseSubjectContext() service.

Arguments:

    Thread - Thread to capture the thread token from. If NULL we don't capture
             an impersonation token.

    Process - Process to capture primary token from.

    SubjectContext - Points to a SECURITY_SUBJECT_CONTEXT data structure
        to be filled in with a snapshot of the calling thread's security
        profile.

Return Value:

    none.

--*/

{
    BOOLEAN IgnoreCopyOnOpen;
    BOOLEAN IgnoreEffectiveOnly;

    PAGED_CODE();

    SubjectContext->ProcessAuditId = PsProcessAuditId( Process );

    //
    // Get pointers to primary and impersonation tokens
    //

    if (Thread == NULL) {
        SubjectContext->ClientToken = NULL;
    } else {
        SubjectContext->ClientToken = PsReferenceImpersonationToken(
                                          Thread,
                                          &IgnoreCopyOnOpen,
                                          &IgnoreEffectiveOnly,
                                          &(SubjectContext->ImpersonationLevel)
                                          );
    }

    SubjectContext->PrimaryToken = PsReferencePrimaryToken(Process);

#if DBG || TOKEN_LEAK_MONITOR

    if (SubjectContext->PrimaryToken) {
        InterlockedIncrement(&((PTOKEN)(SubjectContext->PrimaryToken))->CaptureCount);
        if (SubjectContext->PrimaryToken == SepTokenLeakToken)
        {
            DbgBreakPoint();
        }
    }

    if (SubjectContext->ClientToken) {
        InterlockedIncrement(&((PTOKEN)(SubjectContext->ClientToken))->CaptureCount);
        if (SubjectContext->ClientToken == SepTokenLeakToken)
        {
            DbgBreakPoint();
        }
    }

#endif

    return;

}



VOID
SeLockSubjectContext(
    __in PSECURITY_SUBJECT_CONTEXT SubjectContext
    )

/*++

Routine Description:

    Acquires READ LOCKS on the primary and impersonation tokens
    in the passed SubjectContext.

    This call must be undone by a call to SeUnlockSubjectContext().

    No one outside of the SE component should need to acquire a
    write lock to a token.  Therefore there is no public interface
    to do this.

Arguments:

    SubjectContext - Points to a SECURITY_SUBJECT_CONTEXT data structure
        which points to a primary token and an optional impersonation token.

Return Value:

    None

--*/

{
    PAGED_CODE();

    SepAcquireTokenReadLock((PTOKEN)(SubjectContext->PrimaryToken));

    if (ARGUMENT_PRESENT(SubjectContext->ClientToken)) {

        SepAcquireTokenReadLock((PTOKEN)(SubjectContext->ClientToken));
    }

    return;
}



VOID
SeUnlockSubjectContext(
    __in PSECURITY_SUBJECT_CONTEXT SubjectContext
    )

/*++

Routine Description:

    Releases the read locks on the token(s) in the passed SubjectContext.

Arguments:

    SubjectContext - Points to a SECURITY_SUBJECT_CONTEXT data structure
        which points to a primary token and an optional impersonation token.

Return Value:

    None

--*/

{
    PAGED_CODE();

    SepReleaseTokenReadLock((PTOKEN)(SubjectContext->PrimaryToken));

    if (ARGUMENT_PRESENT(SubjectContext->ClientToken)) {

        SepReleaseTokenReadLock((PTOKEN)(SubjectContext->ClientToken));
    }


}



VOID
SeReleaseSubjectContext (
    __inout PSECURITY_SUBJECT_CONTEXT SubjectContext
    )

/*++


Routine Description:

    This routine releases a subject security context previously captured by
    SeCaptureSubjectContext().

Arguments:

    SubjectContext - Points to a SECURITY_SUBJECT_CONTEXT data structure
        containing a subject's previously captured security context.

Return Value:

    none.

--*/

{
    PAGED_CODE();

#if DBG || TOKEN_LEAK_MONITOR

    if (SubjectContext->PrimaryToken) {
        InterlockedDecrement(&((PTOKEN)(SubjectContext->PrimaryToken))->CaptureCount);
        if (SubjectContext->PrimaryToken == SepTokenLeakToken)
        {
            DbgBreakPoint();
        }
    }

    if (SubjectContext->ClientToken) {
        InterlockedDecrement(&((PTOKEN)(SubjectContext->ClientToken))->CaptureCount);
        if (SubjectContext->ClientToken == SepTokenLeakToken)
        {
            DbgBreakPoint();
        }
    }

#endif
    
    PsDereferencePrimaryTokenEx( PsGetCurrentProcess(), SubjectContext->PrimaryToken );

    SubjectContext->PrimaryToken = NULL;

    PsDereferenceImpersonationToken( SubjectContext->ClientToken );
    
    SubjectContext->ClientToken = NULL;

    return;

}

VOID
SepGetDefaultsSubjectContext(
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext,
    OUT PSID *Owner,
    OUT PSID *Group,
    OUT PSID *ServerOwner,
    OUT PSID *ServerGroup,
    OUT PACL *Dacl
    )
/*++

Routine Description:

    This routine retrieves pointers to the default owner, primary group,
    and, if present, discretionary ACL of the provided subject security
    context.

Arguments:

    SubjectContext - Points to the subject security context whose default
        values are to be retrieved.

    Owner - Receives a pointer to the subject's default owner SID.  This
        value will always be returned as a non-zero pointer.  That is,
        a subject's security context must contain a owner SID.

    Group - Receives a pointer to the subject's default primary group SID.
        This value will always be returned as a non-zero pointer.  That is,
        a subject's security context must contain a primary group.

    Dacl - Receives a pointer to the subject's default discretionary ACL,
        if one is define for the subject.  Note that a subject security context
        does not have to include a default discretionary ACL.  In this case,
        this value will be returned as NULL.




Return Value:

    none.

--*/

{
    PTOKEN EffectiveToken;
    PTOKEN PrimaryToken;

    PAGED_CODE();

    if (ARGUMENT_PRESENT(SubjectContext->ClientToken)) {
        EffectiveToken = (PTOKEN)SubjectContext->ClientToken;
    } else {
        EffectiveToken = (PTOKEN)SubjectContext->PrimaryToken;
    }

    (*Owner) = EffectiveToken->UserAndGroups[EffectiveToken->DefaultOwnerIndex].Sid;

    (*Group) = EffectiveToken->PrimaryGroup;

    (*Dacl)  = EffectiveToken->DefaultDacl;

    PrimaryToken = (PTOKEN)SubjectContext->PrimaryToken;

    *ServerOwner = PrimaryToken->UserAndGroups[PrimaryToken->DefaultOwnerIndex].Sid;

    *ServerGroup = PrimaryToken->PrimaryGroup;

    return;
}


BOOLEAN
SepIdAssignableAsGroup(
    IN PACCESS_TOKEN AToken,
    IN PSID Group
    )
/*++

Routine Description:

    This routine checks to see whether the provided SID is one that
    may be assigned to be the default primary group in a token.

    The current criteria is that the passed SID be a group in the
    token, with no other restrictions.

Arguments:

    Token - Points to the token to be examined.

    Group - Points to the SID to be checked.

Return Value:

    TRUE - SID passed by be assigned as the default primary group in a token.

    FALSE - Passed SID may not be so assigned.

--*/

{
    ULONG Index;
    BOOLEAN Found = FALSE;
    PTOKEN Token;

    PAGED_CODE();

    Token = (PTOKEN)AToken;

    //
    // Let's make it invalid to assign a NULL primary group,
    // but we may need to revisit this.
    //

    if (Group == NULL) {
        return( FALSE );
    }
    Index = 0;

    SepAcquireTokenReadLock( Token );

    //
    //  Walk through the list of user and group IDs looking
    //  for a match to the specified SID.
    //

    while (Index < Token->UserAndGroupCount) {

        Found = RtlEqualSid(
                    Group,
                    Token->UserAndGroups[Index].Sid
                    );

        if ( Found ) {
            break;
        }

        Index += 1;
    }

    SepReleaseTokenReadLock( Token );

    return Found;
}


BOOLEAN
SepValidOwnerSubjectContext(
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext,
    IN PSID Owner,
    IN BOOLEAN ServerObject
    )
/*++

Routine Description:

    This routine checks to see whether the provided SID is one the subject
    is authorized to assign as the owner of objects.  It will also check to
    see if the caller has SeRestorePrivilege, if so, the request is granted.

Arguments:

    SubjectContext - Points to the subject's security context.

    Owner - Points to the SID to be checked.



Return Value:

    none.

--*/

{

    ULONG Index;
    BOOLEAN Found;
    PTOKEN EffectiveToken;
    BOOLEAN Rc = FALSE;

    PAGED_CODE();

    //
    // It is invalid to assign a NULL owner, regardless of
    // whether you have SeRestorePrivilege or not.
    //

    if (Owner == NULL) {
        return( FALSE );
    }

    //
    // Allowable owners come from the primary if it's a server object.
    //

    if (!ServerObject && ARGUMENT_PRESENT(SubjectContext->ClientToken)) {
        EffectiveToken = (PTOKEN)SubjectContext->ClientToken;
    } else {
        EffectiveToken = (PTOKEN)SubjectContext->PrimaryToken;
    }


    //
    // If we're impersonating, make sure we're at TokenImpersonation
    // or above.  This prevents someone from setting the owner of an
    // object when impersonating at less Identify or Anonymous.
    //

    if (EffectiveToken->TokenType == TokenImpersonation) {

        if (EffectiveToken->ImpersonationLevel < SecurityImpersonation) {

            return( FALSE );

        }
    }

    Index = 0;

    SepAcquireTokenReadLock( EffectiveToken );

    //
    //  Walk through the list of user and group IDs looking
    //  for a match to the specified SID.  If one is found,
    //  make sure it may be assigned as an owner.
    //
    //  This code is similar to that performed to set the default
    //  owner of a token (NtSetInformationToken).
    //

    while (Index < EffectiveToken->UserAndGroupCount) {


        Found = RtlEqualSid(
                    Owner,
                    EffectiveToken->UserAndGroups[Index].Sid
                    );

        if ( Found ) {

            //
            // We may return success if the Sid is one that may be assigned
            // as an owner, or if the caller has SeRestorePrivilege
            //

            if ( SepIdAssignableAsOwner(EffectiveToken,Index) ) {

                SepReleaseTokenReadLock( EffectiveToken );
                Rc = TRUE;
                goto exit;

            } else {

                //
                // Rc is already set to FALSE, just exit.
                //

                SepReleaseTokenReadLock( EffectiveToken );
                goto exit;

            } //endif assignable


        }  //endif Found


        Index += 1;

    } //endwhile


    SepReleaseTokenReadLock( EffectiveToken );

exit:

    //
    // If we are going to fail this call, check for Restore privilege,
    // and succeed if he has it.
    //

    //
    // We should really have gotten PreviousMode from the caller, but we
    // didn't, so hard wire it to be user-mode here.
    //

    if ( Rc == FALSE ) {
        Rc = SeSinglePrivilegeCheck( SeRestorePrivilege, UserMode );
    }

    return Rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\tokendup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    tokendup.c

Abstract:

   This module implements the token duplication service.

--*/

#include "pch.h"

#pragma hdrstop


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtDuplicateToken)
#pragma alloc_text(PAGE,SepDuplicateToken)
#pragma alloc_text(PAGE,SepMakeTokenEffectiveOnly)
#pragma alloc_text(PAGE,SepSidInSidAndAttributes)
#pragma alloc_text(PAGE,SepRemoveDisabledGroupsAndPrivileges)
#pragma alloc_text(PAGE,SeCopyClientToken)
#pragma alloc_text(PAGE,NtFilterToken)
#pragma alloc_text(PAGE,SeFilterToken)
#pragma alloc_text(PAGE,SeFastFilterToken)
#pragma alloc_text(PAGE,SepFilterToken)
#endif


NTSTATUS
NtDuplicateToken(
    __in HANDLE ExistingTokenHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in BOOLEAN EffectiveOnly,
    __in TOKEN_TYPE TokenType,
    __out PHANDLE NewTokenHandle
    )

/*++


Routine Description:

    Create a new token that is a duplicate of an existing token.

Arguments:

    ExistingTokenHandle - Is a handle to a token already open for
        TOKEN_DUPLICATE access.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the newly created token.  If specified as zero,
        the granted access mask of the existing token handle
        is used as the desired access mask for the new token.

    ObjectAttributes - Points to the standard object attributes data
        structure.  Refer to the NT Object Management
        Specification for a description of this data structure.

        If the new token type is TokenImpersonation, then this
        parameter may be used to specify the impersonation level
        of the new token.  If no value is provided, and the source
        token is an impersonation token, then the impersonation level
        of the source will become that of the target as well.  If the
        source token is a primary token, then an impersonation level
        must be explicitly provided.

        If the token being duplicated is an impersonation token, and
        an impersonation level is explicitly provided for the target,
        then the value provided must not be greater than that of the
        source token. For example, an Identification level token can
        not be duplicated to produce a Delegation level token.

    EffectiveOnly - Is a boolean flag indicating whether the entire
        source token should be duplicated into the target token or
        just the effective (currently enabled) part of the token.
        This provides a means for a caller of a protected subsystem
        to limit which privileges and optional groups are made
        available to the protected subsystem.  A value of TRUE
        indicates only the currently enabled parts of the source
        token are to be duplicated.  Otherwise, the entire source
        token is duplicated.

    TokenType - Indicates which type of object the new object is to
        be created as (primary or impersonation).  If you are duplicating
        an Impersonation token to produce a Primary token, then
        the Impersonation token must have an impersonation level of
        either DELEGATE or IMPERSONATE.


    NewTokenHandle - Receives the handle of the newly created token.

Return Value:

    STATUS_SUCCESS - Indicates the operation was successful.

    STATUS_INVALID_PARAMETER - Indicates one or more of the parameter values
        was invalid.  This value is returned if the target token is not
        an impersonation token.

    STATUS_BAD_IMPERSONATION_LEVEL - Indicates the impersonation level
        requested for the duplicate token is not compatible with the
        level of the source token.  The duplicate token may not be assigned
        a level greater than that of the source token.

--*/
{

    PTOKEN Token;
    PTOKEN NewToken;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    SECURITY_ADVANCED_QUALITY_OF_SERVICE SecurityQos;
    BOOLEAN SecurityQosPresent = FALSE;
    HANDLE LocalHandle = NULL;

    OBJECT_HANDLE_INFORMATION HandleInformation;
    ACCESS_MASK EffectiveDesiredAccess;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    //
    //  Probe parameters
    //

    if (PreviousMode != KernelMode) {

        try {

            //
            // Make sure the TokenType is valid
            //

            if ( (TokenType < TokenPrimary) || (TokenType > TokenImpersonation) ) {
                return(STATUS_INVALID_PARAMETER);
            }

            //
            //  Make sure we can write the handle
            //

            ProbeForWriteHandle(NewTokenHandle);


        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }  // end_try

    } //end_if



    Status = SeCaptureSecurityQos(
                 ObjectAttributes,
                 PreviousMode,
                 &SecurityQosPresent,
                 &SecurityQos
                 );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }


    //
    //  Check the handle's access to the existing token and get
    //  a pointer to that token.  Pick up the default desired
    //  access mask from the handle while we're at it.
    //

    Status = ObReferenceObjectByHandle(
                 ExistingTokenHandle,    // Handle
                 TOKEN_DUPLICATE,        // DesiredAccess
                 SeTokenObjectType,     // ObjectType
                 PreviousMode,           // AccessMode
                 (PVOID *)&Token,        // Object
                 &HandleInformation      // GrantedAccess
                 );

    if ( !NT_SUCCESS(Status) ) {

        if (SecurityQosPresent) {
            SeFreeCapturedSecurityQos( &SecurityQos );
        }
        return Status;
    }

    //
    // Check to see if an alternate desired access mask was provided.
    //

    if (ARGUMENT_PRESENT(DesiredAccess)) {

        EffectiveDesiredAccess = DesiredAccess;

    } else {

        EffectiveDesiredAccess = HandleInformation.GrantedAccess;
    }


    //
    //  If no impersonation level was specified, pick one up from
    //  the source token.
    //

    if ( !SecurityQosPresent ) {

        SecurityQos.ImpersonationLevel = Token->ImpersonationLevel;

    }

    //
    // If an impersonation token is duplicated into an impersonation token, we 
    // need to do checks on the impersonation level.
    // The impersonation level requested for the new token is ignored if the 
    // new token type is TokenPrimary.
    //

    if ( (Token->TokenType == TokenImpersonation) &&
         (TokenType == TokenImpersonation) 
       ) {

        //
        // Make sure a legitimate transformation is being requested:
        //
        //    (1) The impersonation level of a target duplicate must not
        //        exceed that of the source token.
        //
        //

        ASSERT( SecurityDelegation     > SecurityImpersonation );
        ASSERT( SecurityImpersonation  > SecurityIdentification );
        ASSERT( SecurityIdentification > SecurityAnonymous );

        if ( (SecurityQos.ImpersonationLevel > Token->ImpersonationLevel) ) {

            ObDereferenceObject( (PVOID)Token );
            if (SecurityQosPresent) {
                SeFreeCapturedSecurityQos( &SecurityQos );
            }
            return STATUS_BAD_IMPERSONATION_LEVEL;
        }

    }

    //
    // If we are producing a Primary token from an impersonation
    // token, then specify an impersonation level of at least
    // Impersonate.
    //

    if ( (Token->TokenType == TokenImpersonation) &&
         (TokenType == TokenPrimary)              &&
         (Token->ImpersonationLevel <  SecurityImpersonation)
       ) {
        ObDereferenceObject( (PVOID)Token );
        if (SecurityQosPresent) {
            SeFreeCapturedSecurityQos( &SecurityQos );
        }
        return STATUS_BAD_IMPERSONATION_LEVEL;
    }

    //
    //  Duplicate the existing token
    //

    NewToken = NULL;
    Status = SepDuplicateToken(
                 Token,
                 ObjectAttributes,
                 EffectiveOnly,
                 TokenType,
                 SecurityQos.ImpersonationLevel,
                 PreviousMode,
                 &NewToken
                 );


    if (NT_SUCCESS(Status)) {

        //
        //  Insert the new token
        //

        Status = ObInsertObject( NewToken,
                                 NULL,
                                 EffectiveDesiredAccess,
                                 0,
                                 (PVOID *)NULL,
                                 &LocalHandle
                                 );
    }

    //
    //  We no longer need our reference to the source token
    //

    ObDereferenceObject( (PVOID)Token );

    if (SecurityQosPresent) {
        SeFreeCapturedSecurityQos( &SecurityQos );
    }

    //
    //  Return the new handle
    //

    if (NT_SUCCESS(Status)) {
        try {
            *NewTokenHandle = LocalHandle;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

   return Status;
}


NTSTATUS
SepDuplicateToken(
    __in PTOKEN ExistingToken,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in BOOLEAN EffectiveOnly,
    __in TOKEN_TYPE TokenType,
    __in SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    __in KPROCESSOR_MODE RequestorMode,
    __deref_out PTOKEN *DuplicateToken
    )


/*++


Routine Description:

    This routine does the bulk of the work to actually duplicate
    a token.  This routine assumes all access validation and argument
    probing (except the ObjectAttributes) has been performed.

    THE CALLER IS RESPONSIBLE FOR CHECKING SUBJECT RIGHTS TO CREATE THE
    TYPE OF TOKEN BEING CREATED.

    This routine acquires a read lock on the token being duplicated.

Arguments:

    ExistingToken - Points to the token to be duplicated.

    ObjectAttributes - Points to the standard object attributes data
        structure.  Refer to the NT Object Management
        Specification for a description of this data structure.

        The security Quality Of Service of the object attributes are ignored.
        This information must be specified using parameters to this
        routine.

    EffectiveOnly - Is a boolean flag indicating whether the entire
        source token should be duplicated into the target token or
        just the effective (currently enabled) part of the token.
        This provides a means for a caller of a protected subsystem
        to limit which privileges and optional groups are made
        available to the protected subsystem.  A value of TRUE
        indicates only the currently enabled parts of the source
        token are to be duplicated.  Otherwise, the entire source
        token is duplicated.

    TokenType - Indicates the type of token to make the duplicate token.

    ImpersonationLevel - This value specifies the impersonation level
        to assign to the duplicate token.  If the TokenType of the
        duplicate is not TokenImpersonation then this parameter is
        ignored.  Otherwise, it is must be provided.

    RequestorMode - Mode of client requesting the token be duplicated.

    DuplicateToken - Receives a pointer to the duplicate token.
        The token has not yet been inserted into any object table.
        No exceptions are expected when trying to set this OUT value.

Return Value:

    STATUS_SUCCESS - The service successfully completed the requested
        operation.


--*/
{
    NTSTATUS Status;

    PTOKEN NewToken;
    PULONG DynamicPart;
    ULONG PagedPoolSize;
    ULONG NonPagedPoolSize;
    ULONG TokenBodyLength;
    ULONG_PTR FieldOffset;
    ULONG DynamicSize;
    ULONG Index;

    PSECURITY_TOKEN_PROXY_DATA NewProxyData = NULL;
    PSECURITY_TOKEN_AUDIT_DATA NewAuditData = NULL;
    PSID_AND_ATTRIBUTES UserAndGroups;
    PSID_AND_ATTRIBUTES RestrictedSids;

    PERESOURCE TokenLock;

#if DBG || TOKEN_LEAK_MONITOR
    ULONG Frames;
#endif

    PAGED_CODE();

    ASSERT( sizeof(SECURITY_IMPERSONATION_LEVEL) <= sizeof(ULONG) );


    if ( TokenType == TokenImpersonation ) {

        ASSERT( SecurityDelegation     > SecurityImpersonation );
        ASSERT( SecurityImpersonation  > SecurityIdentification );
        ASSERT( SecurityIdentification > SecurityAnonymous );

        if ( (ImpersonationLevel > SecurityDelegation)  ||
             (ImpersonationLevel < SecurityAnonymous) ) {

            return STATUS_BAD_IMPERSONATION_LEVEL;
        }
    }

    if (ARGUMENT_PRESENT(ExistingToken->ProxyData)) {

        Status = SepCopyProxyData(
                    &NewProxyData,
                    ExistingToken->ProxyData
                    );

        if (!NT_SUCCESS(Status)) {
            return( Status );
        }

    } else {

        NewProxyData = NULL;
    }

    if (ARGUMENT_PRESENT( ExistingToken->AuditData )) {

        NewAuditData = ExAllocatePool( PagedPool, sizeof( SECURITY_TOKEN_AUDIT_DATA ));

        if (NewAuditData == NULL) {

            SepFreeProxyData( NewProxyData );

            return( STATUS_INSUFFICIENT_RESOURCES );

        } else {

            *NewAuditData = *(ExistingToken->AuditData);
        }

    } else {

        NewAuditData = NULL;

    }

    TokenLock = (PERESOURCE)ExAllocatePoolWithTag( NonPagedPool, sizeof( ERESOURCE ), 'dTeS' );

    if (TokenLock == NULL) {

        if (NewAuditData != NULL) {
            ExFreePool( NewAuditData );
        }

        SepFreeProxyData( NewProxyData );

        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  Create a new object
    //

    TokenBodyLength = FIELD_OFFSET(TOKEN, VariablePart) +
                      ExistingToken->VariableLength;

    NonPagedPoolSize = TokenBodyLength;
    PagedPoolSize    = ExistingToken->DynamicCharged;

    Status = ObCreateObject(
                 RequestorMode,      // ProbeMode
                 SeTokenObjectType, // ObjectType
                 ObjectAttributes,   // ObjectAttributes
                 RequestorMode,      // OwnershipMode
                 NULL,               // ParseContext
                 TokenBodyLength,    // ObjectBodySize
                 PagedPoolSize,      // PagedPoolCharge
                 NonPagedPoolSize,   // NonPagedPoolCharge
                 (PVOID *)&NewToken  // Return pointer to object
                 );

    if (!NT_SUCCESS(Status)) {
        SepFreeProxyData( NewProxyData );
        ExFreePool( TokenLock );

        if (NewAuditData != NULL) {
            ExFreePool( NewAuditData );
        }

        return Status;
    }

    //
    // The following fields differ in the new token and can be filled out without the lock.
    //

    ExAllocateLocallyUniqueId( &(NewToken->TokenId) );
    NewToken->TokenInUse = FALSE;
    NewToken->TokenType = TokenType;
    NewToken->ImpersonationLevel = ImpersonationLevel;
    NewToken->TokenLock = TokenLock;

    ExInitializeResourceLite( NewToken->TokenLock );

    NewToken->AuthenticationId = ExistingToken->AuthenticationId;
    NewToken->TokenSource = ExistingToken->TokenSource;
    NewToken->DynamicAvailable = 0;
    NewToken->ProxyData = NewProxyData;
    NewToken->AuditData = NewAuditData;
    NewToken->ParentTokenId = ExistingToken->ParentTokenId;
    NewToken->ExpirationTime = ExistingToken->ExpirationTime;
    NewToken->OriginatingLogonSession  = ExistingToken->OriginatingLogonSession ;

    //
    //  acquire exclusive access to the source token
    //

    SepAcquireTokenReadLock( ExistingToken );


    //
    // Main Body initialization
    //

    //
    // The following fields are unchanged from the source token.
    // Although some may change if EffectiveOnly has been specified.
    //

    NewToken->ModifiedId = ExistingToken->ModifiedId;
    NewToken->DynamicCharged = ExistingToken->DynamicCharged;
    NewToken->DefaultOwnerIndex = ExistingToken->DefaultOwnerIndex;
    NewToken->UserAndGroupCount = ExistingToken->UserAndGroupCount;
    NewToken->RestrictedSidCount = ExistingToken->RestrictedSidCount;
    NewToken->PrivilegeCount = ExistingToken->PrivilegeCount;
    NewToken->VariableLength = ExistingToken->VariableLength;
    NewToken->TokenFlags = ExistingToken->TokenFlags & ~TOKEN_SESSION_NOT_REFERENCED;
    NewToken->SessionId = ExistingToken->SessionId;
    NewToken->AuditPolicy = ExistingToken->AuditPolicy;


    //
    // Increment the reference count for this logon session
    // This can not fail, since there is already a token in this logon
    // session.
    //

    Status = SepDuplicateLogonSessionReference (NewToken, ExistingToken);

    ASSERT( NT_SUCCESS(Status) );

    if (!NT_SUCCESS (Status)) {
        SepReleaseTokenReadLock( ExistingToken );

        NewToken->DynamicPart = NULL;
        ObDereferenceObject (NewToken);
        return Status;
    }


#if DBG || TOKEN_LEAK_MONITOR

    NewToken->ProcessCid          = PsGetCurrentThread()->Cid.UniqueProcess;
    NewToken->ThreadCid           = PsGetCurrentThread()->Cid.UniqueThread;
    NewToken->CreateMethod        = 0xD; // Duplicate
    NewToken->Count               = 0;
    NewToken->CaptureCount        = 0;

    RtlCopyMemory(
        NewToken->ImageFileName,
        PsGetCurrentProcess()->ImageFileName, 
        min(sizeof(NewToken->ImageFileName), sizeof(PsGetCurrentProcess()->ImageFileName))
        );

    Frames = RtlWalkFrameChain(
                 (PVOID)NewToken->CreateTrace,
                 TRACE_SIZE,
                 0
                 );

    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
        
        RtlWalkFrameChain(
            (PVOID)&NewToken->CreateTrace[Frames],
            TRACE_SIZE - Frames,
            1
            );
    }

    SepAddTokenLogonSession(NewToken);

#endif

    //
    //  Copy and initialize the variable part.
    //  The variable part is assumed to be position independent.
    //

    RtlCopyMemory( (PVOID)&(NewToken->VariablePart),
                  (PVOID)&(ExistingToken->VariablePart),
                  ExistingToken->VariableLength
                  );

    //
    //  Set the address of the UserAndGroups array.
    //

    ASSERT( ARGUMENT_PRESENT(ExistingToken->UserAndGroups ) );
    ASSERT( (ULONG_PTR)(ExistingToken->UserAndGroups) >=
            (ULONG_PTR)(&(ExistingToken->VariablePart)) );

    //
    // Calculate the relative offset between the old and new block. We
    // will use this value to fixup embedded pointers in this block.
    //
    FieldOffset = (ULONG_PTR)&NewToken->VariablePart - (ULONG_PTR)&ExistingToken->VariablePart;

    UserAndGroups = (PSID_AND_ATTRIBUTES) ((ULONG_PTR) ExistingToken->UserAndGroups + FieldOffset);

    NewToken->UserAndGroups = UserAndGroups;

    //
    //  Now go through and change the address of each SID pointer
    //  for the user and groups
    //

    Index = NewToken->UserAndGroupCount;

    while (Index > 0) {

        (ULONG_PTR) UserAndGroups->Sid += FieldOffset;

        Index -= 1;
        UserAndGroups++;

    }

    //
    //  Set the address of the RestrictedSids array.
    //
    
    RestrictedSids = ExistingToken->RestrictedSids;
    NewToken->RestrictedSids = RestrictedSids;

    if (ARGUMENT_PRESENT(RestrictedSids) ) {
        ASSERT( (ULONG_PTR)(ExistingToken->RestrictedSids) >=
                (ULONG_PTR)(&(ExistingToken->VariablePart)) );


        (ULONG_PTR) RestrictedSids += FieldOffset;
        NewToken->RestrictedSids = RestrictedSids;

        //
        //  Now go through and change the address of each SID pointer
        //  for the user and groups
        //

        Index = NewToken->RestrictedSidCount;

        while (Index > 0) {

            (ULONG_PTR) RestrictedSids->Sid += FieldOffset;
            RestrictedSids++;

            Index -= 1;

        }
    }

    //
    // If present, set the address of the privileges
    //

    if (ExistingToken->PrivilegeCount > 0) {
        ASSERT( ARGUMENT_PRESENT(ExistingToken->Privileges ) );
        ASSERT( (ULONG_PTR)(ExistingToken->Privileges) >=
                (ULONG_PTR)(&(ExistingToken->VariablePart)) );

        (ULONG_PTR) NewToken->Privileges = (ULONG_PTR) ExistingToken->Privileges + FieldOffset;

    } else {

        NewToken->Privileges = NULL;

    }

    //
    //  Allocate the dynamic portion
    //
    DynamicSize = SeLengthSid( ExistingToken->PrimaryGroup );
    if (ExistingToken->DefaultDacl) {
        DynamicSize += ExistingToken->DefaultDacl->AclSize;
    }

    DynamicPart = (PULONG)ExAllocatePoolWithTag(
                              PagedPool,
                              DynamicSize,
                              'dTeS'
                              );

    NewToken->DynamicPart = DynamicPart;

    if (DynamicPart == NULL) {
        SepReleaseTokenReadLock( ExistingToken );
        ObDereferenceObject (NewToken);
        return( STATUS_INSUFFICIENT_RESOURCES );
    }
    //
    //  Copy and initialize the dynamic part.
    //  The dynamic part is assumed to be position independent.
    //

    RtlCopyMemory( (PVOID)DynamicPart,
                  (PVOID)(ExistingToken->DynamicPart),
                  DynamicSize
                  );

    FieldOffset = (ULONG_PTR) DynamicPart - (ULONG_PTR) ExistingToken->DynamicPart;
    //
    // If present, set the address of the default Dacl
    //

    NewToken->DefaultDacl = ExistingToken->DefaultDacl;
    if (ARGUMENT_PRESENT(NewToken->DefaultDacl)) {

        ASSERT( (ULONG_PTR)(ExistingToken->DefaultDacl) >=
                (ULONG_PTR)(ExistingToken->DynamicPart) );


        (ULONG_PTR) NewToken->DefaultDacl += FieldOffset;

    }

    //
    // Set the address of the primary group
    //

    ASSERT(ARGUMENT_PRESENT(ExistingToken->PrimaryGroup));

    ASSERT( (ULONG_PTR)(ExistingToken->PrimaryGroup) >=
            (ULONG_PTR)(ExistingToken->DynamicPart) );


    (ULONG_PTR) NewToken->PrimaryGroup = (ULONG_PTR) ExistingToken->PrimaryGroup + FieldOffset;

    //
    // Release the source token.
    //

    SepReleaseTokenReadLock( ExistingToken );




    //
    // For the time being, take the easy way to generating an "EffectiveOnly"
    // duplicate.  That is, use the same space required of the original, just
    // eliminate any IDs or privileges not active.
    //
    // Ultimately, if duplication becomes a common operation, then it will be
    // worthwhile to recalculate the actual space needed and copy only the
    // effective IDs/privileges into the new token.
    //

    if (EffectiveOnly) {
        SepMakeTokenEffectiveOnly( NewToken );
    }


    //
    // If the NewToken inherited an active SEP_AUDIT_POLICY from ExistingToken,
    // then increment the counter of tokens with policies.
    //

    if ( NewToken->AuditPolicy.Overlay ) {
        SepModifyTokenPolicyCounter(&NewToken->AuditPolicy, TRUE);
    }
    
#if DBG || TOKEN_LEAK_MONITOR
    if (SepTokenLeakTracking && SepTokenLeakMethodWatch == 0xD && PsGetCurrentProcess()->UniqueProcessId == SepTokenLeakProcessCid) {
        
        NewToken->Count = InterlockedIncrement(&SepTokenLeakMethodCount);
        if (NewToken->Count >= SepTokenLeakBreakCount) {

            DbgPrint("\nToken number 0x%x = 0x%x\n", NewToken->Count, NewToken);
            DbgBreakPoint();
        }
    }
#endif

    (*DuplicateToken) = NewToken;
    return Status;
}


VOID
SepMakeTokenEffectiveOnly(
    __in PTOKEN Token
    )


/*++


Routine Description:

    This routine eliminates all but the effective groups and privileges from
    a token.  It does this by moving elements of the SID and privileges arrays
    to overwrite lapsed IDs/privileges, and then reducing the array element
    counts.  This results in wasted memory within the token object.

    One side effect of this routine is that a token that initially had a
    default owner ID corresponding to a lapsed group will be changed so
    that the default owner ID is the user ID.

    THIS ROUTINE MUST BE CALLED ONLY AS PART OF TOKEN CREATION (FOR TOKENS
    WHICH HAVE NOT YET BEEN INSERTED INTO AN OBJECT TABLE.)  THIS ROUTINE
    MODIFIES READ ONLY TOKEN FIELDS.

    Note that since we are operating on a token that is not yet visible
    to the user, we do not bother acquiring a read lock on the token
    being modified.

Arguments:

    Token - Points to the token to be made effective only.

Return Value:

    None.

--*/
{

    ULONG Index;
    ULONG ElementCount;

    PAGED_CODE();

    //
    // Walk the privilege array, discarding any lapsed privileges
    //

    ElementCount = Token->PrivilegeCount;
    Index = 0;

    while (Index < ElementCount) {

        //
        // If this privilege is not enabled, replace it with the one at
        // the end of the array and reduce the size of the array by one.
        // Otherwise, move on to the next entry in the array.
        //

        if ( !(SepTokenPrivilegeAttributes(Token,Index) & SE_PRIVILEGE_ENABLED)
            ) {

            (Token->Privileges)[Index] =
                (Token->Privileges)[ElementCount - 1];
            ElementCount -= 1;

        } else {

            Index += 1;

        }

    } // endwhile

    Token->PrivilegeCount = ElementCount;

    //
    // Walk the UserAndGroups array (except for the first entry, which is
    // the user - and can't be disabled) discarding any lapsed groups.
    //

    ElementCount = Token->UserAndGroupCount;
    ASSERT( ElementCount >= 1 );        // Must be at least a user ID
    Index = 1;   // Start at the first group, not the user ID.

    while (Index < ElementCount) {

        //
        // If this group is not enabled, replace it with the one at
        // the end of the array and reduce the size of the array by one.
        //

        if ( !(SepTokenGroupAttributes(Token, Index) & SE_GROUP_ENABLED) &&
             !(SepTokenGroupAttributes(Token, Index) & SE_GROUP_USE_FOR_DENY_ONLY) ) {

            //
            // Reset the TOKEN_HAS_ADMIN_GROUP flag
            //

            if (RtlEqualSid(
                    Token->UserAndGroups[Index].Sid,
                    SeAliasAdminsSid
                    )) {
                Token->TokenFlags &= ~TOKEN_HAS_ADMIN_GROUP;
            }


            (Token->UserAndGroups)[Index] =
                (Token->UserAndGroups)[ElementCount - 1];
            ElementCount -= 1;



        } else {

            Index += 1;

        }

    } // endwhile

    Token->UserAndGroupCount = ElementCount;

    return;
}


BOOLEAN
SepSidInSidAndAttributes (
    __in_ecount(SidCount) PSID_AND_ATTRIBUTES SidAndAttributes,
    __in ULONG SidCount,
    __in_opt PSID PrincipalSelfSid,
    __in PSID Sid
    )

/*++

Routine Description:

    Checks to see if a given SID is in the given token.

    N.B. The code to compute the length of a SID and test for equality
         is duplicated from the security runtime since this is such a
         frequently used routine.

Arguments:

    SidAndAttributes - Pointer to the sid and attributes to be examined

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.


    Sid - Pointer to the SID of interest

Return Value:

    A value of TRUE indicates that the SID is in the token, FALSE
    otherwise.

--*/

{

    ULONG i;
    PISID MatchSid;
    ULONG SidLength;
    PTOKEN Token;
    PSID_AND_ATTRIBUTES TokenSid;
    ULONG UserAndGroupCount;

    PAGED_CODE();


    if (!ARGUMENT_PRESENT( SidAndAttributes ) ) {
        return(FALSE);
    }

    //
    // If Sid is the constant PrincipalSelfSid,
    //  replace it with the passed in PrincipalSelfSid.
    //

    if ( PrincipalSelfSid != NULL &&
         RtlEqualSid( SePrincipalSelfSid, Sid ) ) {
        Sid = PrincipalSelfSid;
    }

    //
    // Get the length of the source SID since this only needs to be computed
    // once.
    //

    SidLength = 8 + (4 * ((PISID)Sid)->SubAuthorityCount);

    //
    // Get address of user/group array and number of user/groups.
    //

    TokenSid = SidAndAttributes;
    UserAndGroupCount = SidCount;

    //
    // Scan through the user/groups and attempt to find a match with the
    // specified SID.
    //

    for (i = 0 ; i < UserAndGroupCount ; i += 1) {
        MatchSid = (PISID)TokenSid->Sid;

        //
        // If the SID revision and length matches, then compare the SIDs
        // for equality.
        //

        if ((((PISID)Sid)->Revision == MatchSid->Revision) &&
            (SidLength == (8 + (4 * (ULONG)MatchSid->SubAuthorityCount)))) {
            if (RtlEqualMemory(Sid, MatchSid, SidLength)) {

                return TRUE;

            }
        }

        TokenSid += 1;
    }

    return FALSE;
}


VOID
SepRemoveDisabledGroupsAndPrivileges(
    __in PTOKEN Token,
    __in ULONG Flags,
    __in ULONG GroupCount,
    __in_ecount(GroupCount) PSID_AND_ATTRIBUTES GroupsToDisable,
    __in ULONG PrivilegeCount,
    __in_ecount( PrivilegeCount ) PLUID_AND_ATTRIBUTES PrivilegesToDelete
    )
/*++


Routine Description:

    This routine eliminates all groups and privileges that are marked
    to be deleted/disabled. It does this by looping through the groups in
    the token and checking each one against the groups to disable. Similarly
    the privileges are compared.  It does this by moving elements of the SID and privileges arrays
    to overwrite lapsed IDs/privileges, and then reducing the array element
    counts.  This results in wasted memory within the token object.


    THIS ROUTINE MUST BE CALLED ONLY AS PART OF TOKEN CREATION (FOR TOKENS
    WHICH HAVE NOT YET BEEN INSERTED INTO AN OBJECT TABLE.)  THIS ROUTINE
    MODIFIES READ ONLY TOKEN FIELDS.

    Note that since we are operating on a token that is not yet visible
    to the user, we do not bother acquiring a read lock on the token
    being modified.

Arguments:

    Token - Points to the token to be made effective only.

    Flags - Flags indicating additional filtering. The flags may be:

                DISABLE_MAX_PRIVILEGE - Disable all privileges

    GroupCount - Count of groups to be removed

    GroupsToDisable - Groups to disable and mark with SE_GROUP_USE_FOR_DENY_ONLY

    PrivilegeCount - Count of privileges to remove

    PrivilegesToDelete - List of privileges to remove

Return Value:

    None.

--*/
{

    ULONG Index;
    ULONG Index2;
    ULONG ElementCount;
    BOOLEAN Found;

    PAGED_CODE();

    //
    // Walk the privilege array, discarding any lapsed privileges
    //

    ElementCount = Token->PrivilegeCount;
    Index = 0;

    while (Index < ElementCount) {

        //
        // If the caller asked us to disable all privileges except change
        // notify, do so now.
        //

        if (((Flags & DISABLE_MAX_PRIVILEGE) != 0) &&
              !RtlEqualLuid(
                &Token->Privileges[Index].Luid,
                &SeChangeNotifyPrivilege
                )) {

            (Token->Privileges)[Index] =
                (Token->Privileges)[ElementCount - 1];
            ElementCount -= 1;

        } else {

            //
            // If this privilege is in the list of those to be removed, replace it
            // with the one at the end of the array and reduce the size of the
            // array by one.  Otherwise, move on to the next entry in the array.
            //

            Found = FALSE;
            for (Index2 = 0; Index2 < PrivilegeCount; Index2++ ) {
                
                if (RtlEqualLuid(
                        &Token->Privileges[Index].Luid,
                        &PrivilegesToDelete[Index2].Luid
                        )) {

                    //
                    // If this was a privilege that is noted in the TokenFlags
                    // then the flag must be turned off as well.
                    //

                    if (RtlEqualLuid(
                            &Token->Privileges[Index].Luid,
                            &SeChangeNotifyPrivilege
                            )) {
                        
                        Token->TokenFlags &= ~TOKEN_HAS_TRAVERSE_PRIVILEGE;
                    
                    } else if (RtlEqualLuid(
                                   &Token->Privileges[Index].Luid,
                                   &SeImpersonatePrivilege
                                   )) {
                        
                        Token->TokenFlags &= ~TOKEN_HAS_IMPERSONATE_PRIVILEGE;
                    }

                    (Token->Privileges)[Index] = (Token->Privileges)[ElementCount - 1];
                    ElementCount--;

                    Found = TRUE;
                    break;
                }
            }

            if (!Found) {
                Index += 1;
            }
        }
    } // endwhile

    //
    // Make sure the impersonate privilege is completely
    // turned off for the "blanket" privilege disablings.
    //

    if (Flags & DISABLE_MAX_PRIVILEGE) {

        Token->TokenFlags &= ~TOKEN_HAS_IMPERSONATE_PRIVILEGE;
    }

    Token->PrivilegeCount = ElementCount;

    //
    // Walk the UserAndGroups array marking any disabled groups.
    //

    ElementCount = Token->UserAndGroupCount;
    ASSERT( ElementCount >= 1 );        // Must be at least a user ID
    Index = 0;   // Start at the first group, not the user ID.

    while (Index < ElementCount) {

        //
        // If this group is not enabled, replace it with the one at
        // the end of the array and reduce the size of the array by one.
        //

        if ( SepSidInSidAndAttributes(
                GroupsToDisable,
                GroupCount,
                NULL,           // no principal self sid
                Token->UserAndGroups[Index].Sid
                )){

            (Token->UserAndGroups)[Index].Attributes &= ~(SE_GROUP_ENABLED | SE_GROUP_ENABLED_BY_DEFAULT);
            (Token->UserAndGroups)[Index].Attributes |= SE_GROUP_USE_FOR_DENY_ONLY;

            //
            // If this was the owner, reset the owner to be the user
            //

            if (Index == Token->DefaultOwnerIndex) {
                Token->DefaultOwnerIndex = 0;
            }

            //
            // If this is the admins sid, turn off the admin group flag
            //

            if (RtlEqualSid(
                    Token->UserAndGroups[Index].Sid,
                    SeAliasAdminsSid
                    )) {

                Token->TokenFlags &= ~TOKEN_HAS_ADMIN_GROUP;
            }
        }

        Index += 1;


    } // endwhile


    return;
}


NTSTATUS
SeCopyClientToken(
    __in PACCESS_TOKEN ClientToken,
    __in SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    __in KPROCESSOR_MODE RequestorMode,
    __deref_out PACCESS_TOKEN *DuplicateToken
    )

/*++


Routine Description:

    This routine copies a client's token as part of establishing a client
    context for impersonation.

    The result will be an impersonation token.

    No handles to the new token are established.

    The token will be an exact duplicate of the source token.  It is the
    caller's responsibility to ensure an effective only copy of the token
    is produced when the token is opened, if necessary.


Arguments:

    ClientToken - Points to the token to be duplicated.  This may be either
        a primary or impersonation token.

    ImpersonationLevel - The impersonation level to be assigned to the new
        token.

    RequestorMode - Mode to be assigned as the owner mode of the new token.

    DuplicateToken - Receives a pointer to the duplicate token.
        The token has not yet been inserted into any object table.
        No exceptions are expected when trying to set this OUT value.

Return Value:

    STATUS_SUCCESS - The service successfully completed the requested
        operation.


--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PTOKEN NewToken;

    PAGED_CODE();

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0,
        NULL,
        NULL
        );

    Status = SepDuplicateToken(
                 (PTOKEN)ClientToken,              // ExistingToken
                 &ObjectAttributes,                // ObjectAttributes
                 FALSE,                            // EffectiveOnly
                 TokenImpersonation,               // TokenType  (target)
                 ImpersonationLevel,               // ImpersonationLevel
                 RequestorMode,                    // RequestorMode
                 &NewToken                         // DuplicateToken
                 );

    if (NT_SUCCESS (Status)) {
        //
        //  Insert the new token
        //

        Status = ObInsertObject( NewToken,
                                 NULL,
                                 0,
                                 0,
                                 NULL,
                                 NULL
                                 );


    }

    if (NT_SUCCESS (Status)) {
        *DuplicateToken = (PACCESS_TOKEN)NewToken;
    } else {
        *DuplicateToken = NULL;
    }

    return Status;

}



NTSTATUS
NtFilterToken (
    __in HANDLE ExistingTokenHandle,
    __in ULONG Flags,
    __in_opt PTOKEN_GROUPS SidsToDisable,
    __in_opt PTOKEN_PRIVILEGES PrivilegesToDelete,
    __in_opt PTOKEN_GROUPS RestrictedSids,
    __out PHANDLE NewTokenHandle
    )
/*++


Routine Description:

    Create a new token that is a subset of an existing token.

Arguments:

    ExistingTokenHandle - Is a handle to a token already open for
        TOKEN_DUPLICATE access.

    Flags - Flags indicating additional filtering. The flags may be:

                DISABLE_MAX_PRIVILEGE - Disable all privileges
                SANDBOX_INERT - Record this SAIFER flag in the token.


    SidsToDisable - Contains a list of sids and attributes. All sids with
        the USE_FOR_DENY_ONLY attribute that also exist in the token will
        cause the new token to have that sid set with the USE_FOR_DENY_ONLY
        attribute.

    PrivilegesToDelete - Privileges in this list that are present in the
        existing token will not exist in the final token. This is similar
        to duplicating a token effective only with these privileges set to
        disabled.

    RestrictedSids - Contains a list of SIDs and attributes that will be
        stored in the RestrictedSids field of the new token. These SIDs
        are used after a normal access check to further restrict access.
        The attributes of these groups are always SE_GROUP_MANDATORY |
        SE_GROUP_ENABLED | SE_GROUP_ENABLED_BY_DEFAULT. If there already
        exist RestrictedSids in the original token, these sids will be
        appended.

    NewTokenHandle - Receives the handle of the newly created token.

Return Value:

    STATUS_SUCCESS - Indicates the operation was successful.

    STATUS_INVALID_PARAMETER - Indicates one or more of the parameter values
        was invalid.  This value is returned if the target token is not
        an impersonation token.


--*/
{

    PTOKEN Token;
    PTOKEN NewToken;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status = STATUS_SUCCESS;

    ULONG CapturedSidCount = 0;
    PSID_AND_ATTRIBUTES CapturedSids = NULL;
    ULONG CapturedSidsLength = 0;

    ULONG CapturedGroupCount = 0;
    PSID_AND_ATTRIBUTES CapturedGroups = NULL;
    ULONG CapturedGroupsLength = 0;

    ULONG CapturedPrivilegeCount = 0;
    PLUID_AND_ATTRIBUTES CapturedPrivileges = NULL;
    ULONG CapturedPrivilegesLength = 0;
    ULONG Index;

    HANDLE LocalHandle = NULL;

    OBJECT_HANDLE_INFORMATION HandleInformation;
    ACCESS_MASK EffectiveDesiredAccess;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    //
    //  Probe parameters
    //


    try {


        //
        //  Make sure we can write the handle
        //

        ProbeForWriteHandle(NewTokenHandle);

        //
        //  Capture Sids to remove
        //

        if (ARGUMENT_PRESENT(SidsToDisable)) {
            ProbeForReadSmallStructure( SidsToDisable, sizeof(TOKEN_GROUPS), sizeof(ULONG) );

            CapturedGroupCount = SidsToDisable->GroupCount;
            Status = SeCaptureSidAndAttributesArray(
                        SidsToDisable->Groups,
                        CapturedGroupCount,
                        PreviousMode,
                        NULL, 0,
                        PagedPool,
                        TRUE,
                        &CapturedGroups,
                        &CapturedGroupsLength
                        );

        }

        //
        //  Capture PrivilegesToDelete
        //

        if (NT_SUCCESS(Status) && ARGUMENT_PRESENT(PrivilegesToDelete)) {
            ProbeForReadSmallStructure( PrivilegesToDelete, sizeof(TOKEN_PRIVILEGES), sizeof(ULONG) );

            CapturedPrivilegeCount = PrivilegesToDelete->PrivilegeCount;
            Status = SeCaptureLuidAndAttributesArray(
                         PrivilegesToDelete->Privileges,
                         CapturedPrivilegeCount,
                         PreviousMode,
                         NULL, 0,
                         PagedPool,
                         TRUE,
                         &CapturedPrivileges,
                         &CapturedPrivilegesLength
                         );

        }

        //
        //  Capture Restricted Sids
        //

        if (NT_SUCCESS(Status) && ARGUMENT_PRESENT(RestrictedSids)) {
            ProbeForReadSmallStructure( RestrictedSids, sizeof(TOKEN_GROUPS), sizeof(ULONG) );

            CapturedSidCount = RestrictedSids->GroupCount;
            Status = SeCaptureSidAndAttributesArray(
                        RestrictedSids->Groups,
                        CapturedSidCount,
                        PreviousMode,
                        NULL, 0,
                        PagedPool,
                        TRUE,
                        &CapturedSids,
                        &CapturedSidsLength
                        );

        }



    } except(EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
    }  // end_try

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Check that the attributes are all zero for the restricted sids
    //

    for (Index = 0; Index < CapturedSidCount ; Index++ )
    {
        if (CapturedSids[Index].Attributes != 0) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }
    //
    //  Check the handle's access to the existing token and get
    //  a pointer to that token.  Pick up the default desired
    //  access mask from the handle while we're at it.
    //

    Status = ObReferenceObjectByHandle(
                 ExistingTokenHandle,    // Handle
                 TOKEN_DUPLICATE,        // DesiredAccess
                 SeTokenObjectType,     // ObjectType
                 PreviousMode,           // AccessMode
                 (PVOID *)&Token,        // Object
                 &HandleInformation      // GrantedAccess
                 );

    if ( !NT_SUCCESS(Status) ) {

        goto Cleanup;
    }

    //
    // Check to see if an alternate desired access mask was provided.
    //


    EffectiveDesiredAccess = HandleInformation.GrantedAccess;



    //
    //  Filter the existing token
    //

    NewToken = NULL;
    Status = SepFilterToken(
                 Token,
                 PreviousMode,
                 Flags,
                 CapturedGroupCount,
                 CapturedGroups,
                 CapturedPrivilegeCount,
                 CapturedPrivileges,
                 CapturedSidCount,
                 CapturedSids,
                 CapturedSidsLength,
                 &NewToken
                 );


    if (NT_SUCCESS(Status)) {

        //
        //  Insert the new token
        //

        Status = ObInsertObject( NewToken,
                                 NULL,
                                 EffectiveDesiredAccess,
                                 0,
                                 (PVOID *)NULL,
                                 &LocalHandle
                                 );

    }

    //
    //  We no longer need our reference to the source token
    //

    ObDereferenceObject( (PVOID)Token );


    //
    //  Return the new handle
    //

    if (NT_SUCCESS(Status)) {
        try { *NewTokenHandle = LocalHandle; }
            except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            }
    }

Cleanup:

    if (CapturedGroups != NULL) {
        SeReleaseSidAndAttributesArray(
            CapturedGroups,
            PreviousMode,
            TRUE
            );
    }

    if (CapturedPrivileges != NULL) {
        SeReleaseLuidAndAttributesArray(
            CapturedPrivileges,
            PreviousMode,
            TRUE
            );
    }

    if (CapturedSids != NULL) {
        SeReleaseSidAndAttributesArray(
            CapturedSids,
            PreviousMode,
            TRUE
            );
    }

   return Status;
}


NTSTATUS
SeFilterToken (
    __in PACCESS_TOKEN ExistingToken,
    __in ULONG Flags,
    __in_opt PTOKEN_GROUPS SidsToDisable,
    __in_opt PTOKEN_PRIVILEGES PrivilegesToDelete,
    __in_opt PTOKEN_GROUPS RestrictedSids,
    __deref_out PACCESS_TOKEN * NewToken
    )
/*++


Routine Description:

    Create a new token that is a subset of an existing token.

Arguments:

    ExistingToken - Is a  token already open for
        TOKEN_DUPLICATE access.

    Flags - Flags indicating additional filtering. The flags may be:

                DISABLE_MAX_PRIVILEGE - Disable all privileges
                SANDBOX_INERT - Record this SAIFER flag in the token.


    SidsToDisable - Contains a list of sids and attributes. All sids with
        the USE_FOR_DENY_ONLY attribute that also exist in the token will
        cause the new token to have that sid set with the USE_FOR_DENY_ONLY
        attribute.

    PrivilegesToDelete - Privileges in this list that are present in the
        existing token will not exist in the final token. This is similar
        to duplicating a token effective only with these privileges set to
        disabled.

    RestrictedSids - Contains a list of SIDs and attributes that will be
        stored in the RestrictedSids field of the new token. These SIDs
        are used after a normal access check to further restrict access.
        The attributes of these groups are always SE_GROUP_MANDATORY |
        SE_GROUP_ENABLED | SE_GROUP_ENABLED_BY_DEFAULT. If there already
        exist RestrictedSids in the original token, these sids will be
        appended.

    NewToken - Receives a pointer to the newly created token.

Return Value:

    STATUS_SUCCESS - Indicates the operation was successful.

    STATUS_INVALID_PARAMETER - Indicates one or more of the parameter values
        was invalid.  This value is returned if the target token is not
        an impersonation token.


--*/
{

    PTOKEN Token;
    PTOKEN FilteredToken = NULL;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index;

    ULONG CapturedSidCount = 0;
    PSID_AND_ATTRIBUTES CapturedSids = NULL;
    ULONG CapturedSidsLength = 0;

    ULONG CapturedGroupCount = 0;
    PSID_AND_ATTRIBUTES CapturedGroups = NULL;
    ULONG CapturedGroupsLength = 0;

    ULONG CapturedPrivilegeCount = 0;
    PLUID_AND_ATTRIBUTES CapturedPrivileges = NULL;
    ULONG CapturedPrivilegesLength = 0;

    HANDLE LocalHandle;

    OBJECT_HANDLE_INFORMATION HandleInformation;
    ACCESS_MASK EffectiveDesiredAccess;

    PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    //
    //  Probe parameters
    //

    *NewToken = NULL;


    //
    //  Capture Sids to remove
    //

    if (ARGUMENT_PRESENT(SidsToDisable)) {

        CapturedGroupCount = SidsToDisable->GroupCount;
        CapturedGroups = SidsToDisable->Groups;

    }

    //
    //  Capture PrivilegesToDelete
    //

    if (ARGUMENT_PRESENT(PrivilegesToDelete)) {

        CapturedPrivilegeCount = PrivilegesToDelete->PrivilegeCount;
        CapturedPrivileges = PrivilegesToDelete->Privileges;

    }

    //
    //  Capture Restricted Sids
    //

    if (ARGUMENT_PRESENT(RestrictedSids)) {

        CapturedSidCount = RestrictedSids->GroupCount;
        CapturedSids = RestrictedSids->Groups;

        //
        // Check that the attributes are all zero for the restricted sids
        //

        for (Index = 0; Index < CapturedSidCount ; Index++ ) {
            if (CapturedSids[Index].Attributes != 0) {
                return(STATUS_INVALID_PARAMETER);
            }
        }

    }



    //
    //  Check the handle's access to the existing token and get
    //  a pointer to that token.  Pick up the default desired
    //  access mask from the handle while we're at it.
    //

    Token = (PTOKEN) ExistingToken;

    //
    //  Filter the existing token
    //

    Status = SepFilterToken(
                 Token,
                 KernelMode,
                 Flags,
                 CapturedGroupCount,
                 CapturedGroups,
                 CapturedPrivilegeCount,
                 CapturedPrivileges,
                 CapturedSidCount,
                 CapturedSids,
                 CapturedSidsLength,
                 &FilteredToken
                 );


    if (NT_SUCCESS(Status)) {

        //
        //  Insert the new token
        //

        Status = ObInsertObject( FilteredToken,
                                 NULL,
                                 0,
                                 0,
                                 NULL,
                                 NULL
                                 );

        if (NT_SUCCESS( Status )) {

            *NewToken = FilteredToken;

        } else {

            //
            //  ObInsertObject dereferences the passed object on failure
            //  so we don't have to clean up here.
            //

        }
    }

   return Status;
}

NTSTATUS
SeFastFilterToken(
    __in PACCESS_TOKEN ExistingToken,
    __in KPROCESSOR_MODE RequestorMode,
    __in ULONG Flags,
    __in ULONG GroupCount,
    __in_ecount_opt(GroupCount) PSID_AND_ATTRIBUTES GroupsToDisable,
    __in ULONG PrivilegeCount,
    __in_ecount_opt(PrivilegeCount) PLUID_AND_ATTRIBUTES PrivilegesToDelete,
    __in ULONG SidCount,
    __in_ecount_opt( SidCount ) PSID_AND_ATTRIBUTES RestrictedSids,
    __in ULONG SidLength,
    __deref_out PACCESS_TOKEN * FilteredToken
    )
/*++

Routine Description:

    This is a fast wrapper for the Ps code to filter a token
    inline of an impersonate.

    This routine acquires a read lock on the token being filtered.

Arguments:

    ExistingToken - Points to the token to be duplicated.

    RequestorMode - Mode of client requesting the token be duplicated.

    Flags - Flags indicating additional filtering. The flags may be:

                DISABLE_MAX_PRIVILEGE - Disable all privileges
                SANDBOX_INERT - Record this SAIFER flag in the token.

    GroupCount - Count of groups to disable

    GroupsToDisable - Contains a list of sids and attributes. All sids with
        the USE_FOR_DENY_ONLY attribute that also exist in the token will
        cause the new token to have that sid set with the USE_FOR_DENY_ONLY
        attribute.

    PrivilegeCount - Count of privileges to delete

    PrivilegesToDelete - Privileges in this list that are present in the
        existing token will not exist in the final token. This is similar
        to duplicating a token effective only with these privileges set to
        disabled.

    SidCount - Count of restricted sids to add.

    RestrictedSids - Contains a list of SIDs and attributes that will be
        stored in the RestrictedSids field of the new token. These SIDs
        are used after a normal access check to further restrict access.
        The attributes of these groups are always SE_GROUP_MANDATORY |
        SE_GROUP_ENABLED | SE_GROUP_ENABLED_BY_DEFAULT. If there already
        exist RestrictedSids in the original token, these sids will be
        appended.

    SidLength - Length of added restricted sids.

    FilteredToken - Receives a pointer to the duplicate token.
        The token has not yet been inserted into any object table.
        No exceptions are expected when trying to set this OUT value.

Return Value:

    STATUS_SUCCESS - The service successfully completed the requested
        operation.


--*/
{
    NTSTATUS Status;
    PTOKEN NewToken;

    Status = SepFilterToken( (PTOKEN) ExistingToken,
                             RequestorMode,
                             Flags,
                             GroupCount,
                             GroupsToDisable,
                             PrivilegeCount,
                             PrivilegesToDelete,
                             SidCount,
                             RestrictedSids,
                             SidLength,
                             &NewToken );

    if (NT_SUCCESS (Status)) {
        //
        //  Insert the new token
        //

        Status = ObInsertObject( NewToken,
                                 NULL,
                                 0,
                                 0,
                                 NULL,
                                 NULL
                                 );

    }

    if (NT_SUCCESS( Status )) {
        *FilteredToken = (PACCESS_TOKEN) NewToken;
    } else {
        *FilteredToken = NULL;
    }
    return Status;
}



NTSTATUS
SepFilterToken(
    __in PTOKEN ExistingToken,
    __in KPROCESSOR_MODE RequestorMode,
    __in ULONG Flags,
    __in ULONG GroupCount,
    __in_ecount_opt(GroupCount) PSID_AND_ATTRIBUTES GroupsToDisable,
    __in ULONG PrivilegeCount,
    __in_ecount_opt(PrivilegeCount) PLUID_AND_ATTRIBUTES PrivilegesToDelete,
    __in ULONG SidCount,
    __in_ecount_opt(SidCount) PSID_AND_ATTRIBUTES RestrictedSids,
    __in ULONG SidLength,
    __deref_out PTOKEN * FilteredToken
    )
/*++


Routine Description:

    This routine does the bulk of the work to actually filter
    a token.  This routine assumes all access validation and argument
    probing has been performed.

    THE CALLER IS RESPONSIBLE FOR CHECKING SUBJECT RIGHTS TO CREATE THE
    TYPE OF TOKEN BEING CREATED.

    This routine acquires a read lock on the token being filtered.

Arguments:

    ExistingToken - Points to the token to be duplicated.

    RequestorMode - Mode of client requesting the token be duplicated.

    Flags - Flags indicating additional filtering. The flags may be:

                DISABLE_MAX_PRIVILEGE - Disable all privileges
                SANDBOX_INERT - Record this SAIFER flag in the token.

    GroupCount - Count of groups to disable

    GroupsToDisable - Contains a list of sids and attributes. All sids with
        the USE_FOR_DENY_ONLY attribute that also exist in the token will
        cause the new token to have that sid set with the USE_FOR_DENY_ONLY
        attribute.

    PrivilegeCount - Count of privileges to delete

    PrivilegesToDelete - Privileges in this list that are present in the
        existing token will not exist in the final token. This is similar
        to duplicating a token effective only with these privileges set to
        disabled.

    SidCount - Count of restricted sids to add.

    RestrictedSids - Contains a list of SIDs and attributes that will be
        stored in the RestrictedSids field of the new token. These SIDs
        are used after a normal access check to further restrict access.
        The attributes of these groups are always SE_GROUP_MANDATORY |
        SE_GROUP_ENABLED | SE_GROUP_ENABLED_BY_DEFAULT. If there already
        exist RestrictedSids in the original token, the intersection of the
        two sets will be in the final tokense sids will be.

    SidLength - Length of added restricted sids.

    FilteredToken - Receives a pointer to the duplicate token.
        The token has not yet been inserted into any object table.
        No exceptions are expected when trying to set this OUT value.

Return Value:

    STATUS_SUCCESS - The service successfully completed the requested
        operation.


--*/
{
    NTSTATUS Status;

    PTOKEN NewToken;
    PULONG DynamicPart;
    ULONG PagedPoolSize;
    ULONG NonPagedPoolSize;
    ULONG TokenBodyLength;
    ULONG FieldOffset;
    ULONG_PTR NextFree;
    PSID NextSidFree;
    ULONG VariableLength;
    ULONG Pad;
    ULONG DynamicSize;

    ULONG Index;

    PSECURITY_TOKEN_PROXY_DATA NewProxyData;
    PSECURITY_TOKEN_AUDIT_DATA NewAuditData;
    OBJECT_ATTRIBUTES ObjA ;

    PERESOURCE TokenLock;

#if DBG || TOKEN_LEAK_MONITOR
    ULONG Frames;
#endif

    PAGED_CODE();

    ASSERT( sizeof(SECURITY_IMPERSONATION_LEVEL) <= sizeof(ULONG) );



    if (ARGUMENT_PRESENT(ExistingToken->ProxyData)) {

        Status = SepCopyProxyData(
                    &NewProxyData,
                    ExistingToken->ProxyData
                    );

        if (!NT_SUCCESS(Status)) {
            return( Status );
        }

    } else {

        NewProxyData = NULL;
    }

    if (ARGUMENT_PRESENT( ExistingToken->AuditData )) {

        NewAuditData = ExAllocatePool( PagedPool, sizeof( SECURITY_TOKEN_AUDIT_DATA ));

        if (NewAuditData == NULL) {

            SepFreeProxyData( NewProxyData );
            return( STATUS_INSUFFICIENT_RESOURCES );

        } else {

            *NewAuditData = *(ExistingToken->AuditData);
        }

    } else {

        NewAuditData = NULL;

    }

    TokenLock = (PERESOURCE)ExAllocatePoolWithTag( NonPagedPool, sizeof( ERESOURCE ), 'dTeS' );

    if (TokenLock == NULL) {

        if (NewAuditData != NULL) {
            ExFreePool( NewAuditData );
        }

        SepFreeProxyData( NewProxyData );

        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  Create a new object
    //

    VariableLength = ExistingToken->VariableLength + SidLength;

#if defined(_WIN64)

    //
    // Account for some additional alignment requirements later on.
    //

    VariableLength += sizeof(ULONG);

#endif

    TokenBodyLength = FIELD_OFFSET(TOKEN, VariablePart) +
                      VariableLength;

    NonPagedPoolSize = TokenBodyLength;
    PagedPoolSize    = ExistingToken->DynamicCharged;

    InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );

    Status = ObCreateObject(
                 RequestorMode,      // ProbeMode
                 SeTokenObjectType, // ObjectType
                 NULL,               // ObjectAttributes
                 RequestorMode,      // OwnershipMode
                 NULL,               // ParseContext
                 TokenBodyLength,    // ObjectBodySize
                 PagedPoolSize,      // PagedPoolCharge
                 NonPagedPoolSize,   // NonPagedPoolCharge
                 (PVOID *)&NewToken  // Return pointer to object
                 );

    if (!NT_SUCCESS(Status)) {
        SepFreeProxyData( NewProxyData );
        ExFreePool( TokenLock );

        if (NewAuditData != NULL) {
            ExFreePool( NewAuditData );
        }

        return Status;
    }

    //
    // The following fields differ in the new token.
    //

    NewToken->TokenLock = TokenLock;
    ExInitializeResourceLite( NewToken->TokenLock );

    //
    // Allocate a new modified Id to distinguish this token from the original
    // token.
    //

    ExAllocateLocallyUniqueId( &(NewToken->ModifiedId) );
    ExAllocateLocallyUniqueId( &(NewToken->TokenId) );
    NewToken->TokenInUse = FALSE;
    NewToken->AuthenticationId = ExistingToken->AuthenticationId;
    NewToken->TokenSource = ExistingToken->TokenSource;
    NewToken->DynamicAvailable = 0;
    NewToken->RestrictedSidCount = 0;
    NewToken->VariableLength = VariableLength;
    NewToken->ProxyData = NewProxyData;
    NewToken->AuditData = NewAuditData;
    NewToken->ParentTokenId = ExistingToken->TokenId;
    NewToken->TokenType = ExistingToken->TokenType;
    NewToken->ImpersonationLevel = ExistingToken->ImpersonationLevel;
    NewToken->ExpirationTime = ExistingToken->ExpirationTime;
    NewToken->OriginatingLogonSession  = ExistingToken->OriginatingLogonSession ;

    //
    //  acquire exclusive access to the source token
    //

    SepAcquireTokenReadLock( ExistingToken );


    //
    // Main Body initialization
    //

    //
    // The following fields are unchanged from the source token.
    // Although some may change if EffectiveOnly has been specified.
    //

    NewToken->DynamicCharged = ExistingToken->DynamicCharged;
    NewToken->DefaultOwnerIndex = ExistingToken->DefaultOwnerIndex;
    NewToken->UserAndGroupCount = ExistingToken->UserAndGroupCount;
    NewToken->SessionId = ExistingToken->SessionId;
    NewToken->PrivilegeCount = ExistingToken->PrivilegeCount;
    NewToken->TokenFlags = ExistingToken->TokenFlags & ~TOKEN_SESSION_NOT_REFERENCED;
    NewToken->AuditPolicy = ExistingToken->AuditPolicy;

    //
    // Increment the reference count for this logon session
    // This can not fail, since there is already a token in this logon
    // session.
    //

    Status = SepDuplicateLogonSessionReference (NewToken, ExistingToken);

    ASSERT( NT_SUCCESS(Status) );

    if (!NT_SUCCESS (Status)) {
        SepReleaseTokenReadLock( ExistingToken );

        NewToken->DynamicPart = NULL;
        ObDereferenceObject (NewToken);
        return Status;
    }


#if DBG || TOKEN_LEAK_MONITOR

    NewToken->ProcessCid          = PsGetCurrentThread()->Cid.UniqueProcess;
    NewToken->ThreadCid           = PsGetCurrentThread()->Cid.UniqueThread;
    NewToken->CreateMethod        = 0xF; // Filter
    NewToken->Count               = 0;
    NewToken->CaptureCount        = 0;

    RtlCopyMemory(
        NewToken->ImageFileName,
        PsGetCurrentProcess()->ImageFileName, 
        min(sizeof(NewToken->ImageFileName), sizeof(PsGetCurrentProcess()->ImageFileName))
        );

    Frames = RtlWalkFrameChain(
                 (PVOID)NewToken->CreateTrace,
                 TRACE_SIZE,
                 0
                 );


    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
        
        RtlWalkFrameChain(
            (PVOID)&NewToken->CreateTrace[Frames],
            TRACE_SIZE - Frames,
            1
            );
    }

    SepAddTokenLogonSession(NewToken);

#endif

    //
    // If the caller passed in the sandbox inert flag then record it.
    //

    if ((Flags & SANDBOX_INERT) != 0) {
        NewToken->TokenFlags |= TOKEN_SANDBOX_INERT;
    }


    //
    // Compute the beginning portion of the variable part, which contains the
    // sid & attributes arrays and the privilege set.
    //

    //
    // First copy the privileges. We will later remove the ones that are
    // to be deleted.
    //

    NextFree = (ULONG_PTR)(&NewToken->VariablePart);
    NewToken->Privileges = (PLUID_AND_ATTRIBUTES)NextFree;
    RtlCopyLuidAndAttributesArray( ExistingToken->PrivilegeCount,
                                   ExistingToken->Privileges,
                                   (PLUID_AND_ATTRIBUTES)NextFree
                                   );

    NextFree += (ExistingToken->PrivilegeCount * (ULONG)sizeof(LUID_AND_ATTRIBUTES));
    VariableLength -= ( (ExistingToken->PrivilegeCount * (ULONG)sizeof(LUID_AND_ATTRIBUTES)) );

#if defined(_WIN64)

    //
    // At this point NextFree is 4-byte aligned, so no alignment work
    // is necessary for the 32-bit product.  For Win64, ensure that NextFree
    // is 8-byte aligned.
    //

    Pad = (ULONG)(NextFree & (sizeof(PVOID)-1));
    if (Pad != 0) {
        Pad = sizeof(PVOID) - Pad;
        NextFree += Pad;
        VariableLength -= Pad;
    }

#endif

    //
    // Figure out the count of SIDs. This is the count of users&groups +
    // the number of existing restricted SIDs plus the number of new
    // restricted Sids
    //

#define MAX(_x_,_y_) ((_x_) > (_y_) ? (_x_) : (_y_))

    NextSidFree = (PSID) (NextFree + (ExistingToken->UserAndGroupCount +
                                      MAX(ExistingToken->RestrictedSidCount,SidCount)) * sizeof(SID_AND_ATTRIBUTES));

    NewToken->UserAndGroups = (PSID_AND_ATTRIBUTES) NextFree;

    //
    // Copy in the existing users & groups. We will later flag the ones
    // to be disabled.
    //

    Status = RtlCopySidAndAttributesArray(
                 ExistingToken->UserAndGroupCount,
                 ExistingToken->UserAndGroups,
                 VariableLength,
                 (PSID_AND_ATTRIBUTES)NextFree,
                 NextSidFree,
                 &NextSidFree,
                 &VariableLength
                 );


    ASSERT(NT_SUCCESS(Status));
    NextFree += (ExistingToken->UserAndGroupCount * (ULONG)sizeof(SID_AND_ATTRIBUTES));

    //
    // Now add all the existing restricted sids. We need to take the
    // intersection of the two sets.
    //

    NewToken->RestrictedSids = (PSID_AND_ATTRIBUTES) NextFree;


    for (Index = 0; Index < SidCount ; Index++ ) {
        if ( ( ExistingToken->RestrictedSidCount == 0 ) ||
            SepSidInSidAndAttributes(
                ExistingToken->RestrictedSids,
                ExistingToken->RestrictedSidCount,
                NULL,                           // no self sid
                RestrictedSids[Index].Sid
                )) {

            Status = RtlCopySidAndAttributesArray(
                        1,
                        &RestrictedSids[Index],
                        VariableLength,
                        (PSID_AND_ATTRIBUTES)NextFree,
                        NextSidFree,
                        &NextSidFree,
                        &VariableLength
                        );
            ASSERT(NT_SUCCESS(Status));
            NextFree += sizeof(SID_AND_ATTRIBUTES);
            NewToken->RestrictedSids[NewToken->RestrictedSidCount].Attributes =
                SE_GROUP_ENABLED | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_MANDATORY;
            NewToken->RestrictedSidCount++;

        }
    }

    //
    //  Allocate the dynamic portion
    //
    DynamicSize = SeLengthSid( ExistingToken->PrimaryGroup );
    if (ExistingToken->DefaultDacl) {
        DynamicSize += ExistingToken->DefaultDacl->AclSize;
    }

    DynamicPart = (PULONG)ExAllocatePoolWithTag(
                              PagedPool,
                              DynamicSize,
                              'dTeS'
                              );

    NewToken->DynamicPart = DynamicPart;

    if (DynamicPart == NULL) {
        SepReleaseTokenReadLock( ExistingToken );
        ObDereferenceObject( NewToken );
        return( STATUS_INSUFFICIENT_RESOURCES );
    }
    //
    // Make sure the new token has some restrictions.
    // If it doesn't, then we've ended up with a token
    // that gives us more access than the original,
    // which we don't want.
    //

    if ((ExistingToken->RestrictedSidCount != 0) &&
        (NewToken->RestrictedSidCount == 0)) {

        SepReleaseTokenReadLock( ExistingToken );

        Status = STATUS_INVALID_PARAMETER;

        //
        // Cleanup.  ObDereferenceObject will cause the logon
        // session to be dereferenced, and will free the proxy data
        // as well as the audit data.
        //
        // See SepTokenDeleteMethod(), which is called by
        // the object manager when the token object is
        // being freed.
        //

        ObDereferenceObject( NewToken );

        return(Status);
    }

    //
    // If there are any restricted sids in the token, turn on the restricted
    // flag
    //

    if (NewToken->RestrictedSidCount > 0) {
        NewToken->TokenFlags |= TOKEN_IS_RESTRICTED;
    }

    //
    //  Copy and initialize the dynamic part.
    //  The dynamic part is assumed to be position independent.
    //

    RtlCopyMemory( (PVOID)DynamicPart,
                  (PVOID)(ExistingToken->DynamicPart),
                  DynamicSize
                  );


    //
    // If present, set the address of the default Dacl
    //

    if (ARGUMENT_PRESENT(ExistingToken->DefaultDacl)) {

        ASSERT( (ULONG_PTR)(ExistingToken->DefaultDacl) >=
                (ULONG_PTR)(ExistingToken->DynamicPart) );

        FieldOffset = (ULONG)((ULONG_PTR)(ExistingToken->DefaultDacl) -
                              (ULONG_PTR)(ExistingToken->DynamicPart));

        NewToken->DefaultDacl = (PACL)(FieldOffset + (ULONG_PTR)DynamicPart);

    } else {

        NewToken->DefaultDacl = NULL;
    }


    //
    // Set the address of the primary group
    //

    ASSERT(ARGUMENT_PRESENT(ExistingToken->PrimaryGroup));

    ASSERT( (ULONG_PTR)(ExistingToken->PrimaryGroup) >=
            (ULONG_PTR)(ExistingToken->DynamicPart) );

    FieldOffset = (ULONG)((ULONG_PTR)(ExistingToken->PrimaryGroup) -
                          (ULONG_PTR)(ExistingToken->DynamicPart));

    //
    // Release the source token.
    //

    SepReleaseTokenReadLock( ExistingToken );

    NewToken->PrimaryGroup = (PACL)(FieldOffset + (ULONG_PTR)(DynamicPart));

    //
    // For the time being, take the easy way to generating an "EffectiveOnly"
    // duplicate.  That is, use the same space required of the original, just
    // eliminate any IDs or privileges not active.
    //
    // Ultimately, if duplication becomes a common operation, then it will be
    // worthwhile to recalculate the actual space needed and copy only the
    // effective IDs/privileges into the new token.
    //

    SepRemoveDisabledGroupsAndPrivileges(
        NewToken,
        Flags,
        GroupCount,
        GroupsToDisable,
        PrivilegeCount,
        PrivilegesToDelete
        );

    //
    // If the NewToken inherited an active SEP_AUDIT_POLICY from ExistingToken,
    // then increment the counter of tokens with policies.
    //

    if ( NewToken->AuditPolicy.Overlay ) {
        SepModifyTokenPolicyCounter(&NewToken->AuditPolicy, TRUE);
    }

#if DBG || TOKEN_LEAK_MONITOR
    if (SepTokenLeakTracking && SepTokenLeakMethodWatch == 0xF && PsGetCurrentProcess()->UniqueProcessId == SepTokenLeakProcessCid) {
        
        NewToken->Count = InterlockedIncrement(&SepTokenLeakMethodCount);
        if (NewToken->Count >= SepTokenLeakBreakCount) {

            DbgPrint("\nToken number 0x%x = 0x%x\n", NewToken->Count, NewToken);
            DbgBreakPoint();
        }
    }
#endif

    (*FilteredToken) = NewToken;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\tokenqry.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Tokenqry.c

Abstract:

    This module implements the QUERY function for the executive
    token object.

--*/

#include "pch.h"

#pragma hdrstop


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtQueryInformationToken)
#pragma alloc_text(PAGE,SeQueryAuthenticationIdToken)
#pragma alloc_text(PAGE,SeQueryInformationToken)
#pragma alloc_text(PAGE,SeQuerySessionIdToken)
#endif


NTSTATUS
NtQueryInformationToken (
    __in HANDLE TokenHandle,
    __in TOKEN_INFORMATION_CLASS TokenInformationClass,
    __out_bcount_part_opt(TokenInformationLength,*ReturnLength) PVOID TokenInformation,
    __in ULONG TokenInformationLength,
    __out PULONG ReturnLength
    )

/*++


Routine Description:

    Retrieve information about a specified token.

Arguments:

    TokenHandle - Provides a handle to the token to operate on.

    TokenInformationClass - The token information class about which
        to retrieve information.

    TokenInformation - The buffer to receive the requested class of
        information.  The buffer must be aligned on at least a
        longword boundary.  The actual structures returned are
        dependent upon the information class requested, as defined in
        the TokenInformationClass parameter description.

        TokenInformation Format By Information Class:

           TokenUser => TOKEN_USER data structure.  TOKEN_QUERY
           access is needed to retrieve this information about a
           token.

           TokenGroups => TOKEN_GROUPS data structure.  TOKEN_QUERY
           access is needed to retrieve this information about a
           token.

           TokenPrivileges => TOKEN_PRIVILEGES data structure.
           TOKEN_QUERY access is needed to retrieve this information
           about a token.

           TokenOwner => TOKEN_OWNER data structure.  TOKEN_QUERY
           access is needed to retrieve this information about a
           token.

           TokenPrimaryGroup => TOKEN_PRIMARY_GROUP data structure.
           TOKEN_QUERY access is needed to retrieve this information
           about a token.

           TokenDefaultDacl => TOKEN_DEFAULT_DACL data structure.
           TOKEN_QUERY access is needed to retrieve this information
           about a token.

           TokenSource => TOKEN_SOURCE data structure.
           TOKEN_QUERY_SOURCE access is needed to retrieve this
           information about a token.

           TokenType => TOKEN_TYPE data structure.
           TOKEN_QUERY access is needed to retrieve this information
           about a token.

           TokenStatistics => TOKEN_STATISTICS data structure.
           TOKEN_QUERY access is needed to retrieve this
           information about a token.

           TokenGroups => TOKEN_GROUPS data structure.  TOKEN_QUERY
           access is needed to retrieve this information about a
           token.

           TokenSessionId => ULONG.  TOKEN_QUERY access is needed to 
           query the Session ID of the token.

           TokenAuditPolicy => TOKEN_AUDIT_POLICY structure.  TOKEN_QUERY
           access is needed to retrieve this information about a token.
           
           TokenOrigin => TOKEN_ORIGIN structure.
           
    TokenInformationLength - Indicates the length, in bytes, of the
        TokenInformation buffer.

    ReturnLength - This OUT parameter receives the actual length of
        the requested information.  If this value is larger than that
        provided by the TokenInformationLength parameter, then the
        buffer provided to receive the requested information is not
        large enough to hold that data and no data is returned.

        If the queried class is TokenDefaultDacl and there is no
        default Dacl established for the token, then the return
        length will be returned as zero, and no data will be returned.

Return Value:

    STATUS_SUCCESS - Indicates the operation was successful.

    STATUS_BUFFER_TOO_SMALL - if the requested information did not
        fit in the provided output buffer.  In this case, the
        ReturnLength OUT parameter contains the number of bytes
        actually needed to store the requested information.

--*/
{

    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    PTOKEN Token;

    ULONG RequiredLength;
    ULONG Index;
    ULONG GroupsLength;
    ULONG RestrictedSidsLength;
    ULONG PrivilegesLength;

    PTOKEN_TYPE LocalType;
    PTOKEN_USER LocalUser;
    PTOKEN_GROUPS LocalGroups;
    PTOKEN_PRIVILEGES LocalPrivileges;
    PTOKEN_OWNER LocalOwner;
    PTOKEN_PRIMARY_GROUP LocalPrimaryGroup;
    PTOKEN_DEFAULT_DACL LocalDefaultDacl;
    PTOKEN_SOURCE LocalSource;
    PSECURITY_IMPERSONATION_LEVEL LocalImpersonationLevel;
    PTOKEN_STATISTICS LocalStatistics;
    PTOKEN_GROUPS_AND_PRIVILEGES LocalGroupsAndPrivileges;
    PTOKEN_ORIGIN Origin ;

    PSID PSid;
    PACL PAcl;

    PVOID Ignore;
    ULONG SessionId;

    PTOKEN_AUDIT_POLICY pAuditPolicy; 
    LONG AuditPolicyElementCount;
    SEP_AUDIT_POLICY CurrentTokenAuditPolicy;

    PAGED_CODE();

    //
    // Get previous processor mode and probe output argument if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {

            ProbeForWrite(
                TokenInformation,
                TokenInformationLength,
                sizeof(ULONG)
                );

            ProbeForWriteUlong(ReturnLength);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Case on information class.
    //

    switch ( TokenInformationClass ) {

    case TokenUser:

        LocalUser = (PTOKEN_USER)TokenInformation;

        Status = ObReferenceObjectByHandle(
                 TokenHandle,           // Handle
                 TOKEN_QUERY,           // DesiredAccess
                 SeTokenObjectType,    // ObjectType
                 PreviousMode,          // AccessMode
                 (PVOID *)&Token,       // Object
                 NULL                   // GrantedAccess
                 );

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        //
        //  Gain exclusive access to the token.
        //

        SepAcquireTokenReadLock( Token );



        //
        // Return the length required now in case not enough buffer
        // was provided by the caller and we have to return an error.
        //

        RequiredLength = SeLengthSid( Token->UserAndGroups[0].Sid) +
                         (ULONG)sizeof( TOKEN_USER );

        try {

            *ReturnLength = RequiredLength;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        if ( TokenInformationLength < RequiredLength ) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        // Return the user SID
        //

        try {

            //
            //  Put SID immediately following TOKEN_USER data structure
            //
            PSid = (PSID)( (ULONG_PTR)LocalUser + (ULONG)sizeof(TOKEN_USER) );

            RtlCopySidAndAttributesArray(
                1,
                Token->UserAndGroups,
                RequiredLength,
                &(LocalUser->User),
                PSid,
                ((PSID *)&Ignore),
                ((PULONG)&Ignore)
                );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }


        SepReleaseTokenReadLock( Token );
        ObDereferenceObject( Token );
        return STATUS_SUCCESS;

    case TokenGroups:

        LocalGroups = (PTOKEN_GROUPS)TokenInformation;

        Status = ObReferenceObjectByHandle(
                 TokenHandle,           // Handle
                 TOKEN_QUERY,           // DesiredAccess
                 SeTokenObjectType,    // ObjectType
                 PreviousMode,          // AccessMode
                 (PVOID *)&Token,       // Object
                 NULL                   // GrantedAccess
                 );

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        Index = 1;

        //
        //  Gain exclusive access to the token.
        //

        SepAcquireTokenReadLock( Token );

        //
        // Figure out how much space is needed to return the group SIDs.
        // That's the size of TOKEN_GROUPS (without any array entries)
        // plus the size of an SID_AND_ATTRIBUTES times the number of groups.
        // The number of groups is Token->UserAndGroups-1 (since the count
        // includes the user ID).  Then the lengths of each individual group
        // must be added.
        //

        RequiredLength = (ULONG)sizeof(TOKEN_GROUPS) +
                         ((Token->UserAndGroupCount - ANYSIZE_ARRAY - 1) *
                         ((ULONG)sizeof(SID_AND_ATTRIBUTES)) );

        while (Index < Token->UserAndGroupCount) {

            RequiredLength += SeLengthSid( Token->UserAndGroups[Index].Sid );

            Index += 1;

        } // endwhile

        //
        // Return the length required now in case not enough buffer
        // was provided by the caller and we have to return an error.
        //

        try {

            *ReturnLength = RequiredLength;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        if ( TokenInformationLength < RequiredLength ) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        // Now copy the groups.
        //

        try {

            LocalGroups->GroupCount = Token->UserAndGroupCount - 1;

            PSid = (PSID)( (ULONG_PTR)LocalGroups +
                           (ULONG)sizeof(TOKEN_GROUPS) +
                           (   (Token->UserAndGroupCount - ANYSIZE_ARRAY - 1) *
                               (ULONG)sizeof(SID_AND_ATTRIBUTES) )
                         );

            RtlCopySidAndAttributesArray(
                (ULONG)(Token->UserAndGroupCount - 1),
                &(Token->UserAndGroups[1]),
                RequiredLength,
                LocalGroups->Groups,
                PSid,
                ((PSID *)&Ignore),
                ((PULONG)&Ignore)
                );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }


        SepReleaseTokenReadLock( Token );
        ObDereferenceObject( Token );
        return STATUS_SUCCESS;

    case TokenRestrictedSids:

        LocalGroups = (PTOKEN_GROUPS)TokenInformation;

        Status = ObReferenceObjectByHandle(
                 TokenHandle,           // Handle
                 TOKEN_QUERY,           // DesiredAccess
                 SeTokenObjectType,    // ObjectType
                 PreviousMode,          // AccessMode
                 (PVOID *)&Token,       // Object
                 NULL                   // GrantedAccess
                 );

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        Index = 0;

        //
        //  Gain exclusive access to the token.
        //

        SepAcquireTokenReadLock( Token );

        //
        // Figure out how much space is needed to return the group SIDs.
        // That's the size of TOKEN_GROUPS (without any array entries)
        // plus the size of an SID_AND_ATTRIBUTES times the number of groups.
        // The number of groups is Token->UserAndGroups-1 (since the count
        // includes the user ID).  Then the lengths of each individual group
        // must be added.
        //

        RequiredLength = (ULONG)sizeof(TOKEN_GROUPS) +
                         ((Token->RestrictedSidCount) *
                         ((ULONG)sizeof(SID_AND_ATTRIBUTES)) -
                         ANYSIZE_ARRAY * sizeof(SID_AND_ATTRIBUTES) );

        while (Index < Token->RestrictedSidCount) {

            RequiredLength += SeLengthSid( Token->RestrictedSids[Index].Sid );

            Index += 1;

        } // endwhile

        //
        // Return the length required now in case not enough buffer
        // was provided by the caller and we have to return an error.
        //

        try {

            *ReturnLength = RequiredLength;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        if ( TokenInformationLength < RequiredLength ) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        // Now copy the groups.
        //

        try {

            LocalGroups->GroupCount = Token->RestrictedSidCount;

            PSid = (PSID)( (ULONG_PTR)LocalGroups +
                           (ULONG)sizeof(TOKEN_GROUPS) +
                           (   (Token->RestrictedSidCount ) *
                               (ULONG)sizeof(SID_AND_ATTRIBUTES) -
                               ANYSIZE_ARRAY * sizeof(SID_AND_ATTRIBUTES) )
                         );

            RtlCopySidAndAttributesArray(
                (ULONG)(Token->RestrictedSidCount),
                Token->RestrictedSids,
                RequiredLength,
                LocalGroups->Groups,
                PSid,
                ((PSID *)&Ignore),
                ((PULONG)&Ignore)
                );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }


        SepReleaseTokenReadLock( Token );
        ObDereferenceObject( Token );
        return STATUS_SUCCESS;

    case TokenPrivileges:

        LocalPrivileges = (PTOKEN_PRIVILEGES)TokenInformation;

        Status = ObReferenceObjectByHandle(
                 TokenHandle,           // Handle
                 TOKEN_QUERY,           // DesiredAccess
                 SeTokenObjectType,    // ObjectType
                 PreviousMode,          // AccessMode
                 (PVOID *)&Token,       // Object
                 NULL                   // GrantedAccess
                 );

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        //
        //  Gain exclusive access to the token to prevent changes
        //  from occurring to the privileges.
        //

        SepAcquireTokenReadLock( Token );


        //
        // Return the length required now in case not enough buffer
        // was provided by the caller and we have to return an error.
        //

        RequiredLength = (ULONG)sizeof(TOKEN_PRIVILEGES) +
                         ((Token->PrivilegeCount - ANYSIZE_ARRAY) *
                         ((ULONG)sizeof(LUID_AND_ATTRIBUTES)) );


        try {

            *ReturnLength = RequiredLength;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        if ( TokenInformationLength < RequiredLength ) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        // Return the token privileges.
        //

        try {

            LocalPrivileges->PrivilegeCount = Token->PrivilegeCount;

            RtlCopyLuidAndAttributesArray(
                Token->PrivilegeCount,
                Token->Privileges,
                LocalPrivileges->Privileges
                );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }


        SepReleaseTokenReadLock( Token );
        ObDereferenceObject( Token );
        return STATUS_SUCCESS;

    case TokenOwner:

        LocalOwner = (PTOKEN_OWNER)TokenInformation;

        Status = ObReferenceObjectByHandle(
                 TokenHandle,           // Handle
                 TOKEN_QUERY,           // DesiredAccess
                 SeTokenObjectType,    // ObjectType
                 PreviousMode,          // AccessMode
                 (PVOID *)&Token,       // Object
                 NULL                   // GrantedAccess
                 );

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        //
        //  Gain exclusive access to the token to prevent changes
        //  from occurring to the owner.
        //

        SepAcquireTokenReadLock( Token );

        //
        // Return the length required now in case not enough buffer
        // was provided by the caller and we have to return an error.
        //

        PSid = Token->UserAndGroups[Token->DefaultOwnerIndex].Sid;
        RequiredLength = (ULONG)sizeof(TOKEN_OWNER) +
                         SeLengthSid( PSid );

        try {

            *ReturnLength = RequiredLength;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        if ( TokenInformationLength < RequiredLength ) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        // Return the owner SID
        //

        PSid = (PSID)((ULONG_PTR)LocalOwner +
                      (ULONG)sizeof(TOKEN_OWNER));

        try {

            LocalOwner->Owner = PSid;

            Status = RtlCopySid(
                         (RequiredLength - (ULONG)sizeof(TOKEN_OWNER)),
                         PSid,
                         Token->UserAndGroups[Token->DefaultOwnerIndex].Sid
                         );

            ASSERT( NT_SUCCESS(Status) );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }


        SepReleaseTokenReadLock( Token );
        ObDereferenceObject( Token );
        return STATUS_SUCCESS;

    case TokenPrimaryGroup:

        LocalPrimaryGroup = (PTOKEN_PRIMARY_GROUP)TokenInformation;

        Status = ObReferenceObjectByHandle(
                 TokenHandle,           // Handle
                 TOKEN_QUERY,           // DesiredAccess
                 SeTokenObjectType,    // ObjectType
                 PreviousMode,          // AccessMode
                 (PVOID *)&Token,       // Object
                 NULL                   // GrantedAccess
                 );

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        //
        //  Gain exclusive access to the token to prevent changes
        //  from occurring to the owner.
        //

        SepAcquireTokenReadLock( Token );

        //
        // Return the length required now in case not enough buffer
        // was provided by the caller and we have to return an error.
        //

        RequiredLength = (ULONG)sizeof(TOKEN_PRIMARY_GROUP) +
                         SeLengthSid( Token->PrimaryGroup );

        try {

            *ReturnLength = RequiredLength;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        if ( TokenInformationLength < RequiredLength ) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        // Return the primary group SID
        //

        PSid = (PSID)((ULONG_PTR)LocalPrimaryGroup +
                      (ULONG)sizeof(TOKEN_PRIMARY_GROUP));

        try {

            LocalPrimaryGroup->PrimaryGroup = PSid;

            Status = RtlCopySid( (RequiredLength - (ULONG)sizeof(TOKEN_PRIMARY_GROUP)),
                                 PSid,
                                 Token->PrimaryGroup
                                 );

            ASSERT( NT_SUCCESS(Status) );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }


        SepReleaseTokenReadLock( Token );
        ObDereferenceObject( Token );
        return STATUS_SUCCESS;

    case TokenDefaultDacl:

        LocalDefaultDacl = (PTOKEN_DEFAULT_DACL)TokenInformation;

        Status = ObReferenceObjectByHandle(
                 TokenHandle,           // Handle
                 TOKEN_QUERY,           // DesiredAccess
                 SeTokenObjectType,    // ObjectType
                 PreviousMode,          // AccessMode
                 (PVOID *)&Token,       // Object
                 NULL                   // GrantedAccess
                 );

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        RequiredLength = (ULONG)sizeof(TOKEN_DEFAULT_DACL);

        //
        //  Gain exclusive access to the token to prevent changes
        //  from occurring to the owner.
        //

        SepAcquireTokenReadLock( Token );


        //
        // Return the length required now in case not enough buffer
        // was provided by the caller and we have to return an error.
        //

        if (ARGUMENT_PRESENT(Token->DefaultDacl)) {

            RequiredLength += Token->DefaultDacl->AclSize;

        }

        try {

            *ReturnLength = RequiredLength;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        if ( TokenInformationLength < RequiredLength ) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        // Return the default Dacl
        //

        PAcl = (PACL)((ULONG_PTR)LocalDefaultDacl +
                      (ULONG)sizeof(TOKEN_DEFAULT_DACL));

        try {

            if (ARGUMENT_PRESENT(Token->DefaultDacl)) {

                LocalDefaultDacl->DefaultDacl = PAcl;

                RtlCopyMemory( (PVOID)PAcl,
                               (PVOID)Token->DefaultDacl,
                               Token->DefaultDacl->AclSize
                               );
            } else {

                LocalDefaultDacl->DefaultDacl = NULL;

            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }


        SepReleaseTokenReadLock( Token );
        ObDereferenceObject( Token );
        return STATUS_SUCCESS;



    case TokenSource:

        LocalSource = (PTOKEN_SOURCE)TokenInformation;

        Status = ObReferenceObjectByHandle(
                 TokenHandle,           // Handle
                 TOKEN_QUERY_SOURCE,    // DesiredAccess
                 SeTokenObjectType,    // ObjectType
                 PreviousMode,          // AccessMode
                 (PVOID *)&Token,       // Object
                 NULL                   // GrantedAccess
                 );

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        //
        // The type of a token can not be changed, so
        // exclusive access to the token is not necessary.
        //

        //
        // Return the length required now in case not enough buffer
        // was provided by the caller and we have to return an error.
        //

        RequiredLength = (ULONG) sizeof(TOKEN_SOURCE);

        try {

            *ReturnLength = RequiredLength;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        if ( TokenInformationLength < RequiredLength ) {

            ObDereferenceObject( Token );
            return STATUS_BUFFER_TOO_SMALL;

        }


        //
        // Return the token source
        //

        try {

            (*LocalSource) = Token->TokenSource;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            ObDereferenceObject( Token );
            return GetExceptionCode();
        }


        ObDereferenceObject( Token );
        return STATUS_SUCCESS;

    case TokenType:

        LocalType = (PTOKEN_TYPE)TokenInformation;

        Status = ObReferenceObjectByHandle(
                 TokenHandle,           // Handle
                 TOKEN_QUERY,           // DesiredAccess
                 SeTokenObjectType,    // ObjectType
                 PreviousMode,          // AccessMode
                 (PVOID *)&Token,       // Object
                 NULL                   // GrantedAccess
                 );

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        //
        // The type of a token can not be changed, so
        // exclusive access to the token is not necessary.
        //

        //
        // Return the length required now in case not enough buffer
        // was provided by the caller and we have to return an error.
        //

        RequiredLength = (ULONG) sizeof(TOKEN_TYPE);

        try {

            *ReturnLength = RequiredLength;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        if ( TokenInformationLength < RequiredLength ) {

            ObDereferenceObject( Token );
            return STATUS_BUFFER_TOO_SMALL;

        }


        //
        // Return the token type
        //

        try {

            (*LocalType) = Token->TokenType;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            ObDereferenceObject( Token );
            return GetExceptionCode();
        }


        ObDereferenceObject( Token );
        return STATUS_SUCCESS;


    case TokenImpersonationLevel:

        LocalImpersonationLevel = (PSECURITY_IMPERSONATION_LEVEL)TokenInformation;

        Status = ObReferenceObjectByHandle(
                 TokenHandle,           // Handle
                 TOKEN_QUERY,           // DesiredAccess
                 SeTokenObjectType,    // ObjectType
                 PreviousMode,          // AccessMode
                 (PVOID *)&Token,       // Object
                 NULL                   // GrantedAccess
                 );

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        //
        // The impersonation level of a token can not be changed, so
        // exclusive access to the token is not necessary.
        //

        //
        //  Make sure the token is an appropriate type to be retrieving
        //  the impersonation level from.
        //

        if (Token->TokenType != TokenImpersonation) {

            ObDereferenceObject( Token );
            return STATUS_INVALID_INFO_CLASS;

        }

        //
        // Return the length required now in case not enough buffer
        // was provided by the caller and we have to return an error.
        //

        RequiredLength = (ULONG) sizeof(SECURITY_IMPERSONATION_LEVEL);

        try {

            *ReturnLength = RequiredLength;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        if ( TokenInformationLength < RequiredLength ) {

            ObDereferenceObject( Token );
            return STATUS_BUFFER_TOO_SMALL;

        }


        //
        // Return the impersonation level
        //

        try {

            (*LocalImpersonationLevel) = Token->ImpersonationLevel;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            ObDereferenceObject( Token );
            return GetExceptionCode();
        }


        ObDereferenceObject( Token );
        return STATUS_SUCCESS;


    case TokenStatistics:

        LocalStatistics = (PTOKEN_STATISTICS)TokenInformation;

        Status = ObReferenceObjectByHandle(
                 TokenHandle,           // Handle
                 TOKEN_QUERY,           // DesiredAccess
                 SeTokenObjectType,    // ObjectType
                 PreviousMode,          // AccessMode
                 (PVOID *)&Token,       // Object
                 NULL                   // GrantedAccess
                 );

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        RequiredLength = (ULONG)sizeof( TOKEN_STATISTICS );




        //
        // Return the length required now in case not enough buffer
        // was provided by the caller and we have to return an error.
        //


        try {

            *ReturnLength = RequiredLength;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        if ( TokenInformationLength < RequiredLength ) {

            ObDereferenceObject( Token );
            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        //  Gain exclusive access to the token.
        //

        SepAcquireTokenReadLock( Token );

        //
        // Return the statistics
        //

        try {
            ULONG Size;

            LocalStatistics->TokenId            = Token->TokenId;
            LocalStatistics->AuthenticationId   = Token->AuthenticationId;
            LocalStatistics->ExpirationTime     = Token->ExpirationTime;
            LocalStatistics->TokenType          = Token->TokenType;
            LocalStatistics->ImpersonationLevel = Token->ImpersonationLevel;
            LocalStatistics->DynamicCharged     = Token->DynamicCharged;

            Size = Token->DynamicCharged - SeLengthSid( Token->PrimaryGroup );;

            if (Token->DefaultDacl) {
                Size -= Token->DefaultDacl->AclSize;
            }
            LocalStatistics->DynamicAvailable   = Size;
            LocalStatistics->GroupCount         = Token->UserAndGroupCount-1;
            LocalStatistics->PrivilegeCount     = Token->PrivilegeCount;
            LocalStatistics->ModifiedId         = Token->ModifiedId;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }


        SepReleaseTokenReadLock( Token );
        ObDereferenceObject( Token );
        return STATUS_SUCCESS;

    case TokenSessionId:

        try {

            *ReturnLength = sizeof(ULONG);

        } except(EXCEPTION_EXECUTE_HANDLER) {

            return GetExceptionCode();
        }

        if ( TokenInformationLength < sizeof(ULONG) )
            return( STATUS_BUFFER_TOO_SMALL );

        Status = ObReferenceObjectByHandle(
                 TokenHandle,           // Handle
                 TOKEN_QUERY,           // DesiredAccess
                 SeTokenObjectType,    // ObjectType
                 PreviousMode,          // AccessMode
                 (PVOID *)&Token,       // Object
                 NULL                   // GrantedAccess
                 );

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        //
        // Get SessionId for the token
        //
        SeQuerySessionIdToken( (PACCESS_TOKEN)Token,
                               &SessionId);

        try {

            *(PULONG)TokenInformation = SessionId;
            *ReturnLength = sizeof(ULONG);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        ObDereferenceObject( Token );
        return( STATUS_SUCCESS );


    case TokenGroupsAndPrivileges:

        LocalGroupsAndPrivileges = (PTOKEN_GROUPS_AND_PRIVILEGES)TokenInformation;

        Status = ObReferenceObjectByHandle(
                 TokenHandle,           // Handle
                 TOKEN_QUERY,           // DesiredAccess
                 SeTokenObjectType,    // ObjectType
                 PreviousMode,          // AccessMode
                 (PVOID *)&Token,       // Object
                 NULL                   // GrantedAccess
                 );

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        //
        //  Gain exclusive access to the token.
        //

        SepAcquireTokenReadLock( Token );

        //
        // Figure out how much space is needed to return the group SIDs.
        // The data arrangement is as follows:
        //     GroupsAndPrivileges struct
        //     User and Groups
        //     Restricted sids
        //     Privileges
        //

        PrivilegesLength = Token->PrivilegeCount *
                           ((ULONG)sizeof(LUID_AND_ATTRIBUTES));

        GroupsLength = Token->UserAndGroupCount *
                       ((ULONG)sizeof(SID_AND_ATTRIBUTES));

        RestrictedSidsLength = Token->RestrictedSidCount *
                               ((ULONG)sizeof(SID_AND_ATTRIBUTES));

        Index = 0;
        while (Index < Token->UserAndGroupCount) {

            GroupsLength += SeLengthSid( Token->UserAndGroups[Index].Sid );

            Index += 1;

        } // endwhile

        Index = 0;
        while (Index < Token->RestrictedSidCount) {

            RestrictedSidsLength += SeLengthSid( Token->RestrictedSids[Index].Sid );

            Index += 1;

        } // endwhile

        RequiredLength = (ULONG)sizeof(TOKEN_GROUPS_AND_PRIVILEGES) +
                         PrivilegesLength + RestrictedSidsLength + GroupsLength;
        //
        // Return the length required now in case not enough buffer
        // was provided by the caller and we have to return an error.
        //

        try {

            *ReturnLength = RequiredLength;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        if ( TokenInformationLength < RequiredLength ) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        // Now copy the groups, followed by restricted sids, followed by
        // privileges.
        //

        try {

            LocalGroupsAndPrivileges->AuthenticationId = Token->AuthenticationId;

            LocalGroupsAndPrivileges->SidLength = GroupsLength;
            LocalGroupsAndPrivileges->SidCount = Token->UserAndGroupCount;
            LocalGroupsAndPrivileges->Sids = (PSID_AND_ATTRIBUTES) ((ULONG_PTR)LocalGroupsAndPrivileges +
                                               (ULONG)sizeof(TOKEN_GROUPS_AND_PRIVILEGES));

            LocalGroupsAndPrivileges->RestrictedSidLength = RestrictedSidsLength;
            LocalGroupsAndPrivileges->RestrictedSidCount = Token->RestrictedSidCount;

            //
            // To distinguish between a restricted token with zero sids and
            // a non-restricted token.
            //

            if (SeTokenIsRestricted((PACCESS_TOKEN) Token))
            {
                LocalGroupsAndPrivileges->RestrictedSids = (PSID_AND_ATTRIBUTES) ((ULONG_PTR) LocalGroupsAndPrivileges->Sids +
                                                             GroupsLength);
            }
            else
            {
                LocalGroupsAndPrivileges->RestrictedSids = NULL;
            }

            LocalGroupsAndPrivileges->PrivilegeLength = PrivilegesLength;
            LocalGroupsAndPrivileges->PrivilegeCount = Token->PrivilegeCount;
            LocalGroupsAndPrivileges->Privileges = (PLUID_AND_ATTRIBUTES) ((ULONG_PTR) LocalGroupsAndPrivileges->Sids + GroupsLength +
                                                    RestrictedSidsLength);

            PSid = (PSID)( (ULONG_PTR)LocalGroupsAndPrivileges->Sids +
                           (Token->UserAndGroupCount *
                           (ULONG)sizeof(SID_AND_ATTRIBUTES))
                         );

            RtlCopySidAndAttributesArray(
                (ULONG)Token->UserAndGroupCount,
                Token->UserAndGroups,
                GroupsLength - (Token->UserAndGroupCount * ((ULONG)sizeof(SID_AND_ATTRIBUTES))),
                LocalGroupsAndPrivileges->Sids,
                PSid,
                ((PSID *)&Ignore),
                ((PULONG)&Ignore)
                );

            PSid = (PSID)((ULONG_PTR)LocalGroupsAndPrivileges->RestrictedSids +
                           ((Token->RestrictedSidCount ) *
                            (ULONG)sizeof(SID_AND_ATTRIBUTES))
                         );

            if (LocalGroupsAndPrivileges->RestrictedSidCount > 0)
            {
                RtlCopySidAndAttributesArray(
                    (ULONG)(Token->RestrictedSidCount),
                    Token->RestrictedSids,
                    RestrictedSidsLength - (Token->RestrictedSidCount * ((ULONG)sizeof(SID_AND_ATTRIBUTES))),
                    LocalGroupsAndPrivileges->RestrictedSids,
                    PSid,
                    ((PSID *)&Ignore),
                    ((PULONG)&Ignore)
                    );
            }

            RtlCopyLuidAndAttributesArray(
                Token->PrivilegeCount,
                Token->Privileges,
                LocalGroupsAndPrivileges->Privileges
                );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            SepReleaseTokenReadLock( Token );
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }


        SepReleaseTokenReadLock( Token );
        ObDereferenceObject( Token );
        return STATUS_SUCCESS;


    case TokenSandBoxInert:

        try {
            *ReturnLength = sizeof(ULONG);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

        if ( TokenInformationLength < sizeof(ULONG) ) {
            return( STATUS_BUFFER_TOO_SMALL );
        }

        Status = ObReferenceObjectByHandle(
                 TokenHandle,           // Handle
                 TOKEN_QUERY,           // DesiredAccess
                 SeTokenObjectType,    // ObjectType
                 PreviousMode,          // AccessMode
                 (PVOID *)&Token,       // Object
                 NULL                   // GrantedAccess
                 );

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        try {

            //
            // If the flag is present in the token then return TRUE.
            // Else return FALSE.
            //

            *(PULONG)TokenInformation = (Token->TokenFlags & TOKEN_SANDBOX_INERT) 
                                              ? TRUE : FALSE;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        ObDereferenceObject( Token );
        return( STATUS_SUCCESS );


    case TokenAuditPolicy:
    {
        pAuditPolicy = (PTOKEN_AUDIT_POLICY)TokenInformation;
        AuditPolicyElementCount = 0;

        //                      
        // We only allow callers with Security privilege to read AuditPolicy
        //

        if ( !SeSinglePrivilegeCheck(SeSecurityPrivilege,PreviousMode) ) {
            
            return( STATUS_PRIVILEGE_NOT_HELD );
        
        }

        Status = ObReferenceObjectByHandle(
                 TokenHandle,           // Handle
                 TOKEN_QUERY,           // DesiredAccess
                 SeTokenObjectType,     // ObjectType
                 PreviousMode,          // AccessMode
                 (PVOID *)&Token,       // Object
                 NULL                   // GrantedAccess
                 );

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        //
        // Copy the audit policy structure.  It is larger than a DWORD
        // so the lock is needed to do this safely.
        //

        SepAcquireTokenReadLock( Token );
        CurrentTokenAuditPolicy = Token->AuditPolicy;
        SepReleaseTokenReadLock( Token );
        
        //
        // Figure out how much space is needed to return the audit policy.  Count
        // the policy elements present in the token.
        // 
        
        if (CurrentTokenAuditPolicy.Overlay) {
            
            if (CurrentTokenAuditPolicy.PolicyElements.System) {
                AuditPolicyElementCount++;
            }
            if (CurrentTokenAuditPolicy.PolicyElements.Logon) {
                AuditPolicyElementCount++;
            }
            if (CurrentTokenAuditPolicy.PolicyElements.ObjectAccess) {
                AuditPolicyElementCount++;
            }
            if (CurrentTokenAuditPolicy.PolicyElements.PrivilegeUse) {
                AuditPolicyElementCount++;
            }
            if (CurrentTokenAuditPolicy.PolicyElements.DetailedTracking) {
                AuditPolicyElementCount++;
            }
            if (CurrentTokenAuditPolicy.PolicyElements.PolicyChange) {
                AuditPolicyElementCount++;
            }
            if (CurrentTokenAuditPolicy.PolicyElements.AccountManagement) {
                AuditPolicyElementCount++;
            }
            if (CurrentTokenAuditPolicy.PolicyElements.DirectoryServiceAccess) {
                AuditPolicyElementCount++;
            }
            if (CurrentTokenAuditPolicy.PolicyElements.AccountLogon) {
                AuditPolicyElementCount++;
            }
        }

        RequiredLength = PER_USER_AUDITING_POLICY_SIZE_BY_COUNT(AuditPolicyElementCount);

        //
        // Return the length required now in case not enough buffer
        // was provided by the caller and we have to return an error.
        //

        try {

            *ReturnLength = RequiredLength;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        if ( TokenInformationLength < RequiredLength ) {

            ObDereferenceObject( Token );
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        // Now construct the policy.
        //

        try {

            LONG PolicyIndex = 0;
            pAuditPolicy->PolicyCount = AuditPolicyElementCount;
            
            if (pAuditPolicy->PolicyCount) {
                
                if (CurrentTokenAuditPolicy.PolicyElements.System) {
                    pAuditPolicy->Policy[PolicyIndex].Category = AuditCategorySystem;
                    pAuditPolicy->Policy[PolicyIndex].PolicyMask = CurrentTokenAuditPolicy.PolicyElements.System;
                    PolicyIndex++;
                }
                if (CurrentTokenAuditPolicy.PolicyElements.Logon) {
                    pAuditPolicy->Policy[PolicyIndex].Category = AuditCategoryLogon;
                    pAuditPolicy->Policy[PolicyIndex].PolicyMask = CurrentTokenAuditPolicy.PolicyElements.Logon;
                    PolicyIndex++;
                }
                if (CurrentTokenAuditPolicy.PolicyElements.ObjectAccess) {
                    pAuditPolicy->Policy[PolicyIndex].Category = AuditCategoryObjectAccess;
                    pAuditPolicy->Policy[PolicyIndex].PolicyMask = CurrentTokenAuditPolicy.PolicyElements.ObjectAccess;
                    PolicyIndex++;
                }
                if (CurrentTokenAuditPolicy.PolicyElements.PrivilegeUse) {
                    pAuditPolicy->Policy[PolicyIndex].Category = AuditCategoryPrivilegeUse;
                    pAuditPolicy->Policy[PolicyIndex].PolicyMask = CurrentTokenAuditPolicy.PolicyElements.PrivilegeUse;
                    PolicyIndex++;
                }
                if (CurrentTokenAuditPolicy.PolicyElements.DetailedTracking) {
                    pAuditPolicy->Policy[PolicyIndex].Category = AuditCategoryDetailedTracking;
                    pAuditPolicy->Policy[PolicyIndex].PolicyMask = CurrentTokenAuditPolicy.PolicyElements.DetailedTracking;
                    PolicyIndex++;
                }
                if (CurrentTokenAuditPolicy.PolicyElements.PolicyChange) {
                    pAuditPolicy->Policy[PolicyIndex].Category = AuditCategoryPolicyChange;
                    pAuditPolicy->Policy[PolicyIndex].PolicyMask = CurrentTokenAuditPolicy.PolicyElements.PolicyChange;
                    PolicyIndex++;
                }
                if (CurrentTokenAuditPolicy.PolicyElements.AccountManagement) {
                    pAuditPolicy->Policy[PolicyIndex].Category = AuditCategoryAccountManagement;
                    pAuditPolicy->Policy[PolicyIndex].PolicyMask = CurrentTokenAuditPolicy.PolicyElements.AccountManagement;
                    PolicyIndex++;
                }
                if (CurrentTokenAuditPolicy.PolicyElements.DirectoryServiceAccess) {
                    pAuditPolicy->Policy[PolicyIndex].Category = AuditCategoryDirectoryServiceAccess;
                    pAuditPolicy->Policy[PolicyIndex].PolicyMask = CurrentTokenAuditPolicy.PolicyElements.DirectoryServiceAccess;
                    PolicyIndex++;
                }
                if (CurrentTokenAuditPolicy.PolicyElements.AccountLogon) {
                    pAuditPolicy->Policy[PolicyIndex].Category = AuditCategoryAccountLogon;
                    pAuditPolicy->Policy[PolicyIndex].PolicyMask = CurrentTokenAuditPolicy.PolicyElements.AccountLogon;
                    PolicyIndex++;
                }
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        ObDereferenceObject( Token );
        return STATUS_SUCCESS;
    }

    case TokenOrigin:
    {
        try {
            *ReturnLength = sizeof( TOKEN_ORIGIN );

        }
        except ( EXCEPTION_EXECUTE_HANDLER ) {

            return GetExceptionCode() ;

        }

        if ( TokenInformationLength < sizeof( TOKEN_ORIGIN ) ) {
            return STATUS_BUFFER_TOO_SMALL ;
            
        }

        Status = ObReferenceObjectByHandle(
                 TokenHandle,           // Handle
                 TOKEN_QUERY,           // DesiredAccess
                 SeTokenObjectType,    // ObjectType
                 PreviousMode,          // AccessMode
                 (PVOID *)&Token,       // Object
                 NULL                   // GrantedAccess
                 );

        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }

        try {

            //
            // If the flag is present in the token then return TRUE.
            // Else return FALSE.
            //

            Origin = (PTOKEN_ORIGIN) TokenInformation ;

            Origin->OriginatingLogonSession = Token->OriginatingLogonSession ;

        } except(EXCEPTION_EXECUTE_HANDLER) {
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        ObDereferenceObject( Token );
        return( STATUS_SUCCESS );


    }



    default:

        return STATUS_INVALID_INFO_CLASS;
    }
}


NTSTATUS
SeQueryAuthenticationIdToken(
    __in PACCESS_TOKEN Token,
    __out PLUID AuthenticationId
    )

/*++


Routine Description:

    Retrieve authentication ID out of the token.

Arguments:

    Token - Referenced pointer to a token.

    AutenticationId - Receives the token's authentication ID.

Return Value:

    STATUS_SUCCESS - Indicates the operation was successful.

    This is the only expected status.

--*/
{
    PAGED_CODE();

    //
    // Token AuthenticationId is a readonly field. No locks are required
    // to read this as its constant for the life of the token.
    //

    (*AuthenticationId) = ((PTOKEN)Token)->AuthenticationId;

    return(STATUS_SUCCESS);
}



NTSTATUS
SeQueryInformationToken (
    __in PACCESS_TOKEN AccessToken,
    __in TOKEN_INFORMATION_CLASS TokenInformationClass,
    __deref_out PVOID *TokenInformation
    )

/*++


Routine Description:

    Retrieve information about a specified token.

Arguments:

    TokenHandle - Provides a handle to the token to operate on.

    TokenInformationClass - The token information class about which
        to retrieve information.

    TokenInformation - Receives a pointer to the requested information.
        The actual structures returned are dependent upon the information
        class requested, as defined in the TokenInformationClass parameter
        description.

        TokenInformation Format By Information Class:

           TokenUser => TOKEN_USER data structure.  TOKEN_QUERY
           access is needed to retrieve this information about a
           token.

           TokenGroups => TOKEN_GROUPS data structure.  TOKEN_QUERY
           access is needed to retrieve this information about a
           token.

           TokenPrivileges => TOKEN_PRIVILEGES data structure.
           TOKEN_QUERY access is needed to retrieve this information
           about a token.

           TokenOwner => TOKEN_OWNER data structure.  TOKEN_QUERY
           access is needed to retrieve this information about a
           token.

           TokenPrimaryGroup => TOKEN_PRIMARY_GROUP data structure.
           TOKEN_QUERY access is needed to retrieve this information
           about a token.

           TokenDefaultDacl => TOKEN_DEFAULT_DACL data structure.
           TOKEN_QUERY access is needed to retrieve this information
           about a token.

           TokenSource => TOKEN_SOURCE data structure.
           TOKEN_QUERY_SOURCE access is needed to retrieve this
           information about a token.

           TokenType => TOKEN_TYPE data structure.
           TOKEN_QUERY access is needed to retrieve this information
           about a token.

           TokenStatistics => TOKEN_STATISTICS data structure.
           TOKEN_QUERY access is needed to retrieve this
           information about a token.

Return Value:

    STATUS_SUCCESS - Indicates the operation was successful.

--*/
{

    NTSTATUS Status;

    ULONG RequiredLength;
    ULONG Index;

    PSID PSid;
    PACL PAcl;

    PVOID Ignore;
    PTOKEN Token = (PTOKEN)AccessToken;

    PAGED_CODE();

    //
    // Case on information class.
    //

    switch ( TokenInformationClass ) {

        case TokenUser:
            {
                PTOKEN_USER LocalUser;

                //
                //  Gain exclusive access to the token.
                //

                SepAcquireTokenReadLock( Token );

                //
                // Return the length required now in case not enough buffer
                // was provided by the caller and we have to return an error.
                //

                RequiredLength = SeLengthSid( Token->UserAndGroups[0].Sid) +
                                 (ULONG)sizeof( TOKEN_USER );

                LocalUser = ExAllocatePool( PagedPool, RequiredLength );

                if (LocalUser == NULL) {
                    SepReleaseTokenReadLock( Token );
                    return( STATUS_INSUFFICIENT_RESOURCES );
                }

                //
                // Return the user SID
                //
                //  Put SID immediately following TOKEN_USER data structure
                //

                PSid = (PSID)( (ULONG_PTR)LocalUser + (ULONG)sizeof(TOKEN_USER) );

                RtlCopySidAndAttributesArray(
                    1,
                    Token->UserAndGroups,
                    RequiredLength,
                    &(LocalUser->User),
                    PSid,
                    ((PSID *)&Ignore),
                    ((PULONG)&Ignore)
                    );

                SepReleaseTokenReadLock( Token );
                *TokenInformation = LocalUser;
                return STATUS_SUCCESS;
            }


        case TokenGroups:
            {
                PTOKEN_GROUPS LocalGroups;

                //
                //  Gain exclusive access to the token.
                //

                SepAcquireTokenReadLock( Token );

                //
                // Figure out how much space is needed to return the group SIDs.
                // That's the size of TOKEN_GROUPS (without any array entries)
                // plus the size of an SID_AND_ATTRIBUTES times the number of groups.
                // The number of groups is Token->UserAndGroups-1 (since the count
                // includes the user ID).  Then the lengths of each individual group
                // must be added.
                //

                RequiredLength = (ULONG)sizeof(TOKEN_GROUPS) +
                                 ((Token->UserAndGroupCount - ANYSIZE_ARRAY - 1) *
                                 ((ULONG)sizeof(SID_AND_ATTRIBUTES)) );

                Index = 1;
                while (Index < Token->UserAndGroupCount) {

                    RequiredLength += SeLengthSid( Token->UserAndGroups[Index].Sid );

                    Index += 1;

                } // endwhile

                LocalGroups = ExAllocatePool( PagedPool, RequiredLength );

                if (LocalGroups == NULL) {
                    SepReleaseTokenReadLock( Token );
                    return( STATUS_INSUFFICIENT_RESOURCES );
                }

                //
                // Now copy the groups.
                //

                LocalGroups->GroupCount = Token->UserAndGroupCount - 1;

                PSid = (PSID)( (ULONG_PTR)LocalGroups +
                               (ULONG)sizeof(TOKEN_GROUPS) +
                               (   (Token->UserAndGroupCount - ANYSIZE_ARRAY - 1) *
                                   (ULONG)sizeof(SID_AND_ATTRIBUTES) )
                             );

                RtlCopySidAndAttributesArray(
                    (ULONG)(Token->UserAndGroupCount - 1),
                    &(Token->UserAndGroups[1]),
                    RequiredLength,
                    LocalGroups->Groups,
                    PSid,
                    ((PSID *)&Ignore),
                    ((PULONG)&Ignore)
                    );

                SepReleaseTokenReadLock( Token );
                *TokenInformation = LocalGroups;
                return STATUS_SUCCESS;
            }


        case TokenPrivileges:
            {
                PTOKEN_PRIVILEGES LocalPrivileges;

                //
                //  Gain exclusive access to the token to prevent changes
                //  from occurring to the privileges.
                //

                SepAcquireTokenReadLock( Token );

                //
                // Return the length required now in case not enough buffer
                // was provided by the caller and we have to return an error.
                //

                RequiredLength = (ULONG)sizeof(TOKEN_PRIVILEGES) +
                                 ((Token->PrivilegeCount - ANYSIZE_ARRAY) *
                                 ((ULONG)sizeof(LUID_AND_ATTRIBUTES)) );

                LocalPrivileges = ExAllocatePool( PagedPool, RequiredLength );

                if (LocalPrivileges == NULL) {
                    SepReleaseTokenReadLock( Token );
                    return( STATUS_INSUFFICIENT_RESOURCES );
                }

                //
                // Return the token privileges.
                //

                LocalPrivileges->PrivilegeCount = Token->PrivilegeCount;

                RtlCopyLuidAndAttributesArray(
                    Token->PrivilegeCount,
                    Token->Privileges,
                    LocalPrivileges->Privileges
                    );

                SepReleaseTokenReadLock( Token );
                *TokenInformation = LocalPrivileges;
                return STATUS_SUCCESS;
            }


        case TokenOwner:
            {
                PTOKEN_OWNER LocalOwner;

                //
                //  Gain exclusive access to the token to prevent changes
                //  from occurring to the owner.
                //

                SepAcquireTokenReadLock( Token );

                //
                // Return the length required now in case not enough buffer
                // was provided by the caller and we have to return an error.
                //

                PSid = Token->UserAndGroups[Token->DefaultOwnerIndex].Sid;
                RequiredLength = (ULONG)sizeof(TOKEN_OWNER) +
                                 SeLengthSid( PSid );

                LocalOwner = ExAllocatePool( PagedPool, RequiredLength );

                if (LocalOwner == NULL) {
                    SepReleaseTokenReadLock( Token );
                    return( STATUS_INSUFFICIENT_RESOURCES );
                }

                //
                // Return the owner SID
                //

                PSid = (PSID)((ULONG_PTR)LocalOwner +
                              (ULONG)sizeof(TOKEN_OWNER));

                LocalOwner->Owner = PSid;

                Status = RtlCopySid(
                             (RequiredLength - (ULONG)sizeof(TOKEN_OWNER)),
                             PSid,
                             Token->UserAndGroups[Token->DefaultOwnerIndex].Sid
                             );

                ASSERT( NT_SUCCESS(Status) );

                SepReleaseTokenReadLock( Token );
                *TokenInformation = LocalOwner;
                return STATUS_SUCCESS;
            }


        case TokenPrimaryGroup:
            {
                PTOKEN_PRIMARY_GROUP LocalPrimaryGroup;

                //
                //  Gain exclusive access to the token to prevent changes
                //  from occurring to the owner.
                //

                SepAcquireTokenReadLock( Token );

                //
                // Return the length required now in case not enough buffer
                // was provided by the caller and we have to return an error.
                //

                RequiredLength = (ULONG)sizeof(TOKEN_PRIMARY_GROUP) +
                                 SeLengthSid( Token->PrimaryGroup );

                LocalPrimaryGroup = ExAllocatePool( PagedPool, RequiredLength );

                if (LocalPrimaryGroup == NULL) {
                    SepReleaseTokenReadLock( Token );
                    return( STATUS_INSUFFICIENT_RESOURCES );
                }

                //
                // Return the primary group SID
                //

                PSid = (PSID)((ULONG_PTR)LocalPrimaryGroup +
                              (ULONG)sizeof(TOKEN_PRIMARY_GROUP));

                LocalPrimaryGroup->PrimaryGroup = PSid;

                Status = RtlCopySid( (RequiredLength - (ULONG)sizeof(TOKEN_PRIMARY_GROUP)),
                                     PSid,
                                     Token->PrimaryGroup
                                     );

                ASSERT( NT_SUCCESS(Status) );

                SepReleaseTokenReadLock( Token );
                *TokenInformation = LocalPrimaryGroup;
                return STATUS_SUCCESS;
            }


        case TokenDefaultDacl:
            {
                PTOKEN_DEFAULT_DACL LocalDefaultDacl;

                RequiredLength = (ULONG)sizeof(TOKEN_DEFAULT_DACL);

                //
                //  Gain exclusive access to the token to prevent changes
                //  from occurring to the owner.
                //

                SepAcquireTokenReadLock( Token );

                //
                // Return the length required now in case not enough buffer
                // was provided by the caller and we have to return an error.
                //


                if (ARGUMENT_PRESENT(Token->DefaultDacl)) {

                    RequiredLength += Token->DefaultDacl->AclSize;
                }

                LocalDefaultDacl = ExAllocatePool( PagedPool, RequiredLength );

                if (LocalDefaultDacl == NULL) {
                    SepReleaseTokenReadLock( Token );
                    return( STATUS_INSUFFICIENT_RESOURCES );
                }

                //
                // Return the default Dacl
                //

                PAcl = (PACL)((ULONG_PTR)LocalDefaultDacl +
                              (ULONG)sizeof(TOKEN_DEFAULT_DACL));

                if (ARGUMENT_PRESENT(Token->DefaultDacl)) {

                    LocalDefaultDacl->DefaultDacl = PAcl;

                    RtlCopyMemory( (PVOID)PAcl,
                                   (PVOID)Token->DefaultDacl,
                                   Token->DefaultDacl->AclSize
                                   );
                } else {

                    LocalDefaultDacl->DefaultDacl = NULL;
                }

                SepReleaseTokenReadLock( Token );
                *TokenInformation = LocalDefaultDacl;
                return STATUS_SUCCESS;
            }


        case TokenSource:
            {
                PTOKEN_SOURCE LocalSource;

                //
                // The type of a token can not be changed, so
                // exclusive access to the token is not necessary.
                //

                //
                // Return the length required now in case not enough buffer
                // was provided by the caller and we have to return an error.
                //

                RequiredLength = (ULONG) sizeof(TOKEN_SOURCE);

                LocalSource = ExAllocatePool( PagedPool, RequiredLength );

                if (LocalSource == NULL) {
                    return( STATUS_INSUFFICIENT_RESOURCES );
                }

                //
                // Return the token source
                //

                (*LocalSource) = Token->TokenSource;
                *TokenInformation = LocalSource;

                return STATUS_SUCCESS;
            }


        case TokenType:
            {
                PTOKEN_TYPE LocalType;

                //
                // The type of a token can not be changed, so
                // exclusive access to the token is not necessary.
                //

                //
                // Return the length required now in case not enough buffer
                // was provided by the caller and we have to return an error.
                //

                RequiredLength = (ULONG) sizeof(TOKEN_TYPE);

                LocalType = ExAllocatePool( PagedPool, RequiredLength );

                if (LocalType == NULL) {
                    return( STATUS_INSUFFICIENT_RESOURCES );
                }

                //
                // Return the token type
                //

                (*LocalType) = Token->TokenType;
                *TokenInformation = LocalType;
                return STATUS_SUCCESS;
            }


        case TokenImpersonationLevel:
            {
                PSECURITY_IMPERSONATION_LEVEL LocalImpersonationLevel;

                //
                // The impersonation level of a token can not be changed, so
                // exclusive access to the token is not necessary.
                //

                //
                //  Make sure the token is an appropriate type to be retrieving
                //  the impersonation level from.
                //

                if (Token->TokenType != TokenImpersonation) {

                    return STATUS_INVALID_INFO_CLASS;
                }

                //
                // Return the length required now in case not enough buffer
                // was provided by the caller and we have to return an error.
                //

                RequiredLength = (ULONG) sizeof(SECURITY_IMPERSONATION_LEVEL);

                LocalImpersonationLevel = ExAllocatePool( PagedPool, RequiredLength );

                if (LocalImpersonationLevel == NULL) {
                    return( STATUS_INSUFFICIENT_RESOURCES );
                }

                //
                // Return the impersonation level
                //

                (*LocalImpersonationLevel) = Token->ImpersonationLevel;
                *TokenInformation = LocalImpersonationLevel;
                return STATUS_SUCCESS;
            }


        case TokenStatistics:
            {
                PTOKEN_STATISTICS LocalStatistics;
                ULONG Size;

                //
                // Return the length required now in case not enough buffer
                // was provided by the caller and we have to return an error.
                //

                RequiredLength = (ULONG)sizeof( TOKEN_STATISTICS );

                LocalStatistics = ExAllocatePool( PagedPool, RequiredLength );

                if (LocalStatistics == NULL) {
                    return( STATUS_INSUFFICIENT_RESOURCES );
                }

                //
                // Copy readonly fields outside of the lock
                //
                LocalStatistics->TokenId            = Token->TokenId;
                LocalStatistics->AuthenticationId   = Token->AuthenticationId;
                LocalStatistics->TokenType          = Token->TokenType;
                LocalStatistics->ImpersonationLevel = Token->ImpersonationLevel;
                LocalStatistics->ExpirationTime     = Token->ExpirationTime;

                //
                //  Gain shared access to the token.
                //

                SepAcquireTokenReadLock( Token );

                //
                // Return the statistics
                //

                LocalStatistics->DynamicCharged     = Token->DynamicCharged;

                Size = Token->DynamicCharged - SeLengthSid( Token->PrimaryGroup );

                if (Token->DefaultDacl) {
                    Size -= Token->DefaultDacl->AclSize;
                }

                LocalStatistics->DynamicAvailable   = Size;
                LocalStatistics->DynamicAvailable   = Token->DynamicAvailable;
                LocalStatistics->GroupCount         = Token->UserAndGroupCount-1;
                LocalStatistics->PrivilegeCount     = Token->PrivilegeCount;
                LocalStatistics->ModifiedId         = Token->ModifiedId;

                SepReleaseTokenReadLock( Token );
                *TokenInformation = LocalStatistics;
                return STATUS_SUCCESS;
            }

    case TokenSessionId:

        /*
         * Get SessionId for the token
         */
        SeQuerySessionIdToken( (PACCESS_TOKEN)Token,
                             (PULONG)TokenInformation );

        return( STATUS_SUCCESS );

    default:

        return STATUS_INVALID_INFO_CLASS;
    }
}



NTSTATUS
SeQuerySessionIdToken(
    __in PACCESS_TOKEN Token,
    __out PULONG SessionId
    )

/*++


Routine Description:

    Gets the SessionId from the specified token object.

Arguments:

    Token (input)
      Opaque kernel ACCESS_TOKEN pointer
    SessionId (output)
      pointer to location to return SessionId

Return Value:

    STATUS_SUCCESS - no error

--*/
{
    PAGED_CODE();

    //
    // Get the SessionId.
    //
    SepAcquireTokenReadLock( ((PTOKEN)Token) );
    (*SessionId) = ((PTOKEN)Token)->SessionId;
    SepReleaseTokenReadLock( ((PTOKEN)Token) );

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\se\tokenset.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Tokenset.c

Abstract:

    This module implements the SET function for the executive
    token object.

--*/

#include "pch.h"

#pragma hdrstop


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtSetInformationToken)
#pragma alloc_text(PAGE,SepExpandDynamic)
#pragma alloc_text(PAGE,SepFreePrimaryGroup)
#pragma alloc_text(PAGE,SepFreeDefaultDacl)
#pragma alloc_text(PAGE,SepAppendPrimaryGroup)
#pragma alloc_text(PAGE,SepAppendDefaultDacl)
#pragma alloc_text(PAGE,SeSetSessionIdToken)
#pragma alloc_text(PAGE,SepModifyTokenPolicyCounter)
#endif


NTSTATUS
NtSetInformationToken (
    __in HANDLE TokenHandle,
    __in TOKEN_INFORMATION_CLASS TokenInformationClass,
    __in_bcount(TokenInformationLength) PVOID TokenInformation,
    __in ULONG TokenInformationLength
    )

/*++


Routine Description:

    Modify information in a specified token.

Arguments:

    TokenHandle - Provides a handle to the token to operate on.

    TokenInformationClass - The token information class being set.

    TokenInformation - The buffer containing the new values for the
        specified class of information.  The buffer must be aligned
        on at least a longword boundary.  The actual structures
        provided are dependent upon the information class specified,
        as defined in the TokenInformationClass parameter
        description.

        TokenInformation Format By Information Class:

           TokenUser => This value is not a valid value for this API.
           The User ID may not be replaced.

           TokenGroups => This value is not a valid value for this
           API.  The Group IDs may not be replaced.  However, groups
           may be enabled and disabled using NtAdjustGroupsToken().

           TokenPrivileges => This value is not a valid value for
           this API.  Privilege information may not be replaced.
           However, privileges may be explicitly enabled and disabled
           using the NtAdjustPrivilegesToken API.

           TokenOwner => TOKEN_OWNER data structure.
           TOKEN_ADJUST_DEFAULT access is needed to replace this
           information in a token.  The owner values that may be
           specified are restricted to the user and group IDs with an
           attribute indicating they may be assigned as the owner of
           objects.

           TokenPrimaryGroup => TOKEN_PRIMARY_GROUP data structure.
           TOKEN_ADJUST_DEFAULT access is needed to replace this
           information in a token.  The primary group values that may
           be specified are restricted to be one of the group IDs
           already in the token.

           TokenDefaultDacl => TOKEN_DEFAULT_DACL data structure.
           TOKEN_ADJUST_DEFAULT access is needed to replace this
           information in a token.  The ACL provided as a new default
           discretionary ACL is not validated for structural
           correctness or consistency.

           TokenSource => This value is not a valid value for this
           API.  The source name and context handle  may not be
           replaced.

           TokenStatistics => This value is not a valid value for this
           API.  The statistics of a token are read-only.

           TokenSessionId => ULONG to set the token session.  Must have
           TOKEN_ADJUST_SESSIONID and TCB privilege.

           TokenSessionReference => ULONG.  Must be zero.  Must have 
           TCB privilege to dereference the logon session.  This info class
           will remove a reference for the logon session, and mark the token
           as not referencing the session.
              
           TokenAuditPolicy => TOKEN_AUDIT_POLICY structure.  This sets the per 
           user policy for the token, and all tokens derived from it.  Requires
           TCB privilege.
           
           TokenParent => TOKEN_PARENT structure.  The parent id can be set 
           by a caller with TCB privilege.  The token id cannot.  
           
    TokenInformationLength - Indicates the length, in bytes, of the
        TokenInformation buffer.  This is only the length of the primary
        buffer.  All extensions of the primary buffer are self describing.

Return Value:

    STATUS_SUCCESS - The operation was successful.

    STATUS_INVALID_OWNER - The ID specified to be an owner (or
        default owner) is not one the caller may assign as the owner
        of an object.

    STATUS_INVALID_INFO_CLASS - The specified information class is
        not one that may be specified in this API.

    STATUS_ALLOTTED_SPACE_EXCEEDED - The space allotted for storage
        of the default discretionary access control and the primary
        group ID is not large enough to accept the new value of one
        of these fields.

--*/
{

    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    PTOKEN Token;

    ULONG Index;
    BOOLEAN Found;
    BOOLEAN TokenModified = FALSE;

    ULONG NewLength;
    ULONG CurrentLength;

    PSID CapturedOwner;
    PSID CapturedPrimaryGroup;
    PACL CapturedDefaultDacl;
    ACCESS_MASK DesiredAccess;

    PAGED_CODE();

    //
    // Get previous processor mode and probe input buffer if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {

            //
            // This just probes the main part of the information buffer.
            // Any information class-specific data hung off the primary
            // buffer are self describing and must be probed separately
            // below.
            //

            ProbeForRead(
                TokenInformation,
                TokenInformationLength,
                sizeof(ULONG)
                );

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Return error if not legal class
    //
    if ( (TokenInformationClass != TokenOwner)  &&
         (TokenInformationClass != TokenPrimaryGroup) &&
         (TokenInformationClass != TokenSessionId) &&
         (TokenInformationClass != TokenDefaultDacl) &&
         (TokenInformationClass != TokenSessionReference) &&
         (TokenInformationClass != TokenAuditPolicy) &&
         (TokenInformationClass != TokenOrigin) ) {

        return STATUS_INVALID_INFO_CLASS;

    }

    //
    // Check access rights and reference token
    //


    DesiredAccess = TOKEN_ADJUST_DEFAULT;
    if (TokenInformationClass == TokenSessionId) {
        DesiredAccess |= TOKEN_ADJUST_SESSIONID;
    }

    Status = ObReferenceObjectByHandle(
             TokenHandle,           // Handle
             DesiredAccess,         // DesiredAccess
             SeTokenObjectType,    // ObjectType
             PreviousMode,          // AccessMode
             (PVOID *)&Token,       // Object
             NULL                   // GrantedAccess
             );

    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }


    //
    // Case on information class.
    //

    switch ( TokenInformationClass ) {

    case TokenOwner:

        //
        //  Make sure the buffer is large enough to hold the
        //  necessary information class data structure.
        //

        if (TokenInformationLength < (ULONG)sizeof(TOKEN_OWNER)) {

            ObDereferenceObject( Token );
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        //  Capture and copy

        try {

            //
            //  Capture Owner SID
            //

            CapturedOwner = ((PTOKEN_OWNER)TokenInformation)->Owner;
            Status = SeCaptureSid(
                         CapturedOwner,
                         PreviousMode,
                         NULL, 0,
                         PagedPool,
                         TRUE,
                         &CapturedOwner
                         );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        if (!NT_SUCCESS(Status)) {
            ObDereferenceObject( Token );
            return Status;
        }

        Index = 0;

        //
        //  Gain write access to the token.
        //

        SepAcquireTokenWriteLock( Token );

        //
        //  Walk through the list of user and group IDs looking
        //  for a match to the specified SID.  If one is found,
        //  make sure it may be assigned as an owner.  If it can,
        //  then set the index in the token's OwnerIndex field.
        //  Otherwise, return invalid owner error.
        //

        while (Index < Token->UserAndGroupCount) {

            try {

                Found = RtlEqualSid(
                            CapturedOwner,
                            Token->UserAndGroups[Index].Sid
                            );

                if ( Found ) {

                    if ( SepIdAssignableAsOwner(Token,Index) ){

                        Token->DefaultOwnerIndex = Index;
                        TokenModified = TRUE;
                        Status = STATUS_SUCCESS;

                    } else {

                        Status = STATUS_INVALID_OWNER;

                    } //endif assignable

                    SepReleaseTokenWriteLock( Token, TokenModified );
                    ObDereferenceObject( Token );
                    SeReleaseSid( CapturedOwner, PreviousMode, TRUE);
                    return Status;

                }  //endif Found

            } except(EXCEPTION_EXECUTE_HANDLER) {

                SepReleaseTokenWriteLock( Token, TokenModified );
                ObDereferenceObject( Token );
                SeReleaseSid( CapturedOwner, PreviousMode, TRUE);
                return GetExceptionCode();

            }  //endtry

            Index += 1;

        } //endwhile

        SepReleaseTokenWriteLock( Token, TokenModified );
        ObDereferenceObject( Token );
        SeReleaseSid( CapturedOwner, PreviousMode, TRUE);
        return STATUS_INVALID_OWNER;

    case TokenPrimaryGroup:

        //
        // Assuming everything works out, the strategy is to move everything
        // in the Dynamic part of the token (exept the primary group) to
        // the beginning of the dynamic part, freeing up the entire end of
        // the dynamic part for the new primary group.
        //

        //
        //  Make sure the buffer is large enough to hold the
        //  necessary information class data structure.
        //

        if (TokenInformationLength < (ULONG)sizeof(TOKEN_PRIMARY_GROUP)) {

            ObDereferenceObject( Token );
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // Capture And Validate TOKEN_PRIMARY_GROUP and corresponding SID.
        //

        try {

            CapturedPrimaryGroup =
                ((PTOKEN_PRIMARY_GROUP)TokenInformation)->PrimaryGroup;

            Status = SeCaptureSid(
                         CapturedPrimaryGroup,
                         PreviousMode,
                         NULL, 0,
                         PagedPool,
                         TRUE,
                         &CapturedPrimaryGroup
                         );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        if (!NT_SUCCESS(Status)) {
            ObDereferenceObject( Token );
            return Status;
        }

        if (!SepIdAssignableAsGroup( Token, CapturedPrimaryGroup )) {
            ObDereferenceObject( Token );
            SeReleaseSid( CapturedPrimaryGroup, PreviousMode, TRUE);
            return STATUS_INVALID_PRIMARY_GROUP;
        }

        NewLength = SeLengthSid( CapturedPrimaryGroup );

        //
        //  Gain write access to the token.
        //

        SepAcquireTokenWriteLock( Token );

        //
        // See if there is enough room in the dynamic part of the token
        // to replace the current Primary Group with the one specified.
        //

        if (Token->DefaultDacl) {
            NewLength += Token->DefaultDacl->AclSize;
        }

        if (NewLength > Token->DynamicCharged) {

            SepReleaseTokenWriteLock( Token, TokenModified );
            ObDereferenceObject( Token );
            SeReleaseSid( CapturedPrimaryGroup, PreviousMode, TRUE);
            return STATUS_ALLOTTED_SPACE_EXCEEDED;
        }

        //
        // Expand the tokens dynamic buffer if we have to
        //

        Status = SepExpandDynamic( Token, NewLength );

        if (!NT_SUCCESS (Status)) {
            SepReleaseTokenWriteLock( Token, TokenModified );
            ObDereferenceObject( Token );
            SeReleaseSid( CapturedPrimaryGroup, PreviousMode, TRUE);
            return Status;
        }


        //
        // Free up the existing primary group
        //

        SepFreePrimaryGroup( Token );

        //
        // And put the new SID in its place
        //

        SepAppendPrimaryGroup( Token, CapturedPrimaryGroup );

        TokenModified = TRUE;

        //
        // All done.
        //

        SepReleaseTokenWriteLock( Token, TokenModified );
        ObDereferenceObject( Token );
        SeReleaseSid( CapturedPrimaryGroup, PreviousMode, TRUE);
        return STATUS_SUCCESS;


    case TokenDefaultDacl:

        //
        // Assuming everything works out, the strategy is to move everything
        // in the Dynamic part of the token (exept the default Dacl) to
        // the beginning of the dynamic part, freeing up the entire end of
        // the dynamic part for the new default Dacl.
        //

        //
        //  Make sure the buffer is large enough to hold the
        //  necessary information class data structure.
        //

        if (TokenInformationLength < (ULONG)sizeof(TOKEN_DEFAULT_DACL)) {

            ObDereferenceObject( Token );
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // Capture And Validate TOKEN_DEFAULT_DACL and corresponding ACL.
        //

        try {

            CapturedDefaultDacl =
                ((PTOKEN_DEFAULT_DACL)TokenInformation)->DefaultDacl;

            if (ARGUMENT_PRESENT(CapturedDefaultDacl)) {
                Status = SeCaptureAcl(
                             CapturedDefaultDacl,
                             PreviousMode,
                             NULL, 0,
                             PagedPool,
                             TRUE,
                             &CapturedDefaultDacl,
                             &NewLength
                             );

            } else {
                NewLength = 0;
                Status = STATUS_SUCCESS;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        if (!NT_SUCCESS(Status)) {
            ObDereferenceObject( Token );
            return Status;
        }

        //
        //  Gain write access to the token.
        //

        SepAcquireTokenWriteLock( Token );

        //
        // See if there is enough room in the dynamic part of the token
        // to replace the current Default Dacl with the one specified.
        //
        NewLength += SeLengthSid( Token->PrimaryGroup );

        if (NewLength > Token->DynamicCharged) {

            SepReleaseTokenWriteLock( Token, TokenModified );
            ObDereferenceObject( Token );
            if (ARGUMENT_PRESENT(CapturedDefaultDacl)) {
                SeReleaseAcl( CapturedDefaultDacl, PreviousMode, TRUE);
            }
            return STATUS_ALLOTTED_SPACE_EXCEEDED;
        }

        //
        // Expand the tokens dynamic buffer if we have to
        //
        Status = SepExpandDynamic( Token, NewLength );

        if (!NT_SUCCESS (Status)) {
            SepReleaseTokenWriteLock( Token, TokenModified );
            ObDereferenceObject( Token );
            if (ARGUMENT_PRESENT(CapturedDefaultDacl)) {
                SeReleaseAcl( CapturedDefaultDacl, PreviousMode, TRUE);
            }
            return Status;
        }
        //
        // Free up the existing Default Dacl
        //

        SepFreeDefaultDacl( Token );

        //
        // And put the new ACL in its place
        //

        if (ARGUMENT_PRESENT(CapturedDefaultDacl)) {
            SepAppendDefaultDacl( Token, CapturedDefaultDacl );
        }

        TokenModified = TRUE;

        //
        // All done.
        //

        SepReleaseTokenWriteLock( Token, TokenModified );
        ObDereferenceObject( Token );
        if (ARGUMENT_PRESENT(CapturedDefaultDacl)) {
            SeReleaseAcl( CapturedDefaultDacl, PreviousMode, TRUE);
        }
        return STATUS_SUCCESS;

    case TokenSessionId:
    {
       ULONG SessionId;

        if ( TokenInformationLength != sizeof(ULONG) ) {
            ObDereferenceObject( Token );
            return( STATUS_INFO_LENGTH_MISMATCH );
        }

        try {

           SessionId = *(PULONG)TokenInformation;

        } except(EXCEPTION_EXECUTE_HANDLER) {
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        //
        // We only allow TCB to set SessionId's
        //
        if ( !SeSinglePrivilegeCheck(SeTcbPrivilege,PreviousMode) ) {
            ObDereferenceObject( Token );
            return( STATUS_PRIVILEGE_NOT_HELD );
        }

        //
        // Set SessionId for the token
        //
        SeSetSessionIdToken( (PACCESS_TOKEN)Token,
                             SessionId );

        ObDereferenceObject( Token );
        return( STATUS_SUCCESS );
    }

    case TokenSessionReference:
    {
        ULONG SessionReferenced;
        BOOLEAN DereferenceSession = FALSE;

        if ( TokenInformationLength != sizeof(ULONG) ) {
            ObDereferenceObject( Token );
            return( STATUS_INFO_LENGTH_MISMATCH );
        }

        try {

            SessionReferenced = *(PULONG)TokenInformation;

        } except(EXCEPTION_EXECUTE_HANDLER) {
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        //
        // We only allow TCB to set Session referenced.
        //
        if ( !SeSinglePrivilegeCheck(SeTcbPrivilege,PreviousMode) ) {
            ObDereferenceObject( Token );
            return( STATUS_PRIVILEGE_NOT_HELD );
        }

        //
        // We don't yet have use for this so don't implement it.
        //
        if ( SessionReferenced ) {
            ObDereferenceObject( Token );
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Determine if we're changing the state and change it with the write lock held
        //

        SepAcquireTokenWriteLock( Token );
        if ( (Token->TokenFlags & TOKEN_SESSION_NOT_REFERENCED) == 0 ) {

#if DBG || TOKEN_LEAK_MONITOR
            SepRemoveTokenLogonSession( Token );
#endif
            Token->TokenFlags |= TOKEN_SESSION_NOT_REFERENCED;
            DereferenceSession = TRUE;
        }
        SepReleaseTokenWriteLock( Token, FALSE );

        //
        // Do the actual dereference without any locks held
        //

        if ( DereferenceSession ) {
            SepDeReferenceLogonSessionDirect (Token->LogonSession);
        }

        ObDereferenceObject( Token );
        return( STATUS_SUCCESS );
    }

    case TokenAuditPolicy:
    {

        PTOKEN_AUDIT_POLICY         pAuditPolicy         = (PTOKEN_AUDIT_POLICY)TokenInformation;
        PTOKEN_AUDIT_POLICY         pCapturedAuditPolicy = NULL;
        PTOKEN_AUDIT_POLICY_ELEMENT pPolicyElement;
        SEP_AUDIT_POLICY            TokenPolicy;
        SEP_AUDIT_POLICY            OldTokenPolicy;
        ULONG                       i;

        if (pAuditPolicy == NULL) {

            ObDereferenceObject( Token );
            return STATUS_INVALID_PARAMETER;
        
        }

        //                      
        // We require TCB privilege to set AuditPolicy
        //

        if ( !SeSinglePrivilegeCheck(SeTcbPrivilege,PreviousMode) ) {
            
            ObDereferenceObject( Token );
            return( STATUS_PRIVILEGE_NOT_HELD );
        
        }

        //
        // If the policy was already set on this token then fail.  We only
        // allow setting a token's policy once.
        // 

        SepAcquireTokenReadLock( Token );
        OldTokenPolicy = Token->AuditPolicy;
        SepReleaseTokenReadLock( Token );

        if (OldTokenPolicy.PolicyOverlay.SetBit) {

            ObDereferenceObject( Token );
            return( STATUS_INVALID_PARAMETER );
        }

        //
        // Capture And Validate TOKEN_AUDIT_POLICY.
        //

        try {

            Status = SeCaptureAuditPolicy(
                         pAuditPolicy,
                         PreviousMode,
                         NULL, 
                         0,
                         PagedPool,
                         TRUE,
                         &pCapturedAuditPolicy
                         );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            ObDereferenceObject( Token );
            
            SeReleaseAuditPolicy(
                pCapturedAuditPolicy,
                PreviousMode,
                TRUE
                );

            return GetExceptionCode();
        }

        if (!NT_SUCCESS(Status)) {
            
            ObDereferenceObject( Token );
            return Status;

        }

        TokenPolicy.Overlay = 0;
        TokenPolicy.PolicyOverlay.SetBit = 1;

        if (pCapturedAuditPolicy->PolicyCount) {

            for (i = 0; i < pCapturedAuditPolicy->PolicyCount; i++) {
                
                pPolicyElement = &pCapturedAuditPolicy->Policy[i];

                switch (pPolicyElement->Category) {
                
                case AuditCategorySystem:
                    TokenPolicy.PolicyElements.System = pPolicyElement->PolicyMask;
                    break;

                case AuditCategoryLogon:
                    TokenPolicy.PolicyElements.Logon = pPolicyElement->PolicyMask;
                    break;
                
                case AuditCategoryObjectAccess:
                    TokenPolicy.PolicyElements.ObjectAccess = pPolicyElement->PolicyMask;
                    break;
                
                case AuditCategoryPrivilegeUse:
                    TokenPolicy.PolicyElements.PrivilegeUse = pPolicyElement->PolicyMask;
                    break;
                
                case AuditCategoryDetailedTracking:
                    TokenPolicy.PolicyElements.DetailedTracking = pPolicyElement->PolicyMask;
                    break;
                
                case AuditCategoryPolicyChange:
                    TokenPolicy.PolicyElements.PolicyChange = pPolicyElement->PolicyMask;
                    break;
                
                case AuditCategoryAccountManagement:
                    TokenPolicy.PolicyElements.AccountManagement = pPolicyElement->PolicyMask;
                    break;
                
                case AuditCategoryDirectoryServiceAccess:
                    TokenPolicy.PolicyElements.DirectoryServiceAccess = pPolicyElement->PolicyMask;
                    break;
                
                case AuditCategoryAccountLogon:
                    TokenPolicy.PolicyElements.AccountLogon = pPolicyElement->PolicyMask;
                    break;
                
                default:
                    ASSERT(FALSE && "Illegal audit category");
                    break;
                
                }
            }
        }
        
        SepAcquireTokenWriteLock( Token );
        OldTokenPolicy = Token->AuditPolicy;
        Token->AuditPolicy = TokenPolicy;
        SepReleaseTokenWriteLock( Token, TRUE );
        ObDereferenceObject( Token );
        
        if (TokenPolicy.Overlay) {
            SepModifyTokenPolicyCounter(&TokenPolicy, TRUE);
        }

        SeReleaseAuditPolicy(
            pCapturedAuditPolicy,
            PreviousMode,
            TRUE
            );

        return STATUS_SUCCESS;
    
    }
    case TokenOrigin:
    {
        TOKEN_ORIGIN Origin ;

        if ( TokenInformationLength != sizeof( TOKEN_ORIGIN ) ) {
            ObDereferenceObject( Token );
            return( STATUS_INFO_LENGTH_MISMATCH );
        }

        try {

            RtlCopyMemory(
                &Origin,
                TokenInformation,
                sizeof( TOKEN_ORIGIN ) );

        } except(EXCEPTION_EXECUTE_HANDLER) {
            ObDereferenceObject( Token );
            return GetExceptionCode();
        }

        //
        // We only allow TCB to set Origin information.
        //
        if ( !SeSinglePrivilegeCheck(SeTcbPrivilege,PreviousMode) ) {
            ObDereferenceObject( Token );
            return( STATUS_PRIVILEGE_NOT_HELD );
        }

        SepAcquireTokenWriteLock( Token );

        if ( RtlIsZeroLuid( &Token->OriginatingLogonSession ) )
        {
            Token->OriginatingLogonSession = Origin.OriginatingLogonSession ;
            
        }

        SepReleaseTokenWriteLock( Token, TRUE );

        ObDereferenceObject( Token );

        return( STATUS_SUCCESS );
    }

    } //endswitch

    ASSERT( TRUE == FALSE );  // Should never reach here.
    return( STATUS_INVALID_PARAMETER );

}


VOID
SepModifyTokenPolicyCounter(
    __in PSEP_AUDIT_POLICY TokenPolicy,
    __in BOOLEAN bIncrement
    )

/**

Routine Description:

    This modifies the global SepTokenPolicyCounter hint which records the number of
    tokens in the system with per user auditing settings.
    
Arguments:

    TokenPolicy - the policy which should be reflected in the hint.
    
    bIncrement - boolean indicating if this policy is being added (TRUE) or 
        deleted (FALSE) from the counters.
        
Return Value:

    None.
**/

{
    LONG increment;

    if (bIncrement) {
        increment = 1;
    } else {
        increment = -1;
    }

    if (TokenPolicy->PolicyElements.System) { 
        InterlockedExchangeAdd(&SepTokenPolicyCounter[AuditCategorySystem], increment);
        ASSERT(SepTokenPolicyCounter[AuditCategorySystem] >= 0);
    }
    if (TokenPolicy->PolicyElements.Logon) {
        InterlockedExchangeAdd(&SepTokenPolicyCounter[AuditCategoryLogon], increment);
        ASSERT(SepTokenPolicyCounter[AuditCategoryLogon] >= 0);
    }
    if (TokenPolicy->PolicyElements.ObjectAccess) {
        InterlockedExchangeAdd(&SepTokenPolicyCounter[AuditCategoryObjectAccess], increment);
        ASSERT(SepTokenPolicyCounter[AuditCategoryObjectAccess] >= 0);
    }
    if (TokenPolicy->PolicyElements.PrivilegeUse) {
        InterlockedExchangeAdd(&SepTokenPolicyCounter[AuditCategoryPrivilegeUse], increment);
        ASSERT(SepTokenPolicyCounter[AuditCategoryPrivilegeUse] >= 0);
    }
    if (TokenPolicy->PolicyElements.DetailedTracking) {
        InterlockedExchangeAdd(&SepTokenPolicyCounter[AuditCategoryDetailedTracking], increment);
        ASSERT(SepTokenPolicyCounter[AuditCategoryDetailedTracking] >= 0);
    }
    if (TokenPolicy->PolicyElements.PolicyChange) {
        InterlockedExchangeAdd(&SepTokenPolicyCounter[AuditCategoryPolicyChange], increment);
        ASSERT(SepTokenPolicyCounter[AuditCategoryPolicyChange] >= 0);
    }
    if (TokenPolicy->PolicyElements.AccountManagement) {
        InterlockedExchangeAdd(&SepTokenPolicyCounter[AuditCategoryAccountManagement], increment);
        ASSERT(SepTokenPolicyCounter[AuditCategoryAccountManagement] >= 0);
    }
    if (TokenPolicy->PolicyElements.DirectoryServiceAccess) {
        InterlockedExchangeAdd(&SepTokenPolicyCounter[AuditCategoryDirectoryServiceAccess], increment);
        ASSERT(SepTokenPolicyCounter[AuditCategoryDirectoryServiceAccess] >= 0);
    }
    if (TokenPolicy->PolicyElements.AccountLogon) {
        InterlockedExchangeAdd(&SepTokenPolicyCounter[AuditCategoryAccountLogon], increment);
        ASSERT(SepTokenPolicyCounter[AuditCategoryAccountLogon] >= 0);
    }
}


NTSTATUS
SepExpandDynamic(
    __in PTOKEN Token,
    __in ULONG NewLength
    )
/*++


Routine Description:

    This routines checks if the existing token dynamic buffer is 
    big enough for the new group/dacl. If it isn't then its reallocated.

Arguments:

    Token - Pointer to the token to expand. Locked for write access.

Return Value:

    NTSTATUS - Status of operation

--*/
{
    ULONG CurrentSize;
    PVOID NewDynamic, OldDynamic;

    //
    //  Work out how big it is now
    //
    CurrentSize = SeLengthSid( Token->PrimaryGroup ) + Token->DynamicAvailable;
    if (Token->DefaultDacl) {
        CurrentSize += Token->DefaultDacl->AclSize;
    }
    if (NewLength <= CurrentSize) {
        return STATUS_SUCCESS;
    }

    NewDynamic = ExAllocatePoolWithTag (PagedPool,
                                        NewLength,
                                        'dTeS');
    if (NewDynamic == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    OldDynamic = Token->DynamicPart;

    RtlCopyMemory (NewDynamic, OldDynamic, CurrentSize);

    Token->DynamicPart = NewDynamic;
    Token->DynamicAvailable += NewLength - CurrentSize;

    //
    // Relocate the pointers within the new buffer
    //
    if (Token->DefaultDacl) {
        Token->DefaultDacl = (PACL) ((PUCHAR) NewDynamic + ((PUCHAR) Token->DefaultDacl - (PUCHAR) OldDynamic));
    }
    Token->PrimaryGroup = (PSID) ((PUCHAR) NewDynamic + ((PUCHAR) Token->PrimaryGroup - (PUCHAR) OldDynamic));

    ExFreePool (OldDynamic);

    return STATUS_SUCCESS;
}


VOID
SepFreePrimaryGroup(
    __in PTOKEN Token
    )

/*++


Routine Description:

    Free up the space in the dynamic part of the token take up by the primary
    group.

    The token is assumed to be locked for write access before calling
    this routine.

Arguments:

    Token - Pointer to the token.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // Add the size of the primary group to the DynamicAvailable field.
    //

    Token->DynamicAvailable += SeLengthSid( Token->PrimaryGroup );

    //
    // If there is a default discretionary ACL, and it is not already at the
    // beginning of the dynamic part, move it there (remember to update the
    // pointer to it).
    //

    if (ARGUMENT_PRESENT(Token->DefaultDacl)) {
        if (Token->DynamicPart != (PULONG)(Token->DefaultDacl)) {

            RtlMoveMemory(
                (PVOID)(Token->DynamicPart),
                (PVOID)(Token->DefaultDacl),
                Token->DefaultDacl->AclSize
                );

            Token->DefaultDacl = (PACL)(Token->DynamicPart);

        }
    }

    return;

}


VOID
SepFreeDefaultDacl(
    __in PTOKEN Token
    )

/*++


Routine Description:

    Free up the space in the dynamic part of the token take up by the default
    discretionary access control list.

    The token is assumed to be locked for write access before calling
    this routine.

Arguments:

    Token - Pointer to the token.

Return Value:

    None.

--*/
{
   ULONG PrimaryGroupSize;

   PAGED_CODE();

    //
    // Add the size of the Default Dacl (if there is one) to the
    // DynamicAvailable field.
    //
    if (ARGUMENT_PRESENT(Token->DefaultDacl)) {

        Token->DynamicAvailable += Token->DefaultDacl->AclSize;
        Token->DefaultDacl = NULL;

    }

    //
    // If it is not already at the beginning of the dynamic part, move
    // the primary group there (remember to update the pointer to it).
    //

    if (Token->DynamicPart != (PULONG)(Token->PrimaryGroup)) {

        PrimaryGroupSize = SeLengthSid( Token->PrimaryGroup );

        RtlMoveMemory(
            (PVOID)(Token->DynamicPart),
            (PVOID)(Token->PrimaryGroup),
            PrimaryGroupSize
            );

        Token->PrimaryGroup = (PSID)(Token->DynamicPart);
    }

    return;
}


VOID
SepAppendPrimaryGroup(
    __in PTOKEN Token,
    __in PSID PSid
    )

/*++


Routine Description:

    Add a primary group SID to the available space at the end of the dynamic
    part of the token.  It is the caller's responsibility to ensure that the
    primary group SID fits within the available space of the dynamic part of
    the token.

    The token is assumed to be locked for write access before calling
    this routine.

Arguments:

    Token - Pointer to the token.

    PSid - Pointer to the SID to add.

Return Value:

    None.

--*/
{
   ULONG_PTR NextFree;
   ULONG SidSize;

   PAGED_CODE();

    //
    // Add the size of the Default Dacl (if there is one) to the
    // address of the Dynamic Part of the token to establish
    // where the primary group should be placed.
    //

    if (ARGUMENT_PRESENT(Token->DefaultDacl)) {

        NextFree = (ULONG_PTR)(Token->DynamicPart) + Token->DefaultDacl->AclSize;

    } else {

        NextFree = (ULONG_PTR)(Token->DynamicPart);

    }

    //
    // Now copy the primary group SID.
    //


    SidSize = SeLengthSid( PSid );

    RtlCopyMemory(
        (PVOID)NextFree,
        (PVOID)PSid,
        SidSize
        );

    Token->PrimaryGroup = (PSID)NextFree;

    //
    // And decrement the amount of the dynamic part that is available.
    //

    ASSERT( SidSize <= (Token->DynamicAvailable) );
    Token->DynamicAvailable -= SidSize;

    return;

}

VOID
SepAppendDefaultDacl(
    __in PTOKEN Token,
    __in PACL PAcl
    )

/*++


Routine Description:

    Add a default discretionary ACL to the available space at the end of the
    dynamic part of the token.  It is the caller's responsibility to ensure
    that the default Dacl fits within the available space of the dynamic
    part of the token.

    The token is assumed to be locked for write access before calling
    this routine.

Arguments:

    Token - Pointer to the token.

    PAcl - Pointer to the ACL to add.

Return Value:

    None.

--*/
{
   ULONG_PTR NextFree;
   ULONG AclSize;

   PAGED_CODE();

    //
    // Add the size of the primary group to the
    // address of the Dynamic Part of the token to establish
    // where the primary group should be placed.
    //

    ASSERT(ARGUMENT_PRESENT(Token->PrimaryGroup));

    NextFree = (ULONG_PTR)(Token->DynamicPart) + SeLengthSid(Token->PrimaryGroup);

    //
    // Now copy the default Dacl
    //

    AclSize = (ULONG)(PAcl->AclSize);

    RtlCopyMemory(
        (PVOID)NextFree,
        (PVOID)PAcl,
        AclSize
        );

    Token->DefaultDacl = (PACL)NextFree;

    //
    // And decrement the amount of the dynamic part that is available.
    //

    ASSERT( AclSize <= (Token->DynamicAvailable) );
    Token->DynamicAvailable -= AclSize;

    return;

}


NTSTATUS
SeSetSessionIdToken(
    __in PACCESS_TOKEN Token,
    __in ULONG SessionId
    )
/*++


Routine Description:

    Sets the SessionId for the specified token object.

Arguments:

    pOpaqueToken (input)
      Opaque kernel Token access pointer

    SessionId (input)
      SessionId to store in token

Return Value:

    STATUS_SUCCESS - no error

--*/
{

   PAGED_CODE();

   //
   //  Gain write access to the token.
   //

   SepAcquireTokenWriteLock( ((PTOKEN)Token) );

   ((PTOKEN)Token)->SessionId = SessionId;

   SepReleaseTokenWriteLock( ((PTOKEN)Token), FALSE );

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfddi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfddi.h

Abstract:

    This header contains prototypes for verifier device driver interfaces.

--*/

VOID
VfDdiInit(
    VOID
    );

VOID
VfDdiExposeWmiObjects(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfbugcheck.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfbugcheck.h

Abstract:

    This header defines the prototypes and constants required for verifier
    bugchecks.

--*/

#ifndef _VFBUGCHECK_H_
#define _VFBUGCHECK_H_

extern LONG         IovpInitCalled;

#define KDASSERT(x) { if (KdDebuggerEnabled) { ASSERT(x) ; } }

#define ASSERT_SPINLOCK_HELD(x)

#define DCPARAM_ROUTINE         0x00000001
#define DCPARAM_IRP             0x00000008
#define DCPARAM_IRPSNAP         0x00000040
#define DCPARAM_DEVOBJ          0x00000200
#define DCPARAM_STATUS          0x00001000
#define DCPARAM_ULONG           0x00008000
#define DCPARAM_PVOID           0x00040000

#define WDM_FAIL_ROUTINE(ParenWrappedParamList) \
{ \
    if (IovpInitCalled) { \
        VfBugcheckThrowIoException##ParenWrappedParamList;\
    } \
}

VOID
FASTCALL
VfBugcheckInit(
    VOID
    );

NTSTATUS
VfBugcheckThrowIoException(
    IN DCERROR_ID           MessageIndex,
    IN ULONG                MessageParameterMask,
    ...
    );

NTSTATUS
VfBugcheckThrowException(
    IN PVFMESSAGE_TEMPLATE_TABLE    MessageTable        OPTIONAL,
    IN VFMESSAGE_ERRORID            MessageID,
    IN PCSTR                        MessageParamFormat,
    IN va_list *                    MessageParameters
    );

#endif // _VFBUGCHECK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfdebug.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfdebug.h

Abstract:

    This header contains debugging macros used by the driver verifier code.

--*/

extern ULONG VfSpewLevel;

#if DBG
#define VERIFIER_DBGPRINT(txt,level) \
{ \
    if (VfSpewLevel>(level)) { \
        DbgPrint##txt; \
    }\
}
#else
#define VERIFIER_DBGPRINT(txt,level)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\halverifier.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

   halverifier.c

Abstract:

    This module contains the routines to verify hal usage & apis.

--*/

#ifndef _HAL_VERIFIER_
#define _HAL_VERIFIER_

VOID
VfHalVerifierInitialize(
    VOID
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VDM\i386\vdm.inc ===
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
;  Module Name:
;
;     vdm.inc
;
;  Abstract:
;
;     This module contains the structure and constant definitions for
;     the vdm component
;--
.386p

TRUE                    equ 1
FALSE                   equ 0

;
; Macro's to only do locked memory operations on MP systems
;

IFDEF NT_UP
MPLOCK equ <>
ELSE
MPLOCK equ <lock>
ENDIF

        page , 132
        subttl "Macro to dispatch exception"

;++
;
; Macro Description:
;
;    This macro allocates exception record on stack, sets up exception
;    record using specified parameters and finally sets up arguments
;    and calls _KiDispatchException.
;
; Arguments:
;
;    ExcepCode - Exception code to put into exception record
;    ExceptFlags - Exception flags to put into exception record
;    ExceptRecord - Associated exception record
;    ExceptAddress - Addr of instruction which the hardware exception occurs
;    NumParms - Number of additional parameters
;    ParameterList - the additional parameter list
;
; Return Value:
;
;    None.
;
;--

DISPATCH_EXCEPTION macro ExceptCode, ExceptFlags, ExceptRecord, ExceptAddress,\
                         NumParms, ParameterList
        local de10, de20

; Set up exception record for raising exception

?i      =       0
        sub     esp, ExceptionRecordSize + NumParms * 4
                                        ; allocate exception record
        mov     dword ptr [esp]+ErExceptionCode, ExceptCode
                                        ; set up exception code
        mov     dword ptr [esp]+ErExceptionFlags, ExceptFlags
                                        ; set exception flags
        mov     dword ptr [esp]+ErExceptionRecord, ExceptRecord
                                        ; set associated exception record
        mov     dword ptr [esp]+ErExceptionAddress, ExceptAddress
        mov     dword ptr [esp]+ErNumberParameters, NumParms
                                        ; set number of parameters
        IRP     z, <ParameterList>
        mov     dword ptr [esp]+(ErExceptionInformation+?i*4), z
?i      =       ?i + 1
        ENDM

; set up arguments and call _KiDispatchException

        mov     ecx, esp                ; (ecx)->exception record

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jz      de10

        mov     eax,0FFFFh
        jmp     de20

de10:   mov     eax,[ebp]+TsSegCs
de20:   and     eax,MODE_MASK

; 1 - set first chance TRUE
; eax - PreviousMode
; ebp - trap frame addr
; 0 - Null exception frame
; ecx - exception record addr

; dispatchexception as appropriate
        stdCall _KiDispatchException, <ecx, 0, ebp, eax, 1>
        add     esp,ExceptionRecordSize + NumParms*4

        ENDM


;
; Prefix Flags
;

PREFIX_ES               equ 00000100h
PREFIX_CS               equ 00000200h
PREFIX_SS               equ 00000400h
PREFIX_DS               equ 00000800h
PREFIX_FS               equ 00001000h
PREFIX_GS               equ 00002000h
PREFIX_OPER32           equ 00004000h
PREFIX_ADDR32           equ 00008000h
PREFIX_LOCK             equ 00010000h
PREFIX_REPNE            equ 00020000h
PREFIX_REP              equ 00040000h
PREFIX_SEG_ALL          equ 00003f00h

NUM_OPCODE              equ 255
;
; Reginfo structure
;

RegInfo struc
RiSegSs         dd 0
RiEsp           dd 0
RiEFlags        dd 0
RiSegCs         dd 0
RiEip           dd 0
RiTrapFrame     dd 0
RiCsLimit       dd 0
RiCsBase        dd 0
RiCsFlags       dd 0
RiSsLimit       dd 0
RiSsBase        dd 0
RiSsFlags       dd 0
RiPrefixFlags   dd 0
RiOperand       dd 0
RegInfo ends
REGINFOSIZE     EQU 56

MAX_VDM_ADDR    EQU 0FFFFFFH

DR7_GLOBAL      EQU 002AAH

;
;Fast Read/Write Defines
;

SVC_DEMFASTREAD     equ 42h
SVC_DEMFASTWRITE    equ 43h
DOS_BOP             equ 50h

;
;
; Size of Exception Record
;

ExceptionRecordSize = (ErNumberParameters + 4 + 3) AND 0fffffffcH ;

;
; Magic value
;

OPCODE_MAGIC    equ  00f5ah

;++
;       diBEGIN - BEGIN index table
;
;       ENTRY   name = name of di table
;               badindex = local label for unspecified entries
;
;       EXIT    ?sindex = specific entry index
;               ?badindex = default index for unspecified entries
;--

diBEGIN macro   name,badindex           ;; Beginning of dispatch table
        ?sopc  = 0
        ?badindex = badindex
name    label   byte                    ;; Start of dispatch table
endm

;++
;       dtI - SPECIFIC index table entry
;
;       ENTRY   opc = opcode value
;               index  = INDEX_ value corresponding to opcode
;               ?badindex = unspecified entry index
;               ?sopc = specific entry index
;
;       EXIT    Unspecified entries prior to "index" filled in;
;               Specified entry filled in.
;               ?sopc = next index to fill in;
;--

dtI     macro   opc,index               ;; Specific entry in dispatch table
        if ?sopc gt opc
            %out dtI: opcode out of order
            .err
        else
            if ?sopc lt opc             ;; Fill unspecified entries
                rept opc - ?sopc
                   db   ?badindex
                endm
            endif
            db    index                 ;; Specified entry
            ?sopc = opc+1               ;; Set new start index
        endif
endm

;++
;       diEND - END index table
;
;       ENTRY   index = highest entry in table
;               ?sopc = specific entry index
;
;       EXIT    rest of the table filled in
;--

diEND   macro   index                   ;; End of dispatch table
        if ?sopc lt index               ;; Fill in rest of table
            rept index - ?sopc
                db    ?badindex
            endm
        db      ?badindex               ;; fill in last entry of table!
        endif
endm


;++
;       dtBEGIN - BEGIN dispatch table
;
;       ENTRY   name = name of dt table
;               badaddr = local label for unspecified entries
;
;       EXIT    ?sindex = specific entry index
;               ?badaddr = default handler for unspecified entries
;--

dtBEGIN macro   name,badaddr            ;; Beginning of dispatch table
        ?sindex  = 0
        ?badaddr = badaddr
name    label   dword                   ;; Start of dispatch table
endm

;++
;       dtS - SPECIFIC dispatch table entry
;
;       ENTRY   index = index of entry
;               addr  = address of handler
;               ?badaddr = unspecified entry handler
;               ?sindex = specific entry index
;
;       EXIT    Unspecified entries prior to "index" filled in;
;               Specified entry filled in.
;               ?sindex = next index to fill in;
;--

dtS     macro   index,addr              ;; Specific entry in dispatch table
        if ?sindex gt index
            %out dtS: index out of order
            .err
        else
            if ?sindex lt index         ;; Fill unspecified entries
                rept index - ?sindex
                   dd   offset FLAT:?badaddr
                endm
            endif
            dd    offset FLAT:addr      ;; Specified entry
            ?sindex = index+1           ;; Set new start index
        endif
endm

;++
;       dtEND - END dispatch table
;
;       ENTRY   index = highest entry in table
;               ?sindex = specific entry index
;
;       EXIT    rest of the table filled in
;--

dtEND   macro   index                   ;; End of dispatch table
        if ?sindex lt index             ;; Fill in rest of table
            rept index - ?sindex
                dd    offset FLAT:?badaddr
            endm
        dd offset FLAT:?badaddr         ;; fill in last entry of table!
        endif
endm

;++
;       CsToLinearPM
;
;--

CsToLinearPM    macro sel, erraddr
        lea     eax,[esi].RiCsLimit
        push    eax
        lea     eax,[esi].RiCsBase
        push    eax
        lea     eax,[esi].RiCsFlags
        push    eax
        push    sel

        call    _Ki386GetSelectorParameters@16
        or      al,al
        jz      erraddr

        test    [esi].RiCsFlags,SEL_TYPE_EXECUTE
        jz      erraddr

        test    [esi].RiCsFlags,SEL_TYPE_2GIG
        jz      @f

        ; Correct limit value for granularity
        shl     [esi].RiCsLimit,12
        or      [esi].RiCsLimit,0FFFh
@@:
endm

;++
;       CsToLinearV86
;
;--

CsToLinearV86 macro
        movzx   eax,word ptr [esi].RiSegCs
        shl     eax,4
	mov	[esi].RiCsBase,eax
        mov     [esi].RiCsLimit,0FFFFh
        mov     [esi].RiCsFlags,0
endm
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfdef.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfdef.h

Abstract:

    This header collects together the various files necessary to create a basic
    set of definitions for the verifier.

--*/

//
// Disable W4 level warnings generated by public headers.
//

#include "vfpragma.h"

#include "ntos.h"
#include "vfdebug.h"
#include "vfmacro.h"
#include "vfinit.h"
#include "vfsettings.h"
#include "vfmessage.h"
#include "vfbugcheck.h"
#include "vfprint.h"
#include "vfutil.h"
#include "vfstack.h"
#include "vftriage.h"
#include "vfirp.h"
#include "vfirpdb.h"
#include "vfirplog.h"
#include "vfdevobj.h"
#include "vfpacket.h"
#include "halverifier.h"
#include "vfdeadlock.h"

#include "..\io\trackirp.h"
#include "..\io\sessnirp.h"

#include "..\ob\obvutil.h"
#include "..\io\iovutil.h"
#include "..\io\pnpmgr\ppvutil.h"

#include "vffilter.h"
#include "vfmajor.h"
#include "vfpnp.h"
#include "vfpower.h"
#include "vfwmi.h"
#include "vfgeneric.h"
#include "vfrandom.h"
#include "vfddi.h"
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfdeadlock.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

   vfdeadlock.h

Abstract:

    Detect deadlocks in arbitrary synchronization objects.

--*/

#ifndef _VF_DEADLOCK_
#define _VF_DEADLOCK_

//
// Deadlock detection package initialization.
//

VOID 
VfDeadlockDetectionInitialize(
    );

//
// Functions called from IovCallDriver (driver verifier replacement for
// IoCallDriver) just before and after the real call to the driver is made.
//

BOOLEAN
VfDeadlockBeforeCallDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

VOID
VfDeadlockAfterCallDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN BOOLEAN PagingIrp
    );

//
// Maximum depth of stack traces captured.
//

#define VI_MAX_STACK_DEPTH 8

#define NO_OF_DEADLOCK_PARTICIPANTS 32

//
// VI_DEADLOCK_NODE
//

typedef struct _VI_DEADLOCK_NODE {

    //
    // Node representing the acquisition of the previous resource.
    //

    struct _VI_DEADLOCK_NODE * Parent;

    //
    // Node representing the next resource acquisitions, that are
    // done after acquisition of the current resource.
    //

    struct _LIST_ENTRY ChildrenList;

    //
    // Field used to chain siblings in the tree. A parent node has the
    // ChildrenList field as the head of the children list that is chained
    // with the Siblings field.
    //

    struct _LIST_ENTRY SiblingsList;

    union {
        
        //
        // List of nodes representing the same resource acquisition
        // as the current node but in different contexts (lock combinations).
        //

        struct _LIST_ENTRY ResourceList;

        //
        // Used to chain free nodes. This is used only after the node has
        // been deleted (resource was freed). Nodes are kept in a cache
        // to reduce contention for the kernel pool.
        //
        
        struct _LIST_ENTRY FreeListEntry;
    };

    //
    // Back pointer to the descriptor for this resource.
    //

    struct _VI_DEADLOCK_RESOURCE * Root;

    //
    // When we find a deadlock, we keep this info around in order to
    // be able to identify the parties involved who have caused
    // the deadlock.
    //

    struct _VI_DEADLOCK_THREAD * ThreadEntry;

    //
    // Fields used for decision making within the deadlock analysis 
    // algorithm.
    //
    // Active: 1 if the node represents a resource currently acquired,
    //     0 if resource was acquired in the past.
    //
    // OnlyTryAcquiredUsed: 1 if resource was always acquired with TryAcquire.
    //     0 if at least once normal acquire was used. A node that uses
    //     only TryAcquire cannot be involved in a deadlock.
    //
    // ReleasedOutOfOrder: 1 if the resource was at least once released 
    //     out of order. The flag is used while looking for cycles because
    //     this type of nodes will appear as part of the cycle but there is
    //     no deadlock.
    //
    // SequenceNumber: field that gets a unique stamp during each deadlock
    //     analysis run. It helps figure out if the node was touched 
    //     already in the current graph traversal.
    //

    struct {

        ULONG Active : 1;
        ULONG OnlyTryAcquireUsed : 1;         
        ULONG ReleasedOutOfOrder : 1;
        ULONG SequenceNumber : 29;
    };

    //
    // Stack traces for the resource acquisition moment.
    // Used when displaying deadlock proofs. On free builds
    // anything other than the first entry (return address)
    // may be bogus in case stack trace capturing failed.
    //
   
    PVOID StackTrace[VI_MAX_STACK_DEPTH];
    PVOID ParentStackTrace[VI_MAX_STACK_DEPTH];

} VI_DEADLOCK_NODE, *PVI_DEADLOCK_NODE;

//
// VI_DEADLOCK_RESOURCE
//

typedef struct _VI_DEADLOCK_RESOURCE {

    //
    // Resource type (mutex, spinlock, etc.).
    //

    VI_DEADLOCK_RESOURCE_TYPE Type;

    //
    // Resource flags
    //    
    // NodeCount : number of resource nodes created for this resource.
    //
    // RecursionCount : number of times this resource has been recursively acquired 
    //     It makes sense to put this counter in the resource because as long as
    //     resource is acquired only one thread can operate on it.
    //

    struct {       
        ULONG NodeCount : 16;
        ULONG RecursionCount : 16;
    };

    //
    // The address of the synchronization object used by the kernel.
    //

    PVOID ResourceAddress;

    //
    // The thread that currently owns the resource. The field is
    // null if nobody owns the resource.
    //
    
    struct _VI_DEADLOCK_THREAD * ThreadOwner;

    //
    // List of resource nodes representing acquisitions of this resource.
    //

    LIST_ENTRY ResourceList;

    union {

        //
        // List used for chaining resources from a hash bucket.
        //
        
        LIST_ENTRY HashChainList;
        
        //
        // Used to chain free resources. This list is used only after
        // the resource has been freed and we put the structure
        // into a cache to reduce kernel pool contention.
        //

        LIST_ENTRY FreeListEntry;
    };

    //
    // Stack trace of the resource creator. On free builds we
    // may have here only a return address that is bubbled up
    // from verifier thunks. 
    //
  
    PVOID StackTrace [VI_MAX_STACK_DEPTH];
    
    //
    // Stack trace for last acquire
    //

    PVOID LastAcquireTrace [VI_MAX_STACK_DEPTH];
    
    //
    // Stack trace for last release
    //

    PVOID LastReleaseTrace [VI_MAX_STACK_DEPTH];

} VI_DEADLOCK_RESOURCE, * PVI_DEADLOCK_RESOURCE;

//
// VI_DEADLOCK_THREAD
//

typedef struct _VI_DEADLOCK_THREAD {

    //
    // Kernel thread address
    //

    PKTHREAD Thread;

    //
    // The node representing the last resource acquisition made by
    // this thread.
    //

    //
    // We have separate graph branches for spinlocks and other types
    // of locks (fast mutex, mutex). The thread keeps a list of both types
    // so that we can properly release locks
    //

    PVI_DEADLOCK_NODE CurrentSpinNode;
    PVI_DEADLOCK_NODE CurrentOtherNode;

    union {

        //
        // Thread list. It is used for chaining into a hash bucket.
        //
        
        LIST_ENTRY ListEntry;

        //
        // Used to chain free nodes. The list is used only after we decide
        // to delete the thread structure (possibly because it does not
        // hold resources anymore). Keeping the structures in a cache
        // reduces pool contention.
        //

        LIST_ENTRY FreeListEntry;
    };

    //
    // Count of resources currently acquired by a thread. When this becomes
    // zero the thread will be destroyed. The count goes up during acquire
    // and down during release.
    //

    ULONG NodeCount;

    //
    // This counter is used to count how many IoCallDriver() calls with
    // paging IRPs are active for this thread. This information is necessary
    // to decide if we should temporarily disable deadlock verification
    // to avoid known lack of lock hierarchy issues in file system drivers.
    //

    ULONG PagingCount;

} VI_DEADLOCK_THREAD, *PVI_DEADLOCK_THREAD;

//
// Deadlock verifier globals
//

typedef struct _VI_DEADLOCK_GLOBALS {

    //
    // Structure counters: [0] - current, [1] - maximum
    //

    ULONG Nodes[2];
    ULONG Resources[2];
    ULONG Threads[2];

    //
    // Maximum times for Acquire() and Release() in ticks.
    //

    LONGLONG TimeAcquire;
    LONGLONG TimeRelease;

    //
    // Total number of kernel pool bytes used by the deadlock verifier
    //
    
    SIZE_T BytesAllocated;

    //
    // Resource and thread collection.
    //

    PLIST_ENTRY ResourceDatabase;
    PLIST_ENTRY ThreadDatabase;   
    
    //
    // How many times ExAllocatePool failed on us?
    // If this is >0 we stop deadlock verification.
    //

    ULONG AllocationFailures;

    //
    // How many nodes have been trimmed when we decided to forget
    // partially the history of some resources.
    //

    ULONG NodesTrimmedBasedOnAge;
    ULONG NodesTrimmedBasedOnCount;

    //
    // Deadlock analysis statistics
    //

    ULONG NodesSearched;
    ULONG MaxNodesSearched;
    ULONG SequenceNumber;

    ULONG RecursionDepthLimit;
    ULONG SearchedNodesLimit;

    ULONG DepthLimitHits;
    ULONG SearchLimitHits;

    //
    // Number of times we have to exhonerate a deadlock because
    // it was protected by a common resource (e.g. thread 1 takes ABC, 
    // thread 2 takes ACB -- this will get flagged initially by our algorithm 
    // since B&C are taken out of order but is not actually a deadlock.
    //
    
    ULONG ABC_ACB_Skipped;

    ULONG OutOfOrderReleases;
    ULONG NodesReleasedOutOfOrder;

#if DBG
    //
    // How many locks are held simultaneously while the system is running?
    //

    ULONG NodeLevelCounter[8];
    ULONG GraphNodes[8];
#endif
    
    ULONG TotalReleases;
    ULONG RootNodesDeleted;

    //
    // Used to control how often we delete portions of the dependency
    // graph.
    //

    ULONG ForgetHistoryCounter;

    //
    // How often was a worker items dispatched to trim the
    // pool cache.
    //

    ULONG PoolTrimCounter;
    
    //
    // Caches of freed structures (thread, resource, node) used to
    // decrease kernel pool contention.
    //

    LIST_ENTRY FreeResourceList;    
    LIST_ENTRY FreeThreadList;
    LIST_ENTRY FreeNodeList;

    ULONG FreeResourceCount;
    ULONG FreeThreadCount;
    ULONG FreeNodeCount;   

    //
    // Resource address that caused the deadlock
    //

    PVOID Instigator;

    //
    // Number of participants in the deadlock
    //

    ULONG NumberOfParticipants;

    //
    // List of the nodes that participate in the deadlock
    //

    PVI_DEADLOCK_NODE Participant [NO_OF_DEADLOCK_PARTICIPANTS];

    LOGICAL CacheReductionInProgress;
} VI_DEADLOCK_GLOBALS, *PVI_DEADLOCK_GLOBALS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfgeneric.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfgeneric.h

Abstract:

    This header contains prototypes for verifying generic IRPs are handled
    correctly.

--*/

VOID
VfGenericInit(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vffilter.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vffilter.h

Abstract:

    This header contains prototypes for using the verifier driver filter.

--*/

VOID
VfFilterInit(
    VOID
    );

VOID
VfFilterAttach(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject,
    IN  VF_DEVOBJ_TYPE  DeviceObjectType
    );

BOOLEAN
VfFilterIsVerifierFilterObject(
    IN  PDEVICE_OBJECT  DeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfdevobj.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfdevobj.h

Abstract:

    This header exposes function hooks that verify drivers properly manage
    device objects.

--*/

typedef enum {

    VF_DEVOBJ_PDO = 0,
    VF_DEVOBJ_BUS_FILTER,
    VF_DEVOBJ_LOWER_DEVICE_FILTER,
    VF_DEVOBJ_LOWER_CLASS_FILTER,
    VF_DEVOBJ_FDO,
    VF_DEVOBJ_UPPER_DEVICE_FILTER,
    VF_DEVOBJ_UPPER_CLASS_FILTER

} VF_DEVOBJ_TYPE, *PVF_DEVOBJ_TYPE;

VOID
VfDevObjPreAddDevice(
    IN  PDEVICE_OBJECT      PhysicalDeviceObject,
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDRIVER_ADD_DEVICE  AddDeviceFunction,
    IN  VF_DEVOBJ_TYPE      DevObjType
    );

VOID
VfDevObjPostAddDevice(
    IN  PDEVICE_OBJECT      PhysicalDeviceObject,
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDRIVER_ADD_DEVICE  AddDeviceFunction,
    IN  VF_DEVOBJ_TYPE      DevObjType,
    IN  NTSTATUS            Result
    );

VOID
VfDevObjAdjustFdoForVerifierFilters(
    IN OUT  PDEVICE_OBJECT *FunctionalDeviceObject
    );

VOID
VerifierIoAttachDeviceToDeviceStack(
    IN PDEVICE_OBJECT NewDevice,
    IN PDEVICE_OBJECT ExistingDevice
    );

VOID
VerifierIoDetachDevice(
    IN PDEVICE_OBJECT LowerDevice
    );

VOID
VerifierIoDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfirp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfirp.h

Abstract:

    This module contains prototypes for functions used to manage IRPs used in
    the verification process.

--*/

struct _IOV_STACK_LOCATION;
struct _IOV_REQUEST_PACKET;
struct _IOFCALLDRIVER_STACKDATA;

typedef struct _IOV_STACK_LOCATION         *PIOV_STACK_LOCATION;
typedef struct _IOV_REQUEST_PACKET         *PIOV_REQUEST_PACKET;
typedef struct _IOV_SESSION_DATA           *PIOV_SESSION_DATA;
typedef struct _IOFCALLDRIVER_STACKDATA    *PIOFCALLDRIVER_STACKDATA;

//
// Mini-snapshots of the IRP are stored on the stack for cases when the
// verifier needs to inform the developer as to the mistake, but no longer
// has the original IRP in memory. Because these may be stored on the stack,
// they need to be small and light.
//
typedef struct _IRP_MINI_SNAPSHOT {

    PIRP                Irp;
    IO_STACK_LOCATION   IoStackLocation;

} IRP_MINI_SNAPSHOT, *PIRP_MINI_SNAPSHOT;

typedef struct _IOV_STACK_LOCATION {

    BOOLEAN                 InUse;
    ULONG                   Flags;
    PIOV_STACK_LOCATION     RequestsFirstStackLocation;
    LIST_ENTRY              CallStackData;
    PIO_STACK_LOCATION      IrpSp;
    PVOID                   LastDispatch;
    LARGE_INTEGER           PerfDispatchStart;
    LARGE_INTEGER           PerfStackLocationStart;
    PDEVICE_OBJECT          ReferencingObject;
    LONG                    ReferencingCount;
    IO_STATUS_BLOCK         InitialStatusBlock;
    IO_STATUS_BLOCK         LastStatusBlock;
    PETHREAD                ThreadDispatchedTo;

} IOV_STACK_LOCATION;

typedef struct _IOV_SESSION_DATA {

   PIOV_REQUEST_PACKET          IovRequestPacket;
   LONG                         SessionRefCount;
   LIST_ENTRY                   SessionLink;
   ULONG                        SessionFlags;

   PETHREAD                     OriginatorThread;
   PDEVICE_OBJECT               DeviceLastCalled; // Last device called
   ULONG                        ForwardMethod;
   PIRP                         BestVisibleIrp;
   PVERIFIER_SETTINGS_SNAPSHOT  VerifierSettings;
   IOV_STACK_LOCATION           StackData[ANYSIZE_ARRAY];

} IOV_SESSION_DATA;

typedef struct _IOFCALLDRIVER_STACKDATA {

    PIOV_SESSION_DATA   IovSessionData;
    PIOV_STACK_LOCATION IovStackLocation;
    PIOV_REQUEST_PACKET IovPacket;
    ULONG               Flags;
    LIST_ENTRY          SharedLocationList;
    PDRIVER_DISPATCH    DispatchRoutine;
    NTSTATUS            ExpectedStatus;
    NTSTATUS            NewStatus;
    PDEVICE_OBJECT      RemovePdo;
    IRP_MINI_SNAPSHOT   IrpSnapshot;

} IOFCALLDRIVER_STACKDATA;

typedef struct _IOFCOMPLETEREQUEST_STACKDATA {

    PIOV_SESSION_DATA       IovSessionData;
    PIOV_REQUEST_PACKET     IovRequestPacket;
    BOOLEAN                 IsRemoveIrp;
    LONG                    LocationsAdvanced;
    ULONG                   RaisedCount;
    KIRQL                   PreviousIrql;
    PVOID                   CompletionRoutine;

} IOFCOMPLETEREQUEST_STACKDATA, *PIOFCOMPLETEREQUEST_STACKDATA;

VOID
FASTCALL
VfIrpInit(
    VOID
    );

PIRP
FASTCALL
VfIrpAllocate(
    IN CCHAR    StackSize
    );

VOID
FASTCALL
VfIrpMakeTouchable(
    IN  PIRP  Irp
    );

VOID
FASTCALL
VfIrpMakeUntouchable(
    IN  PIRP    Irp OPTIONAL
    );

VOID
FASTCALL
VfIrpFree(
    IN  PIRP   Irp OPTIONAL
    );

VOID
FASTCALL
VerifierIoAllocateIrp1(
    IN     CCHAR              StackSize,
    IN     BOOLEAN            ChargeQuota,
    IN OUT PIRP               *IrpPointer
    );

VOID
FASTCALL
VerifierIoAllocateIrp2(
    IN     PIRP               Irp
    );

VOID
FASTCALL
VerifierIoFreeIrp(
    IN     PIRP               Irp,
    IN OUT PBOOLEAN           FreeHandled
    );

VOID
FASTCALL
VerifierIoInitializeIrp(
    IN OUT PIRP               Irp,
    IN     USHORT             PacketSize,
    IN     CCHAR              StackSize,
    IN OUT PBOOLEAN           InitializeHandled
    );

BOOLEAN
FASTCALL
VfIrpReserveCallStackData(
    IN  PIRP                            Irp,
    OUT PIOFCALLDRIVER_STACKDATA       *IofCallDriverStackData
    );

VOID
FASTCALL
VfIrpPrepareAllocaCallStackData(
    OUT PIOFCALLDRIVER_STACKDATA        IofCallDriverStackData
    );

VOID
FASTCALL
VfIrpReleaseCallStackData(
    IN  PIOFCALLDRIVER_STACKDATA        IofCallDriverStackData  OPTIONAL
    );

//
// VfIrpCallDriverPreprocess is a macro function that may do an alloca as
// part of it's operation. As such callers must be careful not to use
// variable length arrays in a scope that encompasses
// VfIrpCallDriverPreProcess but not VfIrpCallDriverPostProcess.
//
#define VfIrpCallDriverPreProcess(DeviceObject, IrpPointer, CallStackData, CallerAddress)  \
    if (!VfIrpReserveCallStackData(*(IrpPointer), (CallStackData))) {       \
        *(CallStackData) = alloca(sizeof(IOFCALLDRIVER_STACKDATA));         \
        VfIrpPrepareAllocaCallStackData(*(CallStackData));                  \
    }                                                                       \
    IovpCallDriver1((DeviceObject), (IrpPointer), *(CallStackData), (CallerAddress))

#define VfIrpCallDriverPostProcess(DeviceObject, FinalStatus, CallStackData) \
    IovpCallDriver2(DeviceObject, FinalStatus, CallStackData);               \
    VfIrpReleaseCallStackData(CallStackData)

BOOLEAN
VfIrpSendSynchronousIrp(
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIO_STACK_LOCATION  TopStackLocation,
    IN      BOOLEAN             Untouchable,
    IN      NTSTATUS            InitialStatus,
    IN      ULONG_PTR           InitialInformation  OPTIONAL,
    OUT     ULONG_PTR           *FinalInformation   OPTIONAL,
    OUT     NTSTATUS            *FinalStatus        OPTIONAL
    );

VOID
FASTCALL
VfIrpWatermark(
    IN PIRP  Irp,
    IN ULONG Flags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfirpdb.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfirpdb.h

Abstract:

    This header exposes prototypes for functions used to manage the database of
    IRP tracking data.

--*/

struct _IOV_DATABASE_HEADER;
typedef struct _IOV_DATABASE_HEADER IOV_DATABASE_HEADER;
typedef struct _IOV_DATABASE_HEADER *PIOV_DATABASE_HEADER;

typedef enum _IOV_REFERENCE_TYPE {

    IOVREFTYPE_PACKET = 0,
    IOVREFTYPE_POINTER

} IOV_REFERENCE_TYPE;

typedef enum {

    IRPDBEVENT_POINTER_COUNT_ZERO = 1,
    IRPDBEVENT_REFERENCE_COUNT_ZERO

} IRP_DATABASE_EVENT;

typedef VOID (*PFN_IRPDBEVENT_CALLBACK)(
    IN  PIOV_DATABASE_HEADER    IovHeader,
    IN  PIRP                    TrackedIrp  OPTIONAL,
    IN  IRP_DATABASE_EVENT      Event
    );

typedef struct _IOV_DATABASE_HEADER {

    PIRP                    TrackedIrp;     // Tracked IRP
    KSPIN_LOCK              HeaderLock;     // Spinlock on data structure
    KIRQL                   LockIrql;       // IRQL taken at.
    LONG                    ReferenceCount; // # of reasons to keep this packet
    LONG                    PointerCount;   // # of reasons to track by irp addr
    ULONG                   HeaderFlags;
    LIST_ENTRY              HashLink;       // Link in hash table.
    LIST_ENTRY              ChainLink;      // Head is HeadPacket
    PIOV_DATABASE_HEADER    ChainHead;      // First packet in a chain.
    PFN_IRPDBEVENT_CALLBACK NotificationCallback;
};

VOID
FASTCALL
VfIrpDatabaseInit(
    VOID
    );

BOOLEAN
FASTCALL
VfIrpDatabaseEntryInsertAndLock(
    IN      PIRP                    Irp,
    IN      PFN_IRPDBEVENT_CALLBACK NotificationCallback,
    IN OUT  PIOV_DATABASE_HEADER    IovHeader
    );

PIOV_DATABASE_HEADER
FASTCALL
VfIrpDatabaseEntryFindAndLock(
    IN PIRP     Irp
    );

VOID
FASTCALL
VfIrpDatabaseEntryAcquireLock(
    IN  PIOV_DATABASE_HEADER    IovHeader   OPTIONAL
    );

VOID
FASTCALL
VfIrpDatabaseEntryReleaseLock(
    IN  PIOV_DATABASE_HEADER    IovHeader
    );

VOID
FASTCALL
VfIrpDatabaseEntryReference(
    IN PIOV_DATABASE_HEADER IovHeader,
    IN IOV_REFERENCE_TYPE   IovRefType
    );

VOID
FASTCALL
VfIrpDatabaseEntryDereference(
    IN PIOV_DATABASE_HEADER IovHeader,
    IN IOV_REFERENCE_TYPE   IovRefType
    );

VOID
FASTCALL
VfIrpDatabaseEntryAppendToChain(
    IN OUT  PIOV_DATABASE_HEADER    IovExistingHeader,
    IN OUT  PIOV_DATABASE_HEADER    IovNewHeader
    );

VOID
FASTCALL
VfIrpDatabaseEntryRemoveFromChain(
    IN OUT  PIOV_DATABASE_HEADER    IovHeader
    );

PIOV_DATABASE_HEADER
FASTCALL
VfIrpDatabaseEntryGetChainPrevious(
    IN  PIOV_DATABASE_HEADER    IovHeader
    );

PIOV_DATABASE_HEADER
FASTCALL
VfIrpDatabaseEntryGetChainNext(
    IN  PIOV_DATABASE_HEADER    IovHeader
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfinit.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfinit.h

Abstract:

    This header exposes the routines necessary to initialize the driver verifier.

--*/

VOID
FASTCALL
VfInitVerifier(
    IN  ULONG   MmFlags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfirplog.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfirplog.h

Abstract:

    This header exposes functions for logging IRP events.

--*/

//
// Log-snapshots are retrievable by user mode for profiling and targetted
// probing of stacks. Content-wise they are heavier.
//
typedef struct _IRPLOG_SNAPSHOT {

    ULONG       Count;
    UCHAR       MajorFunction;
    UCHAR       MinorFunction;
    UCHAR       Flags;
    UCHAR       Control;
    ULONGLONG   ArgArray[4];

} IRPLOG_SNAPSHOT, *PIRPLOG_SNAPSHOT;

VOID
VfIrpLogInit(
    VOID
    );

VOID
VfIrpLogRecordEvent(
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot,
    IN  PDEVICE_OBJECT              DeviceObject,
    IN  PIRP                        Irp
    );

ULONG
VfIrpLogGetIrpDatabaseSiloCount(
    VOID
    );

NTSTATUS
VfIrpLogLockDatabase(
    IN  ULONG   SiloNumber
    );

NTSTATUS
VfIrpLogRetrieveWmiData(
    IN  ULONG   SiloNumber,
    OUT PUCHAR  OutputBuffer                OPTIONAL,
    OUT ULONG  *OffsetInstanceNameOffsets,
    OUT ULONG  *InstanceCount,
    OUT ULONG  *DataBlockOffset,
    OUT ULONG  *TotalRequiredSize
    );

VOID
VfIrpLogUnlockDatabase(
    IN  ULONG   SiloNumber
    );

VOID
VfIrpLogDeleteDeviceLogs(
    IN PDEVICE_OBJECT DeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfmacro.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfmacro.h

Abstract:

    This header contains a collection of macros used by the verifier.

--*/


//
// This macro takes an array and returns the number of elements in it.
//
#define ARRAY_COUNT(array) (sizeof(array)/sizeof(array[0]))

//
// This macro takes a value and an alignment and rounds the entry up
// appropriately. The alignment MUST be a power of two!
//
#define ALIGN_UP_ULONG(value, alignment) (((value)+(alignment)-1)&(~(alignment-1)))

//
// This macro compares two guids in their binary form for equivalence.
//
#define IS_EQUAL_GUID(a,b) (RtlCompareMemory(a, b, sizeof(GUID)) == sizeof(GUID))
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfmessage.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfmessage.h

Abstract:

    This module contains prototypes for functions used to retrieve text and
    flags associated with each error.

--*/

//
// The verifier uses tables of messages and with indexes into the tables.
//
typedef ULONG   VFMESSAGE_TABLEID;
typedef ULONG   VFMESSAGE_ERRORID;

//
// VFM_ flags control how a verifier message is handled.
//
// VFM_FLAG_INITIALIZED     - Set when the error template has been updated with
//                            error-class information
//
// VFM_FLAG_BEEP            - Set if error should beep in debugger
//
// VFM_FLAG_ZAPPED          - Set if error was "zapped" (ie prints instead of
//                            stops) via debugger
//
// VFM_FLAG_CLEARED         - Set if error was cleared (disabled) in debugger
//
// VFM_DEPLOYMENT_FAILURE   - Set if the error is severe enough to warrant
//                            removal of the driver from a production system
//
// VFM_LOGO_FAILURE         - Set if the error should disallow certification
//                            for the hardware or the driver
//
// VFM_IGNORE_DRIVER_LIST   - Set if error should fire regardless of whether
//                            the offending driver is being verified or not.
//

#define VFM_FLAG_INITIALIZED        0x00000001
#define VFM_FLAG_BEEP               0x00000002
#define VFM_FLAG_ZAPPED             0x00000004
#define VFM_FLAG_CLEARED            0x00000008
#define VFM_DEPLOYMENT_FAILURE      0x00000010
#define VFM_LOGO_FAILURE            0x00000020
#define VFM_IGNORE_DRIVER_LIST      0x00000040

//
// A message class contains VFM_ flags and some generic text describing the
// problem class.
//
typedef struct _VFMESSAGE_CLASS {

    ULONG   ClassFlags;
    PCSTR   MessageClassText;

} VFMESSAGE_CLASS, *PVFMESSAGE_CLASS;

typedef VFMESSAGE_CLASS const *PCVFMESSAGE_CLASS;

//
// Individual error template. Identifies the index, the message class it's
// associated with, the parameters it takes along with the formatted text it
// displays. Note the ulong flags field - this should always be preinited to
// zero!
//
typedef struct _VFMESSAGE_TEMPLATE {

    VFMESSAGE_ERRORID   MessageID;
    PCVFMESSAGE_CLASS   MessageClass;
    ULONG               Flags;
    PCSTR               ParamString;
    PCSTR               MessageText;

} VFMESSAGE_TEMPLATE, *PVFMESSAGE_TEMPLATE;

//
// Message index 0 is reserved for use in the override tables
//
#define VIMESSAGE_ALL_IDS   0

//
// An override entry allows the verifier to special case generic assertions
// that occur against specific drivers. This is done by overriding the error
// class on the fly.
//
typedef struct _VFMESSAGE_OVERRIDE {

    VFMESSAGE_ERRORID   MessageID;
    PCSTR               DriverName;
    PCVFMESSAGE_CLASS   ReplacementClass;

} VFMESSAGE_OVERRIDE, *PVFMESSAGE_OVERRIDE;

typedef VFMESSAGE_OVERRIDE const *PCVFMESSAGE_OVERRIDE;

//
// The table of errors. Contains the TableID (used for internal lookup),
// bugcheck major ID, array of messages and array of overrides
//
typedef struct _VFMESSAGE_TEMPLATE_TABLE {

    VFMESSAGE_TABLEID       TableID;
    ULONG                   BugCheckMajor;
    PVFMESSAGE_TEMPLATE     TemplateArray;
    ULONG                   TemplateCount;
    PCVFMESSAGE_OVERRIDE    OverrideArray;
    ULONG                   OverrideCount;

} VFMESSAGE_TEMPLATE_TABLE, *PVFMESSAGE_TEMPLATE_TABLE;

//
// Retrieves an internal error table based on ID.
//
VOID
VfMessageRetrieveInternalTable(
    IN  VFMESSAGE_TABLEID           TableID,
    OUT PVFMESSAGE_TEMPLATE_TABLE  *MessageTable
    );

//
// Retrieves and formats the appropriate error message.
//
VOID
VfMessageRetrieveErrorData(
    IN  PVFMESSAGE_TEMPLATE_TABLE   MessageTable        OPTIONAL,
    IN  VFMESSAGE_ERRORID           MessageID,
    IN  PSTR                        AnsiDriverName,
    OUT ULONG                      *BugCheckMajor,
    OUT PCVFMESSAGE_CLASS          *MessageClass,
    OUT PCSTR                      *MessageTextTemplate,
    OUT PULONG                     *TemplateFlags
    );

//
// This file contains a set of internal message tables.
//
// The IO Verifier Table Index is...
//
#define VFMESSAGE_TABLE_IOVERIFIER  1

//
// IO Verifier Messages
//
typedef enum _DCERROR_ID {

    DCERROR_UNSPECIFIED = 0x200,
    DCERROR_DELETE_WHILE_ATTACHED,
    DCERROR_DETACH_NOT_ATTACHED,
    DCERROR_CANCELROUTINE_FORWARDED,
    DCERROR_NULL_DEVOBJ_FORWARDED,
    DCERROR_QUEUED_IRP_FORWARDED,
    DCERROR_NEXTIRPSP_DIRTY,
    DCERROR_IRPSP_COPIED,
    DCERROR_INSUFFICIENT_STACK_LOCATIONS,
    DCERROR_QUEUED_IRP_COMPLETED,
    DCERROR_FREE_OF_INUSE_TRACKED_IRP,
    DCERROR_FREE_OF_INUSE_IRP,
    DCERROR_FREE_OF_THREADED_IRP,
    DCERROR_REINIT_OF_ALLOCATED_IRP_WITH_QUOTA,
    DCERROR_PNP_IRP_BAD_INITIAL_STATUS,
    DCERROR_POWER_IRP_BAD_INITIAL_STATUS,
    DCERROR_WMI_IRP_BAD_INITIAL_STATUS,
    DCERROR_SKIPPED_DEVICE_OBJECT,
    DCERROR_BOGUS_FUNC_TRASHED,
    DCERROR_BOGUS_STATUS_TRASHED,
    DCERROR_BOGUS_INFO_TRASHED,
    DCERROR_PNP_FAILURE_FORWARDED,
    DCERROR_PNP_IRP_STATUS_RESET,
    DCERROR_PNP_IRP_NEEDS_HANDLING,
    DCERROR_PNP_IRP_HANDS_OFF,
    DCERROR_POWER_FAILURE_FORWARDED,
    DCERROR_POWER_IRP_STATUS_RESET,
    DCERROR_INVALID_STATUS,
    DCERROR_UNNECCESSARY_COPY,
    DCERROR_SHOULDVE_DETACHED,
    DCERROR_SHOULDVE_DELETED,
    DCERROR_MISSING_DISPATCH_FUNCTION,
    DCERROR_WMI_IRP_NOT_FORWARDED,
    DCERROR_DELETED_PRESENT_PDO,
    DCERROR_BUS_FILTER_ERRONEOUSLY_DETACHED,
    DCERROR_BUS_FILTER_ERRONEOUSLY_DELETED,
    DCERROR_INCONSISTANT_STATUS,
    DCERROR_UNINITIALIZED_STATUS,
    DCERROR_IRP_RETURNED_WITHOUT_COMPLETION,
    DCERROR_COMPLETION_ROUTINE_PAGABLE,
    DCERROR_PENDING_BIT_NOT_MIGRATED,
    DCERROR_CANCELROUTINE_ON_FORWARDED_IRP,
    DCERROR_PNP_IRP_NEEDS_PDO_HANDLING,
    DCERROR_TARGET_RELATION_LIST_EMPTY,
    DCERROR_TARGET_RELATION_NEEDS_REF,
    DCERROR_BOGUS_PNP_IRP_COMPLETED,
    DCERROR_SUCCESSFUL_PNP_IRP_NOT_FORWARDED,
    DCERROR_UNTOUCHED_PNP_IRP_NOT_FORWARDED,
    DCERROR_BOGUS_POWER_IRP_COMPLETED,
    DCERROR_SUCCESSFUL_POWER_IRP_NOT_FORWARDED,
    DCERROR_UNTOUCHED_POWER_IRP_NOT_FORWARDED,
    DCERROR_PNP_QUERY_CAP_BAD_VERSION,
    DCERROR_PNP_QUERY_CAP_BAD_SIZE,
    DCERROR_PNP_QUERY_CAP_BAD_ADDRESS,
    DCERROR_PNP_QUERY_CAP_BAD_UI_NUM,
    DCERROR_RESTRICTED_IRP,
    DCERROR_REINIT_OF_ALLOCATED_IRP_WITHOUT_QUOTA,
    DCERROR_UNFORWARDED_IRP_COMPLETED,
    DCERROR_DISPATCH_CALLED_AT_BAD_IRQL,
    DCERROR_BOGUS_MINOR_STATUS_TRASHED,
    DCERROR_CANCELROUTINE_AFTER_COMPLETION,
    DCERROR_PENDING_RETURNED_NOT_MARKED,
    DCERROR_PENDING_MARKED_NOT_RETURNED,
    DCERROR_POWER_PAGABLE_NOT_INHERITED,
    DCERROR_DOUBLE_DELETION,
    DCERROR_DETACHED_IN_SURPRISE_REMOVAL,
    DCERROR_DELETED_IN_SURPRISE_REMOVAL,
    DCERROR_DO_INITIALIZING_NOT_CLEARED,
    DCERROR_DO_FLAG_NOT_COPIED,
    DCERROR_INCONSISTANT_DO_FLAGS,
    DCERROR_DEVICE_TYPE_NOT_COPIED,
    DCERROR_NON_FAILABLE_IRP,
    DCERROR_NON_PDO_RETURNED_IN_RELATION,
    DCERROR_DUPLICATE_ENUMERATION,
    DCERROR_FILE_IO_AT_BAD_IRQL,
    DCERROR_MISHANDLED_TARGET_DEVICE_RELATIONS,
    DCERROR_PENDING_RETURNED_NOT_MARKED_2,
    DCERROR_DDI_REQUIRES_PDO,
    DCERROR_MAXIMUM

} DCERROR_ID;
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfpnp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfpnp.h

Abstract:

    This header contains prototypes for verifying Pnp IRPs are handled
    correctly.

--*/

VOID
VfPnpInit(
    VOID
    );

VOID
FASTCALL
VfPnpVerifyNewRequest(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

VOID
FASTCALL
VfPnpVerifyIrpStackDownward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp                   OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress               OPTIONAL
    );

VOID
FASTCALL
VfPnpVerifyIrpStackUpward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN BOOLEAN              IsNewlyCompleted,
    IN BOOLEAN              RequestFinalized
    );

VOID
FASTCALL
VfPnpDumpIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    );

BOOLEAN
FASTCALL
VfPnpIsSystemRestrictedIrp(
    IN PIO_STACK_LOCATION IrpSp
    );

BOOLEAN
FASTCALL
VfPnpAdvanceIrpStatus(
    IN     PIO_STACK_LOCATION   IrpSp,
    IN     NTSTATUS             OriginalStatus,
    IN OUT NTSTATUS             *StatusToAdvance
    );

VOID
FASTCALL
VfPnpTestStartedPdoStack(
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfpragma.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfpragma.h

Abstract:

    This header contains disable instructions for W4 warnings generated
    by public headers. This way we can still compile modules at W4.

--*/

//
// Disable W4 level warnings generated by public headers.
//

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4232)   // dllimport not static
#pragma warning(disable:4206)   // translation unit empty
#pragma warning(disable:4054)   // function pointer to data pointer cast
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfmajor.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfmajor.h

Abstract:

    This header contains prototypes for per-major IRP code verification.

--*/

//
// Use this major code to register a handler for default or all IRPs (context
// specific to function)
//
#define IRP_MJ_ALL_MAJORS   0xFF

typedef VOID (FASTCALL *PFN_DUMP_IRP_STACK)(
    IN PIO_STACK_LOCATION IrpSp
    );

typedef VOID (FASTCALL *PFN_VERIFY_NEW_REQUEST)(
    IN PIOV_REQUEST_PACKET  IrpTrackingData,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

typedef VOID (FASTCALL *PFN_VERIFY_IRP_STACK_DOWNWARD)(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp                   OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress               OPTIONAL
    );

typedef VOID (FASTCALL *PFN_VERIFY_IRP_STACK_UPWARD)(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN BOOLEAN              IsNewlyCompleted,
    IN BOOLEAN              RequestFinalized
    );

typedef BOOLEAN (FASTCALL *PFN_IS_SYSTEM_RESTRICTED_IRP)(
    IN PIO_STACK_LOCATION IrpSp
    );

typedef BOOLEAN (FASTCALL *PFN_ADVANCE_IRP_STATUS)(
    IN     PIO_STACK_LOCATION   IrpSp,
    IN     NTSTATUS             OriginalStatus,
    IN OUT NTSTATUS             *StatusToAdvance
    );

typedef BOOLEAN (FASTCALL *PFN_IS_VALID_IRP_STATUS)(
    IN PIO_STACK_LOCATION   IrpSp,
    IN NTSTATUS             Status
    );

typedef BOOLEAN (FASTCALL *PFN_IS_NEW_REQUEST)(
    IN PIO_STACK_LOCATION   IrpLastSp OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp
    );

typedef VOID (FASTCALL *PFN_VERIFY_NEW_IRP)(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

typedef VOID (FASTCALL *PFN_VERIFY_FINAL_IRP_STACK)(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp
    );

typedef VOID (FASTCALL *PFN_TEST_STARTED_PDO_STACK)(
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );

typedef LOGICAL (FASTCALL *PFN_BUILD_LOG_ENTRY)(
    IN  PIRP                Irp,
    IN  ULONG               CurrentCount,
    IN  PIRPLOG_SNAPSHOT    CurrentEntryArray,
    OUT PIRPLOG_SNAPSHOT    IrpSnapshot
    );

VOID
VfMajorInit(
    VOID
    );

VOID
FASTCALL
VfMajorRegisterHandlers(
    IN  UCHAR                           IrpMajorCode,
    IN  PFN_DUMP_IRP_STACK              DumpIrpStack            OPTIONAL,
    IN  PFN_VERIFY_NEW_REQUEST          VerifyNewRequest        OPTIONAL,
    IN  PFN_VERIFY_IRP_STACK_DOWNWARD   VerifyStackDownward     OPTIONAL,
    IN  PFN_VERIFY_IRP_STACK_UPWARD     VerifyStackUpward       OPTIONAL,
    IN  PFN_IS_SYSTEM_RESTRICTED_IRP    IsSystemRestrictedIrp   OPTIONAL,
    IN  PFN_ADVANCE_IRP_STATUS          AdvanceIrpStatus        OPTIONAL,
    IN  PFN_IS_VALID_IRP_STATUS         IsValidIrpStatus        OPTIONAL,
    IN  PFN_IS_NEW_REQUEST              IsNewRequest            OPTIONAL,
    IN  PFN_VERIFY_NEW_IRP              VerifyNewIrp            OPTIONAL,
    IN  PFN_VERIFY_FINAL_IRP_STACK      VerifyFinalIrpStack     OPTIONAL,
    IN  PFN_TEST_STARTED_PDO_STACK      TestStartedPdoStack     OPTIONAL,
    IN  PFN_BUILD_LOG_ENTRY             BuildIrpLogEntry        OPTIONAL
    );

VOID
FASTCALL
VfMajorDumpIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
FASTCALL
VfMajorVerifyNewRequest(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

VOID
FASTCALL
VfMajorVerifyIrpStackDownward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

VOID
FASTCALL
VfMajorVerifyIrpStackUpward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN BOOLEAN              IsNewlyCompleted,
    IN BOOLEAN              RequestFinalized
    );

BOOLEAN
FASTCALL
VfMajorIsSystemRestrictedIrp(
    IN PIO_STACK_LOCATION IrpSp
    );

BOOLEAN
FASTCALL
VfMajorAdvanceIrpStatus(
    IN     PIO_STACK_LOCATION   IrpSp,
    IN     NTSTATUS             OriginalStatus,
    IN OUT NTSTATUS             *StatusToAdvance
    );

BOOLEAN
FASTCALL
VfMajorIsValidIrpStatus(
    IN PIO_STACK_LOCATION   IrpSp,
    IN NTSTATUS             Status
    );

BOOLEAN
FASTCALL
VfMajorIsNewRequest(
    IN PIO_STACK_LOCATION   IrpLastSp OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp
    );

VOID
FASTCALL
VfMajorVerifyNewIrp(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

VOID
FASTCALL
VfMajorVerifyFinalIrpStack(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp
    );

VOID
FASTCALL
VfMajorTestStartedPdoStack(
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );

LOGICAL
FASTCALL
VfMajorBuildIrpLogEntry(
    IN  PIRP                Irp,
    IN  ULONG               CurrentCount,
    IN  PIRPLOG_SNAPSHOT    CurrentEntryArray,
    OUT PIRPLOG_SNAPSHOT    IrpSnapshot
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfprint.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfprint.h

Abstract:

    This header exposes prototypes required when outputting various data types
    to the debugger.

--*/

VOID
VfPrintDumpIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
VfPrintDumpIrp(
    IN PIRP IrpToFlag
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfpacket.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfpacket.h

Abstract:

    This header exposes functions used to manage the verifier packet data that
    tracks IRPs.

--*/


//
// Currently, ntddk.h uses up to 0x2000 for Irp->Flags
//
#define IRPFLAG_EXAMINE_MASK           0xC0000000
#define IRPFLAG_EXAMINE_NOT_TRACKED    0x80000000
#define IRPFLAG_EXAMINE_TRACKED        0x40000000
#define IRPFLAG_EXAMINE_UNMARKED       0x00000000

#define TRACKFLAG_ACTIVE            0x00000001
#define IRP_ALLOC_COUNT             8

#define IRP_LOG_ENTRIES             16

typedef enum {

    IOV_EVENT_NONE = 0,
    IOV_EVENT_IO_ALLOCATE_IRP,
    IOV_EVENT_IO_CALL_DRIVER,
    IOV_EVENT_IO_CALL_DRIVER_UNWIND,
    IOV_EVENT_IO_COMPLETE_REQUEST,
    IOV_EVENT_IO_COMPLETION_ROUTINE,
    IOV_EVENT_IO_COMPLETION_ROUTINE_UNWIND,
    IOV_EVENT_IO_CANCEL_IRP,
    IOV_EVENT_IO_FREE_IRP

} IOV_LOG_EVENT;

typedef struct {

    IOV_LOG_EVENT   Event;
    PETHREAD        Thread;
    PVOID           Address;
    ULONG_PTR       Data;
    LARGE_INTEGER   TimeStamp;

} IOV_LOG_ENTRY, *PIOV_LOG_ENTRY;

struct _IOV_SESSION_DATA;
struct _IOV_REQUEST_PACKET;

typedef struct _IOV_SESSION_DATA    *PIOV_SESSION_DATA;
typedef struct _IOV_REQUEST_PACKET  *PIOV_REQUEST_PACKET;

typedef struct _IOV_REQUEST_PACKET {

    IOV_DATABASE_HEADER;
    ULONG                       Flags;
    KIRQL                       DepartureIrql;  // Irql IRP will be dispatched at.
    KIRQL                       ArrivalIrql;    // Irql IRP was sent in at.
    LIST_ENTRY                  SessionHead;    // List of all sessions.
    CCHAR                       StackCount;     // StackCount of tracked IRP.
    ULONG                       QuotaCharge;    // Quota charged against IRP.
    PEPROCESS                   QuotaProcess;   // Process quota was charged to.

    PIO_COMPLETION_ROUTINE      RealIrpCompletionRoutine;
    UCHAR                       RealIrpControl;
    PVOID                       RealIrpContext;
    PVOID                       AllocatorStack[IRP_ALLOC_COUNT];

    //
    // The following information is for the assertion routines to read.
    //
    UCHAR                       TopStackLocation;

    CCHAR                       PriorityBoost;  // Boost from IofCompleteRequest
    UCHAR                       LastLocation;   // Last location from IofCallDriver
    ULONG                       RefTrackingCount;

    //
    // This field is only set on surrogate IRPs, and contains the locked system
    // VA for the destination of a direct I/O IRP that's being buffered.
    //
    PUCHAR                      SystemDestVA;

#if DBG
    IOV_LOG_ENTRY               LogEntries[IRP_LOG_ENTRIES];
    ULONG                       LogEntryHead;
    ULONG                       LogEntryTail;
#endif

    PVERIFIER_SETTINGS_SNAPSHOT VerifierSettings;
    PIOV_SESSION_DATA           pIovSessionData;

} IOV_REQUEST_PACKET;

PIOV_REQUEST_PACKET
FASTCALL
VfPacketCreateAndLock(
    IN  PIRP    Irp
    );

PIOV_REQUEST_PACKET
FASTCALL
VfPacketFindAndLock(
    IN  PIRP    Irp
    );

VOID
FASTCALL
VfPacketAcquireLock(
    IN  PIOV_REQUEST_PACKET   IrpTrackingData
    );

VOID
FASTCALL
VfPacketReleaseLock(
    IN  PIOV_REQUEST_PACKET   IrpTrackingData
    );

VOID
FASTCALL
VfPacketReference(
    IN  PIOV_REQUEST_PACKET IovPacket,
    IN  IOV_REFERENCE_TYPE  IovRefType
    );

VOID
FASTCALL
VfPacketDereference(
    IN  PIOV_REQUEST_PACKET IovPacket,
    IN  IOV_REFERENCE_TYPE  IovRefType
    );

PIOV_SESSION_DATA
FASTCALL
VfPacketGetCurrentSessionData(
    IN PIOV_REQUEST_PACKET IovPacket
    );

VOID
FASTCALL
VfPacketLogEntry(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN IOV_LOG_EVENT        IovLogEvent,
    IN PVOID                Address,
    IN ULONG_PTR            Data
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfpower.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfpower.h

Abstract:

    This header contains prototypes for verifying Power IRPs are handled
    correctly.

--*/

VOID
VfPowerInit(
    VOID
    );

VOID
FASTCALL
VfPowerVerifyNewRequest(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

VOID
FASTCALL
VfPowerVerifyIrpStackDownward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp                   OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress               OPTIONAL
    );

VOID
FASTCALL
VfPowerVerifyIrpStackUpward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN BOOLEAN              IsNewlyCompleted,
    IN BOOLEAN              RequestFinalized
    );

VOID
FASTCALL
VfPowerDumpIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    );

BOOLEAN
FASTCALL
VfPowerIsSystemRestrictedIrp(
    IN PIO_STACK_LOCATION IrpSp
    );

BOOLEAN
FASTCALL
VfPowerAdvanceIrpStatus(
    IN     PIO_STACK_LOCATION   IrpSp,
    IN     NTSTATUS             OriginalStatus,
    IN OUT NTSTATUS             *StatusToAdvance
    );

VOID
FASTCALL
VfPowerTestStartedPdoStack(
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfrandom.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfrandom.h

Abstract:

    This header exposes support for random number generation as needed by the
    verifier.

--*/

VOID
VfRandomInit(
    VOID
    );

ULONG
FASTCALL
VfRandomGetNumber(
    IN  ULONG   Minimum,
    IN  ULONG   Maximum
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vftriage.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

   vftriage

Abstract:

    Code to support driver verifier triage decisions and running mode.

--*/

#ifndef INCLUDED_VFTRIAGE_H
#define INCLUDED_VFTRIAGE_H

#endif // #ifndef INCLUDED_VFTRIAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfutil.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfutil.h

Abstract:

    This header contains prototypes for various functions required to do driver
    verification.

--*/

typedef enum {

    VFMP_INSTANT = 0,
    VFMP_INSTANT_NONPAGED

} MEMORY_PERSISTANCE;

BOOLEAN
VfUtilIsMemoryRangeReadable(
    IN PVOID                Location,
    IN size_t               Length,
    IN MEMORY_PERSISTANCE   Persistance
    );

VOID
VfSetVerifierEnabled (
    LOGICAL Value
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfstack.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfstack.h

Abstract:

    This header contains prototypes for verifying drivers don't improperly use
    thread stacks.

--*/

VOID
FASTCALL
VfStackSeedStack(
    IN  ULONG   Seed
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfsettings.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfsettings.h

Abstract:

    This header contains prototypes for manipulating verifier options and
    values.

--*/

typedef PVOID PVERIFIER_SETTINGS_SNAPSHOT;

typedef enum {

    //
    // This option lets the verifer begin tracking all IRPs. It must be enabled
    // for most of the other IRP verification options to work.
    //
    VERIFIER_OPTION_TRACK_IRPS = 1,

    //
    // This option forces all IRPs to be allocated from the special pool.
    // VERIFIER_OPTION_TRACK_IRPS need not be enabled.
    //
    VERIFIER_OPTION_MONITOR_IRP_ALLOCS,

    //
    // This option enables various checks for basic/common IRP handling mistakes.
    //
    VERIFIER_OPTION_POLICE_IRPS,

    //
    // This option enables checks specific to major/minor codes.
    //
    VERIFIER_OPTION_MONITOR_MAJORS,

    //
    // This option causes the call stacks of IRP dispatch and completion
    // routines to be seeded with 0xFFFFFFFF. This value is illegal for a
    // status code, and such seeding flushes out uninitialized variable bugs.
    //
    VERIFIER_OPTION_SEEDSTACK,

    //
    // This option sends a bogus QueryDeviceRelations IRP to newly built stacks.
    // The particular IRP sent is of type -1, and has a -1 passed in for the
    // device list.
    //
    VERIFIER_OPTION_RELATION_IGNORANCE_TEST,

    //
    // This option causes the verifier to stop on unnecessary IRP stack copies.
    // It is useful for optimizing drivers.
    //
    VERIFIER_OPTION_FLAG_UNNECCESSARY_COPIES,

    VERIFIER_OPTION_SEND_BOGUS_WMI_IRPS,
    VERIFIER_OPTION_SEND_BOGUS_POWER_IRPS,

    //
    // If this option is enabled, the verifier makes sure drivers mark the IRP
    // pending if and only if STATUS_PENDING is returned, and visa versa.
    //
    VERIFIER_OPTION_MONITOR_PENDING_IO,

    //
    // If this option is enabled, the verifier makes all IRPs return in an
    // asynchronous manner. Specifically, all IRPs are marked pending, and
    // STATUS_PENDING is returned from every IoCallDriver.
    //
    VERIFIER_OPTION_FORCE_PENDING,

    //
    // If this option is enabled, the verifier will change the status code of
    // successful IRPs to alternate success status's. This catches many IRP
    // forwarding bugs.
    //
    VERIFIER_OPTION_ROTATE_STATUS,

    //
    // If this option is enabled, the verifier will undo the effects of
    // IoSkipCurrentIrpStackLocation so that all stacks appear to be copied.
    // (Exempting the case where an IRP was forwarded to another stack)
    //
    VERIFIER_OPTION_CONSUME_ALWAYS,

    //
    // If this option is enabled, the verifier will update SRB's to handle
    // surrogate IRPs. Some SCSI IRPs can't be surrogated unless the
    // SRB->OriginalRequest pointer is updated. This is due to a busted SRB
    // architecture. Note that the technique used to identify an SRB IRP is
    // "fuzzy", and could in theory touch an IRP it shouldn't have!
    //
    VERIFIER_OPTION_SMASH_SRBS,

    //
    // If this option is enabled, the verifier will replace original IRPs with
    // surrogates when traveling down the stack. The surrogates are allocated
    // from special pool, and get freed immediately upon completion. This lets
    // the verifier catch drivers that touch IRPs after they're completed.
    //
    VERIFIER_OPTION_SURROGATE_IRPS,

    //
    // If this option is enabled, the verifier buffers all direct I/O. It does
    // this by allocating an alternate MDL and copying the MDL contents back
    // to user mode only after IRP completion. This allows overruns, underruns,
    // and late accesses to be detected.
    //
    VERIFIER_OPTION_BUFFER_DIRECT_IO,

    //
    // If this option is enabled, the verifier delays completion of all IRPs
    // via timer. VERIFIER_OPTION_FORCE_PENDING is set by inference.
    //
    VERIFIER_OPTION_DEFER_COMPLETION,

    //
    // If this option is enabled, the verifier completes every IRP at
    // PASSIVE_LEVEL, regardless of major function.
    // VERIFIER_OPTION_FORCE_PENDING is set by inference.
    //
    VERIFIER_OPTION_COMPLETE_AT_PASSIVE,

    //
    // If this option is enabled, the verifier completes every IRP at
    // DISPATCH_LEVEL, regardless of major function.
    //
    VERIFIER_OPTION_COMPLETE_AT_DISPATCH,

    //
    // If this option is enabled, the verifier monitors cancel routines to make
    // sure they are cleared appropriately.
    //
    VERIFIER_OPTION_VERIFY_CANCEL_LOGIC,

    VERIFIER_OPTION_RANDOMLY_CANCEL_IRPS,

    //
    // If this option is enabled, the verifier inserts filter device objects
    // into WDM stacks to ensure IRPs are properly forwarded.
    //
    VERIFIER_OPTION_INSERT_WDM_FILTERS,

    //
    // If this option is enabled, the verifier monitors drivers to ensure they
    // don't send system reserved IRPs to WDM stacks.
    //
    VERIFIER_OPTION_PROTECT_RESERVED_IRPS,

    //
    // If this option is enabled, the verifier walks the entire stack to ensure
    // the DO bits are properly built during AddDevice. This includes the
    // DO_POWER_PAGABLE flag.
    //
    VERIFIER_OPTION_VERIFY_DO_FLAGS,

    //
    // If this option is enabled, the verifier watches Target device relation
    // IRPs to make sure the device object is properly reference counted.
    //
    VERIFIER_OPTION_TEST_TARGET_REFCOUNT,

    //
    // Lets you detect when deadlocks can occur
    //
    VERIFIER_OPTION_DETECT_DEADLOCKS,

    //
    // If this option is enabled, all dma operations will be hooked and
    // validated.
    //
    VERIFIER_OPTION_VERIFY_DMA,

    //
    // This option double buffers all dma and erects guard pages on each side
    // of all common buffers and mapped buffers. Is memory-intensive but can
    // catch hardware buffer overruns and drivers that don't flush adapter
    // buffers.
    //
    VERIFIER_OPTION_DOUBLE_BUFFER_DMA,

    //
    // If this option is enabled, you get notified when the performance counter
    // is being naughty
    //
    VERIFIER_OPTION_VERIFY_PERFORMANCE_COUNTER,

    //
    // If this option is enabled, the verifier checks for implementations of
    // IRP_MN_DEVICE_USAGE_NOTIFICATION and IRP_MN_SURPRISE_REMOVAL. The
    // verifier will also make sure PnP Cancel IRPs are not explicitely failed.
    //
    VERIFIER_OPTION_EXTENDED_REQUIRED_IRPS,

    //
    // If this option is enabled, the verifier mixes up device relations
    // to ensure drivers aren't depending on ordering.
    //
    VERIFIER_OPTION_SCRAMBLE_RELATIONS,

    //
    // If this option is enabled, the verifier ensures proper detaching and
    // deletion occurs on removes and surprise removes.
    //
    VERIFIER_OPTION_MONITOR_REMOVES,

    //
    // If this option is enabled, the verifier ensures device relations only
    // consist of PDO's.
    //
    VERIFIER_OPTION_EXAMINE_RELATION_PDOS,

    //
    // If this option is enabled, the verifier enabled hardware verification
    // (bus specific behavior)
    //
    VERIFIER_OPTION_HARDWARE_VERIFICATION,

    //
    // If this option is enabled, the verifier ensures system BIOS verification
    //
    VERIFIER_OPTION_SYSTEM_BIOS_VERIFICATION,

    //
    // If this option is enabled, the verifier exposes IRP history data that
    // can be used to test for security holes.
    //
    VERIFIER_OPTION_EXPOSE_IRP_HISTORY,

    VERIFIER_OPTION_MAX

} VERIFIER_OPTION;

typedef enum {

    //
    // If VERIFIER_OPTION_DEFER_COMPLETION is set, this value contains the time
    // an IRP will be deferred, in 100us units.
    //
    VERIFIER_VALUE_IRP_DEFERRAL_TIME = 1,

    //
    // This shall be the percentage of allocates to fail during low resource
    // simulation.
    //
    VERIFIER_VALUE_LOW_RESOURCE_PERCENTAGE,

    //
    // If VERIFIER_OPTION_EXPOSE_IRP_HISTORY is set, this value contains the
    // amount of IRPs per device object to log.
    //
    VERIFIER_VALUE_IRPLOG_COUNT,

    VERIFIER_VALUE_MAX

} VERIFIER_VALUE;

VOID
FASTCALL
VfSettingsInit(
    IN  ULONG   MmFlags
    );

BOOLEAN
FASTCALL
VfSettingsIsOptionEnabled(
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot  OPTIONAL,
    IN  VERIFIER_OPTION             VerifierOption
    );

VOID
FASTCALL
VfSettingsCreateSnapshot(
    IN OUT  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot
    );

ULONG
FASTCALL
VfSettingsGetSnapshotSize(
    VOID
    );

VOID
FASTCALL
VfSettingsSetOption(
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot  OPTIONAL,
    IN  VERIFIER_OPTION             VerifierOption,
    IN  BOOLEAN                     Setting
    );

VOID
FASTCALL
VfSettingsGetValue(
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot  OPTIONAL,
    IN  VERIFIER_VALUE              VerifierValue,
    OUT ULONG                       *Value
    );

VOID
FASTCALL
VfSettingsSetValue(
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot  OPTIONAL,
    IN  VERIFIER_VALUE              VerifierValue,
    IN  ULONG                       Value
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\alloc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    alloc.c

Abstract:

    WMI data structure allocation routines

--*/

#include "wmikmp.h"


// This is duplicated from wmium.h. 
//
// This guid is for notifications of changes to registration
// {B48D49A1-E777-11d0-A50C-00A0C9062910}
GUID GUID_REGISTRATION_CHANGE_NOTIFICATION = {0xb48d49a1, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10};

//
// This guid id for notifications of new mof resources being added
// {B48D49A2-E777-11d0-A50C-00A0C9062910}
GUID GUID_MOF_RESOURCE_ADDED_NOTIFICATION = {0xb48d49a2, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10};

//
// This guid id for notifications of new mof resources being added
// {B48D49A3-E777-11d0-A50C-00A0C9062910}
GUID GUID_MOF_RESOURCE_REMOVED_NOTIFICATION = {0xb48d49a3, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10};


//
// This defines the number of DataSources allocated in each DataSource chunk
#if DBG
#define DSCHUNKSIZE 4
#else
#define DSCHUNKSIZE 64
#endif

void WmipDSCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

CHUNKINFO WmipDSChunkInfo =
{
    { NULL, NULL },
    sizeof(DATASOURCE),
    DSCHUNKSIZE,
    WmipDSCleanup,
    FLAG_ENTRY_REMOVE_LIST,
    DS_SIGNATURE
};

LIST_ENTRY WmipDSHead;              // Head of registered data source list
PLIST_ENTRY WmipDSHeadPtr;

//
// This defines the number of GuidEntrys allocated in each GuidEntry chunk
#if DBG
#define GECHUNKSIZE    4
#else
#define GECHUNKSIZE    512
#endif

void WmipGECleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

CHUNKINFO WmipGEChunkInfo =
{
    { NULL, NULL },
    sizeof(GUIDENTRY),
    GECHUNKSIZE,
    WmipGECleanup,
    FLAG_ENTRY_REMOVE_LIST,
    GE_SIGNATURE
};

LIST_ENTRY WmipGEHead;              // Head of registered guid list
PLIST_ENTRY WmipGEHeadPtr;

//
// This defines the number of InstanceSets allocated in each InstanceSet chunk
#if DBG
#define ISCHUNKSIZE    4
#else
#define ISCHUNKSIZE    2048
#endif

void WmipISCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

CHUNKINFO WmipISChunkInfo =
{
    { NULL, NULL },
    sizeof(INSTANCESET),
    ISCHUNKSIZE,
    WmipISCleanup,
    0,
    IS_SIGNATURE
};

#if DBG
#define MRCHUNKSIZE    2
#else
#define MRCHUNKSIZE    16
#endif

void WmipMRCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

CHUNKINFO WmipMRChunkInfo =
{
    { NULL, NULL },
    sizeof(MOFRESOURCE),
    MRCHUNKSIZE,
    WmipMRCleanup,
    FLAG_ENTRY_REMOVE_LIST,
    MR_SIGNATURE
};

LIST_ENTRY WmipMRHead;                     // Head of Mof Resource list
PLIST_ENTRY WmipMRHeadPtr;

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, WmipDSCleanup)
#pragma alloc_text (PAGE, WmipAllocDataSource)
#pragma alloc_text (PAGE, WmipGECleanup)
#pragma alloc_text (PAGE, WmipAllocGuidEntryX)
#pragma alloc_text (PAGE, WmipISCleanup)
#pragma alloc_text (PAGE, WmipMRCleanup)
#pragma alloc_text (PAGE, WmipFindGEByGuid)
#pragma alloc_text (PAGE, WmipFindDSByProviderId)
#pragma alloc_text (PAGE, WmipFindISByGuid)
#pragma alloc_text (PAGE, WmipFindMRByNames)
#pragma alloc_text (PAGE, WmipFindISinGEbyName)
#pragma alloc_text (PAGE, WmipRealloc)
#pragma alloc_text (PAGE, WmipIsNumber)
#endif


PBDATASOURCE WmipAllocDataSource(
    void
    )
/*++

Routine Description:

    Allocates a Data Source structure

Arguments:


Return Value:

    pointer to data source structure or NULL if one cannot be allocated

--*/
{
    PBDATASOURCE DataSource;

    DataSource = (PBDATASOURCE)WmipAllocEntry(&WmipDSChunkInfo);
    if (DataSource != NULL)
    {
        InitializeListHead(&DataSource->ISHead);
        DataSource->MofResourceCount = AVGMOFRESOURCECOUNT;
        DataSource->MofResources = DataSource->StaticMofResources;
        memset(DataSource->MofResources,
               0,
               AVGMOFRESOURCECOUNT * sizeof(PMOFRESOURCE));
    }

    return(DataSource);
}

void WmipDSCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
/*++

Routine Description:

    Cleans up data source structure and any other structures or handles
    associated with it.

Arguments:

    Data source structure to free

Return Value:

--*/
{
    PBDATASOURCE DataSource = (PBDATASOURCE)Entry;
    PBINSTANCESET InstanceSet;
    PLIST_ENTRY InstanceSetList;
    ULONG i;

    UNREFERENCED_PARAMETER (ChunkInfo);

    WmipAssert(DataSource != NULL);
    WmipAssert(DataSource->Flags & FLAG_ENTRY_INVALID);

    WmipEnterSMCritSection();

    InstanceSetList = DataSource->ISHead.Flink;
    while (InstanceSetList != &DataSource->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        DSISList);

        if (InstanceSet->GuidISList.Flink != NULL)
        {
            RemoveEntryList(&InstanceSet->GuidISList);
            InstanceSet->DataSource = NULL;
            InstanceSet->GuidEntry->ISCount--;
        }

        if ((InstanceSet->GuidEntry != NULL) &&
            (! (InstanceSet->Flags & IS_NEWLY_REGISTERED)))
        {

            if (IsEqualGUID(&InstanceSet->GuidEntry->Guid,
                            &WmipBinaryMofGuid))
            {
                WmipLeaveSMCritSection();
            
                WmipGenerateBinaryMofNotification(InstanceSet,
                                     &GUID_MOF_RESOURCE_REMOVED_NOTIFICATION);

                WmipEnterSMCritSection();
            }

            WmipUnreferenceGE(InstanceSet->GuidEntry);
        }
        InstanceSet->GuidEntry = NULL;

        InstanceSetList = InstanceSetList->Flink;

        WmipUnreferenceIS(InstanceSet);
    }

    WmipLeaveSMCritSection();

    for (i = 0; i < DataSource->MofResourceCount; i++)
    {
        if (DataSource->MofResources[i] != NULL)
        {
            WmipUnreferenceMR(DataSource->MofResources[i]);
        }
    }

    if (DataSource->MofResources != DataSource->StaticMofResources)
    {
        WmipFree(DataSource->MofResources);
        DataSource->MofResources = NULL;
    }

    if (DataSource->RegistryPath != NULL)
    {
        WmipFree(DataSource->RegistryPath);
        DataSource->RegistryPath = NULL;
    }
}

void WmipGECleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
/*++

Routine Description:

    Cleans up guid entry structure and any other structures or handles
    associated with it.

Arguments:

    GuidEntry structure to free

Return Value:

--*/
{
    PBGUIDENTRY GuidEntry = (PBGUIDENTRY)Entry;
    
    UNREFERENCED_PARAMETER (ChunkInfo);

    WmipAssert(GuidEntry != NULL);
    WmipAssert(GuidEntry->Flags & FLAG_ENTRY_INVALID);

    GuidEntry->Guid.Data4[7] ^= 0xff;
    
    if (GuidEntry->CollectInProgress != NULL)
    {
        ExFreePool(GuidEntry->CollectInProgress);
        GuidEntry->CollectInProgress = NULL;
    }

}

PBGUIDENTRY WmipAllocGuidEntryX(
    ULONG LINE,
    PCHAR FILE
    )
{
    PBGUIDENTRY GuidEntry;
    PKEVENT Event;
	
#if ! DBG
	UNREFERENCED_PARAMETER(LINE);
	UNREFERENCED_PARAMETER(FILE);
#endif
    
    GuidEntry = NULL;
    Event = ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(KEVENT),
                                  WMIPOOLTAG);

    if (Event != NULL)
    {
        GuidEntry = (PBGUIDENTRY)WmipAllocEntry(&WmipGEChunkInfo);
        if (GuidEntry != NULL)
        {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL, "WMI: %p.%p Create GE %p (%x) at %s %d\n", PsGetCurrentProcessId(), PsGetCurrentThreadId(), GuidEntry, GuidEntry->RefCount, FILE, LINE));
                    
            InitializeListHead(&GuidEntry->ISHead);
            InitializeListHead(&GuidEntry->ObjectHead);
            GuidEntry->CollectInProgress = Event;
        } else {
            ExFreePool(Event);
        }
    }

    return(GuidEntry);
}


void WmipISCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
{
    PBINSTANCESET InstanceSet = (PBINSTANCESET)Entry;

    UNREFERENCED_PARAMETER (ChunkInfo);

    WmipAssert(InstanceSet != NULL);
    WmipAssert(InstanceSet->Flags & FLAG_ENTRY_INVALID);

    if (InstanceSet->IsBaseName != NULL)
    {
        WmipFree(InstanceSet->IsBaseName);
        InstanceSet->IsBaseName = NULL;
    }
}

void WmipMRCleanup(
    IN PCHUNKINFO ChunkInfo,
    IN PENTRYHEADER Entry
    )
{
    PMOFRESOURCE MofResource = (PMOFRESOURCE)Entry;

    PAGED_CODE();
    
    UNREFERENCED_PARAMETER (ChunkInfo);

    if ((MofResource->RegistryPath != NULL) &&
        (MofResource->MofResourceName != NULL) &&
        ((MofResource->Flags & MR_FLAG_USER_MODE) != MR_FLAG_USER_MODE))
    {
        WmipGenerateMofResourceNotification(MofResource->RegistryPath,
                                    MofResource->MofResourceName,
                                    &GUID_MOF_RESOURCE_REMOVED_NOTIFICATION,
                                    MofResource->Flags & MR_FLAG_USER_MODE ?
                                             MOFEVENT_ACTION_IMAGE_PATH :
                                             MOFEVENT_ACTION_REGISTRY_PATH);
    }

    if (MofResource->RegistryPath != NULL)
    {
        WmipFree(MofResource->RegistryPath);
        MofResource->RegistryPath = NULL;
    }

    if (MofResource->MofResourceName != NULL)
    {
        WmipFree(MofResource->MofResourceName);
        MofResource->MofResourceName = NULL;
    }
}


PBGUIDENTRY WmipFindGEByGuid(
    LPGUID Guid,
    BOOLEAN MakeTopOfList
    )
/*++

Routine Description:

    Searches guid list for first occurence of guid. Guid's refcount is
    incremented if found.

Arguments:

    Guid is pointer to guid that is to be found

    MakeTopOfList is TRUE then if NE is found it is placed at the top of the
        NE list

Return Value:

    pointer to guid entry pointer or NULL if not found

--*/
{
    PLIST_ENTRY GuidEntryList;
    PBGUIDENTRY GuidEntry;

    WmipEnterSMCritSection();

    GuidEntryList = WmipGEHeadPtr->Flink;
    while (GuidEntryList != WmipGEHeadPtr)
    {
        GuidEntry = CONTAINING_RECORD(GuidEntryList,
                                      GUIDENTRY,
                                      MainGEList);
        if (IsEqualGUID(Guid, &GuidEntry->Guid))
        {
            WmipReferenceGE(GuidEntry);

            if (MakeTopOfList)
            {
                RemoveEntryList(GuidEntryList);
                InsertHeadList(WmipGEHeadPtr, GuidEntryList);
            }

            WmipLeaveSMCritSection();
            WmipAssert(GuidEntry->Signature == GE_SIGNATURE);
            return(GuidEntry);
        }
        GuidEntryList = GuidEntryList->Flink;
    }
    WmipLeaveSMCritSection();
    return(NULL);
}


PBDATASOURCE WmipFindDSByProviderId(
    ULONG_PTR ProviderId
    )
/*++

Routine Description:

    This routine finds a DataSource on the provider id passed. DataSource's
    ref  count is incremented if found

Arguments:

    ProviderId is the data source provider id

Return Value:

    DataSource pointer or NULL if no data source was found

--*/
{
    PLIST_ENTRY DataSourceList;
    PBDATASOURCE DataSource;

    WmipEnterSMCritSection();
    DataSourceList = WmipDSHeadPtr->Flink;
    while (DataSourceList != WmipDSHeadPtr)
    {
        DataSource = CONTAINING_RECORD(DataSourceList,
                                      DATASOURCE,
                                      MainDSList);
        if (DataSource->ProviderId == ProviderId)
        {
            WmipReferenceDS(DataSource);
            WmipLeaveSMCritSection();
            WmipAssert(DataSource->Signature == DS_SIGNATURE);
            return(DataSource);
        }

        DataSourceList = DataSourceList->Flink;
    }
    WmipLeaveSMCritSection();
    return(NULL);
}


PBINSTANCESET WmipFindISByGuid(
    PBDATASOURCE DataSource,
    GUID UNALIGNED *Guid
    )
/*++

Routine Description:

    This routine will find an instance set within a data source list for a
    specific guid. Note that any instance sets that have been replaced
    (have IS_REPLACED_BY_REFERENCE) are ignored and not returned. The
    InstanceSet that is found has its reference count increased.

Arguments:

    DataSource is the data source whose instance set list is searched
    Guid is a pointer to a guid which defines which instance set list to find

Return Value:

    InstanceSet pointer or NULL if not found

--*/
{
    PBINSTANCESET InstanceSet;
    PLIST_ENTRY InstanceSetList;

    WmipEnterSMCritSection();
    InstanceSetList = DataSource->ISHead.Flink;
    while (InstanceSetList != &DataSource->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                      INSTANCESET,
                                      DSISList);
        if (IsEqualGUID(&InstanceSet->GuidEntry->Guid, Guid))
        {
            WmipReferenceIS(InstanceSet);
            WmipLeaveSMCritSection();
            WmipAssert(InstanceSet->Signature == IS_SIGNATURE);
            return(InstanceSet);
        }

        InstanceSetList = InstanceSetList->Flink;
    }
    WmipLeaveSMCritSection();
    return(NULL);
}


PMOFRESOURCE WmipFindMRByNames(
    LPCWSTR ImagePath,
    LPCWSTR MofResourceName
    )
/*++

Routine Description:

    Searches mof resource list for a MR that has the same image path and
    resource name. If ine is found a reference count is added to it.

Arguments:

    ImagePath points at a string that has the full path to the image
        file that contains the MOF resource

    MofResourceName points at a string that has the name of the MOF
        resource

Return Value:

    pointer to mof resource or NULL if not found

--*/
{
    PLIST_ENTRY MofResourceList;
    PMOFRESOURCE MofResource;

    WmipEnterSMCritSection();

    MofResourceList = WmipMRHeadPtr->Flink;
    while (MofResourceList != WmipMRHeadPtr)
    {
        MofResource = CONTAINING_RECORD(MofResourceList,
                                      MOFRESOURCE,
                                      MainMRList);
        if ((wcscmp(MofResource->RegistryPath, ImagePath) == 0) &&
            (wcscmp(MofResource->MofResourceName, MofResourceName) == 0))
        {
            WmipReferenceMR(MofResource);
            WmipLeaveSMCritSection();
            WmipAssert(MofResource->Signature == MR_SIGNATURE);
            return(MofResource);
        }
        MofResourceList = MofResourceList->Flink;
    }
    WmipLeaveSMCritSection();
    return(NULL);
}

BOOLEAN WmipIsNumber(
    LPCWSTR String
    )
{
    while (*String != UNICODE_NULL)
    {
        if ((*String < L'0') || (*String > L'9'))
        {
            return(FALSE);
        }
        String++;
    }
    return(TRUE);
}

PBINSTANCESET WmipFindISinGEbyName(
    PBGUIDENTRY GuidEntry,
    PWCHAR InstanceName,
    PULONG InstanceIndex
    )
/*++

Routine Description:

    This routine finds the instance set containing the instance name passed
    within the GuidEntry passed. If found it will also return the index of
    the instance name within the instance set. The instance set found has its
    ref count incremented.

Arguments:

    GuidEntry contains the instance sets to look through
    InstanceName is the instance name to look for
    *InstanceIndex return instance index within set

Return Value:

    Instance set containing instance name or NULL of instance name not found

--*/
{
    PBINSTANCESET InstanceSet;
    PLIST_ENTRY InstanceSetList;
    SIZE_T BaseNameLen;
    PWCHAR InstanceNamePtr;
    ULONG InstanceNameIndex;
    ULONG InstanceSetFirstIndex, InstanceSetLastIndex;
    ULONG i;

    WmipEnterSMCritSection();
    InstanceSetList = GuidEntry->ISHead.Flink;
    while (InstanceSetList != &GuidEntry->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
        if (InstanceSet->Flags & IS_INSTANCE_BASENAME)
        {
            BaseNameLen = wcslen(InstanceSet->IsBaseName->BaseName);
            if (wcsncmp(InstanceName,
                        InstanceSet->IsBaseName->BaseName,
                        BaseNameLen) == 0)
            {
                InstanceNamePtr = InstanceName + BaseNameLen;
                InstanceNameIndex = _wtoi(InstanceNamePtr);
                InstanceSetFirstIndex = InstanceSet->IsBaseName->BaseIndex;
                InstanceSetLastIndex = InstanceSetFirstIndex + InstanceSet->Count;
                if (( (InstanceNameIndex >= InstanceSetFirstIndex) &&
                      (InstanceNameIndex < InstanceSetLastIndex)) &&
                    ((InstanceNameIndex != 0) || WmipIsNumber(InstanceNamePtr)))
                {
                   InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
                   *InstanceIndex = InstanceNameIndex - InstanceSetFirstIndex;
                   WmipReferenceIS(InstanceSet);
                   WmipAssert(InstanceSet->Signature == IS_SIGNATURE);
                   WmipLeaveSMCritSection();
                   return(InstanceSet);
                }
            }
        } else if (InstanceSet->Flags & IS_INSTANCE_STATICNAMES) {
            for (i = 0; i < InstanceSet->Count; i++)
            {
                if (wcscmp(InstanceName,
                           InstanceSet->IsStaticNames->StaticNamePtr[i]) == 0)
               {
                   InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
                   *InstanceIndex = i;
                   WmipReferenceIS(InstanceSet);
                   WmipAssert(InstanceSet->Signature == IS_SIGNATURE);
                   WmipLeaveSMCritSection();
                   return(InstanceSet);
               }
            }
        }
        InstanceSetList = InstanceSetList->Flink;
    }
    WmipLeaveSMCritSection();
    return(NULL);
}

BOOLEAN WmipRealloc(
    PVOID *Buffer,
    ULONG CurrentSize,
    ULONG NewSize,
    BOOLEAN FreeOriginalBuffer
    )
/*++

Routine Description:

    Reallocate a buffer to a larger size while preserving data

Arguments:

    Buffer on entry has the buffer to be reallocated, on exit has the new
        buffer

    CurrentSize is the current size of the buffer

    NewSize has the new size desired

Return Value:

    TRUE if realloc was successful

--*/
{
    PVOID NewBuffer;

    WmipAssert(NewSize > CurrentSize);

    NewBuffer = WmipAlloc(NewSize);
    if (NewBuffer != NULL)
    {
        memset(NewBuffer, 0, NewSize);
        memcpy(NewBuffer, *Buffer, CurrentSize);
        if (FreeOriginalBuffer)
        {
            WmipFree(*Buffer);
        }
        *Buffer = NewBuffer;
        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfzwapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

   vfzwapi.h

Abstract:

    Zw interfaces verifier.

--*/

#ifndef _VF_ZWAPI_
#define _VF_ZWAPI_


#define DECLARE_ZW_VERIFIER_THUNK(Name) #Name,(PDRIVER_VERIFIER_THUNK_ROUTINE)Vf##Name

//NTSYSAPI
NTSTATUS
NTAPI
VfZwAccessCheckAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ACCESS_MASK DesiredAccess,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwAddBootEntry (
    IN PBOOT_ENTRY BootEntry,
    OUT PULONG Id OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwAddDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry,
    OUT PULONG Id OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwAdjustPrivilegesToken (
    IN HANDLE TokenHandle,
    IN BOOLEAN DisableAllPrivileges,
    IN PTOKEN_PRIVILEGES NewState OPTIONAL,
    IN ULONG BufferLength OPTIONAL,
    OUT PTOKEN_PRIVILEGES PreviousState OPTIONAL,
    OUT PULONG ReturnLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwAlertThread(
    IN HANDLE ThreadHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwAllocateVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwAssignProcessToJobObject(
    IN HANDLE JobHandle,
    IN HANDLE ProcessHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCancelIoFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCancelTimer (
    IN HANDLE TimerHandle,
    OUT PBOOLEAN CurrentState OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwClearEvent (
    IN HANDLE EventHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwClose(
    IN HANDLE Handle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCloseObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN BOOLEAN GenerateOnClose
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwConnectPort(
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT PPORT_VIEW ClientView OPTIONAL,
    IN OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,
    OUT PULONG MaxMessageLength OPTIONAL,
    IN OUT PVOID ConnectionInformation OPTIONAL,
    IN OUT PULONG ConnectionInformationLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateJobObject (
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize OPTIONAL,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PUNICODE_STRING LinkTarget
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN TIMER_TYPE TimerType
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeleteBootEntry (
    IN ULONG Id
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeleteDriverEntry (
    IN ULONG Id
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeleteKey(
    IN HANDLE KeyHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDisplayString(
    IN PUNICODE_STRING String
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDuplicateObject(
    IN HANDLE SourceProcessHandle,
    IN HANDLE SourceHandle,
    IN HANDLE TargetProcessHandle OPTIONAL,
    OUT PHANDLE TargetHandle OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDuplicateToken(
    IN HANDLE ExistingTokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN EffectiveOnly,
    IN TOKEN_TYPE TokenType,
    OUT PHANDLE NewTokenHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwEnumerateBootEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwEnumerateDriverEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwFlushInstructionCache (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress OPTIONAL,
    IN SIZE_T Length
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwFlushKey(
    IN HANDLE KeyHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwFlushVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    OUT PIO_STATUS_BLOCK IoStatus
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwFsControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FsControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwInitiatePowerAction(
    IN POWER_ACTION SystemAction,
    IN SYSTEM_POWER_STATE MinSystemState,
    IN ULONG Flags,                 // POWER_ACTION_xxx flags
    IN BOOLEAN Asynchronous
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwIsProcessInJob (
    IN HANDLE ProcessHandle,
    IN HANDLE JobHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwLoadKey(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwMakeTemporaryObject(
    IN HANDLE Handle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwMapViewOfSection(
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwModifyBootEntry (
    IN PBOOT_ENTRY BootEntry
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwModifyDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwNotifyChangeKey(
    IN HANDLE KeyHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenJobObject(
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenProcessToken(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE TokenHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenProcessTokenEx(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenSection(
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenThread (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenThreadToken(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    OUT PHANDLE TokenHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenThreadTokenEx(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwPowerInformation(
    IN POWER_INFORMATION_LEVEL InformationLevel,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwPulseEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryBootEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryBootOptions (
    OUT PBOOT_OPTIONS BootOptions,
    IN OUT PULONG BootOptionsLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryDefaultLocale(
    IN BOOLEAN UserProfile,
    OUT PLCID DefaultLocaleId
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryDefaultUILanguage(
    OUT LANGID *DefaultUILanguageId
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryDirectoryObject(
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryDriverEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryEaFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID EaList OPTIONAL,
    IN ULONG EaListLength,
    IN PULONG EaIndex OPTIONAL,
    IN BOOLEAN RestartScan
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryFullAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInformationJobObject(
    IN HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    OUT PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInformationToken (
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    OUT PVOID TokenInformation,
    IN ULONG TokenInformationLength,
    OUT PULONG ReturnLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInstallUILanguage(
    OUT LANGID *InstallUILanguageId
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryObject(
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    OUT PVOID ObjectInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQuerySection(
    IN HANDLE SectionHandle,
    IN SECTION_INFORMATION_CLASS SectionInformationClass,
    OUT PVOID SectionInformation,
    IN SIZE_T SectionInformationLength,
    OUT PSIZE_T ReturnLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQuerySecurityObject(
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Length,
    OUT PULONG LengthNeeded
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQuerySymbolicLinkObject(
    IN HANDLE LinkHandle,
    IN OUT PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQuerySystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwReplaceKey(
    IN POBJECT_ATTRIBUTES NewFile,
    IN HANDLE             TargetHandle,
    IN POBJECT_ATTRIBUTES OldFile
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwRequestWaitReplyPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwResetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwRestoreKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG  Flags
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSaveKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSaveKeyEx(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG  Format
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetBootEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetBootOptions (
    IN PBOOT_OPTIONS BootOptions,
    IN ULONG FieldsToChange
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetDefaultLocale(
    IN BOOLEAN UserProfile,
    IN LCID DefaultLocaleId
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetDefaultUILanguage(
    IN LANGID DefaultUILanguageId
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetDriverEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetEaFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetInformationJobObject(
    IN HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    IN PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetInformationObject(
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    IN PVOID ObjectInformation,
    IN ULONG ObjectInformationLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetSecurityObject(
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetSystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetSystemTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER PreviousTime OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetTimer (
    IN HANDLE TimerHandle,
    IN PLARGE_INTEGER DueTime,
    IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL,
    IN PVOID TimerContext OPTIONAL,
    IN BOOLEAN ResumeTimer,
    IN LONG Period OPTIONAL,
    OUT PBOOLEAN PreviousState OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwTerminateJobObject(
    IN HANDLE JobHandle,
    IN NTSTATUS ExitStatus
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwTerminateProcess(
    IN HANDLE ProcessHandle OPTIONAL,
    IN NTSTATUS ExitStatus
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwTranslateFilePath (
    IN PFILE_PATH InputFilePath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputFilePath,
    IN OUT PULONG OutputFilePathLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwUnloadDriver(
    IN PUNICODE_STRING DriverServiceName
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwUnloadKey(
    IN POBJECT_ATTRIBUTES TargetKey
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwUnmapViewOfSection(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwWaitForMultipleObjects(
    IN ULONG Count,
    IN HANDLE Handles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwYieldExecution (
    VOID
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\VERIFIER\vfwmi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vfwmi.h

Abstract:

    This header contains prototypes for verifying System Control IRPs are
    handled correctly.

--*/

VOID
VfWmiInit(
    VOID
    );

VOID
FASTCALL
VfWmiVerifyNewRequest(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

VOID
FASTCALL
VfWmiVerifyIrpStackDownward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp                   OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress               OPTIONAL
    );

VOID
FASTCALL
VfWmiVerifyIrpStackUpward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN BOOLEAN              IsNewlyCompleted,
    IN BOOLEAN              RequestFinalized
    );

VOID
FASTCALL
VfWmiDumpIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
FASTCALL
VfWmiTestStartedPdoStack(
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\api.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    api.c

Abstract:

    Api entrypoints to WMI

--*/

#include "wmikmp.h"
#include "evntrace.h"
#include "tracep.h"

BOOLEAN WMIInitialize(
    ULONG Phase,
    PVOID LoaderBlock
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,WMIInitialize)
#pragma alloc_text(PAGE,IoWMIRegistrationControl)
#pragma alloc_text(PAGE,IoWMIAllocateInstanceIds)
#pragma alloc_text(PAGE,IoWMISuggestInstanceName)

#pragma alloc_text(PAGE,IoWMIOpenBlock)
#pragma alloc_text(PAGE,IoWMIQueryAllData)
#pragma alloc_text(PAGE,IoWMIQueryAllDataMultiple)
#pragma alloc_text(PAGE,IoWMIQuerySingleInstance)
#pragma alloc_text(PAGE,IoWMIQuerySingleInstanceMultiple)
#pragma alloc_text(PAGE,IoWMISetSingleInstance)
#pragma alloc_text(PAGE,IoWMISetSingleItem)
#pragma alloc_text(PAGE,IoWMISetNotificationCallback)
#pragma alloc_text(PAGE,IoWMIExecuteMethod)
#pragma alloc_text(PAGE,IoWMIHandleToInstanceName)
#pragma alloc_text(PAGE,IoWMIDeviceObjectToInstanceName)
#endif

    //
    // Mutex used to ensure single access to InstanceId chunks
PINSTIDCHUNK WmipInstIdChunkHead;

NTSTATUS
WmipDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

BOOLEAN WMIInitialize(
    ULONG Phase,
    PVOID LoaderBlockPtr
)
/*++

Routine Description:

    This routine is the initialization routine for WMI and is called by IO
    within IoInitSystem on NT.  This routine assumes that the
    IO system is initialized enough to call IoCreateDriver. The rest of the
    initialization occurs in the DriverEntry routine.

Arguments:

    Pass specifies the pass of initialization needed

Return Value:

    TRUE if initialization was successful

--*/
{
//
// We name the driver this so that any eventlogs fired will have the
// source name WMIxWDM and thus get the eventlog messages from
// ntiologc.mc
//
#define WMIDRIVERNAME L"\\Driver\\WMIxWDM"

    UNICODE_STRING DriverName;
    NTSTATUS Status;

#if !DBG
    UNREFERENCED_PARAMETER (LoaderBlockPtr);
#endif

    if (Phase == 0)
    {
        WmipAssert(WmipServiceDeviceObject == NULL);
        WmipAssert(LoaderBlockPtr != NULL);

        RtlInitUnicodeString(&DriverName, WMIDRIVERNAME);
        Status = IoCreateDriver(&DriverName, WmipDriverEntry);

    } else {
        WmipAssert(LoaderBlockPtr == NULL);
        
        WmipInitializeRegistration(Phase);
        WmipRegisterFirmwareProviders();

        Status = STATUS_SUCCESS;
    }

#if defined(_X86_) || defined(_AMD64_)
    //
    // Give MCA a chance to init during phase 0 and 1
    //
    WmipRegisterMcaHandler(Phase);
#endif      
    
    return(NT_SUCCESS(Status) ? TRUE : FALSE);
}

NTSTATUS IoWMIRegistrationControl(
    __in PDEVICE_OBJECT DeviceObject,
    __in ULONG Action
)
/*++

Routine Description:

    This routine informs WMI of the existence and disappearance of a device
    object that would support WMI.

Arguments:

    DeviceObject - Pointer to device object  or callback address

    Action - Registration action code

        WMIREG_ACTION_REGISTER - If set action is to inform WMI that the
            device object supports and is ready to receive WMI IRPS.

        WMIREG_ACTION_DEREGISTER - If set action is to inform WMI that the
            device object no longer supports and is not ready to receive WMI
            IRPS.

        WMIREG_ACTION_REREGISTER - If set action is to requery the device
            object for the guids that it supports. This has the effect of
            deregistering followed by registering.

        WMIREG_ACTION_UPDATE_GUIDS - If set action is to query for information
            that is used to update already registered guids.

        WMIREG_ACTION_BLOCK_IRPS - If set action is to block any further irps
            from being sent to the device. The irps are failed by WMI.

        If the  WMIREG_FLAG_CALLBACK is set then DeviceObject actually specifies a callback
            address and not a DeviceObject

Return Value:

    Returns status code

--*/
{
    NTSTATUS Status;
    ULONG RegistrationFlag = 0;
    ULONG IsTraceProvider = FALSE;
    ULONG TraceClass = 0;
    PREGENTRY RegEntry;

    PAGED_CODE();

    if (WmipIsWmiNotSetupProperly())
    {
        return(STATUS_UNSUCCESSFUL);
    }

    if (Action & WMIREG_FLAG_CALLBACK)
    {
        RegistrationFlag |= WMIREG_FLAG_CALLBACK;
        Action &= ~WMIREG_FLAG_CALLBACK;
    }

    if (Action & WMIREG_FLAG_TRACE_PROVIDER)
    {
        TraceClass = Action & WMIREG_FLAG_TRACE_NOTIFY_MASK;

        Action &= ~WMIREG_FLAG_TRACE_PROVIDER & ~WMIREG_FLAG_TRACE_NOTIFY_MASK;
        IsTraceProvider = TRUE;
        RegistrationFlag |= WMIREG_FLAG_TRACE_PROVIDER | TraceClass;
    }

    switch(Action)
    {
        case WMIREG_ACTION_REGISTER:
        {
            Status = WmipRegisterDevice(
                        DeviceObject,
                        RegistrationFlag);

            if (IsTraceProvider)
            {
                WmipSetTraceNotify(DeviceObject, TraceClass, TRUE);
            }
            break;
        }

        case WMIREG_ACTION_DEREGISTER:
        {
            Status = WmipDeregisterDevice(DeviceObject);
            break;
        }

        case WMIREG_ACTION_REREGISTER:
        {
            Status = WmipDeregisterDevice(DeviceObject);
            if (NT_SUCCESS(Status))
            {
                Status = WmipRegisterDevice(
                            DeviceObject,
                            RegistrationFlag);
            }
            break;
        }

        case WMIREG_ACTION_UPDATE_GUIDS:
        {
            Status = WmipUpdateRegistration(DeviceObject);
            break;
        }

        case WMIREG_ACTION_BLOCK_IRPS:
        {
            RegEntry = WmipFindRegEntryByDevice(DeviceObject, FALSE);
            if (RegEntry != NULL)
            {
                //
                // Mark the regentry as invalid so that no more irps
                // are sent to the device and the event will set when
                // the last irp completes.
                WmipEnterSMCritSection();
                RegEntry->Flags |= REGENTRY_FLAG_NOT_ACCEPTING_IRPS;
                WmipLeaveSMCritSection();
                WmipUnreferenceRegEntry(RegEntry);
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }

            break;
        }
        default:
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
    }
    return(Status);
}


NTSTATUS IoWMIAllocateInstanceIds(
    __in GUID *Guid,
    __in ULONG InstanceCount,
    __out ULONG *FirstInstanceId
    )
/*++

    Routine Description:

    This routine allocates a range of instance ids that are unique to the
    guid. This routine is to be called only at PASSIVE_LEVEL.

    Arguments:

        Guid - Pointer to guid for which instance ids are needed.
        InstanceCount - Count of instance ids to allocate.
        *FirstInstanceId - Returns first instance id in the range.

    Return Value:

        Returns a status code

--*/
{
    PINSTIDCHUNK InstIdChunk, LastInstIdChunk = NULL;
    PINSTID InstId;
    ULONG i;

    PAGED_CODE();

    if (WmipIsWmiNotSetupProperly())
    {
        return(STATUS_UNSUCCESSFUL);
    }

    WmipEnterSMCritSection();

    //
    // See if the guid is already in the list
    InstIdChunk = WmipInstIdChunkHead;

    while (InstIdChunk != NULL)
    {
        for (i = 0; i < INSTIDSPERCHUNK; i++)
        {
            InstId = &InstIdChunk->InstId[i];
            if (InstId->BaseId == ~0)
            {
                //
                // Since InstIds are always filled sequentially and are
                // never freed, if we hit a free one then we know that
                // our guid is not in the list and we need to fill in a
                // new entry.
                goto FillInstId;
            }

            if (IsEqualGUID(Guid, &InstId->Guid))
            {
                //
                // We found an entry for our guid so use its information
                *FirstInstanceId = InstId->BaseId;
                InstId->BaseId += InstanceCount;
                WmipLeaveSMCritSection();
                return(STATUS_SUCCESS);
            }
        }
        LastInstIdChunk = InstIdChunk;
        InstIdChunk = InstIdChunk->Next;
    }

    //
    // We need to allocate a brand new chunk to accommodate the entry
    InstIdChunk = ExAllocatePoolWithTag(PagedPool,
                                        sizeof(INSTIDCHUNK),
                                        WMIIIPOOLTAG);
    if (InstIdChunk != NULL)
    {
        RtlFillMemory(InstIdChunk, sizeof(INSTIDCHUNK), 0xff);
        InstIdChunk->Next = NULL;
        if (LastInstIdChunk == NULL)
        {
            WmipInstIdChunkHead = InstIdChunk;
        } else {
            LastInstIdChunk->Next = InstIdChunk;
        }

        InstId = &InstIdChunk->InstId[0];
    } else {
        WmipLeaveSMCritSection();
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

FillInstId:
    RtlCopyMemory(&InstId->Guid, Guid, sizeof(GUID));
    InstId->BaseId = InstanceCount;
    WmipLeaveSMCritSection();
    *FirstInstanceId = 0;

    return(STATUS_SUCCESS);
}

NTSTATUS IoWMISuggestInstanceName(
    __in_opt PDEVICE_OBJECT PhysicalDeviceObject,
    __in_opt PUNICODE_STRING SymbolicLinkName,
    __in BOOLEAN CombineNames,
    __out PUNICODE_STRING SuggestedInstanceName
    )
/*++

    Routine Description:

    This routine is used by a device driver to suggest a base name with which
    to build WMI instance names for the device. A driver is not bound to
    follow the instance name returned.

    Arguments:

    PhysicalDeviceObject - PDO of device for which a suggested instance name
        is being requested

    SymbolicLinkName - Symbolic link name returned from
        IoRegisterDeviceInterface.

    CombineNames - If TRUE then the suggested names arising from the
        PhysicalDeviceObject and the SymbolicLinkName are combined to create
        the resultant suggested name.

    SuggestedInstanceName - Supplies a pointer to an empty (i.e., Buffer
        field set to NULL) UNICODE_STRING structure which, upon success, will
        be set to a newly-allocated string buffer containing the suggested
        instance name.  The caller is responsible for freeing
        SuggestedInstanceName->Buffer when it is no longer needed.


    Note:  If CombineNames is TRUE then both PhysicalDeviceObject and
           SymbolicLinkName must be specified. Otherwise only one of them
           must be specified.

    Return Value:

        Returns a status code

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER_MIX;
    ULONG DeviceDescSizeRequired;
    ULONG DeviceDescSize;
    PWCHAR DeviceDescBuffer;
    HANDLE DeviceInstanceKey;
    PKEY_VALUE_FULL_INFORMATION InfoBuffer;
    PWCHAR SymLinkDescBuffer;
    ULONG InfoSizeRequired;
    ULONG ResultDescSize;
    PWCHAR ResultDescBuffer;
    UNICODE_STRING DefaultValue;

    PAGED_CODE();

    if (WmipIsWmiNotSetupProperly())
    {
        return(STATUS_UNSUCCESSFUL);
    }

    DeviceDescBuffer = NULL;
    DeviceDescSizeRequired = 0;
    DeviceDescSize = 0;
    
    if (PhysicalDeviceObject != NULL)
    {
        Status = IoGetDeviceProperty(PhysicalDeviceObject,
                                     DevicePropertyDeviceDescription,
                                     DeviceDescSize,
                                     DeviceDescBuffer,
                                     &DeviceDescSizeRequired);

        if (Status == STATUS_BUFFER_TOO_SMALL)
        {
            DeviceDescBuffer = ExAllocatePoolWithTag(PagedPool,
                                                     DeviceDescSizeRequired,
                                                     WMIPOOLTAG);
            if (DeviceDescBuffer == NULL)
            {
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
 
            DeviceDescSize = DeviceDescSizeRequired;
            Status = IoGetDeviceProperty(PhysicalDeviceObject,
                                     DevicePropertyDeviceDescription,
                                     DeviceDescSize,
                                     DeviceDescBuffer,
                                     &DeviceDescSizeRequired);
            if (! NT_SUCCESS(Status))
            {
                ExFreePool(DeviceDescBuffer);
                return(Status);
            }
        } else if (! NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    if (SymbolicLinkName != NULL)
    {
        Status = IoOpenDeviceInterfaceRegistryKey(SymbolicLinkName,
                                                  KEY_ALL_ACCESS,
                                                  &DeviceInstanceKey);
        if (NT_SUCCESS(Status))
        {
            //
            // Figure out how big the data value is so that a buffer of the
            // appropriate size can be allocated.
            DefaultValue.Length = 0;
            DefaultValue.MaximumLength= 0;
            DefaultValue.Buffer = NULL;
            Status = ZwQueryValueKey( DeviceInstanceKey,
                              &DefaultValue,
                              KeyValueFullInformation,
                              (PVOID) NULL,
                              0,
                              &InfoSizeRequired );
            if (Status == STATUS_BUFFER_OVERFLOW ||
                Status == STATUS_BUFFER_TOO_SMALL)
            {
                InfoBuffer = ExAllocatePoolWithTag(PagedPool,
                                            InfoSizeRequired,
                                            WMIPOOLTAG);
                if (InfoBuffer != NULL)
                {
                    Status = ZwQueryValueKey(DeviceInstanceKey,
                                             &DefaultValue,
                                             KeyValueFullInformation,
                                             InfoBuffer,
                                             InfoSizeRequired,
                                             &InfoSizeRequired);
                    if (NT_SUCCESS(Status))
                    {
                        SymLinkDescBuffer = (PWCHAR)((PCHAR)InfoBuffer + InfoBuffer->DataOffset);
                        if (CombineNames)
                        {
                            ResultDescSize = InfoBuffer->DataLength +
                                                    DeviceDescSizeRequired +
                                                    sizeof(WCHAR);
                            ResultDescBuffer = ExAllocatePoolWithTag(PagedPool,
                                                              ResultDescSize,
                                                              WMIPOOLTAG);
                            if (ResultDescBuffer == NULL)
                            {
                                Status = STATUS_INSUFFICIENT_RESOURCES;
                            } else {
                                SuggestedInstanceName->Buffer = ResultDescBuffer;
                                SuggestedInstanceName->Length =  0;
                                SuggestedInstanceName->MaximumLength = (USHORT)ResultDescSize;
                                if (DeviceDescBuffer != NULL)
                                {
                                    RtlAppendUnicodeToString(SuggestedInstanceName,
                                                             DeviceDescBuffer);
                                }
                                RtlAppendUnicodeToString(SuggestedInstanceName,
                                                         L"_");
                                RtlAppendUnicodeToString(SuggestedInstanceName,
                                                         SymLinkDescBuffer);

                            }
                            if (DeviceDescBuffer != NULL)
                            {
                                ExFreePool(DeviceDescBuffer);
                                DeviceDescBuffer= NULL;
                            }
                        } else {
                            if (DeviceDescBuffer != NULL)
                            {
                                ExFreePool(DeviceDescBuffer);
                                DeviceDescBuffer = NULL;
                            }
                            ResultDescBuffer = ExAllocatePoolWithTag(PagedPool,
                                                    InfoBuffer->DataLength,
                                                    WMIPOOLTAG);
                            if (ResultDescBuffer == NULL)
                            {
                                Status = STATUS_INSUFFICIENT_RESOURCES;
                            } else {
                                SuggestedInstanceName->Buffer = ResultDescBuffer;
                                SuggestedInstanceName->Length =  0;
                                SuggestedInstanceName->MaximumLength = (USHORT)InfoBuffer->DataLength;
                                RtlAppendUnicodeToString(SuggestedInstanceName,
                                                         SymLinkDescBuffer);
                            }

                        }
                    }

                    ExFreePool(InfoBuffer);
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            ZwClose(DeviceInstanceKey);
        }

        if ((DeviceDescBuffer != NULL) && (! NT_SUCCESS(Status)))
        {
            ExFreePool(DeviceDescBuffer);
        }
    } else {
        if (DeviceDescBuffer != NULL)
        {
            //
            // Only looking for device description from PDO
            SuggestedInstanceName->Buffer = DeviceDescBuffer;
            SuggestedInstanceName->Length =  (USHORT)DeviceDescSizeRequired - sizeof(WCHAR);
            SuggestedInstanceName->MaximumLength =  (USHORT)DeviceDescSize;
        } else {
            SuggestedInstanceName->Buffer = NULL;
            SuggestedInstanceName->Length =  (USHORT)0;
            SuggestedInstanceName->MaximumLength =  0;
        }
    }

    return(Status);
}

NTSTATUS IoWMIWriteEvent(
    __inout PVOID WnodeEventItem
    )
/*++

Routine Description:

    This routine will queue the passed WNODE_EVENT_ITEM for delivery to the
    WMI user mode agent. Once the event is delivered the WNODE_EVENT_ITEM
    buffer will be returned to the pool.

    This routine may be called at DPC level

Arguments:

    WnodeEventItem - Pointer to WNODE_EVENT_ITEM that has event information.

Return Value:

    Returns STATUS_SUCCESS or an error code

--*/
{
    NTSTATUS Status;
    PWNODE_HEADER WnodeHeader = (PWNODE_HEADER)WnodeEventItem;
    PULONG TraceMarker = (PULONG) WnodeHeader;
    KIRQL OldIrql;
    PREGENTRY RegEntry;
    PEVENTWORKCONTEXT EventContext;
    ULONG ProviderId;

    if (WmipIsWmiNotSetupProperly())
    {
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Special mode with high order bit set
    //
    if ((*TraceMarker & 0xC0000000) == TRACE_HEADER_FLAG)
    {
        return WmiTraceFastEvent(WnodeHeader);
    }

    if ( (WnodeHeader->Flags & WNODE_FLAG_TRACED_GUID) ||
         (WnodeHeader->Flags & WNODE_FLAG_LOG_WNODE) )
    {
        ULONG LoggerId = WmiGetLoggerId(WnodeHeader->HistoricalContext);
        ULONG IsTrace = WnodeHeader->Flags & WNODE_FLAG_TRACED_GUID;
        ULONG SavedSize = WnodeHeader->BufferSize;
        PULONG TraceMarker = (PULONG) WnodeHeader;

        if (SavedSize < sizeof(WNODE_HEADER))
            return STATUS_BUFFER_TOO_SMALL;

        //
        // If trace header, turn higher bit on and support
        // only full header
        //
        if (IsTrace)
        {
            if (SavedSize > 0XFFFF)    // restrict to USHORT max size
                return STATUS_BUFFER_OVERFLOW;

            *TraceMarker |= TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE |
                            (TRACE_HEADER_TYPE_FULL_HEADER << 16);
        }
        else
        {
            if (SavedSize & TRACE_HEADER_FLAG)
                return STATUS_BUFFER_OVERFLOW;
        }

        Status = STATUS_INVALID_HANDLE;
        if (LoggerId > 0 && LoggerId < MAXLOGGERS)
        {
            if (WmipLoggerContext[LoggerId] != NULL)
            {
                //
                // NOTE: The rule here is that IoWMIWriteEvent is always
                // called in kernel mode, and the buffer needs not be probed!
                //
                Status = WmiTraceEvent(WnodeHeader, KernelMode);
            }
        }
        // NOTE: If it is a trace, we will not go any further
        // Otherwise, if it is a regular WMI event, it will still
        // be processed by WMI.

        if (IsTrace)
        {
            WnodeHeader->BufferSize = SavedSize;
            return Status;
        }
    }

    //
    // Memory for event buffers is limited so the size of any event is also
    // limited.
#if DBG
    if (WnodeHeader->BufferSize > LARGEKMWNODEEVENTSIZE)
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_EVENT_INFO_LEVEL,
                          "WMI: Large event %p fired by %x via WMI\n",
                 WnodeEventItem,
                 ((PWNODE_HEADER)WnodeEventItem)->ProviderId));
    }
#endif

    if (WnodeHeader->BufferSize <= WmipMaxKmWnodeEventSize)
    {

        EventContext = ExAllocatePoolWithTag(NonPagedPool,
                                             sizeof(EVENTWORKCONTEXT),
                                             WMINWPOOLTAG);
        if (EventContext != NULL)
        {       
            //
            // Try to take a refcount on the regentry associated with the
            // provider id in the event. If we are successful then we set a
            // flag in the wnode header saying so. When processing the
            // event in the work item we check the flag and if it is set
            // we'll go looking for the regentry on the active and zombie
            // lists and then use it. At that time it will give up the ref
            // count taken here so that if the regentry really is a zombie
            // then it will go away peacefully.
            //

            ProviderId = WnodeHeader->ProviderId;
            KeAcquireSpinLock(&WmipRegistrationSpinLock,
                              &OldIrql);

            RegEntry = WmipDoFindRegEntryByProviderId(ProviderId,
                                                      REGENTRY_FLAG_RUNDOWN);
            if (RegEntry != NULL)
            {
                WmipReferenceRegEntry(RegEntry);
            }

            KeReleaseSpinLock(&WmipRegistrationSpinLock,
                          OldIrql);                 

            WnodeHeader->ClientContext = WnodeHeader->Version;

            EventContext->RegEntry = RegEntry;
            EventContext->Wnode = WnodeHeader;
            
            ExInterlockedInsertTailList(
                &WmipNPEvent,
                &EventContext->ListEntry,
                &WmipNPNotificationSpinlock);
            //
            // If the queue was empty then there was no work item outstanding
            // to move from non paged to paged memory. So fire up a work item
            // to do so.
            if (InterlockedIncrement(&WmipEventWorkItems) == 1)
            {
                ExQueueWorkItem( &WmipEventWorkQueueItem, DelayedWorkQueue );
            }
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        Status = STATUS_BUFFER_OVERFLOW;
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_EVENT_INFO_LEVEL,
                          "WMI: IoWMIWriteEvent detected an event %p fired by %x that exceeds the maximum event size\n",
                             WnodeEventItem,
                             ((PWNODE_HEADER)WnodeEventItem)->ProviderId));
    }

    return(Status);
}

// IoWMIDeviceObjectToProviderId is in register.c

NTSTATUS IoWMIOpenBlock(
    __in GUID *Guid,
    __in ULONG DesiredAccess,
    __out PVOID *DataBlockObject
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR ObjectName[WmiGuidObjectNameLength+1];
    UNICODE_STRING ObjectString;
    ULONG Ioctl;
    NTSTATUS Status;
    HANDLE DataBlockHandle;
    
    PAGED_CODE();
    
    //
    // Establish the OBJECT_ATTRIBUTES for the guid object
    //
    StringCchCopyW(ObjectName, WmiGuidObjectNameLength+1, WmiGuidObjectDirectory);
    StringCchPrintfW(&ObjectName[WmiGuidObjectDirectoryLength-1],
                         WmiGuidObjectNameLength-8,
                         L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                         Guid->Data1, Guid->Data2, 
                         Guid->Data3,
                         Guid->Data4[0], Guid->Data4[1],
                         Guid->Data4[2], Guid->Data4[3],
                         Guid->Data4[4], Guid->Data4[5],
                         Guid->Data4[6], Guid->Data4[7]);
                     
    RtlInitUnicodeString(&ObjectString, ObjectName);
    
    RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.ObjectName = &ObjectString;
    ObjectAttributes.Attributes = OBJ_KERNEL_HANDLE;
    
    if (DesiredAccess & WMIGUID_NOTIFICATION)
    {
        Ioctl = IOCTL_WMI_OPEN_GUID_FOR_EVENTS;
    } else if (DesiredAccess & WRITE_DAC) {
        Ioctl = IOCTL_WMI_OPEN_GUID;
    } else {
        Ioctl = IOCTL_WMI_OPEN_GUID_FOR_QUERYSET;
    }
    
    Status = WmipOpenBlock(Ioctl,
                           KernelMode,
                           &ObjectAttributes,
                           DesiredAccess,
                           &DataBlockHandle);

    if (NT_SUCCESS(Status))
    {
        Status = ObReferenceObjectByHandle(DataBlockHandle,
                                           DesiredAccess,
                                           WmipGuidObjectType,
                                           KernelMode,
                                           DataBlockObject,
                                           NULL);
        ZwClose(DataBlockHandle);
    }
    
    return(Status);                           
}


//
// Useful macro to establish a WNODE_HEADER quickly
#define WmipBuildWnodeHeader(Wnode, WnodeSize, FlagsUlong, Handle) { \
    ((PWNODE_HEADER)(Wnode))->Flags = FlagsUlong;                    \
    ((PWNODE_HEADER)(Wnode))->KernelHandle = Handle;                 \
    ((PWNODE_HEADER)(Wnode))->BufferSize = WnodeSize;                \
    ((PWNODE_HEADER)(Wnode))->Linkage = 0;                           \
}

NTSTATUS IoWMIQueryAllData(
    __in PVOID DataBlockObject,
    __inout ULONG *InOutBufferSize,
    __out_bcount_opt(*InOutBufferSize) /* non paged */ PVOID OutBuffer
)
{
    NTSTATUS Status;    
    WNODE_ALL_DATA WnodeAD;
    ULONG WnodeSize;
    ULONG RetSize;
    PWNODE_ALL_DATA Wnode;
    
    PAGED_CODE();
    
    //
    // See if the caller passed a buffer that is large enough
    //
    WnodeSize = *InOutBufferSize;   
    Wnode = (PWNODE_ALL_DATA)OutBuffer;
    if ((Wnode == NULL) || (WnodeSize < sizeof(WNODE_ALL_DATA)))
    {
        Wnode = &WnodeAD;
        WnodeSize = sizeof(WnodeAD);
    }
    
    //
    // Initialize buffer for query
    //
    WmipBuildWnodeHeader(Wnode,
                         sizeof(WNODE_HEADER),
                         WNODE_FLAG_ALL_DATA,
                         NULL);
        
    Status = WmipQueryAllData(DataBlockObject,
                              NULL,
                              KernelMode,
                              Wnode,
                              WnodeSize,
                              &RetSize);
                                  
    //
    // if this was a successful query then extract the results
    //
    if (NT_SUCCESS(Status))
    {
        if (Wnode->WnodeHeader.Flags & WNODE_FLAG_INTERNAL)
        {
            //
            // Internal guids are not supported in KM
            //
            Status = STATUS_NOT_SUPPORTED;
        } else if (Wnode->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL) {
            //
            // Buffer passed was too small for provider
            //
            *InOutBufferSize = ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded;
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            //
            // Buffer was large enough for provider
            //
            *InOutBufferSize = RetSize;
            
            if (Wnode == &WnodeAD)
            {
                //
                // Although there was enough room for the provider,
                // the caller didn't pass a large enough buffer
                // so we need to return a buffer too small error
                //
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    }   
    
    return(Status);
}


NTSTATUS
IoWMIQueryAllDataMultiple(
    __in_ecount(ObjectCount) PVOID *DataBlockObjectList,
    __in ULONG ObjectCount,
    __inout ULONG *InOutBufferSize,
    __out_bcount_opt(*InOutBufferSize) PVOID OutBuffer
)
{
    NTSTATUS Status;
    WNODE_ALL_DATA WnodeAD;
    PWNODE_HEADER Wnode;
    ULONG WnodeSize;
    ULONG RetSize;

    PAGED_CODE();

    if (!ARGUMENT_PRESENT(DataBlockObjectList) ||
        (ObjectCount == 0) ||
        !ARGUMENT_PRESENT(InOutBufferSize)) {

        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    //
    // Make sure we have an output buffer
    //
    WnodeSize = *InOutBufferSize;   
    Wnode = (PWNODE_HEADER)OutBuffer;
    if ((Wnode == NULL) || (WnodeSize < sizeof(WNODE_ALL_DATA)))
    {
        Wnode = (PWNODE_HEADER)&WnodeAD;
        WnodeSize = sizeof(WnodeAD);
    }
    
    Status = WmipQueryAllDataMultiple(ObjectCount,
                                      (PWMIGUIDOBJECT *)DataBlockObjectList,
                                      NULL,
                                      KernelMode,
                                      (PUCHAR)Wnode,
                                      WnodeSize,
                                      NULL,
                                      &RetSize);
    //
    // if this was a successful query then extract the results
    //
    if (NT_SUCCESS(Status))
    {
        if (Wnode->Flags & WNODE_FLAG_TOO_SMALL)
        {
            //
            // Buffer passed to provider was too small
            //
            *InOutBufferSize = ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded;
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            //
            // Buffer was large enough for provider
            //
            *InOutBufferSize = RetSize;
            
            if (Wnode == (PWNODE_HEADER)&WnodeAD)
            {
                //
                // Although there was enough room for the provider,
                // the caller didn't pass a large enough buffer
                // so we need to return a buffer too small error
                //
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    }

Exit:
    
    return(Status);
}


NTSTATUS
IoWMIQuerySingleInstance(
    __in PVOID DataBlockObject,
    __in PUNICODE_STRING InstanceName,
    __inout ULONG *InOutBufferSize,
    __out_bcount_opt(*InOutBufferSize) PVOID OutBuffer
)
{
    NTSTATUS Status;
    PWNODE_SINGLE_INSTANCE WnodeSI;
    ULONG WnodeSize;
    PWCHAR WPtr;
    ULONG SizeNeeded;
    ULONG RetSize;

    PAGED_CODE();
    
    //
    // Make sure we have an output buffer
    //
    SizeNeeded = (FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                 VariableData) +
                   InstanceName->Length +
                   sizeof(USHORT) + 7) & ~7;


    WnodeSize = *InOutBufferSize;   
    WnodeSI = (PWNODE_SINGLE_INSTANCE)OutBuffer;
    if ((WnodeSI == NULL) || (WnodeSize < SizeNeeded))
    {
        WnodeSI = (PWNODE_SINGLE_INSTANCE)WmipAllocNP(SizeNeeded);
        WnodeSize = SizeNeeded;
    }
            
    if (WnodeSI != NULL)
    {
        //
        // Build WNODE_SINGLE_INSTANCE appropriately and query
        //
        RtlZeroMemory(WnodeSI, FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                          VariableData));
                                      
        WmipBuildWnodeHeader(WnodeSI,
                             SizeNeeded,
                             WNODE_FLAG_SINGLE_INSTANCE,
                             NULL);

        WnodeSI->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                 VariableData);
        WnodeSI->DataBlockOffset = SizeNeeded;

        //
        // Copy InstanceName into the WnodeSingleInstance for the
        // query. Instance name takes a USHORT Length and then followed
        // by a string.
        //
        WPtr = (PWCHAR)OffsetToPtr(WnodeSI, WnodeSI->OffsetInstanceName);
        *WPtr++ = InstanceName->Length;
        RtlCopyMemory(WPtr, InstanceName->Buffer, InstanceName->Length);
                    
        
        Status = WmipQuerySetExecuteSI((PWMIGUIDOBJECT)DataBlockObject,
                                       NULL,
                                       KernelMode,
                                       IRP_MN_QUERY_SINGLE_INSTANCE,
                                       (PWNODE_HEADER)WnodeSI,
                                       WnodeSize,
                                       &RetSize);
    
        //
        // if this was a successful query then extract the results
        //
        if (NT_SUCCESS(Status))
        {
            if (WnodeSI->WnodeHeader.Flags & WNODE_FLAG_INTERNAL)
            {
                //
                // Internal guids are not supported in KM
                //
                Status = STATUS_NOT_SUPPORTED;
            } else if (WnodeSI->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL) {
                //
                // Our buffer was too small
                //
                *InOutBufferSize = ((PWNODE_TOO_SMALL)WnodeSI)->SizeNeeded;
                Status = STATUS_BUFFER_TOO_SMALL;
            } else {
                //
                // Buffer not too small, remember output size
                //
                *InOutBufferSize = RetSize;
                
                if (WnodeSI != OutBuffer)
                {
                    //
                    // Although there was enough room for the provider,
                    // the caller didn't pass a large enough buffer
                    // so we need to return a buffer too small error
                    //
                    Status = STATUS_BUFFER_TOO_SMALL;
                }
            }
        }       
        
        if (WnodeSI != OutBuffer)
        {
            WmipFree(WnodeSI);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return(Status);
}

NTSTATUS
IoWMIQuerySingleInstanceMultiple(
    __in_ecount(ObjectCount) PVOID *DataBlockObjectList,
    __in_ecount(ObjectCount) PUNICODE_STRING InstanceNames,
    __in ULONG ObjectCount,
    __inout ULONG *InOutBufferSize,
    __out_bcount_opt(*InOutBufferSize) PVOID OutBuffer
)
{
    NTSTATUS Status;
    ULONG RetSize;
    PWNODE_HEADER Wnode;
    WNODE_TOO_SMALL WnodeTooSmall;
    ULONG WnodeSize;
    
    PAGED_CODE();

    if (!ARGUMENT_PRESENT(DataBlockObjectList) ||
        !ARGUMENT_PRESENT(InstanceNames) ||
        (ObjectCount == 0) ||
        !ARGUMENT_PRESENT(InOutBufferSize)) {

        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    WnodeSize = *InOutBufferSize;
    Wnode = (PWNODE_HEADER)OutBuffer;
    if ((Wnode == NULL) || (WnodeSize < sizeof(WNODE_TOO_SMALL)))
    {
        Wnode = (PWNODE_HEADER)&WnodeTooSmall;
        WnodeSize = sizeof(WNODE_TOO_SMALL);
    }

    Status = WmipQuerySingleMultiple(NULL,
                                     KernelMode,
                                     (PUCHAR)Wnode,
                                     WnodeSize,
                                     NULL,
                                     ObjectCount,
                                     (PWMIGUIDOBJECT *)DataBlockObjectList,
                                     InstanceNames,
                                     &RetSize);
                            
                                 
    //
    // if this was a successful query then extract the results
    //
    if (NT_SUCCESS(Status))
    {
        if (Wnode->Flags & WNODE_FLAG_TOO_SMALL)
        {
            //
            // Buffer passed to provider was too small
            //
            *InOutBufferSize = ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded;
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            //
            // Buffer was large enough for provider
            //
            *InOutBufferSize = RetSize;
            
                
            if (Wnode == (PWNODE_HEADER)&WnodeTooSmall)
            {
                //
                // Although there was enough room for the provider,
                // the caller didn't pass a large enough buffer
                // so we need to return a buffer too small error
                //
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    }

Exit:
    
    return(Status);
}

NTSTATUS
IoWMISetSingleInstance(
    __in PVOID DataBlockObject,
    __in PUNICODE_STRING InstanceName,
    __in ULONG Version,
    __in ULONG ValueBufferSize,
    __in_bcount(ValueBufferSize) PVOID ValueBuffer
    )
{
    NTSTATUS Status;
    PWNODE_SINGLE_INSTANCE WnodeSI;
    PWCHAR WPtr;
    ULONG SizeNeeded;
    ULONG RetSize;
    ULONG InstanceOffset;
    ULONG DataOffset;
    PUCHAR DPtr;

    PAGED_CODE();
    
    InstanceOffset = (FIELD_OFFSET(WNODE_SINGLE_INSTANCE, 
                                   VariableData) + 1) & ~1;
                               
    DataOffset = (InstanceOffset + 
                  InstanceName->Length + sizeof(USHORT) + 7) & ~7;
                            
    SizeNeeded = DataOffset + ValueBufferSize;

    WnodeSI = (PWNODE_SINGLE_INSTANCE)WmipAllocNP(SizeNeeded);
            
    if (WnodeSI != NULL)
    {
        //
        // Build WNODE_SINGLE_INSTANCE appropriately and query
        //
        RtlZeroMemory(WnodeSI, FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                            VariableData));
                                      
        WmipBuildWnodeHeader(WnodeSI,
                             SizeNeeded,
                             WNODE_FLAG_SINGLE_INSTANCE,
                             NULL);
                         
        WnodeSI->WnodeHeader.Version = Version;

        //
        // Copy InstanceName into the WnodeSingleInstance for the query.
        //
        WnodeSI->OffsetInstanceName = InstanceOffset;
        WPtr = (PWCHAR)OffsetToPtr(WnodeSI, WnodeSI->OffsetInstanceName);
        *WPtr++ = InstanceName->Length;
        RtlCopyMemory(WPtr, InstanceName->Buffer, InstanceName->Length);
                                             
        //
        // Copy the new data into the WNODE
        //
        WnodeSI->SizeDataBlock = ValueBufferSize;
        WnodeSI->DataBlockOffset = DataOffset;
        DPtr = OffsetToPtr(WnodeSI, WnodeSI->DataBlockOffset);
        RtlCopyMemory(DPtr, ValueBuffer, ValueBufferSize);
        
        Status = WmipQuerySetExecuteSI(DataBlockObject,
                                       NULL,
                                       KernelMode,
                                       IRP_MN_CHANGE_SINGLE_INSTANCE,
                                       (PWNODE_HEADER)WnodeSI,
                                       SizeNeeded,
                                       &RetSize);
    
        WmipFree(WnodeSI);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return(Status); 
}

NTSTATUS
IoWMISetSingleItem(
    __in PVOID DataBlockObject,
    __in PUNICODE_STRING InstanceName,
    __in ULONG DataItemId,
    __in ULONG Version,
    __in ULONG ValueBufferSize,
    __in_bcount(ValueBufferSize) PVOID ValueBuffer
    )
{
    NTSTATUS Status;
    PWNODE_SINGLE_ITEM WnodeSI;
    PWCHAR WPtr;
    ULONG SizeNeeded;
    ULONG RetSize;
    ULONG InstanceOffset;
    ULONG DataOffset;
    PUCHAR DPtr;

    PAGED_CODE();
    
    InstanceOffset = (FIELD_OFFSET(WNODE_SINGLE_ITEM, 
                                   VariableData) + 1) & ~1;
                               
    DataOffset = (InstanceOffset + 
                  InstanceName->Length + sizeof(USHORT) + 7) & ~7;
                            
    SizeNeeded = DataOffset + ValueBufferSize;

    WnodeSI = (PWNODE_SINGLE_ITEM)WmipAllocNP(SizeNeeded);
            
    if (WnodeSI != NULL)
    {
        //
        // Build WNODE_SINGLE_INSTANCE appropriately and query
        //
        RtlZeroMemory(WnodeSI, FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                            VariableData));
                                      
        WmipBuildWnodeHeader(WnodeSI,
                             SizeNeeded,
                             WNODE_FLAG_SINGLE_ITEM,
                             NULL);
                         
        WnodeSI->WnodeHeader.Version = Version;
        WnodeSI->ItemId = DataItemId;

        //
        // Copy InstanceName into the WnodeSingleInstance for the query.
        //
        WnodeSI->OffsetInstanceName = InstanceOffset;
        WPtr = (PWCHAR)OffsetToPtr(WnodeSI, WnodeSI->OffsetInstanceName);
        *WPtr++ = InstanceName->Length;
        RtlCopyMemory(WPtr, InstanceName->Buffer, InstanceName->Length);
                                             
        //
        // Copy the new data into the WNODE
        //
        WnodeSI->SizeDataItem = ValueBufferSize;
        WnodeSI->DataBlockOffset = DataOffset;
        DPtr = OffsetToPtr(WnodeSI, WnodeSI->DataBlockOffset);
        RtlCopyMemory(DPtr, ValueBuffer, ValueBufferSize);
        
        Status = WmipQuerySetExecuteSI(DataBlockObject,
                                       NULL,
                                       KernelMode,
                                       IRP_MN_CHANGE_SINGLE_ITEM,
                                       (PWNODE_HEADER)WnodeSI,
                                       SizeNeeded,
                                       &RetSize);
    
        WmipFree(WnodeSI);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return(Status); 
}

NTSTATUS IoWMIExecuteMethod(
    __in PVOID DataBlockObject,
    __in PUNICODE_STRING InstanceName,
    __in ULONG MethodId,
    __in ULONG InBufferSize,
    __inout PULONG OutBufferSize,
    __inout_bcount_part_opt(*OutBufferSize, InBufferSize) PUCHAR InOutBuffer
    )
{
    NTSTATUS Status;
    PWNODE_METHOD_ITEM WnodeMI;
    PWCHAR WPtr;
    PUCHAR DPtr;
    ULONG SizeNeeded;
    ULONG RetSize;
    ULONG DataOffset;

    PAGED_CODE();
    
    //
    // Make sure we have an output buffer
    //
    DataOffset = (FIELD_OFFSET(WNODE_METHOD_ITEM,
                                 VariableData) +
                   InstanceName->Length +
                   sizeof(USHORT) +
                   7) & ~7;
    
    SizeNeeded =  DataOffset +
                   ((InBufferSize > *OutBufferSize) ? InBufferSize :
                                                      *OutBufferSize);
    
    WnodeMI = (PWNODE_METHOD_ITEM)WmipAllocNP(SizeNeeded);
            
    if (WnodeMI != NULL)
    {
        //
        // Build WNODE_SINGLE_INSTANCE appropriately and query
        //
        RtlZeroMemory(WnodeMI, FIELD_OFFSET(WNODE_METHOD_ITEM,
                                          VariableData));
                                      
        WmipBuildWnodeHeader(WnodeMI,
                             SizeNeeded,
                             WNODE_FLAG_METHOD_ITEM,
                             NULL);
        
        WnodeMI->MethodId = MethodId;

        WnodeMI->OffsetInstanceName = FIELD_OFFSET(WNODE_METHOD_ITEM,
                                                   VariableData);
        WnodeMI->DataBlockOffset = DataOffset;
        WnodeMI->SizeDataBlock = InBufferSize;

        //
        // Copy InstanceName into the WnodeMethodItem for the query.
        //
        WPtr = (PWCHAR)OffsetToPtr(WnodeMI, WnodeMI->OffsetInstanceName);
        *WPtr++ = InstanceName->Length;
        RtlCopyMemory(WPtr, InstanceName->Buffer, InstanceName->Length);

        //
        // Copy the input data into the WnodeMethodItem
        //
        DPtr = (PUCHAR)OffsetToPtr(WnodeMI, WnodeMI->DataBlockOffset);
        RtlCopyMemory(DPtr, InOutBuffer, InBufferSize);
        
        Status = WmipQuerySetExecuteSI(DataBlockObject,NULL,
                                       KernelMode,
                                       IRP_MN_EXECUTE_METHOD,
                                       (PWNODE_HEADER)WnodeMI,
                                       SizeNeeded,
                                       &RetSize);
    
        //
        // if this was a successful query then extract the results
        //
        if (NT_SUCCESS(Status))
        {
            if (WnodeMI->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL)
            {
                //
                // Our buffer was too small
                //
                *OutBufferSize = ( (((PWNODE_TOO_SMALL)WnodeMI)->SizeNeeded -
                                 DataOffset) + 7 ) & ~7;
                Status = STATUS_BUFFER_TOO_SMALL;
            } else {
                //
                // Buffer not too small, remember output size
                //
                if (*OutBufferSize >= WnodeMI->SizeDataBlock)
                {
                    *OutBufferSize = WnodeMI->SizeDataBlock;
                    DPtr = (PUCHAR)OffsetToPtr(WnodeMI,
                                               WnodeMI->DataBlockOffset);
                    RtlCopyMemory(InOutBuffer, DPtr, WnodeMI->SizeDataBlock);
                } else {
                    *OutBufferSize = (WnodeMI->SizeDataBlock + 7) & ~7;
                    Status = STATUS_BUFFER_TOO_SMALL;
                }
            }
        }       
        
        WmipFree(WnodeMI);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return(Status);
}

NTSTATUS
IoWMISetNotificationCallback(
    __inout PVOID Object,
    __in WMI_NOTIFICATION_CALLBACK Callback,
    __in_opt PVOID Context
    )
{
    PWMIGUIDOBJECT GuidObject;
    
    PAGED_CODE();

    GuidObject = (PWMIGUIDOBJECT)Object;
    
    WmipAssert(GuidObject->Flags & WMIGUID_FLAG_KERNEL_NOTIFICATION);
    
    WmipEnterSMCritSection();
    
    GuidObject->Callback = Callback;
    GuidObject->CallbackContext = Context;
    
    WmipLeaveSMCritSection();

    return(STATUS_SUCCESS);
}

NTSTATUS IoWMIHandleToInstanceName(
    __in PVOID DataBlockObject,
    __in HANDLE FileHandle,
    __out PUNICODE_STRING InstanceName
    )
{
    NTSTATUS Status;
    
    PAGED_CODE();

    Status = WmipTranslateFileHandle(NULL,
                                     NULL,
                                     FileHandle,
                                     NULL,
                                     DataBlockObject,
                                     InstanceName);
    return(Status);
}

NTSTATUS IoWMIDeviceObjectToInstanceName(
    __in PVOID DataBlockObject,
    __in PDEVICE_OBJECT DeviceObject,
    __out PUNICODE_STRING InstanceName
    )
{
    NTSTATUS Status;
    
    PAGED_CODE();

    Status = WmipTranslateFileHandle(NULL,
                                     NULL,
                                     NULL,
                                     DeviceObject,
                                     DataBlockObject,
                                     InstanceName);
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\chunk.c ===
/*++                 

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    chunk.c

Abstract:
    
    This routine will manage allocations of chunks of structures

--*/

#include "wmikmp.h"

PENTRYHEADER WmipAllocEntry(
    PCHUNKINFO ChunkInfo
    );

void WmipFreeEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

ULONG WmipUnreferenceEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

PWCHAR WmipCountedToSz(
    PWCHAR Counted
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,WmipAllocEntry)
#pragma alloc_text(PAGE,WmipFreeEntry)
#pragma alloc_text(PAGE,WmipUnreferenceEntry)
#pragma alloc_text(PAGE,WmipCountedToSz)
#endif

PENTRYHEADER WmipAllocEntry(
    PCHUNKINFO ChunkInfo
    )
/*++

Routine Description:

    This routine will allocate a single structure within a list of chunks
    of structures.

Arguments:

    ChunkInfo describes the chunks of structures

Return Value:

    Pointer to structure or NULL if one cannot be allocated. Entry returns
    with its refcount set to 1

--*/
{
    PLIST_ENTRY ChunkList, EntryList, FreeEntryHead;
    PCHUNKHEADER Chunk;
    PUCHAR EntryPtr;
    ULONG EntryCount, ChunkSize;
    PENTRYHEADER Entry;
    ULONG i;

    PAGED_CODE();
    
    WmipEnterSMCritSection();
    ChunkList = ChunkInfo->ChunkHead.Flink;

    //
    // Loop over all chunks to see if any chunk has a free entry for us
    while(ChunkList != &ChunkInfo->ChunkHead)
    {
        Chunk = CONTAINING_RECORD(ChunkList, CHUNKHEADER, ChunkList);
        if (! IsListEmpty(&Chunk->FreeEntryHead))
        {
            EntryList = RemoveHeadList(&Chunk->FreeEntryHead);
            Chunk->EntriesInUse++;
            WmipLeaveSMCritSection();
            Entry = (CONTAINING_RECORD(EntryList,
                                       ENTRYHEADER,
                                       FreeEntryList));
            WmipAssert(Entry->Flags & FLAG_ENTRY_ON_FREE_LIST);
            memset(Entry, 0, ChunkInfo->EntrySize);
            Entry->Chunk = Chunk;
            Entry->RefCount = 1;
            Entry->Flags = ChunkInfo->InitialFlags;
            Entry->Signature = ChunkInfo->Signature;
#if DBG
            InterlockedIncrement(&ChunkInfo->AllocCount);
#endif
            return(Entry);
        }
        ChunkList = ChunkList->Flink;
    }
    WmipLeaveSMCritSection();

    //
    // There are no more free entries in any of the chunks. Allocate a new
    // chunk if we can
    ChunkSize = (ChunkInfo->EntrySize * ChunkInfo->EntriesPerChunk) +
                  sizeof(CHUNKHEADER);
    Chunk = (PCHUNKHEADER)ExAllocatePoolWithTag(PagedPool,
                                            ChunkSize,
                        ChunkInfo->Signature);
    if (Chunk != NULL)
    {
        //
        // Initialize the chunk by building the free list of entries within
        // it while also initializing each entry.
        memset(Chunk, 0, ChunkSize);

        FreeEntryHead = &Chunk->FreeEntryHead;
        InitializeListHead(FreeEntryHead);

        EntryPtr = (PUCHAR)Chunk + sizeof(CHUNKHEADER);
        EntryCount = ChunkInfo->EntriesPerChunk - 1;

        for (i = 0; i < EntryCount; i++)
        {
            Entry = (PENTRYHEADER)EntryPtr;
            Entry->Chunk = Chunk;
            Entry->Flags = FLAG_ENTRY_ON_FREE_LIST;
            InsertHeadList(FreeEntryHead,
                           &((PENTRYHEADER)EntryPtr)->FreeEntryList);
            EntryPtr = EntryPtr + ChunkInfo->EntrySize;
        }
        //
        // EntryPtr now points to the last entry in the chunk which has not
        // been placed on the free list. This will be the entry returned
        // to the caller.
        Entry = (PENTRYHEADER)EntryPtr;
        Entry->Chunk = Chunk;
        Entry->RefCount = 1;
        Entry->Flags = ChunkInfo->InitialFlags;
        Entry->Signature = ChunkInfo->Signature;

        Chunk->EntriesInUse = 1;

        //
        // Now place the newly allocated chunk onto the list of chunks
        WmipEnterSMCritSection();
        InsertHeadList(&ChunkInfo->ChunkHead, &Chunk->ChunkList);
        WmipLeaveSMCritSection();

    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Could not allocate memory for new chunk %x\n",
                        ChunkInfo));
        Entry = NULL;
    }
    return(Entry);
}

void WmipFreeEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
/*++

Routine Description:

    This routine will free an entry within a chunk and if the chunk has no
    more allocated entries then the chunk will be returned to the pool.

Arguments:

    ChunkInfo describes the chunks of structures

    Entry is the chunk entry to free

Return Value:


--*/
{
    PCHUNKHEADER Chunk;

    PAGED_CODE();
    
    WmipAssert(Entry != NULL);
    WmipAssert(! (Entry->Flags & FLAG_ENTRY_ON_FREE_LIST));
    WmipAssert(Entry->Flags & FLAG_ENTRY_INVALID);
    WmipAssert(Entry->RefCount == 0);
    WmipAssert(Entry->Signature == ChunkInfo->Signature);

    Chunk = Entry->Chunk;
    WmipAssert(Chunk->EntriesInUse > 0);

    WmipEnterSMCritSection();
    if ((--Chunk->EntriesInUse == 0) &&
        (ChunkInfo->ChunkHead.Blink != &Chunk->ChunkList))
    {
        //
        // We return the chunks memory back to the heap if there are no
        // more entries within the chunk in use and the chunk was not the
        // first chunk to be allocated.
        RemoveEntryList(&Chunk->ChunkList);
        WmipLeaveSMCritSection();
        ExFreePoolWithTag(Chunk, ChunkInfo->Signature);
    } else {
        //
        // Otherwise just mark the entry as free and put it back on the
        // chunks free list.
#if DBG
//        memset(Entry, 0xCCCCCCCC, ChunkInfo->EntrySize);
#endif
        Entry->Flags = FLAG_ENTRY_ON_FREE_LIST;
        Entry->Signature = 0;
        InsertTailList(&Chunk->FreeEntryHead, &Entry->FreeEntryList);
        WmipLeaveSMCritSection();
    }
}


ULONG WmipUnreferenceEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
/*+++

Routine Description:

    This routine will remove a reference count from the entry and if the
    reference count reaches zero then the entry is removed from its active
    list and then cleaned up and finally freed.

Arguments:

    ChunkInfo points at structure that describes the entry

    Entry is the entry to unreference

Return Value:

    New refcount of the entry

---*/
{
    ULONG RefCount;

    PAGED_CODE();
    
    WmipAssert(Entry != NULL);
    WmipAssert(Entry->RefCount > 0);
    WmipAssert(Entry->Signature == ChunkInfo->Signature);

    WmipEnterSMCritSection();
    InterlockedDecrement((PLONG)&Entry->RefCount);
    RefCount = Entry->RefCount;

    if (RefCount == 0)
    {
        //
        // Entry has reached a ref count of 0 so mark it as invalid and remove
        // it from its active list.
        Entry->Flags |= FLAG_ENTRY_INVALID;

        if ((Entry->InUseEntryList.Flink != NULL) &&
            (Entry->Flags & FLAG_ENTRY_REMOVE_LIST))
        {
            RemoveEntryList(&Entry->InUseEntryList);
        }

        WmipLeaveSMCritSection();

        if (ChunkInfo->EntryCleanup != NULL)
        {
            //
            // Call cleanup routine to free anything contained by the entry
            (*ChunkInfo->EntryCleanup)(ChunkInfo, Entry);
        }

        //
        // Place the entry back on its free list
        WmipFreeEntry(ChunkInfo, Entry);
    } else {
        WmipLeaveSMCritSection();
    }
    return(RefCount);
}

PWCHAR WmipCountedToSz(
    PWCHAR Counted
    )
{
    PWCHAR Sz;
    USHORT CountedLen;

    PAGED_CODE();
    
    CountedLen = *Counted++;
       Sz = WmipAlloc(CountedLen + sizeof(WCHAR));
    if (Sz != NULL)
    {
           memcpy(Sz, Counted, CountedLen);
        Sz[CountedLen/sizeof(WCHAR)] = UNICODE_NULL;
    }        

    return(Sz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\callouts.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    callouts.c

Abstract:

    This is the source file that contains all the callout routines
    from the kernel itself. The only exception is TraceIo for DiskPerf.

--*/

#pragma warning(disable:4214)
#pragma warning(disable:4115)
#pragma warning(disable:4201)
#pragma warning(disable:4127)
#pragma warning(disable:4127)
#include <stdio.h>
#include <ntos.h>
#include <zwapi.h>
#include <evntrace.h>
#include "wmikmp.h"
#include "tracep.h"
#pragma warning(default:4214)
#pragma warning(default:4115)
#pragma warning(default:4201)

#ifndef _WMIKM_
#define _WMIKM_
#endif

#define MAX_FILENAME_TO_LOG   4096
#define ETW_WORK_ITEM_LIMIT  64

typedef struct _TRACE_FILE_WORK_ITEM {
    WORK_QUEUE_ITEM         WorkItem;
    PFILE_OBJECT            FileObject;
    ULONG                   BufferSize;
} TRACE_FILE_WORK_ITEM, *PTRACE_FILE_WORK_ITEM;

VOID
FASTCALL
WmipTracePageFault(
    IN NTSTATUS Status,
    IN PVOID VirtualAddress,
    IN PVOID TrapFrame
    );

VOID
WmipTraceNetwork(
    IN ULONG GroupType,
    IN PVOID EventInfo,
    IN ULONG EventInfoLen,
    IN PVOID Reserved 
    );

VOID
WmipTraceIo(
    IN ULONG DiskNumber,
    IN PIRP Irp,
    IN PVOID Counters
    );

VOID
WmipTraceVolMgr(
    IN PIRP ParentIrp,
    IN PIRP ChildIrp
    );

VOID WmipTraceFile(
    IN PVOID TraceFileContext
    );

VOID
WmipTraceLoadImage(
    IN PUNICODE_STRING ImageName,
    IN HANDLE ProcessId,
    IN PIMAGE_INFO ImageInfo
    );

VOID
WmipTraceRegistry(
    IN NTSTATUS         Status,
    IN PVOID            Kcb,
    IN LONGLONG         ElapsedTime,
    IN ULONG            Index,
    IN PUNICODE_STRING  KeyName,
    IN UCHAR            Type
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEWMI, WmipIsLoggerOn)
#pragma alloc_text(PAGE,    WmipEnableKernelTrace)
#pragma alloc_text(PAGE,    WmipDisableKernelTrace)
#pragma alloc_text(PAGE,    WmipSetTraceNotify)
#pragma alloc_text(PAGE,    WmiTraceProcess)
#pragma alloc_text(PAGE,    WmiTraceThread)
#pragma alloc_text(PAGE,    WmipTraceFile)
#pragma alloc_text(PAGE,    WmipTraceLoadImage)
#pragma alloc_text(PAGE,    WmipTraceRegistry)
#pragma alloc_text(PAGEWMI, WmipTracePageFault)
#pragma alloc_text(PAGEWMI, WmipTraceNetwork)
#pragma alloc_text(PAGEWMI, WmipTraceIo)
#pragma alloc_text(PAGEWMI, WmipTraceVolMgr)
#pragma alloc_text(PAGEWMI, WmiTraceContextSwap)
#pragma alloc_text(PAGE,    WmiStartContextSwapTrace)
#pragma alloc_text(PAGE,    WmiStopContextSwapTrace)
#endif

ULONG WmipTraceFileFlag = FALSE;
LONG WmipFileIndex = 0;
LONG WmipWorkItemCounter = 0;
PFILE_OBJECT *WmipFileTable = NULL;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
ULONG WmipKernelLoggerStartedOnce = 0;
LONG WmipTraceProcessRef  = 0;
PVOID WmipDiskIoNotify    = NULL;
PVOID WmipTdiIoNotify     = NULL;
PVOID WmipVolMgrIoNotify  = NULL;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

typedef struct _TRACE_DEVICE {
    PDEVICE_OBJECT      DeviceObject;
    ULONG               TraceClass;
} TRACE_DEVICE, *PTRACE_DEVICE;

VOID
FASTCALL
WmipEnableKernelTrace(
    IN ULONG EnableFlags
    )
/*++

Routine Description:

    This is called by WmipStartLogger in tracelog.c. Its purpose is to
    set up all the kernel notification routines that can produce event traces
    for capacity planning.

Arguments:

    ExtendedOn      a flag to indicate if extended mode tracing is requested

Return Value:

    None

--*/

{
    PREGENTRY RegEntry;
    PLIST_ENTRY RegEntryList;
    ULONG DevicesFound;
    long Index, DiskFound;
    PTRACE_DEVICE *deviceList, device;
    CCHAR stackSize;
    PIRP irp;
    PVOID notifyRoutine;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS status;
    ULONG enableDisk, enableNetwork, enableVolMgr;

    PAGED_CODE();

    //
    // Since we cannot do anything, we will have to count the number
    // of entries we need to create first, and add some buffer
    //

    DiskFound = 0;

    enableDisk = (EnableFlags & EVENT_TRACE_FLAG_DISK_IO);
    enableVolMgr = (EnableFlags & EVENT_TRACE_FLAG_VOLMGR);
    enableNetwork = (EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP);

    if ( enableDisk || enableNetwork || enableVolMgr) {

        //
        // Setting the callouts will cause new PDO registration to be enabled
        // from here on.
        //
        if (enableDisk) {
            WmipDiskIoNotify = (PVOID) (ULONG_PTR) &WmipTraceIo;
        }
        if (enableNetwork) {
            WmipTdiIoNotify = (PVOID) (ULONG_PTR) &WmipTraceNetwork;
        }
        if (enableVolMgr) {
            WmipVolMgrIoNotify = (PVOID) (ULONG_PTR) &WmipTraceVolMgr;
        }

        DevicesFound = WmipInUseRegEntryCount;
        if (DevicesFound == 0) {
            return;
        }

        deviceList = (PTRACE_DEVICE*)
                        ExAllocatePoolWithTag(
                            PagedPool,
                            (DevicesFound) * sizeof(TRACE_DEVICE),
                            TRACEPOOLTAG);
        if (deviceList == NULL) {
            return;
        }

        RtlZeroMemory(deviceList, sizeof(TRACE_DEVICE) * DevicesFound);

        //
        // Now, we will go through what's already in the list and enable trace
        // notification routine. Devices who registered while after we've set
        // the callout will get another Irp to enable, but that's alright
        //

        device = (PTRACE_DEVICE) deviceList;        // start from first element

        Index = 0;

        WmipEnterSMCritSection();
        RegEntryList = WmipInUseRegEntryHead.Flink;
        while (RegEntryList != &WmipInUseRegEntryHead) {
            RegEntry = CONTAINING_RECORD(RegEntryList,REGENTRY,InUseEntryList);

            if (RegEntry->Flags & REGENTRY_FLAG_TRACED) {
                if ((ULONG) Index < DevicesFound) {
                    device->TraceClass
                        = RegEntry->Flags & WMIREG_FLAG_TRACE_NOTIFY_MASK;
                    if (device->TraceClass == WMIREG_NOTIFY_DISK_IO)
                        DiskFound++;
                    device->DeviceObject = RegEntry->DeviceObject;
                    device++;
                    Index++;
                }
            }
            RegEntryList = RegEntryList->Flink;
        }
        WmipLeaveSMCritSection();

        //
        // actually send the notification to diskperf or tdi here
        //
        stackSize = WmipServiceDeviceObject->StackSize;
        irp = IoAllocateIrp(stackSize, FALSE);

        device = (PTRACE_DEVICE) deviceList;
        while (--Index >= 0 && irp != NULL) {
            if (device->DeviceObject != NULL) {

                if ( (device->TraceClass == WMIREG_NOTIFY_TDI_IO) &&
                      enableNetwork ) {
                    notifyRoutine = (PVOID) (ULONG_PTR) &WmipTraceNetwork;
                }
                else if ( (device->TraceClass == WMIREG_NOTIFY_DISK_IO) &&
                           enableDisk ) {
                    notifyRoutine = (PVOID) (ULONG_PTR) &WmipTraceIo;
                }
                else if ( (device->TraceClass == WMIREG_NOTIFY_VOLMGR_IO) &&
                           enableVolMgr ) {
                    notifyRoutine = (PVOID) (ULONG_PTR) &WmipTraceVolMgr;
                }
                else {  // consider supporting generic callout for other devices
                    notifyRoutine = NULL;
                    device ++;
                    continue;
                }

                do {
                    IoInitializeIrp(irp, IoSizeOfIrp(stackSize), stackSize);
                    IoSetNextIrpStackLocation(irp);
                    irpStack = IoGetCurrentIrpStackLocation(irp);
                    irpStack->DeviceObject = WmipServiceDeviceObject;
                    irp->Tail.Overlay.Thread = PsGetCurrentThread();

                    status = WmipForwardWmiIrp(
                                irp,
                                IRP_MN_SET_TRACE_NOTIFY,
                                IoWMIDeviceObjectToProviderId(device->DeviceObject),
                                NULL,
                                sizeof(notifyRoutine),
                                &notifyRoutine
                                );

                    if (status == STATUS_WMI_TRY_AGAIN) {
                        IoFreeIrp(irp);
                        stackSize = WmipServiceDeviceObject->StackSize;
                        irp = IoAllocateIrp(stackSize, FALSE);
                        if (!irp) {
                            break;
                        }
                    }
                } while (status == STATUS_WMI_TRY_AGAIN);
            }
            device++;
        }
        if (irp) {
            IoFreeIrp(irp);
        }
        ExFreePoolWithTag(deviceList, TRACEPOOLTAG);
        // free the array that we created above
        //
    }

    if (EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS) {
        MmSetPageFaultNotifyRoutine(
            (PPAGE_FAULT_NOTIFY_ROUTINE) &WmipTracePageFault);
    }
    if (EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO) {
        //
        // NOTE: We assume StartLogger will always reserve space for
        // FileTable already
        //
        WmipTraceFileFlag = TRUE;
    }

    if (EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD) {
        if (!(WmipKernelLoggerStartedOnce & EVENT_TRACE_FLAG_IMAGE_LOAD)) {
            PsSetLoadImageNotifyRoutine(
                (PLOAD_IMAGE_NOTIFY_ROUTINE) &WmipTraceLoadImage
                );
            WmipKernelLoggerStartedOnce |= EVENT_TRACE_FLAG_IMAGE_LOAD;
        }
    }

    if (EnableFlags & EVENT_TRACE_FLAG_REGISTRY) {
        CmSetTraceNotifyRoutine(
            (PCM_TRACE_NOTIFY_ROUTINE) &WmipTraceRegistry,
            FALSE
            );
    }
}


VOID
FASTCALL
WmipDisableKernelTrace(
    IN ULONG EnableFlags
    )
/*++

Routine Description:

    This is called by WmipStopLogger in tracelog.c. Its purpose of the
    disable all the kernel notification routines that was defined by
    WmipEnableKernelTrace

Arguments:

    EnableFlags     Flags indicated what was enabled and needs to be disabled

Return Value:

    None

--*/

{
    PVOID NullPtr = NULL;
    PREGENTRY RegEntry;
    PLIST_ENTRY RegEntryList;
    ULONG DevicesFound;
    long Index;
    PTRACE_DEVICE* deviceList, device;
    CCHAR stackSize;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS status;
    ULONG enableDisk, enableNetwork, enableVolMgr;

    PAGED_CODE();

    //
    // first, disable partition change notification
    //

    if (EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO) {
        WmipTraceFileFlag = FALSE;
        if (WmipFileTable != NULL) {
            RtlZeroMemory(
                WmipFileTable,
                MAX_FILE_TABLE_SIZE * sizeof(PFILE_OBJECT));
        }
    }

    if (EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS) {
        MmSetPageFaultNotifyRoutine(NULL);
    }

    if (EnableFlags & EVENT_TRACE_FLAG_REGISTRY) {
        CmSetTraceNotifyRoutine(NULL,TRUE);
    }

    enableDisk = (EnableFlags & EVENT_TRACE_FLAG_DISK_IO);
    enableNetwork = (EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP);
    enableVolMgr = (EnableFlags & EVENT_TRACE_FLAG_VOLMGR);

    if (!enableDisk && !enableNetwork && !enableVolMgr)
        return;     // NOTE: assumes all flags are already checked

    //
    // Note. Since this is in the middle is StopLogger, it is not possible
    // StartLogger will prevent kernel tracing from being enabled, hence
    // we need not worry about WmipEnableKernelTrace() being called while
    // this is in progress.
    //
    WmipDiskIoNotify = NULL;
    WmipTdiIoNotify = NULL;
    WmipVolMgrIoNotify = NULL;

    DevicesFound = WmipInUseRegEntryCount;

    deviceList = (PTRACE_DEVICE*)
                ExAllocatePoolWithTag(
                    PagedPool,
                    (DevicesFound) * sizeof(TRACE_DEVICE),
                    TRACEPOOLTAG);
    if (deviceList == NULL)
        return;

    RtlZeroMemory(deviceList, sizeof(TRACE_DEVICE) * DevicesFound);
    Index = 0;
    device = (PTRACE_DEVICE) deviceList;        // start from first element

    //
    // To disable we do not need to worry about TraceClass, since we simply
    // set all callouts to NULL
    //
    WmipEnterSMCritSection();
    RegEntryList = WmipInUseRegEntryHead.Flink;
    while (RegEntryList != &WmipInUseRegEntryHead) {
        RegEntry = CONTAINING_RECORD(RegEntryList, REGENTRY, InUseEntryList);
        if (RegEntry->Flags & REGENTRY_FLAG_TRACED) {
            if ((ULONG)Index < DevicesFound) {
                device->TraceClass
                    = RegEntry->Flags & WMIREG_FLAG_TRACE_NOTIFY_MASK;
                device->DeviceObject = RegEntry->DeviceObject;
                device++; Index++;
            }
        }
        RegEntryList = RegEntryList->Flink;
    }
    WmipLeaveSMCritSection();

    stackSize = WmipServiceDeviceObject->StackSize;
    irp = IoAllocateIrp(stackSize, FALSE);

    device = (PTRACE_DEVICE) deviceList;        // start from first element
    while (--Index >= 0 && irp != NULL) {
        if ((device->DeviceObject != NULL) &&
            ((device->TraceClass == WMIREG_NOTIFY_TDI_IO) ||
             (device->TraceClass == WMIREG_NOTIFY_DISK_IO) ||
             (device->TraceClass == WMIREG_NOTIFY_VOLMGR_IO))) {

            do {
                IoInitializeIrp(irp, IoSizeOfIrp(stackSize), stackSize);
                IoSetNextIrpStackLocation(irp);
                irpStack = IoGetCurrentIrpStackLocation(irp);
                irpStack->DeviceObject = WmipServiceDeviceObject;
                irp->Tail.Overlay.Thread = PsGetCurrentThread();

                status = WmipForwardWmiIrp(
                            irp,
                            IRP_MN_SET_TRACE_NOTIFY,
                            IoWMIDeviceObjectToProviderId(device->DeviceObject),
                            NULL,
                            sizeof(NullPtr),
                            &NullPtr
                            );

                if (status == STATUS_WMI_TRY_AGAIN) {
                    IoFreeIrp(irp);
                    stackSize = WmipServiceDeviceObject->StackSize;
                    irp = IoAllocateIrp(stackSize, FALSE);
                    if (!irp) {
                        break;
                    }
                }
                else {
                    break;
                }
            } while (TRUE);
        }
        device++;
    }

    if (irp) {
        IoFreeIrp(irp);
    }
    ExFreePoolWithTag(deviceList, TRACEPOOLTAG);
}

VOID
WmipSetTraceNotify(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG TraceClass,
    IN ULONG Enable
    )
{
    PIRP irp;
    PVOID NotifyRoutine = NULL;
    NTSTATUS status;
    CCHAR stackSize;
    PIO_STACK_LOCATION irpStack;

    if (Enable) {
        switch (TraceClass) {
            case WMIREG_NOTIFY_DISK_IO  :
                NotifyRoutine = WmipDiskIoNotify;
                break;
            case WMIREG_NOTIFY_TDI_IO   :
                NotifyRoutine = WmipTdiIoNotify;
                break;
            case WMIREG_NOTIFY_VOLMGR_IO   :
                NotifyRoutine = WmipVolMgrIoNotify;
                break;
            default :
                return;
        }
        if (NotifyRoutine == NULL)  // trace not enabled, so do not
            return;                 // send any Irp to enable
    }

    do {
        stackSize = WmipServiceDeviceObject->StackSize;
        irp = IoAllocateIrp(stackSize, FALSE);

        if (!irp)
            return;

        IoSetNextIrpStackLocation(irp);
        irpStack = IoGetCurrentIrpStackLocation(irp);
        irpStack->DeviceObject = WmipServiceDeviceObject;
        status = WmipForwardWmiIrp(
                     irp,
                     IRP_MN_SET_TRACE_NOTIFY,
                     IoWMIDeviceObjectToProviderId(DeviceObject),
                     NULL,
                     sizeof(NotifyRoutine),
                     &NotifyRoutine
                     );
        IoFreeIrp(irp);
    } while (status == STATUS_WMI_TRY_AGAIN);
}

//
// All the following routines are callout or notification routines for
// generating kernel event traces
//


NTKERNELAPI
VOID
FASTCALL
WmiTraceProcess(
    IN PEPROCESS Process,
    IN BOOLEAN Create
    )
/*++

Routine Description:

    This callout routine is called from ps\create.c and ps\psdelete.c.

Arguments:

    Process - PEPROCESS;
    Create - True if intended process is being created.

Return Value:

    None

--*/

{
    ULONG Size, LoggerId;
    NTSTATUS Status;
    PCHAR AuxPtr;
    PSYSTEM_TRACE_HEADER Header;
    PVOID BufferResource;
    ULONG SidLength = sizeof(ULONG);
    PTOKEN_USER LocalUser = NULL;
    PWMI_PROCESS_INFORMATION ProcessInfo;
    PWMI_LOGGER_CONTEXT LoggerContext;
    PVOID Token;
    PUNICODE_STRING pImageFileName;
    ANSI_STRING AnsiImageFileName;
    ULONG ImageLength, ImageOnlyLength;
    PCHAR Src;
    PCHAR Dst;
    ULONG LongImageName;
#if DBG
    LONG RefCount;
#endif

    PAGED_CODE();

    if ((WmipIsLoggerOn(WmipKernelLogger) == NULL) &&
        (WmipIsLoggerOn(WmipEventLogger) == NULL))
        return;

    Token = PsReferencePrimaryToken(Process);
    if (Token != NULL) {
        Status = SeQueryInformationToken(
            Token,
            TokenUser,
            &LocalUser);
        PsDereferencePrimaryTokenEx (Process, Token);
    } else {
        Status = STATUS_SEVERITY_ERROR;
    }

    if (NT_SUCCESS(Status)) {
        WmipAssert(LocalUser != NULL);  // temporary for SE folks
        if (LocalUser != NULL) {
            SidLength = SeLengthSid(LocalUser->User.Sid) + sizeof(TOKEN_USER);
        }
    } else {
        SidLength = sizeof(ULONG);
        LocalUser = NULL;
    }

    AnsiImageFileName.Buffer = NULL;
    // Get image name not limited to 16 chars.
    Status = SeLocateProcessImageName (Process, &pImageFileName);
    if (NT_SUCCESS (Status)) {
        ImageLength = pImageFileName->Length;
        if (ImageLength != 0) {
            Status = RtlUnicodeStringToAnsiString(&AnsiImageFileName, pImageFileName, TRUE);
            if (NT_SUCCESS (Status)) {
                ImageLength = AnsiImageFileName.Length;
            } else {
                ImageLength = 0;
            }
        }
        ExFreePool (pImageFileName);
    } else {
        ImageLength = 0;
    }
    // if ImageLength == 0, AnsiImageFileName has not been allocated at this point.

    if (ImageLength != 0) {
        Src = AnsiImageFileName.Buffer + ImageLength;
        while (Src != AnsiImageFileName.Buffer) {
            if (*--Src == '\\') {
                Src = Src + 1;
                break;
            }
        }

        ImageOnlyLength = ImageLength - (ULONG)(Src - AnsiImageFileName.Buffer);
        ImageLength = ImageOnlyLength + 1;
        LongImageName = TRUE;
    } else {
        Src = (PCHAR) Process->ImageFileName;
        // Process->ImageFileName is max 16 chars and always NULL-terminated.
        ImageLength = (ULONG) strlen (Src);
        if (ImageLength != 0) {
            ImageLength++;
        }
        LongImageName = FALSE;
        ImageOnlyLength = 0;
    }
    // if LongImageName == FALSE, AnsiImageFileName has not been allocated at this point.

    Size = SidLength + FIELD_OFFSET(WMI_PROCESS_INFORMATION, Sid) + ImageLength;

    for (LoggerId = 0; LoggerId < MAXLOGGERS; LoggerId++) {
        if (LoggerId != WmipKernelLogger && LoggerId != WmipEventLogger) {
            continue;
        }
#if DBG
        RefCount =
#endif
        WmipReferenceLogger(LoggerId);
        TraceDebug((4, "WmiTraceProcess: %d %d->%d\n",
                     LoggerId, RefCount-1, RefCount));        

        LoggerContext = WmipIsLoggerOn(LoggerId);
        if (LoggerContext != NULL) {
            if (LoggerContext->EnableFlags & EVENT_TRACE_FLAG_PROCESS) {
                Header = WmiReserveWithSystemHeader( LoggerId,
                                                     Size,
                                                     NULL,
                                                     &BufferResource);
                if (Header) {
                    if(Create) {
                        Header->Packet.HookId = WMI_LOG_TYPE_PROCESS_CREATE;
                    } else {
                        Header->Packet.HookId = WMI_LOG_TYPE_PROCESS_DELETE;
                    }
                    ProcessInfo = (PWMI_PROCESS_INFORMATION) (Header + 1);

                    ProcessInfo->PageDirectoryBase = MmGetDirectoryFrameFromProcess(Process);
                    ProcessInfo->ProcessId = HandleToUlong(Process->UniqueProcessId);
                    ProcessInfo->ParentId = HandleToUlong(Process->InheritedFromUniqueProcessId);
                    ProcessInfo->SessionId = MmGetSessionId (Process);
                    ProcessInfo->ExitStatus = (Create ? STATUS_SUCCESS : Process->ExitStatus);

                    AuxPtr = (PCHAR) (&ProcessInfo->Sid);

                    if (LocalUser != NULL) {
                        RtlCopyMemory(AuxPtr, LocalUser, SidLength);
                    } else {
                        *((PULONG) AuxPtr) = 0;
                    }

                    AuxPtr += SidLength;

                    if (ImageLength != 0) {
                        Dst = AuxPtr;
                        if (LongImageName) {
                            // ImageOnlyLength is from SeLocateProcessImageName(), 
                            // so we can trust it.
                            RtlCopyMemory (Dst, Src, ImageOnlyLength);
                            Dst += ImageOnlyLength;
                            *Dst++ = '\0';
                        } else {
                            // Copy 16 char name. Src is always NULL-terminated.
                            while (*Dst++ = *Src++) {
                                ;
                            }
                        }
                    }

                    WmipReleaseTraceBuffer(BufferResource, LoggerContext);
                }

            }
        }
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((4, "WmiTraceProcess: %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));

    }
    if (LongImageName) {
        RtlFreeAnsiString (&AnsiImageFileName);
    }
    if (LocalUser != NULL) {
        ExFreePool(LocalUser);
    }
}


NTKERNELAPI
VOID
WmiTraceThread(
    IN PETHREAD Thread,
    IN PINITIAL_TEB InitialTeb OPTIONAL,
    IN BOOLEAN Create
    )
/*++

Routine Description:

    This callout routine is called from ps\create.c and ps\psdelete.c.
    It is a PCREATE_THREAD_NOTIFY_ROUTINE.

Arguments:

    Thread - PETHREAD structure
    InitialTeb - PINITIAL_TEB
    Create - True if intended thread is being created.

Return Value:

    None

--*/

{
    ULONG LoggerId;
    PSYSTEM_TRACE_HEADER Header;
    PVOID BufferResource;
    PWMI_LOGGER_CONTEXT LoggerContext;
#if DBG
    LONG RefCount;
#endif


    PAGED_CODE();

    if ((WmipIsLoggerOn(WmipKernelLogger) == NULL) &&
        (WmipIsLoggerOn(WmipEventLogger) == NULL)) {
        return;
    }

    for (LoggerId = 0; LoggerId < MAXLOGGERS; LoggerId++) {
        if (LoggerId != WmipKernelLogger && LoggerId != WmipEventLogger) {
            continue;
        }
#if DBG
        RefCount =
#endif
        WmipReferenceLogger(LoggerId);
        TraceDebug((4, "WmiTraceThread: %d %d->%d\n",
                     LoggerId, RefCount-1, RefCount));        

        LoggerContext = WmipIsLoggerOn(LoggerId);
        if (LoggerContext != NULL) {
            if (LoggerContext->EnableFlags & EVENT_TRACE_FLAG_THREAD) {
                if (Create) {
                        PWMI_EXTENDED_THREAD_INFORMATION ThreadInfo;
                    Header = (PSYSTEM_TRACE_HEADER)
                              WmiReserveWithSystemHeader( LoggerId,
                                                          sizeof(WMI_EXTENDED_THREAD_INFORMATION),
                                                          NULL,
                                                          &BufferResource);

                    if (Header) {
                        Header->Packet.HookId = WMI_LOG_TYPE_THREAD_CREATE;
                        ThreadInfo = (PWMI_EXTENDED_THREAD_INFORMATION) (Header + 1);

                            ThreadInfo->ProcessId = HandleToUlong(Thread->Cid.UniqueProcess);
                            ThreadInfo->ThreadId = HandleToUlong(Thread->Cid.UniqueThread);
                            ThreadInfo->StackBase = Thread->Tcb.StackBase;
                            ThreadInfo->StackLimit = Thread->Tcb.StackLimit;

                            if (InitialTeb != NULL) {
                                    if ((InitialTeb->OldInitialTeb.OldStackBase == NULL) &&
                                        (InitialTeb->OldInitialTeb.OldStackLimit == NULL)) {
                                            ThreadInfo->UserStackBase = InitialTeb->StackBase;
                                            ThreadInfo->UserStackLimit = InitialTeb->StackLimit;
                                    } else {
                                            ThreadInfo->UserStackBase = InitialTeb->OldInitialTeb.OldStackBase;
                                            ThreadInfo->UserStackLimit = InitialTeb->OldInitialTeb.OldStackLimit;
                                    }
                            } else {
                                    ThreadInfo->UserStackBase = NULL;
                                    ThreadInfo->UserStackLimit = NULL;
                            }

                            ThreadInfo->StartAddr = (Thread)->StartAddress;
                            ThreadInfo->Win32StartAddr = (Thread)->Win32StartAddress;
                            ThreadInfo->WaitMode = -1;

                        WmipReleaseTraceBuffer(BufferResource, LoggerContext);
                    }
                } else {
                        PWMI_THREAD_INFORMATION ThreadInfo;
                    Header = (PSYSTEM_TRACE_HEADER)
                              WmiReserveWithSystemHeader( LoggerId,
                                                          sizeof(WMI_THREAD_INFORMATION),
                                                          NULL,
                                                          &BufferResource);

                    if (Header) {
                        Header->Packet.HookId = WMI_LOG_TYPE_THREAD_DELETE;
                        ThreadInfo = (PWMI_THREAD_INFORMATION) (Header + 1);
                            ThreadInfo->ProcessId = HandleToUlong((Thread)->Cid.UniqueProcess);
                            ThreadInfo->ThreadId = HandleToUlong((Thread)->Cid.UniqueThread);
                        WmipReleaseTraceBuffer(BufferResource, LoggerContext);
                    }
                }
            }
        }
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((4, "WmiTraceThread: %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));

    }
}


VOID
FASTCALL
WmipTracePageFault(
    IN NTSTATUS Status,
    IN PVOID VirtualAddress,
    IN PVOID TrapFrame
    )
/*++

Routine Description:

    This callout routine is called from mm\mmfault.c.
    It is a PPAGE_FAULT_NOTIFY_ROUTINE

Arguments:

    Status              Used to tell the type of fault
    VirtualAddress      The virtual address responsible for the fault
    TrapFrame           Trap Frame

Return Value:

    None

--*/

{
    UCHAR Type;
    PVOID *AuxInfo;
    PSYSTEM_TRACE_HEADER Header;
    PVOID BufferResource;
    PWMI_LOGGER_CONTEXT LoggerContext;

    if (Status == STATUS_PAGE_FAULT_DEMAND_ZERO)
        Type = EVENT_TRACE_TYPE_MM_DZF;
    else if (Status == STATUS_PAGE_FAULT_TRANSITION)
        Type = EVENT_TRACE_TYPE_MM_TF;
    else if (Status == STATUS_PAGE_FAULT_COPY_ON_WRITE)
        Type = EVENT_TRACE_TYPE_MM_COW;
    else if (Status == STATUS_PAGE_FAULT_PAGING_FILE)
        Type = EVENT_TRACE_TYPE_MM_HPF;
    else if (Status == STATUS_PAGE_FAULT_GUARD_PAGE)
        Type = EVENT_TRACE_TYPE_MM_GPF;
    else {
#if DBG
        DbgPrintEx(DPFLTR_WMILIB_ID,
                   DPFLTR_INFO_LEVEL,
                   "WmipTracePageFault: Skipping fault %X\n",
                   Status);
#endif
        return;
    }

    LoggerContext = WmipIsLoggerOn(WmipKernelLogger);
    if (LoggerContext == NULL) {
        return;
    }

    Header = (PSYSTEM_TRACE_HEADER)
             WmiReserveWithSystemHeader(
                WmipKernelLogger,
                2 * sizeof(PVOID),
                NULL,
                &BufferResource);

    if (Header == NULL)
        return;
    Header->Packet.Group = (UCHAR) (EVENT_TRACE_GROUP_MEMORY >> 8);
    Header->Packet.Type  = Type;

    AuxInfo = (PVOID*) ((PCHAR)Header + sizeof(SYSTEM_TRACE_HEADER));

    AuxInfo[0] = VirtualAddress;
    AuxInfo[1] = 0;
    if (TrapFrame != NULL) {

#ifdef _X86_

        AuxInfo[1] = (PVOID) ((PKTRAP_FRAME)TrapFrame)->Eip;

#endif

#ifdef _AMD64_

        AuxInfo[1] = (PVOID) ((PKTRAP_FRAME)TrapFrame)->Rip;

#endif

    }
    WmipReleaseTraceBuffer(BufferResource, LoggerContext);
    return;
}

VOID
WmipTraceNetwork(
    IN ULONG GroupType,         // Group/type for the event
    IN PVOID EventInfo,         // Event data as defined in MOF
    IN ULONG EventInfoLen,      // Length of the event data
    IN PVOID Reserved           // not used
    )
/*++

Routine Description:

    This callout routine is called from tcpip.sys to log a network event.

Arguments:

    GroupType       a ULONG key to indicate the action 

    EventInfo       a pointer to contiguous memory containing information
                    to be attached to event trace

    EventInfoLen    length of EventInfo

    Reserved        Not used.

Return Value:

    None

--*/
{
    PPERFINFO_TRACE_HEADER Header;
    PWMI_BUFFER_HEADER BufferResource;
    PWMI_LOGGER_CONTEXT LoggerContext;
    
    UNREFERENCED_PARAMETER (Reserved);

    LoggerContext = WmipLoggerContext[WmipKernelLogger];
    Header = WmiReserveWithPerfHeader(EventInfoLen, &BufferResource);
    if (Header == NULL) {
        return;
    }

    Header->Packet.HookId = (USHORT) GroupType;
    RtlCopyMemory((PUCHAR)Header + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data),
                  EventInfo, 
                  EventInfoLen);

    WmipReleaseTraceBuffer(BufferResource, LoggerContext);
    return;
}

VOID
WmipTraceIo(
    IN ULONG DiskNumber,
    IN PIRP Irp,
    IN PVOID Counters   // use PDISK_PERFORMANCE if we need it
    )
/*++

Routine Description:

    This callout routine is called from DiskPerf
    It is a PPHYSICAL_DISK_IO_NOTIFY_ROUTINE

Arguments:

    DiskNumber          The disk number assigned by DiskPerf
    CurrentIrpStack     The Irp stack location that DiskPerf is at
    Irp                 The Irp that is being passed through DiskPerf

Return Value:

    None

--*/

{
    PIO_STACK_LOCATION CurrentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    WMI_DISKIO_READWRITE *IoTrace;
    ULONG Size;
    PLARGE_INTEGER IoResponse;
    PSYSTEM_TRACE_HEADER Header;
    PVOID BufferResource;
    PWMI_LOGGER_CONTEXT LoggerContext;
    ULONG FileTraceOn = WmipTraceFileFlag;
    PFILE_OBJECT fileObject = NULL;
    PTRACE_FILE_WORK_ITEM TraceFileWorkQueueItem;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(Counters);

    Size = sizeof(struct _WMI_DISKIO_READWRITE);

    LoggerContext = WmipIsLoggerOn(WmipKernelLogger);
    if (LoggerContext == NULL) {
        return;
    }

    Header = (PSYSTEM_TRACE_HEADER)
             WmiReserveWithSystemHeader(
                WmipKernelLogger,
                Size,
                Irp->Tail.Overlay.Thread,
                &BufferResource);

    if (Header == NULL) {
        return;
    }

    Header->Packet.Group = (UCHAR) (EVENT_TRACE_GROUP_IO >> 8);
    if (CurrentIrpStack->MajorFunction == IRP_MJ_READ)
        Header->Packet.Type = EVENT_TRACE_TYPE_IO_READ;
    else
        Header->Packet.Type = EVENT_TRACE_TYPE_IO_WRITE;

    IoTrace = (struct _WMI_DISKIO_READWRITE *)
              ((PCHAR) Header + sizeof(SYSTEM_TRACE_HEADER));
    IoResponse          = (PLARGE_INTEGER) &CurrentIrpStack->Parameters.Read;

    IoTrace->DiskNumber = DiskNumber;
    IoTrace->IrpFlags   = Irp->Flags;
    IoTrace->Size       = (ULONG) Irp->IoStatus.Information;
    IoTrace->ByteOffset = CurrentIrpStack->Parameters.Read.ByteOffset.QuadPart;
    IoTrace->ResponseTime = (ULONG) IoResponse->QuadPart;

    if (IoResponse->HighPart == 0) {
        IoTrace->ResponseTime = IoResponse->LowPart;
    } else {
        IoTrace->ResponseTime = 0xFFFFFFFF;
    }
    IoTrace->HighResResponseTime = IoResponse->QuadPart;
    IoTrace->IrpAddr = (PVOID) Irp;
    IoTrace->FileObject = NULL;

    if (FileTraceOn) {
        PFILE_OBJECT *fileTable;
        ULONG i;
        ULONG LoggerId;
        ULONG currentValue, newValue, retValue;
#if DBG
        LONG RefCount;
#endif

        if (Irp->Flags & IRP_ASSOCIATED_IRP) {
            PIRP AssociatedIrp = Irp->AssociatedIrp.MasterIrp;
            if (AssociatedIrp != NULL) {
                fileObject = AssociatedIrp->Tail.Overlay.OriginalFileObject;
            }
        } else {
            fileObject = Irp->Tail.Overlay.OriginalFileObject;
        }
        IoTrace->FileObject = fileObject;

        //
        // We are done with the IO Hook. Release the Buffer but take 
        // a refcount on the logger context so that the fileTable 
        // does not go away. 
        //
        LoggerId = LoggerContext->LoggerId;

#if DBG
        RefCount =
#endif
        WmipReferenceLogger(LoggerId);
        TraceDebug((4, "WmiTraceFile: %d %d->%d\n",
                     LoggerId, RefCount-1, RefCount));

        WmipReleaseTraceBuffer(BufferResource, LoggerContext);

        //
        // Rules for validating a file object.
        //
        // 1. File object cannot be NULL.
        // 2. Thread field in the IRP cannot be NULL.
        // 3. We log only paging and user mode IO.

        fileTable = (PFILE_OBJECT *) WmipFileTable;

        if ( (fileObject == NULL) ||
             (Irp->Tail.Overlay.Thread == NULL) ||
             ((!(Irp->Flags & IRP_PAGING_IO)) && (Irp->RequestorMode != UserMode)) ||
             (fileTable == NULL) ||
             (fileObject->FileName.Length == 0) ) {
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceFile: %d %d->%d\n",
                        LoggerId, RefCount+1, RefCount));

            return;
        }

        //
        // File Cache: WmipFileIndex points to a slot for next entry. 
        // Start with previous index and scan the table backwards. 
        // If found, return else queue work item after checking max work 
        // item limit. 
        //


        currentValue = WmipFileIndex;

        for (i=0; i <MAX_FILE_TABLE_SIZE; i++) {

            if (currentValue == 0) {
                currentValue = MAX_FILE_TABLE_SIZE - 1;
            }
            else {
                currentValue--;
            }
            if (fileTable[currentValue] == fileObject) {
                //
                // CacheHit
                //
#if DBG
                RefCount =
#endif
                WmipDereferenceLogger(LoggerId);
                TraceDebug((4, "WmiTraceFile: %d %d->%d\n",
                            LoggerId, RefCount+1, RefCount));
                return;
            }
        }


        //
        // Cache Miss: First check for work item queue throttle
        //
        
        retValue = WmipWorkItemCounter;
        do {
            currentValue = retValue;
            if (currentValue == ETW_WORK_ITEM_LIMIT) {
#if DBG
                RefCount =
#endif
                WmipDereferenceLogger(LoggerId);
                TraceDebug((4, "WmiTraceFile: %d %d->%d\n",
                            LoggerId, RefCount+1, RefCount));
                return;

            } else {
                newValue = currentValue + 1;
            }
            retValue = InterlockedCompareExchange(&WmipWorkItemCounter, newValue, currentValue);
        } while (currentValue != retValue);



        //
        // Cache Miss: Simply kick out the next item based on global index
        // while ensuring that the WmipFileIndex is always in range. 
        //

        retValue = WmipFileIndex;
        do {
            currentValue = retValue;
            if (currentValue == (MAX_FILE_TABLE_SIZE - 1)) {
                newValue = 0;
            } else {
                newValue = currentValue + 1;
            }
            retValue = InterlockedCompareExchange(&WmipFileIndex, newValue, currentValue); 
        } while (currentValue != retValue);

        //
        // Allocate additional memory (up to 4K) with the work item allocation.
        // This space is used in WmipTraceFile for ObQueryNameString call
        //

        TraceFileWorkQueueItem = ExAllocatePoolWithTag(NonPagedPool, 
                                                      MAX_FILENAME_TO_LOG, 
                                                      TRACEPOOLTAG);
        if (TraceFileWorkQueueItem == NULL) {
            InterlockedDecrement(&WmipWorkItemCounter);
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceFile: %d %d->%d\n",
                        LoggerId, RefCount+1, RefCount));
            return;
        }

        Status = ObReferenceObjectByPointer (
                    fileObject,
                    0L,
                    IoFileObjectType,
                    KernelMode
                    );

        if (!NT_SUCCESS(Status)) {
            ExFreePool(TraceFileWorkQueueItem);
            InterlockedDecrement(&WmipWorkItemCounter);
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceFile: %d %d->%d\n",
                        LoggerId, RefCount+1, RefCount));
            return;
        }

        ExInitializeWorkItem(
            &TraceFileWorkQueueItem->WorkItem,
            WmipTraceFile,
            TraceFileWorkQueueItem
            );

        TraceFileWorkQueueItem->FileObject            = fileObject;
        TraceFileWorkQueueItem->BufferSize            = MAX_FILENAME_TO_LOG;

        //
        // Insert the fileObject into the table before queuing work item
        //

        ASSERT(retValue < MAX_FILE_TABLE_SIZE);
        fileTable[retValue] = fileObject;

#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((4, "WmiTraceFile: %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));

        ExQueueWorkItem(
            &TraceFileWorkQueueItem->WorkItem,
            DelayedWorkQueue
            );

    }
    else {
        WmipReleaseTraceBuffer(BufferResource, LoggerContext);
    }
    return;
}

VOID
WmipTraceVolMgr(
    IN PIRP ParentIrp,
    IN PIRP ChildIrp
    )
/*++

Routine Description:

    This routine traces the connection between IRPs entering the volume
    manager and the child IRPs they spawn

Return Value:

    None

--*/

{
    PSYSTEM_TRACE_HEADER Header;
    PVOID BufferResource;
    PWMI_LOGGER_CONTEXT LoggerContext;
    PVOID* DataAddress;

    LoggerContext = WmipIsLoggerOn(WmipKernelLogger);
    if (LoggerContext == NULL) {
        return;
    }

    Header = (PSYSTEM_TRACE_HEADER) 
             WmiReserveWithSystemHeader(WmipKernelLogger, 
                                        2*sizeof(PVOID), 
                                        NULL, 
                                        &BufferResource);
    if (Header == NULL) {
        return;
    }

    Header->Packet.HookId = WMI_LOG_TYPE_VOLMGR;

    DataAddress = (PVOID*) ((PCHAR) Header + sizeof(SYSTEM_TRACE_HEADER));
    *DataAddress = (PVOID) ParentIrp;
    DataAddress++;
    *DataAddress = (PVOID) ChildIrp;

    WmipReleaseTraceBuffer(BufferResource, LoggerContext);
    return;
}

VOID WmipTraceFile(
    IN PVOID TraceFileContext
    )
{
    ULONG len;
    PFILE_OBJECT fileObject;
    PUNICODE_STRING fileName;
    PPERFINFO_TRACE_HEADER Header;
    PWMI_BUFFER_HEADER BufferResource;
    PUCHAR AuxPtr;
    PWMI_LOGGER_CONTEXT LoggerContext;
    NTSTATUS Status;
    POBJECT_NAME_INFORMATION FileNameInfo;
    ULONG FileNameInfoOffset, ReturnLen;
    PTRACE_FILE_WORK_ITEM WorkItem = (PTRACE_FILE_WORK_ITEM) TraceFileContext;
#if DBG
    LONG RefCount;
#endif

    PAGED_CODE();


    FileNameInfoOffset = (ULONG) ALIGN_TO_POWER2(sizeof(TRACE_FILE_WORK_ITEM), WmiTraceAlignment);

    FileNameInfo = (POBJECT_NAME_INFORMATION) ((PUCHAR)TraceFileContext + 
                                                       FileNameInfoOffset);
    fileObject = WorkItem->FileObject;
    ASSERT(fileObject != NULL);
    ASSERT(WorkItem->BufferSize > FileNameInfoOffset);


    Status = ObQueryNameString( fileObject,
                                FileNameInfo,
                                WorkItem->BufferSize - FileNameInfoOffset,
                                &ReturnLen
                                );
    ObDereferenceObject(fileObject);

    if (NT_SUCCESS (Status)) {

        fileName = &FileNameInfo->Name;
        len = fileName->Length;

        if ((len > 0) && (fileName->Buffer != NULL)) {

            ULONG LoggerId = WmipKernelLogger;
            if (LoggerId < MAXLOGGERS) {
#if DBG
                RefCount =
#endif
                WmipReferenceLogger(LoggerId);
                TraceDebug((4, "WmipTraceFile: %d %d->%d\n",
                             LoggerId, RefCount-1, RefCount));
                LoggerContext = WmipIsLoggerOn(LoggerId);
                if (LoggerContext != NULL) {

                    Header = WmiReserveWithPerfHeader(
                                sizeof(PFILE_OBJECT) + len + sizeof(WCHAR),
                                &BufferResource);
                    if (Header != NULL) {
                        Header->Packet.Group = (UCHAR)(EVENT_TRACE_GROUP_FILE >> 8);
                        Header->Packet.Type  = EVENT_TRACE_TYPE_INFO;
                        AuxPtr = (PUCHAR)Header + 
                                 FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

                        *((PFILE_OBJECT*)AuxPtr) = fileObject;
                        AuxPtr += sizeof(PFILE_OBJECT);
    
                        RtlCopyMemory(AuxPtr, fileName->Buffer, len);
                        AuxPtr += len;
                        *((PWCHAR) AuxPtr) = UNICODE_NULL; // always put a NULL
    
                        WmipReleaseTraceBuffer(BufferResource, LoggerContext);
                    }
                }
#if DBG
                RefCount =
#endif
                WmipDereferenceLogger(LoggerId);
                TraceDebug((4, "WmiTraceThread: %d %d->%d\n",
                            LoggerId, RefCount+1, RefCount));
            }
        }
    }

    ExFreePool(TraceFileContext);
    InterlockedDecrement(&WmipWorkItemCounter);
}

VOID
WmipTraceLoadImage(
    IN PUNICODE_STRING ImageName,
    IN HANDLE ProcessId,
    IN PIMAGE_INFO ImageInfo
    )
{
    PSYSTEM_TRACE_HEADER Header;
    PUCHAR AuxInfo;
    PVOID BufferResource;
    ULONG Length, LoggerId;
    PWMI_LOGGER_CONTEXT LoggerContext;
#if DBG
    LONG RefCount;
#endif


    PAGED_CODE();
    UNREFERENCED_PARAMETER(ProcessId);

    if ((WmipIsLoggerOn(WmipKernelLogger) == NULL) &&
        (WmipIsLoggerOn(WmipEventLogger) == NULL)) {
        return;
    }
    if (ImageName == NULL) {
        return;
    }
    Length = ImageName->Length;
    if ((Length == 0) || (ImageName->Buffer == NULL)) {
        return;
    }

    for (LoggerId = 0; LoggerId < MAXLOGGERS; LoggerId++) {
        if (LoggerId != WmipKernelLogger && LoggerId != WmipEventLogger) {
            continue;
        }
#if DBG
        RefCount =
#endif
        WmipReferenceLogger(LoggerId);
        TraceDebug((4, "WmipTraceLoadImage: %d %d->%d\n",
                     LoggerId, RefCount-1, RefCount));        

        LoggerContext = WmipIsLoggerOn(LoggerId);
        if (LoggerContext != NULL) {
            if (LoggerContext->EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD) {
                PWMI_IMAGELOAD_INFORMATION ImageLoadInfo;

                Header = WmiReserveWithSystemHeader(
                            LoggerId,
                            FIELD_OFFSET (WMI_IMAGELOAD_INFORMATION, FileName) + Length + sizeof(WCHAR),
                            NULL,
                            &BufferResource);

                if (Header != NULL) {
                    Header->Packet.HookId = WMI_LOG_TYPE_PROCESS_LOAD_IMAGE;

                    ImageLoadInfo = (PWMI_IMAGELOAD_INFORMATION) (Header + 1);

                    ImageLoadInfo->ImageBase = ImageInfo->ImageBase;
                    ImageLoadInfo->ImageSize = ImageInfo->ImageSize;
                    ImageLoadInfo->ProcessId = HandleToUlong(ProcessId);

                    AuxInfo = (PUCHAR) &(ImageLoadInfo->FileName[0]);
                    RtlCopyMemory(AuxInfo, ImageName->Buffer, Length);
                    AuxInfo += Length;
                    *((PWCHAR) AuxInfo) = UNICODE_NULL; // put a trailing NULL

                    WmipReleaseTraceBuffer(BufferResource, LoggerContext);
                }
            }
        }
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((4, "WmipTraceLoadImage: %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));

    }
    PerfInfoFlushProfileCache();
}

VOID
WmipTraceRegistry(
    IN NTSTATUS         Status,
    IN PVOID            Kcb,
    IN LONGLONG         ElapsedTime,
    IN ULONG            Index,
    IN PUNICODE_STRING  KeyName,
    IN UCHAR            Type
    )
/*++

Routine Description:

    This routine is called to trace out registry calls

Arguments:

Return Value:

    None

--*/

{
    PCHAR   EventInfo;
    PSYSTEM_TRACE_HEADER Header;
    PVOID BufferResource;
    ULONG len = 0;
    PWMI_LOGGER_CONTEXT LoggerContext;

    PAGED_CODE();

    LoggerContext = WmipIsLoggerOn(WmipKernelLogger);
    if (LoggerContext == NULL) {
        return;
    }

    try {
        if( KeyName && KeyName->Buffer && KeyName->Length) {
            len += KeyName->Length;
            //
            // make sure it is a valid unicode string
            //
            if( len & 1 ) {
                len -= 1;
            }

            if ((len ==0 ) || (KeyName->Buffer[len/sizeof(WCHAR) -1] != 0) ) {
                //
                // make room for NULL terminator
                //
                len += sizeof(WCHAR);
            }
        } else {
            len += sizeof(WCHAR);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        // KeyName buffer is from user. AV can happen.
        return;
    }

    len += sizeof(PVOID) + sizeof(LONGLONG) + sizeof(ULONG);
#if defined(_WIN64)
    len += sizeof(LONG64);
#else
    len += sizeof(NTSTATUS);
#endif

    Header = (PSYSTEM_TRACE_HEADER)
             WmiReserveWithSystemHeader(
                        WmipKernelLogger,
                        len,
                        NULL,
                        &BufferResource);
    if (Header == NULL) {
        return;
    }

    Header->Packet.Group = (UCHAR) (EVENT_TRACE_GROUP_REGISTRY >> 8);
    Header->Packet.Type = Type;

    EventInfo = (PCHAR) ((PCHAR) Header + sizeof(SYSTEM_TRACE_HEADER));
#if defined(_WIN64)
    *((LONG64 *)EventInfo) = (LONG64)Status;
    EventInfo += sizeof(LONG64);
#else
    *((NTSTATUS *)EventInfo) = Status;
    EventInfo += sizeof(NTSTATUS);
#endif
    *((PVOID *)EventInfo) = Kcb;
    EventInfo += sizeof(PVOID);
    *((LONGLONG *)EventInfo) = ElapsedTime;
    EventInfo += sizeof(LONGLONG);
    *((ULONG *)EventInfo) = Index;
    EventInfo += sizeof(ULONG);

    len -= (sizeof(HANDLE) + sizeof(LONGLONG) + sizeof(ULONG) );
#if defined(_WIN64)
    len -= sizeof(LONG64);
#else
    len -= sizeof(NTSTATUS);
#endif

    try {
        if( KeyName && KeyName->Buffer && KeyName->Length) {
            RtlCopyMemory(EventInfo, KeyName->Buffer, len - sizeof(WCHAR));
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        // Cleanup just in case
        RtlZeroMemory(EventInfo, len - sizeof(WCHAR));
    }

    ((PWCHAR)EventInfo)[len/sizeof(WCHAR) -1] = UNICODE_NULL;

    WmipReleaseTraceBuffer(BufferResource, LoggerContext);
}

VOID
FASTCALL
WmiTraceContextSwap (
    IN PETHREAD OldEThread,
    IN PETHREAD NewEThread )
/*++

Routine Description:

    This routine is called to trace context swap
    operations.  It is called directly from the
    context swap procedure while the context swap
    lock is being held, so it is critical that this
    routine not take any locks.

    Assumptions:
    - This routine will only be called from the ContextSwap routine
    - This routine will always be called at IRQL >= DISPATCH_LEVEL
    - This routine will only be called when the PPerfGlobalGroupMask
      is not equal to null, and the context swap flag is set within 
      the structure to which PPerfGlobalGroupMask points to,
      and the kernel's WMI_LOGGER_CONTEXT struct has been fully initialized.
    - The Wmi kernel WMI_LOGGER_CONTEXT object, as well as all buffers
      it allocates are allocated from nonpaged pool.  All Wmi globals
      that we access are also in nonpaged memory.
    - This code has been locked into paged memory when the logger started
    - The logger context reference count has been incremented via the 
      InterlockedIncrement() operation in WmipReferenceLogger(WmipKernelLogger)
      by our start code.


Arguments:
    OldThread - ptr to ETHREAD object of thread
                being swapped out
    NewThread - ptr to ETHREAD object of thread
                being swapped in

Return Value:

    None

--*/
{
    UCHAR                       CurrentProcessor;
    PWMI_BUFFER_HEADER          Buffer;
    PPERFINFO_TRACE_HEADER      EventHeader;
    SIZE_T                      EventSize;
    PWMI_CONTEXTSWAP            ContextSwapData;

    //
    // Figure out which processor we are running on
    //
    CurrentProcessor = (UCHAR)KeGetCurrentProcessorNumber();

    //
    // If we currently have no context swap buffer for this processor
    // then we need to grab one from the ETW Free list.
    //
    Buffer = WmipContextSwapProcessorBuffers[CurrentProcessor];

    if (Buffer == NULL) {

        Buffer = WmipPopFreeContextSwapBuffer(
            CurrentProcessor);

        if( Buffer == NULL ) {
            return;
        }

        //
        // We have a legitimate buffer, so now we
        // set it as this processor's current cxtswap buffer
        //
        WmipContextSwapProcessorBuffers[CurrentProcessor] = Buffer;
    }
    
    if (Buffer->Offset <= Buffer->CurrentOffset) {
        //
        // Due to an rare unfortunate timing issue with buffer recycle, 
        // buffer CurrentOffset is corrupt. We should not write over
        // buffer boundary.
        //
        WmipPushDirtyContextSwapBuffer(CurrentProcessor, Buffer);
        //
        // Zero out the processor buffer pointer so that when we next come
        // into the trace code, we know to grab another one.
        //
        WmipContextSwapProcessorBuffers[CurrentProcessor] = NULL;

        return;
    }

    //
    // Compute the pointers to our event structures within the buffer
    // At this point, we will always have enough space in the buffer for
    // this event.  We check for a full buffer after we fill out the event
    //
    EventHeader     = (PPERFINFO_TRACE_HEADER)( (SIZE_T)Buffer
                    + (SIZE_T)Buffer->CurrentOffset);
    
    ContextSwapData = (PWMI_CONTEXTSWAP)( (SIZE_T)EventHeader
                    + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

    EventSize       = sizeof(WMI_CONTEXTSWAP)
                    + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);


    //
    // Fill out the event header
    //
    EventHeader->Marker = PERFINFO_TRACE_MARKER;
    EventHeader->Packet.Size = (USHORT) EventSize;
    EventHeader->Packet.HookId = PERFINFO_LOG_TYPE_CONTEXTSWAP;
    PerfTimeStamp(EventHeader->SystemTime);

    //
    // Assert that the event size is at aligned correctly
    //
    ASSERT( EventSize % WMI_CTXSWAP_EVENTSIZE_ALIGNMENT == 0);

    //
    // Fill out the event data struct for context swap
    //
    ContextSwapData->NewThreadId = HandleToUlong(NewEThread->Cid.UniqueThread);
    ContextSwapData->OldThreadId = HandleToUlong(OldEThread->Cid.UniqueThread);
    
    ContextSwapData->NewThreadPriority  = NewEThread->Tcb.Priority;
    ContextSwapData->OldThreadPriority  = OldEThread->Tcb.Priority;
    ContextSwapData->NewThreadQuantum   = NewEThread->Tcb.Quantum;
    ContextSwapData->OldThreadQuantum   = OldEThread->Tcb.Quantum;
    
    ContextSwapData->OldThreadWaitReason= OldEThread->Tcb.WaitReason;
    ContextSwapData->OldThreadWaitMode  = OldEThread->Tcb.WaitMode;
    ContextSwapData->OldThreadState     = OldEThread->Tcb.State;
    
    ContextSwapData->OldThreadIdealProcessor = 
        OldEThread->Tcb.IdealProcessor;
    
    //
    // Increment the offset.  Don't need synchronization here because
    // IRQL >= DISPATCH_LEVEL.
    //
    Buffer->CurrentOffset += (ULONG)EventSize;
    
    //
    // Check if the buffer is full by taking the difference between
    // the buffer's maximum offset and the current offset.
    //
    if ((Buffer->Offset - Buffer->CurrentOffset) <= EventSize) {

        //
        // Push the full buffer onto the FlushList.
        //
        WmipPushDirtyContextSwapBuffer(CurrentProcessor, Buffer);

        //
        // Zero out the processor buffer pointer so that when we next come
        // into the trace code, we know to grab another one.
        //
        WmipContextSwapProcessorBuffers[CurrentProcessor] = NULL;
    }

    return;
}

VOID
FASTCALL
WmiStartContextSwapTrace
    (
    )
/*++

Routine Description:

    Allocates the memory to track the per-processor buffers
    used by context swap tracing.  "locks" the logger by incrementing
    the logger context reference count by one.

    Assumptions:
    - This function will not run at DISPATCH or higher
    - The kernel logger context mutex has been acquired before entering
      this function.

    Calling Functions:
    - PerfInfoStartLog
    
Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Only used in checked builds - asserts if this code is called with
    // Irql > APC_LEVEL.
    //
    PAGED_CODE();

    //
    // Set the pointers to our buffers to NULL, indicating to the trace event
    // code that a buffer needs to be acquired.
    //
    RtlZeroMemory(
        WmipContextSwapProcessorBuffers,
        sizeof(PWMI_BUFFER_HEADER)*MAXIMUM_PROCESSORS);
}

VOID
FASTCALL
WmiStopContextSwapTrace
    (
    )
/*++

Routine Description:

    Forces a context swap on a processor by jumping onto it.
    Once a context swap has occured on a processor after the context
    swap tracing flag has been disabled, we are guaranteed that the
    buffer associated with that processor is not in use.  It is then
    safe to place that buffer on the flush list.

    Assumptions:
    - This function will not run at DISPATCH
    - The kernel logger context mutex was acquired before this function
      was called.

    Calling Functions:
    -PerfInfoStopLog

Arguments:

    None
    
Return Value:

    None; if we fail here there's nothing we can do anyway.

--*/
{
    PKTHREAD            ThisThread;
    KAFFINITY           OriginalAffinity;
    UCHAR               i;
    PWMI_LOGGER_CONTEXT LoggerContext;

    //
    // Only used in checked builds - asserts if this code is called with
    // Irql > APC_LEVEL.
    //
    PAGED_CODE();

    //
    // Remember the original thread affinity
    //
    ThisThread = KeGetCurrentThread();
    OriginalAffinity = ThisThread->Affinity;

    //
    // Get the kernel logger context- this should never fail.
    // If we can't get the logger context, then we have nowhere
    // to flush buffers and we might as well stop here.
    //
    LoggerContext = WmipLoggerContext[WmipKernelLogger];
    
    if( !WmipIsValidLogger( LoggerContext ) ) {
        return;
    }

    //
    // Loop through all processors and place their buffers on the flush list
    // This would probably break if the number of processors were decreased in
    // the middle of the trace.
    //
    for(i=0; i<KeNumberProcessors; i++) {
    
        //
        // Set the hard processor affinity to 1 << i
        // This effectively jumps onto the processor
        //
        KeSetSystemAffinityThread ( AFFINITY_MASK(i) );

        //
        // Check to make sure this processor even has a buffer, 
        // if it doesn't, then next loop
        //
        if(WmipContextSwapProcessorBuffers[i] == NULL) {
            continue;
        }

        //
        // Release the buffer to the flush list
        //
        WmipPushDirtyContextSwapBuffer(i, WmipContextSwapProcessorBuffers[i]);
        WmipContextSwapProcessorBuffers[i] = NULL;
    }

    //
    // Set our Affinity back to normal
    //
    KeSetSystemAffinityThread( OriginalAffinity );
    KeRevertToUserAffinityThread();

    return;
}

PWMI_LOGGER_CONTEXT
FASTCALL
WmipIsLoggerOn(
    IN ULONG LoggerId
    )
{
    PWMI_LOGGER_CONTEXT LoggerContext;

    if (LoggerId >= MAXLOGGERS) {
        return NULL;
    }
    LoggerContext = WmipLoggerContext[LoggerId];
    if (WmipIsValidLogger(LoggerContext)) {
        return LoggerContext;
    }
    else {
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\consumer.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

   consumer.c

Abstract:

    Data Consumer apis

--*/

#include "wmikmp.h"
#include <evntrace.h>

#include <ntcsrmsg.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

void WmipCompleteGuidIrpWithError(
    PWMIGUIDOBJECT GuidObject
    );

NTSTATUS WmipCreatePumpThread(
    PWMIGUIDOBJECT Object
    );

void WmipClearThreadObjectList(
    PWMIGUIDOBJECT MainObject
    );

void
WmipGetGuidPropertiesFromGuidEntry(
    PWMIGUIDPROPERTIES GuidInfo, 
    PGUIDENTRY GuidEntry);

BOOLEAN WmipIsQuerySetGuid(
    PBGUIDENTRY GuidEntry
    );

NTSTATUS WmipAddProviderIdToPIList(
    PBINSTANCESET **PIPtrPtr,
    PULONG PICountPtr,
    PULONG PIMaxPtr,
    PBINSTANCESET *StaticPIPtr,
    PBINSTANCESET InstanceSet
);

NTSTATUS WmipPrepareForWnodeAD(
    IN PWMIGUIDOBJECT GuidObject,
    OUT LPGUID Guid,
    IN OUT ULONG *ProviderIdCount,
    OUT PBINSTANCESET **ProviderIdList,
    OUT BOOLEAN *InternalGuid       
    );

ULONG WmipStaticInstanceNameSize(
    PBINSTANCESET InstanceSet
    );

void WmipInsertStaticNames(
    PWNODE_ALL_DATA Wnode,
    ULONG MaxWnodeSize,
    PBINSTANCESET InstanceSet
    );

NTSTATUS WmipQueryGuidInfo(
    IN OUT PWMIQUERYGUIDINFO QueryGuidInfo
    );

void WmipCopyFromEventQueues(
    IN POBJECT_EVENT_INFO ObjectArray,
    IN ULONG HandleCount,
    OUT PUCHAR OutBuffer,
    OUT ULONG *OutBufferSizeUsed,
    OUT PWNODE_HEADER *LastWnode,                               
    IN BOOLEAN IsHiPriority
    );

void WmipClearIrpObjectList(
    PIRP Irp
    );

NTSTATUS WmipReceiveNotifications(
    PWMIRECEIVENOTIFICATION ReceiveNotification,
    PULONG OutBufferSize,
    PIRP Irp
    );


NTSTATUS WmipQueueNotification(
    PWMIGUIDOBJECT Object,
    PWMIEVENTQUEUE EventQueue,
    PWNODE_HEADER Wnode
    );

PWNODE_HEADER WmipDereferenceEvent(
    PWNODE_HEADER Wnode
    );

PWNODE_HEADER WmipIncludeStaticNames(
    PWNODE_HEADER Wnode
    );

NTSTATUS WmipWriteWnodeToObject(
    PWMIGUIDOBJECT Object,
    PWNODE_HEADER Wnode,
    BOOLEAN IsHighPriority
);

NTSTATUS WmipProcessEvent(
    PWNODE_HEADER InWnode,
    BOOLEAN IsHighPriority,
    BOOLEAN FreeBuffer
    );

NTSTATUS WmipRegisterUMGuids(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Cookie,
    IN PWMIREGINFO RegInfo,
    IN ULONG RegInfoSize,
    OUT HANDLE *RequestHandle,
    OUT ULONG64 *LoggerContext
    );

NTSTATUS WmipUnregisterGuids(
    PWMIUNREGGUIDS UnregGuids
    );

NTSTATUS WmipWriteMBToObject(
    IN PWMIGUIDOBJECT RequestObject,
    IN PWMIGUIDOBJECT ReplyObject,
    IN PUCHAR Message,
    IN ULONG MessageSize
    );

NTSTATUS WmipWriteMessageToGuid(
    IN PBGUIDENTRY GuidEntry,
    IN PWMIGUIDOBJECT ReplyObject,
    IN PUCHAR Message,
    IN ULONG MessageSize,
    OUT PULONG WrittenCount                             
);

NTSTATUS WmipCreateUMLogger(
    IN OUT PWMICREATEUMLOGGER CreateInfo
    );

NTSTATUS WmipMBReply(
    IN HANDLE RequestHandle,
    IN ULONG ReplyIndex,
    IN PUCHAR Message,
    IN ULONG MessageSize
    );

NTSTATUS WmipPrepareWnodeSI(
    IN PWMIGUIDOBJECT GuidObject,
    IN OUT PWNODE_SINGLE_INSTANCE WnodeSI,
    IN OUT ULONG *ProviderIdCount,
    OUT PBINSTANCESET **ProviderIdList,
    OUT BOOLEAN *IsDynamic,
    OUT BOOLEAN *InternalGuid       
    );

void WmipCreatePumpThreadRoutine(
    PVOID Context
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,WmipIsQuerySetGuid)
#pragma alloc_text(PAGE,WmipOpenBlock)
#pragma alloc_text(PAGE,WmipAddProviderIdToPIList)
#pragma alloc_text(PAGE,WmipPrepareForWnodeAD)
#pragma alloc_text(PAGE,WmipStaticInstanceNameSize)
#pragma alloc_text(PAGE,WmipInsertStaticNames)
#pragma alloc_text(PAGE,WmipQueryAllData)
#pragma alloc_text(PAGE,WmipQueryAllDataMultiple)
#pragma alloc_text(PAGE,WmipPrepareWnodeSI)
#pragma alloc_text(PAGE,WmipQuerySetExecuteSI)
#pragma alloc_text(PAGE,WmipQuerySingleMultiple)
#pragma alloc_text(PAGE,WmipEnumerateGuids)
#pragma alloc_text(PAGE,WmipQueryGuidInfo)
#pragma alloc_text(PAGE,WmipClearIrpObjectList)
#pragma alloc_text(PAGE,WmipReceiveNotifications)
#pragma alloc_text(PAGE,WmipQueueNotification)
#pragma alloc_text(PAGE,WmipDereferenceEvent)
#pragma alloc_text(PAGE,WmipIncludeStaticNames)
#pragma alloc_text(PAGE,WmipWriteWnodeToObject)
#pragma alloc_text(PAGE,WmipProcessEvent)
#pragma alloc_text(PAGE,WmipUMProviderCallback)
#pragma alloc_text(PAGE,WmipRegisterUMGuids)
#pragma alloc_text(PAGE,WmipUnregisterGuids)
#pragma alloc_text(PAGE,WmipWriteMBToObject)
#pragma alloc_text(PAGE,WmipWriteMessageToGuid)
#pragma alloc_text(PAGE,WmipCreateUMLogger)
#pragma alloc_text(PAGE,WmipMBReply)
#pragma alloc_text(PAGE,WmipGetGuidPropertiesFromGuidEntry)
#pragma alloc_text(PAGE,WmipClearThreadObjectList)
#pragma alloc_text(PAGE,WmipClearObjectFromThreadList)
#pragma alloc_text(PAGE,WmipCreatePumpThread)
#pragma alloc_text(PAGE,WmipCopyFromEventQueues)
#pragma alloc_text(PAGE,WmipCreatePumpThreadRoutine)
#pragma alloc_text(PAGE,WmipMarkHandleAsClosed)
#pragma alloc_text(PAGE,WmipCompleteGuidIrpWithError)
#endif

BOOLEAN WmipIsQuerySetGuid(
    PBGUIDENTRY GuidEntry
    )
{
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;

    PAGED_CODE();
    
    WmipAssert(GuidEntry != NULL);
    
    WmipEnterSMCritSection();
    InstanceSetList = GuidEntry->ISHead.Flink;
    while (InstanceSetList != &GuidEntry->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
        if ( (InstanceSet->Flags & 
                (IS_TRACED | IS_CONTROL_GUID | IS_EVENT_ONLY)) == 0 )
        {
            //
            // If there is at least one IS that isn't traced and isn't
            // an event only then it is a queryset guid
            //
            WmipLeaveSMCritSection();
            return (TRUE);
        }
        InstanceSetList = InstanceSetList->Flink;
    }
    WmipLeaveSMCritSection();
    
    return (FALSE);
    
}


NTSTATUS WmipOpenBlock(
    IN ULONG Ioctl,
    IN KPROCESSOR_MODE AccessMode,
    IN POBJECT_ATTRIBUTES CapturedObjectAttributes,
    IN ULONG DesiredAccess,
    OUT PHANDLE Handle
    )
{
    PBGUIDENTRY GuidEntry;
    PWMIGUIDOBJECT Object;
    NTSTATUS Status;

    PAGED_CODE();
    
    //
    // Creates a guid handle with the desired access
    //
    Status = WmipOpenGuidObject(CapturedObjectAttributes,
                                DesiredAccess,
                                AccessMode,
                                Handle,
                                &Object);
                            
                            
    if (NT_SUCCESS(Status))
    {        
        Object->Type = Ioctl;
        
        if (Ioctl != IOCTL_WMI_OPEN_GUID)
        {
            GuidEntry = WmipFindGEByGuid(&Object->Guid, FALSE);
        
            //
            // Establish our object on the guidentry list
            //
            WmipEnterSMCritSection();
            if (GuidEntry != NULL)
            {
                InsertTailList(&GuidEntry->ObjectHead,
                               &Object->GEObjectList);
                                     
            }
            Object->GuidEntry = GuidEntry;
            WmipLeaveSMCritSection();
            
            switch (Ioctl)
            {
                case IOCTL_WMI_OPEN_GUID_FOR_QUERYSET:
                {
                    //
                    // Guid is being opened for query/set/method operations so
                    // we need to ensure that there is a guid entry and that
                    // the guid entry has InstanceSets attached and it is
                    // has at least one instance set that is not a traced 
                    // guid and is not an event only guid
                    //
                    if ((GuidEntry == NULL) ||
                        (GuidEntry->ISCount == 0) ||
                        (! WmipIsQuerySetGuid(GuidEntry)))
                    {
                        //
                        // Either we could not find a guidentry or there
                        // is no instance sets attached. We close the
                        // original handle and fail the IOCTL
                        //
                        ZwClose(*Handle);
                        Status = STATUS_WMI_GUID_NOT_FOUND;
                        break;
                    }
                    //
                    // Fall through
                    //
                }
                
                case IOCTL_WMI_OPEN_GUID_FOR_EVENTS:
                {
                    //
                    // Since we can register to receive events before
                    // the event provider has been registered we'll need
                    // to create the guid entry if one does not exist
                    //
                    
                    if (AccessMode == KernelMode)
                    {
                        Object->Flags |= WMIGUID_FLAG_KERNEL_NOTIFICATION;
                    }
                    
                    if (GuidEntry == NULL)
                    {
                        WmipAssert(Ioctl == IOCTL_WMI_OPEN_GUID_FOR_EVENTS);
                        
                        WmipEnterSMCritSection();
                        GuidEntry = WmipAllocGuidEntry();
                        if (GuidEntry != NULL)
                        {
                            //
                            // Initialize the new GuidEntry and place it 
                            // on the master GuidEntry list.
                            //
                            memcpy(&GuidEntry->Guid,
                                   &Object->Guid,
                                   sizeof(GUID));

                            InsertHeadList(WmipGEHeadPtr, &GuidEntry->MainGEList);
                            InsertTailList(&GuidEntry->ObjectHead,
                                           &Object->GEObjectList);
                            Object->GuidEntry = GuidEntry;
                            WmipLeaveSMCritSection();
                        } else {
                            WmipLeaveSMCritSection();
                            ZwClose(*Handle);
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            break;
                        }
                     }
                    
                    
                    //
                    // Now we need to see if we have to enable collection
                    // or events
                    //
                    Status = WmipEnableCollectOrEvent(GuidEntry,
                                         Ioctl,
                                         &Object->EnableRequestSent,
                                         0);
                    
                    if (! NT_SUCCESS(Status))
                    {
                        //
                        // For some reason enabling failed so just return
                        // the error
                        //
                        ZwClose(*Handle);
                    }
                    
                    //
                    // Don't unref the guid entry as that ref count is 
                    // taken by the object just placed on the list
                    //
                    break;
                }
                                                  
                default:
                {
                    //
                    // We should never get here.....
                    //
                    WmipAssert(FALSE);
            
                    ZwClose(*Handle);
                    Status = STATUS_ILLEGAL_FUNCTION;
                    break;
                }
            }
        } else {
            //
            // Mark this as a security object
            //
            Object->Flags |= WMIGUID_FLAG_SECURITY_OBJECT;
        }

        //
        // remove the ref taken when the object was created
        //
        ObDereferenceObject(Object);
    }
    return(Status);
}



NTSTATUS WmipAddProviderIdToPIList(
    PBINSTANCESET **PIPtrPtr,
    PULONG PICountPtr,
    PULONG PIMaxPtr,
    PBINSTANCESET *StaticPIPtr,
    PBINSTANCESET InstanceSet
)
{
    ULONG PICount;
    ULONG PIMax, NewPIMax;
    PBINSTANCESET *PIPtr, *OldPIPtr, *NewPIPtr;
    NTSTATUS Status;
    ULONG i;
 
    PAGED_CODE();
    
    Status = STATUS_SUCCESS;
    PICount = *PICountPtr;
    PIMax = *PIMaxPtr;
    PIPtr = *PIPtrPtr;
    
    //
    // Remember dynamic providerid
    //
       if (PICount == PIMax)
    {
        //
        // We have overflowed the PI List so we need to
        // reallocate a bigger buffer
        //
        NewPIMax = PIMax * 2;
        NewPIPtr = (PBINSTANCESET *)WmipAlloc(NewPIMax * 
                                              sizeof(PBINSTANCESET));
        OldPIPtr = PIPtr;
        if (NewPIPtr != NULL)
        {
            //
            // Copy provider ids from old to new buffer
            //
            memcpy(NewPIPtr, OldPIPtr, PIMax*sizeof(PBINSTANCESET));
            PIPtr = NewPIPtr;
            *PIPtrPtr = NewPIPtr;
            PIMax = NewPIMax;
            *PIMaxPtr = PIMax;
        } else {
            //
            // Bad break, we could not allocate more space
            // unref any instance sets and return an error
            //
            for (i = 0; i < PIMax; i++)
            {
                WmipUnreferenceIS(PIPtr[i]);
            }
            WmipUnreferenceIS(InstanceSet);
            *PIPtrPtr = NULL;
            
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
                        
        //
        // if previous buffer was not static then free it
        //
        if (OldPIPtr != StaticPIPtr)
        {
            WmipFree(OldPIPtr);
        }
    }
    
    if (NT_SUCCESS(Status))
    {
        //
        // Remember instance set
        //
        PIPtr[PICount++] = InstanceSet;
        *PICountPtr = PICount;
    }
    return(Status);
}

NTSTATUS WmipPrepareForWnodeAD(
    IN PWMIGUIDOBJECT GuidObject,
    OUT LPGUID Guid,
    IN OUT ULONG *ProviderIdCount,
    OUT PBINSTANCESET **ProviderIdList,
    OUT BOOLEAN *InternalGuid
    )
{
    PBINSTANCESET *PIPtr, *StaticPIPtr;
    ULONG PICount, PIMax;
    NTSTATUS Status;
    PBGUIDENTRY GuidEntry;
    PBINSTANCESET InstanceSet;
    PLIST_ENTRY InstanceSetList;

    PAGED_CODE();

    GuidEntry = GuidObject->GuidEntry;
    
    if ((GuidEntry != NULL) && (GuidEntry->ISCount > 0))
    {
        //
        // We were passed a valid guid handle, get out the guid 
        //
        *Guid = GuidEntry->Guid;

        Status = STATUS_SUCCESS;
        if (GuidEntry->Flags & GE_FLAG_INTERNAL) 
        {
            *InternalGuid = TRUE;
        } else {        
            //
            // Build list of provider ids to whom the QAD will be targetted
            //
            *InternalGuid = FALSE;
        
            StaticPIPtr = *ProviderIdList;
            PIPtr = StaticPIPtr;
            PIMax = *ProviderIdCount;
            PICount = 0;
    
            WmipEnterSMCritSection();
        
            InstanceSetList = GuidEntry->ISHead.Flink;
            while ((InstanceSetList != &GuidEntry->ISHead) && 
                   NT_SUCCESS(Status))
            {
                InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                                INSTANCESET,
                                                GuidISList);
            
                //
                // Take a refcount on the instance set so that it won't
                // go away until after we are done with our query
                // The refcount gets removed by the caller when it is 
                // done with the list or in WmipAddProviderIdTOLlist  if it
                // returns an error
                //
                        
                if ((InstanceSet->Flags & (IS_TRACED | IS_CONTROL_GUID | IS_EVENT_ONLY)) == 0)
                {
                    //
                    // Only take those IS that are not traced or control
                    // guids and are not event only guids
                    //
                    WmipReferenceIS(InstanceSet);
                    Status = WmipAddProviderIdToPIList(&PIPtr,
                                                 &PICount,
                                                 &PIMax,
                                                 StaticPIPtr,
                                                 InstanceSet);
                }
                                             
                InstanceSetList = InstanceSetList->Flink;
            }
        
            WmipLeaveSMCritSection();            
        
            if (PICount == 0)
            {
                Status = STATUS_WMI_GUID_DISCONNECTED;
            } else {
                *ProviderIdCount = PICount;
                *ProviderIdList = PIPtr;
            }
        }
    } else {
        Status = STATUS_WMI_GUID_DISCONNECTED;
    }
    
    return(Status);
}



ULONG WmipStaticInstanceNameSize(
    PBINSTANCESET InstanceSet
    )
/*+++

Routine Description:

    This routine will calculate the size needed to place instance names in
    a WNODE_ALL_DATA

Arguments:

    WmiInstanceInfo describes to instance set whose instance name size
        is to be calculated

Return Value:

    Size needed to place instance names in a WNODE_ALL_DATA plus 3. The
    extra 3 bytes are added in case the OffsetInstanceNameOffsets need to be
    padded since they must be on a 4 byte boundary.
        
---*/
{
    SIZE_T NameSize;
    ULONG i;

    PAGED_CODE();
    
    //
    // If we already computed this then just return the results
    if (InstanceSet->WADInstanceNameSize != 0)
    {
        return(InstanceSet->WADInstanceNameSize);
    }

    //
    // Start with a name size of 3 in case the OffsetInstanceNameOffset will
    // need to be padded so that it starts on a 4 byte boundary.
    NameSize = 3;

    if (InstanceSet->Flags & IS_INSTANCE_BASENAME)
    {
        //
        // For static base names we assume that there will never be more than
        // MAXBASENAMESUFFIXVALUE instances of a guid. So the size of each instance name 
        // would be the size of the base name plus the size of the suffix
        // plus a USHORT for the count (for counted string) plus a ULONG
        // to hold the offset to the instance name
        //
        WmipAssert((InstanceSet->IsBaseName->BaseIndex + InstanceSet->Count) < MAXBASENAMESUFFIXVALUE);
    
        NameSize += ((wcslen(InstanceSet->IsBaseName->BaseName) * sizeof(WCHAR)) +
                    MAXBASENAMESUFFIXLENGTH * sizeof(WCHAR) + 
                    sizeof(USHORT) + 
                    sizeof(ULONG)) * InstanceSet->Count;
                
    } else if (InstanceSet->Flags & IS_INSTANCE_STATICNAMES)
    {
        //
        // For a static name list we count up each size of
        // the static instance names in the list and add a ULONG and a USHORT
        // for the offset and count (for counted string)
        for (i = 0; i < InstanceSet->Count; i++)
        {
            NameSize += (wcslen(InstanceSet->IsStaticNames->StaticNamePtr[i]) + 2) * sizeof(WCHAR) + sizeof(ULONG);
        }
    }

    InstanceSet->WADInstanceNameSize = (ULONG)NameSize;

    return(ULONG)(NameSize);
}

void WmipInsertStaticNames(
    PWNODE_ALL_DATA Wnode,
    ULONG MaxWnodeSize,
    PBINSTANCESET InstanceSet
    )
/*+++

Routine Description:

    This routine will copy into the WNODE_ALL_DATA instance names for a
    static instance name set. If the Wnode_All_data is too small then it
    is converted to a WNODE_TOO_SMALL

Arguments:

    Wnode points at the WNODE_ALL_DATA
    MaxWnodeSize is the maximum size of the Wnode
    WmiInstanceInfo is the Instance Info

Return Value:

---*/
{
    PWCHAR NamePtr;
    PULONG NameOffsetPtr;
    ULONG InstanceCount;
    ULONG i;
    WCHAR Index[MAXBASENAMESUFFIXLENGTH+1];
    PWCHAR StaticName;
    ULONG SizeNeeded;
    SIZE_T NameLen;
    USHORT Len;
    ULONG PaddedBufferSize;
    size_t Size;
    HRESULT hr;

    PAGED_CODE();
    
    if ((InstanceSet->Flags &
                (IS_INSTANCE_BASENAME | IS_INSTANCE_STATICNAMES)) == 0)
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_ERROR_LEVEL,"WMI: Try to setup static names for dynamic guid\n"));
        return;
    }
    InstanceCount = InstanceSet->Count;

    //
    // Pad out the size of the incoming wnode to a 4 byte boundary since the
    // OffsetInstanceNameOffsets is being appended to the end of the
    // wnode and it must be on a 4 byte boundary
    //
    PaddedBufferSize = (Wnode->WnodeHeader.BufferSize + 3) & ~3;
    
    //
    // Compute the complete size needed to rewrite the WNODE to include
    // the instance names. 
    //
    //     Include the size that is needed to fill out 
    Size = WmipStaticInstanceNameSize(InstanceSet);

    //     Include the space needed for the array of offsets to the
    //     instance names plus the size of the names plus the padded
    //     size of the wnode
    SizeNeeded = (InstanceCount * sizeof(ULONG)) +
                 (ULONG)Size +
                 PaddedBufferSize;

    if (SizeNeeded > MaxWnodeSize)
    {
        //
        // If not enough space left in the buffer passed then build a
        // WNODE_TOO_SMALL as the result to indicate how much buffer
        // space is needed.
        //
        Wnode->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
        Wnode->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
        ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded = SizeNeeded;
        return;
    }

    //
    // Allocate space for the array of offsets to instance names
    //
    NameOffsetPtr = (PULONG)((PUCHAR)Wnode + PaddedBufferSize);
    Wnode->OffsetInstanceNameOffsets = (ULONG)((PUCHAR)NameOffsetPtr - (PUCHAR)Wnode);

    //
    // Point at the beginning of the area to write the instance names
    //
    NamePtr = (PWCHAR)(NameOffsetPtr + InstanceCount);


    if (InstanceSet->Flags & IS_INSTANCE_BASENAME)
    {
        //
        // The instance name is based upon a basename with a trailing
        // index number to provide uniqueness
        //
        if (InstanceSet->Flags & IS_PDO_INSTANCENAME)
        {
            Wnode->WnodeHeader.Flags |= WNODE_FLAG_PDO_INSTANCE_NAMES;
        }

        for (i = 0; i < InstanceCount; i++)
        {
            //
            // Account for space used by length of string that follows
            //
            Size -= sizeof(USHORT);
            *NameOffsetPtr++ = (ULONG)((PUCHAR)NamePtr - (PUCHAR)Wnode);

            //
            // Copy over basename while accounting length used by it
            //
            hr = StringCbCopy(NamePtr+1,
                              Size,
                              InstanceSet->IsBaseName->BaseName);
            WmipAssert(hr == S_OK);

            //
            // Format unique index number
            //
            hr = StringCbPrintf(Index,
                                sizeof(Index),
                                BASENAMEFORMATSTRING,
                                InstanceSet->IsBaseName->BaseIndex+i);
            WmipAssert(hr == S_OK);

            //
            // Append unique index number to instance name
            //
            hr = StringCbCat(NamePtr+1,
                           Size,
                           Index);
            WmipAssert(hr == S_OK);
            
            NameLen = wcslen(NamePtr+1) + 1;
            *NamePtr = (USHORT)NameLen * sizeof(WCHAR);
            NamePtr += NameLen + 1;
            
            Size -= NameLen * sizeof(WCHAR);
        }
    } else if (InstanceSet->Flags & IS_INSTANCE_STATICNAMES) {
        //
        // Instance names are from a list of static names
        //
        for (i = 0; i < InstanceCount; i++)
        {
            *NameOffsetPtr++ = (ULONG)((PUCHAR)NamePtr - (PUCHAR)Wnode);
            StaticName = InstanceSet->IsStaticNames->StaticNamePtr[i];
            Len = (USHORT)((wcslen(StaticName)+1) * sizeof(WCHAR));
            *NamePtr++ = Len;
            
            //
            // Account for space used by length of string that follows
            //
            Size -= sizeof(USHORT);

            //
            // Copy over and account for static name
            //
            hr = StringCbCopyEx(NamePtr,
                           Size,
                           StaticName,
                           NULL,
                           &Size,
                           0);
            WmipAssert(hr == S_OK);
            
            NamePtr += Len / sizeof(WCHAR);
            
        }
    }
    Wnode->WnodeHeader.BufferSize = SizeNeeded;
}



//
// This defines how many provider ids will fit within the static block. If
// we need more than this, then we'll have to allocate memory for it
//
#if DBG
#define MANYPROVIDERIDS 1
#else
#define MANYPROVIDERIDS 16
#endif

NTSTATUS WmipQueryAllData(
    IN PWMIGUIDOBJECT GuidObject,
    IN PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    IN PWNODE_ALL_DATA Wnode,
    IN ULONG OutBufferLen,
    OUT PULONG RetSize
    )
{
    NTSTATUS Status;
    PBINSTANCESET StaticPIList[MANYPROVIDERIDS];
    PBINSTANCESET *PIList;
    PBINSTANCESET InstanceSet;
    WNODE_ALL_DATA WnodeAllData;
    BOOLEAN IsBufferTooSmall;
    PWNODE_HEADER WnodeHeader;
    LOGICAL UsesStaticNames;
    PWNODE_TOO_SMALL WnodeTooSmall = (PWNODE_TOO_SMALL)&WnodeAllData;
    PWNODE_ALL_DATA WnodeAD;
    ULONG BufferLeft;
    ULONG SizeNeeded;
    ULONG PICount;
    ULONG WnodeFlags, WnodeSize;
    PWNODE_HEADER WnodeLast;
    ULONG Linkage;
    ULONG i;
    GUID Guid;
    PUCHAR Buffer;
    ULONG BufferUsed;
    HANDLE KernelHandle;
    BOOLEAN InternalGuid;
    IO_STATUS_BLOCK Iosb;
    
    PAGED_CODE();
    
    //
    // Check Security
    //
    if (GuidObject != NULL)
    {
        Status = ObReferenceObjectByPointer(GuidObject,
                                            WMIGUID_QUERY,
                                            WmipGuidObjectType,
                                            AccessMode);
    } else {
        KernelHandle = Wnode->WnodeHeader.KernelHandle;

        Status = ObReferenceObjectByHandle(KernelHandle,
                                           WMIGUID_QUERY,
                                           WmipGuidObjectType,
                                           AccessMode,
                                           &GuidObject,
                                           NULL);
    }
                   
    if (NT_SUCCESS(Status))
    {
        //
        // Get the provider id list for the guid 
        //
        PIList = StaticPIList;
        PICount = MANYPROVIDERIDS;
        Status = WmipPrepareForWnodeAD(GuidObject,
                                       &Guid,
                                       &PICount,
                                       &PIList,
                                       &InternalGuid);
        if (NT_SUCCESS(Status))
        {
            if (InternalGuid)
            {
                //
                // This is an internal guid so we fill out the WNODE_ALL_DATA
                // and mark it to be completed by the user mode code
                //
                Wnode->WnodeHeader.Guid = Guid;
                Wnode->WnodeHeader.Flags |= WNODE_FLAG_INTERNAL;
                Wnode->WnodeHeader.Linkage = 0;
                *RetSize = sizeof(WNODE_HEADER);
                Status = STATUS_SUCCESS;
            } else {
                //
                // Get all of the information from the WNODE_HEADER so we can 
                // rebuild it
                //
                WnodeFlags = Wnode->WnodeHeader.Flags;
                WnodeSize = Wnode->WnodeHeader.BufferSize;
                    
                //
                // Loop over all provider ids and send each a WAD query
                //
                Buffer = (PUCHAR)Wnode;
                BufferLeft = OutBufferLen;
                IsBufferTooSmall = FALSE;
                SizeNeeded = 0;
                WnodeLast = NULL;
                for (i = 0; i < PICount; i++)
                {
                    InstanceSet = PIList[i];
                    
                    if ((IsBufferTooSmall) || (BufferLeft < sizeof(WNODE_ALL_DATA)))
                    {
                        //
                        // If we have already determined that the buffer is
                        // too small then we use the static WNODE_ALL_DATA
                        // just to get the size needed
                        //
                        WnodeAD = &WnodeAllData;
                        BufferLeft = sizeof(WNODE_ALL_DATA);
                        IsBufferTooSmall = TRUE;
                    } else {
                        //
                        // Otherwise we will append to the end of the buffer
                        //
                        WnodeAD = (PWNODE_ALL_DATA)Buffer;
                    }
                    
                    //
                    // Build the WNODE and send it off to the driver
                    //
                    WnodeHeader = (PWNODE_HEADER)WnodeAD;
                    WnodeHeader->BufferSize = sizeof(WNODE_HEADER);
                    UsesStaticNames =((InstanceSet->Flags & IS_INSTANCE_BASENAME) ||
                                      (InstanceSet->Flags & IS_INSTANCE_STATICNAMES));
                    WnodeHeader->Flags = WnodeFlags | (UsesStaticNames ?
                                                WNODE_FLAG_STATIC_INSTANCE_NAMES :
                                                0);
                    WnodeHeader->Guid = Guid;
                    WnodeHeader->ProviderId = PIList[i]->ProviderId;
                    WnodeHeader->Linkage = 0;

                    if (Irp != NULL)
                    {
                        Status = WmipForwardWmiIrp(Irp,
                                                   IRP_MN_QUERY_ALL_DATA,
                                                   WnodeHeader->ProviderId,
                                                   &WnodeHeader->Guid,
                                                   BufferLeft,
                                                   WnodeAD);
                    } else {
                        Status = WmipSendWmiIrp(
                                                IRP_MN_QUERY_ALL_DATA,
                                                WnodeHeader->ProviderId,
                                                &WnodeHeader->Guid,
                                                BufferLeft,
                                                WnodeAD,
                                                &Iosb);
                    }
                    
                    if (NT_SUCCESS(Status))
                    {
                        if (WnodeHeader->Flags & WNODE_FLAG_TOO_SMALL)
                        {
                            //
                            // There was not enough space to write the WNODE
                            // so we keep track of how much was needed and then
                            // switch to the mode where we just query for size needed
                            //
                            WnodeTooSmall = (PWNODE_TOO_SMALL)WnodeAD;
                            
                            SizeNeeded += WnodeTooSmall->SizeNeeded;
                            if (UsesStaticNames)
                            {
                                SizeNeeded = (SizeNeeded + 3) &~3;
                                SizeNeeded += WmipStaticInstanceNameSize(InstanceSet)+
                                              (InstanceSet->Count *sizeof(ULONG));
                            }
                                      
                            SizeNeeded = (SizeNeeded +7) & ~7;
                            
                            IsBufferTooSmall = TRUE;
                        } else if (IsBufferTooSmall) {
                            //
                            // We passed a minimum sized buffer, but it is large
                            // enough for the driver. Since we are just trying
                            // to get the size needed we get the size he needs
                            // and throw away his data
                            //
                            SizeNeeded += WnodeAD->WnodeHeader.BufferSize +
                                          WmipStaticInstanceNameSize(InstanceSet) +
                                          (InstanceSet->Count *sizeof(ULONG));
                            SizeNeeded = (SizeNeeded +7) & ~7;
        
                        } else {
                            //
                            // The driver returned a completed WNODE_ALL_DATA
                            // so we need to link the previous WNODE_ALL_DATA to
                            // this one, fill out any static instance names, and
                            // then update the buffer pointer and size
                            //
                            if (WnodeLast != NULL)
                            {
                                Linkage = (ULONG) ((PCHAR)WnodeAD - (PCHAR)WnodeLast);
                                WnodeLast->Linkage = Linkage;
                            }
                            WnodeLast = (PWNODE_HEADER)WnodeAD;
                            
                            if (UsesStaticNames)
                            {
                                //
                                // We need to insert the static names 
                                //
                                WmipInsertStaticNames(WnodeAD,
                                                      BufferLeft,
                                                      InstanceSet);
        
                                if (WnodeAD->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL)
                                {
                                    //
                                    // The static names caused us to run out of
                                    // buffer so we switch to mode  where we
                                    // query for the sizes
                                    //
                                    WnodeTooSmall = (PWNODE_TOO_SMALL)WnodeAD;
                                    IsBufferTooSmall = TRUE;
                                    BufferUsed = WnodeTooSmall->SizeNeeded;
                                } else {
                                    //
                                    // Static names fit so just pull out the updated
                                    // wnode size
                                    //
                                    BufferUsed = WnodeAD->WnodeHeader.BufferSize;
                                }                        
                            } else {
                                //
                                // Wnode has dynamic names so just add size returned
                                // by driver
                                //
                                BufferUsed = WnodeAD->WnodeHeader.BufferSize;
                            }
                            
                            //
                            // Update size needed and advance to free space in
                            // output buffer
                            //
                            BufferUsed = (BufferUsed + 7) & ~7;
                            SizeNeeded += BufferUsed;
                            
                            //
                            // Make sure that by adding in pad we don't run out of
                            // room in buffer
                            //
                            if ((! IsBufferTooSmall) && (BufferLeft >= BufferUsed))
                            {
                                BufferLeft -= BufferUsed;
                                Buffer += BufferUsed;
                            } else {
                                IsBufferTooSmall = TRUE;
                            }
                        }
                    } else {
                        //
                        // The driver failed the request, but that is no biggie
                        // as we just ignore it for now
                        //
                    }
                    
                    //
                    // We are done with the instance set so remove our ref
                    // on it so it can go away if need be
                    //
                    WmipUnreferenceIS(InstanceSet);
                }
                
                if (SizeNeeded == 0)
                {
                    //
                    // No devices responded to the WMI Query All Data so we
                    // return an error
                    //
                    Status = STATUS_WMI_GUID_NOT_FOUND;
                } else if ((IsBufferTooSmall) &&
                           (SizeNeeded > OutBufferLen)) {
                    //
                    // Our buffer passed was too small so return a WNODE_TOO_SMALL
                    //
                    WnodeTooSmall = (PWNODE_TOO_SMALL)Wnode;
                    WnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                    WnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                    WnodeTooSmall->SizeNeeded = SizeNeeded;
                    *RetSize = sizeof(WNODE_TOO_SMALL);
                    Status = STATUS_SUCCESS;
                } else {
                    *RetSize = SizeNeeded;
                    Status = STATUS_SUCCESS;
                }
        
                //
                // Make sure any memory allocated for the PI list is freed
                //
                if ((PIList != StaticPIList) && (PIList != NULL))
                {
                    WmipFree(PIList);           
                }    
            }
        }
        //
        // And remove ref on guid object
        //
        ObDereferenceObject(GuidObject);    
    }
    
    return(Status);
}

NTSTATUS WmipQueryAllDataMultiple(
    IN ULONG ObjectCount,
    IN PWMIGUIDOBJECT *ObjectList,
    IN PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    IN OUT PUCHAR BufferPtr,        
    IN ULONG BufferSize,
    IN PWMIQADMULTIPLE QadMultiple,
    OUT ULONG *ReturnSize
    )
{
    ULONG i;
    HANDLE *Handles;
    ULONG Count;
    WNODE_ALL_DATA WnodeAD;
    BOOLEAN BufferOverFlow;
    ULONG SkipSize, RetSize, SizeNeeded;
    ULONG WnodeSize;
    NTSTATUS Status, Status2;
    ULONG Linkage = 0;
    PWNODE_TOO_SMALL WnodeTooSmall;
    PWNODE_HEADER WnodePrev;
    PUCHAR Buffer;
    PWNODE_ALL_DATA Wnode;
    PWMIGUIDOBJECT Object = NULL;
    
    PAGED_CODE();

    Status = STATUS_SUCCESS;

    if (ObjectList == NULL) {

        WmipAssert(QadMultiple != NULL);
        WmipAssert(QadMultiple->HandleCount > 0);

        //
        // Copy the handle list out of the system buffer since it will
        // be overwritten by the first query all data
        //
        Count = QadMultiple->HandleCount;
        Handles = (HANDLE *)WmipAlloc(Count * sizeof(HANDLE));
    
        if (Handles != NULL)
        {
            for (i = 0; i < Count; i++)
            {
                Handles[i] = QadMultiple->Handles[i].Handle;
            }
        
        } else {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {

        WmipAssert(ObjectCount > 0);

        Count = ObjectCount;
        Handles = NULL;
    }

    SizeNeeded = 0;
    Buffer = BufferPtr;
        
    BufferOverFlow = FALSE;
    WnodePrev = NULL;        
    Wnode = (PWNODE_ALL_DATA)Buffer;
    WnodeSize = BufferSize;
    
    for (i = 0; i < Count; i++)
    {
        if ((Wnode == &WnodeAD) || (WnodeSize < sizeof(WNODE_ALL_DATA)))
        {
            //
            // If there is no more room, we are just querying for the
            // size that will be needed.
            //
            Wnode = &WnodeAD;
            WnodeSize = sizeof(WNODE_ALL_DATA);
            WnodePrev = NULL;
        } else {
            Wnode = (PWNODE_ALL_DATA)Buffer;
            WnodeSize = BufferSize;
        }
            
        //
        // Build WNODE_ALL_DATA in order to do the query
        //
        RtlZeroMemory(Wnode, sizeof(WNODE_ALL_DATA));
        Wnode->WnodeHeader.Flags = WNODE_FLAG_ALL_DATA;
        Wnode->WnodeHeader.BufferSize = sizeof(WNODE_HEADER);

        if (ObjectList == NULL)
        {
            Wnode->WnodeHeader.KernelHandle = Handles[i];
        } else {
            Object = ObjectList[i];
        }
        
        Status2 = WmipQueryAllData(Object,
                                   Irp,
                                   AccessMode,
                                   Wnode,
                                   WnodeSize,
                                   &RetSize);
                               
        if (NT_SUCCESS(Status2))
        {
            if (Wnode->WnodeHeader.Flags & WNODE_FLAG_INTERNAL) 
            {
                //
                // Skip any internal guid quesries 
                //
            } else if (Wnode->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL) {
                //
                // There is no enough room so just tally up
                // the size that will be needed.
                //
                WnodeTooSmall = (PWNODE_TOO_SMALL)Wnode;
                SizeNeeded += (WnodeTooSmall->SizeNeeded+7) & ~7;
                Wnode = &WnodeAD;
                BufferOverFlow = TRUE;
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,"WMI: %x Too Small %x needed, total %x\n",
                            ObjectList ? ObjectList[i] : Handles[i],
                            WnodeTooSmall->SizeNeeded, SizeNeeded));
            } else if (Wnode == &WnodeAD) {
                //
                // Even though this succeeded, we still aren't going
                // to be able to return any data so just count up
                // how much size we need
                //
                SizeNeeded += (RetSize+7) & ~7;
                BufferOverFlow = TRUE;
            
                WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                  DPFLTR_API_INFO_LEVEL,"WMI: %x Large Enough but full %x needed, total %x\n",
                            ObjectList ? ObjectList[i] : Handles[i],
                            RetSize, SizeNeeded));
                
            } else {
                //
                // We successfully got data. Link the previous wnode
                // to this one
                //
                if (WnodePrev != NULL)
                {
                    WnodePrev->Linkage = Linkage;
                }
                
                WnodePrev = (PWNODE_HEADER)Wnode;
                while (WnodePrev->Linkage != 0)
                {
                    WnodePrev = (PWNODE_HEADER)OffsetToPtr(WnodePrev,
                                                      WnodePrev->Linkage);
                }
                
                SkipSize = (RetSize+7) &~7;
                SizeNeeded += SkipSize;
                BufferSize -= SkipSize;
                Buffer += SkipSize;
                
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,"WMI: %x Large Enough %x needed, total %x\n",
                            ObjectList ? ObjectList[i] : Handles[i],
                            RetSize, SizeNeeded));
                
                Linkage = (ULONG) ((PCHAR)Buffer - (PCHAR)WnodePrev);
            }
        } else {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,"WMI: %x Failed %x, total %x\n",
                            ObjectList ? ObjectList[i] : Handles[i],
                            Status2,
                            SizeNeeded));
        }
    }

    if (Handles != NULL)
    {
        WmipFree(Handles);
    }
        
    if (BufferOverFlow)
    {
        WnodeTooSmall = (PWNODE_TOO_SMALL)BufferPtr;
        WnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
        WnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
        WnodeTooSmall->SizeNeeded = SizeNeeded;
        *ReturnSize = sizeof(WNODE_TOO_SMALL);
    } else {
        *ReturnSize = SizeNeeded;
    }
    
    return(Status);
}

NTSTATUS WmipPrepareWnodeSI(
    IN PWMIGUIDOBJECT GuidObject,
    IN OUT PWNODE_SINGLE_INSTANCE WnodeSI,
    IN OUT ULONG *ProviderIdCount,
    OUT PBINSTANCESET **ProviderIdList,
    OUT BOOLEAN *IsDynamic,
    OUT BOOLEAN *InternalGuid
    )
{
    NTSTATUS Status;
    PBGUIDENTRY GuidEntry;
    ULONG i;
    PWNODE_HEADER Wnode;
    PWCHAR CInstanceName;
    PWCHAR InstanceName;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    PBINSTANCESET *PIPtr = NULL;
    PBINSTANCESET *StaticPIPtr = NULL;
    ULONG PICount = 0, PIMax;
    BOOLEAN Done;

    PAGED_CODE();
    
    *IsDynamic = TRUE;
    GuidEntry = GuidObject->GuidEntry;
    Wnode = (PWNODE_HEADER)WnodeSI;
    
    if ((GuidEntry != NULL)  && (GuidEntry->ISCount > 0))
    {
        //
        // We were passed a valid guid handle, fill out the guid 
        // in WNODE_HEADER
        //
        Status = STATUS_SUCCESS;
        Wnode->Guid = GuidEntry->Guid;

        if (GuidEntry->Flags & GE_FLAG_INTERNAL) 
        {
            *InternalGuid = TRUE;
        } else {        
            *InternalGuid = FALSE;
            
            //
            // Obtain instance name from WNODE
            //
            CInstanceName = (PWCHAR)OffsetToPtr(WnodeSI, 
                                                WnodeSI->OffsetInstanceName);
            InstanceName = WmipCountedToSz(CInstanceName);
            if (InstanceName != NULL)
            {
                //
                // Remember the static provider id list and assume that the 
                // request is going to be dynamic
                //
                StaticPIPtr = *ProviderIdList;
                PIPtr = StaticPIPtr;
                PIMax = *ProviderIdCount;
                PICount = 0;
                
                //
                // March down instance set list to see if we have a 
                // static name and build the list of dynamic provider ids
                // 
                Done = FALSE;
            
                WmipEnterSMCritSection();
                if (GuidEntry->ISCount > 0)
                {
                    InstanceSetList = GuidEntry->ISHead.Flink;
                    while ((InstanceSetList != &GuidEntry->ISHead) && ! Done)
                    {
                        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                                        INSTANCESET,
                                                        GuidISList);
                                        
                        if ((InstanceSet->Flags & (IS_TRACED | IS_CONTROL_GUID | IS_EVENT_ONLY)) == 0)
                        {
                            //
                            // Only take those IS that are not traced or control
                            // guids and are not event only guids
                            //
                            if (InstanceSet->Flags & IS_INSTANCE_BASENAME)
                            {
                                PBISBASENAME IsBaseName;
                                ULONG BaseIndex;
                                PWCHAR BaseName;
                                SIZE_T BaseNameLen;
                                PWCHAR SuffixPtr;
                                ULONG Suffix;
                                WCHAR SuffixText[MAXBASENAMESUFFIXLENGTH+1];
                            
                                //
                                // See if the instance name is from this base name
                                //
                                IsBaseName = InstanceSet->IsBaseName;
                        
                                BaseIndex = IsBaseName->BaseIndex;
                                BaseName = IsBaseName->BaseName;
                                BaseNameLen = wcslen(BaseName);
                         
                                if ((wcslen(InstanceName) > BaseNameLen) && 
                                    (_wcsnicmp(InstanceName, BaseName, BaseNameLen) == 0))
                                {
                                    //
                                    // The suffix matches the beginning of our instance
                                    // name and our instance name is longer than the
                                    // suffix.
                                    //
                                    SuffixPtr = &InstanceName[BaseNameLen];
                                    Suffix = _wtoi(SuffixPtr);
                                    if ((WmipIsNumber(SuffixPtr) && 
                                        (Suffix >= BaseIndex) && 
                                        (Suffix < (BaseIndex + InstanceSet->Count))))
                                    {
                                        //
                                        // Our suffix is a number within the range for
                                        // this instance set
                                        //
                                        if (Suffix < MAXBASENAMESUFFIXVALUE)
                                        {
                                            StringCbPrintf(SuffixText,
                                                           sizeof(SuffixText),
                                                           BASENAMEFORMATSTRING,
                                                           Suffix);
                                            if (_wcsicmp(SuffixText, SuffixPtr) == 0)
                                            {
                                                //
                                                // Our instance name is part of the
                                                // instance set so note the provider id
                                                // and instance index
                                                //
                                                Wnode->Flags |= WNODE_FLAG_STATIC_INSTANCE_NAMES;
                                                Wnode->ProviderId = InstanceSet->ProviderId;
                                                WnodeSI->InstanceIndex = Suffix - BaseIndex;
                                                *IsDynamic = FALSE;
                                                Done = TRUE;
                                            }
                                        }
                                    }
                                }                    
                             } else if (InstanceSet->Flags & IS_INSTANCE_STATICNAMES) {
                                //
                                // See if the passed instance name matches any of the 
                                // static names for this instance set
                                //
                                PWCHAR *StaticNames;
                        
                                StaticNames = InstanceSet->IsStaticNames->StaticNamePtr;
                                for (i =0; i < InstanceSet->Count; i++)
                                {
                                    if (_wcsicmp(StaticNames[i], InstanceName) == 0)
                                    {
                                        //
                                        // We matched our instance name with a static
                                        // instance name. Remember provider id and
                                        // instance index.
                                        //
                                        Wnode->Flags |= WNODE_FLAG_STATIC_INSTANCE_NAMES;
                                        Wnode->ProviderId = InstanceSet->ProviderId;
                                        WnodeSI->InstanceIndex = i;
                                        *IsDynamic = FALSE;
                                        Done = TRUE;
                                        break;
                                    }
                                }
                        
                            } else {
                                //
                                // Remember dynamic providerid
                                //
                                WmipReferenceIS(InstanceSet);
                                Status = WmipAddProviderIdToPIList(&PIPtr,
                                                             &PICount,
                                                             &PIMax,
                                                             StaticPIPtr,
                                                             InstanceSet);
                                if (! NT_SUCCESS(Status))
                                {
                                    Done = TRUE;
                                }
                             }
                         }
                        InstanceSetList = InstanceSetList->Flink;
                    }
                } else {
                    //
                    // There are no instance sets registered for this guid
                    //
                    Status = STATUS_WMI_GUID_DISCONNECTED;
                }
                
                WmipFree(InstanceName);             
                WmipLeaveSMCritSection();               
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
            
        
            if (*IsDynamic)
            {
                //
                // Dynamic instance name so return list of dynamic providers
                //
                *ProviderIdCount = PICount;
                *ProviderIdList = PIPtr;
            } else {
                //
                // Static instance name so unref an dynamic instance sets
                //
                if (PIPtr != NULL)
                {
                    for (i = 0; i < PICount; i++)
                    {
                        WmipUnreferenceIS(PIPtr[i]);
                    }
                
                    if (PIPtr != StaticPIPtr)
                    {
                        WmipFree(PIPtr);
                    }
                }
            }
        }
    } else {
        Status = STATUS_WMI_GUID_DISCONNECTED;
    }
    
    return(Status);                             
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

const ACCESS_MASK DesiredAccessForFunction[] =
{
    WMIGUID_QUERY,         // IRP_MN_QUERY_ALL_DATA
    WMIGUID_QUERY,         // IRP_MN_QUERY_SINGLE_INSTANCE
    WMIGUID_SET,           // IRP_MN_CHANGE_SINGLE_INSTANCE
    WMIGUID_SET,           // IRP_MN_CHANGE_SINGLE_ITEM
    0,                     // IRP_MN_ENABLE_EVENTS
    0,                     // IRP_MN_DISABLE_EVENTS
    0,                     // IRP_MN_ENABLE_COLLECTION
    0,                     // IRP_MN_DISABLE_COLLECTION
    0,                     // IRP_MN_REGINFO
    WMIGUID_EXECUTE,       // IRP_MN_EXECUTE_METHOD
    0,                     // IRP_MN_TRACE_EVENT or IRP_MN_SET_TRACE_NOTIFY
    0                      // IRP_MN_REGINFO_EX
};

NTSTATUS WmipQuerySetExecuteSI(
    IN PWMIGUIDOBJECT GuidObject,
    IN PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    IN UCHAR MinorFunction,
    IN OUT PWNODE_HEADER Wnode,
    IN ULONG OutBufferSize,
    OUT PULONG RetSize
    )
{
    NTSTATUS Status, ReturnStatus;
    PBINSTANCESET StaticPIList[MANYPROVIDERIDS];
    PBINSTANCESET *PIList;
    HANDLE KernelHandle;
    ULONG PICount;
    BOOLEAN IsDynamic;
    ULONG i;
    BOOLEAN InternalGuid;
    IO_STATUS_BLOCK Iosb;

    PAGED_CODE();

    WmipAssert(((MinorFunction >= IRP_MN_QUERY_ALL_DATA) &&
                (MinorFunction <= IRP_MN_CHANGE_SINGLE_ITEM)) ||
               (MinorFunction == IRP_MN_EXECUTE_METHOD));


    //
    // Check Security
    //
    if (GuidObject != NULL)
    {
        Status = ObReferenceObjectByPointer(GuidObject,
                                            DesiredAccessForFunction[MinorFunction],
                                            WmipGuidObjectType,
                                            AccessMode);        
    } else {
        KernelHandle = Wnode->KernelHandle;
        Status = ObReferenceObjectByHandle(KernelHandle,
                                          DesiredAccessForFunction[MinorFunction],
                                          WmipGuidObjectType,
                                          AccessMode,
                                          &GuidObject,
                                          NULL);
    }
                   
    if (NT_SUCCESS(Status))
    {        
        PIList = StaticPIList;
        PICount = MANYPROVIDERIDS;
        Status = WmipPrepareWnodeSI(GuidObject,
                        (PWNODE_SINGLE_INSTANCE)Wnode,
                                &PICount,
                                &PIList,
                                &IsDynamic,
                                &InternalGuid);

        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,
                          "WMI: QSI Prepare [%s - %s] %x with %x PI at %p\n",
                          IsDynamic ? "Dynamic" : "Static", 
                          InternalGuid  ? "Internal" : "External",
                          Wnode->KernelHandle, PICount, PIList));
                      
        if (NT_SUCCESS(Status))
        {
            if (InternalGuid)
            {
                //
                // Internal guid query 
                //
                Wnode->Flags |= WNODE_FLAG_INTERNAL;
                Wnode->BufferSize = sizeof(WNODE_HEADER);
                Irp->IoStatus.Information = sizeof(WNODE_HEADER);
            } else {
                if (IsDynamic)
                {
                    //
                    // We need to loop over all dynamic instance names until
                    // one of them responds successfully and then we assume
                    // that they own the instance
                    //

                    if ((MinorFunction == IRP_MN_CHANGE_SINGLE_ITEM) ||
                        (MinorFunction == IRP_MN_EXECUTE_METHOD))
                    {
                        Status = STATUS_WMI_ITEMID_NOT_FOUND;
                    } else {
                        Status = STATUS_WMI_INSTANCE_NOT_FOUND;
                    }
        
                    for (i = 0; i < PICount; i++)
                    {
                        Wnode->ProviderId = PIList[i]->ProviderId;
                        if (Irp != NULL)
                        {
                            ReturnStatus = WmipForwardWmiIrp(Irp,
                                               MinorFunction,
                                               Wnode->ProviderId,
                                               &Wnode->Guid,
                                               OutBufferSize,
                                               Wnode);

                            if (NT_SUCCESS(ReturnStatus))
                            {
                                *RetSize = (ULONG)Irp->IoStatus.Information;
                            }                           
                        } else {
                            ReturnStatus = WmipSendWmiIrp(
                                                       MinorFunction,
                                                       Wnode->ProviderId,
                                                       &Wnode->Guid,
                                                       OutBufferSize,
                                                       Wnode,
                                                       &Iosb);
                            
                            if (NT_SUCCESS(ReturnStatus))
                            {
                                *RetSize = (ULONG)Iosb.Information;
                            }
                        }
                        
                        //
                        // One of these status codes imply that the device does
                        // positively claim the instance name and so we break out
                        // and return the results
                        //
                        if ((NT_SUCCESS(ReturnStatus)) ||
                            (ReturnStatus == STATUS_WMI_SET_FAILURE) ||
                            (ReturnStatus == STATUS_WMI_ITEMID_NOT_FOUND) ||
                            (ReturnStatus == STATUS_WMI_READ_ONLY))
                        {
                            Status = ReturnStatus;
                            break;
                        }
                                       
                                       
                        //
                         // If the device does not own the instance it can
                        // only return STATUS_WMI_INSTANCE_NOT_FOUND or 
                        // STATUS_WMI_GUID_NOT_FOUND. Any other return code
                        // implies that the device owns the instance, but 
                         // encountered an error.
                        //                
                        if ( (ReturnStatus != STATUS_WMI_INSTANCE_NOT_FOUND) &&
                             (ReturnStatus != STATUS_WMI_GUID_NOT_FOUND))
                        {
                            Status = ReturnStatus;
                        }
                    }

                    //
                    // Unreference each of the dynamic instance sets.
                    //

                    for (i = 0; i < PICount; ++i) {
                        WmipUnreferenceIS(PIList[i]);
                    }
                    
                    if ((PIList != StaticPIList) && (PIList != NULL))
                    {
                        WmipFree(PIList);
                    }    
                } else {
                    //
                    // Since we have a static instance name we can target directly
                    // at the device that has our instance name
                    //
                    if (Irp != NULL)
                    {
                        Status = WmipForwardWmiIrp(Irp,
                                                   MinorFunction,
                                                   Wnode->ProviderId,
                                                   &Wnode->Guid,
                                                   OutBufferSize,
                                                   Wnode);
                                               
                        *RetSize = (ULONG)Irp->IoStatus.Information;
                    } else {
                        Status = WmipSendWmiIrp(
                                                   MinorFunction,
                                                   Wnode->ProviderId,
                                                   &Wnode->Guid,
                                                   OutBufferSize,
                                                   Wnode,
                                                   &Iosb);
                                               
                        *RetSize = (ULONG)Iosb.Information;
                    }
                }
            }
        }
    
        //
        // And remove ref on guid object
        //
        ObDereferenceObject(GuidObject);    
    }

    return(Status);
}

NTSTATUS WmipQuerySingleMultiple(
    IN PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    IN OUT PUCHAR BufferPtr,        
    IN ULONG BufferSize,
    IN PWMIQSIMULTIPLE QsiMultiple,
    IN ULONG QueryCount,
    IN PWMIGUIDOBJECT *ObjectList,
    IN PUNICODE_STRING InstanceNames,    
    OUT ULONG *ReturnSize
    )
{
    PWMIQSIINFO QsiInfo;
    ULONG WnodeQSISize;
    ULONG WnodeSizeNeeded;
    NTSTATUS Status, Status2;
    ULONG SizeNeeded;
    BOOLEAN BufferFull, BufferOverFlow;
    PWNODE_HEADER WnodePrev;
    PUCHAR Buffer;
    ULONG i;
    ULONG WnodeSize;
    PWNODE_SINGLE_INSTANCE Wnode;
    PWCHAR InstanceName;
    ULONG RetSize;
    PWNODE_TOO_SMALL WnodeTooSmall;
    ULONG Linkage = 0;
    ULONG SkipSize;
    PWMIGUIDOBJECT Object = NULL;
    UNICODE_STRING UString;
    HANDLE KernelHandle;
    PWNODE_SINGLE_INSTANCE WnodeQSIPtr;

    union {
        WNODE_SINGLE_INSTANCE Wnode;
        UCHAR Buffer[sizeof(WNODE_SINGLE_INSTANCE) + (256 * sizeof(WCHAR)) + sizeof(ULONG)];
    } WnodeQSIStatic;

    PAGED_CODE();

    WmipAssert(QueryCount > 0);

    //
    // We are called by kernel mode and passed an object list and InstanceNames
    // or we are called by user mode and passed a QsiMultiple instead
    //

    WmipAssert( ((AccessMode == KernelMode) &&
                  (QsiMultiple == NULL) && 
                  (ObjectList != NULL) && 
                  (InstanceNames != NULL)) ||
                ((AccessMode == UserMode) &&
                  (QsiMultiple != NULL) && 
                  (ObjectList == NULL) && 
                  (InstanceNames == NULL)) );

    Status = STATUS_SUCCESS;
    if (ObjectList == NULL)
    {
        //
        // if this is a user call then we need to copy out the
        // QSIMULTIPLE information since it is in the system buffer and
        // will get overwritten on the first query
        //
        QsiInfo = (PWMIQSIINFO)WmipAlloc(QueryCount * sizeof(WMIQSIINFO));

        if (QsiInfo != NULL)
        {
            RtlCopyMemory(QsiInfo, 
                          &QsiMultiple->QsiInfo, 
                          QueryCount * sizeof(WMIQSIINFO));
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        Object = NULL;
    } else {
        QsiInfo = NULL;
    }

    if (NT_SUCCESS(Status))
    {
        SizeNeeded = 0;
        BufferFull = FALSE;
        BufferOverFlow = FALSE;
        WnodePrev = NULL;
        Buffer = BufferPtr;

        WnodeQSIPtr = &WnodeQSIStatic.Wnode;
        WnodeQSISize = sizeof(WnodeQSIStatic.Buffer);
        
        for (i = 0; i < QueryCount; i++)
        {
            if (ObjectList == NULL)
            {
                UString.Length = QsiInfo[i].InstanceName.Length;
                UString.MaximumLength = QsiInfo[i].InstanceName.MaximumLength;
                UString.Buffer = QsiInfo[i].InstanceName.Buffer;
                KernelHandle = QsiInfo[i].Handle.Handle;
            } else {
                UString = InstanceNames[i];
                Object = ObjectList[i];
                KernelHandle = NULL;
            }
            
            WnodeSizeNeeded = (FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                             VariableData) +
                                UString.Length + 
                                sizeof(USHORT) + 7) & ~7;

            if ((BufferFull) || (BufferSize < WnodeSizeNeeded))
            {
                //
                // If there is no more room, we are just querying for the
                // size that will be needed.
                //
                if (WnodeSizeNeeded > WnodeQSISize)
                {
                    //
                    // Our temporary buffer is too small so lets alloc a
                    // larger one
                    //
                    if (WnodeQSIPtr != &WnodeQSIStatic.Wnode)
                    {
                        WmipFree(WnodeQSIPtr);
                    }
                    
                    WnodeQSIPtr = (PWNODE_SINGLE_INSTANCE)WmipAllocNP(WnodeSizeNeeded);
                    
                    if (WnodeQSIPtr == NULL)
                    {
                        //
                        // We couldn't allocate a larger temporary buffer
                        // so we abort this call and try to exit gracefully
                        //
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }
                    
                    WnodeQSISize = WnodeSizeNeeded;
                }
                
                Wnode = WnodeQSIPtr;
                WnodeSize = WnodeSizeNeeded;
                WnodePrev = NULL;
                BufferFull = TRUE;
            } else {
                //
                // Plenty of room so build wnode directly into the output
                // buffer
                //
                Wnode = (PWNODE_SINGLE_INSTANCE)Buffer;
                WnodeSize = BufferSize;
            }
            
            //
            // Build WNODE_SINGLE_INSTANCE in order to do the query
            //
            RtlZeroMemory(Wnode, sizeof(WNODE_SINGLE_INSTANCE));
            Wnode->WnodeHeader.Flags = WNODE_FLAG_SINGLE_INSTANCE;
            Wnode->WnodeHeader.BufferSize = WnodeSizeNeeded;
            Wnode->WnodeHeader.KernelHandle = KernelHandle;
            
            Wnode->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                     VariableData);
            Wnode->DataBlockOffset = WnodeSizeNeeded;
            InstanceName = (PWCHAR)OffsetToPtr(Wnode, 
                                               Wnode->OffsetInstanceName);

            
            *InstanceName++ = UString.Length;
            try
            {
                if (AccessMode == UserMode)
                {
                    ProbeForRead(UString.Buffer,
                                 UString.Length,
                                 sizeof(WCHAR));
                }
                 
                RtlCopyMemory(InstanceName,
                              UString.Buffer,
                              UString.Length);
                  
                
            } except(EXCEPTION_EXECUTE_HANDLER) {
                //
                // If an error occured probing then we fail the entire call
                //
                Status = GetExceptionCode();
                break;
            }
    
    
            Status2 = WmipQuerySetExecuteSI(Object,
                                            Irp,
                                            AccessMode,
                                            IRP_MN_QUERY_SINGLE_INSTANCE,
                                            (PWNODE_HEADER)Wnode,
                                            WnodeSize,
                                            &RetSize);
                                   
            if (NT_SUCCESS(Status2))
            {
                if (Wnode->WnodeHeader.Flags & WNODE_FLAG_INTERNAL) 
                {
                    //
                    // Skip any internal guid quesries 
                    //
                } else if (Wnode->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL) {
                    //
                    // There is no enough room so just tally up
                    // the size that will be needed.
                    //
                    WnodeTooSmall = (PWNODE_TOO_SMALL)Wnode;
                    SizeNeeded += (WnodeTooSmall->SizeNeeded+7) & ~7;
                    BufferFull = TRUE;
                    BufferOverFlow = TRUE;
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,
                                    "WMI: QSIM %ws too small %x SizeNeeded %x\n",
                                     UString.Buffer,
                                     (WnodeTooSmall->SizeNeeded+7) & ~7,
                                     SizeNeeded));
                } else if (BufferFull) {
                    //
                    // There was enough room, but the buffer was already
                    // filled so we just tally up the size needed
                    //
                    SizeNeeded += (RetSize+7) & ~7;
                    BufferOverFlow = TRUE;
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,
                                    "WMI: QSIM %ws big enough but full  %x SizeNeeded %x\n",
                                     UString.Buffer,
                                     (RetSize+7) & ~7,
                                     SizeNeeded));
                } else {
                    //
                    // We successfully got data. Link the previous wnode
                    // to this one
                    //
                    if (WnodePrev != NULL)
                    {
                        WnodePrev->Linkage = Linkage;
                    }
                    
                    WnodePrev = (PWNODE_HEADER)Wnode;
                    while (WnodePrev->Linkage != 0)
                    {
                        WnodePrev = (PWNODE_HEADER)OffsetToPtr(WnodePrev,
                                                          WnodePrev->Linkage);
                    }
                    
                    SkipSize = (RetSize+7) &~7;
                    SizeNeeded += SkipSize;
                    BufferSize -= SkipSize;
                    Buffer += SkipSize;

                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,
                                    "WMI: QSIM %ws big enough %x SizeNeeded %x\n",
                                     UString.Buffer,
                                     SkipSize,
                                     SizeNeeded));
                    
                    Linkage = (ULONG) ((PCHAR)Buffer - (PCHAR)WnodePrev);
                }
            } else {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,
                                    "WMI: QSIM %ws Failed SizeNeeded %x\n",
                                     UString.Buffer,
                                     SizeNeeded));
            }
        }
        
        if (WnodeQSIPtr != &WnodeQSIStatic.Wnode)
        {
            WmipFree(WnodeQSIPtr);
        }
                  
        if (NT_SUCCESS(Status) && (BufferFull))
        {
            WnodeTooSmall = (PWNODE_TOO_SMALL)BufferPtr;
            WnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
            WnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
            WnodeTooSmall->SizeNeeded = SizeNeeded;
            *ReturnSize = sizeof(WNODE_TOO_SMALL);
        } else {
            *ReturnSize = SizeNeeded;
        }

        if (QsiInfo != NULL)
        {
            WmipFree(QsiInfo);
        }
    }
    
    return(Status);
}

void
WmipGetGuidPropertiesFromGuidEntry(
    PWMIGUIDPROPERTIES GuidInfo, 
    PGUIDENTRY GuidEntry)
/*++
Routine Description:

    This routine fills GuidInfo with the properties for the Guid
    represented by the GuidEntry. Note that this call is made holding
    the SMCritSection.

Arguments:

Return Value:

--*/
{
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;

    PAGED_CODE();
    
    GuidInfo->GuidType = WMI_GUIDTYPE_DATA;
    GuidInfo->IsEnabled = FALSE;
    GuidInfo->LoggerId = 0;
    GuidInfo->EnableLevel = 0;
    GuidInfo->EnableFlags = 0;

    InstanceSetList = GuidEntry->ISHead.Flink;
    while (InstanceSetList != &GuidEntry->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        GuidISList);
        if (InstanceSet->Flags & IS_EVENT_ONLY) 
        {
            GuidInfo->GuidType = WMI_GUIDTYPE_EVENT;
        }
        if (((InstanceSet->Flags & IS_ENABLE_EVENT) ||
            (InstanceSet->Flags & IS_ENABLE_COLLECTION)) ||
            (InstanceSet->Flags & IS_COLLECTING))
        {
            GuidInfo->IsEnabled = TRUE;
        }
        if ( (InstanceSet->Flags & IS_TRACED) &&
             (InstanceSet->Flags & IS_CONTROL_GUID) )
        {
            GuidInfo->GuidType = WMI_GUIDTYPE_TRACECONTROL;
            break;
        }
        InstanceSetList = InstanceSetList->Flink;
    }
    

    if (GuidEntry->Flags & GE_NOTIFICATION_TRACE_FLAG)
    {
        if (GuidInfo->GuidType == WMI_GUIDTYPE_TRACECONTROL) {
            //
            // If a NotificationEntry is found for a TraceControlGuid
            // it means that it is enabled.
            //
            ULONG64 LoggerContext = GuidEntry->LoggerContext;
            GuidInfo->IsEnabled = TRUE; 
            GuidInfo->LoggerId = WmiGetLoggerId(LoggerContext);
            GuidInfo->EnableLevel = WmiGetLoggerEnableLevel(LoggerContext);
            GuidInfo->EnableFlags = WmiGetLoggerEnableFlags(LoggerContext);
        }
    }
}

NTSTATUS WmipEnumerateGuids(
    ULONG Ioctl,
    PWMIGUIDLISTINFO GuidList,
    ULONG MaxBufferSize,
    ULONG *OutBufferSize
)
{
    ULONG TotalGuidCount;
    ULONG WrittenGuidCount;
    ULONG AllowedGuidCount;
    PWMIGUIDPROPERTIES GuidPtr;
    PBGUIDENTRY GuidEntry;
    PLIST_ENTRY GuidEntryList;
    

    PAGED_CODE();
    
    TotalGuidCount = 0;
    WrittenGuidCount = 0;
    AllowedGuidCount = (MaxBufferSize - FIELD_OFFSET(WMIGUIDLISTINFO, GuidList)) / sizeof(WMIGUIDPROPERTIES);
    
    GuidPtr = &GuidList->GuidList[0];
    
    WmipEnterSMCritSection();
    
    //
    // Fill up structure with list of guids
    //
    GuidEntryList = WmipGEHeadPtr->Flink;
    while (GuidEntryList != WmipGEHeadPtr)
    {
        GuidEntry = CONTAINING_RECORD(GuidEntryList,
                                     GUIDENTRY,
                                     MainGEList);

        TotalGuidCount++;
        if (WrittenGuidCount < AllowedGuidCount)
        {
            GuidPtr[WrittenGuidCount].Guid = GuidEntry->Guid;
            WrittenGuidCount++;
        }
        
        GuidEntryList = GuidEntryList->Flink;
    }
    
    if (Ioctl == IOCTL_WMI_ENUMERATE_GUIDS_AND_PROPERTIES)
    {
        //
        // If needed fill struct with guid properties
        //
        TotalGuidCount = 0;
        WrittenGuidCount = 0;
        GuidEntryList = WmipGEHeadPtr->Flink;
        while (GuidEntryList != WmipGEHeadPtr)
        {
            GuidEntry = CONTAINING_RECORD(GuidEntryList,
                                     GUIDENTRY,
                                     MainGEList);

            TotalGuidCount++;
            if (WrittenGuidCount < AllowedGuidCount)
            {
                WmipGetGuidPropertiesFromGuidEntry(&GuidPtr[WrittenGuidCount], 
                                               GuidEntry);
                WrittenGuidCount++;
            }
        
            GuidEntryList = GuidEntryList->Flink;
        }       
    }
    
    WmipLeaveSMCritSection();
    
    GuidList->TotalGuidCount = TotalGuidCount;
    GuidList->ReturnedGuidCount = WrittenGuidCount;
                 
    *OutBufferSize = FIELD_OFFSET(WMIGUIDLISTINFO, GuidList) +
                     WrittenGuidCount * sizeof(WMIGUIDPROPERTIES);
                 
    return(STATUS_SUCCESS);
}

NTSTATUS WmipQueryGuidInfo(
    IN OUT PWMIQUERYGUIDINFO QueryGuidInfo
    )
{
    HANDLE Handle;
    NTSTATUS Status;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    PBGUIDENTRY GuidEntry;
    PWMIGUIDOBJECT GuidObject;
    
    PAGED_CODE();
    
    Handle = QueryGuidInfo->KernelHandle.Handle;
    
    Status = ObReferenceObjectByHandle(Handle,
                                       WMIGUID_QUERY,
                                       WmipGuidObjectType,
                                       UserMode,
                                       &GuidObject,
                                       NULL);
                   
    if (NT_SUCCESS(Status))
    {
        GuidEntry = GuidObject->GuidEntry;
    
        if (GuidEntry != NULL)
        {
            //
            // Assume that the guid is not expensive and then loop over 
            // all instances to see if one of them is expensive.
            //
            QueryGuidInfo->IsExpensive = FALSE;
                
            WmipEnterSMCritSection();
            InstanceSetList = GuidEntry->ISHead.Flink;
            while (InstanceSetList != &GuidEntry->ISHead)
            {
                InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                                    INSTANCESET,
                                                    GuidISList);
            
                if (InstanceSet->Flags & IS_EXPENSIVE)
                {
                    //
                    // The guid is expensive so remember that and break
                    // out of loop
                    //
                    QueryGuidInfo->IsExpensive = TRUE;
                    break;
                }
                InstanceSetList = InstanceSetList->Flink;
            }
        
            WmipLeaveSMCritSection();
        } else {
            //
            // The guid object exists, but there is not a corresponding 
            // guidentry which is an error.
            //
            Status = STATUS_WMI_GUID_DISCONNECTED;
        }
    
    //
    // And remove ref on guid object
    //
        ObDereferenceObject(GuidObject);    
    
    }
    return(Status);
}

//
// The head of the list that contains the guid objects associated with
// an irp is in the DriverContext  part of the irp
//
#define IRP_OBJECT_LIST_HEAD(Irp) (PLIST_ENTRY)((Irp)->Tail.Overlay.DriverContext)

void WmipClearIrpObjectList(
    PIRP Irp
    )
{
    PLIST_ENTRY ObjectListHead;
    PLIST_ENTRY ObjectList, ObjectListNext;
    PWMIGUIDOBJECT Object;
        
    PAGED_CODE();
    
    //
    // This routine assumes that the SMCritSection is being held
    //
    ObjectListHead = IRP_OBJECT_LIST_HEAD(Irp);
    ObjectList = ObjectListHead->Flink;
    
    //
    // Loop over all objects associated with this irp and reset the
    // value for its associated irp since this irp is now going away
    //
    while (ObjectList != ObjectListHead)
    {
        Object = CONTAINING_RECORD(ObjectList,
                                   WMIGUIDOBJECT,
                                   IrpObjectList);
                            
        WmipAssert(Object->Irp == Irp);
        WmipAssert(Object->EventQueueAction == RECEIVE_ACTION_NONE);
        Object->Irp = NULL;
        RemoveEntryList(ObjectList);
        ObjectListNext = ObjectList->Flink;
        ObjectList = ObjectListNext;
    }
}

void WmipClearObjectFromThreadList(
    PWMIGUIDOBJECT Object
    )
{
    PLIST_ENTRY ThreadList;
    
    PAGED_CODE();

    ThreadList = &Object->ThreadObjectList;
    
    if (IsListEmpty(ThreadList))
    {
        //
        // if this is the last object on the thread list then we need
        // to close the handle (in the system handle table) to the user
        // mode process
        //
        ZwClose(Object->UserModeProcess);
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,
                          "WMI: Closed UserModeProcessHandle %x\n", Object->UserModeProcess));
    }

    Object->UserModeProcess = NULL;
    Object->UserModeCallback = NULL;
    Object->EventQueueAction = RECEIVE_ACTION_NONE;

    RemoveEntryList(ThreadList);
    InitializeListHead(ThreadList);
}

void WmipClearThreadObjectList(
    PWMIGUIDOBJECT MainObject
    )
{
    PWMIGUIDOBJECT Object;
    PLIST_ENTRY ObjectList;
#if DBG 
    HANDLE MyUserModeProcess;
    PUSER_THREAD_START_ROUTINE MyUserModeCallback;
#endif  
    
    PAGED_CODE();

    //
    // This routine assumes the SMCrit Section is held
    //
#if DBG     
    MyUserModeProcess = MainObject->UserModeProcess;
    MyUserModeCallback = MainObject->UserModeCallback;
#endif      
        
    ObjectList = &MainObject->ThreadObjectList;
    do 
    {
        Object = CONTAINING_RECORD(ObjectList,
                                   WMIGUIDOBJECT,
                                   ThreadObjectList);

        WmipAssert(Object->UserModeProcess == MyUserModeProcess);
        WmipAssert(Object->UserModeCallback == MyUserModeCallback);
        WmipAssert(Object->EventQueueAction == RECEIVE_ACTION_CREATE_THREAD);

        ObjectList = ObjectList->Flink;

        WmipClearObjectFromThreadList(Object);
        
    } while (! IsListEmpty(ObjectList));
}

void WmipNotificationIrpCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Cancel routine for a pending read notification irp.

Arguments:

    DeviceObject is the device object of the WMI service device

    Irp is the pending Irp to be cancelled

Return Value:


--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    WmipEnterSMCritSection();
    WmipClearIrpObjectList(Irp);
    WmipLeaveSMCritSection();

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT );
}


#define WmipHaveHiPriorityEvent(Object) \
      (((Object)->HiPriority.Buffer != NULL) &&  \
       ((Object)->HiPriority.NextOffset != 0))

#define WmipHaveLoPriorityEvent(Object) \
      (((Object)->LoPriority.Buffer != NULL) &&  \
       ((Object)->LoPriority.NextOffset != 0))

#define WmipSetHighWord(a, b) \
    (a) &= ~(0xffff0000); \
    (a) |= ( (USHORT)(b) << 16)

void WmipCopyFromEventQueues(
    IN POBJECT_EVENT_INFO ObjectArray,
    IN ULONG HandleCount,
    OUT PUCHAR OutBuffer,
    OUT ULONG *OutBufferSizeUsed,
    OUT PWNODE_HEADER *LastWnode,                               
    IN BOOLEAN IsHiPriority
    )
{

    PWMIGUIDOBJECT GuidObject;
    ULONG i, Earliest;
    ULONG SizeUsed, Size;
    PWNODE_HEADER InWnode, OutWnode;
    LARGE_INTEGER Timestamp, LastTimestamp;
    PWMIEVENTQUEUE EventQueue;


    //
    // Consider adding extra code for perf
    // 1. If only 1 object is passed
    // 2. Once we find the earliest event we look ahead in that same
    //    event queue buffer assuming that it will be earlier than
    //    events in other buffers. This makes sense when only one queue
    //    has events left in it.
    //
    
    PAGED_CODE();
    
    //
    // This routine assumes that the output buffer has been checked and
    // that it is large enough to accommodate all of the events. This
    // implies that this function is called while holding the critical
    // section.
    //
    
    //
    // See which guid objects have events to be processed
    //
    for (i = 0; i < HandleCount; i++)
    {
        GuidObject = ObjectArray[i].GuidObject;
        if (IsHiPriority)
        {
            if ((GuidObject->HiPriority.Buffer != NULL) &&
                (GuidObject->HiPriority.NextOffset != 0))
            {
                ObjectArray[i].NextWnode = (PWNODE_HEADER)GuidObject->HiPriority.Buffer;
                WmipSetHighWord(ObjectArray[i].NextWnode->Version,
                                GuidObject->HiPriority.EventsLost);
                GuidObject->HiPriority.EventsLost = 0;
                WmipAssert(ObjectArray[i].NextWnode != NULL);
            } else {
                ObjectArray[i].NextWnode = NULL;
            }                       
        } else {
            if ((GuidObject->LoPriority.Buffer != 0) &&
                (GuidObject->LoPriority.NextOffset != 0))
            {
                ObjectArray[i].NextWnode = (PWNODE_HEADER)GuidObject->LoPriority.Buffer;
                WmipSetHighWord(ObjectArray[i].NextWnode->Version,
                                GuidObject->LoPriority.EventsLost);
                GuidObject->LoPriority.EventsLost = 0;
                WmipAssert(ObjectArray[i].NextWnode != NULL);
            } else {
                ObjectArray[i].NextWnode = NULL;
            }                       
        }       
    }

    //
    // loop until all events in all guid objects have been
    // processed
    //
    SizeUsed = 0;
    Earliest = 0;
    OutWnode = NULL;
    while (Earliest != 0xffffffff)
    {
        Timestamp.QuadPart = 0x7fffffffffffffff;
        Earliest = 0xffffffff;
        for (i = 0; i < HandleCount; i++)
        {
            InWnode = (PWNODE_HEADER)ObjectArray[i].NextWnode;
            if ((InWnode != NULL) &&
                (InWnode->TimeStamp.QuadPart < Timestamp.QuadPart))
            {
                //
                // We found an event that is earlier than any previous
                // one so we remember the new candidate for earliest
                // event and also the previous early event
                //
                LastTimestamp = Timestamp;
                Timestamp = InWnode->TimeStamp;
                Earliest = i;
            }
        }

        if (Earliest != 0xffffffff)
        {
            //
            // We found the earliest event so copy it into the output
            // buffer
            //
            InWnode = (PWNODE_HEADER)ObjectArray[Earliest].NextWnode;
            Size = (InWnode->BufferSize + 7) & ~7;

            OutWnode = (PWNODE_HEADER)OutBuffer;
            RtlCopyMemory(OutWnode, InWnode, InWnode->BufferSize);
            OutWnode->Linkage = Size;
            
            OutBuffer += Size;
            SizeUsed += Size;

            if (InWnode->Linkage != 0)
            {
                InWnode = (PWNODE_HEADER)((PUCHAR)InWnode + InWnode->Linkage);
            } else {
                InWnode = NULL;
            }
            ObjectArray[Earliest].NextWnode = InWnode;
        }
    }
    
    *LastWnode = OutWnode;
    *OutBufferSizeUsed = SizeUsed;

    //
    // clean up event queue resources and reset the object
    //
    for (i = 0; i < HandleCount; i++)
    {
        
        GuidObject = ObjectArray[i].GuidObject;

        if (IsHiPriority)
        {
            EventQueue = &GuidObject->HiPriority;
        } else {
            EventQueue = &GuidObject->LoPriority;           
        }

        if (EventQueue->Buffer != NULL)
        {
            WmipFree(EventQueue->Buffer);
            EventQueue->Buffer = NULL;
            EventQueue->NextOffset = 0;
            EventQueue->LastWnode = NULL;
        }
        
        KeClearEvent(&GuidObject->Event);
    }
}

void WmipCompleteGuidIrpWithError(
    PWMIGUIDOBJECT GuidObject
    )
{
    PIRP OldIrp;

    PAGED_CODE();

    //
    // This routine assumes that the SM Critical Section is held
    //
    
    //
    // If this object is already being waited on by a different
    // irp then we need to fail the original irp since we only
    // allow a single irp to wait on a specific object
    //
    WmipAssert(GuidObject->IrpObjectList.Flink != NULL);
    WmipAssert(GuidObject->IrpObjectList.Blink != NULL);

    OldIrp = GuidObject->Irp;
    if (IoSetCancelRoutine(OldIrp, NULL))
    {
        //
        // If there was a cancel routine then this means that
        // the irp is still pending so we can go and complete it
        //
        WmipClearIrpObjectList(OldIrp);
        WmipAssert(GuidObject->Irp == NULL);
        OldIrp->IoStatus.Status = STATUS_INVALID_HANDLE;
        IoCompleteRequest(OldIrp, IO_NO_INCREMENT);
    }
}

NTSTATUS WmipMarkHandleAsClosed(
    HANDLE Handle
    )
{
    NTSTATUS Status;
    PWMIGUIDOBJECT GuidObject;

    PAGED_CODE();
    
    Status = ObReferenceObjectByHandle(Handle,
                                   WMIGUID_NOTIFICATION,
                                   WmipGuidObjectType,
                                   UserMode,
                                   &GuidObject,
                                   NULL);
    
    if (NT_SUCCESS(Status))
    {
        //
        // Mark object as no longer able to receive events
        //
        WmipEnterSMCritSection();
        GuidObject->Flags |= WMIGUID_FLAG_RECEIVE_NO_EVENTS;
        if (GuidObject->Irp != NULL)
        {
            //
            // If this object was is waiting in a pending irp then we
            // need to complete the irp to keep the pump moving
            //
            WmipCompleteGuidIrpWithError(GuidObject);
        }
        WmipLeaveSMCritSection();
        ObDereferenceObject(GuidObject);
    }
    
    return(Status);
    
}

NTSTATUS WmipReceiveNotifications(
    PWMIRECEIVENOTIFICATION ReceiveNotification,
    PULONG OutBufferSize,
    PIRP Irp
    )
{
    #define MANY_NOTIFICATION_OBJECTS 16
    ULONG i;
    PWMIGUIDOBJECT GuidObject;
    ULONG HandleCount;
    PHANDLE3264 HandleArray;
    OBJECT_EVENT_INFO *ObjectArray;
    OBJECT_EVENT_INFO StaticObjects[MANY_NOTIFICATION_OBJECTS];
    PUCHAR OutBuffer;
    UCHAR IsLoPriorityEvent, IsHighPriorityEvent, ReplacingIrp;
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PWNODE_HEADER LastWnode;
    PLIST_ENTRY IrpListHead, ThreadListHead;
    ULONG MaxBufferSize, SizeUsed;
    PVOID UserProcessObject;
    HANDLE UserModeProcess;
    ULONG SizeLeft, SizeNeeded, HiTotalSizeNeeded, LoTotalSizeNeeded;
    PWNODE_TOO_SMALL WnodeTooSmall;
    ULONG j, ObjectCount;
    BOOLEAN DuplicateObject;
    PIMAGE_NT_HEADERS NtHeaders;
    SIZE_T StackSize, StackCommit;
#if defined(_WIN64)
    PVOID Wow64Process;
    PIMAGE_NT_HEADERS32 NtHeaders32;
#endif

    PAGED_CODE();
    
    MaxBufferSize = *OutBufferSize;
    
    HandleCount = ReceiveNotification->HandleCount;
    HandleArray = ReceiveNotification->Handles;

    //
    // Create space to store the object pointers so we can work with them
    //

    if (HandleCount > MANY_NOTIFICATION_OBJECTS)
    {
        ObjectArray = WmipAlloc(HandleCount * sizeof(OBJECT_EVENT_INFO));
        if (ObjectArray == NULL)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    } else {
        ObjectArray = StaticObjects;
    }        
#if DBG
    RtlZeroMemory(ObjectArray, HandleCount * sizeof(OBJECT_EVENT_INFO));
#endif
    
    //
    // First check that we all handles are entitled to receive notifications
    // and that the object is not already associated with an irp.
    // Also check if there are any hi or lo priority events
    //
    WmipEnterSMCritSection();

    IsLoPriorityEvent = 0;
    IsHighPriorityEvent = 0;
    ReplacingIrp = 0;
    HiTotalSizeNeeded = 0;
    LoTotalSizeNeeded = 0;
    ObjectCount = 0;
    for (i = 0; (i < HandleCount); i++)
    {
        Status = ObReferenceObjectByHandle(HandleArray[i].Handle,
                                       WMIGUID_NOTIFICATION,
                                       WmipGuidObjectType,
                                       UserMode,
                                       &GuidObject,
                                       NULL);
        if (! NT_SUCCESS(Status))
        {
            //
            // If one handle is bad then it spoils the whole request
            //
            //
            // Now try with Trace flags and if succeeds, 
            // We need to make sure the object is a trace request object. 
            //

            Status = ObReferenceObjectByHandle(HandleArray[i].Handle,
                               TRACELOG_REGISTER_GUIDS,
                               WmipGuidObjectType,
                               UserMode,
                               &GuidObject,
                               NULL);

            if (! NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            if (! (GuidObject->Flags & WMIGUID_FLAG_REQUEST_OBJECT) )
            {
                ObDereferenceObject(GuidObject);
                Status = STATUS_ACCESS_DENIED;
                goto Cleanup;
            }

        }

        //
        // Check that we do not have a duplicate object in the list
        //
        DuplicateObject = FALSE;
        for (j = 0; j < ObjectCount; j++)
        {
            if (GuidObject == ObjectArray[j].GuidObject)
            {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_ERROR_LEVEL,
                                  "WMI: Duplicate object %p passed to WmiReceiveNotifciations\n",
                                GuidObject));
                ObDereferenceObject(GuidObject);
                DuplicateObject = TRUE;
                break;
            }
        }

        if (! DuplicateObject)
        {
            //
            // See if there was an irp attached to the guid object
            // already. We'll need to cancel it if all guid objects
            // are valid
            //
            if (GuidObject->Irp != NULL)
            {
                ReplacingIrp = 1;
            }


            //
            // We note if there are any lo and hi priority events
            //
            ObjectArray[ObjectCount++].GuidObject = GuidObject;        

            if (WmipHaveHiPriorityEvent(GuidObject))
            {
                IsHighPriorityEvent = 1;
            }

            if (WmipHaveLoPriorityEvent(GuidObject))
            {
                IsLoPriorityEvent = 1;
            }

            //
            // Clean up object in case it was part of a thread list
            //
            if (GuidObject->EventQueueAction == RECEIVE_ACTION_CREATE_THREAD)
            {
                WmipAssert(ReplacingIrp == 0);
                WmipClearObjectFromThreadList(GuidObject);
            }

            //
            // Calculate size needed to return data for this guid
            //
            HiTotalSizeNeeded += ((GuidObject->HiPriority.NextOffset + 7) & ~7);
            LoTotalSizeNeeded += ((GuidObject->LoPriority.NextOffset + 7) & ~7);
        }        
    }

    //
    // This is the total size needed to return all events
    //
    SizeNeeded = HiTotalSizeNeeded + LoTotalSizeNeeded;


    //
    // If any of the guid objects already had an irp attached then
    // we need to complete that irp with an error and move on
    //
    if (ReplacingIrp == 1)
    {
        for (i = 0; i < ObjectCount; i++)
        {
            GuidObject = ObjectArray[i].GuidObject;
            if (GuidObject->Irp != NULL)
            {
                WmipCompleteGuidIrpWithError(GuidObject);
            }
        }        
    }
    
    if ( (IsHighPriorityEvent | IsLoPriorityEvent) != 0 )
    {
        if (SizeNeeded <= MaxBufferSize)
        {
            //
            // There are events waiting to be received so pull them all 
            // out, high priority ones first then low priority ones.            // events will show up first.
            //
            OutBuffer = (PUCHAR)ReceiveNotification;
            LastWnode = NULL;
            SizeLeft = MaxBufferSize;
            SizeUsed = 0;

            if (IsHighPriorityEvent != 0)
            {
                WmipCopyFromEventQueues(ObjectArray,
                                        ObjectCount,
                                        OutBuffer,
                                        &SizeUsed,
                                        &LastWnode,
                                        TRUE);
                
                WmipAssert(SizeUsed <= SizeLeft);
                WmipAssert(SizeUsed = HiTotalSizeNeeded);
                
                OutBuffer += SizeUsed;
                SizeLeft -= SizeUsed;
            }

            if (IsLoPriorityEvent != 0)
            {
                WmipAssert(SizeLeft >= LoTotalSizeNeeded);
                
                WmipCopyFromEventQueues(ObjectArray,
                                        ObjectCount,
                                        OutBuffer,
                                        &SizeUsed,
                                        &LastWnode,
                                        FALSE);
                
                WmipAssert(SizeUsed <= SizeLeft);
                WmipAssert(SizeUsed == LoTotalSizeNeeded);
                
                SizeLeft -= SizeUsed;
            }

            //
            // We need to set the linkage field for the last wnode in
            // the list to 0 so it can mark the end of the list
            // correctly
            //
            if (LastWnode != NULL)
            {
                LastWnode->Linkage = 0;
            }
            
            //
            // Compute the number of bytes used to fill the output
            // buffer by subtracting the size left from the size passed
            // in
            //
            *OutBufferSize = MaxBufferSize - SizeLeft;
        } else {
            //
            // Not enough room to return all of the event data so we return
            // a WNODE_TOO_SMALL to indicate the size needed
            //
            WnodeTooSmall = (PWNODE_TOO_SMALL)ReceiveNotification;
            WnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
            WnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
            WnodeTooSmall->SizeNeeded = SizeNeeded;
            *OutBufferSize = sizeof(WNODE_TOO_SMALL);       
        }

    } else {
        //
        // There are no events waiting to be returned so we need to
        // create our wait structures, pend the irp and return pending
        //
        if (ReceiveNotification->Action == RECEIVE_ACTION_NONE)
        {
            IrpListHead = IRP_OBJECT_LIST_HEAD(Irp);
            InitializeListHead(IrpListHead);
            for (i = 0; i < ObjectCount; i++)
            {
                GuidObject = ObjectArray[i].GuidObject;
                GuidObject->Irp = Irp;
                GuidObject->EventQueueAction = RECEIVE_ACTION_NONE;
                InsertTailList(IrpListHead, &GuidObject->IrpObjectList);
            }

            IoSetCancelRoutine(Irp, WmipNotificationIrpCancel);
            if (Irp->Cancel && IoSetCancelRoutine(Irp, NULL))
            {
                Status = STATUS_CANCELLED;
            } else {
                IoMarkIrpPending(Irp);
                Status = STATUS_PENDING;
            }
        } else if (ReceiveNotification->Action == RECEIVE_ACTION_CREATE_THREAD) {
            //
            // Pump has called us to tell us that it is shutting down so we
            // need to establish a list linking the guid objects and
            // stashing away the callback address
            //

#if defined(_WIN64)
            
            //
            // For native Win64 processes, ensure that the thread start 
            // address is aligned properly
            //

            Wow64Process = _PsGetCurrentProcess()->Wow64Process;

            if ((Wow64Process == NULL) &&
                (((ULONG_PTR)ReceiveNotification->UserModeCallback.Handle64 & 0x7) != 0))
            {
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }
#endif

            //
            // Make sure that the process handle we get is valid and has
            // enough permissions to create the thread
            //
            Status = ObReferenceObjectByHandle(ReceiveNotification->UserModeProcess.Handle,
                                              PROCESS_CREATE_THREAD |
                                              PROCESS_QUERY_INFORMATION |
                                              PROCESS_VM_OPERATION |
                                              PROCESS_VM_WRITE |
                                              PROCESS_VM_READ ,
                                              NULL,
                                              UserMode,
                                              &UserProcessObject,
                                              NULL);


            if (NT_SUCCESS(Status))
            {
                //
                // Create a handle for the process that lives in the system
                // handle table so that it will be available in any thread
                // context. Note that one handle is created for each thread
                // object list and the handle is closed when the last
                // object is removed from the list
                // 
                Status = ObOpenObjectByPointer(UserProcessObject,
                                               OBJ_KERNEL_HANDLE,
                                               NULL,
                                               THREAD_ALL_ACCESS,
                                               NULL,
                                               KernelMode,
                                               &UserModeProcess);

                if (NT_SUCCESS(Status))
                {
                    //
                    // Get the default stack size and commit for this
                    // process and store it away in the guid object so
                    // that the pump threads created from kernel will
                    // have appropriately sized stacks
                    //
                    
                    try {
                    
                        NtHeaders = RtlImageNtHeader(_PsGetCurrentProcess()->SectionBaseAddress);
                        if (NtHeaders != NULL)
                        {
#if defined(_WIN64)
                            if (Wow64Process != NULL) {
                                
                                NtHeaders32 = (PIMAGE_NT_HEADERS32) NtHeaders;
                                StackSize = NtHeaders32->OptionalHeader.SizeOfStackReserve;
                                StackCommit = NtHeaders32->OptionalHeader.SizeOfStackCommit;
                            } else {
#endif
                               StackSize = NtHeaders->OptionalHeader.SizeOfStackReserve;
                               StackCommit = NtHeaders->OptionalHeader.SizeOfStackCommit;
#if defined(_WIN64)
                            }
#endif
                        } else {
                            StackSize = 0;
                            StackCommit = 0;
                        }
                    } except (EXCEPTION_EXECUTE_HANDLER) {                          
                        StackSize = 0;
                        StackCommit = 0;
                    }
                    
                    GuidObject = ObjectArray[0].GuidObject;
                    GuidObject->UserModeCallback = (PUSER_THREAD_START_ROUTINE)(ULONG_PTR)ReceiveNotification->UserModeCallback.Handle;
                    GuidObject->EventQueueAction = RECEIVE_ACTION_CREATE_THREAD;
                    GuidObject->UserModeProcess = UserModeProcess;
                    GuidObject->StackSize = StackSize;
                    GuidObject->StackCommit = StackCommit;

                    ThreadListHead = &GuidObject->ThreadObjectList;
                    InitializeListHead(ThreadListHead);

                    for (i = 1; i < ObjectCount; i++)
                    {
                        GuidObject = ObjectArray[i].GuidObject;
                        GuidObject->UserModeCallback = (PUSER_THREAD_START_ROUTINE)(ULONG_PTR)ReceiveNotification->UserModeCallback.Handle;
                        GuidObject->EventQueueAction = RECEIVE_ACTION_CREATE_THREAD;
                        GuidObject->UserModeProcess = UserModeProcess;
                        GuidObject->StackSize = StackSize;
                        GuidObject->StackCommit = StackCommit;
                        InsertTailList(ThreadListHead, &GuidObject->ThreadObjectList);
                    }

                }

                ObDereferenceObject(UserProcessObject);
            }
            
            *OutBufferSize = 0;
        }
    }

Cleanup:
    //
    // Remove any object references that we took and free memory for
    // the object array
    //
    WmipLeaveSMCritSection();

    for (i = 0; i < ObjectCount; i++)
    {
        ObDereferenceObject(ObjectArray[i].GuidObject);
    }

    if (ObjectArray != StaticObjects)
    {
        WmipFree(ObjectArray);
    }
    

    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_EVENT_INFO_LEVEL,
                      "WMI: RCV Notification call -> 0x%x\n", Status));
    
    return(Status);    
}


NTSTATUS
WmipCsrClientMessageServer(
    IN PVOID CsrPort,                       
    IN OUT PCSR_API_MSG m,
    IN CSR_API_NUMBER ApiNumber,
    IN ULONG ArgLength
    )

/*++

Routine Description:

    This function sends an API datagram to the Windows Emulation Subsystem
    Server. 

Arguments:

    CsrPort - pointer to LPC port object that is connected to CSR on
              behalf of this process

    m - Pointer to the API request message to send.

    ApiNumber - Small integer that is the number of the API being called.

    ArgLength - Length, in bytes, of the argument portion located at the
        end of the request message.  Used to calculate the length of the
        request message.

Return Value:

    Status Code from either client or server

--*/

{
    NTSTATUS Status;

    //
    // Initialize the header of the message.
    //

    if ((LONG)ArgLength < 0)
    {
        ArgLength = (ULONG)(-(LONG)ArgLength);
        m->h.u2.s2.Type = 0;
    } else {
        m->h.u2.ZeroInit = 0;
    }

    ArgLength |= (ArgLength << 16);
    ArgLength +=     ((sizeof( CSR_API_MSG ) - sizeof( m->u )) << 16) |
                     (FIELD_OFFSET( CSR_API_MSG, u ) - sizeof( m->h ));
    m->h.u1.Length = ArgLength;
    m->CaptureBuffer = NULL;
    m->ApiNumber = ApiNumber;

    Status = LpcRequestPort( CsrPort,
                            (PPORT_MESSAGE)m);
    
    //
    // Check for failed status and do something.
    //
    if (! NT_SUCCESS( Status ))
    {       
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_ERROR_LEVEL,
                          "WMI: %p.%p LpcRequestPort failed %x\n",
                          NtCurrentTeb()->ClientId.UniqueProcess,
                          NtCurrentTeb()->ClientId.UniqueThread,
                          Status));
        WmipAssert(FALSE);

        m->ReturnValue = Status;
    }

    //
    // The value of this function is whatever the server function returned.
    //

    return( m->ReturnValue );
}

//
// XXX
//
typedef struct _BASE_CREATETHREAD_MSG {
    HANDLE ThreadHandle;
    CLIENT_ID ClientId;
} BASE_CREATETHREAD_MSG, *PBASE_CREATETHREAD_MSG;

typedef struct _BASE_API_MSG {
    PORT_MESSAGE h;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CSR_API_NUMBER ApiNumber;
    ULONG ReturnValue;
    ULONG Reserved;
    union {
        BASE_CREATETHREAD_MSG CreateThread;
    } u;
} BASE_API_MSG, *PBASE_API_MSG;

#define BasepRegisterThread 29


VOID WmipPumpThreadApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )
/*++

Routine Description:

    Kernel mode APC that will register the current thread with CSR

Arguments:


Return Value:


--*/
{
    BASE_API_MSG m;
    PBASE_CREATETHREAD_MSG a = &m.u.CreateThread;
    PEPROCESS Process;

    UNREFERENCED_PARAMETER (NormalRoutine);
    UNREFERENCED_PARAMETER (NormalContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    //
    // Free memory used by APC
    //
    ExFreePool(Apc);
    
    //
    // Get the ExceptionPort from the process object. In a Win32
    // process this port is set by CSR to allow it to be notified when
    // an exception occurs. This code will also use it to register this
    // thread with CSR. Note that if the exception port is NULL then
    // the process is not a Win32 process and it doesn't matter if the
    // thread doesn't get registered.
    //
    Process = PsGetCurrentProcess();
    if (Process->ExceptionPort != NULL)
    {
        a->ThreadHandle = NULL;
        a->ClientId = NtCurrentTeb()->ClientId;

        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,
                          "WMI: Sending message To CSR for %p.%p\n",
                          NtCurrentTeb()->ClientId.UniqueProcess,
                          NtCurrentTeb()->ClientId.UniqueThread));
        WmipCsrClientMessageServer( Process->ExceptionPort,
                               (PCSR_API_MSG)&m,
                             CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                  BasepRegisterThread
                                                ),
                             sizeof( *a )
                           );
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_ERROR_LEVEL,
                          "WMI: %p.%p Process %p has no exception port\n",
                          NtCurrentTeb()->ClientId.UniqueProcess,
                          NtCurrentTeb()->ClientId.UniqueThread,
                          Process));
        WmipAssert(FALSE);
    }
}

NTSTATUS WmipCreatePumpThread(
    PWMIGUIDOBJECT Object
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE ThreadHandle;
    PKAPC Apc;
    PKTHREAD ThreadObj;
    
    PAGED_CODE();

    //
    // First off we need to create the pump thread suspended so we'll
    // have a chance to queue a kernel apc before the thread starts
    // running
    //
    WmipEnterSMCritSection();
    if (Object->UserModeProcess != NULL)
    {
        Status = RtlCreateUserThread(Object->UserModeProcess,
                                     NULL,
                                     TRUE,
                                     0,
                                     Object->StackSize,
                                     Object->StackCommit,
                                     Object->UserModeCallback,
                                     (PVOID)0x1f1f1f1f,
                                     &ThreadHandle,
                                     NULL);

        if (NT_SUCCESS(Status))
        {

            //
            // Queue a kernel mode apc that will call into CSR to register
            // this newly created thread. Note that if the APC cannot be
            // run it is not fatal as we can allow the thread to run
            // without being registered with CSR. The APC is freed at the
            // end of the APC routine
            //

            Status = ObReferenceObjectByHandle(ThreadHandle,
                                               0,
                                               NULL,
                                               KernelMode,
                                               &ThreadObj,
                                               NULL);

            if (NT_SUCCESS(Status))
            {
                Apc = WmipAllocNP(sizeof(KAPC));
                if (Apc != NULL)
                {
                    KeInitializeApc(Apc,
                                    ThreadObj,
                                    OriginalApcEnvironment,
                                    WmipPumpThreadApc,
                                    NULL,
                                    NULL,
                                    KernelMode,
                                    NULL);

                    if (! KeInsertQueueApc(Apc,
                                           NULL,
                                           NULL,
                                           0))
                    {
                        ExFreePool(Apc);
                    } 
                }
                ObDereferenceObject(ThreadObj);
            } else {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_ERROR_LEVEL,
                                  "WMI: ObRef(ThreadObj) failed %x\n",
                                  Status));

                //
                // Status is still successful since the pump thread was
                // created, just not registered with CSR
                //
                Status = STATUS_SUCCESS;
            }

            //
            // If we successfully created the pump thread then mark all of
            // the related objects as not needing any thread creation
            // anymore
            //
            WmipClearThreadObjectList(Object);

            WmipLeaveSMCritSection();

            ZwResumeThread(ThreadHandle,
                          NULL);
            ZwClose(ThreadHandle);
        } else {
            WmipLeaveSMCritSection();
        }
    } else {
        WmipLeaveSMCritSection();
    }
    
    return(Status); 
}

void WmipCreatePumpThreadRoutine(
    PVOID Context
    )
/*+++

Routine Description:

    This routine is a worker routine that will create a user mode pump
    thread so that events can be delivered. 
        
Arguments:

    Context is a pointer to a CREATETHREADWORKITEM struct. It is freed
        in this routine

Return Value:


---*/
{
    PCREATETHREADWORKITEM WorkItem = (PCREATETHREADWORKITEM)Context;
    NTSTATUS Status;

    PAGED_CODE();

    if (ObReferenceObjectSafe(WorkItem->Object))
    {
        //
        // Only continue if the object is not being deleted
        //
        Status = WmipCreatePumpThread(WorkItem->Object);
        if (! NT_SUCCESS(Status))
        {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_ERROR_LEVEL,
                              "WMI: Delayed pump thread creation failed %x\n",
                             Status));
        }
        
        ObDereferenceObject(WorkItem->Object);
    }

    //
    // Release reference to object taken when work item was queued
    //
    ObDereferenceObject(WorkItem->Object);
    ExFreePool(WorkItem);
}


#define WmipQueueEventToObject(Object, Wnode, IsHighPriority) \
    WmipQueueNotification(Object, IsHighPriority ? &Object->HiPriority : \
                                         &Object->LoPriority, \
                          Wnode);

NTSTATUS WmipQueueNotification(
    PWMIGUIDOBJECT Object,
    PWMIEVENTQUEUE EventQueue,
    PWNODE_HEADER Wnode
    )
{
    //
    // This routine assumes that the SMCritSection is held
    //
    PUCHAR Buffer;
    ULONG InWnodeSize;
    ULONG NextOffset;
    PUCHAR DestPtr;
    PWNODE_HEADER LastWnode;
    NTSTATUS Status;
    ULONG SizeNeeded;
    PCREATETHREADWORKITEM WorkItem;
        
    PAGED_CODE();
    
    //
    // If there is not a buffer allocated to store the event then
    // allocate one
    //
    if (EventQueue->Buffer == NULL)
    {
        //
        // If we get an event that is larger than the default max
        // buffer size then we bump the buffer size up to 64K, unless
        // it is larger than 64K where we bump up to the actual size of
        // the event.
        //
        SizeNeeded = (Wnode->BufferSize + 7) & ~7;

        if (SizeNeeded > EventQueue->MaxBufferSize) {
            EventQueue->MaxBufferSize = (SizeNeeded >= 65536) ? SizeNeeded : 65536;
        }
        
        Buffer = WmipAlloc(EventQueue->MaxBufferSize);
        if (Buffer != NULL)
        {
            EventQueue->Buffer = Buffer;
            EventQueue->NextOffset = 0;
            EventQueue->LastWnode = NULL;
        } else {
            EventQueue->EventsLost++;
            WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                              DPFLTR_EVENT_INFO_LEVEL,
                              "WMI: Event 0x%x lost for object %p since could not alloc\n",
                              EventQueue->EventsLost, Object));
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    } else {
        Buffer = EventQueue->Buffer;
    }
    
    //
    // See if there is room to queue the WNODE
    //
    InWnodeSize = Wnode->BufferSize;
    NextOffset = ((EventQueue->NextOffset + InWnodeSize) + 7) &~7;
    if (NextOffset <= EventQueue->MaxBufferSize)
    {
        //
        // Link the previous wnode to this one, copy in the new wnode
        // and update the pointer to next free space
        //
        DestPtr = Buffer + EventQueue->NextOffset;
        LastWnode = EventQueue->LastWnode;
        if (LastWnode != NULL)
        {
            LastWnode->Linkage = (ULONG) ((PCHAR)DestPtr - (PCHAR)LastWnode);
        }
        
        EventQueue->LastWnode = (PWNODE_HEADER)DestPtr;
        EventQueue->NextOffset = NextOffset;
        memcpy(DestPtr, Wnode, InWnodeSize);
        
        //
        // Guid object gets signaled when event is placed into queue
        //
        KeSetEvent(&Object->Event, 0, FALSE);

        //
        // If consumer requested that we autostart a thread then we do
        // that now
        //
        if (Object->EventQueueAction == RECEIVE_ACTION_CREATE_THREAD)
        {
            if (KeIsAttachedProcess())
            {
                //
                // If the current thread is attached to a process then
                // it is not safe to create a thread. So we queue a
                // work item and let the work item create it
                //
                WorkItem = ExAllocatePoolWithTag(NonPagedPool,
                                                sizeof(CREATETHREADWORKITEM),
                                                WMIPCREATETHREADTAG);
                if (WorkItem != NULL)
                {
                    //
                    // Take reference on object. Reference released in
                    // worker routine
                    //
                    Status = ObReferenceObjectByPointer(Object,
                                               0,
                                               NULL,
                                               KernelMode);

                    if (NT_SUCCESS(Status))
                    {
                        WorkItem->Object = Object;
                        ExInitializeWorkItem(&WorkItem->WorkItem,
                                             WmipCreatePumpThreadRoutine,
                                             WorkItem);
                        ExQueueWorkItem(&WorkItem->WorkItem,
                                        DelayedWorkQueue);

                    } else {
                        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                          DPFLTR_ERROR_LEVEL,
                                          "WMI: Ref on object %p failed %x for queuing notification work item\n",
                                         Object,
                                         Status));
                        ExFreePool(WorkItem);
                    }                   
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                Status = WmipCreatePumpThread(Object);
            }
            
            if (! NT_SUCCESS(Status))
            {
                EventQueue->EventsLost++;
                WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                      DPFLTR_EVENT_INFO_LEVEL,
                                      "WMI: Event 0x%x lost for object %p since Thread create Failed\n",
                                      EventQueue->EventsLost, Object));
            }
        } else {
            Status = STATUS_SUCCESS;
        }
    } else {
        //
        // Not enough space, throw away the event
        //

        EventQueue->EventsLost++;
        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                              DPFLTR_EVENT_INFO_LEVEL,
                              "WMI: Event 0x%x lost for object %p since too large 0x%x\n",
                              EventQueue->EventsLost, Object, Wnode->BufferSize));
        Status = STATUS_BUFFER_TOO_SMALL;
    }
    return(Status);
}

PWNODE_HEADER WmipDereferenceEvent(
    PWNODE_HEADER Wnode
    )
{
    ULONG WnodeTargetSize;
    ULONG IsStaticInstanceNames;
    ULONG InstanceNameLen, InstanceNameLen2;
    PWNODE_SINGLE_INSTANCE WnodeTarget;
    PWCHAR Ptr;
    PWNODE_EVENT_REFERENCE WnodeRef = (PWNODE_EVENT_REFERENCE)Wnode;
    PBDATASOURCE DataSource;
    NTSTATUS Status;
    ULONG Retries;

    PAGED_CODE();
    
    //
    // Determine if the data source is valid or not
    //
    DataSource = WmipFindDSByProviderId(WnodeRef->WnodeHeader.ProviderId);
    if (DataSource == NULL)
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_EVENT_INFO_LEVEL,
                          "WMI: Invalid Data Source in referenced guid \n"));
        return(NULL);
    }
    
    //
    // Compute the size of any dynamic name that must go into the TargetWnode
    //
    IsStaticInstanceNames = WnodeRef->WnodeHeader.Flags & 
                             WNODE_FLAG_STATIC_INSTANCE_NAMES;
    if (IsStaticInstanceNames == 0)
    {
        InstanceNameLen = *WnodeRef->TargetInstanceName + sizeof(USHORT);
    } else {
        InstanceNameLen = 0;
    }
    
    WnodeTargetSize = WnodeRef->TargetDataBlockSize + 
                          FIELD_OFFSET(WNODE_SINGLE_INSTANCE, 
                                       VariableData) +
                          InstanceNameLen + 
                          8;

    Retries = 0;
    do
    {
        WnodeTarget = WmipAllocNP(WnodeTargetSize);
    
        if (WnodeTarget != NULL)
        {
            //
            // Build WNODE_SINGLE_INSTANCE that we use to query for event data
            //
            memset(WnodeTarget, 0, WnodeTargetSize);

            WnodeTarget->WnodeHeader.BufferSize = WnodeTargetSize;
            WnodeTarget->WnodeHeader.ProviderId = WnodeRef->WnodeHeader.ProviderId;
            memcpy(&WnodeTarget->WnodeHeader.Guid, 
                   &WnodeRef->TargetGuid,
                   sizeof(GUID));
            WnodeTarget->WnodeHeader.Version = WnodeRef->WnodeHeader.Version;
            WnodeTarget->WnodeHeader.Flags = WNODE_FLAG_SINGLE_INSTANCE |
                                           IsStaticInstanceNames;
                                       
            if (IsStaticInstanceNames != 0)
            {
                WnodeTarget->InstanceIndex = WnodeRef->TargetInstanceIndex;
                WnodeTarget->DataBlockOffset = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                        VariableData);
            } else {            
                WnodeTarget->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                           VariableData);
                Ptr = (PWCHAR)OffsetToPtr(WnodeTarget, WnodeTarget->OffsetInstanceName);
                InstanceNameLen2 = InstanceNameLen - sizeof(USHORT);
                *Ptr++ = (USHORT)InstanceNameLen2;
                memcpy(Ptr, 
                       &WnodeRef->TargetInstanceName[1], 
                       InstanceNameLen2);
                //
                // Round data block offset to 8 byte alignment
                //
                WnodeTarget->DataBlockOffset = ((FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                          VariableData) + 
                                            InstanceNameLen2 + 
                                            sizeof(USHORT)+7) & 0xfffffff8);
            }
            Status = WmipDeliverWnodeToDS(IRP_MN_QUERY_SINGLE_INSTANCE,
                                          DataSource,
                                          (PWNODE_HEADER)WnodeTarget,
                                          WnodeTargetSize);
                                      
            if (NT_SUCCESS(Status) &&
                (WnodeTarget->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL))
            {
                WnodeTargetSize = ((PWNODE_TOO_SMALL)WnodeTarget)->SizeNeeded;
                WmipFree(WnodeTarget);
                Retries++;
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } while ((Status == STATUS_BUFFER_TOO_SMALL) && (Retries < 2));
    
    WmipUnreferenceDS(DataSource);
    
    if (! NT_SUCCESS(Status))
    {
        WmipReportEventLog(EVENT_WMI_CANT_GET_EVENT_DATA,

                           EVENTLOG_WARNING_TYPE,
                            0,
                           Wnode->BufferSize,
                           Wnode,
                           0,
                           NULL);
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_ERROR_LEVEL,
                          "WMI: Query to dereference WNODE failed %d\n",
                Status));
        if (WnodeTarget != NULL)
        {
            WmipFree(WnodeTarget);
            WnodeTarget = NULL;
        }
    } else {
        WnodeTarget->WnodeHeader.Flags |= (WnodeRef->WnodeHeader.Flags & 
                                              WNODE_FLAG_SEVERITY_MASK) |
                                             WNODE_FLAG_EVENT_ITEM;
    }
    return((PWNODE_HEADER)WnodeTarget);
}


PWNODE_HEADER WmipIncludeStaticNames(
    PWNODE_HEADER Wnode
    )
{
    PWNODE_HEADER ReturnWnode = Wnode;
    PWNODE_HEADER WnodeFull;
    PWNODE_ALL_DATA WnodeAllData;
    PWNODE_SINGLE_INSTANCE WnodeSI;
    PWCHAR InstanceName = NULL;
    SIZE_T InstanceNameLen = 0;
    ULONG InstanceIndex;
    LPGUID EventGuid = &Wnode->Guid;
    SIZE_T WnodeFullSize;
    PWCHAR TargetInstanceName;
    WCHAR Index[MAXBASENAMESUFFIXLENGTH+1];
    ULONG TargetProviderId;
    BOOLEAN IsError;
    PBINSTANCESET TargetInstanceSet;
    PBGUIDENTRY GuidEntry;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;

    PAGED_CODE();
    
    IsError = TRUE;
    TargetInstanceSet = NULL;
    GuidEntry = WmipFindGEByGuid(EventGuid, FALSE);
    
    if (GuidEntry != NULL)
    {
        //
        // Loop over all instance sets to find the one that corresponds
        // to our provider id
        //
        TargetProviderId = Wnode->ProviderId;
    
        WmipEnterSMCritSection();
        InstanceSetList = GuidEntry->ISHead.Flink;
        while (InstanceSetList != &GuidEntry->ISHead)
        {
            InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
                                        
            if (InstanceSet->ProviderId == TargetProviderId)
            {
                //
                // We found the instance set corrsponding to the provider id
                //
                TargetInstanceSet = InstanceSet;
                WmipReferenceIS(TargetInstanceSet);
                break;
            }
            InstanceSetList = InstanceSetList->Flink;
        }        
        WmipLeaveSMCritSection();
            
        //
        // Remove ref on the guid entry as we have refed the TargetInstanceSet
        //
        WmipUnreferenceGE(GuidEntry);
    }
        
    if (TargetInstanceSet != NULL)
    {
        if ((TargetInstanceSet->Flags &
            (IS_INSTANCE_BASENAME | IS_INSTANCE_STATICNAMES)) != 0)
        {

            if (Wnode->Flags & WNODE_FLAG_ALL_DATA) 
            {
                //
                // Fill instance names in WNODE_ALL_DATA. Allocate a
                // new buffer to hold all of the original wnode plus
                // the instance names. We need to add space for padding
                // the wnode to 4 bytes plus space for the array of
                // offsets to instance names plus space for the instance
                // names
                //
                WnodeFullSize = ((Wnode->BufferSize+3) & ~3) +
                        (TargetInstanceSet->Count * sizeof(ULONG)) +
                              WmipStaticInstanceNameSize(TargetInstanceSet);
                WnodeFull = WmipAlloc(WnodeFullSize);
                if (WnodeFull != NULL)
                {
                    memcpy(WnodeFull, Wnode, Wnode->BufferSize);
                    WnodeAllData = (PWNODE_ALL_DATA)WnodeFull;
                    WmipInsertStaticNames(WnodeAllData,
                                          (ULONG)WnodeFullSize,
                                          TargetInstanceSet);
                    ReturnWnode = WnodeFull;
                    IsError = FALSE;
                }

            } else if ((Wnode->Flags & WNODE_FLAG_SINGLE_INSTANCE) ||
                       (Wnode->Flags & WNODE_FLAG_SINGLE_ITEM)) {
                //
                // Fill instance names in WNODE_SINGLE_INSTANCE or
                // _ITEM. 
                //
                WnodeFull = Wnode;

                WnodeSI = (PWNODE_SINGLE_INSTANCE)Wnode;
                InstanceIndex = WnodeSI->InstanceIndex;
                if (InstanceIndex < TargetInstanceSet->Count)
                {
                    if (TargetInstanceSet->Flags & IS_INSTANCE_STATICNAMES)
                    {
                        InstanceName = TargetInstanceSet->IsStaticNames->StaticNamePtr[InstanceIndex];
                        InstanceNameLen = (wcslen(InstanceName) + 2) * 
                                                               sizeof(WCHAR);
                    } else if (TargetInstanceSet->Flags & IS_INSTANCE_BASENAME) {
                         InstanceName = TargetInstanceSet->IsBaseName->BaseName;
                         InstanceNameLen = (wcslen(InstanceName) + 2 + 
                                       MAXBASENAMESUFFIXLENGTH) * sizeof(WCHAR);
                    }
 
                    //
                    // Allocate a new Wnode and fill in the instance
                    // name. Include space for padding the wnode to a 2
                    // byte boundary and space for the instance name
                    //
                    WnodeFullSize = ((Wnode->BufferSize+1) & ~1) +
                                    InstanceNameLen;
                    
                    WnodeFull = WmipAlloc(WnodeFullSize);
                    
                    if (WnodeFull != NULL)
                    {
                        memcpy(WnodeFull, Wnode, Wnode->BufferSize);
                        WnodeFull->BufferSize = (ULONG)WnodeFullSize;
                        WnodeSI = (PWNODE_SINGLE_INSTANCE)WnodeFull;
                        WnodeSI->OffsetInstanceName = (Wnode->BufferSize+1)& ~1;
                        TargetInstanceName = (PWCHAR)((PUCHAR)WnodeSI + WnodeSI->OffsetInstanceName);
                        if (TargetInstanceSet->Flags & IS_INSTANCE_STATICNAMES)
                        {
                            InstanceNameLen -= sizeof(WCHAR);
                            *TargetInstanceName++ = (USHORT)InstanceNameLen;
                            StringCbCopy(TargetInstanceName,
                                         InstanceNameLen,
                                         InstanceName);
                        } else {
                            if (TargetInstanceSet->Flags & IS_PDO_INSTANCENAME)
                            {
                                WnodeFull->Flags |= WNODE_FLAG_PDO_INSTANCE_NAMES;
                            }
                            StringCbPrintf(Index,
                                           sizeof(Index),
                                           BASENAMEFORMATSTRING,
                                           TargetInstanceSet->IsBaseName->BaseIndex + 
                                                               InstanceIndex);
                            StringCbCopy(TargetInstanceName+1,
                                         InstanceNameLen,
                                         InstanceName);
                            
                            StringCbCat(TargetInstanceName+1,
                                        InstanceNameLen,
                                        Index);
                            InstanceNameLen = wcslen(TargetInstanceName+1);
                            *TargetInstanceName = ((USHORT)InstanceNameLen+1) * sizeof(WCHAR);
                        }
                        IsError = FALSE;
                        ReturnWnode = WnodeFull;
                    }
                }
            }
        }
    }
        
    if (IsError)
    {
        //
        // If we had an error resolving the instance name then report it
        // and remove the instance name from the event.
        //
        WmipReportEventLog(EVENT_WMI_CANT_RESOLVE_INSTANCE,
                           EVENTLOG_WARNING_TYPE,
                            0,
                           Wnode->BufferSize,
                           Wnode,
                           0,
                           NULL);
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_WARNING_LEVEL,
                          "WMI: Static instance name in event, but error processing\n"));
        if (Wnode->Flags & WNODE_FLAG_ALL_DATA)
        {
            WnodeAllData = (PWNODE_ALL_DATA)Wnode;
            WnodeAllData->OffsetInstanceNameOffsets = 0;
        } else if ((Wnode->Flags & WNODE_FLAG_SINGLE_INSTANCE) ||
                   (Wnode->Flags & WNODE_FLAG_SINGLE_ITEM))
        {
            WnodeSI = (PWNODE_SINGLE_INSTANCE)Wnode;
            WnodeSI->OffsetInstanceName = 0;
        }
    }

    if (TargetInstanceSet != NULL)
    {
        WmipUnreferenceIS(TargetInstanceSet);
    }
    
    return(ReturnWnode);
}

NTSTATUS WmipWriteWnodeToObject(
    PWMIGUIDOBJECT Object,
    PWNODE_HEADER Wnode,
    BOOLEAN IsHighPriority
)
/*+++

Routine Description:

    This routine will write a WNODE into the queue of events to be returned
    for a guid object. If there is an irp already waiting then it will be
    satisfied with the event otherwise it will be queued in the objects
    buffer. 
        
    This routine assumes that the SM Critical section is held
        
Arguments:

    Object is the object to which to send the request

    Wnode is the Wnode with the event
        
    IsHighPriority is TRUE if the event should go into the high priority
        queue

Return Value:

    STATUS_SUCCESS or an error code

---*/
{
    PIRP Irp;
    ULONG WnodeSize;
    PUCHAR OutBuffer;
    ULONG OutBufferSize;
    PIO_STACK_LOCATION IrpStack;
    PWNODE_TOO_SMALL WnodeTooSmall;    
    NTSTATUS Status;
    
    PAGED_CODE();
    
    //
    // Someone has registered to receive this event so
    // see if there is an irp waiting to be completed or
    // if we should just queue it
    //
    Irp = Object->Irp;
    if ((Irp != NULL) &&
        (IoSetCancelRoutine(Irp, NULL)))
    {
        //
        // There is an irp waiting for this event, copy out the
        // event and complete the irp
        //
        IrpStack = IoGetCurrentIrpStackLocation(Irp);
        OutBuffer = Irp->AssociatedIrp.SystemBuffer;
        OutBufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
        WnodeSize = Wnode->BufferSize;
        if (WnodeSize > OutBufferSize)
        {
            //
            // There is not enough room to return the event so
            // we return a WNODE_TOO_SMALL with the size needed
            // and then go and queue the event
            //
            WmipAssert(OutBufferSize >= sizeof(WNODE_TOO_SMALL));
            WnodeTooSmall = (PWNODE_TOO_SMALL)OutBuffer;
            WnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
            WnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
            WnodeTooSmall->SizeNeeded = WnodeSize;
            WnodeSize = sizeof(WNODE_TOO_SMALL);
            Status = WmipQueueEventToObject(Object,
                                   Wnode,
                                   IsHighPriority);
        } else {
            //
            // Plenty of room, copy the event into the irp
            // buffer and complete the irp
            //
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_EVENT_INFO_LEVEL,
                              "WMI: Returning event to waiting irp for object %p\n", Object));
            RtlCopyMemory(OutBuffer, Wnode, WnodeSize);
            Status = STATUS_SUCCESS;
        }
        
        //
        // Remove link from all objects associated with the irp
        // since now the irp is going away.
        //
        WmipClearIrpObjectList(Irp);
        Irp->IoStatus.Information = WnodeSize;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    } else {
        //
        // There is no irp waiting to receive the event so we
        // need to queue it if we can
        //
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_EVENT_INFO_LEVEL,
                          "WMI: Queued event to object %p\n", Object));
        Status = WmipQueueEventToObject(Object,
                                   Wnode,
                                   IsHighPriority);
    }
    
    return(Status);
}


NTSTATUS WmipProcessEvent(
    PWNODE_HEADER InWnode,
    BOOLEAN IsHighPriority,
    BOOLEAN FreeBuffer
    )
{
    LPGUID Guid;
    NTSTATUS Status, ReturnStatus;
    PBGUIDENTRY GuidEntry;
    PLIST_ENTRY ObjectList, ObjectListNext;
    PWMIGUIDOBJECT Object;
    LPGUID EventGuid = &InWnode->Guid;
    PWNODE_HEADER Wnode, WnodeTarget;    
    
    PAGED_CODE();
    
    //
    // If the event references a guid that needs to be queried then
    // go do the dereferencing here.
    //
    if (InWnode->Flags & WNODE_FLAG_EVENT_REFERENCE)
    {
        WnodeTarget = WmipDereferenceEvent(InWnode);
        if (WnodeTarget == NULL)
        {
            if (FreeBuffer)
            {
                ExFreePool(InWnode);
            }
            return(STATUS_UNSUCCESSFUL);
        }
        Wnode = WnodeTarget;
    } else {
        Wnode = InWnode;
        WnodeTarget = NULL;
    }

    //
    // Be sure to use the guid of the referenced event, not the event that
    // was originally fired.
    EventGuid = &Wnode->Guid;


    //
    // If it is Trace error notification, disable providers
    //
    if (IsEqualGUID(EventGuid, & TraceErrorGuid)) {
        PWMI_TRACE_EVENT WmiEvent = (PWMI_TRACE_EVENT) InWnode;
        ULONG LoggerId = WmiGetLoggerId(InWnode->HistoricalContext);
        if ( InWnode->BufferSize >= sizeof(WMI_TRACE_EVENT) ) {
            //
            // Logger thread terminating will result in DisableTrace
            // through StopTrace. No need to call twice. 
            //
            if (WmiEvent->TraceErrorFlag == STATUS_SEVERITY_ERROR) {
                WmipDisableTraceProviders(LoggerId);
            }
        }
    }

    //
    // See if this event has a static name and if so fill it in
    if (Wnode->Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES)
    {
        Wnode = WmipIncludeStaticNames(Wnode);
    }
        
    //
    // See if any data provider has registered this event
    //
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_EVENT_INFO_LEVEL,
                      "WMI: Received event\n"));
    Guid = &Wnode->Guid;    
    GuidEntry = WmipFindGEByGuid(Guid, TRUE);
    if (GuidEntry != NULL)
    {
        //
        // Yup, so check if there are any open objects to the guid and
        // if anyone is interested in receiving events from them
        //
        ReturnStatus = STATUS_SUCCESS;
        WmipEnterSMCritSection();
        ObjectList = GuidEntry->ObjectHead.Flink;
        while (ObjectList != &GuidEntry->ObjectHead)
        {
            Object = CONTAINING_RECORD(ObjectList,
                                       WMIGUIDOBJECT,
                                       GEObjectList);

            //
            // ObRefSafe so that we can be sure that the object is not
            // in the process of being deleted. If this function
            // returns FALSE then the object is being deleted and so we
            // don't want to use it. If TRUE then it is safe to use the
            // object
            //
            ObjectListNext = ObjectList->Flink;
            if (ObReferenceObjectSafe(Object))
            {
                //
                // Make sure the object has not been marked as one that
                // should not receive any events since it is
                // transitioning to a closed state
                //
                if ((Object->Flags & WMIGUID_FLAG_RECEIVE_NO_EVENTS) == 0)
                {
                    if (Object->Flags & WMIGUID_FLAG_KERNEL_NOTIFICATION)
                    {
                        //
                        // KM clients get a direct callback
                        //
                        WMI_NOTIFICATION_CALLBACK Callback;
                        PVOID Context;

                        Callback = Object->Callback;
                        Context = Object->CallbackContext;
                        if (Callback != NULL)
                        {
                            (*Callback)(Wnode, Context);
                        }
                    } else {
                        //
                        // UM clients get event written into IRP or queued up
                        //
                        Status = WmipWriteWnodeToObject(Object,
                                                        Wnode,
                                                        IsHighPriority);

                        if (! NT_SUCCESS(Status))
                        {
                            //
                            // If any attempts to queue the event fail then we return
                            // an error
                            //
                            ReturnStatus = STATUS_UNSUCCESSFUL;
                        }
                    }
                }
                
                ObDereferenceObject(Object);
                //
                // Note that we cannot touch the object anymore
                //
            }
    
            ObjectList = ObjectListNext;
        }
        
        WmipLeaveSMCritSection();
        WmipUnreferenceGE(GuidEntry);
    } else {
        ReturnStatus = STATUS_WMI_GUID_NOT_FOUND;
    }
    
    if (FreeBuffer)
    {
        //
        // Free buffer passed by driver containing event
        //
        ExFreePool(InWnode);
    }

    if ((Wnode != InWnode) && (Wnode != WnodeTarget))
    {
        //
        // If we inserted static names then free it
        //
        WmipFree(Wnode);
    }

    if (WnodeTarget != NULL)
    {
        //
        // if we dereferenced then free it
        //
        WmipFree(WnodeTarget);
    }
    
    return(ReturnStatus);
}

NTSTATUS WmipUMProviderCallback(
    IN WMIACTIONCODE ActionCode,
    IN PVOID DataPath,
    IN ULONG BufferSize,
    IN OUT PVOID Buffer
)
{
    PAGED_CODE();
    
    UNREFERENCED_PARAMETER (ActionCode);
    UNREFERENCED_PARAMETER (DataPath);
    UNREFERENCED_PARAMETER (BufferSize);
    UNREFERENCED_PARAMETER (Buffer);

    ASSERT(FALSE);
    return(STATUS_UNSUCCESSFUL);
}

NTSTATUS WmipRegisterUMGuids(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Cookie,
    IN PWMIREGINFO RegInfo,
    IN ULONG RegInfoSize,
    OUT HANDLE *RequestHandle,
    OUT ULONG64 *LoggerContext
    )
/*+++

Routine Description:

    This routine will register a set of user mode guids with WMI for use
    by tracelog. The following steps will occur:
        
        * A request object is created using the passed object attributes.
          Although the object created is unnamed, the object name passed
          is used to lookup a security descriptor to associate with the 
          object.
              
        * The guids are registered in the system.

Arguments:

    ObjectAttribtes is a pointer to the passed object attributes used to
        create the request object
            
    Cookie is a unique id to associate with the request object so that
        when a request is delivered the UM code can understand the context
        via the cookie.
            
    RegInfo is the registration information passed
        
    RegInfoSize is the number of bytes of registration information passed
        
    *RequestHandle returns with a handle to the request object. UM logger
        creation and tracelog enabled/disable requests are delivered to
        the object as WMI events.
        
    *LoggerContext returns with the logger context

Return Value:

    STATUS_SUCCESS or an error code

---*/
{
    NTSTATUS Status;
    PDEVICE_OBJECT Callback;
    PWMIGUIDOBJECT RequestObject;
    PREGENTRY RegEntry;
    PBGUIDENTRY GuidEntry;
    PWMIREGGUID RegGuid;
    PBDATASOURCE DataSource;
    PBINSTANCESET InstanceSet;
    OBJECT_ATTRIBUTES CapturedObjectAttributes;
    UNICODE_STRING CapturedGuidString;
    WCHAR CapturedGuidBuffer[WmiGuidObjectNameLength + 1];
    
    PAGED_CODE();

    Status = WmipProbeAndCaptureGuidObjectAttributes(&CapturedObjectAttributes,
                                                     &CapturedGuidString,
                                                     CapturedGuidBuffer,
                                                     ObjectAttributes);

    if (NT_SUCCESS(Status))
    {
        Callback = (PDEVICE_OBJECT)(ULONG_PTR) WmipUMProviderCallback;

        //
        // Establish a regentry for the data provider
        //
        WmipEnterSMCritSection();
        RegEntry = WmipAllocRegEntry(Callback,
                                     WMIREG_FLAG_CALLBACK |
                                     REGENTRY_FLAG_TRACED |
                                     REGENTRY_FLAG_NEWREGINFO | 
                                     REGENTRY_FLAG_INUSE |
                                     REGENTRY_FLAG_REG_IN_PROGRESS);
        WmipLeaveSMCritSection();
        
        if (RegEntry != NULL)
        {
            //
            // Build a request object for this data source so that any
            // enable requests can be posted to it while processing the 
            // WmiRegInfo
            //
            Status = WmipOpenGuidObject(&CapturedObjectAttributes,
                                        TRACELOG_REGISTER_GUIDS, 
                                        UserMode,
                                        RequestHandle,
                                        &RequestObject);

            if (NT_SUCCESS(Status))
            {
                Status = WmipProcessWmiRegInfo(RegEntry,
                                               RegInfo,
                                               RegInfoSize,
                                               RequestObject,
                                               FALSE,
                                               TRUE);

                if (NT_SUCCESS(Status))
                {
                    //
                    // Initialize/Update InstanceSet
                    //
                    DataSource = RegEntry->DataSource;
                    RegGuid = &RegInfo->WmiRegGuid[0];

                    InstanceSet = WmipFindISByGuid( DataSource, 
                                                &RegGuid->Guid );
                    if (InstanceSet == NULL)
                    {
                        Status = STATUS_WMI_GUID_NOT_FOUND;
                    }
                    else {
                        WmipUnreferenceIS(InstanceSet);
                    }
                    //
                    // Find out if this Guid is currently Enabled. If so find
                    // its LoggerContext
                    //
                    *LoggerContext = 0;
                    GuidEntry = WmipFindGEByGuid(&RegInfo->WmiRegGuid->Guid, 
                                                 FALSE);
                    if (GuidEntry != NULL)
                    {
                        if (GuidEntry->Flags & GE_NOTIFICATION_TRACE_FLAG)
                        {
                            *LoggerContext = GuidEntry->LoggerContext;
                        }
                        WmipUnreferenceGE(GuidEntry);
                    }

                    RequestObject->Flags |= WMIGUID_FLAG_REQUEST_OBJECT;
                    RequestObject->RegEntry = RegEntry;
                    RequestObject->Cookie = Cookie;
                }
                else
                {
                    //
                    // If an error registering guids then clean up regentry
                    //
                    RegEntry->Flags |= (REGENTRY_FLAG_RUNDOWN | 
                                        REGENTRY_FLAG_NOT_ACCEPTING_IRPS);
                    WmipUnreferenceRegEntry(RegEntry);
                    ZwClose(*RequestHandle);
                }
                
                //
                // remove the ref from when the object was created
                //
                ObDereferenceObject(RequestObject);
                
            } 
            else {
                RegEntry->Flags |= (REGENTRY_FLAG_RUNDOWN | 
                                        REGENTRY_FLAG_NOT_ACCEPTING_IRPS);
                WmipUnreferenceRegEntry(RegEntry);
            }


        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    return(Status);
}


NTSTATUS WmipUnregisterGuids(
    PWMIUNREGGUIDS UnregGuids
    )
{
    PBGUIDENTRY GuidEntry;
    
    PAGED_CODE();

    //
    // Check to see if this GUID got disabled in the middle
    // of Unregister Call. If so, send the LoggerContext back
    //

    GuidEntry = WmipFindGEByGuid(&UnregGuids->Guid, FALSE);
    if (GuidEntry != NULL)
    {
        if ((GuidEntry->Flags & GE_NOTIFICATION_TRACE_FLAG) != 0)
        {

            UnregGuids->LoggerContext = GuidEntry->LoggerContext;
        }
        WmipUnreferenceGE(GuidEntry);
        return (STATUS_SUCCESS);
    }
    else {
        return (STATUS_WMI_INSTANCE_NOT_FOUND);
    }
}


NTSTATUS WmipWriteMBToObject(
    IN PWMIGUIDOBJECT RequestObject,
    IN PWMIGUIDOBJECT ReplyObject,
    IN PUCHAR Message,
    IN ULONG MessageSize
    )
/*+++

Routine Description:

    This routine will build a WNODE out of a message and then write it 
    into the Request object. If a reply object is specified then the reply
    object is linked into the request object so when the reply is written
    to the request object it can be routed to the reply object correctly,.
        
    This routine assumes that the SM Critical section is held
        
Arguments:

    RequestObject is the object to which to send the request
        
    ReplyObject is the object to which the request object should reply.
        This may be NULL in the case that no reply is needed.
            
    Message is the message to be sent
    
    MessageSize is the size of the message in bytes

Return Value:

    STATUS_SUCCESS or an error code

---*/
{
    PWNODE_HEADER Wnode;
    ULONG WnodeSize;
    PUCHAR Payload;
    ULONG i;
    PMBREQUESTS MBRequest;
    NTSTATUS Status;
    
    PAGED_CODE();
    
    //
    // Allocate space to build a wnode out of the data passed
    //
    WnodeSize = sizeof(WNODE_HEADER) + MessageSize;    
    Wnode = WmipAlloc(WnodeSize);
    if (Wnode != NULL)
    {
        //
        // Create an internal wnode with the message as the payload
         //
        RtlZeroMemory(Wnode, sizeof(WNODE_HEADER));
        Wnode->BufferSize = WnodeSize;
        Wnode->Flags = WNODE_FLAG_INTERNAL;
        Wnode->Guid = RequestObject->Guid;
        Wnode->ProviderId = WmiMBRequest;
        Payload = (PUCHAR)Wnode + sizeof(WNODE_HEADER);
        RtlCopyMemory(Payload, Message, MessageSize);
        
        //
        // if this request requires a reply then update the lists for the
        // request and reply objects
        //
        if (ReplyObject != NULL)
        {
            // 
            // Find a free spot in the request object to link
            // in the reply.
            //
            Status = STATUS_INSUFFICIENT_RESOURCES;
        
            for (i = 0; i < MAXREQREPLYSLOTS; i++)
            {
                MBRequest = &RequestObject->MBRequests[i];
                if (MBRequest->ReplyObject == NULL)
                {
                    //
                    // We have a free slot so link request and reply
                    // objects together and send off the request.
                    // The request object takes a ref count on the reply
                    // object since it maintains a pointer to it. The
                    // refcount is released when the request object writes
                    // the reply back to the reply object.
                    //
                    Status = ObReferenceObjectByPointer(ReplyObject,
                                               0,
                                               WmipGuidObjectType,
                                               KernelMode);

                    if (NT_SUCCESS(Status))
                    {
                        MBRequest->ReplyObject = ReplyObject;
                        InsertTailList(&ReplyObject->RequestListHead,
                                       &MBRequest->RequestListEntry);

                        Wnode->Version = i;

                        Status = WmipWriteWnodeToObject(RequestObject,
                                                        Wnode,
                                                        TRUE);
                        if (! NT_SUCCESS(Status))
                        {
                            //
                            // If writing request failed, we need to cleanup
                            //
                            ObDereferenceObject(ReplyObject);
                            MBRequest->ReplyObject = NULL;
                            RemoveEntryList(&MBRequest->RequestListEntry);
                        }
                    }
                    break;
                }
            }
        } else {
            //
            // No reply required so we just write the message to the
            // object and continue with our business
            //
            Status = WmipWriteWnodeToObject(RequestObject,
                                            Wnode,
                                            TRUE);
        }
        
        WmipFree(Wnode);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return(Status);
}

NTSTATUS WmipWriteMessageToGuid(
    IN PBGUIDENTRY GuidEntry,
    IN PWMIGUIDOBJECT ReplyObject,
    IN PUCHAR Message,
    IN ULONG MessageSize,
    OUT PULONG WrittenCount
)
/*+++

Routine Description:

    This routine will loop over all instance sets attached to a guid entry
    and if the data source for it is a user mode data source then it will
    get a request message sent to it.
        
    Note that if there are more than one providers to which a message is
    sent, then success is returned as long as writing to one of them is
    successful.
        
Arguments:

    GuidEntry is the guid entry for the control guid
        
    ReplyObject is the object to which the request object should reply.
        This may be NULL in the case that no reply is needed.
            
    Message is the message to be sent
    
    MessageSize is the size of the message in bytes

Return Value:

    STATUS_SUCCESS or an error code

---*/
{
    NTSTATUS Status, Status2;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    PBDATASOURCE DataSource;
       
    PAGED_CODE();
    
    Status = STATUS_UNSUCCESSFUL;
    *WrittenCount = 0;
    
    WmipEnterSMCritSection();
    
    //
    // Loop over all instances and send create logger
    // request to all user mode data providers
    //
    InstanceSetList = GuidEntry->ISHead.Flink;
    while (InstanceSetList != &GuidEntry->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        GuidISList);
                                    
        DataSource = InstanceSet->DataSource;
        
        if (DataSource->Flags & DS_USER_MODE)
        {
            //
            // User mode guy, so send the request to him
            //
            ASSERT(DataSource->RequestObject != NULL);
            Status2 = WmipWriteMBToObject(DataSource->RequestObject,
                                       ReplyObject,
                                       Message,
                                       MessageSize);
                                   
            if (NT_SUCCESS(Status2))
            {
                Status = STATUS_SUCCESS;
                (*WrittenCount)++;
            }
        }
        
        InstanceSetList = InstanceSetList->Flink;
    }
    
    WmipLeaveSMCritSection();
    
    return(Status);            
}

NTSTATUS WmipCreateUMLogger(
    IN OUT PWMICREATEUMLOGGER CreateInfo
    )
/*+++

Routine Description:

    This routine will send a request to create a UM logger. First it will 
    find the providers associated with the control guid and then create a
    reply object which the providers will reply to when the UM logger is 
    created. Note that the reply object is created as an unnamed object, 
    but that the guid passed in the object name is used to look up the
    security descriptor for the reply object.
        
    Note that if there are more than one providers to which a message is
    sent, then success is returned as long as writing to one of them is
    successful.
        
Arguments:

    CreateInfo has the information needed to create the UM logger. 

Return Value:

    STATUS_SUCCESS or an error code

---*/
{
    NTSTATUS Status;
    PBGUIDENTRY GuidEntry;
    HANDLE ReplyHandle;
    PWMIGUIDOBJECT ReplyObject;
    ULONG MessageSize = 1;
    PWNODE_HEADER Wnode;
    ULONG ReplyCount;
    OBJECT_ATTRIBUTES CapturedObjectAttributes;
    UNICODE_STRING CapturedGuidString;
    WCHAR CapturedGuidBuffer[WmiGuidObjectNameLength + 1];
    
    PAGED_CODE();

    Status = WmipProbeAndCaptureGuidObjectAttributes(&CapturedObjectAttributes,
                                                     &CapturedGuidString,
                                                     CapturedGuidBuffer,
                                                     CreateInfo->ObjectAttributes);


    if (NT_SUCCESS(Status))
    {
        GuidEntry = WmipFindGEByGuid(&CreateInfo->ControlGuid, FALSE);
        if (GuidEntry != NULL)
        {
            //
            // Control guid is registered so create a reply object that the
            // provider will write to.
            //
            if (WmipIsControlGuid(GuidEntry))
            {
                //
                // Create the reply object
                //
                Status = WmipOpenGuidObject(&CapturedObjectAttributes,
                                            TRACELOG_CREATE_INPROC |
                                            TRACELOG_GUID_ENABLE |
                                            WMIGUID_NOTIFICATION,
                                            UserMode,
                                            &ReplyHandle,
                                            &ReplyObject);

                if (NT_SUCCESS(Status))
                {
                    //
                    // Send request to all providers who registered for control
                    // guid
                    //
                    ReplyObject->Flags |= WMIGUID_FLAG_REPLY_OBJECT;
                    InitializeListHead(&ReplyObject->RequestListHead);


                    Wnode = (PWNODE_HEADER) ((PUCHAR) CreateInfo+ sizeof(WMICREATEUMLOGGER));
                    MessageSize = Wnode->BufferSize;

                    Status = WmipWriteMessageToGuid(GuidEntry,
                                                    ReplyObject,
                                                    (PUCHAR)Wnode,
                                                    MessageSize,
                                                    &ReplyCount
                                                   );
                    if (NT_SUCCESS(Status))
                    {
                        //
                        // Create logger requests delivered ok so return handle
                        // to object that will receive the replies.
                        //
                        CreateInfo->ReplyHandle.Handle = ReplyHandle;
                        CreateInfo->ReplyCount = ReplyCount;
                    } else {
                        //
                        // We were not able to deliver the requests so we do not
                        // need to keep the reply object open
                        //
                        ZwClose(ReplyHandle);
                    }

                    //
                    // remove the ref taken when the object was created
                    //
                    ObDereferenceObject(ReplyObject);
                }
            }

            WmipUnreferenceGE(GuidEntry);
        } else {
            //
            // Control guid is not registered so return an error
            //

            Status = STATUS_WMI_INSTANCE_NOT_FOUND;
        }
    }
    
    return(Status);
}


NTSTATUS WmipMBReply(
    IN HANDLE RequestHandle,
    IN ULONG ReplyIndex,
    IN PUCHAR Message,
    IN ULONG MessageSize
    )
/*+++

Routine Description:

    This routine will write a MB reply message to the appropriate
    reply object and unlink the reply object from the request object;
        
Arguments:

    RequestHandle is the handle to the request object
        
    ReplyIndex is the index to the MBRequest entry for the reply object
        
    Message is the reply message
        
    MessageSize is the size of the reply message

Return Value:

    STATUS_SUCCESS or an error code

---*/
{
    NTSTATUS Status;
    PWMIGUIDOBJECT RequestObject, ReplyObject;
    PMBREQUESTS MBRequest;
    
    PAGED_CODE();
    
    Status = ObReferenceObjectByHandle(RequestHandle,
                                       TRACELOG_REGISTER_GUIDS,
                                       WmipGuidObjectType,
                                       UserMode,
                                       &RequestObject,
                                       NULL);

                                   
    if (NT_SUCCESS(Status))
    {
        if (ReplyIndex < MAXREQREPLYSLOTS)
        {
            //
            // Is the ReplyIndex passed valid ??
            //
            WmipEnterSMCritSection();
            MBRequest = &RequestObject->MBRequests[ReplyIndex];
            
            ReplyObject = MBRequest->ReplyObject;
            if (ReplyObject != NULL)
            {

                //
                // We have figured out who we need to reply to so
                // clear out the link between the reply object
                // and this request object
                //
                RemoveEntryList(&MBRequest->RequestListEntry);
                MBRequest->ReplyObject = NULL;
                ObDereferenceObject(ReplyObject);
                
                Status = WmipWriteMBToObject(ReplyObject,
                                  NULL,
                                  Message,
                                  MessageSize);
                if (! NT_SUCCESS(Status))
                {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_ERROR_LEVEL,
                                      "WMI: WmipWriteMBToObject(%p) failed %x\n",
                                      ReplyObject,
                                      Status));                 
                }
                
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
            
            WmipLeaveSMCritSection();
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
        ObDereferenceObject(RequestObject);
    }
    
    return(Status);
}


#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\enabdisa.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

   enabdisa.c

Abstract:

    Enable and disable code

--*/

#include "wmikmp.h"
#include "tracep.h"

BOOLEAN
WmipIsISFlagsSet(
    PBGUIDENTRY GuidEntry,
    ULONG Flags
    );

NTSTATUS WmipDeliverWnodeToDS(
    CHAR ActionCode, 
    PBDATASOURCE DataSource,
    PWNODE_HEADER Wnode,
    ULONG BufferSize
   );

NTSTATUS WmipSendEnableDisableRequest(
    UCHAR ActionCode,
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext
    );

void WmipReleaseCollectionEnabled(
    PBGUIDENTRY GuidEntry
    );

void WmipWaitForCollectionEnabled(
    PBGUIDENTRY GuidEntry
    );

ULONG WmipSendEnableRequest(
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext
    );

ULONG WmipDoDisableRequest(
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext,
    ULONG InProgressFlag
    );

ULONG WmipSendDisableRequest(
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext
    );

NTSTATUS WmipEnableCollectOrEvent(
    PBGUIDENTRY GuidEntry,
    ULONG Ioctl,
    BOOLEAN *RequestSent,
    ULONG64 LoggerContext
    );

NTSTATUS WmipDisableCollectOrEvent(
    PBGUIDENTRY GuidEntry,
    ULONG Ioctl,
    ULONG64 LoggerContext
    );

NTSTATUS WmipEnableDisableTrace(
    IN ULONG Ioctl,
    IN PWMITRACEENABLEDISABLEINFO TraceEnableInfo
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,WmipIsISFlagsSet)
#pragma alloc_text(PAGE,WmipDeliverWnodeToDS)
#pragma alloc_text(PAGE,WmipSendEnableDisableRequest)
#pragma alloc_text(PAGE,WmipReleaseCollectionEnabled)
#pragma alloc_text(PAGE,WmipWaitForCollectionEnabled)
#pragma alloc_text(PAGE,WmipSendEnableRequest)
#pragma alloc_text(PAGE,WmipDoDisableRequest)
#pragma alloc_text(PAGE,WmipSendDisableRequest)
#pragma alloc_text(PAGE,WmipEnableCollectOrEvent)
#pragma alloc_text(PAGE,WmipDisableCollectOrEvent)
#pragma alloc_text(PAGE,WmipEnableDisableTrace)
#pragma alloc_text(PAGE,WmipDisableTraceProviders)
#endif

BOOLEAN
WmipIsISFlagsSet(
    PBGUIDENTRY GuidEntry,
    ULONG Flags
    )
/*++

Routine Description:

    This routine determines whether any of the instance sets associated
    with the GuidEntry has ALL of the flags set

Arguments:

    GuidEntry  Pointer to the Guid Entry structure.
        
    Flags has flags required

Return Value:


--*/
{
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;

    PAGED_CODE();
    
    if (GuidEntry != NULL)
    {
        WmipEnterSMCritSection();
        InstanceSetList = GuidEntry->ISHead.Flink;
        while (InstanceSetList != &GuidEntry->ISHead)
        {
            InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
            if ( (InstanceSet->Flags & Flags) == Flags )
            {
                WmipLeaveSMCritSection();
                return (TRUE);
            }
            InstanceSetList = InstanceSetList->Flink;
        }
        WmipLeaveSMCritSection();
    }
    return (FALSE);
}

NTSTATUS WmipDeliverWnodeToDS(
    CHAR ActionCode, 
    PBDATASOURCE DataSource,
    PWNODE_HEADER Wnode,
    ULONG BufferSize
   )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    PWMIGUIDOBJECT GuidObject;

    PAGED_CODE();
    
    if (DataSource->Flags & DS_KERNEL_MODE)
    {    
        //
        // If KM provider then send an irp
        //
        Status = WmipSendWmiIrp(ActionCode,
                                DataSource->ProviderId,
                                &Wnode->Guid,
                                BufferSize,
                                Wnode,
                                &Iosb);
    } else if (DataSource->Flags & DS_USER_MODE) {
        //
        // If UM provider then send a MB message
        //
        GuidObject = DataSource->RequestObject;
        if (GuidObject != NULL)
        {
            Wnode->Flags |= WNODE_FLAG_INTERNAL;
            Wnode->ProviderId = ActionCode;
            Wnode->CountLost = GuidObject->Cookie;
            WmipEnterSMCritSection();
            Status = WmipWriteWnodeToObject(GuidObject,
                                            Wnode,
                                            TRUE);
            WmipLeaveSMCritSection();
        } else {
            Status = STATUS_SUCCESS;
        }
    } else {
        ASSERT(FALSE);
        Status = STATUS_UNSUCCESSFUL;
    }
                     
    return(Status);
}

NTSTATUS WmipSendEnableDisableRequest(
    UCHAR ActionCode,
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext
    )
/*++

Routine Description:

    This routine will deliver an event or collection WNODE to all data
    providers of a guid. This routine assumes that it is called with the
    SM critical section held. The routine does not hold the critical
    section for the duration of the call.

Arguments:

    ActionCode is WMI_ENABLE_EVENTS, WMI_DISABLE_EVENTS,
        WMI_ENABLE_COLLECTION or WMI_DISABLE_COLLECTION

    GuidEntry is the guid entry for the guid that is being enabled/disable
        or collected/stop collected

    IsEvent is TRUE then ActionCode is to enable or disable events.
        If FALSE then ActionCode is to enable or disbale collecton

    IsTraceLog is TRUE then enable is only sent to those guids registered as
        being a tracelog guid

    LoggerContext is a logger context handle that should be placed in the
        HistoricalContext field of the WNODE_HEADER if IsTraceLog is TRUE.

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
#if DBG
#define AVGISPERGUID 1
#else
#define AVGISPERGUID 64
#endif

    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    PBDATASOURCE DataSourceArray[AVGISPERGUID];
    PBDATASOURCE *DataSourceList;
    ULONG BufferSize;
    ULONG Status = 0;
    PWNODE_HEADER pWnode;
    ULONG i;
    PBDATASOURCE DataSource;
    ULONG DSCount;
    BOOLEAN IsEnable;
    ULONG IsFlags, IsUpdate;

    WMITRACE_NOTIFY_HEADER  TraceNotifyHeader;

    PAGED_CODE();

    if (GuidEntry->Flags & GE_FLAG_INTERNAL)
    {
        //
        // Guids that have been unregistered and Internally defined guids
        // have no data source to send requests to, so just leave happily
        return(STATUS_SUCCESS);
    }
            

    IsEnable = ((ActionCode == IRP_MN_ENABLE_EVENTS) ||
                (ActionCode == IRP_MN_ENABLE_COLLECTION));
    IsFlags = IsEvent ? IS_ENABLE_EVENT : IS_ENABLE_COLLECTION;

    //
    // Determine whether this is an update call and reset the bit
    //
    IsUpdate = (GuidEntry->Flags & GE_NOTIFICATION_TRACE_UPDATE);


    //
    // First we make a list of all of the DataSources that need to be called
    // while we have the critical section and take a reference on them so
    // they don't go away after we release them. Note that the DataSource
    // structure will stay, but the actual data provider may in fact go away.
    // In this case sending the request will fail.
    DSCount = 0;

    if (GuidEntry->ISCount > AVGISPERGUID)
    {
        DataSourceList = WmipAlloc(GuidEntry->ISCount * sizeof(PBDATASOURCE));
        if (DataSourceList == NULL)
        {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: alloc failed for DataSource array in WmipSendEnableDisableRequest\n"));

            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    } else {
        DataSourceList = &DataSourceArray[0];
    }
#if DBG
    memset(DataSourceList, 0, GuidEntry->ISCount * sizeof(PBDATASOURCE));
#endif

    InstanceSetList = GuidEntry->ISHead.Flink;
    while ((InstanceSetList != &GuidEntry->ISHead) &&
           (DSCount < GuidEntry->ISCount))
    {
        WmipAssert(DSCount < GuidEntry->ISCount);
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        GuidISList);


        //
        // We send requests to those data providers that are not inprocs when
        // it is an event being enabled or it is collection being enabled
        // and they are defined to be expensive (collection needs to be
        // enabled)
        if (
             ( (IsTraceLog && (InstanceSet->Flags & IS_TRACED)) ||
               ( ! IsTraceLog && (! (InstanceSet->Flags & IS_TRACED)) &&
                 (IsEvent || (InstanceSet->Flags & IS_EXPENSIVE))
               )
             )
           )
        {

            if ( (! IsEnable && (InstanceSet->Flags & IsFlags)) ||
                 ((IsEnable && ! (InstanceSet->Flags & IsFlags)) ||
                 (IsUpdate && IsTraceLog))
               )
            {
                DataSourceList[DSCount] = InstanceSet->DataSource;
                WmipReferenceDS(DataSourceList[DSCount]);
                DSCount++;
            }

            if (IsEnable)
            {
                InstanceSet->Flags |= IsFlags;
            } else {
                InstanceSet->Flags &= ~IsFlags;
            }
        }

        InstanceSetList = InstanceSetList->Flink;
    }


    if (IsUpdate) 
    { 
        GuidEntry->Flags &= ~GE_NOTIFICATION_TRACE_UPDATE;
    }


    WmipLeaveSMCritSection();

    //
    // Now without the critical section we send the request to all of the
    // data providers. Any new data providers who register after we made our
    // list will be enabled by the registration code.
    if (DSCount > 0)
    {
        pWnode = &TraceNotifyHeader.Wnode;
        RtlZeroMemory(pWnode, sizeof(TraceNotifyHeader));
        RtlCopyMemory(&pWnode->Guid, &GuidEntry->Guid, sizeof(GUID));
        BufferSize = sizeof(WNODE_HEADER);

        if (IsTraceLog)
        {
            BufferSize = sizeof(TraceNotifyHeader);
            TraceNotifyHeader.LoggerContext = LoggerContext;
            pWnode->Flags |= WNODE_FLAG_TRACED_GUID;
            //
            // If this GUID is already enabled then this must 
            // an update call. So mark it so. 
            // 
            if ( IsEnable &&  IsUpdate ) {
                pWnode->ClientContext = IsUpdate;
            }

        }
        pWnode->BufferSize = BufferSize;

        for (i = 0; i < DSCount; i++)
        {
            DataSource = DataSourceList[i];
            WmipAssert(DataSource != NULL);
            if (IsTraceLog) {
                if (DataSource->Flags & DS_KERNEL_MODE) {
                    pWnode->HistoricalContext = LoggerContext;
                }
                else if (DataSource->Flags & DS_USER_MODE) {
                    pWnode->HistoricalContext = 0;
                }
                else {
                    ASSERT(FALSE);
                }
            }
                                
            Status |= WmipDeliverWnodeToDS(ActionCode, 
                                          DataSource, 
                                          pWnode,
                                          BufferSize);
            

            WmipUnreferenceDS(DataSource);
        }
    }

    if( ! IsTraceLog )
    {

        Status = STATUS_SUCCESS;
    }

    if (DataSourceList != DataSourceArray)
    {
        WmipFree(DataSourceList);
    }

    WmipEnterSMCritSection();

    return(Status);
}

void WmipReleaseCollectionEnabled(
    PBGUIDENTRY GuidEntry
    )
{
    PAGED_CODE();
    
    if (GuidEntry->Flags & GE_FLAG_WAIT_ENABLED)
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p enable releasning %p.%p %x event %p\n",
                                 PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                     GuidEntry,
                                     GuidEntry->Flags));
                                 
        KeSetEvent(GuidEntry->CollectInProgress, 0, FALSE);
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p enable did release %p %x event %p\n",
                                 PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                     GuidEntry,
                                     GuidEntry->Flags));
                                 
        GuidEntry->Flags &= ~GE_FLAG_WAIT_ENABLED;
    }
}

void WmipWaitForCollectionEnabled(
    PBGUIDENTRY GuidEntry
    )
{
    PAGED_CODE();
    
    WmipAssert((GuidEntry->Flags & GE_FLAG_COLLECTION_IN_PROGRESS) ==
                   GE_FLAG_COLLECTION_IN_PROGRESS);
    
    //
    // Collection Enable/Disable is in progress so
    // we cannot return just yet. Right now there could be a 
    // disable request being processed and if we didn't wait, we
    // might get back to this caller before that disable request
    // got around to realizing that it needs to send and enable 
    // request (needed by this thread's caller). So we'd have a 
    // situation where a thread though that collection was enabled
    // but in reality it wasn't yet enabled.
    if ((GuidEntry->Flags & GE_FLAG_WAIT_ENABLED) == 0)
    {
        KeInitializeEvent(GuidEntry->CollectInProgress, 
                          NotificationEvent,
                          FALSE);
        GuidEntry->Flags |= GE_FLAG_WAIT_ENABLED;
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p for %p %x created event\n",
                                 PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                 GuidEntry,
                                 GuidEntry->Flags));
    }
            
    WmipLeaveSMCritSection();
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p waiting for %p %x on event\n",
                                 PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                     GuidEntry,
                                     GuidEntry->Flags));
    KeWaitForSingleObject(GuidEntry->CollectInProgress, 
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p done %p %x waiting on event\n",
                                 PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                     GuidEntry,
                                     GuidEntry->Flags));
    WmipEnterSMCritSection();
    
}

ULONG WmipSendEnableRequest(
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext
    )
/*++
Routine Description:

    This routine will send an enable collection or notification request to
    all of the data providers that have registered the guid being enabled.
    This routine will manage any race conditions that might occur when
    multiple threads are enabling and disabling the notification
    simultaneously.

    This routine is called while the SM critical section is being held and
    will increment the appropriate reference count. if the ref count
    transitions from 0 to 1 then the enable request will need to be forwarded
    to the data providers otherwise the routine is all done and returns.
    Before sending the enable request the routine checks to see if any
    enable or disable requests are currently in progress and if not then sets
    the in progress flag, releases the critical section and sends the enable
    request. If there was a request in progress then the routine does not
    send a request, but just returns. When the other thread that was sending
    the request returns from processing the request it will recheck the
    refcount and notice that it is greater than 0 and then send the enable
    request.


Arguments:

    GuidEntry is the guid entry that describes the guid being enabled. For
        a notification it may be NULL.

    NotificationContext is the notification context to use if enabling events

    IsEvent is TRUE if notifications are being enables else FALSE if
        collection is being enabled

    IsTraceLog is TRUE if enable is for a trace log guid

    LoggerContext is a context value to forward in the enable request

Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    ULONG InProgressFlag;
    ULONG RefCount;
    ULONG Status;

    PAGED_CODE();
    
    if (IsEvent)
    {
        InProgressFlag = GE_FLAG_NOTIFICATION_IN_PROGRESS;
        RefCount = GuidEntry->EventRefCount++;
    } else {
        InProgressFlag = GE_FLAG_COLLECTION_IN_PROGRESS;
        RefCount = GuidEntry->CollectRefCount++;
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p enable collect for %p %x\n",
                  PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                  GuidEntry, GuidEntry->Flags ));
    }

    //
    // If the guid is transitioning from a refcount of 0 to 1 and there
    // is not currently a request in progress, then we need to set the
    // request in progress flag, release the critical section and
    // send an enable request. If there is a request in progress we can't
    // do another request. Whenever the current request finishes  it
    // will notice the ref count change and send the enable request on
    // our behalf.
    if ((RefCount == 0) &&
        ! (GuidEntry->Flags & InProgressFlag)) 
    {
        //
        // Take an extra ref count so that even if this gets disabled
        // while the enable request is in progress the GuidEntry
        // will stay valid.
        WmipReferenceGE(GuidEntry);
        GuidEntry->Flags |= InProgressFlag;
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p NE %p flags -> %x at %d\n",
                  PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                  GuidEntry,
                  GuidEntry->Flags,
                  __LINE__));

EnableNotification:
        Status = WmipSendEnableDisableRequest((UCHAR)(IsEvent ?
                                                IRP_MN_ENABLE_EVENTS :
                                                IRP_MN_ENABLE_COLLECTION),
                                              GuidEntry,
                                              IsEvent,
                                              IsTraceLog,
                                              LoggerContext);

       RefCount = IsEvent ? GuidEntry->EventRefCount :
                            GuidEntry->CollectRefCount;

       if (RefCount == 0)
       {
           // This is the bogus situation we were worried about. While
           // the enable request was being processed the notification
           // was disabled. So leave the in progress flag set and
           // send the disable.

           Status = WmipSendEnableDisableRequest((UCHAR)(IsEvent ?
                                                    IRP_MN_DISABLE_EVENTS :
                                                    IRP_MN_DISABLE_COLLECTION),
                                                 GuidEntry,
                                                 IsEvent,
                                                 IsTraceLog,
                                                 LoggerContext);

            RefCount = IsEvent ? GuidEntry->EventRefCount :
                                 GuidEntry->CollectRefCount;

            if (RefCount > 0)
            {
                //
                // We have hit a pathological case. One thread called to
                // enable and while the enable request was being processed
                // another thread called to disable, but was postponed
                // since the enable was in progress. So once the enable
                // completed we realized that the ref count reached 0 and
                // so we need to disable and sent the disable request.
                // But while the disable request was being processed
                // an enable request came in so now we need to enable
                // the notification.
                goto EnableNotification;
            }
        }
        GuidEntry->Flags &= ~InProgressFlag;
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p NE %p flags -> %x at %d\n",
                  PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                  GuidEntry,
                  GuidEntry->Flags,
                  __LINE__));
        
        //
        // If there are any other threads that were waiting until all of 
        // the enable/disable work completed, we close the event handle
        // to release them from their wait.
        //
        if (! IsEvent)
        {            
            WmipReleaseCollectionEnabled(GuidEntry);
        }

        //
        // Get rid of extra ref count we took above. Note that the
        // GuidEntry could be going away here if there was a
        // disable while the enable was in progress.
        WmipUnreferenceGE(GuidEntry);

    } else if (IsTraceLog && (GuidEntry->Flags & GE_NOTIFICATION_TRACE_UPDATE) ) {
        //
        // If it's a tracelog and we have a trace Update enable call, ignore the 
        // refcount and send it through. 
        //

        WmipReferenceGE(GuidEntry);

        Status = WmipSendEnableDisableRequest((UCHAR)(IsEvent ?
                                                IRP_MN_ENABLE_EVENTS :
                                                IRP_MN_ENABLE_COLLECTION),
                                              GuidEntry,
                                              IsEvent,
                                              IsTraceLog,
                                              LoggerContext);
        GuidEntry->EventRefCount--;

        WmipUnreferenceGE(GuidEntry);

    } else {
        if ((! IsEvent) && (GuidEntry->Flags & InProgressFlag))
        {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p going to wait for %p %x at %d\n",
                                          PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                          GuidEntry,
                                          GuidEntry->Flags,
                                          __LINE__));
            WmipWaitForCollectionEnabled(GuidEntry);
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p done to wait for %p %x at %d\n",
                                          PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                          GuidEntry,
                                          GuidEntry->Flags,
                                          __LINE__));
            
        }
        
        Status = STATUS_SUCCESS;
    }

    if (! IsEvent)
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p enable collect done for %p %x\n",
                  PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                  GuidEntry,
                  GuidEntry->Flags));
    }

    return(Status);
}

ULONG WmipDoDisableRequest(
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext,
    ULONG InProgressFlag
    )
{
    ULONG RefCount;
    ULONG Status;

    PAGED_CODE();
    
DisableNotification:
    Status = WmipSendEnableDisableRequest((UCHAR)(IsEvent ?
                                            IRP_MN_DISABLE_EVENTS :
                                            IRP_MN_DISABLE_COLLECTION),
                                          GuidEntry,
                                          IsEvent,
                                          IsTraceLog,
                                          LoggerContext);

    RefCount = IsEvent ? GuidEntry->EventRefCount :
                         GuidEntry->CollectRefCount;

    if (RefCount > 0)
    {
        //
        // While we were processing the disable request an
        // enable request arrived. Since the in progress
        // flag was set the enable request was not sent
        // so now we need to do that.

        Status = WmipSendEnableDisableRequest((UCHAR)(IsEvent ?
                                                 IRP_MN_ENABLE_EVENTS :
                                                 IRP_MN_ENABLE_COLLECTION),
                                              GuidEntry,
                                              IsEvent,
                                              IsTraceLog,
                                              LoggerContext);

        RefCount = IsEvent ? GuidEntry->EventRefCount:
                             GuidEntry->CollectRefCount;

        if (RefCount == 0)
        {
            //
            // While processing the enable request above the
            // notification was disabled and since a request
            // was in progress the disable request was not
            // forwarded. Now it is time to forward the
            // request.
            goto DisableNotification;
        }
    }
    GuidEntry->Flags &= ~InProgressFlag;
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p NE %p flags -> %x at %d\n",
                  PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                  GuidEntry,
                  GuidEntry->Flags,
                  __LINE__));
    
    //
    // If there are any other threads that were waiting until all of 
    // the enable/disable work completed, we close the event handle
    // to release them from their wait.
    //
    if (! IsEvent)
    {
        WmipReleaseCollectionEnabled(GuidEntry);
    }
    
    return(Status);
}

ULONG WmipSendDisableRequest(
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext
    )
/*++
Routine Description:

    This routine will send an disable collection or notification request to
    all of the data providers that have registered the guid being disabled.
    This routine will manage any race conditions that might occur when
    multiple threads are enabling and disabling the notification
    simultaneously.

    This routine is called while the SM critical section is being held and
    will increment the appropriate reference count. if the ref count
    transitions from 1 to 0 then the disable request will need to be forwarded
    to the data providers otherwise the routine is all done and returns.
    Before sending the disable request the routine checks to see if any
    enable or disable requests are currently in progress and if not then sets
    the in progress flag, releases the critical section and sends the disable
    request. If there was a request in progress then the routine does not
    send a request, but just returns. When the other thread that was sending
    the request returns from processing the request it will recheck the
    refcount and notice that it is  0 and then send the disable
    request.


Arguments:

    GuidEntry is the Notification entry that describes the guid
        being enabled.

    GuidEntry is the guid entry that describes the guid being enabled. For
        a notification it may be NULL.

    NotificationContext is the notification context to use if enabling events

    IsEvent is TRUE if notifications are being enables else FALSE if
        collection is being enabled

    IsTraceLog is TRUE if enable is for a trace log guid

    LoggerContext is a context value to forward in the enable request

Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    ULONG InProgressFlag;
    ULONG RefCount;
    ULONG Status;

    PAGED_CODE();
    
    if (IsEvent)
    {
        InProgressFlag = GE_FLAG_NOTIFICATION_IN_PROGRESS;
        RefCount = GuidEntry->EventRefCount;
        if (RefCount == 0)
        {
            //
            // A bad data consumer is disabling his event more
            // than once. Just ignore it
            return(STATUS_SUCCESS);
        }

        RefCount = --GuidEntry->EventRefCount;
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p Disabling for %p %x\n",
                                 PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                 GuidEntry,
                                 GuidEntry->Flags));
        InProgressFlag = GE_FLAG_COLLECTION_IN_PROGRESS;
        RefCount = --GuidEntry->CollectRefCount;
        WmipAssert(RefCount != 0xffffffff);
    }

    //
    // If we have transitioned to a refcount of zero and there is
    // not a request in progress then forward the disable request.
    if ((RefCount == 0) &&
        ! (GuidEntry->Flags & InProgressFlag))
    {

        //
        // Take an extra ref count so that even if this gets
        // disabled while the disable request is in progress the
        // GuidEntry will stay valid.
        GuidEntry->Flags |= InProgressFlag;
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p NE %p flags -> %x at %d\n",
                  PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                  GuidEntry,
                  GuidEntry->Flags,
                  __LINE__));

        Status = WmipDoDisableRequest(GuidEntry,
                                      IsEvent,
                                      IsTraceLog,
                                      LoggerContext,
                                      InProgressFlag);
                                  
    } else {
        Status = STATUS_SUCCESS;
    }

    if (! IsEvent)
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p Disable complete for %p %x\n",
                                 PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                 GuidEntry,
                                 GuidEntry->Flags));
    }
    return(Status);
}


NTSTATUS WmipEnableCollectOrEvent(
    PBGUIDENTRY GuidEntry,
    ULONG Ioctl,
    BOOLEAN *RequestSent,
    ULONG64 LoggerContext
    )
{
    LOGICAL DoEnable;
    BOOLEAN IsEvent, IsTracelog;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    NTSTATUS Status;

    PAGED_CODE();
    
    *RequestSent = FALSE;
    
    switch (Ioctl)
    {
        case IOCTL_WMI_OPEN_GUID_FOR_QUERYSET:
        {
            //
            // See if the guid requires an enable collection. Loop over all
            // instance sets that are not for tracelog or events.
            //
            DoEnable = FALSE;
            IsTracelog = FALSE;
            IsEvent = FALSE;
            WmipEnterSMCritSection();
            InstanceSetList = GuidEntry->ISHead.Flink;
            while (InstanceSetList != &GuidEntry->ISHead) 
            {
                InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        GuidISList);

                if ( ! ((InstanceSet->Flags & IS_TRACED) ||
                        ((InstanceSet->Flags & IS_EVENT_ONLY) && DoEnable)))
                {
                    //
                    // Only those guids not Traced guids, event only guids
                    // and unresolved references are not available for queries
                    DoEnable = (DoEnable || (InstanceSet->Flags & IS_EXPENSIVE));
                }
                InstanceSetList = InstanceSetList->Flink;
            }
        
            WmipLeaveSMCritSection();
            break;
        }
        
        case IOCTL_WMI_OPEN_GUID_FOR_EVENTS:
        {
            //
            // For events we always send enable request
            //
            DoEnable = TRUE;
            IsEvent = TRUE;
            IsTracelog = FALSE;
            //
            // Note: If this guid has GE_NOTIFICATION_TRACE_FLAG set, 
            // then it will get enabled for tracelog as well as for 
            // wmi events. 
            //
            break;
        }
        
        case IOCTL_WMI_ENABLE_DISABLE_TRACELOG:
        {
            //
            // Setup for a tracelog enable request
            //
            DoEnable = TRUE;
            IsEvent = TRUE;
            IsTracelog = TRUE;
            break;
        }
        
        default:
        {
            ASSERT(FALSE);
            return(STATUS_ILLEGAL_FUNCTION);
        }
    }
    
    if (DoEnable)
    {
        WmipEnterSMCritSection();
        Status = WmipSendEnableRequest(GuidEntry,
                              IsEvent,
                              IsTracelog,
                              LoggerContext);
        WmipLeaveSMCritSection();
                          
        if (NT_SUCCESS(Status))
        {
            *RequestSent = TRUE;
        }
    } else {
        Status = STATUS_SUCCESS;
    }
    return(Status);
}

NTSTATUS WmipDisableCollectOrEvent(
    PBGUIDENTRY GuidEntry,
    ULONG Ioctl,
    ULONG64 LoggerContext
    )
{
    BOOLEAN IsEvent, IsTracelog;
    NTSTATUS Status;

    PAGED_CODE();
    
    switch(Ioctl)
    {
        case IOCTL_WMI_OPEN_GUID_FOR_QUERYSET:
        {
            IsEvent = FALSE;
            IsTracelog = FALSE;
            break;
        }
        
        case IOCTL_WMI_OPEN_GUID_FOR_EVENTS:
        {
            //
            // For events we always send enable request
            //    
            IsEvent = TRUE;
            IsTracelog = FALSE;
            break;
        }
            
        case IOCTL_WMI_ENABLE_DISABLE_TRACELOG:
        {
            IsEvent = TRUE;
            IsTracelog = TRUE;
            break;
        }
        
        default:
        {
            ASSERT(FALSE);
            return(STATUS_ILLEGAL_FUNCTION);
        }
            
    }
    
    WmipEnterSMCritSection();
    Status = WmipSendDisableRequest(GuidEntry,
                              IsEvent,
                              IsTracelog,
                              LoggerContext);
    WmipLeaveSMCritSection();

    return(Status);
}

NTSTATUS WmipEnableDisableTrace(
    IN ULONG Ioctl,
    IN PWMITRACEENABLEDISABLEINFO TraceEnableInfo
    )
/*++

Routine Description:

    This routine will enable or disable a tracelog guid

Arguments:

   Ioctl is the IOCTL used to call this routine from UM
         
   TraceEnableInfo has all the info needed to enable or disable

Return Value:


--*/
{
    NTSTATUS Status;
    LPGUID Guid;
    PBGUIDENTRY GuidEntry;
    BOOLEAN RequestSent;
    BOOLEAN IsEnable;
    ULONG64 LoggerContext;
    
    PAGED_CODE();
    
    Guid = &TraceEnableInfo->Guid;
    
    Status = WmipCheckGuidAccess(Guid,
                                 TRACELOG_GUID_ENABLE,
                                 EtwpDefaultTraceSecurityDescriptor);

                
    if (NT_SUCCESS(Status))
    {

        //
        // The following code is serialized for Trace Guids. Only one 
        // control application can be enabling or disabling Trace Guids at a time. 
        // Must be taken before SMCritSection is taken. Otherwise deadlocks will result.
        //
        
        WmipEnterTLCritSection();

        IsEnable = TraceEnableInfo->Enable;

        //
        // Check for Heap and Crit Sec Tracing Guid.
        //

        if( IsEqualGUID(&HeapGuid,Guid)) {

            if(IsEnable){

	            SharedUserData->TraceLogging |= ENABLEHEAPTRACE;

                //
                // increment counter. The counter  
                // is composed of first two bytes
                //

                SharedUserData->TraceLogging += 0x00010000; 


            } else {

                SharedUserData->TraceLogging &= DISABLEHEAPTRACE;
            }

			WmipLeaveTLCritSection();
			return STATUS_SUCCESS;
        } else if(IsEqualGUID(&CritSecGuid,Guid)){  

            if(IsEnable) {

	            SharedUserData->TraceLogging |= ENABLECRITSECTRACE;

                //
                // increment counter. The counter  
                // is composed of first two bytes
                //

                SharedUserData->TraceLogging += 0x00010000; 

            } else {

                SharedUserData->TraceLogging &= DISABLECRITSECTRACE;
            }

			WmipLeaveTLCritSection();
			return STATUS_SUCCESS;

        } else if(IsEqualGUID(&NtdllTraceGuid,Guid)){  

            if(!IsEnable){

                SharedUserData->TraceLogging &= DISABLENTDLLTRACE;

            }
        }

        LoggerContext = TraceEnableInfo->LoggerContext;
        
        WmipEnterSMCritSection();

        GuidEntry = WmipFindGEByGuid(Guid, FALSE);
        
        if (GuidEntry == NULL )
        {
            //
            // The guid is not yet registered
            //
            if (IsEnable )
            {
                //
                // If the NtdllTraceGuid is not in list then we do not want to enable it
                // the NtdllTraceGuid will make an entry only to call starttrace
                //

                if(IsEqualGUID(&NtdllTraceGuid,Guid)){

                    Status = STATUS_ILLEGAL_FUNCTION;

                } else {

                    //
                    // If we are enabling a guid that is not yet registered
                    // we need to create the guid object for it
                    //

                    GuidEntry = WmipAllocGuidEntry();
                    if (GuidEntry != NULL)
                    {
                        //
                        // Initialize the guid entry and keep the ref count
                        // from creation. When tracelog enables we take a ref
                        // count and when it disables we release it
                        //
                        GuidEntry->Guid = *Guid;
                        GuidEntry->Flags |= GE_NOTIFICATION_TRACE_FLAG;
                        GuidEntry->LoggerContext = LoggerContext;
                        GuidEntry->EventRefCount = 1; 
                        InsertHeadList(WmipGEHeadPtr, &GuidEntry->MainGEList);
                        Status = STATUS_SUCCESS;                    
                    } else {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            } 

        } else {
            //
            // The control guid is already registered so lets go and
            // enabled or disable it
            //
            if (WmipIsControlGuid(GuidEntry))
            {
                if (IsEnable)
                {
                    GuidEntry->LoggerContext = LoggerContext;
                    if (GuidEntry->Flags & GE_NOTIFICATION_TRACE_FLAG)
                    {
                        //
                        // We are trying to enable a trace guid that is already
                        // registered
                        //
                        GuidEntry->Flags |= GE_NOTIFICATION_TRACE_UPDATE;
                        Status = WmipEnableCollectOrEvent(GuidEntry,
                                             Ioctl,
                                             &RequestSent,
                                             LoggerContext);

                    } else {
                        GuidEntry->Flags |= GE_NOTIFICATION_TRACE_FLAG;
                        WmipReferenceGE(GuidEntry);

                        Status = WmipEnableCollectOrEvent(GuidEntry,
                                             Ioctl,
                                             &RequestSent,
                                             LoggerContext);
                        
                        if (!NT_SUCCESS(Status) &&
                            (GuidEntry->Flags & GE_NOTIFICATION_TRACE_FLAG)) {

                            //
                            // We failed to enable the trace event, and our
                            // flag is still set. Remove the flag and deref
                            // the guid entry.
                            //
                            // When we call WmipEnableCollectOrEvent above,
                            // we actually drop the SM lock for a little bit.
                            // That means it's possible for a disable call to
                            // come through at the same time, which would
                            // remove the flag and deref the guid entry itself.
                            //

                            GuidEntry->Flags &= ~GE_NOTIFICATION_TRACE_FLAG;
                            WmipUnreferenceGE(GuidEntry);
                        }
                    }

                } else {

                    if (GuidEntry->Flags & GE_NOTIFICATION_TRACE_FLAG)
                    {
                        //
                        // Send the disable collection call and then remove
                        // the refcount that was taken when we enabled
                        //
                        GuidEntry->Flags &= ~GE_NOTIFICATION_TRACE_FLAG;
                        Status = WmipDisableCollectOrEvent(GuidEntry,
                                                 Ioctl,
                                                 LoggerContext);
                        //
                        // Whether the Disable request succeeds or not
                        // we will remove the extra refcount since we 
                        // reset the NOTIFICATION_FLAG
                        //
                        GuidEntry->LoggerContext = 0;
                        WmipUnreferenceGE(GuidEntry);
                    } else {
                        Status = STATUS_WMI_ALREADY_DISABLED;
                    }
                }
            } else if ( IsListEmpty(&GuidEntry->ISHead)  && (! IsEnable) ) {
                //
                // If this GUID is not a control GUID, check to see if 
                // there are no instance sets for this GUID. If so, 
                // it is getting disabled before any instances 
                // registered it. Disable the GUID and clean up the GE. 
                //
                if (GuidEntry->Flags & GE_NOTIFICATION_TRACE_FLAG)
                {
                    GuidEntry->Flags &= ~GE_NOTIFICATION_TRACE_FLAG;
                    GuidEntry->LoggerContext = 0;
                    WmipUnreferenceGE(GuidEntry);
                }
                Status = STATUS_SUCCESS;

            } else if(!IsEqualGUID(&NtdllTraceGuid,Guid)){

                Status = STATUS_ILLEGAL_FUNCTION;

            }

            WmipUnreferenceGE(GuidEntry);
        }

        WmipLeaveSMCritSection();

        WmipLeaveTLCritSection();
    }
    return(Status);
}


//
// When a Logger is shutdown, all providers logging to this logger
// are notified to stop logging first.
//

NTSTATUS 
WmipDisableTraceProviders (
    ULONG StopLoggerId
    )
{
    PBGUIDENTRY GuidEntry;
    PLIST_ENTRY GuidEntryList;
    ULONG LoggerId;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Find all the providers that are logging to this logger
    // and disable them automatically.
    //
CheckAgain:

    WmipEnterSMCritSection();

    GuidEntryList = WmipGEHeadPtr->Flink;
    while (GuidEntryList != WmipGEHeadPtr)
    {
        GuidEntry = CONTAINING_RECORD(GuidEntryList,
                                     GUIDENTRY,
                                     MainGEList);

        if (GuidEntry->Flags & GE_NOTIFICATION_TRACE_FLAG)
        {
            LoggerId = WmiGetLoggerId(GuidEntry->LoggerContext);
            if (LoggerId == StopLoggerId) {
                //
                // Send Disable Notification
                //
                WmipReferenceGE(GuidEntry);
                GuidEntry->Flags &= ~GE_NOTIFICATION_TRACE_FLAG;
                Status = WmipSendDisableRequest(GuidEntry,
                          TRUE,
                          TRUE,
                          GuidEntry->LoggerContext);
                //
                // Since we reset the NOTIFICATION_TRACE_FLAG
                // we will take out the extra ref count whether the 
                // SendDisableRequest was successful or not. 
                //
                GuidEntry->LoggerContext = 0;
                WmipUnreferenceGE(GuidEntry);

                //
                // We need to remove the refcount that was taken when this
                // Guid was Enabled. 
                //

                WmipUnreferenceGE(GuidEntry);

                WmipLeaveSMCritSection();

                //
                // We have to jump out and restart the loop because we let go 
                // of the critsect during SendDisableRequest call
                //
                goto CheckAgain;

            }
        }
        GuidEntryList = GuidEntryList->Flink;
    }

    WmipLeaveSMCritSection();

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\globalog.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    globalog.c

Abstract:

    The global logger, which is started only by registry settings.
    Will start at boot.

--*/

#include "wmikmp.h"
#include "ntos.h"
#include <evntrace.h>
#include "tracep.h"

#define MAX_REGKEYS         10
#define MAX_ENABLE_FLAGS    10
#define DOSDEVICES                      L"\\DosDevices\\"
#define UNCDEVICES                      L"\\??\\UNC"
#define DEFAULT_GLOBAL_LOGFILE_ROOT     L"%SystemRoot%"
#define DEFAULT_GLOBAL_DIRECTORY        L"\\System32\\LogFiles\\WMI"
#define DEFAULT_GLOBAL_LOGFILE          L"trace.log"
#define DEFAULT_TRACE_GUID_NAME         L"0811c1af-7a07-4a06-82ed-869455cdf713"

    //
    // NOTE: Need a trailing NULL entry so that RtlQueryRegistryValues()
    // knows when to stop
    //

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, WmipStartGlobalLogger)
#pragma alloc_text(PAGE, WmipQueryGLRegistryRoutine)
#pragma alloc_text(PAGE, WmipAddLogHeader)
#pragma alloc_text(PAGE, WmipDelayCreate)
#pragma alloc_text(PAGE, WmipCreateDirectoryFile)
#pragma alloc_text(PAGE, WmipCreateNtFileName)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
SECURITY_DESCRIPTOR EtwpDefaultSecurityDescriptor;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

extern HANDLE EtwpPageLockHandle;
//
// NOTE: If we are going to function earlier in boot, we need to see
// if the creation routines and logger routines can run at all while in
// boot path and being pageable
//

VOID
WmipStartGlobalLogger(
    )
/*++

Routine Description:

    This routine will check for registry entries to see if the global
    needs to be started at boot time.

Arguments:

    None

Return Value:


--*/
{
    struct _LOGGER_INFO {
        WMI_LOGGER_INFORMATION LoggerInfo;
        ULONG EnableFlags[MAX_ENABLE_FLAGS];
    } GLog;
    RTL_QUERY_REGISTRY_TABLE QueryRegistryTable[MAX_REGKEYS];
    NTSTATUS status;
    ULONG Win32Error = 0; // ERROR_SUCCESS
    ULONG StartRequested = 0;
    WCHAR NullString = UNICODE_NULL;
    UNICODE_STRING DefaultTraceGuidName;

    // We lock and unlock non-paged portion of ETW code so that we can keep global
    // logger in the memory while it's alive.
    EtwpPageLockHandle
        = MmLockPageableCodeSection((PVOID)(ULONG_PTR)WmipReserveTraceBuffer);
    MmUnlockPageableImageSection(EtwpPageLockHandle);
    KeInitializeGuardedMutex(&WmipTraceGuardedMutex);

    RtlZeroMemory(&EtwpDefaultSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));
    EtwpDefaultTraceSecurityDescriptor = &EtwpDefaultSecurityDescriptor;
    RtlInitUnicodeString(&DefaultTraceGuidName, DEFAULT_TRACE_GUID_NAME);
    status = WmipGetGuidSecurityDescriptor(
                &DefaultTraceGuidName,
                &EtwpDefaultTraceSecurityDescriptor,
                NULL
                );

    RtlZeroMemory(&GLog, sizeof(GLog));

    GLog.LoggerInfo.Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    GLog.LoggerInfo.MinimumBuffers = (ULONG) KeNumberProcessors + 1;
    GLog.LoggerInfo.MaximumBuffers = GLog.LoggerInfo.MinimumBuffers + 25;
    GLog.LoggerInfo.BufferSize     = PAGE_SIZE / 1024;
    GLog.LoggerInfo.Wnode.BufferSize = sizeof(WMI_LOGGER_INFORMATION);
    GLog.LoggerInfo.Wnode.Guid = GlobalLoggerGuid;
    GLog.LoggerInfo.LogFileMode = EVENT_TRACE_DELAY_OPEN_FILE_MODE |
                                  EVENT_TRACE_ADD_HEADER_MODE;
    RtlInitUnicodeString(&GLog.LoggerInfo.LoggerName, L"GlobalLogger");

    RtlZeroMemory(QueryRegistryTable,
                  sizeof(RTL_QUERY_REGISTRY_TABLE) * MAX_REGKEYS);

    QueryRegistryTable[0].QueryRoutine = WmipQueryGLRegistryRoutine;
    QueryRegistryTable[0].EntryContext = (PVOID) &StartRequested;
    QueryRegistryTable[0].Name = L"Start";
    QueryRegistryTable[0].DefaultType = REG_DWORD;

    QueryRegistryTable[1].QueryRoutine = WmipQueryGLRegistryRoutine;
    QueryRegistryTable[1].EntryContext = (PVOID) &GLog.LoggerInfo.BufferSize;
    QueryRegistryTable[1].Name = L"BufferSize";
    QueryRegistryTable[1].DefaultType = REG_DWORD;

    QueryRegistryTable[2].QueryRoutine = WmipQueryGLRegistryRoutine;
    QueryRegistryTable[2].EntryContext = (PVOID)&GLog.LoggerInfo.MinimumBuffers;
    QueryRegistryTable[2].Name = L"MinimumBuffers";
    QueryRegistryTable[2].DefaultType = REG_DWORD;

    QueryRegistryTable[3].QueryRoutine = WmipQueryGLRegistryRoutine;
    QueryRegistryTable[3].EntryContext = (PVOID) &GLog.LoggerInfo.FlushTimer;
    QueryRegistryTable[3].Name = L"FlushTimer";
    QueryRegistryTable[3].DefaultType = REG_DWORD;

    QueryRegistryTable[4].QueryRoutine = WmipQueryGLRegistryRoutine;
    QueryRegistryTable[4].EntryContext = (PVOID)&GLog.LoggerInfo.MaximumBuffers;
    QueryRegistryTable[4].Name = L"MaximumBuffers";
    QueryRegistryTable[4].DefaultType = REG_DWORD;

    QueryRegistryTable[5].QueryRoutine = WmipQueryGLRegistryRoutine;
    QueryRegistryTable[5].EntryContext = (PVOID) &GLog.LoggerInfo.LogFileName;
    QueryRegistryTable[5].Name = L"FileName";
    QueryRegistryTable[5].DefaultType = REG_SZ;
    QueryRegistryTable[5].DefaultData = &NullString;

    QueryRegistryTable[6].QueryRoutine = WmipQueryGLRegistryRoutine;
    QueryRegistryTable[6].EntryContext = (PVOID) &GLog.EnableFlags[0];
    QueryRegistryTable[6].Name = L"EnableKernelFlags";
    QueryRegistryTable[6].DefaultType = REG_BINARY;

    QueryRegistryTable[7].QueryRoutine = WmipQueryGLRegistryRoutine;
    QueryRegistryTable[7].EntryContext = (PVOID)&GLog.LoggerInfo.Wnode.ClientContext;
    QueryRegistryTable[7].Name = L"ClockType";
    QueryRegistryTable[7].DefaultType = REG_DWORD;

    status = RtlQueryRegistryValues(
                RTL_REGISTRY_CONTROL,
                L"WMI\\GlobalLogger",
                QueryRegistryTable,
                NULL,
                NULL);

    if (NT_SUCCESS(status) && (StartRequested != 0)) {
        if (GLog.EnableFlags[0] != 0) {
            SHORT Length;
            for (Length=MAX_ENABLE_FLAGS-1; Length>=0; Length--) {
                if (GLog.EnableFlags[Length] != 0)
                    break;
            }
            if (Length >= 0) {
                PTRACE_ENABLE_FLAG_EXTENSION FlagExt;
                Length++;       // Index is 1 less!
                FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                          &GLog.LoggerInfo.EnableFlags;
                GLog.LoggerInfo.EnableFlags = EVENT_TRACE_FLAG_EXTENSION;
                FlagExt->Length = (UCHAR) Length;
                FlagExt->Offset = (UCHAR) GLog.LoggerInfo.Wnode.BufferSize;
                GLog.LoggerInfo.Wnode.BufferSize
                    += (ULONG) (Length * sizeof(ULONG));
            }
        }

        if (GLog.LoggerInfo.LogFileName.Buffer == NULL) {
            RtlCreateUnicodeString(
                &GLog.LoggerInfo.LogFileName,
                DEFAULT_GLOBAL_LOGFILE_ROOT); // Use ROOT as indicator
            if (GLog.LoggerInfo.LogFileName.Buffer == NULL)
                status = STATUS_NO_MEMORY;
            else
                status = STATUS_SUCCESS;
        }
        if (NT_SUCCESS(status)) {
            status = WmipStartLogger(&GLog.LoggerInfo);
        }
    }
    if (GLog.LoggerInfo.LogFileName.Buffer) {
        RtlFreeUnicodeString(&GLog.LoggerInfo.LogFileName);
    }
    // Write Win32 error to registry.
    if (!NT_SUCCESS(status)) {
        Win32Error = RtlNtStatusToDosError(status);
    }
    RtlWriteRegistryValue(RTL_REGISTRY_CONTROL,
                          L"WMI\\GlobalLogger",
                          L"Status",
                          REG_DWORD,
                          &Win32Error,
                          sizeof(ULONG));
}

NTSTATUS
WmipQueryGLRegistryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    Registry query values callback routine for reading SDs for guids

Arguments:

    ValueName - the name of the value

    ValueType - the type of the value

    ValueData - the data in the value (unicode string data)

    ValueLength - the number of bytes in the value data

    Context - Not used

    EntryContext - Pointer to PSECURITY_DESCRIPTOR to store a pointer to
        store the security descriptor read from the registry value

Return Value:

    NT Status code

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();
    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(Context);

    if ( (ValueData != NULL) && (ValueLength > 0) && (EntryContext != NULL) ){
        if (ValueType == REG_DWORD) {
            if ((ValueLength >= sizeof(ULONG)) && (ValueData != NULL)) {
                *((PULONG)EntryContext) = *((PULONG)ValueData);
            }
        }
        else if (ValueType == REG_SZ) {
            if (ValueLength > sizeof(UNICODE_NULL)) {
                status = RtlCreateUnicodeString(
                            (PUNICODE_STRING) EntryContext,
                            (PCWSTR) ValueData);
            }
        }
        else if (ValueType == REG_BINARY) {
            if ((ValueLength >= sizeof(ULONG)) && (ValueData != NULL)) {
                RtlMoveMemory(EntryContext, ValueData, ValueLength);
            }
        }
    }
    return status;
}

NTSTATUS
WmipAddLogHeader(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN OUT PWMI_BUFFER_HEADER Buffer
    )
/*++

Routine Description:

    Add a standard logfile header in kernel mode. 
    To make sure the first buffer of the log file contains the file header,
    we pop a buffer from the free list, write the header, and flush the buffer
    right away.

Arguments:

    LoggerContext - The logger context

Return Value:

    NT Status code

--*/
{
    PTRACE_LOGFILE_HEADER LogfileHeader;
    USHORT HeaderSize;
    PSYSTEM_TRACE_HEADER EventTrace;
    PETHREAD Thread;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BufferProvided = (Buffer != NULL);
    ULONG LocalBuffer = FALSE;

    if (LoggerContext == NULL) {
        return STATUS_INVALID_PARAMETER;
    }
    // if this is a non-kernel logger started under wow64, 
    // we need to shrink the logfileheader
    if (LoggerContext->Wow && !LoggerContext->KernelTraceOn) {
        HeaderSize = sizeof(TRACE_LOGFILE_HEADER)
                     + LoggerContext->LoggerName.Length + sizeof(UNICODE_NULL)
                     + LoggerContext->LogFileName.Length + sizeof(UNICODE_NULL)
                     - 8;
    }
    else {
        HeaderSize = sizeof(TRACE_LOGFILE_HEADER)
                     + LoggerContext->LoggerName.Length + sizeof(UNICODE_NULL)
                     + LoggerContext->LogFileName.Length + sizeof(UNICODE_NULL);
    }
    if (LoggerContext->BufferSize < 
        (HeaderSize + sizeof(WMI_BUFFER_HEADER) + sizeof(SYSTEM_TRACE_HEADER))) {
        return STATUS_NO_MEMORY;
    }

    //
    // Pop a buffer from Free List
    //

    if (!BufferProvided) {
        Buffer = WmipGetFreeBuffer(LoggerContext);

        if (Buffer == NULL) {
            Buffer = ExAllocatePoolWithTag(NonPagedPool,
                        LoggerContext->BufferSize, TRACEPOOLTAG);
            if (Buffer == NULL) {

            //
            // No buffer available.
            //
                return STATUS_NO_MEMORY;
            }
            LocalBuffer = TRUE;

            Buffer->Flags = 1;

            WmipResetBufferHeader(LoggerContext, Buffer, WMI_BUFFER_TYPE_RUNDOWN);

            KeQuerySystemTime(&Buffer->TimeStamp);
        }
    }

    //
    // Fill in the Header Info.
    //
    Thread = PsGetCurrentThread();
    EventTrace = (PSYSTEM_TRACE_HEADER) (Buffer+1);
    EventTrace->Packet.Group = (UCHAR) (EVENT_TRACE_GROUP_HEADER >> 8);
    EventTrace->Packet.Type  = EVENT_TRACE_TYPE_INFO;
    EventTrace->Packet.Size  = HeaderSize + sizeof(SYSTEM_TRACE_HEADER);
    EventTrace->Marker       = SYSTEM_TRACE_MARKER;
    EventTrace->ThreadId     = HandleToUlong(Thread->Cid.UniqueThread);
    EventTrace->KernelTime   = Thread->Tcb.KernelTime;
    EventTrace->UserTime     = Thread->Tcb.UserTime;
    EventTrace->SystemTime = LoggerContext->ReferenceTimeStamp;


    LogfileHeader = (PTRACE_LOGFILE_HEADER) (EventTrace+1);
    RtlZeroMemory(LogfileHeader, HeaderSize);

    LogfileHeader->BufferSize = LoggerContext->BufferSize;
    LogfileHeader->VersionDetail.MajorVersion = (UCHAR) NtMajorVersion;
    LogfileHeader->VersionDetail.MinorVersion = (UCHAR) NtMinorVersion;
    LogfileHeader->VersionDetail.SubVersion = TRACE_VERSION_MAJOR;
    LogfileHeader->VersionDetail.SubMinorVersion = TRACE_VERSION_MINOR;
    LogfileHeader->ProviderVersion = (NtBuildNumber & 0xffff);

    LogfileHeader->StartBuffers = 1;
    LogfileHeader->LogFileMode =
        LoggerContext->LoggerMode & (~(EVENT_TRACE_REAL_TIME_MODE));
    LogfileHeader->NumberOfProcessors = KeNumberProcessors;
    LogfileHeader->MaximumFileSize = LoggerContext->MaximumFileSize;
    LogfileHeader->TimerResolution = KeMaximumIncrement;

    if (LoggerContext->Wow && !LoggerContext->KernelTraceOn) {
        // We need to shrink a log file header for a non-kernel WOW64 logger.
        PUCHAR LoggerNamePtr64, LogFileNamePtr64;
        KeQueryPerformanceCounter((PLARGE_INTEGER)((PUCHAR)(&LogfileHeader->PerfFreq) - 8));
        *((PLARGE_INTEGER)((PUCHAR)(&LogfileHeader->StartTime) - 8)) 
                                            = LoggerContext->ReferenceSystemTime;
        *((PLARGE_INTEGER)((PUCHAR)(&LogfileHeader->BootTime) - 8)) 
                                            = KeBootTime;
        LogfileHeader->PointerSize = sizeof(ULONG);

        //
        // ReservedFlags to indicate using Perf Clock
        //
        *((PULONG)((PUCHAR)(&LogfileHeader->ReservedFlags) - 8)) 
                                            = LoggerContext->UsePerfClock;

        LoggerNamePtr64 = (PUCHAR) LogfileHeader
                            + sizeof(TRACE_LOGFILE_HEADER) 
                            - 8;
        *((PULONG)(&LogfileHeader->LoggerName)) = PtrToUlong(LoggerNamePtr64);

        LogFileNamePtr64 = (PUCHAR)LogfileHeader
                            + sizeof(TRACE_LOGFILE_HEADER) 
                            - 8 
                            + LoggerContext->LoggerName.Length
                            + sizeof(UNICODE_NULL);
        *((PULONG)((PUCHAR)(&LogfileHeader->LogFileName) - 4)) = PtrToUlong(LogFileNamePtr64);

        RtlCopyMemory(LoggerNamePtr64,
                        LoggerContext->LoggerName.Buffer,
                        LoggerContext->LoggerName.Length + sizeof(UNICODE_NULL));
        RtlCopyMemory(LogFileNamePtr64,
                        LoggerContext->LogFileName.Buffer,
                        LoggerContext->LogFileName.Length + sizeof(UNICODE_NULL));
        RtlQueryTimeZoneInformation((PRTL_TIME_ZONE_INFORMATION)((PUCHAR)(&LogfileHeader->TimeZone) - 8));
    }
    else {
        KeQueryPerformanceCounter(&LogfileHeader->PerfFreq);
        LogfileHeader->StartTime = LoggerContext->ReferenceSystemTime;
        LogfileHeader->BootTime = KeBootTime;
        LogfileHeader->PointerSize = sizeof(PVOID);

        //
        // ReservedFlags to indicate using Perf Clock
        //
        LogfileHeader->ReservedFlags = LoggerContext->UsePerfClock;

        LogfileHeader->LoggerName = (PWCHAR) ( (PUCHAR) LogfileHeader
                                                + sizeof(TRACE_LOGFILE_HEADER) );
        LogfileHeader->LogFileName = (PWCHAR) ( (PUCHAR)LogfileHeader->LoggerName
                                        + LoggerContext->LoggerName.Length
                                        + sizeof(UNICODE_NULL));

        RtlCopyMemory(LogfileHeader->LoggerName,
                            LoggerContext->LoggerName.Buffer,
                            LoggerContext->LoggerName.Length + sizeof(UNICODE_NULL));
        RtlCopyMemory(LogfileHeader->LogFileName,
                            LoggerContext->LogFileName.Buffer,
                            LoggerContext->LogFileName.Length + sizeof(UNICODE_NULL));
        RtlQueryTimeZoneInformation(&LogfileHeader->TimeZone);
    }

    //
    // Adjust the Offset;
    //
    Buffer->CurrentOffset += ALIGN_TO_POWER2(sizeof(SYSTEM_TRACE_HEADER) + HeaderSize, 
                                              WmiTraceAlignment);

    //
    // Log the Group Masks if it is from the kernel logger
    //
    if(LoggerContext == WmipLoggerContext[WmipKernelLogger]) {
        PPERFINFO_GROUPMASK PGroupMask;

        HeaderSize = sizeof(PERFINFO_GROUPMASK) + sizeof(SYSTEM_TRACE_HEADER);
        EventTrace = (PSYSTEM_TRACE_HEADER) ((PCHAR) Buffer + Buffer->CurrentOffset);
        EventTrace->Packet.Group = (UCHAR) (EVENT_TRACE_GROUP_HEADER >> 8);
        EventTrace->Packet.Type  = EVENT_TRACE_TYPE_EXTENSION;
        EventTrace->Packet.Size  = HeaderSize;
        EventTrace->Marker       = SYSTEM_TRACE_MARKER;
        EventTrace->ThreadId     = HandleToUlong(Thread->Cid.UniqueThread);
        EventTrace->KernelTime   = Thread->Tcb.KernelTime;
        EventTrace->UserTime     = Thread->Tcb.UserTime;
        EventTrace->SystemTime   = LoggerContext->ReferenceTimeStamp;

        PGroupMask = (PPERFINFO_GROUPMASK) (EventTrace+1);
        ASSERT(PPerfGlobalGroupMask != NULL);
        RtlCopyMemory(PGroupMask, PPerfGlobalGroupMask, sizeof(PERFINFO_GROUPMASK));

        Buffer->CurrentOffset += ALIGN_TO_POWER2( HeaderSize, WmiTraceAlignment);
    }




    if (BufferProvided)
        return Status;
    //
    // The buffer is prepared properly.  Flush it so it can be written out to disk.
    //
    Status = WmipFlushBuffer(LoggerContext, Buffer, WMI_BUFFER_FLAG_NORMAL);

    if (LocalBuffer && (Buffer != NULL)) {
        ExFreePool(Buffer);
        return Status;
    }

    //
    // Reference count is overwritten during the flush,
    // Set it back before push the buffer into free list.
    //
    Buffer->ReferenceCount = 0;

    //
    // Set the buffer flags to "free" state
    //
    Buffer->State.Flush = 0;
    Buffer->State.InUse = 0;
    Buffer->State.Free = 1;

    //
    // Push into free list
    //
    InterlockedPushEntrySList(&LoggerContext->FreeList,
                              (PSLIST_ENTRY) &Buffer->SlistEntry);
    InterlockedIncrement(&LoggerContext->BuffersAvailable);
    InterlockedDecrement(&LoggerContext->BuffersInUse);
                    
    TraceDebug((2, "WmipAddLogHeader: Boot %I64u Current %I64u Difference %I64u\n",
                   KeBootTime, EventTrace->SystemTime,
                   EventTrace->SystemTime.QuadPart - KeBootTime.QuadPart));

    return Status;
}

NTSTATUS
WmipDelayCreate(
    OUT PHANDLE FileHandle,
    IN OUT PUNICODE_STRING FileName,
    IN ULONG Append
    )
/*++

Routine Description:

    This is called by the global logger to actually open the logfile
    when the first buffer needs to flush (instead of when the logger started)

Arguments:

    LoggerHandle    The handle to the logfile to be returned
    FileName        The logfile name. If the default was chosen, we will
                    returned the actual pathname in %systemroot%

Return Value:

    NT Status code

--*/
{
    PWCHAR Buffer;
    PWCHAR strBuffer = NULL;
    ULONG  DefaultFile, Length;
    UNICODE_STRING LogFileName;
    NTSTATUS Status;

    if (FileName == NULL)
        return STATUS_INVALID_PARAMETER;

    RtlInitUnicodeString(&LogFileName, DEFAULT_GLOBAL_LOGFILE_ROOT);
    DefaultFile = (RtlCompareUnicodeString(FileName, &LogFileName, TRUE) == 0);

    if (DefaultFile) {
        HRESULT hr;
        //
        // Try creating the file first
        //
        Length = (ULONG) (  NtSystemRoot.Length
                          + sizeof(WCHAR) * (wcslen(DEFAULT_GLOBAL_DIRECTORY) +
                                             wcslen(DEFAULT_GLOBAL_LOGFILE) + 1)
                          + sizeof(UNICODE_NULL));
        strBuffer = (PWCHAR) ExAllocatePoolWithTag(
                                        PagedPool, Length, TRACEPOOLTAG);
        if (strBuffer == NULL)
            return STATUS_NO_MEMORY;

        hr = StringCbPrintfW(strBuffer, 
                                  Length,
                                  L"%ws%ws\\%ws",
                                  NtSystemRoot.Buffer,
                                  DEFAULT_GLOBAL_DIRECTORY,
                                  DEFAULT_GLOBAL_LOGFILE);
        if (FAILED(hr)) {
            ExFreePool(strBuffer);
            return STATUS_INVALID_PARAMETER;
        }

        Status = WmipCreateNtFileName(strBuffer, &Buffer);
        if (!NT_SUCCESS(Status)) {
            ExFreePool(strBuffer);
            return Status;
        }

        Status = WmipCreateDirectoryFile(Buffer, FALSE, FileHandle, Append);
        if (!NT_SUCCESS(Status)) {
            ULONG DirLen;
            //
            // Probably directory does not exist, so try and create it
            //
            DirLen = (ULONG)
                     (wcslen(Buffer)-wcslen(DEFAULT_GLOBAL_LOGFILE)) - 5;
            Buffer[DirLen] = UNICODE_NULL;
            Status = WmipCreateDirectoryFile(Buffer, TRUE, NULL, Append);
            if (NT_SUCCESS(Status)) {
                Buffer[DirLen] = L'\\';
                DirLen += 4;
                Buffer[DirLen] = UNICODE_NULL;
                Status = WmipCreateDirectoryFile(Buffer, TRUE, NULL, Append);
                Buffer[DirLen] = L'\\';
            }
            if (NT_SUCCESS(Status)) {
                Status = WmipCreateDirectoryFile(Buffer, FALSE, FileHandle, Append);
            }
        }
        // Make sure that directory is there first

        if (NT_SUCCESS(Status)) {
            if (FileName->Buffer != NULL) {
                RtlFreeUnicodeString(FileName);
            }
            RtlInitUnicodeString(FileName, strBuffer);
            if (FileName->MaximumLength < Length)
                FileName->MaximumLength = (USHORT) Length;
        }
    }
    else {
        Status = WmipCreateNtFileName(FileName->Buffer, &Buffer);
        if (NT_SUCCESS(Status)) {
            Status = WmipCreateDirectoryFile(Buffer, FALSE, FileHandle, Append);
        }
    }

    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }
    return Status;
}

NTSTATUS
WmipCreateDirectoryFile(
    IN PWCHAR DirFileName,
    IN BOOLEAN IsDirectory,
    OUT PHANDLE FileHandle,
    IN ULONG Append
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    UNICODE_STRING LogDirName;
    HANDLE DirHandle = NULL;
    NTSTATUS Status;
    ULONG CreateDisposition;

    if (!IsDirectory && FileHandle == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    RtlInitUnicodeString(&LogDirName, DirFileName);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &LogDirName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    if (IsDirectory) {
        CreateDisposition = FILE_OPEN_IF;
    } else if (Append) {
        CreateDisposition = FILE_OPEN_IF;
    } else {
        CreateDisposition = FILE_OVERWRITE_IF;
    }

    Status = ZwCreateFile(
                &DirHandle,
                FILE_GENERIC_READ | SYNCHRONIZE
                    | (IsDirectory ? FILE_GENERIC_WRITE : FILE_WRITE_DATA),
                &ObjectAttributes,
                &IoStatus,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                CreateDisposition,
                FILE_SYNCHRONOUS_IO_NONALERT
                    | (IsDirectory ? FILE_DIRECTORY_FILE
                                   : FILE_NO_INTERMEDIATE_BUFFERING),
                NULL,
                0);

    TraceDebug((2, "WmipCreateDirectoryFile: Create %ws Mode: %x status: %x\n",
                DirFileName, Append, Status));

    if (NT_SUCCESS(Status) && IsDirectory && (DirHandle != NULL)) {
        ZwClose(DirHandle);
        if (FileHandle) {
            *FileHandle = NULL;
        }
    }
    else {
        if (FileHandle) {
            *FileHandle = DirHandle;
        }
    }

    return Status;
}

NTSTATUS
WmipCreateNtFileName(
    IN  PWCHAR   strFileName,
    OUT PWCHAR * strNtFileName
)
{
    PWCHAR   NtFileName;
    ULONG    lenFileName;
    HRESULT  hr;

    if (strFileName == NULL) {
        *strNtFileName = NULL;
        return STATUS_INVALID_PARAMETER;
    }

    lenFileName = sizeof(UNICODE_NULL)
                + (ULONG) (sizeof(WCHAR) * wcslen(strFileName));
    if ((strFileName[0] == L'\\') && (strFileName[1] == L'\\')) {
        lenFileName += (ULONG) (wcslen(UNCDEVICES) * sizeof(WCHAR));
    }
    else {
        lenFileName += (ULONG) (wcslen(DOSDEVICES) * sizeof(WCHAR));
    }
    NtFileName = (PWCHAR) ExAllocatePoolWithTag(
                            PagedPool, lenFileName, TRACEPOOLTAG);
    if (NtFileName == NULL) {
        *strNtFileName = NULL;
        return STATUS_NO_MEMORY;
    }

    if ((strFileName[0] == L'\\') && (strFileName[1] == L'\\')) {
        hr = StringCbPrintfW(NtFileName, 
                                  lenFileName, 
                                  L"%ws%ws", 
                                  UNCDEVICES, 
                                  &(strFileName[1]));
    }
    else {
        hr = StringCbPrintfW(NtFileName, 
                                  lenFileName, 
                                  L"%ws%ws", 
                                  DOSDEVICES, 
                                  strFileName);
    }
    if (FAILED(hr)) {
        ExFreePool(NtFileName);
        *strNtFileName = NULL;
        return STATUS_INVALID_PARAMETER;
    }

    *strNtFileName = NtFileName;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\dataprov.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    DataProv.c

Abstract:

    WMI internal data provider interface

--*/

#include "wmikmp.h"

NTSTATUS
WmipQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
WmipQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath
    );

NTSTATUS WmipSetWmiDataBlock(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    ULONG GuidIndex,
    ULONG InstanceIndex,
    ULONG BufferSize,
    PUCHAR Buffer
    );

NTSTATUS
WmipExecuteWmiMethod (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    );

BOOLEAN
WmipFindGuid(
    IN PGUIDREGINFO GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex,
    OUT PULONG InstanceCount
    );

NTSTATUS
IoWMICompleteRequest(
    IN PWMILIB_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG BufferUsed,
    IN CCHAR PriorityBoost
    );

NTSTATUS
IoWMISystemControl(
    IN PWMILIB_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif


const GUIDREGINFO WmipGuidList[] =
{
    //
    // This is the pnp id guid which is registered by wmi into other device
    // objects' registration info. And requests to the innocent devices
    // are hijacked by wmi so that wmi can complete the request for it. We
    // have the WMIREG_FLAG_REMOVE_GUID set so that the guid is not registered
    // for the wmi device which does not support it.
    {
        DATA_PROVIDER_PNPID_GUID,
        0,
        WMIREG_FLAG_REMOVE_GUID
    },

    {
        DATA_PROVIDER_PNPID_INSTANCE_NAMES_GUID,
        0,
        WMIREG_FLAG_REMOVE_GUID
    },

    {
        MSAcpiInfoGuid,
        1,
        0
    },
    
#if  defined(_AMD64_) || defined(i386)
    {
        SMBIOS_DATA_GUID,
        1,
        0
    },

    {
        SYSID_UUID_DATA_GUID,
        1,
        0
    },

    {
        SYSID_1394_DATA_GUID,
        1,
        0
    },

    {
        MSSmBios_SMBiosEventlogGuid,
        1,
        0
    },
#endif

#if  defined(_X86_) || defined(_AMD64_)
    {
        MSMCAInfo_RawMCADataGuid,
        1,
        0
    },

    {
        MSMCAInfo_RawMCAEventGuid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        MSMCAInfo_RawCMCEventGuid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        MSMCAInfo_RawCorrectedPlatformEventGuid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },
    
#endif

};
#define WmipGuidCount (sizeof(WmipGuidList) / sizeof(GUIDREGINFO))

typedef enum
{
    PnPIdGuidIndex =      0,
    PnPIdInstanceNamesGuidIndex,
    MSAcpiInfoGuidIndex,
#if  defined(_AMD64_) || defined(i386)
    SmbiosDataGuidIndex,
    SysidUuidGuidIndex,
    Sysid1394GuidIndex,
    SmbiosEventGuidIndex,
#endif  
#if  defined(_X86_) || defined(_AMD64_)
    MCARawDataGuidIndex,
    RawMCAEventGuidIndex,
    RawCMCEventGuidIndex,
    RawCPEEventGuidIndex,
#endif
} WMIGUIDINDEXES;
    

const WMILIB_INFO WmipWmiLibInfo =
{
    NULL,
    NULL,
    WmipGuidCount,
    (PGUIDREGINFO)WmipGuidList,
    WmipQueryWmiRegInfo,
    WmipQueryWmiDataBlock,
    NULL,
    NULL,
    NULL,
    NULL
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,WmipQueryWmiRegInfo)
#pragma alloc_text(PAGE,WmipQueryWmiDataBlock)
#pragma alloc_text(PAGE,WmipSetWmiDataBlock)
#pragma alloc_text(PAGE,WmipExecuteWmiMethod)
#pragma alloc_text(PAGE,WmipFindGuid)
#pragma alloc_text(PAGE,IoWMISystemControl)
#pragma alloc_text(PAGE,IoWMICompleteRequest)
#endif


NTSTATUS
WmipQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    ClassWmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

Return Value:

    status

--*/
{
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (RegFlags);

    *RegistryPath = &WmipRegistryPath;

    RtlInitAnsiString(&AnsiString, "SMBiosData");

    Status = RtlAnsiStringToUnicodeString(InstanceName, &AnsiString, TRUE);

    return(Status);
}

NTSTATUS
WmipQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. When the driver has finished filling the
    data block it must call IoWMICompleteRequest to complete the irp. The
    driver can return STATUS_PENDING if the irp cannot be completed
    immediately.

Arguments:

    DeviceObject is the device whose data block is being queried. In the case
        of the PnPId guid this is the device object of the device on whose
        behalf the request is being processed.

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instances expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fulfill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundary.


Return Value:

    status

--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    ULONG sizeNeeded = 0, sizeSMBios;
    PUCHAR BufferPtr;
    PSMBIOSVERSIONINFO SMBiosVersionInfo;
    PULONG TableSize = NULL;

    PAGED_CODE();

    switch (GuidIndex)
    {
        case SmbiosDataGuidIndex:
        {
            //
            // SMBIOS data table query
#if defined(_AMD64_) || defined(i386)
            WmipAssert((InstanceIndex == 0) && (InstanceCount == 1));

            sizeNeeded = sizeof(SMBIOSVERSIONINFO) + sizeof(ULONG);
            if (BufferAvail >= sizeNeeded)
            {
                sizeSMBios = BufferAvail - sizeNeeded;
                SMBiosVersionInfo = (PSMBIOSVERSIONINFO)Buffer;
                TableSize = (PULONG) (Buffer + sizeof(SMBIOSVERSIONINFO));
                BufferPtr = Buffer + sizeNeeded;
            }
            else
            {
                sizeSMBios = 0;
                BufferPtr = NULL;
                SMBiosVersionInfo = NULL;
            }

            status = WmipGetSMBiosTableData(BufferPtr,
                                    &sizeSMBios,
                                    SMBiosVersionInfo);

            sizeNeeded += sizeSMBios;

            if (NT_SUCCESS(status))
            {
                *(TableSize) = sizeSMBios;
                *InstanceLengthArray = sizeNeeded;
            }
#else
            status = STATUS_WMI_GUID_NOT_FOUND;
#endif
            break;
        }

        case PnPIdGuidIndex:
        {
            PDEVICE_OBJECT pDO;
            UNICODE_STRING instancePath;
            PREGENTRY regEntry;
            ULONG dataBlockSize, paddedDataBlockSize, padSize;
            ULONG i;

            regEntry = WmipFindRegEntryByDevice(DeviceObject, FALSE);
            if (regEntry != NULL)
            {
                pDO = regEntry->PDO;
                WmipAssert(pDO != NULL);

                if (pDO != NULL)
                {
                    status = WmipPDOToDeviceInstanceName(pDO, &instancePath);
                    if (NT_SUCCESS(status))
                    {
                        dataBlockSize = instancePath.Length + sizeof(USHORT);
                        paddedDataBlockSize = (dataBlockSize + 7) & ~7;
                        padSize = paddedDataBlockSize - dataBlockSize;
                        sizeNeeded = paddedDataBlockSize * InstanceCount;
                        if (sizeNeeded <= BufferAvail)
                        {
                            for (i = InstanceIndex;
                                 i < (InstanceIndex + InstanceCount);
                                 i++)
                            {
                                *InstanceLengthArray++ = dataBlockSize;
                                *((PUSHORT)Buffer) = instancePath.Length;
                                Buffer += sizeof(USHORT);
                                RtlCopyMemory(Buffer,
                                                 instancePath.Buffer,
                                              instancePath.Length);
                                Buffer += instancePath.Length;
                                RtlZeroMemory(Buffer, padSize);
                                Buffer += padSize;
                            }
                        } else {
                            status = STATUS_BUFFER_TOO_SMALL;
                        }

                        RtlFreeUnicodeString(&instancePath);

                    } else {
                        status = STATUS_WMI_GUID_NOT_FOUND;
                    }
                } else {
                    status = STATUS_UNSUCCESSFUL;
                }

                WmipUnreferenceRegEntry(regEntry);
            } else {
                WmipAssert(FALSE);
                status = STATUS_WMI_GUID_NOT_FOUND;
            }

            break;
        }

        case PnPIdInstanceNamesGuidIndex:
        {
            PDEVICE_OBJECT pDO;
            UNICODE_STRING instancePath;
            PREGENTRY regEntry;

            regEntry = WmipFindRegEntryByDevice(DeviceObject, FALSE);
            if (regEntry != NULL)
            {
                pDO = regEntry->PDO;
                WmipAssert(pDO != NULL);

                if (pDO != NULL)
                {
                    status = WmipPDOToDeviceInstanceName(pDO, &instancePath);
                    if (NT_SUCCESS(status))
                    {
                        sizeNeeded = sizeof(ULONG) +
                                        instancePath.Length + 2 * sizeof(WCHAR) +
                        sizeof(USHORT);

                        if (sizeNeeded <= BufferAvail)
                        {
                            *((PULONG)Buffer) = 1;
                            Buffer += sizeof(ULONG);
                            *InstanceLengthArray = sizeNeeded;
                            *((PUSHORT)Buffer) = instancePath.Length + 2*sizeof(WCHAR);
                            Buffer += sizeof(USHORT);
                            RtlCopyMemory(Buffer,
                                          instancePath.Buffer,
                                          instancePath.Length);
                            Buffer += instancePath.Length;
                            *((PWCHAR)Buffer) = '_';
                            Buffer += sizeof(WCHAR);
                            *((PWCHAR)Buffer) = '0';
                        } else {
                            status = STATUS_BUFFER_TOO_SMALL;
                        }

                        RtlFreeUnicodeString(&instancePath);

                    } else {
                        status = STATUS_WMI_GUID_NOT_FOUND;
                    }
                } else {
                    status = STATUS_UNSUCCESSFUL;
                }

                WmipUnreferenceRegEntry(regEntry);
            } else {
                WmipAssert(FALSE);
                status = STATUS_WMI_GUID_NOT_FOUND;
            }

            break;
        }

        case MSAcpiInfoGuidIndex:
        {
            RTL_QUERY_REGISTRY_TABLE queryTable[4];
            ULONG bootArchitecture = 0;
            ULONG preferredProfile = 0;
            ULONG capabilities = 0;

            queryTable[0].QueryRoutine = NULL;
            queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT |
                                  RTL_QUERY_REGISTRY_REQUIRED;
            queryTable[0].Name = L"BootArchitecture";
            queryTable[0].EntryContext = &bootArchitecture;
            queryTable[0].DefaultType = REG_NONE;

            queryTable[1].QueryRoutine = NULL;
            queryTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT |
                                  RTL_QUERY_REGISTRY_REQUIRED;
            queryTable[1].Name = L"PreferredProfile";
            queryTable[1].EntryContext = &preferredProfile;
            queryTable[1].DefaultType = REG_NONE;

            queryTable[2].QueryRoutine = NULL;
            queryTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT |
                                  RTL_QUERY_REGISTRY_REQUIRED;
            queryTable[2].Name = L"Capabilities";
            queryTable[2].EntryContext = &capabilities;
            queryTable[2].DefaultType = REG_NONE;

            queryTable[3].QueryRoutine = NULL;
            queryTable[3].Flags = 0;
            
            status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                            L"\\Registry\\Machine\\Hardware\\Description\\System",
                                            queryTable,
                                            NULL,
                                            NULL);

            if (NT_SUCCESS(status))
            {
                sizeNeeded = sizeof(MSAcpiInfo);
                if (sizeNeeded <= BufferAvail)
                {
                    PMSAcpiInfo info = (PMSAcpiInfo)Buffer;
                    info->BootArchitecture = bootArchitecture;
                    info->PreferredProfile = preferredProfile;
                    info->Capabilities = capabilities;
                    status = STATUS_SUCCESS;
                } else {
                    status = STATUS_BUFFER_TOO_SMALL;
                }
            } else {
                status = STATUS_WMI_GUID_NOT_FOUND;
            }
            break;
        }
        
        case Sysid1394GuidIndex:
        case SysidUuidGuidIndex:
        {
            PSYSID_UUID uuid;
            ULONG uuidCount;
            PSYSID_1394 x1394;
            ULONG x1394Count;
            PUCHAR data;
            ULONG count;

#if defined(_AMD64_) || defined(i386)

            status = WmipGetSysIds(&uuid,
                                   &uuidCount,
                                   &x1394,
                                   &x1394Count);

            if (NT_SUCCESS(status))
            {
                if (GuidIndex == Sysid1394GuidIndex)
                {
                    sizeNeeded = x1394Count * sizeof(SYSID_1394) +
                                 sizeof(ULONG);
                    data = (PUCHAR)x1394;
                    count = x1394Count;
                } else {
                    sizeNeeded = uuidCount * sizeof(SYSID_UUID) +
                                 sizeof(ULONG);
                    data = (PUCHAR)uuid;
                    count = uuidCount;
                }

                if (BufferAvail >= sizeNeeded)
                {
                    *InstanceLengthArray = sizeNeeded;
                    *((PULONG)Buffer) = count;
                    Buffer += sizeof(ULONG);
                    RtlCopyMemory(Buffer, data, sizeNeeded-sizeof(ULONG));
                    status = STATUS_SUCCESS;
                } else {
                    status = STATUS_BUFFER_TOO_SMALL;
                }
            }
#else
            status = STATUS_WMI_GUID_NOT_FOUND;
#endif

            break;
        }

        case SmbiosEventGuidIndex:
        {
            //
            // SMBIOS eventlog query

#if defined(_AMD64_) || defined(i386)
            WmipAssert((InstanceIndex == 0) && (InstanceCount == 1));

            if (BufferAvail == 0)
            {
                sizeNeeded = 0;
                BufferPtr = NULL;
            } else {
                sizeNeeded = BufferAvail;
                BufferPtr = Buffer;
            }

            status = WmipGetSMBiosEventlog(BufferPtr, &sizeNeeded);

            if (NT_SUCCESS(status))
            {
                *InstanceLengthArray = sizeNeeded;
            }
#else
            status = STATUS_WMI_GUID_NOT_FOUND;
#endif
            break;
        }

#if  defined(_X86_) || defined(_AMD64_)
        case MCARawDataGuidIndex:
        {
            sizeNeeded = BufferAvail;
            status = WmipGetRawMCAInfo(Buffer,
                                       &sizeNeeded);
                    
            if (NT_SUCCESS(status))
            {
                *InstanceLengthArray = sizeNeeded;
            }
            break;
        }
#endif
        
        default:
        {
            WmipAssert(FALSE);
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
    }

    status = IoWMICompleteRequest((PWMILIB_INFO)&WmipWmiLibInfo,
                                 DeviceObject,
                                 Irp,
                                 status,
                                 sizeNeeded,
                                 IO_NO_INCREMENT);
    return(status);
}

BOOLEAN
WmipFindGuid(
    IN PGUIDREGINFO GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex,
    OUT PULONG InstanceCount
    )
/*++

Routine Description:

    This routine will search the list of guids registered and return
    the index for the one that was registered.

Arguments:

    GuidList is the list of guids to search

    GuidCount is the count of guids in the list

    Guid is the guid being searched for

    *GuidIndex returns the index to the guid

    *InstanceCount returns the count of instances for the guid

Return Value:

    TRUE if guid is found else FALSE

--*/
{
    ULONG i;

    PAGED_CODE();

    for (i = 0; i < GuidCount; i++)
    {
        if (IsEqualGUID(Guid, &GuidList[i].Guid))
        {
            *GuidIndex = i;
            *InstanceCount = GuidList[i].InstanceCount;
            return(TRUE);
        }
    }

    return(FALSE);
}


NTSTATUS
IoWMISystemControl(
    IN PWMILIB_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_SYSTEM_CONTROL. This routine will process
    all wmi requests received, forwarding them if they are not for this
    driver or determining if the guid is valid and if so passing it to
    the driver specific function for handing out wmi requests.

Arguments:

    WmiLibInfo has the WMI information control block

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

    status

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG bufferSize;
    PUCHAR buffer;
    NTSTATUS status;
    ULONG retSize;
    UCHAR minorFunction;
    ULONG guidIndex = 0;
    ULONG instanceCount = 0;
    ULONG instanceIndex = 0;

    PAGED_CODE();

    //
    // If the irp is not a WMI irp or it is not targetted at this device
    // or this device has not registered with WMI then just forward it on.
    minorFunction = irpStack->MinorFunction;
    if ((minorFunction > IRP_MN_REGINFO_EX) ||
        (irpStack->Parameters.WMI.ProviderId != (ULONG_PTR)DeviceObject) ||
        (((minorFunction != IRP_MN_REGINFO) &&
         ((minorFunction != IRP_MN_REGINFO_EX))) &&
         (WmiLibInfo->GuidList == NULL)))
    {
        //
        // IRP is not for us so forward if there is a lower device object
        if (WmiLibInfo->LowerDeviceObject != NULL)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            return(IoCallDriver(WmiLibInfo->LowerDeviceObject, Irp));
        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }
    }

    buffer = (PUCHAR)irpStack->Parameters.WMI.Buffer;
    bufferSize = irpStack->Parameters.WMI.BufferSize;

    if ((minorFunction != IRP_MN_REGINFO) &&
        (minorFunction != IRP_MN_REGINFO_EX))
    {
        //
        // For all requests other than query registration info we are passed
        // a guid. Determine if the guid is one that is supported by the
        // device.
        if (WmipFindGuid(WmiLibInfo->GuidList,
                            WmiLibInfo->GuidCount,
                            (LPGUID)irpStack->Parameters.WMI.DataPath,
                            &guidIndex,
                            &instanceCount))
        {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }

        if (NT_SUCCESS(status) &&
            ((minorFunction == IRP_MN_QUERY_SINGLE_INSTANCE) ||
             (minorFunction == IRP_MN_CHANGE_SINGLE_INSTANCE) ||
             (minorFunction == IRP_MN_CHANGE_SINGLE_ITEM) ||
             (minorFunction == IRP_MN_EXECUTE_METHOD)))
        {
            instanceIndex = ((PWNODE_SINGLE_INSTANCE)buffer)->InstanceIndex;

            if ( ((((PWNODE_HEADER)buffer)->Flags) &
                                     WNODE_FLAG_STATIC_INSTANCE_NAMES) == 0)
            {
                status = STATUS_WMI_INSTANCE_NOT_FOUND;
            }
        }

        if (! NT_SUCCESS(status))
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }
    }

    switch(minorFunction)
    {
        case IRP_MN_REGINFO:
        case IRP_MN_REGINFO_EX:
        {
            ULONG guidCount;
            PGUIDREGINFO guidList;
            PWMIREGINFOW wmiRegInfo;
            PWMIREGGUIDW wmiRegGuid;
            PUNICODE_STRING regPath;
            PWCHAR stringPtr;
            ULONG registryPathOffset;
            ULONG mofResourceOffset;
            ULONG bufferNeeded;
            ULONG i;
            ULONG_PTR nameInfo;
            ULONG nameSize, nameOffset, nameFlags;
            UNICODE_STRING name;
            UNICODE_STRING nullRegistryPath;

            WmipAssert(WmiLibInfo->QueryWmiRegInfo != NULL);
            WmipAssert(WmiLibInfo->QueryWmiDataBlock != NULL);

            name.Buffer = NULL;
            name.Length = 0;
            name.MaximumLength = 0;
            nameFlags = 0;
            status = WmiLibInfo->QueryWmiRegInfo(
                                                    DeviceObject,
                                                    &nameFlags,
                                                    &name,
                                                    &regPath);

            if (NT_SUCCESS(status) &&
                (! (nameFlags &  WMIREG_FLAG_INSTANCE_PDO) &&
                (name.Buffer == NULL)))
            {
                //
                // if PDO flag not specified then an instance name must be
                status = STATUS_INVALID_DEVICE_REQUEST;
            }

#if DBG
            if (nameFlags &  WMIREG_FLAG_INSTANCE_PDO)
            {
                WmipAssert(WmiLibInfo->LowerPDO != NULL);
            }
#endif
            if (NT_SUCCESS(status))
            {
                WmipAssert(WmiLibInfo->GuidList != NULL);

                guidList = WmiLibInfo->GuidList;
                guidCount = WmiLibInfo->GuidCount;

                nameOffset = FIELD_OFFSET(WMIREGINFOW, WmiRegGuid) +
                                      guidCount * sizeof(WMIREGGUIDW);

                if (nameFlags & WMIREG_FLAG_INSTANCE_PDO)
                {
                    nameSize = 0;
                    nameInfo = (ULONG_PTR)WmiLibInfo->LowerPDO;
                } else {
                    nameFlags |= WMIREG_FLAG_INSTANCE_LIST;
                    nameSize = name.Length + sizeof(USHORT);
                    nameInfo = nameOffset;
                }

                if (regPath == NULL)
                {
                    //
                    // No registry path specified. This is a bad thing for
                    // the device to do, but is not fatal
                    nullRegistryPath.Buffer = NULL;
                    nullRegistryPath.Length = 0;
                    nullRegistryPath.MaximumLength = 0;
                    regPath = &nullRegistryPath;
                }

                mofResourceOffset = 0;

                registryPathOffset = nameOffset + nameSize; 

                bufferNeeded = registryPathOffset +
                regPath->Length + sizeof(USHORT);

                if (bufferNeeded <= bufferSize)
                {
                    retSize = bufferNeeded;

                    wmiRegInfo = (PWMIREGINFO)buffer;
                    wmiRegInfo->BufferSize = bufferNeeded;
                    wmiRegInfo->NextWmiRegInfo = 0;
                    wmiRegInfo->MofResourceName = mofResourceOffset;
                    wmiRegInfo->RegistryPath = registryPathOffset;
                    wmiRegInfo->GuidCount = guidCount;

                    for (i = 0; i < guidCount; i++)
                    {
                        wmiRegGuid = &wmiRegInfo->WmiRegGuid[i];
                        wmiRegGuid->Guid = guidList[i].Guid;
                        wmiRegGuid->Flags = guidList[i].Flags | nameFlags;
                        wmiRegGuid->InstanceInfo = nameInfo;
                        wmiRegGuid->InstanceCount = guidList[i].InstanceCount;
                    }

                    if ( nameFlags &  WMIREG_FLAG_INSTANCE_LIST)
                    {
                        stringPtr = (PWCHAR)((PUCHAR)buffer + nameOffset);
                        *stringPtr++ = name.Length;
                        RtlCopyMemory(stringPtr,
                                  name.Buffer,
                                  name.Length);
                    }

                    stringPtr = (PWCHAR)((PUCHAR)buffer + registryPathOffset);
                    *stringPtr++ = regPath->Length;
                    RtlCopyMemory(stringPtr,
                              regPath->Buffer,
                              regPath->Length);
                } else {
                    *((PULONG)buffer) = bufferNeeded;
                    retSize = sizeof(ULONG);
                }
            } else {
                retSize = 0;
            }

            if (name.Buffer != NULL)
            {
                ExFreePool(name.Buffer);
            }

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = retSize;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }

        case IRP_MN_QUERY_ALL_DATA:
        {
            PWNODE_ALL_DATA wnode;
            ULONG bufferAvail;
            PULONG instanceLengthArray;
            PUCHAR dataBuffer;
            ULONG instanceLengthArraySize;
            ULONG dataBlockOffset;
            PREGENTRY regEntry;

            wnode = (PWNODE_ALL_DATA)buffer;

            if (bufferSize < FIELD_OFFSET(WNODE_ALL_DATA,
                                          OffsetInstanceDataAndLength))
            {
                //
                // The buffer should never be smaller than the size of
                // WNODE_ALL_DATA, however if it is then return with an
                // error requesting the minimum sized buffer.
                WmipAssert(FALSE);
                status = IoWMICompleteRequest(WmiLibInfo,
                                              DeviceObject,
                                              Irp,
                                              STATUS_BUFFER_TOO_SMALL,
                                              FIELD_OFFSET(WNODE_ALL_DATA,
                                                           OffsetInstanceDataAndLength),
                                              IO_NO_INCREMENT);
                break;
            }

            //
            // If this is the pnp id guid then we need to get the instance
            // count from the regentry for the device and switch the
            // device object.

            if ((guidIndex == PnPIdGuidIndex) ||
                (guidIndex == PnPIdInstanceNamesGuidIndex))
            {
                regEntry = WmipFindRegEntryByProviderId(wnode->WnodeHeader.ProviderId,
                                                        FALSE);
                if (regEntry == NULL)
                {
                    //
                    // Why couldn't we get the regentry again ??
                    WmipAssert(FALSE);
                    status = IoWMICompleteRequest(WmiLibInfo,
                                              DeviceObject,
                                              Irp,
                                              STATUS_WMI_GUID_NOT_FOUND,
                                              0,
                                              IO_NO_INCREMENT);
                    break;
                }

                DeviceObject = regEntry->DeviceObject;
                instanceCount = (guidIndex == PnPIdGuidIndex) ? regEntry->MaxInstanceNames : 1;

                WmipUnreferenceRegEntry(regEntry);
            }

            wnode->InstanceCount = instanceCount;

            wnode->WnodeHeader.Flags &= ~WNODE_FLAG_FIXED_INSTANCE_SIZE;

            instanceLengthArraySize = instanceCount * sizeof(OFFSETINSTANCEDATAANDLENGTH);

            dataBlockOffset = (FIELD_OFFSET(WNODE_ALL_DATA, OffsetInstanceDataAndLength) + instanceLengthArraySize + 7) & ~7;

            wnode->DataBlockOffset = dataBlockOffset;
            if (dataBlockOffset <= bufferSize)
            {
                instanceLengthArray = (PULONG)&wnode->OffsetInstanceDataAndLength[0];
                dataBuffer = buffer + dataBlockOffset;
                bufferAvail = bufferSize - dataBlockOffset;
            } else {
                //
                // There is not enough room in the WNODE to complete
                // the query
                instanceLengthArray = NULL;
                dataBuffer = NULL;
                bufferAvail = 0;
            }

            status = WmiLibInfo->QueryWmiDataBlock(
                                             DeviceObject,
                                             Irp,
                                             guidIndex,
                                             0,
                                             instanceCount,
                                             instanceLengthArray,
                                             bufferAvail,
                                             dataBuffer);
            break;
        }

        case IRP_MN_QUERY_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;
            ULONG dataBlockOffset;
            PREGENTRY regEntry;

            wnode = (PWNODE_SINGLE_INSTANCE)buffer;

            if ((guidIndex == PnPIdGuidIndex) ||
                (guidIndex == PnPIdInstanceNamesGuidIndex))
            {
                regEntry = WmipFindRegEntryByProviderId(wnode->WnodeHeader.ProviderId,
                                                        FALSE);
                if (regEntry != NULL)
                {
                    DeviceObject = regEntry->DeviceObject;
                    WmipUnreferenceRegEntry(regEntry);          
                } else {
                    //
                    // Why couldn't we get the regentry again ??
                    WmipAssert(FALSE);
                    status = IoWMICompleteRequest(WmiLibInfo,
                                              DeviceObject,
                                              Irp,
                                              STATUS_WMI_GUID_NOT_FOUND,
                                              0,
                                              IO_NO_INCREMENT);
                    break;
                }

            }

            dataBlockOffset = wnode->DataBlockOffset;

            status = WmiLibInfo->QueryWmiDataBlock(
                                          DeviceObject,
                                          Irp,
                                          guidIndex,
                                          instanceIndex,
                                          1,
                                          &wnode->SizeDataBlock,
                                          bufferSize - dataBlockOffset,
                                          (PUCHAR)wnode + dataBlockOffset);

            break;
        }

        case IRP_MN_CHANGE_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;

            if (WmiLibInfo->SetWmiDataBlock != NULL)
            {
                wnode = (PWNODE_SINGLE_INSTANCE)buffer;

                status = WmiLibInfo->SetWmiDataBlock(
                                     DeviceObject,
                                     Irp,
                                     guidIndex,
                                     instanceIndex,
                                     wnode->SizeDataBlock,
                                     (PUCHAR)wnode + wnode->DataBlockOffset);
            } else {
                //
                // If set callback is not filled in then it must be readonly
                status = STATUS_WMI_READ_ONLY;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }


            break;
        }

        case IRP_MN_CHANGE_SINGLE_ITEM:
        {
            PWNODE_SINGLE_ITEM wnode;

            if (WmiLibInfo->SetWmiDataItem != NULL)
            {
                wnode = (PWNODE_SINGLE_ITEM)buffer;

                status = WmiLibInfo->SetWmiDataItem(
                                     DeviceObject,
                                     Irp,
                                     guidIndex,
                                     instanceIndex,
                                     wnode->ItemId,
                                     wnode->SizeDataItem,
                                     (PUCHAR)wnode + wnode->DataBlockOffset);

            } else {
                //
                // If set callback is not filled in then it must be readonly
                status = STATUS_WMI_READ_ONLY;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            break;
        }

        case IRP_MN_EXECUTE_METHOD:
        {
            PWNODE_METHOD_ITEM wnode;

            if (WmiLibInfo->ExecuteWmiMethod != NULL)
            {
                wnode = (PWNODE_METHOD_ITEM)buffer;

                status = WmiLibInfo->ExecuteWmiMethod(
                                         DeviceObject,
                                         Irp,
                                         guidIndex,
                                         instanceIndex,
                                         wnode->MethodId,
                                         wnode->SizeDataBlock,
                                         bufferSize - wnode->DataBlockOffset,
                                         buffer + wnode->DataBlockOffset);

            } else {
                //
                // If method callback is not filled in then it must be error
                status = STATUS_INVALID_DEVICE_REQUEST;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }

            break;
        }

        case IRP_MN_ENABLE_EVENTS:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                           DeviceObject,
                                                           Irp,
                                                           guidIndex,
                                                           WmiEventGeneration,
                                                           TRUE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = STATUS_SUCCESS;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            break;
        }

        case IRP_MN_DISABLE_EVENTS:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                           DeviceObject,
                                                           Irp,
                                                           guidIndex,
                                                           WmiEventGeneration,
                                                           FALSE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = STATUS_SUCCESS;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            break;
        }

        case IRP_MN_ENABLE_COLLECTION:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                         DeviceObject,
                                                         Irp,
                                                         guidIndex,
                                                         WmiDataBlockCollection,
                                                         TRUE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = STATUS_SUCCESS;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            break;
        }

        case IRP_MN_DISABLE_COLLECTION:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                         DeviceObject,
                                                         Irp,
                                                         guidIndex,
                                                         WmiDataBlockCollection,
                                                         FALSE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = STATUS_SUCCESS;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            break;
        }

        default:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    }

    return(status);
}

NTSTATUS
IoWMICompleteRequest(
    IN PWMILIB_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG BufferUsed,
    IN CCHAR PriorityBoost
    )
/*++

Routine Description:


    This routine will do the work of completing a WMI irp. Depending upon the
    the WMI request this routine will fixup the returned WNODE appropriately.

Arguments:

    WmiLibInfo has the WMI information control block

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

    Status has the return status code for the IRP

    BufferUsed has the number of bytes needed by the device to return the
       data requested in any query. In the case that the buffer passed to
       the device is too small this has the number of bytes needed for the
       return data. If the buffer passed is large enough then this has the
       number of bytes actually used by the device.

    PriorityBoost is the value used for the IoCompleteRequest call.

Return Value:

    status

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PUCHAR buffer;
    ULONG retSize;
    UCHAR minorFunction;
    ULONG bufferSize;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (WmiLibInfo);
    UNREFERENCED_PARAMETER (DeviceObject);

    minorFunction = irpStack->MinorFunction;
    buffer = (PUCHAR)irpStack->Parameters.WMI.Buffer;
    bufferSize = irpStack->Parameters.WMI.BufferSize;

    switch(minorFunction)
    {
        case IRP_MN_QUERY_ALL_DATA:
        {
            PWNODE_ALL_DATA wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;
            ULONG instanceCount;
            POFFSETINSTANCEDATAANDLENGTH offsetInstanceDataAndLength;
            ULONG i;
            PULONG instanceLengthArray;
            ULONG dataBlockOffset;

            wnode = (PWNODE_ALL_DATA)buffer;

            dataBlockOffset = wnode->DataBlockOffset;
            instanceCount = wnode->InstanceCount;
            bufferNeeded = dataBlockOffset + BufferUsed;

            if ((NT_SUCCESS(Status)) &&
                (bufferNeeded > irpStack->Parameters.WMI.BufferSize))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }

            if (! NT_SUCCESS(Status))
            {
                if (Status == STATUS_BUFFER_TOO_SMALL)
                {
                    wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                    wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                    wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                    wnodeTooSmall->SizeNeeded = bufferNeeded;

                    retSize = sizeof(WNODE_TOO_SMALL);
                    Status = STATUS_SUCCESS;
                } else {
                    retSize = 0;
                }
                break;
            }

            KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);

            instanceLengthArray = (PULONG)&wnode->OffsetInstanceDataAndLength[0];
            offsetInstanceDataAndLength = (POFFSETINSTANCEDATAANDLENGTH)instanceLengthArray;

            wnode->WnodeHeader.BufferSize = bufferNeeded;
            retSize = bufferNeeded;

            for (i = instanceCount; i != 0; i--)
            {
                offsetInstanceDataAndLength[i-1].LengthInstanceData = instanceLengthArray[i-1];
            }

            for (i = 0; i < instanceCount; i++)
            {
                offsetInstanceDataAndLength[i].OffsetInstanceData = dataBlockOffset;
                dataBlockOffset = (dataBlockOffset + offsetInstanceDataAndLength[i].LengthInstanceData + 7) & ~7;
            }

            break;
        }

        case IRP_MN_QUERY_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;

            wnode = (PWNODE_SINGLE_INSTANCE)buffer;

            bufferNeeded = wnode->DataBlockOffset + BufferUsed;

            if (NT_SUCCESS(Status))
            {
                retSize = bufferNeeded;
                wnode->WnodeHeader.BufferSize = bufferNeeded;
                KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);

                WmipAssert(wnode->SizeDataBlock <= BufferUsed);

            } else if (Status == STATUS_BUFFER_TOO_SMALL) {
                wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                wnodeTooSmall->SizeNeeded = bufferNeeded;
                retSize = sizeof(WNODE_TOO_SMALL);
                Status = STATUS_SUCCESS;
            } else {
                retSize = 0;
            }
            break;
        }

        case IRP_MN_EXECUTE_METHOD:
        {
            PWNODE_METHOD_ITEM wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;

            wnode = (PWNODE_METHOD_ITEM)buffer;

            bufferNeeded = wnode->DataBlockOffset + BufferUsed;

            if (NT_SUCCESS(Status))
            {
                retSize = bufferNeeded;
                wnode->WnodeHeader.BufferSize = bufferNeeded;
                KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
                wnode->SizeDataBlock = BufferUsed;

            } else if (Status == STATUS_BUFFER_TOO_SMALL) {
                wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                wnodeTooSmall->SizeNeeded = bufferNeeded;
                retSize = sizeof(WNODE_TOO_SMALL);
                Status = STATUS_SUCCESS;
            } else {
                retSize = 0;
            }
            break;
        }

        default:
        {
            //
            // All other requests don't return any data
            retSize = 0;
            break;
        }

    }

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = retSize;
    IoCompleteRequest(Irp, PriorityBoost);
    return(Status);
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\mcaevent.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
//
// You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//
//
#ifndef _MCA_H_
#define _MCA_H_

//
// Types of corrected errors that are tracked
//
typedef enum
{
    SingleBitEcc,
    CpuCache,
    CpuTlb,
    CpuBus,
    CpuRegFile
} MCECORRECTEDTYPE, *PMCECORRECTEDTYPE;

typedef struct
{
    LIST_ENTRY List;
    MCECORRECTEDTYPE Type;
    USHORT Counter;
    USHORT Flags;
    LARGE_INTEGER Timestamp;
    
    union
    {
        //
        // For SingleBitEcc type, indicates physical address of page
        // where error occured
        //
        PHYSICAL_ADDRESS SingleBitEccAddress;

        //
        // For Cpu* types, indicates cpu on which the error
        // occured
        //
        ULONG CpuId;
    };
} MCECORRECTEDEVENT, *PMCECORRECTEDEVENT;

typedef enum
{
    CpuStateCheckCache = 0,
    CpuStateCheckTLB = 1,
    CpuStateCheckBus = 2,
    CpuStateCheckRegFile = 3,
    CpuStateCheckMS = 4
};

extern ULONG WmipDisableMCAPopups;

//
// Configurable parameters for managing thresholds for eventlog
// suppression and recovery action for corrected MCE
//

//
// Interval within which multiple identical errors will be reported as
// a single error to the system eventlog. Can be configured under
// HKLM\System\CurrentControlSet\Control\WMI\CoalesceCorrectedErrorInterval
// A value of 0 will cause no coalesce of identical errors
//
extern ULONG WmipCoalesceCorrectedErrorInterval;

//
// Number of single bit ecc errors that can occur in the same page
// before it is attempted to map out the page. Can be configured under : 
// HKLM\System\CurrentControlSet\Control\WMI\SingleBitEccErrorThreshold
// A value of 0 will cause no attempt to map out pages
//
extern ULONG WmipSingleBitEccErrorThreshold;


//
// Maxiumum number of MCE events being tracked at one time. If there is
// more than this limit then the oldest ones are recycled. Can be
// configured under :
// HKLM\System\CurrentControlSet\Control\WMI\MaxCorrectedMCEOutstanding
// A value of 0 will disable tracking of corrected errors
//
extern ULONG WmipMaxCorrectedMCEOutstanding;

//
// List of corrected MCE that are being tracked
//
extern LIST_ENTRY WmipCorrectedMCEHead;
extern ULONG WmipCorrectedMCECount;

//
// Counter of maximum eventlog entries generated by any source. Can be
// configured under:
// HKLM\System\CurrentControlSet\Control\WMI\MaxCorrectedEventlogs
//
extern ULONG WmipCorrectedEventlogCounter;

#if defined(_X86_) || defined(_AMD64_)
NTSTATUS
WmipConstructMCAErrorEvent(
    IN PMCA_EXCEPTION McaException,
    IN ULONG ErrorLogSize,
    IN OUT PWNODE_SINGLE_INSTANCE Wnode,
    IN OUT PMSMCAEvent_Header Header,
    IN OUT PUCHAR *RawPtr,
    IN OUT BOOLEAN *IsFatal
    );
#else
NTSTATUS
WmipConstructMCAErrorEvent(
    IN PERROR_RECORD_HEADER RecordHeader,
    IN ULONG ErrorLogSize,
    IN OUT PWNODE_SINGLE_INSTANCE Wnode,
    IN OUT PMSMCAEvent_Header Header,
    IN OUT PUCHAR *RawPtr,
    IN OUT BOOLEAN *IsFatal
    );
#endif

NTSTATUS WmipFireOffWmiEvent(
    LPGUID Guid,
    ULONG DataSize,
    PVOID DataPtr            
    );

#endif // _MCA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\mca.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Mca.c

Abstract:

    Machine Check Architecture interface

--*/

#pragma warning(disable:4206)   // translation unit empty

#include "wmikmp.h"
#include <mce.h>
#include "hal.h"
#include "ntiologc.h"
#include "mcaevent.h"
#define MCA_EVENT_INSTANCE_NAME L"McaEvent"
#define MCA_UNDEFINED_CPU 0xffffffff


#if defined(_X86_) || defined(_AMD64_)
#define HalpGetFwMceLogProcessorNumber( /* PMCA_EXCEPTION */ _Log ) \
    ( (_Log)->ProcessorNumber )
typedef MCA_EXCEPTION ERROR_LOGRECORD, *PERROR_LOGRECORD;
typedef MCA_EXCEPTION ERROR_RECORD_HEADER, *PERROR_RECORD_HEADER;
#endif

BOOLEAN WmipMceEventDelivery(
    IN PVOID Reserved,
    IN KERNEL_MCE_DELIVERY_OPERATION Operation,
    IN PVOID Argument2
    );

BOOLEAN WmipMceDelivery(
    IN PVOID Reserved,
    IN KERNEL_MCE_DELIVERY_OPERATION Operation,
    IN PVOID Argument2
    );

void WmipMceWorkerRoutine(    
    IN PVOID Context             // Not Used
    );

NTSTATUS WmipGetLogFromHal(
    HAL_QUERY_INFORMATION_CLASS InfoClass,
    PVOID Token,
    PWNODE_SINGLE_INSTANCE *Wnode,
    PERROR_LOGRECORD *Mca,
    PULONG McaSize,
    ULONG MaxSize,
    LPGUID Guid
    );

NTSTATUS WmipRegisterMcaHandler(
    ULONG Phase
    );

NTSTATUS WmipBuildMcaCmcEvent(
    OUT PWNODE_SINGLE_INSTANCE Wnode,
    IN LPGUID EventGuid,
    IN PERROR_LOGRECORD McaCmcEvent,
    IN ULONG McaCmcSize
    );

NTSTATUS WmipGetRawMCAInfo(
    OUT PUCHAR Buffer,
    IN OUT PULONG BufferSize
    );

NTSTATUS WmipWriteMCAEventLogEvent(
    PUCHAR Event
    );

NTSTATUS WmipSetupWaitForWbem(
    void
    );

void WmipIsWbemRunningDispatch(    
    IN PKDPC Dpc,
    IN PVOID DeferredContext,     // Not Used
    IN PVOID SystemArgument1,     // Not Used
    IN PVOID SystemArgument2      // Not Used
    );

void WmipPollingDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,     // MCEQUERYINFO
    IN PVOID SystemArgument1,     // New polling interval
    IN PVOID SystemArgument2      // Not used
    );

void WmipIsWbemRunningWorker(
    PVOID Context
    );

BOOLEAN WmipCheckIsWbemRunning(
    void
    );

void WmipProcessPrevMcaLogs(
    void
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,WmipRegisterMcaHandler)
#pragma alloc_text(PAGE,WmipMceWorkerRoutine)
#pragma alloc_text(PAGE,WmipGetLogFromHal)
#pragma alloc_text(PAGE,WmipBuildMcaCmcEvent)
#pragma alloc_text(PAGE,WmipGetRawMCAInfo)
#pragma alloc_text(PAGE,WmipWriteMCAEventLogEvent)
#pragma alloc_text(PAGE,WmipGenerateMCAEventlog)
#pragma alloc_text(PAGE,WmipIsWbemRunningWorker)
#pragma alloc_text(PAGE,WmipCheckIsWbemRunning)
#pragma alloc_text(PAGE,WmipSetupWaitForWbem)
#pragma alloc_text(PAGE,WmipProcessPrevMcaLogs)
#endif

//
// Set to TRUE when the registry indicates that popups should be
// disabled. HKLM\System\CurrentControlSet\Control\WMI\DisableMCAPopups
//
ULONG WmipDisableMCAPopups;

GUID WmipMSMCAEvent_InvalidErrorGuid = MSMCAEvent_InvalidErrorGuid;

//
// Each type of MCE has a control structure that is used to determine
// whether to poll or wait for an interrupt to determine when to query
// for the logs.  This is needed since we can get a callback from the
// HAL at high IRQL to inform us that a MCE log is available.
// Additionally Ke Timer used for polling will calls us at DPC level.
// So in the case of an interrupt we will queue a DPC. Within the DPC
// routine we will queue a work item so that we can get back to
// passive level and be able to call the hal to get the logs (Can only
// call hal at passive). The DPC and work item routines are common so a
// MCEQUERYINFO struct is passed around so that it can operate on the
// correct log type. Note that this implies that there may be multiple
// work items querying the hal for different log types at the same
// time. In addition this struct also contains useful log related
// information including the maximum log size (as reported by the HAL),
// the token that must be passed to the HAL when querying for the
// logs and the HAL InfoClass to use when querying for the logs.
//
// PollFrequency keeps track of the number of seconds before initiating a
// query. If it is 0 (HAL_CPE_DISABLED / HAL_CMC_DISABLED) then no
// polling occurs and if it is -1 (HAL_CPE_INTERRUPTS_BASED /
// HAL_CMC_INTERRUPTS_BASED) then no polling occurs either. There is
// only one work item active for each log type and this is enforced via
// ItemsOutstanding in that only whenever it transitions from 0 to 1 is
// the work item queued.
//
#define DEFAULT_MAX_MCA_SIZE 0x1000
#define DEFAULT_MAX_CMC_SIZE 0x1000
#define DEFAULT_MAX_CPE_SIZE 0x1000

typedef struct
{
    HAL_QUERY_INFORMATION_CLASS InfoClass;  // HAL Info class to use in MCE query
    ULONG PollFrequency;                    // Polling Frequency in seconds
    PVOID Token;                            // HAL Token to use in MCE Queries
    LONG ItemsOutstanding;                  // Number of interrupts or poll requests to process
    ULONG MaxSize;                          // Max size for log (as reported by HAL)
    GUID WnodeGuid;                         // GUID to use for the raw data event
    GUID SwitchToPollGuid;                  // GUID to use to fire event for switching to polled mode
    NTSTATUS SwitchToPollErrorCode;         // Eventlog error code that indicates a switch to polled mode
    ULONG WorkerInProgress;                 // Set to 1 if worker routine is running
    KSPIN_LOCK DpcLock;
    KDPC DeliveryDpc;                       // DPC to handle delivery
    KTIMER PollingTimer;                    // KTIMER used for polling
    KDPC PollingDpc;                        // DPC to use for polling
    WORK_QUEUE_ITEM WorkItem;               // Work item used to query for log
} MCEQUERYINFO, *PMCEQUERYINFO;

MCEQUERYINFO WmipMcaQueryInfo =
{
    HalMcaLogInformation,
    HAL_MCA_INTERRUPTS_BASED,               // Corrected MCA are delivered by interrupts
    NULL,
    0,
    DEFAULT_MAX_MCA_SIZE,
    MSMCAInfo_RawMCAEventGuid
};

MCEQUERYINFO WmipCmcQueryInfo =
{
    HalCmcLogInformation,
    HAL_CMC_DISABLED,
    NULL,
    0,
    DEFAULT_MAX_CMC_SIZE,
    MSMCAInfo_RawCMCEventGuid,
    MSMCAEvent_SwitchToCMCPollingGuid,
    MCA_WARNING_CMC_THRESHOLD_EXCEEDED,
    0
};
                               
MCEQUERYINFO WmipCpeQueryInfo =
{
    HalCpeLogInformation,
    HAL_CPE_DISABLED,
    NULL,
    0,
    DEFAULT_MAX_CPE_SIZE,
    MSMCAInfo_RawCorrectedPlatformEventGuid,
    MSMCAEvent_SwitchToCPEPollingGuid,
    MCA_WARNING_CPE_THRESHOLD_EXCEEDED,
    0
};

//
// Used for waiting until WBEM is ready to receive events
//
KTIMER WmipIsWbemRunningTimer;
KDPC WmipIsWbemRunningDpc;
WORK_QUEUE_ITEM WmipIsWbemRunningWorkItem;
LIST_ENTRY WmipWaitingMCAEvents = {&WmipWaitingMCAEvents, &WmipWaitingMCAEvents};

#define WBEM_STATUS_UNKNOWN 0   // Polling process for waiting is not started
#define WBEM_IS_RUNNING 1       // WBEM is currently running
#define WAITING_FOR_WBEM  2     // Polling process for waiting is started
UCHAR WmipIsWbemRunningFlag;


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

//
// MCA information obtained at boot and holds the MCA that caused the
// system to bugcheck on the previous boot
//
ULONG WmipRawMCASize;
PMSMCAInfo_RawMCAData WmipRawMCA;

//
// Status of the MCE registration process
//
#define MCE_STATE_UNINIT     0
#define MCE_STATE_REGISTERED 1
#define MCE_STATE_RUNNING    2
#define MCE_STATE_ERROR      -1
ULONG WmipMCEState;

//
// Configurable parameters for managing thresholds for eventlog
// suppression and recovery action for corrected MCE
//

//
// Interval within which multiple identical errors will be reported as
// a single error to the system eventlog. Can be configured under
// HKLM\System\CurrentControlSet\Control\WMI\CoalesceCorrectedErrorInterval
// A value of 0 will cause no coalesce of identical errors
//
ULONG WmipCoalesceCorrectedErrorInterval = 5000;

//
// Number of single bit ecc errors that can occur in the same page
// before it is attempted to map out the page. Can be configured under : 
// HKLM\System\CurrentControlSet\Control\WMI\SingleBitEccErrorThreshold
// A value of 0 will cause no attempt to map out pages
//
ULONG WmipSingleBitEccErrorThreshold = 6;

//
// Maxiumum number of MCE events being tracked at one time. If there is
// more than this limit then the oldest ones are recycled. Can be
// configured under :
// HKLM\System\CurrentControlSet\Control\WMI\MaxCorrectedMCEOutstanding
// A value of 0 will disable tracking of corrected errors
//
ULONG WmipMaxCorrectedMCEOutstanding = 5;

//
// List of corrected MCE that are being tracked
//
LIST_ENTRY WmipCorrectedMCEHead = {&WmipCorrectedMCEHead, &WmipCorrectedMCEHead};
ULONG WmipCorrectedMCECount;

//
// Counter of maximum eventlog entries generated by any source. Can be
// configured under:
// HKLM\System\CurrentControlSet\Control\WMI\MaxCorrectedEventlogs
//
ULONG WmipCorrectedEventlogCounter = 20;

//
// Check if WBEM is already running and if not check if we've already
// kicked off the timer that will wait for wbem to start
//
#define WmipIsWbemRunning() ((WmipIsWbemRunningFlag == WBEM_IS_RUNNING) ? \
                                                       TRUE : \
                                                       FALSE)
void WmipInsertQueueMCEDpc(
    PMCEQUERYINFO QueryInfo
    );



NTSTATUS WmipWriteToEventlog(
    NTSTATUS ErrorCode,
    NTSTATUS FinalStatus
    )
{
    PIO_ERROR_LOG_PACKET ErrLog;
    NTSTATUS Status;

    ErrLog = IoAllocateErrorLogEntry(WmipServiceDeviceObject,
                                     sizeof(IO_ERROR_LOG_PACKET));

    if (ErrLog != NULL) {

        //
        // Fill it in and write it out as a single string.
        //
        ErrLog->ErrorCode = ErrorCode;
        ErrLog->FinalStatus = FinalStatus;

        ErrLog->StringOffset = 0;
        ErrLog->NumberOfStrings = 0;

        IoWriteErrorLogEntry(ErrLog);
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return(Status);
}

NTSTATUS WmipFireOffWmiEvent(
    LPGUID Guid,
    ULONG DataSize,
    PVOID DataPtr            
    )
{
    PVOID Ptr;
    PWNODE_SINGLE_INSTANCE Wnode;
    PWCHAR Wptr;
    ULONG RoundedDataSize;
    NTSTATUS Status;

    RoundedDataSize = (DataSize + 1) & ~1;
    
    Wnode = ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(WNODE_SINGLE_INSTANCE) +
                                       RoundedDataSize +
                                      sizeof(USHORT) +
                                       sizeof(MCA_EVENT_INSTANCE_NAME),
                                  WmipMCAPoolTag);

    if (Wnode != NULL)
    {
        Wnode->WnodeHeader.BufferSize = sizeof(WNODE_SINGLE_INSTANCE) +
                                       sizeof(USHORT) +
                                        RoundedDataSize +
                                       sizeof(MCA_EVENT_INSTANCE_NAME);
        Wnode->WnodeHeader.Guid = *Guid;

        Wnode->WnodeHeader.Flags = WNODE_FLAG_SINGLE_INSTANCE |
                                   WNODE_FLAG_EVENT_ITEM;
        KeQuerySystemTime(&Wnode->WnodeHeader.TimeStamp);

        Wnode->DataBlockOffset = sizeof(WNODE_SINGLE_INSTANCE);
        Wnode->SizeDataBlock = DataSize;
        if (DataPtr != NULL)
        {
            Ptr = OffsetToPtr(Wnode, Wnode->DataBlockOffset);
            memcpy(Ptr, DataPtr, DataSize);
        }
        Wnode->OffsetInstanceName = sizeof(WNODE_SINGLE_INSTANCE) + RoundedDataSize;

        Wptr = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
        *Wptr++ = sizeof(MCA_EVENT_INSTANCE_NAME);
        RtlCopyMemory(Wptr,
                      MCA_EVENT_INSTANCE_NAME,
                      sizeof(MCA_EVENT_INSTANCE_NAME));

        Status = IoWMIWriteEvent(Wnode);
        if (! NT_SUCCESS(Status))
        {
            ExFreePool(Wnode);
        }
    }
    else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(Status);
}

NTSTATUS WmipBuildMcaCmcEvent(
    OUT PWNODE_SINGLE_INSTANCE Wnode,
    IN LPGUID EventGuid,
    IN PERROR_LOGRECORD McaCmcEvent,
    IN ULONG McaCmcSize
    )
/*++

Routine Description:


    This routine will take a MCA or CMC log and build a
    WNODE_EVENT_ITEM for it.

    This routine may be called at DPC

Arguments:

    Wnode is the wnode buffer in which to build the event

    EventGuid is the guid to use in the event wnode

    McaCmcEvent is the MCA, CMC or CPE data payload to put into the
            event

    McaCmcSize is the size of the event data


Return Value:

    NT status code

--*/
{
    PMSMCAInfo_RawCMCEvent Ptr;
    ULONG Size;

    PAGED_CODE();

    Size = McaCmcSize + FIELD_OFFSET(MSMCAInfo_RawCMCEvent,
                                                     Records) +
                                        FIELD_OFFSET(MSMCAInfo_Entry, Data);
    
    RtlZeroMemory(Wnode, sizeof(WNODE_SINGLE_INSTANCE));
    Wnode->WnodeHeader.BufferSize = Size + sizeof(WNODE_SINGLE_INSTANCE);
    Wnode->WnodeHeader.ProviderId = IoWMIDeviceObjectToProviderId(WmipServiceDeviceObject);
    KeQuerySystemTime(&Wnode->WnodeHeader.TimeStamp);       
    Wnode->WnodeHeader.Guid = *EventGuid;
    Wnode->WnodeHeader.Flags = WNODE_FLAG_SINGLE_INSTANCE |
                               WNODE_FLAG_EVENT_ITEM |
                               WNODE_FLAG_STATIC_INSTANCE_NAMES;
    Wnode->DataBlockOffset = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                          VariableData);
    Wnode->SizeDataBlock = Size;
    Ptr = (PMSMCAInfo_RawCMCEvent)&Wnode->VariableData;
    Ptr->Count = 1;                           // 1 Record in this event
    Ptr->Records[0].Length = McaCmcSize;       // Size of log record in bytes
    if (McaCmcEvent != NULL)
    {
        RtlCopyMemory(Ptr->Records[0].Data, McaCmcEvent, McaCmcSize);
    }
    
    return(STATUS_SUCCESS);
}

NTSTATUS WmipQueryLogAndFireEvent(
    PMCEQUERYINFO QueryInfo
    )
/*++

Routine Description:

    Utility routine that will query the hal for a log and then if one
    is returned successfully then will fire the appropriate WMI events 

Arguments:

    QueryInfo is a pointer to the MCEQUERYINFO for the type of log that
    needs to be queried.

Return Value:

--*/
{
    PWNODE_SINGLE_INSTANCE Wnode;
    NTSTATUS Status, Status2;
    ULONG Size;
    PERROR_LOGRECORD Log;   

    PAGED_CODE();

    //
    // Call HAL to get the log
    //
    Status = WmipGetLogFromHal(QueryInfo->InfoClass,
                               QueryInfo->Token,
                               &Wnode,
                               &Log,
                               &Size,
                               QueryInfo->MaxSize,
                               &QueryInfo->WnodeGuid);

    if (NT_SUCCESS(Status))
    {
        //
        // Look at the event and fire it off as WMI events that
        // will generate eventlog events
        //
        WmipGenerateMCAEventlog((PUCHAR)Log,
                                Size,
                                FALSE);

        //
        // Fire the log off as a WMI event
        //
        Status2 = IoWMIWriteEvent(Wnode);
        if (! NT_SUCCESS(Status2))
        {
            //
            // IoWMIWriteEvent will free the wnode back to pool,
            // but not if it fails
            //
            ExFreePool(Wnode);
        }
        
        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                          DPFLTR_MCA_LEVEL,
                          "WMI: MCE Event fired to WMI -> %x\n",
                          Status));
        
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                          DPFLTR_MCA_LEVEL,
                          "WMI: MCE Event for %p not available %x\n",
                          QueryInfo, Status));
    }
    return(Status);
}

void WmipMceWorkerRoutine(    
    IN PVOID Context             // MCEQUERYINFO
    )
/*++

Routine Description:

    Worker routine that handles polling for corrected MCA, CMC and CPE
    logs from the HAL and then firing them as WMI events.

Arguments:

    Context is a pointer to the MCEQUERYINFO for the type of log that
    needs to be queried.

Return Value:

--*/
{
    PMCEQUERYINFO QueryInfo = (PMCEQUERYINFO)Context;
    NTSTATUS Status;
    ULONG i;
    LONG x, Count;

    PAGED_CODE();

    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                      "WMI: WmipMceWorkerRoutine %p enter\n",
                     QueryInfo));

    //
    // If the worker is already in progress then we just exit
    //
    WmipEnterSMCritSection();
    if (QueryInfo->WorkerInProgress == 0)
    {
        QueryInfo->WorkerInProgress = 1;
        WmipLeaveSMCritSection();
    } else {
        WmipLeaveSMCritSection();
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                          "WMI: WmipMceWorkerRoutine %p in progress\n",
                         QueryInfo));
        return;
    }

    //
    // Check to see if access has already been disabled
    //
    if (QueryInfo->PollFrequency != HAL_MCE_DISABLED)
    {
        //
        // We get all of the records by calling into the hal and querying
        // for the logs until the hal returns an error or we've
        // retrieved 256 records. We want to protect ourselves from the
        // case where a repeated corrected error would cause the loop
        // to be infinite.
        //
        i = 0;
        do
        {
            //
            // Remember how many corrected errors we have received up until
            // this point. We guarantee that we've handled them up
            // until this point
            //
            Count = QueryInfo->ItemsOutstanding;

            Status = WmipQueryLogAndFireEvent(QueryInfo);           
        } while ((NT_SUCCESS(Status) && (i++ < 256)));

        //
        // Reset counter back to 0, but check if any errors
        // had occured while we were processing. If so we go
        // back and make sure they are handled. Note that this
        // could cause a new worker thread to be created while we
        // are still processing these, but that is ok since we only
        // allow one worker thread to run at one time.
        //
        WmipEnterSMCritSection();
        x = InterlockedExchange(&QueryInfo->ItemsOutstanding,
                                0);
        if ((x > Count) && (i < 257))
        {
            //
            // Since there are still more corrected errors to
            // process, queue a new DPC to cause a new worker
            // routine to be run.
            //
            WmipInsertQueueMCEDpc(QueryInfo);
        }

        QueryInfo->WorkerInProgress = 0;
        WmipLeaveSMCritSection();
    }
}

void WmipMceDispatchRoutine(
    PMCEQUERYINFO QueryInfo
    )
{

    ULONG x;

    //
    // Increment the number of items that are outstanding for this info
    // class. If the number of items outstanding transitions from 0 to
    // 1 then this implies that a work item for this info class needs
    // to be queued
    //
    x = InterlockedIncrement(&QueryInfo->ItemsOutstanding);

    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                      "WMI: WmipMceDispatchRoutine %p transition to %d\n",
                     QueryInfo,
                     x));

    if (x == 1)
    {
        ExQueueWorkItem(&QueryInfo->WorkItem,
                        DelayedWorkQueue);
    }
}

void WmipMceDpcRoutine(    
    IN PKDPC Dpc,
    IN PVOID DeferredContext,     // Not Used
    IN PVOID SystemArgument1,     // MCEQUERYINFO
    IN PVOID SystemArgument2      // Not used
    )
{
    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (DeferredContext);
    UNREFERENCED_PARAMETER (SystemArgument2);

    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                      "WMI: WmipMceDpcRoutine %p Enter\n",
                     SystemArgument1));
    
    WmipMceDispatchRoutine((PMCEQUERYINFO)SystemArgument1);
}


void WmipPollingDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,     // MCEQUERYINFO
    IN PVOID SystemArgument1,     // New polling Interval
    IN PVOID SystemArgument2      // Not used
    )
{
    PMCEQUERYINFO QueryInfo = (PMCEQUERYINFO)DeferredContext;
    LARGE_INTEGER li;
    ULONG PollingInterval = PtrToUlong(SystemArgument1);

    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (SystemArgument2);

    if (QueryInfo->PollFrequency == HAL_MCE_INTERRUPTS_BASED)
    {
        //
        // HAL has instructed us to switch into polled mode and has
        // informed us of the new polling interval.
        //

        QueryInfo->PollFrequency = PollingInterval;

        li.QuadPart = -1 * (QueryInfo->PollFrequency * 1000000000);
        KeSetTimerEx(&QueryInfo->PollingTimer,
                     li,
                     QueryInfo->PollFrequency * 1000,
                     &QueryInfo->PollingDpc);

        //
        // Make a note in the eventlog that this has occured. 
        //
        WmipWriteToEventlog(QueryInfo->SwitchToPollErrorCode,
                            STATUS_SUCCESS
                           );
        
        //
        // Inform any WMI consumers that the switch has occured
        //
        WmipFireOffWmiEvent(&QueryInfo->SwitchToPollGuid,
                           0,
                           NULL);
    } else {
        //
        // Our timer fired so we need to poll
        //
        WmipMceDispatchRoutine(QueryInfo);
    }
}

BOOLEAN WmipMceDelivery(
    IN PVOID Reserved,
    IN KERNEL_MCE_DELIVERY_OPERATION Operation,
    IN PVOID Argument2
    )
/*++

Routine Description:


    This routine is called by the HAL when a CMC or CPE occurs. It is called
    at high irql

Arguments:

    Operation is the operation that the HAL is instructing us to do

    Reserved is the CMC token

    Parameter for operation specified.
        For CmcSwitchToPolledMode and CpeSwitchToPolledMode, Parameter
        specifies the number of seconds to between polling.


Return Value:

    TRUE to indicate that we handled the delivery

--*/
{
    PMCEQUERYINFO QueryInfo;
    BOOLEAN ret;
    
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                      "WMI: MceDelivery Operation %d(%p)\n",
                     Operation, Argument2));

    //
    // First figure out which type of MCE we are dealing with
    //
    switch (Operation)
    {
        case CmcAvailable:
        case CmcSwitchToPolledMode:
        {
            QueryInfo = &WmipCmcQueryInfo;
            break;
        }
        
        case CpeAvailable:
        case CpeSwitchToPolledMode:
        {
            QueryInfo = &WmipCpeQueryInfo;
            break;
        }

        case McaAvailable:
        {
            QueryInfo = &WmipMcaQueryInfo;
            break;
        }
        
        default:
        {
            WmipAssert(FALSE);
            return(FALSE);
        }
    }


    //
    // Next determine what action to perform
    //
    switch (Operation)
    {
        case CmcAvailable:
        case CpeAvailable:
        case McaAvailable:
        {
            //
            // Store the HAL token which is needed to retrieve the logs from
            // the hal
            //
            QueryInfo->Token = Reserved;

            //
            // If we are ready to handle the logs and we are dealing with thse
            // logs  on an interrupt basis, then go ahead and queue a DPC to handle
            // processing the log
            //
            if ((WmipMCEState == MCE_STATE_RUNNING) &&
                (QueryInfo->PollFrequency == HAL_MCE_INTERRUPTS_BASED))

            {
                KeAcquireSpinLockAtDpcLevel(&QueryInfo->DpcLock);
                KeInsertQueueDpc(&QueryInfo->DeliveryDpc,
                                 QueryInfo,
                                 NULL);
                KeReleaseSpinLockFromDpcLevel(&QueryInfo->DpcLock);
                ret = TRUE;
            } else {
                ret = FALSE;
            }
            break;
        }

        case CmcSwitchToPolledMode:
        case CpeSwitchToPolledMode:
        {
            KeInsertQueueDpc(&QueryInfo->PollingDpc,
                             Argument2,
                             NULL);
            ret = TRUE;
            break;
        }
        default:
        {
            ret = FALSE;
            break;
        }
    }

    return(ret);
}

BOOLEAN WmipMceEventDelivery(
    IN PVOID Reserved,
    IN KERNEL_MCE_DELIVERY_OPERATION Operation,
    IN PVOID Argument2
    )
/*++

Routine Description:


    This routine is called by the HAL when a situation occurs between
    the HAL and SAL interface. It is called at high irql

Arguments:

    Reserved has the Operation and EventType

    Argument2 has the SAL return code

Return Value:


--*/
{
    USHORT MceOperation;
    LONGLONG SalStatus;
    ULONG MceType;
    PMCEQUERYINFO QueryInfo;
    
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                      "WMI: MCEDelivery %p %d %p\n",
                      Reserved,
                      Operation,
                      Argument2
                     ));

    MceOperation = KERNEL_MCE_OPERATION(Reserved);
    MceType = KERNEL_MCE_EVENTTYPE(Reserved);
    SalStatus = (LONGLONG)Argument2;

    //
    // If the hal is notifying us that a GetStateInfo failed with
    // SalStatus == -15 then we need to retry our query later
    //
    if ((MceOperation == KERNEL_MCE_OPERATION_GET_STATE_INFO) &&
        (Operation == MceNotification) &&
        (SalStatus == (LONGLONG)-15))
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                          "WMI: Sal is asking us to retry getstateinfo for type %x\n",
                          MceType));

        switch(MceType)
        {
            case KERNEL_MCE_EVENTTYPE_CMC:
            {
                QueryInfo = &WmipCmcQueryInfo;              
                break;
            }

            case KERNEL_MCE_EVENTTYPE_CPE:
            {
                QueryInfo = &WmipCpeQueryInfo;
                break;
            }

            default:
            {
                QueryInfo = NULL;
            }
        }

        if (QueryInfo != NULL)
        {
            //
            // If CMC or CPE are interrupt based then queue up a new
            // DPC for performing the query. If polling based then
            // there are no worries, we just wait for the next polling
            // interval.
            //
            if ((WmipMCEState == MCE_STATE_RUNNING) &&
                (QueryInfo->PollFrequency == HAL_MCE_INTERRUPTS_BASED))

            {
                KeAcquireSpinLockAtDpcLevel(&QueryInfo->DpcLock);
                KeInsertQueueDpc(&QueryInfo->DeliveryDpc,
                                 QueryInfo,
                                 NULL);
                KeReleaseSpinLockFromDpcLevel(&QueryInfo->DpcLock);
            }
        }
        
    }
    
    return(FALSE);
    
}

void WmipProcessPrevMcaLogs(
    void
    )
/*++

Routine Description:

    This routine will flush out any of the previous MCA logs and then
    hang onto them for WMI to report.


Arguments:


Return Value:


--*/
{
    NTSTATUS status;
    PERROR_LOGRECORD log;
    PMSMCAInfo_RawMCAEvent event;
    ULONG size;
    PWNODE_SINGLE_INSTANCE wnode;
    LIST_ENTRY list;
    ULONG prevLogCount;
    PMSMCAInfo_Entry record;
    ULONG sizeNeeded;
    
    PAGED_CODE();

    InitializeListHead(&list);
    
    sizeNeeded = sizeof(ULONG);      // Need space for count of records
    prevLogCount = 0;
    do
    {
        //
        // Read a MCA log out of the HAL
        //
        status = WmipGetLogFromHal(HalMcaLogInformation,
                                   WmipMcaQueryInfo.Token,
                                   &wnode,
                                   &log,
                                   &size,
                                   WmipMcaQueryInfo.MaxSize,
                                   &WmipMcaQueryInfo.WnodeGuid);

        if (NT_SUCCESS(status))
        {
            //
            // Previous logs have a ErrorSeverity of Fatal since they
            // were fatal and brought down the system in last boot.
            // keep track of how much memory we will need           
            //
            prevLogCount++;
                                   // Need space for record length and
                                   // record padded to DWORD                                   
            sizeNeeded += sizeof(ULONG) + ((size +3)&~3);
            
            InsertTailList(&list, (PLIST_ENTRY)wnode);

            WmipGenerateMCAEventlog((PUCHAR)log,
                                    size,
                                    TRUE);                
        }
        
    } while (NT_SUCCESS(status));

    if (! IsListEmpty(&list))
    {
        //
        // We have collected a set of previous logs, so we need to
        // build the buffer containing the aggregation of those logs.
        // The buffer will correspond to the entire MOF structure for
        // the MSMCAInfo_RawMCAData class
        //
        WmipRawMCA = (PMSMCAInfo_RawMCAData)ExAllocatePoolWithTag(PagedPool,
                                                                  sizeNeeded,
                                                                  WmipMCAPoolTag);


        //
        // Fill in the count of logs that follow
        //
        if (WmipRawMCA != NULL)
        {
            WmipRawMCA->Count = prevLogCount;
        }

        //
        // Loop over all previous logs
        //
        WmipRawMCASize = sizeNeeded;
        record = &WmipRawMCA->Records[0];
        
        while (! IsListEmpty(&list))
        {           
            wnode = (PWNODE_SINGLE_INSTANCE)RemoveHeadList(&list);
            if (WmipRawMCA != NULL)
            {
                //
                // Get the log back from within the wnode
                //
                event = (PMSMCAInfo_RawMCAEvent)OffsetToPtr(wnode, wnode->DataBlockOffset);

                //
                // Copy the log data into our buffer. Note that we
                // assume there will only be 1 record within the event
                //
                size = event->Records[0].Length;
                record->Length = size;
                
                RtlCopyMemory(&record->Data[0], &event->Records[0].Data[0], size);
                
                size = FIELD_OFFSET(MSMCAInfo_Entry, Data) + (size +3)&~3;
                
                record = (PMSMCAInfo_Entry)((PUCHAR)record + size);
            }

            ExFreePool(wnode);
        }
    }
}

void WmipInsertQueueMCEDpc(
    PMCEQUERYINFO QueryInfo
    )
{
    KIRQL OldIrql;

    KeAcquireSpinLock(&QueryInfo->DpcLock,
                      &OldIrql);
    KeInsertQueueDpc(&QueryInfo->DeliveryDpc,
                     QueryInfo,
                     NULL);
    KeReleaseSpinLock(&QueryInfo->DpcLock,
                      OldIrql);
}

NTSTATUS WmipRegisterMcaHandler(
    ULONG Phase
    )
/*++

Routine Description:


    This routine will register a kernel MCA and CMC handler with the
    hal

Arguments:


Return Value:

    NT status code

--*/
{
    KERNEL_ERROR_HANDLER_INFO KernelMcaHandlerInfo;
    NTSTATUS Status;
    HAL_ERROR_INFO HalErrorInfo;
    ULONG ReturnSize;
    LARGE_INTEGER li;

    PAGED_CODE();

    if (Phase == 0)
    {
        //
        // Phase 0 initialization is done before device drivers are
        // loaded so that the kernel can register its kernel error
        // handler before any driver gets a chance to do so.
        //


        //
        // Validate registry values
        //
        if (WmipCorrectedEventlogCounter == 0)
        {
            //
            // set corrected eventlog counter to -1 to indicate that no
            // eventlog suppression should occur
            //
            WmipCorrectedEventlogCounter = 0xffffffff;
        }
        
        //
        // Get the size of the logs and any polling/interrupt policies
        //
        HalErrorInfo.Version = HAL_ERROR_INFO_VERSION;

        Status = HalQuerySystemInformation(HalErrorInformation,
                                           sizeof(HAL_ERROR_INFO),
                                           &HalErrorInfo,
                                           &ReturnSize);

        if ((NT_SUCCESS(Status)) &&
            (ReturnSize >= sizeof(HAL_ERROR_INFO)))
        {
            //
            // Initialize MCA QueryInfo structure
            //
            if (HalErrorInfo.McaMaxSize != 0)
            {
                WmipMcaQueryInfo.MaxSize = HalErrorInfo.McaMaxSize;
            }

            
            WmipMcaQueryInfo.Token = (PVOID)(ULONG_PTR) HalErrorInfo.McaKernelToken;

            //
            // Initialize DPC and Workitem for processing
            //
            KeInitializeDpc(&WmipMcaQueryInfo.DeliveryDpc,
                            WmipMceDpcRoutine,
                            NULL);

            KeInitializeDpc(&WmipMcaQueryInfo.PollingDpc,
                            WmipPollingDpcRoutine,
                            &WmipMcaQueryInfo);

            ExInitializeWorkItem(&WmipMcaQueryInfo.WorkItem,
                                 WmipMceWorkerRoutine,
                                 &WmipMcaQueryInfo);


            //
            // Initialize CMC QueryInfo structure
            //          
            if (HalErrorInfo.CmcMaxSize != 0)
            {
                WmipCmcQueryInfo.MaxSize = HalErrorInfo.CmcMaxSize;
            }
           
            WmipCmcQueryInfo.PollFrequency = HalErrorInfo.CmcPollingInterval;
            
            WmipCmcQueryInfo.Token = (PVOID)(ULONG_PTR) HalErrorInfo.CmcKernelToken;

            //
            // Initialize DPC and Workitem for processing
            //
            KeInitializeSpinLock(&WmipCmcQueryInfo.DpcLock);
            KeInitializeDpc(&WmipCmcQueryInfo.DeliveryDpc,
                            WmipMceDpcRoutine,
                            NULL);

            KeInitializeDpc(&WmipCmcQueryInfo.PollingDpc,
                            WmipPollingDpcRoutine,
                            &WmipCmcQueryInfo);

            ExInitializeWorkItem(&WmipCmcQueryInfo.WorkItem,
                                 WmipMceWorkerRoutine,
                                 &WmipCmcQueryInfo);

            KeInitializeTimerEx(&WmipCmcQueryInfo.PollingTimer,
                                NotificationTimer);

            //
            // Initialize CPE QueryInfo structure
            //          
            if (HalErrorInfo.CpeMaxSize != 0)
            {
                WmipCpeQueryInfo.MaxSize = HalErrorInfo.CpeMaxSize;
            }

            WmipCpeQueryInfo.PollFrequency = HalErrorInfo.CpePollingInterval;
            
            WmipCpeQueryInfo.Token = (PVOID)(ULONG_PTR) HalErrorInfo.CpeKernelToken;

            //
            // Initialize DPC and Workitem for processing
            //
            KeInitializeSpinLock(&WmipCpeQueryInfo.DpcLock);
            KeInitializeDpc(&WmipCpeQueryInfo.DeliveryDpc,
                            WmipMceDpcRoutine,
                            NULL);

            KeInitializeDpc(&WmipCpeQueryInfo.PollingDpc,
                            WmipPollingDpcRoutine,
                            &WmipCpeQueryInfo);

            ExInitializeWorkItem(&WmipCpeQueryInfo.WorkItem,
                                 WmipMceWorkerRoutine,
                                 &WmipCpeQueryInfo);
            
            KeInitializeTimerEx(&WmipCpeQueryInfo.PollingTimer,
                                NotificationTimer);

            //
            // Register our CMC and MCA callbacks. And if interrupt driven CPE
            // callbacks are enabled register them too
            //
            KernelMcaHandlerInfo.Version = KERNEL_ERROR_HANDLER_VERSION;
            KernelMcaHandlerInfo.KernelMcaDelivery = WmipMceDelivery;
            KernelMcaHandlerInfo.KernelCmcDelivery = WmipMceDelivery;
            KernelMcaHandlerInfo.KernelCpeDelivery = WmipMceDelivery;
            KernelMcaHandlerInfo.KernelMceDelivery = WmipMceEventDelivery;

            Status = HalSetSystemInformation(HalKernelErrorHandler,
                                             sizeof(KERNEL_ERROR_HANDLER_INFO),
                                             &KernelMcaHandlerInfo);

            if (NT_SUCCESS(Status))
            {
                WmipMCEState = MCE_STATE_REGISTERED;
            } else {
                WmipMCEState = (ULONG) MCE_STATE_ERROR;
                WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                  DPFLTR_MCA_LEVEL | DPFLTR_ERROR_LEVEL,
                                  "WMI: Error %x registering MCA error handlers\n",
                                  Status));
            }
        }

    } else if (WmipMCEState != MCE_STATE_ERROR) {
        //
        // Phase 1 initialization is done after all of the boot drivers
        // have loaded and have had a chance to register for WMI event
        // notifications. At this point it is safe to go ahead and send
        // wmi events for MCA, CMC, CPE, etc

        //
        // If there were any MCA logs generated prior to boot then get
        // them out of the HAL and process them. Do this before
        // starting any polling since the SAL likes to have the
        // previous MCA records removed before being polled for CPE and
        // CMC
        //


        HalErrorInfo.Version = HAL_ERROR_INFO_VERSION;

        Status = HalQuerySystemInformation(HalErrorInformation,
                                           sizeof(HAL_ERROR_INFO),
                                           &HalErrorInfo,
                                           &ReturnSize);

        if ((NT_SUCCESS(Status)) &&
            (ReturnSize >= sizeof(HAL_ERROR_INFO)))
        {
            if (HalErrorInfo.McaPreviousEventsCount != 0)
            {
                //
                // We need to flush out any previous MCA logs and then
                // make them available via WMI
                //
                WmipProcessPrevMcaLogs();                
            }           
        }        

        //
        // Establish polling timer for CMC, if needed
        //
        if ((WmipCmcQueryInfo.PollFrequency != HAL_CMC_DISABLED) &&
            (WmipCmcQueryInfo.PollFrequency != HAL_CMC_INTERRUPTS_BASED))
        {
            li.QuadPart = -1 * (WmipCmcQueryInfo.PollFrequency * 1000000000);
            KeSetTimerEx(&WmipCmcQueryInfo.PollingTimer,
                         li,
                         WmipCmcQueryInfo.PollFrequency * 1000,
                         &WmipCmcQueryInfo.PollingDpc);
        } else if (WmipCmcQueryInfo.PollFrequency == HAL_CMC_INTERRUPTS_BASED) {
            //
            // CMC is interrupt based so we need to kick off an attempt
            // to read any CMC that had previously occured
            //
            WmipInsertQueueMCEDpc(&WmipCmcQueryInfo);
        }

        //
        // Establish polling timer for Cpe, if needed
        //
        if ((WmipCpeQueryInfo.PollFrequency != HAL_CPE_DISABLED) &&
            (WmipCpeQueryInfo.PollFrequency != HAL_CPE_INTERRUPTS_BASED))
        {
            li.QuadPart = -1 * (WmipCpeQueryInfo.PollFrequency * 1000000000);
            KeSetTimerEx(&WmipCpeQueryInfo.PollingTimer,
                         li,
                         WmipCpeQueryInfo.PollFrequency * 1000,
                         &WmipCpeQueryInfo.PollingDpc);
        } else if (WmipCpeQueryInfo.PollFrequency == HAL_CPE_INTERRUPTS_BASED) {
            //
            // Cpe is interrupt based so we need to kick off an attempt
            // to read any Cpe that had previously occured
            //
            WmipInsertQueueMCEDpc(&WmipCpeQueryInfo);
        }

        //
        // Flag that we are now able to start firing events
        //
        WmipMCEState = MCE_STATE_RUNNING;
        
        Status = STATUS_SUCCESS;
    }
    else {
        Status = STATUS_UNSUCCESSFUL;
    }
    
    return(Status);
}

NTSTATUS WmipGetRawMCAInfo(
    OUT PUCHAR Buffer,
    IN OUT PULONG BufferSize
    )
/*++

Routine Description:

    Return raw MCA log that was already retrieved from hal

Arguments:


Return Value:

    NT status code

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    if (WmipRawMCA != NULL)
    {
        //
        // THere are logs so copy over all of the logs
        //
        if (*BufferSize >= WmipRawMCASize)
        {
            RtlCopyMemory(Buffer, WmipRawMCA, WmipRawMCASize);
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        *BufferSize = WmipRawMCASize;
    } else {
        //
        // There are no logs so return no records
        //
        if (*BufferSize >= sizeof(ULONG))
        {
            *(PULONG)Buffer = 0;
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        *BufferSize = sizeof(ULONG);        
    }
    
    return(status);
}


NTSTATUS WmipGetLogFromHal(
    IN HAL_QUERY_INFORMATION_CLASS InfoClass,
    IN PVOID Token,                        
    IN OUT PWNODE_SINGLE_INSTANCE *Wnode,
    OUT PERROR_LOGRECORD *Mca,
    OUT PULONG McaSize,
    IN ULONG MaxSize,
    IN LPGUID Guid                         
    )
/*++

Routine Description:

    This routine will call the HAL to get a log and possibly build a
    wnode event for it.

Arguments:

    InfoClass is the HalInformationClass that specifies the log
        information to retrieve

    Token is the HAL token for the log type

    *Wnode returns a pointer to a WNODE_EVENT_ITEM containing the log
        information if Wnode is not NULL

    *Mca returns a pointer to the log read from the hal. It may point
        into the memory pointed to by *Wnode

    *McaSize returns with the size of the log information.

    MaxSize has the maximum size to allocate for the log data

    Guid points to the guid to use if a Wnode is built

Return Value:

    NT status code

--*/
{
    NTSTATUS Status;
    PERROR_LOGRECORD Log;
    PWNODE_SINGLE_INSTANCE WnodeSI;
    PULONG Ptr;
    ULONG Size, LogSize, WnodeSize;

    PAGED_CODE();

    //
    // If we are reading directly into a wnode then set this up
    //
    if (Wnode != NULL)
    {
        WnodeSize = FIELD_OFFSET(WNODE_SINGLE_INSTANCE, VariableData) +
                    2 * sizeof(ULONG);
    } else {
        WnodeSize = 0;
    }

    //
    // Allocate a buffer to store the log reported from the hal. Note
    // that this must be in non paged pool as per the HAL.
    //
    Size = MaxSize + WnodeSize;
                                    
    Ptr = ExAllocatePoolWithTag(NonPagedPool,
                                Size,
                                WmipMCAPoolTag);
    if (Ptr != NULL)
    {
        Log = (PERROR_LOGRECORD)((PUCHAR)Ptr + WnodeSize);
        LogSize = Size - WnodeSize;

        *(PVOID *)Log = Token;
        
        Status = HalQuerySystemInformation(InfoClass,
                                           LogSize,
                                           Log,
                                           &LogSize);

        if (Status == STATUS_BUFFER_TOO_SMALL)
        {
            //
            // If our buffer was too small then the Hal lied to us when
            // it told us the maximum buffer size. This is ok as we'll
            // handle this situation by reallocating and trying again
            //
            ExFreePool(Log);

            //
            // Reallocate the buffer and call the hal to get the log
            //
            Size = LogSize + WnodeSize;
            Ptr = ExAllocatePoolWithTag(NonPagedPool,
                                        Size,
                                        WmipMCAPoolTag);
            if (Ptr != NULL)
            {
                Log = (PERROR_LOGRECORD)((PUCHAR)Ptr + WnodeSize);
                LogSize = Size - WnodeSize;

                *(PVOID *)Log = Token;
                Status = HalQuerySystemInformation(InfoClass,
                                                    LogSize,
                                                    Log,
                                                    &LogSize);

                //
                // The hal gave us a buffer size needed that was too
                // small, so lets stop right here and let him know]
                //
                WmipAssert(Status != STATUS_BUFFER_TOO_SMALL);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (NT_SUCCESS(Status))
        {
            //
            // We successfully read the data from the hal so build up
            // output buffers.
            //
            if (Wnode != NULL)
            {
                //
                // Caller requested buffer returned within a WNODE, so
                // build up the wnode around the log data
                //
                
                WnodeSI = (PWNODE_SINGLE_INSTANCE)Ptr;
                Status = WmipBuildMcaCmcEvent(WnodeSI,
                                              Guid,
                                              NULL,
                                              LogSize);
                *Wnode = WnodeSI;
            }
            
            *Mca = Log;
            *McaSize = LogSize;
        }

        if ((! NT_SUCCESS(Status)) && (Ptr != NULL))
        {
            //
            // If the function failed, but we have an allocated buffer
            // then clean it up
            //
            ExFreePool(Ptr);
        }
        
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(Status);
}

#define MAX_ERROR_EVENT_SIZE \
    (((sizeof(WNODE_SINGLE_INSTANCE) + \
       (sizeof(USHORT) + sizeof(MCA_EVENT_INSTANCE_NAME)) + 7) & ~7) + \
     sizeof(MSMCAEvent_MemoryError))
                               
void WmipGenerateMCAEventlog(
    PUCHAR ErrorLog,
    ULONG ErrorLogSize,
    BOOLEAN IsFatal
    )
{
    PERROR_RECORD_HEADER RecordHeader;
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PWCHAR w;
    ULONG BufferSize;
    PUCHAR Buffer, RawPtr = NULL;
    PWNODE_SINGLE_INSTANCE Wnode;
    PMSMCAEvent_Header Header;

    PAGED_CODE();
    
    RecordHeader = (PERROR_RECORD_HEADER)ErrorLog;

    //
    // Allocate a buffer large enough to accommodate any type of MCA.
    // Right now the largest is MSMCAEvent_MemoryError. If this changes
    // then this code should be updated
    //  
    BufferSize = MAX_ERROR_EVENT_SIZE + ErrorLogSize;

    //
    // Allocate a buffer to build the event
    //
    Buffer = ExAllocatePoolWithTag(PagedPool,
                                   BufferSize,
                                   WmipMCAPoolTag);
    
    if (Buffer != NULL)
    {
        //
        // Fill in the common fields of the WNODE
        //
        Wnode = (PWNODE_SINGLE_INSTANCE)Buffer;
        Wnode->WnodeHeader.BufferSize = BufferSize;
        Wnode->WnodeHeader.Linkage = 0;
        WmiInsertTimestamp(&Wnode->WnodeHeader);
        Wnode->WnodeHeader.Flags = WNODE_FLAG_SINGLE_INSTANCE |
                                   WNODE_FLAG_EVENT_ITEM;
        Wnode->OffsetInstanceName = sizeof(WNODE_SINGLE_INSTANCE);
        Wnode->DataBlockOffset = ((sizeof(WNODE_SINGLE_INSTANCE) +
                       (sizeof(USHORT) + sizeof(MCA_EVENT_INSTANCE_NAME)) +7) & ~7);

        w = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
        *w++ = sizeof(MCA_EVENT_INSTANCE_NAME);
        wcscpy(w, MCA_EVENT_INSTANCE_NAME);

        //
        // Fill in the common fields of the event data
        //
        Header = (PMSMCAEvent_Header)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
        Header->Cpu = MCA_UNDEFINED_CPU;   // assume CPU will be undefined
        Header->AdditionalErrors = 0;
        Header->LogToEventlog = 1;
            
        //
        // Construct the error event using the data in the error log we
        // retrieved from the HAL.
        //
#if defined(_AMD64_) || defined(i386)
        if (IsFatal) {
#endif
        Status = WmipConstructMCAErrorEvent(
                     (PVOID) ErrorLog,
                     ErrorLogSize,
                     Wnode,
                     Header,
                     &RawPtr,
                     &IsFatal
                     );
#if defined(_AMD64_) || defined(i386)
        }
#endif

        //
        // If we were not able to build a specific event type then
        // we fallback and fire a generic one
        //
        if (! NT_SUCCESS(Status))
        {
            //
            // Build event for Unknown MCA
            //
            PMSMCAEvent_InvalidError Event;

            WmipAssert( sizeof(MSMCAEvent_MemoryError) >=
                        sizeof(MSMCAEvent_InvalidError) );

            Event = (PMSMCAEvent_InvalidError)Header;

            //
            // Fill in the data from the MCA within the WMI event
            //
            if (Header->Cpu == MCA_UNDEFINED_CPU)
            {
                Event->Type = IsFatal ? MCA_ERROR_UNKNOWN_NO_CPU :
                                        MCA_WARNING_UNKNOWN_NO_CPU;
            } else {
                Event->Type = IsFatal ? MCA_ERROR_UNKNOWN :
                                        MCA_WARNING_UNKNOWN;
            }

            Event->Size = ErrorLogSize;
            RawPtr = Event->RawRecord;

            //
            // Finish filling in WNODE fields
            //
            Wnode->WnodeHeader.Guid = WmipMSMCAEvent_InvalidErrorGuid;
            Wnode->SizeDataBlock = FIELD_OFFSET(MSMCAEvent_InvalidError,
                                               RawRecord) + ErrorLogSize;
        }

        //
        // Adjust the Error event count
        //
        if (Header->AdditionalErrors > 0)
        {
            Header->AdditionalErrors--;
        }
        
        //
        // Put the entire MCA record into the event
        //
        RtlCopyMemory(RawPtr,
                      RecordHeader,
                      ErrorLogSize);

        if ((! IsFatal) && (Header->LogToEventlog == 1))

        {
            if (WmipCorrectedEventlogCounter != 0)
            {
                //
                // Since this is a corrected error that is getting
                // logged to the eventlog we need to account for it
                //
                if ((WmipCorrectedEventlogCounter != 0xffffffff) &&
                    (--WmipCorrectedEventlogCounter == 0))
                {
                    WmipWriteToEventlog(MCA_INFO_NO_MORE_CORRECTED_ERROR_LOGS,
                                        STATUS_SUCCESS);
                }
            } else {
                //
                // We have exceeded the limit of corrected errors that
                // we are allowed to write into the eventlog, so we
                // just suppress it
                //
                Header->LogToEventlog = 0;
            }           
        }
        
        //
        // Now go and fire off the event
        //
        if ((WmipDisableMCAPopups == 0) &&
           (Header->LogToEventlog != 0))
        {
            IoRaiseInformationalHardError(STATUS_MCA_OCCURED,
                                          NULL,
                                          NULL);
        }

        if ((Header->LogToEventlog == 1) ||
            (WmipIsWbemRunning()))
        {
            //
            // Only fire off a WMI event if we want to log to the
            // eventlog or WBEM is up and running
            //
            Status = WmipWriteMCAEventLogEvent((PUCHAR)Wnode);
        }

        if (! NT_SUCCESS(Status))
        {
            ExFreePool(Wnode);
        }

    } else {

        //
        // Not enough memory to do a full MCA event so lets just do a
        // generic one.
        //
        WmipWriteToEventlog(
            IsFatal ? MCA_WARNING_UNKNOWN_NO_CPU : MCA_ERROR_UNKNOWN_NO_CPU,
            STATUS_INSUFFICIENT_RESOURCES
            );
    }
}



NTSTATUS WmipWriteMCAEventLogEvent(
    PUCHAR Event
    )
{
    PWNODE_HEADER Wnode = (PWNODE_HEADER)Event;
    NTSTATUS Status;

    PAGED_CODE();
    
    WmipEnterSMCritSection();
    
    if (WmipIsWbemRunning() ||
        WmipCheckIsWbemRunning())
    {
        //
        // We know WBEM is running so we can just fire off our event
        //
        WmipLeaveSMCritSection();
        Status = IoWMIWriteEvent(Event);
    } else {
        //
        // WBEM is not currently running and so startup a timer that
        // will keep polling it
        //
        if (WmipIsWbemRunningFlag == WBEM_STATUS_UNKNOWN)
        {
            //
            // No one has kicked off the waiting process for wbem so we
            // do that here. Note we need to maintain the critical
            // section to guard against another thread that might be
            // trying to startup the waiting process as well. Note that
            // if the setup fails we want to stay in the unknown state
            // so that the next time an event is fired we can retry
            // waiting for wbem
            //
            Status = WmipSetupWaitForWbem();
            if (NT_SUCCESS(Status))
            {
                WmipIsWbemRunningFlag = WAITING_FOR_WBEM;
            }
        }
        
        Wnode->ClientContext = Wnode->BufferSize;
        InsertTailList(&WmipWaitingMCAEvents,
                       (PLIST_ENTRY)Event);
        WmipLeaveSMCritSection();
        Status = STATUS_SUCCESS;
    }
    return(Status);
}

ULONG WmipWbemMinuteWait = 1;

NTSTATUS WmipSetupWaitForWbem(
    void
    )
{
    LARGE_INTEGER TimeOut;
    NTSTATUS Status;
    
    PAGED_CODE();

    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                      "WMI: SetupWaitForWbem starting\n"));

    //
    // Initialize a kernel time to fire periodically so we can
    // check if WBEM has started or not
    //
    KeInitializeTimer(&WmipIsWbemRunningTimer);

    KeInitializeDpc(&WmipIsWbemRunningDpc,
                    WmipIsWbemRunningDispatch,
                    NULL);

    ExInitializeWorkItem(&WmipIsWbemRunningWorkItem,
                         WmipIsWbemRunningWorker,
                         NULL);

    TimeOut.HighPart = -1;
    TimeOut.LowPart = -1 * (WmipWbemMinuteWait * 60 * 1000 * 10000);    // 1 minutes
    KeSetTimer(&WmipIsWbemRunningTimer,
               TimeOut,
               &WmipIsWbemRunningDpc);

    Status = STATUS_SUCCESS;

    return(Status);
}

void WmipIsWbemRunningDispatch(    
    IN PKDPC Dpc,
    IN PVOID DeferredContext,     // Not Used
    IN PVOID SystemArgument1,     // Not Used
    IN PVOID SystemArgument2      // Not Used
    )
{
    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (DeferredContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    ExQueueWorkItem(&WmipIsWbemRunningWorkItem,
                    DelayedWorkQueue);
}

void WmipIsWbemRunningWorker(
    PVOID Context
    )
{
    LARGE_INTEGER TimeOut;
    
    PAGED_CODE();
    
    UNREFERENCED_PARAMETER (Context);

    if (! WmipCheckIsWbemRunning())
    {
        //
        // WBEM is not yet started, so timeout in another minute to
        // check again
        //
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                          "WMI: IsWbemRunningWorker starting -> WBEM not started\n"));

        TimeOut.HighPart = -1;
        TimeOut.LowPart = (ULONG)(-1 * (1 *60 *1000 *10000));   // 1 minutes
        KeSetTimer(&WmipIsWbemRunningTimer,
                   TimeOut,
                   &WmipIsWbemRunningDpc);
        
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                          "WMI: WbemRunningWorker found wbem started\n"));

    }
}

BOOLEAN WmipCheckIsWbemRunning(
    void
    )
{
    OBJECT_ATTRIBUTES Obj;
    UNICODE_STRING Name;
    HANDLE Handle;
    LARGE_INTEGER TimeOut;
    BOOLEAN IsWbemRunning = FALSE;
    NTSTATUS Status;
    PWNODE_HEADER Wnode;

    PAGED_CODE();

    RtlInitUnicodeString(&Name,
                         L"\\BaseNamedObjects\\WBEM_ESS_OPEN_FOR_BUSINESS");

    
    InitializeObjectAttributes(
        &Obj,
        &Name,
        FALSE,
        NULL,
        NULL
        );

    Status = ZwOpenEvent(
                &Handle,
                SYNCHRONIZE,
                &Obj
                );

    if (NT_SUCCESS(Status))
    {
        TimeOut.QuadPart = 0;
        Status = ZwWaitForSingleObject(Handle,
                                       FALSE,
                                       &TimeOut);
        if (Status == STATUS_SUCCESS)
        {
            IsWbemRunning = TRUE;

            //
            // We've determined that WBEM is running so now lets see if
            // another thread has made that determination as well. If not
            // then we can flush the MCA event queue and set the flag
            // that WBEM is running
            //
            WmipEnterSMCritSection();
            if (WmipIsWbemRunningFlag != WBEM_IS_RUNNING)
            {
                //
                // Flush the list of all MCA events waiting to be fired
                //
                while (! IsListEmpty(&WmipWaitingMCAEvents))
                {
                    Wnode = (PWNODE_HEADER)RemoveHeadList(&WmipWaitingMCAEvents);
                    WmipLeaveSMCritSection();
                    Wnode->BufferSize = Wnode->ClientContext;
                    Wnode->Linkage = 0;
                    Status = IoWMIWriteEvent(Wnode);
                    if (! NT_SUCCESS(Status))
                    {
                        ExFreePool(Wnode);
                    }
                    WmipEnterSMCritSection();
                }
                
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                  "WMI: WBEM is Running and queus flushed\n"));
                
                WmipIsWbemRunningFlag = WBEM_IS_RUNNING;
            }
            WmipLeaveSMCritSection();
        }
        ZwClose(Handle);
    }
    return(IsWbemRunning);
}

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\ds.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    ds.c

Abstract:

    WMI data provider registration code

--*/

#include "wmikmp.h"

#include <strsafe.h>

void WmipEnableCollectionForNewGuid(
    LPGUID Guid,
    PBINSTANCESET InstanceSet
    );

void WmipDisableCollectionForRemovedGuid(
    LPGUID Guid,
    PBINSTANCESET InstanceSet
    );

ULONG WmipDetermineInstanceBaseIndex(
    LPGUID Guid,
    PWCHAR BaseName,
    ULONG InstanceCount
    );

NTSTATUS
WmipMangleInstanceName(
    IN  LPGUID  Guid,
    IN  PWCHAR  Name,
    IN  SIZE_T  MaxMangledNameLen,
    OUT PWCHAR  MangledName
    );

NTSTATUS WmipBuildInstanceSet(
    PWMIREGGUID RegGuid,
    PWMIREGINFOW WmiRegInfo,
    ULONG BufferSize,
    PBINSTANCESET InstanceSet,
    ULONG ProviderId,
    LPCTSTR MofImagePath
    );

NTSTATUS WmipLinkDataSourceToList(
    PBDATASOURCE DataSource,
    BOOLEAN AddDSToList
    );

void WmipSendGuidUpdateNotifications(
    NOTIFICATIONTYPES NotificationType,
    ULONG GuidCount,
    PTRCACHE *GuidList
    );

void WmipGenerateBinaryMofNotification(
    PBINSTANCESET BinaryMofInstanceSet,
    LPCGUID Guid        
    );

void WmipGenerateRegistrationNotification(
    PBDATASOURCE DataSource,
    ULONG NotificationCode
    );

NTSTATUS WmipAddMofResource(
    PBDATASOURCE DataSource,
    LPWSTR ImagePath,
    BOOLEAN IsImagePath,
    LPWSTR MofResourceName,
    PBOOLEAN NewMofResource
    );

PBINSTANCESET WmipFindISInDSByGuid(
    PBDATASOURCE DataSource,
    LPGUID Guid
    );

ULONG WmipUpdateAddGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PWMIREGINFO WmiRegInfo,
    ULONG BufferSize,
    PBINSTANCESET *AddModInstanceSet
    );

PWCHAR GuidToString(
    PWCHAR s,
    ULONG SizeInBytes,
    LPGUID piid
    );

BOOLEAN WmipUpdateRemoveGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PBINSTANCESET *AddModInstanceSet
    );

BOOLEAN WmipIsEqualInstanceSets(
    PBINSTANCESET InstanceSet1,
    PBINSTANCESET InstanceSet2
    );

ULONG WmipUpdateModifyGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PWMIREGINFO WmiRegInfo,
    ULONG BufferSize,
    PBINSTANCESET *AddModInstanceSet
    );

void WmipCachePtrs(
    LPGUID Ptr1,
    PBINSTANCESET Ptr2,
    ULONG *PtrCount,
    ULONG *PtrMax,
    PTRCACHE **PtrArray
    );

NTSTATUS WmipUpdateDataSource(
    PREGENTRY RegEntry,
    PWMIREGINFOW WmiRegInfo,
    ULONG RetSize
    );

void WmipRemoveDataSourceByDS(
    PBDATASOURCE DataSource
    );

NTSTATUS WmipRemoveDataSource(
    PREGENTRY RegEntry
    );

NTSTATUS WmipInitializeDataStructs(
    void
);

NTSTATUS WmipEnumerateMofResources(
    PWMIMOFLIST MofList,
    ULONG BufferSize,
    ULONG *RetSize
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,WmipInitializeDataStructs)
#pragma alloc_text(PAGE,WmipEnableCollectionForNewGuid)
#pragma alloc_text(PAGE,WmipDisableCollectionForRemovedGuid)
#pragma alloc_text(PAGE,WmipDetermineInstanceBaseIndex)
#pragma alloc_text(PAGE,WmipMangleInstanceName)
#pragma alloc_text(PAGE,WmipBuildInstanceSet)
#pragma alloc_text(PAGE,WmipLinkDataSourceToList)
#pragma alloc_text(PAGE,WmipSendGuidUpdateNotifications)
#pragma alloc_text(PAGE,WmipGenerateBinaryMofNotification)
#pragma alloc_text(PAGE,WmipGenerateMofResourceNotification)
#pragma alloc_text(PAGE,WmipGenerateRegistrationNotification)
#pragma alloc_text(PAGE,WmipAddMofResource)
#pragma alloc_text(PAGE,WmipAddDataSource)
#pragma alloc_text(PAGE,WmipFindISInDSByGuid)
#pragma alloc_text(PAGE,WmipUpdateAddGuid)
#pragma alloc_text(PAGE,WmipUpdateRemoveGuid)
#pragma alloc_text(PAGE,WmipIsEqualInstanceSets)
#pragma alloc_text(PAGE,WmipUpdateModifyGuid)
#pragma alloc_text(PAGE,WmipCachePtrs)
#pragma alloc_text(PAGE,WmipUpdateDataSource)
#pragma alloc_text(PAGE,WmipRemoveDataSourceByDS)
#pragma alloc_text(PAGE,WmipRemoveDataSource)
#pragma alloc_text(PAGE,WmipEnumerateMofResources)
 
#if DBG
#pragma alloc_text(PAGE,GuidToString)
#endif
#endif


#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

const GUID WmipBinaryMofGuid = BINARY_MOF_GUID;

// {4EE0B301-94BC-11d0-A4EC-00A0C9062910}
const GUID RegChangeNotificationGuid =
{ 0x4ee0b301, 0x94bc, 0x11d0, { 0xa4, 0xec, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 } };


void WmipEnableCollectionForNewGuid(
    LPGUID Guid,
    PBINSTANCESET InstanceSet
    )
{
    WNODE_HEADER Wnode;
    PBGUIDENTRY GuidEntry;
    ULONG Status;
    BOOLEAN IsTraceLog;

    PAGED_CODE();
    
    GuidEntry = WmipFindGEByGuid(Guid, FALSE);

    if (GuidEntry != NULL)
    {
        memset(&Wnode, 0, sizeof(WNODE_HEADER));
        memcpy(&Wnode.Guid, Guid, sizeof(GUID));
        Wnode.BufferSize = sizeof(WNODE_HEADER);

        WmipEnterSMCritSection();
        if ((GuidEntry->EventRefCount > 0) &&
            ((InstanceSet->Flags & IS_ENABLE_EVENT) == 0))

        {
            //
            // Events were previously enabled for this guid, but not for this
            // instance set so call data source for instance set to enable
            // the events. First set the in progress flag and InstanceSet
            // set flag to denote that events have been enabled for the
            // instance set.
            InstanceSet->Flags |= IS_ENABLE_EVENT;

            //
            // If it is Tracelog, NewGuid notifications are piggybacked with
            // Registration call return. 
            //
            IsTraceLog = ((InstanceSet->Flags & IS_TRACED) == IS_TRACED) ? TRUE : FALSE;
            if (IsTraceLog) 
            {
                if (!(InstanceSet->DataSource->Flags & DS_KERNEL_MODE) ) 
                {
                    if (GuidEntry != NULL)
                    {
                        WmipUnreferenceGE(GuidEntry);
                    }
                    WmipLeaveSMCritSection();
                    return;
                }
            
                //
                // For the Kernel Mode Trace Providers pass on the context
                //
                Wnode.HistoricalContext = GuidEntry->LoggerContext;
            }

            GuidEntry->Flags |= GE_FLAG_NOTIFICATION_IN_PROGRESS;

            WmipLeaveSMCritSection();
            WmipDeliverWnodeToDS(IRP_MN_ENABLE_EVENTS,
                                 InstanceSet->DataSource,
                                 &Wnode,
                                 Wnode.BufferSize);
            WmipEnterSMCritSection();

            //
            // Now we need to check if events were disabled while the enable
            // request was in progress. If so go do the work to actually
            // disable them.
            if (GuidEntry->EventRefCount == 0)
            {
                Status = WmipDoDisableRequest(GuidEntry,
                                          TRUE,
                                             IsTraceLog,
                                           GuidEntry->LoggerContext,
                                          GE_FLAG_NOTIFICATION_IN_PROGRESS);

            } else {
                GuidEntry->Flags &= ~GE_FLAG_NOTIFICATION_IN_PROGRESS;
            }
        }

        //
        // Now check to see if collection needs to be enabled for this guid
        //
        if ((GuidEntry->CollectRefCount > 0) &&
            ((InstanceSet->Flags & IS_ENABLE_COLLECTION) == 0)  &&
            (InstanceSet->Flags & IS_EXPENSIVE) )

        {
            //
            // Collection was previously enabled for this guid, but not
            // for this instance set so call data source for instance set
            // to enable collection. First set the in progress flag and
            // InstanceSet set flag to denote that collection has been enabled
            //  for the instance set.
            //
            GuidEntry->Flags |= GE_FLAG_COLLECTION_IN_PROGRESS;
            InstanceSet->Flags |= IS_ENABLE_COLLECTION;

            WmipLeaveSMCritSection();
            WmipDeliverWnodeToDS(IRP_MN_ENABLE_COLLECTION,
                                 InstanceSet->DataSource,
                                 &Wnode,
                                 Wnode.BufferSize);
            WmipEnterSMCritSection();

            //
            // Now we need to check if events were disabled while the enable
            // request was in progress. If so go do the work to actually
            // disable them.
            //
            if (GuidEntry->CollectRefCount == 0)
            {
                Status = WmipDoDisableRequest(GuidEntry,
                                          FALSE,
                                             FALSE,
                                           0,
                                          GE_FLAG_COLLECTION_IN_PROGRESS);

            } else {
                GuidEntry->Flags &= ~GE_FLAG_COLLECTION_IN_PROGRESS;
        
                //
                   // If there are any other threads that were waiting 
                // until all of the enable/disable work completed, we 
                // close the event handle to release them from their wait.
                //
                WmipReleaseCollectionEnabled(GuidEntry);
            }
        }
        WmipUnreferenceGE(GuidEntry);
        WmipLeaveSMCritSection();
    } else {
        WmipAssert(FALSE);
    }
}

void WmipDisableCollectionForRemovedGuid(
    LPGUID Guid,
    PBINSTANCESET InstanceSet
    )
{
    WNODE_HEADER Wnode;
    PBGUIDENTRY GuidEntry;
    ULONG Status;
    BOOLEAN IsTraceLog;

    PAGED_CODE();
    
    GuidEntry = WmipFindGEByGuid(Guid, FALSE);

    if (GuidEntry != NULL)
    {
        memset(&Wnode, 0, sizeof(WNODE_HEADER));
        memcpy(&Wnode.Guid, Guid, sizeof(GUID));
        Wnode.BufferSize = sizeof(WNODE_HEADER);

        WmipEnterSMCritSection();

        if ((GuidEntry->EventRefCount > 0) &&
               ((InstanceSet->Flags & IS_ENABLE_EVENT) != 0))

        {
            // Events were previously enabled for this guid, but not for this
            // instance set so call data source for instance set to enable
            // the events. First set the in progress flag and InstanceSet
            // set flag to denote that events have been enabled for the
            // instance set.
            InstanceSet->Flags &= ~IS_ENABLE_EVENT;

            //
            // If it is Tracelog, RemoveGuid notifications are handled
            // through UnregisterGuids call. 
            //
            IsTraceLog = ((InstanceSet->Flags & IS_TRACED) == IS_TRACED) ? TRUE : FALSE;
            if (IsTraceLog)
            {
                if ( !(InstanceSet->DataSource->Flags & DS_KERNEL_MODE)) 
                {
                    WmipUnreferenceGE(GuidEntry);
                    WmipLeaveSMCritSection();
                    return;
                }
                Wnode.HistoricalContext = GuidEntry->LoggerContext;
            }


            GuidEntry->Flags |= GE_FLAG_NOTIFICATION_IN_PROGRESS;

            WmipLeaveSMCritSection();
            WmipDeliverWnodeToDS(IRP_MN_DISABLE_EVENTS,
                                 InstanceSet->DataSource,
                                 &Wnode,
                                 Wnode.BufferSize);
            WmipEnterSMCritSection();

            //
            // Now we need to check if events were disabled while the enable
            // request was in progress. If so go do the work to actually
            // disable them.
            if (GuidEntry->EventRefCount == 0)
            {
                Status = WmipDoDisableRequest(GuidEntry,
                                          TRUE,
                                             IsTraceLog,
                                           GuidEntry->LoggerContext,
                                          GE_FLAG_NOTIFICATION_IN_PROGRESS);

            } else {
                GuidEntry->Flags &= ~GE_FLAG_NOTIFICATION_IN_PROGRESS;
            }
        }

        //
        // Now check to see if collection needs to be enabled for this guid
        if ((GuidEntry->CollectRefCount > 0) &&
            ((InstanceSet->Flags & IS_ENABLE_COLLECTION) != 0))

        {
            // Collection was previously enabled for this guid, but not
            // for this instance set so call data source for instance set
            // to enable collection. First set the in progress flag and
            // InstanceSet set flag to denote that collection has been enabled
            //  for the instance set.
            GuidEntry->Flags |= GE_FLAG_COLLECTION_IN_PROGRESS;
            InstanceSet->Flags &= ~IS_ENABLE_COLLECTION;

            WmipLeaveSMCritSection();
            WmipDeliverWnodeToDS(IRP_MN_DISABLE_COLLECTION,
                                 InstanceSet->DataSource,
                                 &Wnode,
                                 Wnode.BufferSize);
            WmipEnterSMCritSection();

            //
            // Now we need to check if events were disabled while the enable
            // request was in progress. If so go do the work to actually
            // disable them.
            if (GuidEntry->CollectRefCount == 0)
            {
                Status = WmipDoDisableRequest(GuidEntry,
                                          FALSE,
                                             FALSE,
                                           0,
                                          GE_FLAG_COLLECTION_IN_PROGRESS);

            } else {
                GuidEntry->Flags &= ~GE_FLAG_COLLECTION_IN_PROGRESS;
        
                //
                // If there are any other threads that were waiting 
                // until all of the enable/disable work completed, we 
                // close the event handle to release them from their wait.
                //
                WmipReleaseCollectionEnabled(GuidEntry);
            }
        }
        WmipUnreferenceGE(GuidEntry);
        WmipLeaveSMCritSection();
    } else {
        WmipAssert(FALSE);
    }
}

ULONG WmipDetermineInstanceBaseIndex(
    LPGUID Guid,
    PWCHAR BaseName,
    ULONG InstanceCount
    )
/*++

Routine Description:

    Figure out the base index for the instance names specified by a base
    instance name. We walk the list of instances sets for the guid and if
    there is a match in the base instance name we set the base instance index
    above that used by the previously registered instance set.

Arguments:

    Guid points at guid for the instance names
    BaseName points at the base name for the instances
    InstanceCount is the count of instance names

Return Value:

    Base index for instance name

--*/
{
    PBGUIDENTRY GuidEntry;
    ULONG BaseIndex = 0;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    ULONG LastBaseIndex;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (InstanceCount);

    WmipEnterSMCritSection();
    
    GuidEntry = WmipFindGEByGuid(Guid, FALSE);
    if (GuidEntry != NULL)
    {
        InstanceSetList = GuidEntry->ISHead.Flink;
        while (InstanceSetList != &GuidEntry->ISHead)
        {
            InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
            if (InstanceSet->Flags & IS_INSTANCE_BASENAME)
            {
                if (wcscmp(BaseName, InstanceSet->IsBaseName->BaseName) == 0)
                {
                    LastBaseIndex = InstanceSet->IsBaseName->BaseIndex + InstanceSet->Count;
                    if (BaseIndex <= LastBaseIndex)
                    {
                        BaseIndex = LastBaseIndex;
                    }
                }
            }
            InstanceSetList = InstanceSetList->Flink;
        }
        WmipUnreferenceGE(GuidEntry);
    }
    
    WmipLeaveSMCritSection();
    
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Static instance name %ws has base index %x\n",
                    BaseName, BaseIndex));
    return(BaseIndex);
}

NTSTATUS
WmipMangleInstanceName(
    IN  LPGUID  Guid,
    IN  PWCHAR  OriginalName,
    IN  SIZE_T  MaxMangledNameLen,
    OUT PWCHAR  MangledName
    )
/*++

Routine Description:

    Copies a static instance name from the input buffer to the output
    buffer, mangling it if the name collides with another name for the
    same guid.

Arguments:

    Guid - points at guid for the instance name
    
    OriginalName - points at the proposed, null-terminated instance name
    
    MaxMangledNameLen - has the maximum number of chars in mangled name buffer,
        including the terminating NULL
        
    MangledName - points at buffer to return the null-terminated mangled name

Return Value:

    Normal NTSTATUS code.
    
Note:

    This algorithm is busted! It's supposed to try up to (26^6) mangled name
    variations, but it actually only tries up to (26 * 6) variations.
    
    Note that, if we wanted to, we could actually go for (62^6) variations
    if we used uppercase letters, lowercase letters and numbers.

--*/
{
    PBGUIDENTRY     GuidEntry;
    ULONG           InstanceIndex;
    PBINSTANCESET   InstanceSet;
    SIZE_T          ManglePos;
    WCHAR           ManglingChar;
    SIZE_T          NameLength;
    NTSTATUS        Status;

    PAGED_CODE();

    WmipAssert(Guid != NULL);
    WmipAssert(OriginalName != NULL);
    WmipAssert(MangledName != NULL);

    GuidEntry = NULL;

    if (Guid == NULL ||
        OriginalName == NULL ||
        MangledName == NULL) {

        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    NameLength = wcslen(OriginalName);
    
    WmipAssert(MaxMangledNameLen >= NameLength + 1);

    //
    // To make prefast happy, we have to wcsncpy the string and manually
    // terminate it.
    //

    wcsncpy(MangledName, OriginalName, NameLength);
    MangledName[NameLength] = UNICODE_NULL;

    Status = STATUS_SUCCESS;

    GuidEntry = WmipFindGEByGuid(Guid, FALSE);

    if (GuidEntry == NULL) {
        goto Exit;
    }

    //
    // Set ManglePos to the last valid character in the name and set
    // ManglingChar to 'Z' -- note that this will trigger the loop below
    // to move ManglePos one position forward (to the first spot we actually
    // want to mangle) and reset ManglingChar to 'A' to really start the
    // mangling.
    //

    ManglePos = NameLength - 1;
    ManglingChar = L'Z';

    //
    // Loop until we get a unique name.
    //

    InstanceSet = WmipFindISinGEbyName(GuidEntry, MangledName, &InstanceIndex);

    while (InstanceSet != NULL) {

        WmipUnreferenceIS(InstanceSet);
        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                          DPFLTR_INFO_LEVEL,
                          "WMI: Need to mangle name %ws\n",
                          MangledName));
        
        if (ManglingChar == L'Z') {

            //
            // Reset back to 'A' and move to the next character position to
            // try and mangle.
            //

            ManglingChar = L'A';
            ++ManglePos;
            
            if (ManglePos == MaxMangledNameLen - 1) {

                //
                // We're out of room, so fail.
                //

                WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                  DPFLTR_INFO_LEVEL,
                                  "WMI: Instance Name could not be mangled\n"));
                
                Status = STATUS_UNSUCCESSFUL;
                goto Exit;
            }

            //
            // Make sure to re-terminate the string.
            //

            MangledName[ManglePos + 1] = UNICODE_NULL;
        } else {
            ++ManglingChar;
        }

        MangledName[ManglePos] = ManglingChar;
        
        InstanceSet = WmipFindISinGEbyName(GuidEntry,
                                           MangledName,
                                           &InstanceIndex) ;
    }

Exit:

    if (GuidEntry != NULL) {
        WmipUnreferenceGE(GuidEntry);
    }

    return Status;
}

NTSTATUS
WmipBuildInstanceSet(
    IN  PWMIREGGUID     RegGuid,
    IN  PWMIREGINFOW    WmiRegInfo,
    IN  ULONG           BufferSize,
    IN  PBINSTANCESET   InstanceSet,
    IN  ULONG           ProviderId,
    IN  LPCTSTR         MofImagePath
    )
/*++

Routine Description:

    This routine sets up the passed in InstanceSet with the appropriate
    instance names as described in RegGuid.
    
Arguments:

    RegGuid - pointer to registration information about this instance set
    
    WmiRegInfo - the WMI registration blob that contains RegGuid
    
    BufferSize - total size of WmiRegInfo
    
    InstanceSet - the instance set to fill out
    
    ProviderId - id of the provider registering with WMI
    
    MofImagePath - path the binary containing this provider's MOF data
    
Return Value:

    Normal NTSTATUS code.

--*/
{
    ULONG           i;
    ULONG           InstanceCount;
    PWCHAR          InstanceName;
    SIZE_T          InstanceNameOffset;
    PWCHAR          InstanceNamePtr;
    PBISBASENAME    IsBaseName;
    PBISSTATICNAMES IsStaticName;
    SIZE_T          MaxStaticInstanceNameLength;
    SIZE_T          NameLength;
    SIZE_T          SizeNeeded;
    PWCHAR          StaticInstanceNameBuffer;
    PWCHAR          StaticNames;
    NTSTATUS        Status;

    PAGED_CODE();

    WmipAssert(RegGuid != NULL);
    WmipAssert(WmiRegInfo != NULL);
    WmipAssert(BufferSize > 0);
    WmipAssert(InstanceSet != NULL);

    UNREFERENCED_PARAMETER(MofImagePath);
    
    StaticInstanceNameBuffer = NULL;

    if (RegGuid == NULL ||
        WmiRegInfo == NULL ||
        BufferSize == 0 ||
        InstanceSet == NULL) {

        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    //
    // Remember the count of instances for the guid in the DS.
    //

    InstanceCount = RegGuid->InstanceCount;

    InstanceSet->Count = InstanceCount;
    InstanceSet->ProviderId = ProviderId;

    //
    // Reset the cached size of space needed for all instance names in a
    // "query all data" request. This will be recomputed when the next
    // request comes in.
    //

    InstanceSet->WADInstanceNameSize = 0;
    
    //
    // Reset any flags that might be changed by a new REGGUID.
    //
    
    InstanceSet->Flags &= ~(IS_EXPENSIVE |
                            IS_EVENT_ONLY |
                            IS_PDO_INSTANCENAME |
                            IS_INSTANCE_STATICNAMES |
                            IS_INSTANCE_BASENAME);

    //
    // Finish initializing the Instance Set flags.
    //

    if (RegGuid->Flags & WMIREG_FLAG_EXPENSIVE) {
        InstanceSet->Flags |= IS_EXPENSIVE;
    }

    if (RegGuid->Flags & WMIREG_FLAG_TRACED_GUID) {

        //
        // This guid is not queryable, but is used for sending trace
        // events. We mark the InstanceSet as special.
        //
        
        InstanceSet->Flags |= IS_TRACED;

        if (RegGuid->Flags & WMIREG_FLAG_TRACE_CONTROL_GUID) {
            InstanceSet->Flags |= IS_CONTROL_GUID;
        }
    }

    if (RegGuid->Flags & WMIREG_FLAG_EVENT_ONLY_GUID) {

        //
        // This guid is not queryable, but is only used for sending
        // events. We mark the InstanceSet as special.
        //
        
        InstanceSet->Flags |= IS_EVENT_ONLY;
    }

    InstanceNameOffset = (SIZE_T)RegGuid->InstanceNameList;
    InstanceName = (PWCHAR)OffsetToPtr(WmiRegInfo, InstanceNameOffset);

    if (RegGuid->Flags & WMIREG_FLAG_INSTANCE_LIST) {

        //
        // We have static list of instance names that might need mangling
        // We assume that any name mangling that must occur can be
        // done with a suffix of 6 or fewer characters. This allows
        // up to 100,000 identical static instance names within the
        // same guid. First lets get the amount of memory we'll need.
        //

        SizeNeeded = FIELD_OFFSET(ISSTATICENAMES, StaticNamePtr[0]) + 1;
        MaxStaticInstanceNameLength = 0;

        for (i = 0; i < InstanceCount; ++i) {

            Status = WmipValidateWmiRegInfoString(WmiRegInfo,
                                                  BufferSize,
                                                  (ULONG)InstanceNameOffset,
                                                  &InstanceNamePtr);
                        
            if (!NT_SUCCESS(Status) || (InstanceNamePtr == NULL)) {

                WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                  DPFLTR_INFO_LEVEL,
                                  "WMI: WmipBuildInstanceSet: bad static instance name %x\n",
                                  InstanceNamePtr));
                
                WmipReportEventLog(EVENT_WMI_INVALID_REGINFO,
                                   EVENTLOG_WARNING_TYPE,
                                   0,
                                   WmiRegInfo->BufferSize,
                                   WmiRegInfo,
                                   1,
                                   MofImagePath != NULL ? MofImagePath : TEXT("Unknown"));
                
                Status = STATUS_INVALID_PARAMETER;
                goto Exit;
            }

            //
            // InstanceNamePtr now points to the beginning of a counted string.
            //

            NameLength = (*InstanceNamePtr) / sizeof(WCHAR);

            //
            // Keep track of the longest instance name.
            //

            if (NameLength > MaxStaticInstanceNameLength) {
                MaxStaticInstanceNameLength = NameLength;
            }

            //
            // Assume the worst case -- that this instance name will need all
            // possible suffix characters for mangling.
            //

            SizeNeeded += (sizeof(PWCHAR) +
                           ((NameLength + MAXBASENAMESUFFIXLENGTH + 1) * sizeof(WCHAR)));
                        
            InstanceNameOffset += ((1 + NameLength) * sizeof(WCHAR));
        }

        IsStaticName = (PBISSTATICNAMES)WmipAlloc(SizeNeeded);
        
        if (IsStaticName == NULL) {
            
            WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                              DPFLTR_INFO_LEVEL,
                              "WMI: WmipBuildInstanceSet: alloc static instance names\n"));
            
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }

        //
        // Once we assign IsStaticName to the InstanceSet, it will be cleaned
        // up when the InstanceSet goes away.
        //

        InstanceSet->Flags |= IS_INSTANCE_STATICNAMES;
        InstanceSet->IsStaticNames = IsStaticName;

        //
        // Allocate a temporary buffer big enough for the longest possible
        // mangled, null-terminated, string.
        //

        StaticInstanceNameBuffer = WmipAlloc((MaxStaticInstanceNameLength + 1) * sizeof(WCHAR));
        
        if (StaticInstanceNameBuffer == NULL) {
            
            WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                              DPFLTR_INFO_LEVEL,
                              "WMI: WmipBuildInstanceSet: couldn't alloc StaticInstanceNameBuffer\n"));
            
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }

        //
        // The actual instance names start immediately following the array
        // of StaticNamePtrs.
        //

        StaticNames = (PWCHAR)&IsStaticName->StaticNamePtr[InstanceCount];
        InstanceNamePtr = InstanceName;

        for (i = 0; i < InstanceCount; ++i) {

            IsStaticName->StaticNamePtr[i] = StaticNames;
            
            NameLength = (*InstanceNamePtr) / sizeof(WCHAR);
            ++InstanceNamePtr;
            
            //
            // Copy the counted instance name into a temporary, null-terminated
            // buffer.
            //

            wcsncpy(StaticInstanceNameBuffer, InstanceNamePtr, NameLength);
            StaticInstanceNameBuffer[NameLength] = UNICODE_NULL;
            
            //
            // Mangle the name if it needs it.
            //

            Status = WmipMangleInstanceName(&RegGuid->Guid,
                                            StaticInstanceNameBuffer,
                                            NameLength + MAXBASENAMESUFFIXLENGTH + 1,
                                            StaticNames);

            if (!NT_SUCCESS(Status)) {
                goto Exit;
            }

            //
            // Update the string pointers for both the new blob of strings
            // (StaticNames) and the original blob of strings (InstanceNamePtr).
            //

            StaticNames += (wcslen(StaticNames) + 1);
            InstanceNamePtr += NameLength;
        }

    } else if (RegGuid->Flags & WMIREG_FLAG_INSTANCE_BASENAME) {

        //
        // We have static instance names built from a base name.
        //

        Status = WmipValidateWmiRegInfoString(WmiRegInfo,
                                              BufferSize,
                                              (ULONG)InstanceNameOffset,
                                              &InstanceNamePtr);
                        
        if (!NT_SUCCESS(Status) || (InstanceNamePtr == NULL)) {

            WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                              DPFLTR_INFO_LEVEL,
                              "WMI: WmipBuildInstanceSet: Invalid instance base name %x\n",
                              InstanceName));

            WmipReportEventLog(EVENT_WMI_INVALID_REGINFO,
                               EVENTLOG_WARNING_TYPE,
                               0,
                               WmiRegInfo->BufferSize,
                               WmiRegInfo,
                               1,
                               MofImagePath ? MofImagePath : TEXT("Unknown"));
            
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        NameLength = (*InstanceNamePtr) / sizeof(WCHAR);
        ++InstanceNamePtr;

        IsBaseName = (PBISBASENAME)WmipAlloc(FIELD_OFFSET(ISBASENAME, BaseName[0]) +
                                             ((NameLength + 1) * sizeof(WCHAR)));

        if (IsBaseName == NULL) {

            WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                              DPFLTR_INFO_LEVEL,
                              "WMI: WmipBuildInstanceSet: alloc ISBASENAME failed\n"));
            
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }

        //
        // Once we assign IsBaseName to the InstanceSet, it will be cleaned
        // up when the InstanceSet goes away.
        //

        InstanceSet->Flags |= IS_INSTANCE_BASENAME;
        InstanceSet->IsBaseName = IsBaseName;

        if (RegGuid->Flags & WMIREG_FLAG_INSTANCE_PDO) {
            InstanceSet->Flags |= IS_PDO_INSTANCENAME;
        }

        //
        // Copy the counted instance name into BaseName as a null-terminated
        // string.
        //

        wcsncpy(&IsBaseName->BaseName[0], InstanceNamePtr, NameLength);
        IsBaseName->BaseName[NameLength] = UNICODE_NULL;

        IsBaseName->BaseIndex = WmipDetermineInstanceBaseIndex(&RegGuid->Guid,
                                                               &IsBaseName->BaseName[0],
                                                               RegGuid->InstanceCount);
    }

    Status = STATUS_SUCCESS;

Exit:

    if (StaticInstanceNameBuffer != NULL) {
        WmipFree(StaticInstanceNameBuffer);
    }

    return Status;
}

NTSTATUS WmipLinkDataSourceToList(
    PBDATASOURCE DataSource,
    BOOLEAN AddDSToList
    )
/*++

Routine Description:

    This routine will take a DataSource that was just registered or updated
    and link any new InstanceSets to an appropriate GuidEntry. Then if the
    AddDSToList is TRUE the DataSource itself will be added to the main
    data source list.

    This routine will do all of the linkages within a critical section so the
    data source and its new instances are added atomically. The routine will
    also determine if the guid entry associated with a InstanceSet is a
    duplicate of another that is already on the main guid entry list and if
    so will use the preexisting guid entry.

    This routine assumes that the SM critical section has been taken

Arguments:

    DataSource is a based pointer to a DataSource structure

    AddDSToList    is TRUE then data source will be added to the main list
        of data sources

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    PBINSTANCESET InstanceSet;
    PLIST_ENTRY InstanceSetList;
    PBGUIDENTRY GuidEntry;

    PAGED_CODE();
    
    InstanceSetList = DataSource->ISHead.Flink;
    while (InstanceSetList != &DataSource->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        DSISList);
        //
        // If this instance set has just been registered then we need to
        // get it on a GuidEntry list.
        if (InstanceSet->Flags & IS_NEWLY_REGISTERED)
        {
            //
            // See if there is already a GUID entry for the instance set.
            // If not go allocate a new guid entry and place it on the
            // main guid list. If there already is a GuidEntry for the
            // InstanceSet we will assign the ref count that was given by
            // the WmipFindGEByGuid to the DataSource which will unreference
            // the GuidEntry when the DataSource is unregistered.
            GuidEntry = WmipFindGEByGuid((LPGUID)InstanceSet->GuidEntry, 
                                          FALSE);
            if (GuidEntry == NULL)
            {
                GuidEntry = WmipAllocGuidEntry();
                if (GuidEntry == NULL)
                {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: WmipLinkDataSourceToList: WmipAllocGuidEntry failed\n"));
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }

                //
                // Initialize the new GuidEntry and place it on the master
                // GuidEntry list.
                memcpy(&GuidEntry->Guid,
                       (LPGUID)InstanceSet->GuidEntry,
                       sizeof(GUID));
           
                InsertHeadList(WmipGEHeadPtr, &GuidEntry->MainGEList);
            }
            InstanceSet->GuidEntry = GuidEntry;
            InstanceSet->Flags &= ~IS_NEWLY_REGISTERED;
            InsertTailList(&GuidEntry->ISHead, &InstanceSet->GuidISList);
            GuidEntry->ISCount++;
        }

        InstanceSetList = InstanceSetList->Flink;
    }


    if (AddDSToList)
    {
        WmipAssert(! (DataSource->Flags & FLAG_ENTRY_ON_INUSE_LIST));

        DataSource->Flags |= FLAG_ENTRY_ON_INUSE_LIST;
        InsertTailList(WmipDSHeadPtr, &DataSource->MainDSList);
    }

    return(STATUS_SUCCESS);
}

void WmipSendGuidUpdateNotifications(
    NOTIFICATIONTYPES NotificationType,
    ULONG GuidCount,
    PTRCACHE *GuidList
    )
{
    PUCHAR WnodeBuffer;
    PWNODE_SINGLE_INSTANCE Wnode;
    ULONG WnodeSize;
    LPGUID GuidPtr;
    ULONG i;
    PWCHAR InstanceName;
    PMSWmi_GuidRegistrationInfo RegInfo;
    ULONG DataBlockSize;
    GUID RegChangeGuid = MSWmi_GuidRegistrationInfoGuid;
#define REGUPDATENAME L"REGUPDATEINFO"

    PAGED_CODE();

    DataBlockSize = sizeof(MSWmi_GuidRegistrationInfo) +
                    GuidCount*sizeof(GUID) - sizeof(GUID);

    WnodeSize = sizeof(WNODE_SINGLE_INSTANCE) +
                sizeof(USHORT) + sizeof(REGUPDATENAME) + 8 + DataBlockSize;
    
    WnodeBuffer = WmipAlloc(WnodeSize);
    if (WnodeBuffer != NULL)
    {
        Wnode = (PWNODE_SINGLE_INSTANCE)WnodeBuffer;

        //
        // Setup a WNODE_SINGLE_INSTANCE event with the updated guid
        // registration information
        //
        memset(Wnode, 0, sizeof(WNODE_HEADER));
        Wnode->WnodeHeader.Guid = RegChangeGuid;
        Wnode->WnodeHeader.BufferSize = WnodeSize;
        Wnode->WnodeHeader.Flags = WNODE_FLAG_SINGLE_INSTANCE |
                                   WNODE_FLAG_EVENT_ITEM;
        Wnode->OffsetInstanceName = sizeof(WNODE_SINGLE_INSTANCE);
        Wnode->DataBlockOffset = ((Wnode->OffsetInstanceName +
                                   sizeof(USHORT) + sizeof(REGUPDATENAME) + 7) & ~7);
        Wnode->SizeDataBlock = DataBlockSize;

        InstanceName = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
        *InstanceName++ = sizeof(REGUPDATENAME);
        StringCbCopy(InstanceName, sizeof(REGUPDATENAME), REGUPDATENAME);

        RegInfo = (PMSWmi_GuidRegistrationInfo)OffsetToPtr(Wnode,
                                                       Wnode->DataBlockOffset);
        RegInfo->Operation = NotificationType; 
        RegInfo->GuidCount = GuidCount;
        
        GuidPtr = (LPGUID)RegInfo->GuidList;
        for (i = 0; i < GuidCount; i++)
        {
            *GuidPtr++ =  *GuidList[i].Guid;
        }

        WmipProcessEvent((PWNODE_HEADER)Wnode, TRUE, FALSE);

        WmipFree(WnodeBuffer);
    }

}


void WmipGenerateBinaryMofNotification(
    PBINSTANCESET BinaryMofInstanceSet,
    LPCGUID Guid        
    )
{
    PWNODE_SINGLE_INSTANCE Wnode;
    SIZE_T ImagePathLen, ResourceNameLen, InstanceNameLen, BufferSize;
    PWCHAR Ptr;
    ULONG i;
    HRESULT hr;

    PAGED_CODE();
    
    if (BinaryMofInstanceSet->Count == 0)
    {
        return;
    }

    for (i = 0; i < BinaryMofInstanceSet->Count; i++)
    {
        ImagePathLen = sizeof(USHORT);
        InstanceNameLen = (sizeof(USHORT) + 7) & ~7;

        if (BinaryMofInstanceSet->Flags & IS_INSTANCE_STATICNAMES)
        {
            ResourceNameLen = ((wcslen(BinaryMofInstanceSet->IsStaticNames->StaticNamePtr[i])+1) * sizeof(WCHAR)) + sizeof(USHORT);
        } else if (BinaryMofInstanceSet->Flags & IS_INSTANCE_BASENAME) {
            ResourceNameLen = (((wcslen(BinaryMofInstanceSet->IsBaseName->BaseName) +
                             MAXBASENAMESUFFIXLENGTH) * sizeof(WCHAR)) + sizeof(USHORT));
        } else {
            return;
        }

        BufferSize = FIELD_OFFSET(WNODE_SINGLE_INSTANCE, VariableData) +
                      InstanceNameLen +
                      ImagePathLen +
                      ResourceNameLen;

        Wnode = (PWNODE_SINGLE_INSTANCE)WmipAlloc(BufferSize);
        if (Wnode != NULL)
        {
            Wnode->WnodeHeader.BufferSize = (ULONG) BufferSize;
            Wnode->WnodeHeader.ProviderId = MOFEVENT_ACTION_BINARY_MOF;
            Wnode->WnodeHeader.Version = 1;
            Wnode->WnodeHeader.Linkage = 0;
            Wnode->WnodeHeader.Flags = (WNODE_FLAG_EVENT_ITEM |
                                        WNODE_FLAG_SINGLE_INSTANCE);
            memcpy(&Wnode->WnodeHeader.Guid,
                   Guid,
                   sizeof(GUID));
            WmiInsertTimestamp(&Wnode->WnodeHeader);
            Wnode->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                 VariableData);
            Wnode->DataBlockOffset = (ULONG)(Wnode->OffsetInstanceName + 
                                      InstanceNameLen);
            Wnode->SizeDataBlock = (ULONG)(ImagePathLen + ResourceNameLen);
            Ptr = (PWCHAR)&Wnode->VariableData;

            *Ptr++ = 0;              // Empty instance name
            
            Ptr = (PWCHAR)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
            *Ptr++ = 0;              // Empty image path

            // Instance name for binary mof resource
            ResourceNameLen -= sizeof(USHORT);
            if (BinaryMofInstanceSet->Flags & IS_INSTANCE_STATICNAMES)
            {
                *Ptr++ = (USHORT)ResourceNameLen;
                hr = StringCbCopy(Ptr,
                             ResourceNameLen,
                             BinaryMofInstanceSet->IsStaticNames->StaticNamePtr[i]);
                WmipAssert(hr == S_OK);
            } else if (BinaryMofInstanceSet->Flags & IS_INSTANCE_BASENAME) {
                hr = (USHORT)StringCbPrintfEx(Ptr+1,
                                                ResourceNameLen,
                                                NULL,
                                                NULL,
                                                STRSAFE_FILL_BEHIND_NULL,
                                                L"%ws%d",
                                                BinaryMofInstanceSet->IsBaseName->BaseName,
                                                BinaryMofInstanceSet->IsBaseName->BaseIndex+i) * sizeof(WCHAR);
                WmipAssert(hr == S_OK);
                *Ptr = (USHORT)ResourceNameLen;
            }

            WmipProcessEvent((PWNODE_HEADER)Wnode, TRUE, FALSE);
            WmipFree(Wnode);
        }
    }
}

void WmipGenerateMofResourceNotification(
    LPWSTR ImagePath,
    LPWSTR ResourceName,
    LPCGUID Guid,
    ULONG ActionCode
    )
{
    PWNODE_SINGLE_INSTANCE Wnode;
    SIZE_T ImagePathLen, ResourceNameLen, InstanceNameLen, BufferSize;
    PWCHAR Ptr;

    PAGED_CODE();

    ImagePathLen = (wcslen(ImagePath) + 2) * sizeof(WCHAR);

    ResourceNameLen = (wcslen(ResourceName) + 2) * sizeof(WCHAR);
    InstanceNameLen = ( sizeof(USHORT)+7 ) & ~7;
    BufferSize = FIELD_OFFSET(WNODE_SINGLE_INSTANCE, VariableData) +
                      InstanceNameLen +
                      ImagePathLen +
                      ResourceNameLen;

    Wnode = (PWNODE_SINGLE_INSTANCE)WmipAlloc(BufferSize);
    if (Wnode != NULL)
    {
        Wnode->WnodeHeader.BufferSize = (ULONG) BufferSize;
        Wnode->WnodeHeader.ProviderId = ActionCode;
        Wnode->WnodeHeader.Version = 1;
        Wnode->WnodeHeader.Linkage = 0;
        Wnode->WnodeHeader.Flags = (WNODE_FLAG_EVENT_ITEM |
                                    WNODE_FLAG_SINGLE_INSTANCE |
                                    WNODE_FLAG_INTERNAL);
        memcpy(&Wnode->WnodeHeader.Guid,
               Guid,
               sizeof(GUID));
        WmiInsertTimestamp(&Wnode->WnodeHeader);
        Wnode->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                 VariableData);
        Wnode->DataBlockOffset = (ULONG)(Wnode->OffsetInstanceName + InstanceNameLen);
        Wnode->SizeDataBlock = (ULONG)(ImagePathLen + ResourceNameLen);
        Ptr = (PWCHAR)&Wnode->VariableData;

        *Ptr = 0;              // Empty instance name

                                 // ImagePath name
        Ptr = (PWCHAR)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
        ImagePathLen -= sizeof(USHORT);
        *Ptr++ = (USHORT)ImagePathLen;
        memcpy(Ptr, ImagePath, ImagePathLen);
        Ptr += (ImagePathLen / sizeof(WCHAR));

                                 // MofResource Name
        ResourceNameLen -= sizeof(USHORT);
        *Ptr++ = (USHORT)ResourceNameLen;
        memcpy(Ptr, ResourceName, ResourceNameLen);

        WmipProcessEvent((PWNODE_HEADER)Wnode, TRUE, FALSE);
        WmipFree(Wnode);
    }
}

void WmipGenerateRegistrationNotification(
    PBDATASOURCE DataSource,
    NOTIFICATIONTYPES NotificationType
    )
{
    PTRCACHE *Guids;
    ULONG GuidCount, GuidMax;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    LPGUID Guid;

    PAGED_CODE();
    
    WmipReferenceDS(DataSource);

    //
    // Loop over all instance sets for this data source
    //
    GuidCount = 0;
    GuidMax = 0;
    Guids = NULL;
    InstanceSetList =  DataSource->ISHead.Flink;
    while (InstanceSetList != &DataSource->ISHead)
    {

        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        DSISList);

        //
        // Cache the guid and instance set so we can send registration
        // change notifications
        //
        Guid = &InstanceSet->GuidEntry->Guid;
        WmipCachePtrs(Guid,
                      InstanceSet,
                      &GuidCount,
                      &GuidMax,
                      &Guids);

        //
        // If we are adding a guid and it is already enabled then we
        // need to send an enable irp. Likewise if the guid is being
        // removed and is enabled then we need to send a disable
        //
        if (NotificationType == RegistrationAdd)
        {
            WmipEnableCollectionForNewGuid(Guid, InstanceSet);
        } else if (NotificationType == RegistrationDelete) {
            WmipDisableCollectionForRemovedGuid(Guid, InstanceSet);
        }

        InstanceSetList = InstanceSetList->Flink;
    }

    //
    // Send out event that informs about guid registration changes
    //
    WmipSendGuidUpdateNotifications(NotificationType,
                                    GuidCount,
                                    Guids);

    if (Guids != NULL)
    {
        WmipFree(Guids);
    }
    
    WmipUnreferenceDS(DataSource);
}

NTSTATUS WmipAddMofResource(
    PBDATASOURCE DataSource,
    LPWSTR ImagePath,
    BOOLEAN IsImagePath,
    LPWSTR MofResourceName,
    PBOOLEAN NewMofResource
    )
/*++

Routine Description:

    This routine will build MOFCLASSINFO structures for each guid that is 
    described in the MOF for the data source. If there are any errors in the
    mof resource then no mof information from the resource is retained and the
    resource data is unloaded. 

Arguments:

    DataSource is the data source structure of the data provider
        
    ImagePath points at a string that has the full path to the image
        file that contains the MOF resource
            
    MofResourceName points at a string that has the name of the MOF
        resource
        
Return Value:


--*/        
{
    PMOFRESOURCE MofResource;
    ULONG NewMofResourceCount;
    ULONG i;
    BOOLEAN FreeBuffer;
    size_t RegPathLen, ResNameLen;
    HRESULT hr;

    PAGED_CODE();
    
    MofResource = WmipFindMRByNames(ImagePath, 
                                    MofResourceName);
                     
    if (MofResource == NULL)
    {
        //
        // Mof Resource not previously specified, so allocate a new one
        MofResource = WmipAllocMofResource();
        if (MofResource == NULL)
        {    
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        if (IsImagePath)
        {
            MofResource->Flags |= MR_FLAG_USER_MODE;
        }

        RegPathLen = (wcslen(ImagePath)+1) * sizeof(WCHAR);
        MofResource->RegistryPath = WmipAlloc(RegPathLen);
        ResNameLen = (wcslen(MofResourceName) + 1) * sizeof(WCHAR);
        MofResource->MofResourceName = WmipAlloc(ResNameLen);

        if ((MofResource->RegistryPath == NULL) || 
            (MofResource->MofResourceName == NULL))
        {
            //
            // Allocation cleanup routine will free any memory allocated for MR
            WmipUnreferenceMR(MofResource);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    
        hr = StringCbCopy(MofResource->RegistryPath, RegPathLen, ImagePath);
        WmipAssert(hr == S_OK);
        hr = StringCbCopy(MofResource->MofResourceName, ResNameLen, MofResourceName);
        WmipAssert(hr == S_OK);

        WmipEnterSMCritSection();
        InsertTailList(WmipMRHeadPtr, &MofResource->MainMRList);
        WmipLeaveSMCritSection();
        *NewMofResource = TRUE;
    } else {
        *NewMofResource = FALSE;
    }
    
    if (DataSource != NULL)
    {
        WmipEnterSMCritSection();
        for (i = 0; i < DataSource->MofResourceCount; i++)
        {
            if (DataSource->MofResources[i] == MofResource)
            {
                //
                // If this mof resource is already been registered for
                // this data source then we do not need to worry about
                // it anymore.
                //
                WmipUnreferenceMR(MofResource);
                break;
            }
            
            if (DataSource->MofResources[i] == NULL)
            {
                DataSource->MofResources[i] = MofResource;
                break;
            }
        }
            
        if (i == DataSource->MofResourceCount)
        {
            NewMofResourceCount = DataSource->MofResourceCount + 
                                  AVGMOFRESOURCECOUNT;
            if (DataSource->MofResources != 
                     DataSource->StaticMofResources)
            {
                FreeBuffer = TRUE;
            } else {
                FreeBuffer = FALSE;
            }
        
            if (WmipRealloc((PVOID *)&DataSource->MofResources,
                         DataSource->MofResourceCount * sizeof(PMOFRESOURCE),
                         NewMofResourceCount * sizeof(PMOFRESOURCE),
                         FreeBuffer )  )
            {
                DataSource->MofResourceCount = NewMofResourceCount;
                DataSource->MofResources[i] = MofResource;
            }
        }
        WmipLeaveSMCritSection();
    }

    return(STATUS_SUCCESS);
}


NTSTATUS WmipAddDataSource(
    IN PREGENTRY RegEntry,
    IN PWMIREGINFOW WmiRegInfo,
    IN ULONG BufferSize,
    IN PWCHAR RegPath,
    IN PWCHAR ResourceName,
    IN PWMIGUIDOBJECT RequestObject,
    IN BOOLEAN IsUserMode
    )
/*+++

Routine Description:

    This routine will register a information in the WMI database for a 
    new DataSource or add additional guids to an existing data source.
        
Arguments:

    RegEntry is the regentry for the data provider
        
    WmiRegInfo is the registration information to register
        
    BufferSize is the size of WmiRegInfo in bytes
        
    RegPath is a pointer into WmiRegInfo to a counted string that is the 
        registry path (or image path for UM providers).
            
    ResourceName is a pointer into WmiRegInfo to a counted string that is the 
        resource name
            
    RequestObject is the request object associated with the UM provider.
        If this is NULL then the registration is for a driver
                        

Return Value:

    STATUS_SUCCESS or an error code

---*/
{
    PBDATASOURCE DataSource;
    PWMIREGGUID RegGuid;
    ULONG i;
    NTSTATUS Status, Status2;
    PBINSTANCESET InstanceSet;
    PBINSTANCESET BinaryMofInstanceSet = NULL;
    PWCHAR MofRegistryPath;
    PWCHAR MofResourceName;
    BOOLEAN AppendToDS;
    BOOLEAN NewMofResource;

    PAGED_CODE();    
    
    if (RegEntry->DataSource != NULL)
    {
        DataSource = RegEntry->DataSource;
        WmipAssert(DataSource != NULL);
        AppendToDS = TRUE;
    } else {
        DataSource = WmipAllocDataSource();
        AppendToDS = FALSE;
    }
    
    if (DataSource != NULL)
    {
        //
        // Loop over each guid being registered and build instance sets and
        // guid entries.
        //
        if (! AppendToDS)
        {
            DataSource->ProviderId = RegEntry->ProviderId;
            if (RequestObject != NULL)
            {
                DataSource->Flags |= DS_USER_MODE;
                DataSource->RequestObject = RequestObject;
            } else {
                DataSource->Flags |= DS_KERNEL_MODE;
            }
        
        }
    
        RegGuid = WmiRegInfo->WmiRegGuid;


        for (i = 0; i < WmiRegInfo->GuidCount; i++, RegGuid++)
        {
            if (! (RegGuid->Flags & WMIREG_FLAG_REMOVE_GUID))
            {

                //
                // Only trace control guids are registered. Trace transaction
                // guids will not be registered since they can not be enabled or
                // disabled individually. They will be kept on the ControlGuids'
                // instance set structure. 
                //

                if ( ( (RegGuid->Flags & WMIREG_FLAG_TRACED_GUID) != WMIREG_FLAG_TRACED_GUID ) || 
                       (RegGuid->Flags & WMIREG_FLAG_TRACE_CONTROL_GUID) )
                { 

                    //
                    // Allocate an instance set for this new set of instances
                    //
                    InstanceSet = WmipAllocInstanceSet();
                    if (InstanceSet == NULL)
                    {
                        WmipUnreferenceDS(DataSource);
                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: WmipAddDataSource: WmipAllocInstanceSet failed\n"));
                        return(STATUS_INSUFFICIENT_RESOURCES);
                    }

                    //
                    // We will allocate a proper guid entry for the instance 
                    // set when the data source gets linked into the main data 
                    // source list so we stash a pointer to the guid away now.
                    //
                    InstanceSet->GuidEntry = (PBGUIDENTRY)&RegGuid->Guid;

                    //
                    // Minimally initialize the InstanceSet and add it to 
                    // the DataSource's list of InstanceSets. We do this 
                    // first so that if there is any failure below and 
                    // the DataSource can'e be fully registered the instance 
                    // set and guid entry will be free when the DataSource is
                    // freed.
                    //
                    InstanceSet->DataSource = DataSource;
                    InstanceSet->Flags |= IS_NEWLY_REGISTERED;

                    Status = WmipBuildInstanceSet(RegGuid,
                                                  WmiRegInfo,
                                                  BufferSize,
                                                  InstanceSet,
                                                  RegEntry->ProviderId,
                                                  RegPath);

                    //
                    // If this is the guid that represents the binary mof data
                    // then remember the InstanceSet for  later
                    //
                    if (IsEqualGUID(&RegGuid->Guid, &WmipBinaryMofGuid))
                    {
                        BinaryMofInstanceSet = InstanceSet;
                    }


                    InsertHeadList(&DataSource->ISHead, &InstanceSet->DSISList);
  
                    if (! NT_SUCCESS(Status))
                    {
                        WmipUnreferenceDS(DataSource);
                        return(Status);
                    }
                }
            }
        }
        
        //
        // Now that the instance sets have been built successfully we 
        // can link them into the master list.
        //                        
        WmipEnterSMCritSection();
        Status = WmipLinkDataSourceToList(DataSource, (BOOLEAN)(! AppendToDS));
        WmipLeaveSMCritSection();

        if (! NT_SUCCESS(Status))
        {
            WmipUnreferenceDS(DataSource);
            return(Status);
        }
        
        RegEntry->DataSource = DataSource;
        
        //
        // We need to send out notification of new guids and mofs.
        //
        if (BinaryMofInstanceSet != NULL)
        {
            //
            // Send binary mof guid arrival notification
            //
            WmipGenerateBinaryMofNotification(BinaryMofInstanceSet,
                                      &GUID_MOF_RESOURCE_ADDED_NOTIFICATION);

        }

        //
        // Convert Registry path to a sz string so we can assign it to
        // the DS if the DS is a new one
        //
        if (RegPath != NULL)
        {
            MofRegistryPath = WmipCountedToSz(RegPath);
        } else {
            MofRegistryPath = NULL;
        }
        
        if ((AppendToDS == FALSE) && (MofRegistryPath != NULL))
        {
            DataSource->RegistryPath = MofRegistryPath;
        }
        
        if (ResourceName != NULL)
        {
            MofResourceName = WmipCountedToSz(ResourceName);        
        } else {
            MofResourceName = NULL;
        }
        
        //
        // Finally if we created a new data source we need to register
        // the mof for it. Only register those that have a RegistryPath
        // and a ResourceName
        //
        if ((MofRegistryPath != NULL) &&
            (*MofRegistryPath != 0) &&
            (MofResourceName != NULL) &&
            (*MofResourceName != 0))
        {
            //
            // If a mof is specified then add it to the list
            //
            Status2 = WmipAddMofResource(DataSource,
                                        MofRegistryPath,
                                        IsUserMode,
                                        MofResourceName, 
                                        &NewMofResource);
                                    
            if (NT_SUCCESS(Status2) && NewMofResource)
            {
                //
                // We successfully added a brand new MOF resource so
                // we need to fire an event for wbem.
                //
                WmipGenerateMofResourceNotification(MofRegistryPath,
                                                    MofResourceName,
                                      &GUID_MOF_RESOURCE_ADDED_NOTIFICATION,
                                      IsUserMode ?
                                             MOFEVENT_ACTION_IMAGE_PATH :
                                             MOFEVENT_ACTION_REGISTRY_PATH);
            }            
        }        
        
        //
        // Clean up registry path and mof resource name strings
        //
        if ((MofRegistryPath != NULL) && AppendToDS)
        {
            //
            // Only free if registry path not saved in DataSource
            //
            WmipAssert(MofRegistryPath != DataSource->RegistryPath);
            WmipFree(MofRegistryPath);
        }
        
        if (MofResourceName != NULL)
        {
            WmipFree(MofResourceName);
        }
        
        //
        // Send a notification about new/changed guids
        //
        WmipGenerateRegistrationNotification(DataSource,
                                             RegistrationAdd);
        
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return(Status);
}


PBINSTANCESET WmipFindISInDSByGuid(
    PBDATASOURCE DataSource,
    LPGUID Guid
    )
/*++

Routine Description:

    This routine will find the InstanceSet in the passed DataSource for the
    guid passed.

    This routine assumes that the SM critical section is held before it is
    called.

Arguments:

    DataSource is the data source from which the guid is to be removed

    Guid has the Guid for the InstanceSet to find

Return Value:

--*/
{
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;

    PAGED_CODE();
    
    InstanceSetList = DataSource->ISHead.Flink;
    while (InstanceSetList != &DataSource->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        DSISList);

        if ((InstanceSet->GuidEntry != NULL) &&
             (IsEqualGUID(Guid, &InstanceSet->GuidEntry->Guid)))
        {
            WmipReferenceIS(InstanceSet);
            return(InstanceSet);
        }

        InstanceSetList = InstanceSetList->Flink;
    }
    return(NULL);
}

ULONG WmipUpdateAddGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PWMIREGINFO WmiRegInfo,
    ULONG BufferSize,
    PBINSTANCESET *AddModInstanceSet
    )
/*++

Routine Description:

    This routine will add a new guid for the data source and send notification

    This routine assumes that the SM critical section is held before it is
    called.

Arguments:

    DataSource is the data source from which the guid is to be removed

    RegGuid has the Guid update data structure

    WmiRegInfo points at the beginning of the registration update info

Return Value:

    1 if guid was added or 0

--*/
{
    PBINSTANCESET InstanceSet;
    LPGUID Guid = &RegGuid->Guid;
    NTSTATUS Status;

    PAGED_CODE();
    
    //
    // Allocate an instance set for this new set of instances
    InstanceSet = WmipAllocInstanceSet();
    if (InstanceSet == NULL)
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: WmipUpdateAddGuid: WmipAllocInstanceSet failed\n"));
        return(0);
    }

    //
    // We will allocate a proper guid entry for the instance set when
    // the data source gets linked into the main data source list so
    // we stash a pointer to the guid away now.
    InstanceSet->GuidEntry = (PBGUIDENTRY)Guid;

    //
    // Minimally initialize the InstanceSet and add it to the DataSource's
    // list of InstanceSets. We do this first so that if there is any
    // failure below and the DataSource can'e be fully registered the
    // instance set and guid entry will be free when the DataSource is
    // freed.
    InstanceSet->DataSource = DataSource;
    InstanceSet->Flags |= IS_NEWLY_REGISTERED;

    InsertHeadList(&DataSource->ISHead, &InstanceSet->DSISList);

    Status = WmipBuildInstanceSet(RegGuid,
                                  WmiRegInfo,
                                  BufferSize,
                                  InstanceSet,
                                  DataSource->ProviderId,
                                  DataSource->RegistryPath);

    if (! NT_SUCCESS(Status))
    {
        WmipUnreferenceIS(InstanceSet);
        return(0);
    }

    Status = WmipLinkDataSourceToList(DataSource,
                                          FALSE);

    *AddModInstanceSet = InstanceSet;

    return( NT_SUCCESS(Status) ? 1 : 0);
}

#if DBG
PWCHAR GuidToString(
    PWCHAR s,
    ULONG SizeInBytes,
    LPGUID piid
    )
{
    HRESULT hr;
    
    PAGED_CODE();
    
    hr = StringCbPrintf(s, SizeInBytes, L"%x-%x-%x-%x%x%x%x%x%x%x%x",                   
               piid->Data1, piid->Data2,
               piid->Data3,
               piid->Data4[0], piid->Data4[1],
               piid->Data4[2], piid->Data4[3],
               piid->Data4[4], piid->Data4[5],
               piid->Data4[6], piid->Data4[7]);
    WmipAssert(hr == S_OK);

    return(s);
}
#endif


BOOLEAN WmipUpdateRemoveGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PBINSTANCESET *AddModInstanceSet
    )
/*++

Routine Description:

    This routine will remove the guid for the data source and send notification

    This routine assumes that the SM critical section is held before it is
    called.

Arguments:

    DataSource is the data source from which the guid is to be removed

    RegGuid has the Guid update data structure

Return Value:

    TRUE if guid was removed else FALSE

--*/
{
    PBINSTANCESET InstanceSet;
    LPGUID Guid = &RegGuid->Guid;
    BOOLEAN SendNotification;

    PAGED_CODE();
    
    InstanceSet = WmipFindISInDSByGuid(DataSource,
                                       Guid);
    if (InstanceSet != NULL)
    {
        WmipUnreferenceIS(InstanceSet);
        *AddModInstanceSet = InstanceSet;
        SendNotification = TRUE;
    } else {
#if DBG
        WCHAR s[256];
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: UpdateRemoveGuid %ws not registered by %ws\n",
                        GuidToString(s, sizeof(s), Guid), DataSource->RegistryPath));
#endif
        SendNotification = FALSE;
    }
    return(SendNotification);
}


BOOLEAN WmipIsEqualInstanceSets(
    PBINSTANCESET InstanceSet1,
    PBINSTANCESET InstanceSet2
    )
{
    ULONG i;
    ULONG Flags1, Flags2;

    PAGED_CODE();
    
    Flags1 = InstanceSet1->Flags & ~(IS_ENABLE_EVENT | IS_ENABLE_COLLECTION);
    Flags2 = InstanceSet2->Flags & ~(IS_ENABLE_EVENT | IS_ENABLE_COLLECTION);
    if (Flags1 == Flags2)
    {
        if (InstanceSet1->Flags & IS_INSTANCE_BASENAME)
        {
            if ((InstanceSet1->Count == InstanceSet2->Count) &&
                (wcscmp(InstanceSet1->IsBaseName->BaseName,
                        InstanceSet1->IsBaseName->BaseName) == 0))
            {
                return(TRUE);
            }
        } else if (InstanceSet1->Flags & IS_INSTANCE_STATICNAMES) {
            if (InstanceSet1->Count == InstanceSet2->Count)
            {
                for (i = 0; i < InstanceSet1->Count; i++)
                {
                    if (wcscmp(InstanceSet1->IsStaticNames->StaticNamePtr[i],
                               InstanceSet2->IsStaticNames->StaticNamePtr[i]) != 0)
                     {
                        return(FALSE);
                    }
                }
                return(TRUE);
            }
        } else {
            return(TRUE);
        }
    }

    return(FALSE);

}

ULONG WmipUpdateModifyGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PWMIREGINFO WmiRegInfo,
    ULONG BufferSize,
    PBINSTANCESET *AddModInstanceSet
    )
/*++

Routine Description:

    This routine will modify an existing guid for the data source and
    send notification

    This routine assumes that the SM critical section is held before it is
    called.


    If a guid was opened when it was registered as cheap, but closed
    when the guid was registered expensive a disable collection will
    NOT be sent. Conversely if a guid was opened when it was
    registered as expensive and is closed when registered as cheap a
    disable collection may be sent.

Arguments:

    DataSource is the data source from which the guid is to be removed

    RegGuid has the Guid update data structure

    WmiRegInfo points at the beginning of the registration update info

Return Value:

    1 if guid was added or 2 if guid was modified else 0

--*/
{
    PBINSTANCESET InstanceSet;
    LPGUID Guid = &RegGuid->Guid;
    ULONG SendNotification;
    PBINSTANCESET InstanceSetNew;
    PVOID ToFree;
    NTSTATUS Status;

    PAGED_CODE();
    
    InstanceSet = WmipFindISInDSByGuid(DataSource,
                                       Guid);
    if (InstanceSet != NULL)
    {
        //
        // See if anything has changed with the instance names and if not
        // then don't bother to recreate the instance set

        InstanceSetNew = WmipAllocInstanceSet();
        if (InstanceSetNew == NULL)
        {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: UpdateModifyGuid Not enough memory to alloc InstanceSet\n"));
            WmipUnreferenceIS(InstanceSet);
            return(0);
        }
    
        Status = WmipBuildInstanceSet(RegGuid,
                             WmiRegInfo,
                             BufferSize,
                             InstanceSetNew,
                             DataSource->ProviderId,
                             DataSource->RegistryPath);
                         
        if (NT_SUCCESS(Status))
        {
            if (! WmipIsEqualInstanceSets(InstanceSet,
                                          InstanceSetNew))
            {
                ToFree = NULL;
                if (InstanceSet->IsBaseName != NULL) {
                    ToFree = (PVOID)InstanceSet->IsBaseName;
                }

                RemoveEntryList(&InstanceSet->GuidISList);
                Status = WmipBuildInstanceSet(RegGuid,
                             WmiRegInfo,
                             BufferSize,
                             InstanceSet,
                             DataSource->ProviderId,
                             DataSource->RegistryPath);
                if (NT_SUCCESS(Status))
                {
                    InsertHeadList(&InstanceSet->GuidEntry->ISHead,
                               &InstanceSet->GuidISList);
                } else {
                    //
                    // It is sad, but we weren't able to rebuild the instance
                    // set so the old one is gone. This is an unlikely
                    // situation that can really only occur when the machine
                    // is out of memory.
                    //
                }

                if (ToFree != NULL)
                {
                    WmipFree(ToFree);
                }

                *AddModInstanceSet = InstanceSet;
                SendNotification = 2;
            } else {
                //
                // The InstanceSets are identical so just delete the new one
                SendNotification = 0;
            }
            
            WmipUnreferenceIS(InstanceSetNew);
            WmipUnreferenceIS(InstanceSet);
        } else {
            //
            // We could not parse the new instance set so leave the old
            // one alone
            //
            WmipUnreferenceIS(InstanceSet);
            WmipUnreferenceIS(InstanceSetNew);
            SendNotification = FALSE;
        }
    } else {
        //
        // Guid not already registered so try to add it
        SendNotification = WmipUpdateAddGuid(DataSource,
                          RegGuid,
                          WmiRegInfo,
                          BufferSize,
                          AddModInstanceSet);
    }
    return(SendNotification);
}


void WmipCachePtrs(
    LPGUID Ptr1,
    PBINSTANCESET Ptr2,
    ULONG *PtrCount,
    ULONG *PtrMax,
    PTRCACHE **PtrArray
    )
{
    PTRCACHE *NewPtrArray;
    PTRCACHE *OldPtrArray;
    PTRCACHE *ActualPtrArray;

    PAGED_CODE();
    
    if (*PtrCount == *PtrMax)
    {
        NewPtrArray = WmipAlloc((*PtrMax + PTRCACHEGROWSIZE) * sizeof(PTRCACHE));
        if (NewPtrArray != NULL)
        {
            OldPtrArray = *PtrArray;
            memcpy(NewPtrArray, OldPtrArray, *PtrMax * sizeof(PTRCACHE));
            *PtrMax += PTRCACHEGROWSIZE;
            if (*PtrArray != NULL)
            {
                WmipFree(*PtrArray);
            }
            *PtrArray = NewPtrArray;
        } else {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Couldn't alloc memory for pointer cache\n"));
            return;
        }
    }
    ActualPtrArray = *PtrArray;
    ActualPtrArray[*PtrCount].Guid = Ptr1;
    ActualPtrArray[*PtrCount].InstanceSet = Ptr2;
    (*PtrCount)++;
}



NTSTATUS WmipUpdateDataSource(
    PREGENTRY RegEntry,
    PWMIREGINFOW WmiRegInfo,
    ULONG RetSize
    )
/*++

Routine Description:

    This routine will update a data source with changes to already registered
    guids.

Arguments:

    ProviderId is the provider id of the DataSource whose guids are being
        updated.

    WmiRegInfo has the registration update information

    RetSize has the size of the registration information returned from
        kernel mode.

Return Value:


--*/
{
    PBDATASOURCE DataSource;
    PUCHAR RegInfo;
    ULONG RetSizeLeft;
    ULONG i;
    PWMIREGGUID RegGuid;
    ULONG NextWmiRegInfo;
    PTRCACHE *RemovedGuids;
    PTRCACHE *AddedGuids;
    PTRCACHE *ModifiedGuids;
    ULONG RemovedGuidCount;
    ULONG AddedGuidCount;
    ULONG ModifiedGuidCount;
    ULONG RemovedGuidMax;
    ULONG AddedGuidMax;
    ULONG ModifiedGuidMax;
    PBINSTANCESET InstanceSet;
    ULONG Action;

    PAGED_CODE();
    
    DataSource = RegEntry->DataSource;
    if (DataSource == NULL)
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: RegEntry %p requested update but is not registered\n",
                       RegEntry));
        return(STATUS_OBJECT_NAME_NOT_FOUND);
    }

    WmipReferenceDS(DataSource);
    AddedGuidCount = 0;
    ModifiedGuidCount = 0;
    RemovedGuidCount = 0;
    AddedGuidMax = 0;
    ModifiedGuidMax = 0;
    RemovedGuidMax = 0;
    ModifiedGuids = NULL;
    AddedGuids = NULL;
    RemovedGuids = NULL;

    NextWmiRegInfo = 0;
    RetSizeLeft = RetSize;
    WmipEnterSMCritSection();
    RegInfo = (PUCHAR)WmiRegInfo;
    for (i = 0; i < WmiRegInfo->GuidCount; i++)
    {
        RegGuid = &WmiRegInfo->WmiRegGuid[i];
        if (RegGuid->Flags & WMIREG_FLAG_REMOVE_GUID)
        {
            if (WmipUpdateRemoveGuid(DataSource,
                                         RegGuid,
                                         &InstanceSet))
            {
                WmipCachePtrs(&RegGuid->Guid,
                             InstanceSet,
                             &RemovedGuidCount,
                             &RemovedGuidMax,
                             &RemovedGuids);
            }
        } else  {
            Action = WmipUpdateModifyGuid(DataSource,
                                       RegGuid,
                                       WmiRegInfo,
                                       RetSize,
                                       &InstanceSet);
            if (Action == 1)
            {
                WmipCachePtrs(&RegGuid->Guid,
                                 InstanceSet,
                                 &AddedGuidCount,
                                 &AddedGuidMax,
                                 &AddedGuids);

            } else if (Action == 2) {
                WmipCachePtrs(&RegGuid->Guid,
                                 InstanceSet,
                                 &ModifiedGuidCount,
                                 &ModifiedGuidMax,
                                 &ModifiedGuids);
            }
        }
    }
    WmipLeaveSMCritSection();

    WmipUnreferenceDS(DataSource);

    if (RemovedGuidCount > 0)
    {
        for (i = 0; i < RemovedGuidCount; i++)
        {
            if (IsEqualGUID(RemovedGuids[i].Guid,
                            &WmipBinaryMofGuid))
            {
                WmipGenerateBinaryMofNotification(RemovedGuids[i].InstanceSet,
                                     &GUID_MOF_RESOURCE_REMOVED_NOTIFICATION);
            }
                
            InstanceSet = RemovedGuids[i].InstanceSet;

            WmipDisableCollectionForRemovedGuid(RemovedGuids[i].Guid,
                                                InstanceSet);

            WmipEnterSMCritSection();
            //
            // If IS is on the GE list then remove it
            if (InstanceSet->GuidISList.Flink != NULL)
            {
                RemoveEntryList(&InstanceSet->GuidISList);
                InstanceSet->GuidEntry->ISCount--;
            }

            if (! (InstanceSet->Flags & IS_NEWLY_REGISTERED))
            {
                WmipUnreferenceGE(InstanceSet->GuidEntry);
            }

            InstanceSet->GuidEntry = NULL;

            //
            // Remove IS from the DS List
            RemoveEntryList(&InstanceSet->DSISList);
            WmipUnreferenceIS(InstanceSet);
            WmipLeaveSMCritSection();
        }

        WmipSendGuidUpdateNotifications(RegistrationDelete,
                                    RemovedGuidCount,
                                    RemovedGuids);
        WmipFree(RemovedGuids);
    }

    if (ModifiedGuidCount > 0)
    {
        for (i = 0; i < ModifiedGuidCount; i++)
        {
            if (IsEqualGUID(ModifiedGuids[i].Guid,
                            &WmipBinaryMofGuid))
            {
                WmipGenerateBinaryMofNotification(ModifiedGuids[i].InstanceSet,
                                      &GUID_MOF_RESOURCE_ADDED_NOTIFICATION);
            }
        }
        
        WmipSendGuidUpdateNotifications(RegistrationUpdate,
                                    ModifiedGuidCount,
                                    ModifiedGuids);
        WmipFree(ModifiedGuids);
    }

    if (AddedGuidCount > 0)
    {
        for (i = 0; i < AddedGuidCount; i++)
        {
            if (IsEqualGUID(AddedGuids[i].Guid,
                            &WmipBinaryMofGuid))
            {
                WmipGenerateBinaryMofNotification(AddedGuids[i].InstanceSet,
                                      &GUID_MOF_RESOURCE_ADDED_NOTIFICATION);
            }
                
            WmipEnableCollectionForNewGuid(AddedGuids[i].Guid,
                                           AddedGuids[i].InstanceSet);
        }
        WmipSendGuidUpdateNotifications(RegistrationAdd,
                                    AddedGuidCount,
                                    AddedGuids);
        WmipFree(AddedGuids);
    }
    return(STATUS_SUCCESS);
}

void WmipRemoveDataSourceByDS(
    PBDATASOURCE DataSource
    )
{    

    PAGED_CODE();
    
    WmipGenerateRegistrationNotification(DataSource,
                                         RegistrationDelete);

    WmipUnreferenceDS(DataSource);
}

NTSTATUS WmipRemoveDataSource(
    PREGENTRY RegEntry
    )
{
    PBDATASOURCE DataSource;
    NTSTATUS Status;

    PAGED_CODE();
    
    DataSource = RegEntry->DataSource;
    if (DataSource != NULL)
    {
        WmipReferenceDS(DataSource);
        WmipRemoveDataSourceByDS(DataSource);
        WmipUnreferenceDS(DataSource);
        Status = STATUS_SUCCESS;
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Attempt to remove non existent data source %p\n",
                        RegEntry));
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
    }
    return(Status);
}


NTSTATUS WmipEnumerateMofResources(
    PWMIMOFLIST MofList,
    ULONG BufferSize,
    ULONG *RetSize
    )
{
    PLIST_ENTRY MofResourceList;
    PMOFRESOURCE MofResource;
    ULONG MRCount;
    SIZE_T SizeNeeded, MRSize;
    PWMIMOFENTRY MofEntry;
    PWCHAR MRBuffer;
    ULONG i;
    HRESULT hr;

    PAGED_CODE();
    
    WmipEnterSMCritSection();

    MRCount = 0;
    SizeNeeded = 0;
    MofResourceList = WmipMRHeadPtr->Flink;
    while (MofResourceList != WmipMRHeadPtr)
    {
        MofResource = CONTAINING_RECORD(MofResourceList,
                                      MOFRESOURCE,
                                      MainMRList);
                                  
        MRCount++;
        SizeNeeded += (wcslen(MofResource->RegistryPath) + 
                       wcslen(MofResource->MofResourceName) + 2) * 
                           sizeof(WCHAR);
                                  
        MofResourceList = MofResourceList->Flink;
    }
    
    if (MRCount != 0)
    {
        MRSize = sizeof(WMIMOFLIST) + ((MRCount-1) * sizeof(WMIMOFENTRY));
        SizeNeeded += MRSize;
        
        if (BufferSize >= SizeNeeded)
        {
            MofList->MofListCount = MRCount;
            MofResourceList = WmipMRHeadPtr->Flink;
            i = 0;
            while (MofResourceList != WmipMRHeadPtr)
            {
                MofResource = CONTAINING_RECORD(MofResourceList,
                                      MOFRESOURCE,
                                      MainMRList);
                
                MofEntry = &MofList->MofEntry[i++];
                MofEntry->Flags = MofResource->Flags & MR_FLAG_USER_MODE ? 
                                                  WMIMOFENTRY_FLAG_USERMODE : 
                                                  0;
                                                  
                MofEntry->RegPathOffset = (ULONG) MRSize;
                MRBuffer = (PWCHAR)OffsetToPtr(MofList, MRSize);
                hr = StringCbCopy(MRBuffer,
                                  (BufferSize - MRSize),
                                  MofResource->RegistryPath);
                WmipAssert(hr == S_OK);             
                MRSize += (wcslen(MofResource->RegistryPath) + 1) * sizeof(WCHAR);
                
                MofEntry->ResourceOffset = (ULONG) MRSize;
                MRBuffer = (PWCHAR)OffsetToPtr(MofList, MRSize);
                hr = StringCbCopy(MRBuffer,
                                  (BufferSize - MRSize),
                                  MofResource->MofResourceName);
                WmipAssert(hr == S_OK);             
                MRSize += (wcslen(MofResource->MofResourceName) + 1) * sizeof(WCHAR);
                MofResourceList = MofResourceList->Flink;
            }           
        } else {
            //
            // Buffer not large enough, return size needed
            //
            MofList->MofListCount = (ULONG) SizeNeeded;
            *RetSize = sizeof(ULONG);
        }
        
    } else {
        //
        // No mof resources
        //
        MofList->MofListCount = 0;
        *RetSize = sizeof(WMIMOFLIST);
    }
    
    
    WmipLeaveSMCritSection();
    return(STATUS_SUCCESS);
}


NTSTATUS WmipInitializeDataStructs(
    void
)
/*++

Routine Description:

    This routine will do the work of initializing the WMI service

Arguments:

Return Value:

    Error status value
        
--*/
{
    ULONG Status;
    GUID InstanceInfoGuid = INSTANCE_INFO_GUID;
    GUID EnumerateGuidsGuid = ENUMERATE_GUIDS_GUID;
    PREGENTRY RegEntry;
    PDEVICE_OBJECT Callback;
    PLIST_ENTRY GuidEntryList;
    PBGUIDENTRY GuidEntry;
    BOOLEAN NewResource;

    union {
        WMIREGINFOW Info;
        UCHAR Buffer[sizeof(WMIREGINFOW) + (2 * sizeof(WMIREGGUIDW))];
    } WmiReg;

    PAGED_CODE();
    
    //
    // Initialize the various data structure lists that we maintain
    //
    WmipDSHeadPtr = &WmipDSHead;
    InitializeListHead(WmipDSHeadPtr);
    InitializeListHead(&WmipDSChunkInfo.ChunkHead);

    WmipGEHeadPtr = &WmipGEHead;
    InitializeListHead(WmipGEHeadPtr);
    InitializeListHead(&WmipGEChunkInfo.ChunkHead);

    WmipMRHeadPtr = &WmipMRHead;
    InitializeListHead(WmipMRHeadPtr);
    InitializeListHead(&WmipMRChunkInfo.ChunkHead);

    InitializeListHead(&WmipISChunkInfo.ChunkHead);

  
    //      
    // Register any internal data provider guids and mark them as such
    //
    Callback = (PDEVICE_OBJECT)(ULONG_PTR) WmipUMProviderCallback;
    
    //
    // Establish a regentry for the data provider
    //
    RegEntry = WmipAllocRegEntry(Callback,
                                 WMIREG_FLAG_CALLBACK |
                                 REGENTRY_FLAG_TRACED |
                                 REGENTRY_FLAG_NEWREGINFO | 
                                 REGENTRY_FLAG_INUSE |
                                 REGENTRY_FLAG_REG_IN_PROGRESS);
                             
    if (RegEntry != NULL)
    {
        //
        // This code assumes that no other data providers have
        // yet registered.
        //
        WmipAssert(WmipGEHeadPtr->Flink == WmipGEHeadPtr);
                
        RtlZeroMemory(&WmiReg, sizeof(WmiReg));

        WmiReg.Info.BufferSize = sizeof(WmiReg.Buffer);
        WmiReg.Info.GuidCount = 2;
        WmiReg.Info.WmiRegGuid[0].Guid = InstanceInfoGuid;
        WmiReg.Info.WmiRegGuid[1].Guid = EnumerateGuidsGuid;
        
        Status = WmipAddDataSource(RegEntry,
                                   &WmiReg.Info,
                                   WmiReg.Info.BufferSize,
                                   NULL,
                                   NULL,
                                   NULL,
                                   FALSE);
                           
        if (NT_SUCCESS(Status))
        {                          
            GuidEntryList = WmipGEHeadPtr->Flink;
            while (GuidEntryList != WmipGEHeadPtr)
            {   
                GuidEntry = CONTAINING_RECORD(GuidEntryList,
                                              GUIDENTRY,
                                             MainGEList);

                GuidEntry->Flags |= GE_FLAG_INTERNAL;
        
                GuidEntryList = GuidEntryList->Flink;       
            }
        } else {
            RegEntry->Flags |= (REGENTRY_FLAG_RUNDOWN | 
                                    REGENTRY_FLAG_NOT_ACCEPTING_IRPS);
            WmipUnreferenceRegEntry(RegEntry);
        }
        
        Status = WmipAddMofResource(RegEntry->DataSource,
                                    WMICOREIMAGEPATH,
                                    TRUE,
                                    WMICORERESOURCENAME,
                                    &NewResource);
        WmipAssert(NewResource);
    }
    
        
    return(STATUS_SUCCESS);
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\notify.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    notify.c

Abstract:

    Manages KM to UM notification queue

--*/

#include "wmikmp.h"


void WmipInitializeNotifications(
    void
    );

void WmipEventNotification(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,WmipInitializeNotifications)
#pragma alloc_text(PAGE,WmipEventNotification)
#endif

WORK_QUEUE_ITEM WmipEventWorkQueueItem;
LIST_ENTRY WmipNPEvent = {&WmipNPEvent, &WmipNPEvent};
KSPIN_LOCK WmipNPNotificationSpinlock;
LONG WmipEventWorkItems;
#if DBG
ULONG WmipNPAllocFail;
#endif

void WmipInitializeNotifications(
    void
    )
{
    PAGED_CODE();
    
    ExInitializeWorkItem( &WmipEventWorkQueueItem,
                          WmipEventNotification,
                          NULL );

    KeInitializeSpinLock(&WmipNPNotificationSpinlock);

}

void WmipEventNotification(
    IN PVOID Context
    )
/*++

Routine Description:

    Work item routine to call WmipNotifyUserMode on behalf of an event fired
    by a driver

Arguments:

    Context is not used

Return Value:


--*/
{
    PWNODE_HEADER WnodeEventItem;
    PLIST_ENTRY NotificationPacketList;
	PEVENTWORKCONTEXT EventContext;

    PAGED_CODE();
    
    UNREFERENCED_PARAMETER (Context);

    do
    {
        NotificationPacketList = ExInterlockedRemoveHeadList(
            &WmipNPEvent,
            &WmipNPNotificationSpinlock);

        WmipAssert(NotificationPacketList != NULL);

		EventContext = (PEVENTWORKCONTEXT)
                         CONTAINING_RECORD(NotificationPacketList,
                         EVENTWORKCONTEXT,
                         ListEntry);
		
        WnodeEventItem = EventContext->Wnode;

        //
        // Restore the Wnode->Version from ->ClientContext
        //
        WnodeEventItem->Version = WnodeEventItem->ClientContext;
        WnodeEventItem->ClientContext = 0;
        WnodeEventItem->Linkage = 0;

        WmipProcessEvent(WnodeEventItem,
                         FALSE,
                         TRUE);

        if (EventContext->RegEntry != NULL)
        {
            //
            // Unref for the ref count taken in IoWMIWriteEvent
            //
            WmipUnreferenceRegEntry(EventContext->RegEntry);
        }

		ExFreePool(EventContext);
    } while (InterlockedDecrement(&WmipEventWorkItems));

}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\provider.c ===
/*++                 

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    provider.c

Abstract:
    
    This module registers all of the firmware providers supported by the
    kernel.

--*/

#include "wmikmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,WmipRegisterFirmwareProviders)
#endif

NTSTATUS
__cdecl
WmipRawSMBiosTableHandler(
    PSYSTEM_FIRMWARE_TABLE_INFORMATION TableInfo
    );

NTSTATUS
__cdecl
WmipFirmwareTableHandler(
    PSYSTEM_FIRMWARE_TABLE_INFORMATION TableInfo
    );

VOID
WmipRegisterFirmwareProviders(
                             )
/*++

Routine Description:

    This routine is called to register the correct set of data providers
    with the Executive part of the kernel.
    
    Currently, the SMBIOS raw provider is supported on all platforms. 
    The Firmware provider is only supported on X86 and X64.
    
Arguments:

    None
    
Return Value:

    None         

--*/ {
    SYSTEM_FIRMWARE_TABLE_HANDLER   TableHandler;

    //
    // Register the SMBIOS raw provider.
    //
    TableHandler.ProviderSignature = 'RSMB';    // (Raw SMBIOS)
    TableHandler.Register = TRUE;
    TableHandler.FirmwareTableHandler = &WmipRawSMBiosTableHandler;
    TableHandler.DriverObject = IoPnpDriverObject;
    NtSetSystemInformation(
        SystemRegisterFirmwareTableInformationHandler,
        (PVOID) &TableHandler,
        sizeof(SYSTEM_FIRMWARE_TABLE_HANDLER)
        );

#if defined(_X86_) || defined(_AMD64_)
    //
    // Register the Firmware provider.
    //
    TableHandler.ProviderSignature = 'FIRM';    // (Firmware)
    TableHandler.Register = TRUE;
    TableHandler.FirmwareTableHandler = &WmipFirmwareTableHandler;
    TableHandler.DriverObject = IoPnpDriverObject;
    NtSetSystemInformation(
        SystemRegisterFirmwareTableInformationHandler,
        (PVOID) &TableHandler,
        sizeof(SYSTEM_FIRMWARE_TABLE_HANDLER)
        );
#endif
}

//
// This array defines the legal ranges of memory that can be returned by 
// the FirmwareTableHandler. The format is starting address and length.
//
// Addresses over 4 gigabytes are specifically not included.
//
ULONG   WmipFirmwareTableArray[] = {
    0xC0000,    0x20000,        // Option ROM => C:0000 - D:FFFF
    0xE0000,    0x20000,        // System ROM => E:0000 - F:FFFF
};

NTSTATUS
__cdecl
WmipFirmwareTableHandler(
    PSYSTEM_FIRMWARE_TABLE_INFORMATION TableInfo
    )
/*++

Routine Description:

    This routine handles request for firmware information. 
    
    Currently, the only requested range is the E0000-FFFFF range, but
    we also support handing back the C0000-DFFFF range.
    
Arguments:

     TableInfo  - Information about the request
     
Return Value:

    NTSTATUS        

--*/ {
    PULONG              Buffer;
    PHYSICAL_ADDRESS    Address;
    PCHAR               Firmware;
    ULONG               TableCount;
    ULONG               TableIndex = 0;
    ULONG               TableSize = 0;
    ULONG               i,j;

    ASSERT( TableInfo != NULL );

    if (TableInfo == NULL) {
        return STATUS_INVALID_PARAMETER_1;
    }

    //
    // Calculate the number of tables supported and their length.
    //
    TableCount = sizeof(WmipFirmwareTableArray) / (sizeof(ULONG) * 2);

    //
    // Handle the enumeration case.
    //
    if (TableInfo->Action == SystemFirmwareTable_Enumerate) {

        //
        // We only handle the enumerate of one table.
        //
        TableSize = TableCount * sizeof(ULONG);
        if (TableInfo->TableBufferLength < TableSize) {

            TableInfo->TableBufferLength = TableSize;
            return STATUS_BUFFER_TOO_SMALL;

        }
        TableInfo->TableBufferLength = TableSize;

        //
        // Fill in the starting address so that they can be used as "IDs".
        //
        Buffer = (PULONG) TableInfo->TableBuffer;
        for (i = j = 0; i < TableCount; i++, j += 2) {

            Buffer[i] = WmipFirmwareTableArray[j];

        }
        return STATUS_SUCCESS;

    }

    ASSERT(TableInfo->Action == SystemFirmwareTable_Get);
    if (TableInfo->Action != SystemFirmwareTable_Get) {

        return STATUS_INVALID_PARAMETER_1;

    }

    //
    // Make sure that the length field is correct and that the
    // ID requested matches one of the supported starting addresses.
    //
    TableIndex = TableCount;
    for (i = j = 0; i < TableCount; i++, j += 2) {

        //
        // Determine if the starting location matches the specified ID.
        // If it doesn't, then no match exits.
        //
        if (WmipFirmwareTableArray[j] != TableInfo->TableID) {

            continue;

        }

        //
        // We have a match, so check the size.
        //
        TableSize = WmipFirmwareTableArray[j+1];
        if (TableInfo->TableBufferLength < WmipFirmwareTableArray[j+1]) {

            TableInfo->TableBufferLength = TableSize;
            return STATUS_BUFFER_TOO_SMALL;

        }
        TableInfo->TableBufferLength = TableSize;

        //
        // Remember what the matching index for the table is.
        //
        TableIndex = j;
        break;

    }

    //
    // If we failed to find a match, than abort.
    //
    if (i == TableCount) {

        return STATUS_INVALID_PARAMETER_1;

    }

    //
    // Map in the relevant window.
    //
    Address.QuadPart = WmipFirmwareTableArray[TableIndex];
    Firmware = MmMapIoSpace( Address, TableSize, MmNonCached );
    if (Firmware == NULL) {

        return STATUS_NOT_FOUND;

    }

    //
    // Copy the buffer.
    //
    RtlCopyMemory( TableInfo->TableBuffer, Firmware, TableSize );

    //
    // Unamp the firmware pointer.
    //
    MmUnmapIoSpace( Firmware, TableSize );
    return STATUS_SUCCESS;
}

NTSTATUS
__cdecl
WmipRawSMBiosTableHandler(
    PSYSTEM_FIRMWARE_TABLE_INFORMATION TableInfo
    )
/*++

Routine Description:

    This routine handles request for raw SMBIOS information. 
    
    Currently, this returns a single table.
    
Arguments:

     TableInfo  - Information about the request
     
Return Value:

    NTSTATUS        

--*/ {
    NTSTATUS            status;
    PUCHAR              Buffer = NULL;
    PUCHAR              SMBios = NULL;
    PSMBIOSVERSIONINFO  VersionInfo = NULL;
    PULONG              TableSizePtr = NULL;
    ULONG               HeaderSize = 0;
    ULONG               SizeNeeded = 0;
    ULONG               TableSize = 0;
    ASSERT( TableInfo != NULL );

    if (TableInfo == NULL) {

        return STATUS_INVALID_PARAMETER_1;

    }

    if (TableInfo->Action == SystemFirmwareTable_Enumerate) {

        //
        // We only handle the enumerate of one table.
        //
        if (TableInfo->TableBufferLength < sizeof(ULONG)) {

            TableInfo->TableBufferLength = sizeof(ULONG);
            return STATUS_BUFFER_TOO_SMALL;

        }
        TableInfo->TableBufferLength = sizeof(ULONG);

        //
        // The "TableID" of the only table is '0'. Make sure that we
        // indicate that only one table exists.
        //
        TableSizePtr = (PULONG) TableInfo->TableBuffer;
        TableSizePtr[0] = 0;
        return STATUS_SUCCESS;
    }

    ASSERT(TableInfo->Action == SystemFirmwareTable_Get);
    if (TableInfo->Action != SystemFirmwareTable_Get) {

        return STATUS_INVALID_PARAMETER_1;

    }

    //
    // Calculate the amount of space required.
    //
    status = WmipGetSMBiosTableData( NULL, &TableSize, NULL );
    if (status != STATUS_BUFFER_TOO_SMALL || TableSize == 0) {

        TableInfo->TableBufferLength = 0;
        return status;

    }
    HeaderSize = sizeof(SMBIOSVERSIONINFO) + sizeof(ULONG);
    SizeNeeded = HeaderSize + TableSize;

    //
    // If the caller didn't provide enough memory, then fail the call.
    //
    if (TableInfo->TableBufferLength < SizeNeeded) {

        TableInfo->TableBufferLength = SizeNeeded;
        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    // Setup all the pointers that we will need for getting a real copy
    // of the tables.
    //
    Buffer = (PUCHAR) TableInfo->TableBuffer;
    VersionInfo = (PSMBIOSVERSIONINFO) Buffer;
    TableSizePtr = (PULONG) (Buffer + sizeof(SMBIOSVERSIONINFO));
    SMBios = Buffer + HeaderSize;

    //
    // Get the full copy of the tables this time around.
    //
    status = WmipGetSMBiosTableData( SMBios, &TableSize, VersionInfo );
    if (NT_SUCCESS(status)) {

        *TableSizePtr = TableSize;

    }
    TableInfo->TableBufferLength = HeaderSize + TableSize;
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\secure.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Secure.c

Abstract:

    Security implementation for WMI objects

    WMI security is guid based, that is each guid can be assigned a security
    descriptor. There is also a default security descriptor that applies
    to any guid that does not have its own specific security descriptor.
    Security is enforced by relying upon the object manager. We define the
    WmiGuid object type and require all WMI requests to have a handle to the
    WmiGuid object. In this way the guid is opened with a specific ACCESS_MASK
    and if the caller is permitted those rights (as specified in the specific
    or default security descriptor) then a handle is returned. When the
    caller wants to do an operation he must pass the handle and before the
    operation is performed we check that the handle has the allowed access.

    Guid security descriptors are serialized as REG_BINARY values under the
    registry key HKLM\CurrentControlSet\Control\Wmi\Security. If no specific
    or default security descriptor for a guid exists then the all access
    is available for anyone. For this reason this registry key must be
    protected.

    WMI implements its own security method for the WmiGuid object type to
    allow it to intercept any changes to an objects security descriptor. By
    doing this we allow the standard security apis
    (Get/SetKernelObjectSecurity) to query and set the WMI security
    descriptors.

    A guid security descriptor contains the following specific rights:

        WMIGUID_QUERY                 0x0001
        WMIGUID_SET                   0x0002
        WMIGUID_NOTIFICATION          0x0004
        WMIGUID_READ_DESCRIPTION      0x0008
        WMIGUID_EXECUTE               0x0010
        TRACELOG_CREATE_REALTIME      0x0020
        TRACELOG_CREATE_ONDISK        0x0040
        TRACELOG_GUID_ENABLE          0x0080
        TRACELOG_ACCESS_KERNEL_LOGGER 0x0100
--*/


#include "strsafe.h"
#include "wmikmp.h"

NTSTATUS
WmipSecurityMethod (
    IN PVOID Object,
    IN SECURITY_OPERATION_CODE OperationCode,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG CapturedLength,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    );

VOID WmipDeleteMethod(
    IN  PVOID   Object
    );

VOID WmipCloseMethod(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    );

NTSTATUS
WmipSaveGuidSecurityDescriptor(
    PUNICODE_STRING GuidName,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSTATUS
WmipSDRegistryQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
WmipCreateGuidObject(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN LPGUID Guid,
    OUT PHANDLE CreatorHandle,
    OUT PWMIGUIDOBJECT *Object
    );

NTSTATUS
WmipUuidFromString (
    IN PWCHAR StringUuid,
    OUT LPGUID Uuid
    );

BOOLEAN
WmipHexStringToDword(
    IN PWCHAR lpsz,
    OUT PULONG RetValue,
    IN ULONG cDigits,
    IN WCHAR chDelim
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,WmipInitializeSecurity)
#pragma alloc_text(INIT,WmipCreateAdminSD)

#pragma alloc_text(PAGE,WmipGetGuidSecurityDescriptor)
#pragma alloc_text(PAGE,WmipSaveGuidSecurityDescriptor)
#pragma alloc_text(PAGE,WmipOpenGuidObject)
#pragma alloc_text(PAGE,WmipCheckGuidAccess)
#pragma alloc_text(PAGE,WmipSDRegistryQueryRoutine)
#pragma alloc_text(PAGE,WmipSecurityMethod)
#pragma alloc_text(PAGE,WmipDeleteMethod)
#pragma alloc_text(PAGE,WmipCreateGuidObject)
#pragma alloc_text(PAGE,WmipUuidFromString)
#pragma alloc_text(PAGE,WmipHexStringToDword)
#pragma alloc_text(PAGE,WmipCloseMethod)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#pragma data_seg("PAGEDATA")
#endif
//
// Subject context for the System process, captured at boot
SECURITY_SUBJECT_CONTEXT WmipSystemSubjectContext;

//
// Object type object created by Ob when registering WmiGuid object type
POBJECT_TYPE WmipGuidObjectType;

//
// SD attached to a guid when no specific or default SD exists in the
// registry. Created at boot, it allows all WMI access to WORLD and full
// access to System and Administrators group.
SECURITY_DESCRIPTOR WmipDefaultAccessSecurityDescriptor;
PSECURITY_DESCRIPTOR WmipDefaultAccessSd;

//
// Generic mapping for specific rights
const GENERIC_MAPPING WmipGenericMapping =
{
                                  // GENERIC_READ <--> WMIGUID_QUERY
        WMIGUID_QUERY,
                                  // GENERIC_WRUTE <--> WMIGUID_SET
        WMIGUID_SET,
                                  // GENERIC_EXECUTE <--> WMIGUID_EXECUTE
        WMIGUID_EXECUTE,
    WMIGUID_ALL_ACCESS | STANDARD_RIGHTS_READ
};


NTSTATUS
WmipSecurityMethod (
    IN PVOID Object,
    IN SECURITY_OPERATION_CODE OperationCode,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG CapturedLength,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    This is the WMI security method for objects.  It is responsible
    for either retrieving, setting, and deleting the security descriptor of
    an object.  It is not used to assign the original security descriptor
    to an object (use SeAssignSecurity for that purpose).


    IT IS ASSUMED THAT THE OBJECT MANAGER HAS ALREADY DONE THE ACCESS
    VALIDATIONS NECESSARY TO ALLOW THE REQUESTED OPERATIONS TO BE PERFORMED.

    This code stolen directly from SeDefaultObjectMethod in
    \nt\private\ntos\se\semethod.c. It does not do anything special except
    serialize any SD that is being set for an object.

Arguments:

    Object - Supplies a pointer to the object being used.

    OperationCode - Indicates if the operation is for setting, querying, or
        deleting the object's security descriptor.

    SecurityInformation - Indicates which security information is being
        queried or set.  This argument is ignored for the delete operation.

    SecurityDescriptor - The meaning of this parameter depends on the
        OperationCode:

        QuerySecurityDescriptor - For the query operation this supplies the
            buffer to copy the descriptor into.  The security descriptor is
            assumed to have been probed up to the size passed in in Length.
            Since it still points into user space, it must always be
            accessed in a try clause in case it should suddenly disappear.

        SetSecurityDescriptor - For a set operation this supplies the
            security descriptor to copy into the object.  The security
            descriptor must be captured before this routine is called.

        DeleteSecurityDescriptor - It is ignored when deleting a security
            descriptor.

        AssignSecurityDescriptor - For assign operations this is the
            security descriptor that will be assigned to the object.
            It is assumed to be in kernel space, and is therefore not
            probed or captured.

    CapturedLength - For the query operation this specifies the length, in
        bytes, of the security descriptor buffer, and upon return contains
        the number of bytes needed to store the descriptor.  If the length
        needed is greater than the length supplied the operation will fail.
        It is ignored in the set and delete operation.

        This parameter is assumed to be captured and probed as appropriate.

    ObjectsSecurityDescriptor - For the Set operation this supplies the address
        of a pointer to the object's current security descriptor.  This routine
        will either modify the security descriptor in place or allocate a new
        security descriptor and use this variable to indicate its new location.
        For the query operation it simply supplies the security descriptor
        being queried.  The caller is responsible for freeing the old security
        descriptor.

    PoolType - For the set operation this specifies the pool type to use if
        a new security descriptor needs to be allocated.  It is ignored
        in the query and delete operation.

        the mapping of generic to specific/standard access types for the object
        being accessed.  This mapping structure is expected to be safe to
        access (i.e., captured if necessary) prior to be passed to this routine.

Return Value:

    NTSTATUS - STATUS_SUCCESS if the operation is successful and an
        appropriate error status otherwise.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    //
    // If the object's security descriptor is null, then object is not
    // one that has security information associated with it.  Return
    // an error.
    //

    //
    //  Make sure the common parts of our input are proper
    //

    ASSERT( (OperationCode == SetSecurityDescriptor) ||
            (OperationCode == QuerySecurityDescriptor) ||
            (OperationCode == AssignSecurityDescriptor) ||
            (OperationCode == DeleteSecurityDescriptor) );

    //
    //  This routine simply cases off of the operation code to decide
    //  which support routine to call
    //

    switch (OperationCode) {

        case SetSecurityDescriptor:
        {
            UNICODE_STRING GuidName;
            WCHAR GuidBuffer[38];
            LPGUID Guid;
            SECURITY_INFORMATION LocalSecInfo;
            PSECURITY_DESCRIPTOR SecurityDescriptorCopy;
            ULONG SecurityDescriptorLength;
            NTSTATUS Status2;

            ASSERT( (PoolType == PagedPool) || (PoolType == NonPagedPool) );

            Status = ObSetSecurityDescriptorInfo( Object,
                                            SecurityInformation,
                                            SecurityDescriptor,
                                            ObjectsSecurityDescriptor,
                                            PoolType,
                                            GenericMapping
                                            );

            if (NT_SUCCESS(Status))
            {
                //
                // Serialize the guid's new security descriptor in
                // the registry. But first we need to get a copy of
                // it.

                SecurityDescriptorLength = 1024;
                do
                {
                    SecurityDescriptorCopy = ExAllocatePoolWithTag(
                                                            PoolType,
                                                            SecurityDescriptorLength,
                                                            WMIPOOLTAG);

                    if (SecurityDescriptorCopy == NULL)
                    {
                        Status2 = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }
                    LocalSecInfo = 0xffffffff;
                    Status2 = ObQuerySecurityDescriptorInfo( Object,
                                                             &LocalSecInfo,
                                                             SecurityDescriptorCopy,
                                                             &SecurityDescriptorLength,
                                                             ObjectsSecurityDescriptor);


                    if (Status2 == STATUS_BUFFER_TOO_SMALL)
                    {
                        ExFreePool(SecurityDescriptorCopy);
                    } else {
                        break;
                    }

                } while (TRUE);


                if (NT_SUCCESS(Status2))
                {
                    Guid = &((PWMIGUIDOBJECT)Object)->Guid;
                    StringCbPrintf(GuidBuffer,
                                   sizeof(GuidBuffer),
                          L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                         Guid->Data1, Guid->Data2,
                         Guid->Data3,
                         Guid->Data4[0], Guid->Data4[1],
                         Guid->Data4[2], Guid->Data4[3],
                         Guid->Data4[4], Guid->Data4[5],
                         Guid->Data4[6], Guid->Data4[7]);

                    RtlInitUnicodeString(&GuidName, GuidBuffer);

                    WmipSaveGuidSecurityDescriptor(&GuidName,
                                               SecurityDescriptorCopy);
                }

                if (SecurityDescriptorCopy != NULL)
                {
                    ExFreePool(SecurityDescriptorCopy);
                }

            }

            return(Status);
        }



    case QuerySecurityDescriptor:
    {

        //
        //  check the rest of our input and call the default query security
        //  method
        //

        ASSERT( CapturedLength != NULL );


        return ObQuerySecurityDescriptorInfo( Object,
                                              SecurityInformation,
                                              SecurityDescriptor,
                                              CapturedLength,
                                              ObjectsSecurityDescriptor );
    }

    case DeleteSecurityDescriptor:
    {

        //
        //  call the default delete security method
        //

        Status = ObDeassignSecurity(ObjectsSecurityDescriptor);
        return(Status);
    }

    case AssignSecurityDescriptor:

        ObAssignObjectSecurityDescriptor( Object,
                                          SecurityDescriptor,
                                          PoolType );
        return( STATUS_SUCCESS );

    default:

        //
        //  Bugcheck on any other operation code,  We won't get here if
        //  the earlier asserts are still checked.
        //

        KeBugCheckEx( SECURITY_SYSTEM, 1, (ULONG_PTR) STATUS_INVALID_PARAMETER, 0, 0 );
    }

}


NTSTATUS WmipInitializeSecurity(
    void
    )
/*++

Routine Description:

    This routine will initialize WMI security subsystem. Basically we
    create the WMIGUID object type, obtain the SECURITY_SUBJECT_CONTEXT for
    the System process and establish a SD that allows all access that is used
    when no default or specific SD is assigned to a guid.

Arguments:

Return Value:

    NT Status code

--*/

{
    NTSTATUS Status;
    UNICODE_STRING ObjectTypeName;
    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    ULONG DaclLength;
    PACL DefaultAccessDacl;

    PAGED_CODE();

    //
    // Establish a SD for those guids with no specific or default SD
    DaclLength = (ULONG)sizeof(ACL) +
                   (5*((ULONG)sizeof(ACCESS_ALLOWED_ACE))) +
                   SeLengthSid( SeLocalSystemSid ) +
                   SeLengthSid( SeExports->SeLocalServiceSid ) +
                   SeLengthSid( SeExports->SeNetworkServiceSid ) +
                   SeLengthSid( SeAliasAdminsSid ) +
                   SeLengthSid( SeAliasUsersSid ) +
                   8; // The 8 is just for good measure


    DefaultAccessDacl = (PACL)ExAllocatePoolWithTag(PagedPool,
                                                   DaclLength,
                                                   WMIPOOLTAG);
    if (DefaultAccessDacl == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = RtlCreateAcl( DefaultAccessDacl,
                           DaclLength,
                           ACL_REVISION2);
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = RtlAddAccessAllowedAce (
                 DefaultAccessDacl,
                 ACL_REVISION2,
                 (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL),
                 SeLocalSystemSid
                 );
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = RtlAddAccessAllowedAce (
                 DefaultAccessDacl,
                 ACL_REVISION2,
                 TRACELOG_REGISTER_GUIDS,
                 SeAliasUsersSid
                 );
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = RtlAddAccessAllowedAce (
                 DefaultAccessDacl,
                 ACL_REVISION2,
                 (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL | ACCESS_SYSTEM_SECURITY),
                 SeAliasAdminsSid
                 );
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = RtlAddAccessAllowedAce (
                 DefaultAccessDacl,
                 ACL_REVISION2,
                 (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL),
                 SeExports->SeLocalServiceSid
                 );
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = RtlAddAccessAllowedAce (
                 DefaultAccessDacl,
                 ACL_REVISION2,
                 (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL),
                 SeExports->SeNetworkServiceSid
                 );
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    WmipDefaultAccessSd = &WmipDefaultAccessSecurityDescriptor;
    Status = RtlCreateSecurityDescriptor(
                 WmipDefaultAccessSd,
                 SECURITY_DESCRIPTOR_REVISION1
                 );

    Status = RtlSetDaclSecurityDescriptor(
                 WmipDefaultAccessSd,
                 TRUE,                       // DaclPresent
                 DefaultAccessDacl,
                 FALSE                       // DaclDefaulted
                 );
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = RtlSetOwnerSecurityDescriptor(WmipDefaultAccessSd,
                                           SeAliasAdminsSid,
                                           FALSE);
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = RtlSetGroupSecurityDescriptor(WmipDefaultAccessSd,
                                           SeAliasAdminsSid,
                                           FALSE);
    if (! NT_SUCCESS(Status))
    {
Cleanup:
        ExFreePool(DefaultAccessDacl);
        WmipDefaultAccessSd = NULL;
        return(Status);
    }

    //
    // Remember System process subject context
    SeCaptureSubjectContext(&WmipSystemSubjectContext);

    //
    // Establish WmiGuid object type
    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));

    ObjectTypeInitializer.Length = sizeof(OBJECT_TYPE_INITIALIZER);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = WmipGenericMapping;
    ObjectTypeInitializer.ValidAccessMask = WMIGUID_ALL_ACCESS | STANDARD_RIGHTS_ALL;

    //
    // All named objects may (must ?) have security descriptors attached
    // to them. If unnamed objects also must have security descriptors
    // attached then this must be TRUE
    ObjectTypeInitializer.SecurityRequired = TRUE;

    //
    // Tracks # handles open for object within a process
    ObjectTypeInitializer.MaintainHandleCount = FALSE;

    //
    // Need to be in non paged pool since KEVENT contained within the
    // object must be in non paged pool
    //
    ObjectTypeInitializer.PoolType = NonPagedPool;

    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(WMIGUIDOBJECT);

    //
    // Use a custom security procedure so that we can serialize any
    // changes to the security descriptor.
    ObjectTypeInitializer.SecurityProcedure = WmipSecurityMethod;

    //
    // We need to know when an object is being deleted
    //
    ObjectTypeInitializer.DeleteProcedure = WmipDeleteMethod;
    ObjectTypeInitializer.CloseProcedure = WmipCloseMethod;
    RtlInitUnicodeString(&ObjectTypeName, L"WmiGuid");

    Status = ObCreateObjectType(&ObjectTypeName,
                                &ObjectTypeInitializer,
                                NULL,
                                &WmipGuidObjectType);

    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    return(Status);
}

NTSTATUS WmipSDRegistryQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    Registry query values callback routine for reading SDs for guids

Arguments:

    ValueName - the name of the value

    ValueType - the type of the value

    ValueData - the data in the value (unicode string data)

    ValueLength - the number of bytes in the value data

    Context - Not used

    EntryContext - Pointer to PSECURITTY_DESCRIPTOR to store a pointer to
        store the security descriptor read from the registry value

Return Value:

    NT Status code

--*/
{
    PSECURITY_DESCRIPTOR *SecurityDescriptor;
    NTSTATUS Status;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (Context);
    UNREFERENCED_PARAMETER (ValueName);

    Status = STATUS_SUCCESS;
    if ((ValueType == REG_BINARY) &&
        (ValueData != NULL))
    {
        //
        // If a SD is specified in the registry then verify that it is
        // valid and if so then copy it
        //
        if (SeValidSecurityDescriptor(ValueLength,
                                      (PSECURITY_DESCRIPTOR)ValueData))
        {
            SecurityDescriptor = (PSECURITY_DESCRIPTOR *)EntryContext;
            *SecurityDescriptor = ExAllocatePoolWithTag(PagedPool,
                                                        ValueLength,
                                WMIPOOLTAG);
            if (*SecurityDescriptor != NULL)
            {
                RtlCopyMemory(*SecurityDescriptor,
                              ValueData,
                              ValueLength);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }
    return(Status);
}

NTSTATUS WmipSaveGuidSecurityDescriptor(
    PUNICODE_STRING GuidName,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )
/*++

Routine Description:

    This routine will serialize the security descriptor associated with a
    guid.

    Security descriptors are maintained as REG_BINARY values named by the guid
    in the registry under
    HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Wmi\Security

Arguments:

    GuidName is a pointer to a unicode string that represents the guid

    SecurityDescriptor points at a self relative security descriptor

Return Value:

    NT Status code

--*/
{
    ULONG SecurityDescriptorLength;
    NTSTATUS Status;

    PAGED_CODE();

    SecurityDescriptorLength = RtlLengthSecurityDescriptor(SecurityDescriptor);
    Status = RtlWriteRegistryValue(RTL_REGISTRY_CONTROL,
                              L"WMI\\Security",
                              GuidName->Buffer,
                              REG_BINARY,
                              SecurityDescriptor,
                              SecurityDescriptorLength);

    return(Status);
}

NTSTATUS WmipGetGuidSecurityDescriptor(
    IN PUNICODE_STRING GuidName,
    IN PSECURITY_DESCRIPTOR *SecurityDescriptor,
    IN PSECURITY_DESCRIPTOR UserDefaultSecurity
    )
/*++

Routine Description:

    This routine will retrieve the security descriptor associated with a
    guid. First it looks for a security descriptor specifically for the
    guid and if not found then looks for the default security descriptor.

    Security descriptors are maintained as REG_BINARY values named by the guid
    in the registry under
    HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Wmi\Security

Arguments:

    GuidName is a pointer to a unicode string that represents the guid

    *SecurityDescriptor returns the security descriptor for the guid. It
    must be freed back to pool unless it is the same value as that in
    WmipDefaultAccessSd which must NOT be freed.

Return Value:

    NT Status code

--*/
{
    RTL_QUERY_REGISTRY_TABLE QueryRegistryTable[3];
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR GuidSecurityDescriptor = NULL;
    PSECURITY_DESCRIPTOR DefaultSecurityDescriptor = NULL;

    PAGED_CODE();

    RtlZeroMemory(QueryRegistryTable, sizeof(QueryRegistryTable));

    QueryRegistryTable[0].QueryRoutine = WmipSDRegistryQueryRoutine;
    QueryRegistryTable[0].EntryContext = &GuidSecurityDescriptor;
    QueryRegistryTable[0].Name = GuidName->Buffer;
    QueryRegistryTable[0].DefaultType = REG_BINARY;

    QueryRegistryTable[1].QueryRoutine = WmipSDRegistryQueryRoutine;
    QueryRegistryTable[1].Flags = 0;
    QueryRegistryTable[1].EntryContext = &DefaultSecurityDescriptor;
    QueryRegistryTable[1].Name = DefaultSecurityGuidName;
    QueryRegistryTable[1].DefaultType = REG_BINARY;

    Status = RtlQueryRegistryValues(RTL_REGISTRY_CONTROL,
                              L"WMI\\Security",
                              QueryRegistryTable,
                              NULL,
                              NULL);

    *SecurityDescriptor = NULL;
    if (NT_SUCCESS(Status))
    {
        //
        // If there is a guid specific SD then choose that and free any
        // default SD. Else we use the default SD unless that doesn't
        // exist and so there is no security
        if (GuidSecurityDescriptor != NULL)
        {
            *SecurityDescriptor = GuidSecurityDescriptor;
            if (DefaultSecurityDescriptor != NULL)
            {
                ExFreePool(DefaultSecurityDescriptor);
            }
        } else if (DefaultSecurityDescriptor != NULL) {
            *SecurityDescriptor = DefaultSecurityDescriptor;
        }
    }

    if (*SecurityDescriptor == NULL)
    {
        if (UserDefaultSecurity == NULL)
        {
            //
            // If the caller didn't provide a default, use the generic default
            //
            UserDefaultSecurity = WmipDefaultAccessSd;
        }
        //
        // Set the default security if none was found in the registry for
        // the Guid
        //
        *SecurityDescriptor = UserDefaultSecurity;
    }

    return(STATUS_SUCCESS);
}


NTSTATUS WmipOpenGuidObject(
    IN POBJECT_ATTRIBUTES CapturedObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN KPROCESSOR_MODE AccessMode,
    OUT PHANDLE Handle,
    OUT PWMIGUIDOBJECT *ObjectPtr
    )
/*++

Routine Description:

    This routine will open a handle to a WmiGuid object with the access rights
    specified. WmiGuid objects are temporary objects that are created on an
    as needed basis. We will always create a new unnamed guid object each time
    a guid is opened.

Arguments:

    GuidString is the string representation for the guid that refers to
        the object to open. Note that this parameter has NOT been probed.
         Parse UUID such as \WmiGuid\00000000-0000-0000-0000-000000000000

    DesiredAccess specifies the access requested

    *Handle returns a handle to the guid object

    *ObjectPtr returns containing a pointer to the object. This object
        will have a reference attached to it that must be dereferenced by
        the calling code.

Return Value:

    NT Status code

--*/
{
    NTSTATUS Status;
    GUID Guid;
    PWMIGUIDOBJECT GuidObject;
    HANDLE CreatorHandle;
    PUNICODE_STRING CapturedGuidString;

    PAGED_CODE();

    //
    // Validate guid object name passed by ensuring that it is in the
    // correct object directory and the correct format for a uuid
    CapturedGuidString = CapturedObjectAttributes->ObjectName;

    if (RtlEqualMemory(CapturedGuidString->Buffer,
                         WmiGuidObjectDirectory,
                         (WmiGuidObjectDirectoryLength-1) * sizeof(WCHAR)) == 0)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    Status = WmipUuidFromString(&CapturedGuidString->Buffer[WmiGuidGuidPosition], &Guid);
    if (! NT_SUCCESS(Status))
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Invalid uuid format for guid object %ws\n", CapturedGuidString->Buffer));
        return(Status);
    }

    //
    // If it does not exist then create an object for the guid ....
    //
    Status = WmipCreateGuidObject(CapturedObjectAttributes,
                                  DesiredAccess,
                                  &Guid,
                                  &CreatorHandle,
                                  &GuidObject);

    if (NT_SUCCESS(Status))
    {
        //
        // .... and try again to open it
        //
        Status = ObOpenObjectByPointer(GuidObject,
                                       0,
                                       NULL,
                                       DesiredAccess,
                                       WmipGuidObjectType,
                                       AccessMode,
                                       Handle);

        if (! NT_SUCCESS(Status))
        {
            //
            // Remove extra ref count taken by ObInsertObject since we
            // are returning an error
            //
            ObDereferenceObject(GuidObject);
        }

        //
        // Make sure to close handle obtained in creating object. We
        // attach to the system process since the handle was created in
        // its handle table.
        //
        KeAttachProcess( &PsInitialSystemProcess->Pcb );
        ZwClose(CreatorHandle);
        KeDetachProcess( );
        *ObjectPtr = GuidObject;
    }

    return(Status);
}

NTSTATUS WmipCreateGuidObject(
    IN OUT POBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN LPGUID Guid,
    OUT PHANDLE CreatorHandle,
    OUT PWMIGUIDOBJECT *Object
    )
/*++

Routine Description:

    This routine will create a new guid object for
    the guid passed. The handle returned is the handle issued to the creator
    of the object and should be closed after the object is opened.

    Guid Objects are created on the fly, but

Arguments:

    ObjectAttributes - Describes object being created. ObjectAttributes
                       is modified in this call.

    Guid is the guid for which the object is being created

    *CreatorHandle returns a handle to the created guid object. This handle
        is in the system process handle table

    *Object returns with a pointer to the object

Return Value:

    NT Status code

--*/
{
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    UNICODE_STRING UnicodeString;
    WCHAR *ObjectNameBuffer;
    WCHAR *GuidBuffer;
    NTSTATUS Status;
    ACCESS_STATE LocalAccessState;
    AUX_ACCESS_DATA AuxData;
    SECURITY_SUBJECT_CONTEXT SavedSubjectContext;
    PSECURITY_SUBJECT_CONTEXT SubjectContext;
    PWMIGUIDOBJECT NewObject;
    OBJECT_ATTRIBUTES UnnamedObjectAttributes;

    PAGED_CODE();

    ObjectNameBuffer = ObjectAttributes->ObjectName->Buffer;
    GuidBuffer = &ObjectNameBuffer[WmiGuidGuidPosition];
    RtlInitUnicodeString(&UnicodeString, GuidBuffer);

    //
    // Obtain security descriptor associated with the guid
    Status = WmipGetGuidSecurityDescriptor(&UnicodeString,
                                           &SecurityDescriptor, NULL);

    if (NT_SUCCESS(Status))
    {
        WmipAssert(SecurityDescriptor != NULL);

        //
        // Establish ObjectAttributes for the newly created object
        RtlInitUnicodeString(&UnicodeString, ObjectNameBuffer);

        UnnamedObjectAttributes = *ObjectAttributes;
        UnnamedObjectAttributes.Attributes = OBJ_OPENIF;
        UnnamedObjectAttributes.SecurityDescriptor = SecurityDescriptor;
        UnnamedObjectAttributes.ObjectName = NULL;


        //
        // Create an AccessState and wack on the token
        Status = SeCreateAccessState(&LocalAccessState,
                                     &AuxData,
                                     DesiredAccess,
                                     (PGENERIC_MAPPING)&WmipGenericMapping);

        if (NT_SUCCESS(Status))
        {
            SubjectContext = &LocalAccessState.SubjectSecurityContext;
            SavedSubjectContext = *SubjectContext;
            *SubjectContext = WmipSystemSubjectContext;

            //
            // Attach to system process so that the initial handle created
            // by ObInsertObject is not available to user mode. This handle
            // allows full access to the object.
            KeAttachProcess( &PsInitialSystemProcess->Pcb );

            Status = ObCreateObject(KernelMode,
                                    WmipGuidObjectType,
                                    &UnnamedObjectAttributes,
                                    KernelMode,
                                    NULL,
                                    sizeof(WMIGUIDOBJECT),
                                    0,
                                    0,
                                    (PVOID *)Object);

            if (NT_SUCCESS(Status))
            {
                //
                // Initialize WMIGUIDOBJECT structure
                //
                RtlZeroMemory(*Object, sizeof(WMIGUIDOBJECT));

                KeInitializeEvent(&(*Object)->Event,
                                  NotificationEvent,
                                  FALSE);

                (*Object)->HiPriority.MaxBufferSize = 0x1000;
                (*Object)->LoPriority.MaxBufferSize = 0x1000;
                (*Object)->Guid = *Guid;

                //
                // Take an extra refcount when inserting the object. We
                // need this ref count so that we can ensure that the
                // object will stick around while we are using it, but
                // after a handle has been made available to user mode
                // code. User mode can guess the handle and close it
                // even before we return it.
                //
                Status = ObInsertObject(*Object,
                                        &LocalAccessState,
                                        DesiredAccess,
                                        1,
                                        &NewObject,
                                        CreatorHandle);

                WmipAssert(Status != STATUS_OBJECT_NAME_EXISTS);
            }

            *SubjectContext = SavedSubjectContext;
            SeDeleteAccessState(&LocalAccessState);

            KeDetachProcess( );
        }

        if (SecurityDescriptor != WmipDefaultAccessSd)
        {
            ExFreePool(SecurityDescriptor);
        }
    }

    return(Status);
}

VOID WmipCloseMethod(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    )
/*++

Routine Description:

    This routine is called whenever a guid object handle is closed. We
    only need to worry about this for reply object and then only when the
    last handle to it is closed.

Arguments:

    Process

    Object

    GrantedAccess

    ProcessHandleCount

    SystemHandleCount

Return Value:


--*/
{
    PWMIGUIDOBJECT ReplyObject;
    PLIST_ENTRY RequestList;
    PMBREQUESTS MBRequest;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (Process);
    UNREFERENCED_PARAMETER (GrantedAccess);
    UNREFERENCED_PARAMETER (ProcessHandleCount);

    if (SystemHandleCount == 1)
    {
        //
        // Only clean up if there are no more valid handles left
        //
        ReplyObject = (PWMIGUIDOBJECT)Object;

        if (ReplyObject->Flags & WMIGUID_FLAG_REPLY_OBJECT)
        {
            //
            // When a reply object is closed we need to make sure that
            // any reference to it by a request object is cleaned up
            //
            ASSERT(ReplyObject->GuidEntry == NULL);

            WmipEnterSMCritSection();
            RequestList = ReplyObject->RequestListHead.Flink;

            while (RequestList != &ReplyObject->RequestListHead)
            {
                //
                //
                MBRequest = CONTAINING_RECORD(RequestList,
                                                  MBREQUESTS,
                                                  RequestListEntry);

                if (MBRequest->ReplyObject == ReplyObject)
                {
                    RemoveEntryList(&MBRequest->RequestListEntry);
                    MBRequest->ReplyObject = NULL;
                    ObDereferenceObject(ReplyObject);
                    break;
                }

                RequestList = RequestList->Flink;
            }

            WmipLeaveSMCritSection();
        }
    }
}



VOID WmipDeleteMethod(
    IN  PVOID   Object
    )
{
    PIRP Irp;
    PWMIGUIDOBJECT GuidObject, ReplyObject;
    PMBREQUESTS MBRequest;
    WNODE_HEADER Wnode;
    PREGENTRY RegEntry;
    PBDATASOURCE DataSource;
    ULONG i;

    PAGED_CODE();

    GuidObject = (PWMIGUIDOBJECT)Object;


    if (GuidObject->Flags & WMIGUID_FLAG_REQUEST_OBJECT)
    {
        //
        // This is a request object that is going away so we need to
        //
        ASSERT(GuidObject->GuidEntry == NULL);

        //
        // First reply to all reply objects that are waiting for
        // a reply
        //
        WmipEnterSMCritSection();
        for (i = 0; i < MAXREQREPLYSLOTS; i++)
        {
            MBRequest = &GuidObject->MBRequests[i];

            ReplyObject = MBRequest->ReplyObject;
            if (ReplyObject != NULL)
            {
                RtlZeroMemory(&Wnode, sizeof(WNODE_HEADER));
                Wnode.BufferSize = sizeof(WNODE_HEADER);
                Wnode.Flags = WNODE_FLAG_INTERNAL;
                Wnode.ProviderId = WmiRequestDied;
                WmipWriteWnodeToObject(ReplyObject,
                                       &Wnode,
                                       TRUE);

                RemoveEntryList(&MBRequest->RequestListEntry);
                MBRequest->ReplyObject = NULL;
                ObDereferenceObject(ReplyObject);
            }
        }

        //
        // next, unreference the regentry which will cause the regentry
        // to get a ref count of 0 and then ultimately remove the
        // DATASOURCE and all related data structures. But first make
        // sure to remove the pointer from the datasource to the
        // regentry
        //
        RegEntry = GuidObject->RegEntry;
        if (RegEntry != NULL)
        {
            DataSource = RegEntry->DataSource;
            if (DataSource != NULL)
            {
                DataSource->RequestObject = NULL;
            }

            RegEntry->Flags |= (REGENTRY_FLAG_RUNDOWN |
                                    REGENTRY_FLAG_NOT_ACCEPTING_IRPS);
            WmipUnreferenceRegEntry(RegEntry);
        }
        WmipLeaveSMCritSection();

    } else if (GuidObject->Flags & WMIGUID_FLAG_REPLY_OBJECT) {
        //
        // This is a reply object that is going away
        //
        ASSERT(GuidObject->GuidEntry == NULL);
    } else if (GuidObject->GuidEntry != NULL)  {
        //
        // If there is a guid entry associated with the object
        // then we need to see if we should disable collection
        // or events and then remove the object from the
        // guidentry list and finally remove the refcount on the guid
        // entry held by the object
        //
        if (GuidObject->EnableRequestSent)
        {
            WmipDisableCollectOrEvent(GuidObject->GuidEntry,
                                      GuidObject->Type,
                                      0);
        }

        WmipEnterSMCritSection();
        RemoveEntryList(&GuidObject->GEObjectList);
        WmipLeaveSMCritSection();

        WmipUnreferenceGE(GuidObject->GuidEntry);
    }

    if ((GuidObject->Flags & WMIGUID_FLAG_KERNEL_NOTIFICATION) == 0)
    {
        //
        // Clean up any queued events and irps for UM objects
        //
        if (GuidObject->HiPriority.Buffer != NULL)
        {
            WmipFree(GuidObject->HiPriority.Buffer);
        }

        if (GuidObject->LoPriority.Buffer != NULL)
        {
            WmipFree(GuidObject->LoPriority.Buffer);
        }

        WmipEnterSMCritSection();

        if (GuidObject->EventQueueAction == RECEIVE_ACTION_NONE)
        {
            Irp = GuidObject->Irp;

            if (Irp != NULL)
            {
                //
                // Since this object is going away and there is an irp waiting for
                // we need to make sure that the object is removed from the
                // irp's list.
                //
                WmipClearIrpObjectList(Irp);

                if (IoSetCancelRoutine(Irp, NULL))
                {
                    //
                    // If the irp has not been completed yet then we
                    // complete it now with an error
                    //
                    Irp->IoStatus.Information = 0;
                    Irp->IoStatus.Status = STATUS_INVALID_HANDLE;
                    IoCompleteRequest(Irp, IO_NO_INCREMENT);
                }
            }
        } else if (GuidObject->EventQueueAction == RECEIVE_ACTION_CREATE_THREAD) {
            //
            // If the object is going away and is part of a list of
            // objects waiting for an event to start a thread, all we
            // need to do is to removed the object from the list
            //
            WmipAssert(GuidObject->UserModeProcess != NULL);
            WmipAssert(GuidObject->UserModeCallback != NULL);
            WmipClearObjectFromThreadList(GuidObject);
        }
        WmipLeaveSMCritSection();
    }    
}

//
// The routines below are from the ole sources in
// \nt\private\ole32\com\class\compapi.cxx.
// They are copied here so that WMI doesn't need to load in ole32 only
// to convert a guid string into its binary representation.
//


//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------
BOOLEAN
WmipHexStringToDword(
    IN PWCHAR lpsz,
    OUT PULONG RetValue,
    IN ULONG cDigits,
    IN WCHAR chDelim
    )
{
    ULONG Count;
    ULONG Value;

    PAGED_CODE();

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }

    *RetValue = Value;

    if (chDelim != 0)
        return (*lpsz++ == chDelim) ? TRUE : FALSE;
    else
        return TRUE;
}


NTSTATUS
WmipUuidFromString (
    IN PWCHAR StringUuid,
    OUT LPGUID Uuid
    )
/*++

Routine Description:

    We convert a UUID from its string representation into the binary
    representation. Parse UUID such as 00000000-0000-0000-0000-000000000000

Arguments:

    StringUuid -  supplies the string representation of the UUID. It is
                  assumed that this parameter has been probed and captured

    Uuid - Returns the binary representation of the UUID.

Return Value:

    STATUS_SUCCESS or STATUS_INVALID_PARAMETER

--*/
{
    ULONG dw;
    PWCHAR lpsz = StringUuid;

    PAGED_CODE();

    //
    // read 8 digits and make sure the 9th is a '-'
    // XXXXXXXX-0000-0000-0000-000000000000
    //
    if (!WmipHexStringToDword(lpsz, &Uuid->Data1, 8, L'-'))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // advance 9 characters, 8 numeric, one '-'
    //
    lpsz += 8 + 1;


    //
    // read next 4 digits, make sure the 5th is a '-'
    // 00000000-XXXX-0000-0000-000000000000
    //
    if (!WmipHexStringToDword(lpsz, &dw, 4, L'-'))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data2 = (USHORT)dw;

    //
    // advance 5 characters, 4 numeric, one '-'
    //
    lpsz += 4 + 1;


    //
    // read next 4 digits, make sure the 5th is a '-'
    // 00000000-0000-XXXX-0000-000000000000
    //
    if (!WmipHexStringToDword(lpsz, &dw, 4, L'-'))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data3 = (USHORT)dw;

    //
    // advance 5 characters, 4 numeric, one '-'
    //
    lpsz += 4 + 1;

    //
    // read next 2 digits out of a USHORT portion of the string
    // 00000000-0000-0000-XX00-000000000000
    //
    if (!WmipHexStringToDword(lpsz, &dw, 2, 0))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data4[0] = (UCHAR)dw;

    //
    // advance 2 characters, 2 numeric
    //
    lpsz += 2;


    //
    // read the last 2 digits out of a USHORT portion of the string.
    // make sure there is a '-' as well.
    // 00000000-0000-0000-00XX-000000000000
    //
    if (!WmipHexStringToDword(lpsz, &dw, 2, L'-'))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data4[1] = (UCHAR)dw;
    
    //
    // advance 3 characters, 2 numeric, one '-'
    //
    lpsz += 2 + 1;


    //
    // read 2 digits out of the remaining string
    // 00000000-0000-0000-0000-XX0000000000
    //
    if (!WmipHexStringToDword(lpsz, &dw, 2, 0))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data4[2] = (UCHAR)dw;
    //
    // advance 2 characters, 2 numeric
    //
    lpsz += 2;

    //
    // read 2 digits out of the remaining string
    // 00000000-0000-0000-0000-00XX00000000
    //
    if (!WmipHexStringToDword(lpsz, &dw, 2, 0))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data4[3] = (UCHAR)dw;
    //
    // advance 2 characters, 2 numeric
    //
    lpsz += 2;

    //
    // read 2 digits out of the remaining string
    // 00000000-0000-0000-0000-0000XX000000
    //
    if (!WmipHexStringToDword(lpsz, &dw, 2, 0))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data4[4] = (UCHAR)dw;
    //
    // advance 2 characters, 2 numeric
    //
    lpsz += 2;

    //
    // read 2 digits out of the remaining string
    // 00000000-0000-0000-0000-000000XX0000
    //
    if (!WmipHexStringToDword(lpsz, &dw, 2, 0))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data4[5] = (UCHAR)dw;
    //
    // advance 2 characters, 2 numeric
    //
    lpsz += 2;

    //
    // read 2 digits out of the remaining string
    // 00000000-0000-0000-0000-00000000XX00
    //
    if (!WmipHexStringToDword(lpsz, &dw, 2, 0))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data4[6] = (UCHAR)dw;
    //
    // advance 2 characters, 2 numeric
    //
    lpsz += 2;

    //
    // read 2 digits out of the remaining string
    // 00000000-0000-0000-0000-0000000000XX
    //
    if (!WmipHexStringToDword(lpsz, &dw, 2, 0))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data4[7] = (UCHAR)dw;

    return(STATUS_SUCCESS);
}

NTSTATUS
WmipCheckGuidAccess(
    IN LPGUID Guid,
    IN ACCESS_MASK DesiredAccess,
    IN PSECURITY_DESCRIPTOR UserDefaultSecurity
    )
/*++

Routine Description:

    Allows checking if the current user has the rights to access a guid.

Arguments:

    Guid is the guid whose security is to be checked

    DesiredAccess is the access that is desired by the user.
                  NOTE: This does not support GENERIC_* mappings or
                          ASSIGN_SYSTEM_SECURITY

Return Value:

    STATUS_SUCCESS or error

--*/
{
    BOOLEAN Granted;
    ACCESS_MASK PreviousGrantedAccess = 0;
    NTSTATUS Status;
    ACCESS_MASK GrantedAccess;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    UNICODE_STRING GuidString;
    WCHAR GuidBuffer[38];
    SECURITY_SUBJECT_CONTEXT SecuritySubjectContext;

    PAGED_CODE();

    StringCbPrintf(GuidBuffer,
                   sizeof(GuidBuffer),
             L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                         Guid->Data1, Guid->Data2,
                         Guid->Data3,
                         Guid->Data4[0], Guid->Data4[1],
                         Guid->Data4[2], Guid->Data4[3],
                         Guid->Data4[4], Guid->Data4[5],
                         Guid->Data4[6], Guid->Data4[7]);
    RtlInitUnicodeString(&GuidString, GuidBuffer);

    Status = WmipGetGuidSecurityDescriptor(&GuidString,
                                           &SecurityDescriptor,
                                           UserDefaultSecurity);

    if (NT_SUCCESS(Status))
    {
        SeCaptureSubjectContext(&SecuritySubjectContext);

        Granted = SeAccessCheck (SecurityDescriptor,
                             &SecuritySubjectContext,
                             FALSE,
                             DesiredAccess,
                             PreviousGrantedAccess,
                             NULL,
                             (PGENERIC_MAPPING)&WmipGenericMapping,
                             UserMode,
                             &GrantedAccess,
                             &Status);

        SeReleaseSubjectContext(&SecuritySubjectContext);

        if ((SecurityDescriptor != WmipDefaultAccessSd) &&
            (SecurityDescriptor != UserDefaultSecurity))
        {
            ExFreePool(SecurityDescriptor);
        }
    }

    return(Status);
}

NTSTATUS WmipCreateAdminSD(
    PSECURITY_DESCRIPTOR *Sd
    )
{
    ULONG DaclLength;
    PACL AdminDeviceDacl;
    PSECURITY_DESCRIPTOR AdminDeviceSd;
    NTSTATUS Status;

    PAGED_CODE();
    
    DaclLength = (ULONG)sizeof(ACL) +
                   (2*((ULONG)sizeof(ACCESS_ALLOWED_ACE))) +
                   SeLengthSid( SeAliasAdminsSid ) +
                   SeLengthSid( SeLocalSystemSid ) +
                   8; // The 8 is just for good measure

    AdminDeviceSd = (PSECURITY_DESCRIPTOR)ExAllocatePoolWithTag(PagedPool,
                                               DaclLength +
                                                  sizeof(SECURITY_DESCRIPTOR),
                                               WMIPOOLTAG);

    if (AdminDeviceSd != NULL)
    {
        AdminDeviceDacl = (PACL)((PUCHAR)AdminDeviceSd +
                                    sizeof(SECURITY_DESCRIPTOR));
        Status = RtlCreateAcl( AdminDeviceDacl,
                               DaclLength,
                               ACL_REVISION2);

        if (NT_SUCCESS(Status))
        {
            Status = RtlAddAccessAllowedAce (
                         AdminDeviceDacl,
                         ACL_REVISION2,
                         FILE_ALL_ACCESS,
                         SeAliasAdminsSid
                         );
            if (NT_SUCCESS(Status))
            {
                Status = RtlAddAccessAllowedAce (
                             AdminDeviceDacl,
                             ACL_REVISION2,
                             FILE_ALL_ACCESS,
                             SeLocalSystemSid
                             );
                if (NT_SUCCESS(Status))
                {
                    Status = RtlCreateSecurityDescriptor(
                                 AdminDeviceSd,
                                 SECURITY_DESCRIPTOR_REVISION1
                                 );
                    if (NT_SUCCESS(Status))
                    {
                        Status = RtlSetDaclSecurityDescriptor(
                                     AdminDeviceSd,
                                     TRUE,                       // DaclPresent
                                     AdminDeviceDacl,
                                     FALSE                       // DaclDefaulted
                                     );
                        if (NT_SUCCESS(Status))
                        {

                            //
                            // We need to make sure that there is an owner for the security
                            // descriptor since it is required when security is being checked
                            // when the device is being opened.
                            Status = RtlSetOwnerSecurityDescriptor(AdminDeviceSd,
                                                                   SeAliasAdminsSid,
                                                                   FALSE);
                        }
                    }
                }
            }
        }

        if (NT_SUCCESS(Status))
        {
            *Sd = AdminDeviceSd;
        } else {
            ExFreePool(AdminDeviceSd);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return(Status);
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\traceapi.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    traceapi.c

Abstract:

    This is the source file that implements the published routines of
    the performance event tracing and logging facility. These routines are
    be declared in ntos\inc\wmi.h

--*/

#include "wmikmp.h"
#include <ntos.h>
#include <evntrace.h>

#include <wmi.h>
#include "tracep.h"

extern SIZE_T MmMaximumNonPagedPoolInBytes;

#pragma alloc_text(PAGE, WmiStartTrace)
#pragma alloc_text(PAGE, WmiQueryTrace)
#pragma alloc_text(PAGE, WmiStopTrace)
#pragma alloc_text(PAGE, WmiUpdateTrace)
#pragma alloc_text(PAGE, WmiSetTraceBufferCallback)
#pragma alloc_text(PAGE, WmiFlushTrace)
#pragma alloc_text(PAGE, WmiQueryTraceInformation)
#pragma alloc_text(PAGEWMI, WmiTraceKernelEvent)
#pragma alloc_text(PAGEWMI, WmiTraceUserMessage)
#pragma alloc_text(PAGEWMI, WmiSetMark)

//
// Trace Control APIs
//

NTKERNELAPI
NTSTATUS
WmiStartTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This routine is used to create and start an event tracing session.
    NOTE: A special instance (KERNEL_LOGGER) is reserved exclusively for
    logging kernel tracing.

    To turn on KERNEL_LOGGER, LoggerInfo->Wnode.Guid should be set to
    SystemTraceControlGuid, and sufficient space must be provided in
    LoggerInfo->LoggerName.

    To turn on other loggers, simply provide a name in LoggerName. The
    logger id will be returned.

Arguments:

    LoggerInfo     a pointer to the structure for the logger's control
                    and status information

Return Value:

    The status of performing the action requested.

--*/

{
    NTSTATUS status;
    PWCHAR LogFileName = NULL;
    HANDLE FileHandle = NULL;
    ULONG DelayOpen;

    PAGED_CODE();

    if (LoggerInfo == NULL)
        return STATUS_INVALID_PARAMETER;

    if (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        return STATUS_INVALID_BUFFER_SIZE;

    //
    // We assume that the caller is always kernel mode
    // First, we try and see it is a delay create.
    // If not, if we can even open the file
    //
    DelayOpen = LoggerInfo->LogFileMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE;

    if (!DelayOpen) {
        if (LoggerInfo->LogFileName.Buffer != NULL) { // && !delay_create
            status = WmipCreateNtFileName(
                        LoggerInfo->LogFileName.Buffer,
                        &LogFileName);
            if (!NT_SUCCESS(status))
                return status;
            status = WmipCreateDirectoryFile(LogFileName, 
                                            FALSE, 
                                            &FileHandle,
                                            LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND);
            if (LogFileName != NULL) {
                ExFreePool(LogFileName);
            }
            if (!NT_SUCCESS(status)) {
                return status;
            }
            ZwClose(FileHandle);
        }
    }

    status = WmipStartLogger(LoggerInfo);
    if (NT_SUCCESS(status)) {
        status = WmiFlushTrace(LoggerInfo);
    }
    return status;
}


NTKERNELAPI
NTSTATUS
WmiQueryTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This routine is called to query the status of a tracing session.
    Caller must pass in either the Logger Name or a valid Logger Id/Handle.

Arguments:

    LoggerInfo     a pointer to the structure for the logger's control
                    and status information

Return Value:

    The status of performing the action requested.

--*/

{
    PAGED_CODE();

    if (LoggerInfo == NULL)
        return STATUS_INVALID_PARAMETER;
    return WmipQueryLogger(LoggerInfo, NULL);
}


NTKERNELAPI
NTSTATUS
WmiStopTrace(
    IN PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    It is called by WmipIoControl in wmi.c, with IOCTL_WMI_STOP_LOGGER
    to stop an instance of the logger. If the logger is the kernel logger,
    it will also turn off kernel tracing and unlock the routines previously
    locked. It will also free all the context of the logger.
    Calls StopLoggerInstance to do the actual work.

Arguments:

    LoggerInfo     a pointer to the structure for the logger's control
                    and status information

Return Value:

    The status of performing the action requested.

--*/

{
    PWMI_LOGGER_CONTEXT LoggerContext = NULL;
    NTSTATUS        Status;
    LARGE_INTEGER   TimeOut = {(ULONG)(-200 * 1000 * 1000 * 10), -1};
    ACCESS_MASK     DesiredAccess = TRACELOG_GUID_ENABLE;
    ULONG           LoggerId;
#if DBG
    LONG            RefCount;
#endif

    PAGED_CODE();

    if (LoggerInfo == NULL)
        return STATUS_INVALID_PARAMETER;

    TraceDebug((1, "WmiStopTrace: %d\n",
                    LoggerInfo->Wnode.HistoricalContext));
#if DBG
    Status = WmipVerifyLoggerInfo(LoggerInfo, &LoggerContext, "WmiStopTrace");
#else
    Status = WmipVerifyLoggerInfo(LoggerInfo, &LoggerContext);
#endif

    if (!NT_SUCCESS(Status) || (LoggerContext == NULL))
        return Status;

    LoggerId = LoggerContext->LoggerId;
    TraceDebug((1, "WmiStopTrace: Stopping %X %d slot %X\n",
                    LoggerContext, LoggerId, WmipLoggerContext[LoggerId]));

    if (LoggerContext->KernelTraceOn)
        DesiredAccess |= TRACELOG_ACCESS_KERNEL_LOGGER;

    Status = WmipCheckGuidAccess(
                &LoggerContext->InstanceGuid,
                DesiredAccess,
                EtwpDefaultTraceSecurityDescriptor
                );
    if (!NT_SUCCESS(Status)) {
        InterlockedDecrement(&LoggerContext->MutexCount);
        TraceDebug((1, "WmiStopTrace: Release mutex1 %d %d\n",
            LoggerId, LoggerContext->MutexCount));
        WmipReleaseMutex(&LoggerContext->LoggerMutex);

#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmiStopTrace: Status1=%X %d %d->%d\n",
                        Status, LoggerId, RefCount+1, RefCount));
        return Status;
    }

    //
    // Reset the Event inside the mutex to be sure
    // before waiting on it.

    KeResetEvent(&LoggerContext->FlushEvent);

    Status = WmipStopLoggerInstance (LoggerContext);

    InterlockedDecrement(&LoggerContext->MutexCount);
    TraceDebug((1, "WmiStopTrace: Release mutex3 %d %d\n",
        LoggerId, LoggerContext->MutexCount));
    WmipReleaseMutex(&LoggerContext->LoggerMutex); // Let others in

    if (NT_SUCCESS(Status)) {
        if (LoggerId == WmipKernelLogger)
            WmipKernelLogger = KERNEL_LOGGER;
        else if (LoggerId == WmipEventLogger)
            WmipEventLogger = 0XFFFFFFFF;
        else 
            Status = WmipDisableTraceProviders(LoggerId);

        if (LoggerInfo != NULL) {
            if (NT_SUCCESS(LoggerContext->LoggerStatus)) {
                LONG Buffers;

                Status = STATUS_TIMEOUT;
                Buffers = LoggerContext->BuffersAvailable;

                //
                // If all buffers are accounted for and the logfile handle
                // is NULL, then there is no reason to wait. 
                //

                if ( (Buffers == LoggerContext->NumberOfBuffers) && 
                     (LoggerContext->LogFileHandle == NULL) ) {
                    Status = STATUS_SUCCESS;
                }
                //
                // We need to wait for the logger thread to flush
                //
                while (Status == STATUS_TIMEOUT) {
                    Status = KeWaitForSingleObject(
                                &LoggerContext->FlushEvent,
                                Executive,
                                KernelMode,
                                FALSE,
                                &TimeOut
                                );
/*                    if (LoggerContext->NumberOfBuffers
                            == LoggerContext->BuffersAvailable)
                        break;
                    else if (LoggerContext->BuffersAvailable == Buffers) {
                        TraceDebug((1,
                            "WmiStopTrace: Logger %d hung %d != %d\n",
                            LoggerId, Buffers, LoggerContext->NumberOfBuffers));
                        KeResetEvent(&LoggerContext->FlushEvent);
//                        break;
                    } 
*/
                    TraceDebug((1, "WmiStopTrace: Wait status=%X\n",Status));
                }
            }
            //
            // Required for Query to work
            // But since CollectionOn is FALSE, it should be safe
            //
            Status = WmipQueryLogger(
                        LoggerInfo,
                        LoggerContext
                        );
        }
    }
#if DBG
    RefCount =
#endif
    WmipDereferenceLogger(LoggerId);
    TraceDebug((1, "WmiStopTrace: Stopped status=%X %d %d->%d\n",
                       Status, LoggerId, RefCount+1, RefCount));
    return Status;
}


NTKERNELAPI
NTSTATUS
WmiUpdateTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    It is called by WmipIoControl in wmi.c, with IOCTL_WMI_UPDATE_LOGGER
    to update certain characteristics of a running logger.

Arguments:

    LoggerInfo      a pointer to the structure for the logger's control
                    and status information

Return Value:

    The status of performing the action requested.

--*/

{
    NTSTATUS Status;
    ULONG Max_Buffers;
    PWMI_LOGGER_CONTEXT LoggerContext = NULL;
    ACCESS_MASK     DesiredAccess = TRACELOG_GUID_ENABLE;
    LARGE_INTEGER   TimeOut = {(ULONG)(-20 * 1000 * 1000 * 10), -1};
    ULONG           EnableFlags, TmpFlags;
    KPROCESSOR_MODE     RequestorMode;
    ULONG           LoggerMode, LoggerId, NewMode;
    UNICODE_STRING  NewLogFileName;
    PTRACE_ENABLE_FLAG_EXTENSION FlagExt = NULL;
    PERFINFO_GROUPMASK *PerfGroupMasks=NULL;
    ULONG GroupMaskSize;
    SECURITY_QUALITY_OF_SERVICE ServiceQos;
#if DBG
    LONG            RefCount;
#endif

    PAGED_CODE();

    
    //
    // see if Logger is running properly first. Error checking will be done
    // in WmiQueryTrace
    //

    if (LoggerInfo == NULL)
        return STATUS_INVALID_PARAMETER;

    EnableFlags = LoggerInfo->EnableFlags;

    TraceDebug((1, "WmiUpdateTrace: %d\n",
                    LoggerInfo->Wnode.HistoricalContext));
#if DBG
    Status = WmipVerifyLoggerInfo(LoggerInfo, &LoggerContext, "WmiUpdateTrace");
#else
    Status = WmipVerifyLoggerInfo(LoggerInfo, &LoggerContext);
#endif
    if (!NT_SUCCESS(Status) || (LoggerContext == NULL))
        return Status;

    LoggerId = LoggerContext->LoggerId;

    // at this point, LoggerContext must be non-NULL

    LoggerMode = LoggerContext->LoggerMode;   // local copy
    NewMode = LoggerInfo->LogFileMode;

    //
    // First, check to make sure that you cannot turn on certain modes
    // in UpdateTrace()
    //

    if ( ((NewMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) &&
          (NewMode & EVENT_TRACE_FILE_MODE_CIRCULAR))        ||

         ((NewMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE) &&
          (NewMode & EVENT_TRACE_USE_LOCAL_SEQUENCE))        || 

         (!(LoggerMode & EVENT_TRACE_FILE_MODE_CIRCULAR) &&
          (NewMode & EVENT_TRACE_FILE_MODE_CIRCULAR))        ||

        // Cannot support append to circular
         ((NewMode & EVENT_TRACE_FILE_MODE_CIRCULAR) &&
          (NewMode & EVENT_TRACE_FILE_MODE_APPEND))

       ) {
        InterlockedDecrement(&LoggerContext->MutexCount);
        TraceDebug((1, "WmiUpdateTrace: Release mutex1 %d %d\n",
            LoggerContext->LoggerId, LoggerContext->MutexCount));
        WmipReleaseMutex(&LoggerContext->LoggerMutex);
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmiUpdateTrace: Status2=%X %d %d->%d\n",
                        Status, LoggerId, RefCount+1, RefCount));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // support turn on or off real time dynamically
    //

    if (NewMode & EVENT_TRACE_REAL_TIME_MODE) {
        LoggerMode   |= EVENT_TRACE_REAL_TIME_MODE;
        DesiredAccess |= TRACELOG_CREATE_REALTIME;
    } else {
        if (LoggerMode & EVENT_TRACE_REAL_TIME_MODE)
            DesiredAccess |= TRACELOG_CREATE_REALTIME;  // turn off real time
        LoggerMode &= ~EVENT_TRACE_REAL_TIME_MODE;
    }
    if (NewMode & EVENT_TRACE_BUFFERING_MODE) {
        LoggerMode |= EVENT_TRACE_BUFFERING_MODE;
    }
    else {
        LoggerMode &= ~EVENT_TRACE_BUFFERING_MODE;
    }
    if (LoggerContext->KernelTraceOn)
        DesiredAccess |= TRACELOG_ACCESS_KERNEL_LOGGER;
    if (LoggerInfo->LogFileHandle != NULL)
        DesiredAccess |= TRACELOG_CREATE_ONDISK;

    Status = WmipCheckGuidAccess(
                &LoggerContext->InstanceGuid,
                DesiredAccess,
                EtwpDefaultTraceSecurityDescriptor
                );
    if (!NT_SUCCESS(Status)) {
        InterlockedDecrement(&LoggerContext->MutexCount);
        TraceDebug((1, "WmiUpdateTrace: Release mutex1 %d %d\n",
            LoggerContext->LoggerId, LoggerContext->MutexCount));
        WmipReleaseMutex(&LoggerContext->LoggerMutex);
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmiUpdateTrace: Status2=%X %d %d->%d\n",
                        Status, LoggerId, RefCount+1, RefCount));
        return Status;
    }

    RtlZeroMemory(&NewLogFileName, sizeof(UNICODE_STRING));
    RequestorMode = KeGetPreviousMode();
    if (LoggerInfo->LogFileHandle != NULL) {
        PFILE_OBJECT    fileObject;
        OBJECT_HANDLE_INFORMATION handleInformation;
        ACCESS_MASK grantedAccess;
        LOGICAL bDelayOpenFlag;

        bDelayOpenFlag =  (LoggerContext->LogFileHandle == NULL &&
                          (LoggerContext->LoggerMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE));

        if (LoggerInfo->LogFileName.Buffer == NULL ||
            LoggerMode & EVENT_TRACE_FILE_MODE_NEWFILE ||
            NewMode & EVENT_TRACE_FILE_MODE_NEWFILE ) {
            // Do not allow snapping in or out of NEW_FILE mode.
            Status = STATUS_INVALID_PARAMETER;
            goto ReleaseAndExit;
        }
        // Save the new LogFileName
        //
        try {
            if (RequestorMode != KernelMode) {
                ProbeForRead(
                    LoggerInfo->LogFileName.Buffer,
                    LoggerInfo->LogFileName.Length,
                    sizeof (UCHAR) );
            }
            RtlCreateUnicodeString(
                &NewLogFileName,
                LoggerInfo->LogFileName.Buffer);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            if (NewLogFileName.Buffer != NULL) {
                RtlFreeUnicodeString(&NewLogFileName);
            }
            InterlockedDecrement(&LoggerContext->MutexCount);
            TraceDebug((1, "WmiUpdateTrace: Release mutex3 %d %d\n",
                LoggerId, LoggerContext->MutexCount));
            WmipReleaseMutex(&LoggerContext->LoggerMutex);
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((1, "WmiUpdateTrace: Status5=EXCEPTION %d %d->%d\n",
                            LoggerId, RefCount+1, RefCount));
            return GetExceptionCode();
        }

        // Switching to a new logfile. This routine does not put any
        // headers into the logfile. The headers should be written out
        // by UpdateTrace() in user-mode.
        //
        fileObject = NULL;
        Status = ObReferenceObjectByHandle(
                    LoggerInfo->LogFileHandle,
                    0L,
                    IoFileObjectType,
                    RequestorMode,
                    (PVOID *) &fileObject,
                    &handleInformation);
        if (!NT_SUCCESS(Status)) {
            goto ReleaseAndExit;
        }

        if (RequestorMode != KernelMode) {
            grantedAccess = handleInformation.GrantedAccess;
            if (!SeComputeGrantedAccesses(grantedAccess, FILE_WRITE_DATA)) {
                ObDereferenceObject( fileObject );
                Status = STATUS_ACCESS_DENIED;
                goto ReleaseAndExit;
            }
        }
        ObDereferenceObject(fileObject); // Referenced in WmipCreateLogFile

        // Obtain the security context here so we can use it
        // later to impersonate the user, which we will do
        // if we cannot access the file as SYSTEM.  This
        // usually occurs if the file is on a remote machine.
        //
        ServiceQos.Length  = sizeof(SECURITY_QUALITY_OF_SERVICE);
        ServiceQos.ImpersonationLevel = SecurityImpersonation;
        ServiceQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        ServiceQos.EffectiveOnly = TRUE;
        Status = SeCreateClientSecurity(
                    CONTAINING_RECORD(KeGetCurrentThread(), ETHREAD, Tcb),
                    &ServiceQos,
                    FALSE,
                    & LoggerContext->ClientSecurityContext);
        if (!NT_SUCCESS(Status)) {
            goto ReleaseAndExit;
        }

        if (LoggerInfo->Checksum != NULL) {
            if (LoggerContext->LoggerHeader == NULL) {
                LoggerContext->LoggerHeader =
                    ExAllocatePoolWithTag(
                        PagedPool,
                        sizeof(WNODE_HEADER) + sizeof(TRACE_LOGFILE_HEADER),
                        TRACEPOOLTAG);
            }

    //
    // Although we allocate sizeof(WNODE_HEADER) + sizeof(TRACE_LOGFILE_HEADER)
    // chunk, we will only copy sizeof(WNODE_HEADER) + 
    // FIELD_OFFSET(TRACE_LOGFILE_HEADER, LoggerName) because we will not use 
    // the parts after the pointers. Also, this prevents AV when WOW UpdateTrace
    // calls are made with 32 bit TRACE_LOGFILE_HEADER.
    //

            if (LoggerContext->LoggerHeader != NULL) {
                RtlCopyMemory(
                    LoggerContext->LoggerHeader,
                    LoggerInfo->Checksum,
                    sizeof(WNODE_HEADER) + FIELD_OFFSET(TRACE_LOGFILE_HEADER, LoggerName));
            }
        }

        // We try to update the file name using LoggerContext->NewLogFileName.
        // This is freed by WmipCreateLogFile() in the logger thread. 
        // This have to be NULL. 
        if (NewLogFileName.Buffer != NULL) {
            ASSERT(LoggerContext->NewLogFileName.Buffer == NULL);
            LoggerContext->NewLogFileName = NewLogFileName;
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
            goto ReleaseAndExit;
        }

        //
        // Reset the event inside the mutex before waiting on it. 
        //
        KeResetEvent(&LoggerContext->FlushEvent);

        ZwClose(LoggerInfo->LogFileHandle);
        LoggerInfo->LogFileHandle = NULL;

        // must turn on flag just before releasing semaphore
        LoggerContext->RequestFlag |= REQUEST_FLAG_NEW_FILE;
        // Wake up the logger thread (system) to change the file
        Status = WmipNotifyLogger(LoggerContext);
        if (!NT_SUCCESS(Status)) {
            goto ReleaseAndExit;
        }
        // use the same event initialized by start logger
        //
        KeWaitForSingleObject(
            &LoggerContext->FlushEvent,
            Executive,
            KernelMode,
            FALSE,
            &TimeOut
            );
        KeResetEvent(&LoggerContext->FlushEvent);
        Status = LoggerContext->LoggerStatus;

        if (!NT_SUCCESS(Status) || !LoggerContext->CollectionOn) {
            goto ReleaseAndExit;
        }

        if (bDelayOpenFlag && (LoggerContext->LoggerId == WmipKernelLogger)) {
            LONG PerfLogInTransition;
            //
            // This is a update call from advapi32.dll after RunDown.
            // Call PerfInfoStartLog.
            //

            if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
                FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &EnableFlags;
                if ((FlagExt->Length == 0) || 
                    (FlagExt->Offset == 0) || 
                    (LoggerInfo->Wnode.BufferSize < FlagExt->Offset)) {
                    Status = STATUS_INVALID_PARAMETER;
                    goto ReleaseAndExit;
                }

                if ((FlagExt->Length * sizeof(ULONG)) >
                    (LoggerInfo->Wnode.BufferSize - FlagExt->Offset)) {
                    Status = STATUS_INVALID_PARAMETER;
                    goto ReleaseAndExit;
                }
                GroupMaskSize = FlagExt->Length * sizeof(ULONG);
                if (GroupMaskSize < sizeof(PERFINFO_GROUPMASK)) {
                    GroupMaskSize = sizeof(PERFINFO_GROUPMASK);
                }
            } else {
                GroupMaskSize = sizeof(PERFINFO_GROUPMASK);
            }

            LoggerContext->EnableFlagArray = (PULONG) WmipExtendBase(LoggerContext, GroupMaskSize);

            if (LoggerContext->EnableFlagArray) {
                PCHAR FlagArray;

                RtlZeroMemory(LoggerContext->EnableFlagArray, GroupMaskSize);
                if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
                    FlagArray = (PCHAR) (FlagExt->Offset + (PCHAR) LoggerInfo);
            
                    //
                    // Copy only the bytes actually supplied
                    //
                    RtlCopyMemory(LoggerContext->EnableFlagArray, FlagArray, FlagExt->Length * sizeof(ULONG));
            
                    EnableFlags = LoggerContext->EnableFlagArray[0];
            
                } else {
                    LoggerContext->EnableFlagArray[0] = EnableFlags;
                }
                // We need to protect PerfInfoStartLog from stopping thread.
                PerfLogInTransition =
                    InterlockedCompareExchange(&LoggerContext->PerfLogInTransition,
                                PERF_LOG_START_TRANSITION,
                                PERF_LOG_NO_TRANSITION);
                if (PerfLogInTransition != PERF_LOG_NO_TRANSITION) {
                    Status = STATUS_ALREADY_DISCONNECTED;
                    goto ReleaseAndExit;
                }
                PerfGroupMasks = (PERFINFO_GROUPMASK *) &LoggerContext->EnableFlagArray[0];
                Status = PerfInfoStartLog(PerfGroupMasks, PERFINFO_START_LOG_POST_BOOT);
                PerfLogInTransition =
                    InterlockedExchange(&LoggerContext->PerfLogInTransition,
                                PERF_LOG_NO_TRANSITION);
                ASSERT(PerfLogInTransition == PERF_LOG_START_TRANSITION);
                if (!NT_SUCCESS(Status)) {
                    goto ReleaseAndExit;
                }

            } else {
                Status = STATUS_NO_MEMORY;
                goto ReleaseAndExit;
            }
        }
    }

    if (LoggerContext->KernelTraceOn &&
        LoggerId == WmipKernelLogger &&
        IsEqualGUID(&LoggerInfo->Wnode.Guid, &SystemTraceControlGuid)) {
        TmpFlags = (~LoggerContext->EnableFlags & EnableFlags);
        if (TmpFlags != 0) {
            WmipEnableKernelTrace(TmpFlags);
        }
        TmpFlags = (LoggerContext->EnableFlags & ~EnableFlags);
        if (TmpFlags != 0) {
            WmipDisableKernelTrace(TmpFlags);
        }
        LoggerContext->EnableFlags = EnableFlags;
    }

    //
    // Cap Maximum Buffers to Max_Buffers
    //

    if ( LoggerInfo->MaximumBuffers > 0 ) {
        Max_Buffers = (LoggerContext->BufferSize > 0) ? 
                           (ULONG) (MmMaximumNonPagedPoolInBytes
                            / TRACE_MAXIMUM_NP_POOL_USAGE
                            / LoggerContext->BufferSize)
                        : 0;

        if (LoggerInfo->MaximumBuffers > Max_Buffers ) {
            LoggerInfo->MaximumBuffers = Max_Buffers;
        }
        if (LoggerInfo->MaximumBuffers > LoggerContext->MaximumBuffers) {
            LoggerContext->MaximumBuffers = LoggerInfo->MaximumBuffers;
        }

    }

    // Allow changing of FlushTimer
    if (LoggerInfo->FlushTimer > 0) {
        LoggerContext->FlushTimer = LoggerInfo->FlushTimer;
    }

    if (NewMode & EVENT_TRACE_KD_FILTER_MODE) {
        LoggerMode |= EVENT_TRACE_KD_FILTER_MODE;
        LoggerContext->BufferCallback = &KdReportTraceData;
    }
    else {
        LoggerMode &= ~EVENT_TRACE_KD_FILTER_MODE;
        if (LoggerContext->BufferCallback == &KdReportTraceData) {
            LoggerContext->BufferCallback = NULL;
        }
    }
    if (LoggerContext->LoggerMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE) {
        LoggerContext->LoggerMode = LoggerMode;
    }
    else {
        LoggerContext->LoggerMode = 
            (LoggerMode & ~EVENT_TRACE_DELAY_OPEN_FILE_MODE);
    }
    Status = WmipQueryLogger(LoggerInfo, LoggerContext);

ReleaseAndExit:
    InterlockedDecrement(&LoggerContext->MutexCount);
    TraceDebug((1, "WmiUpdateTrace: Release mutex5 %d %d\n",
        LoggerId, LoggerContext->MutexCount));
    WmipReleaseMutex(&LoggerContext->LoggerMutex);

#if DBG
    RefCount =
#endif
    WmipDereferenceLogger(LoggerId);
    TraceDebug((1, "WmiUpdateTrace: %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));

    return Status;
}


NTKERNELAPI
NTSTATUS
WmiFlushTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    It is called by WmipIoControl in wmi.c, with IOCTL_WMI_FLUSH_LOGGER
    to flush all the buffers out of a particular logger

Arguments:

    LoggerInfo      a pointer to the structure for the logger's control
                    and status information

Return Value:

    The status of performing the action requested.

--*/

{
    NTSTATUS Status;
    PWMI_LOGGER_CONTEXT LoggerContext = NULL;
    ACCESS_MASK     DesiredAccess = TRACELOG_GUID_ENABLE;
    ULONG           LoggerId;
    ULONG           LoggerMode;
#if DBG
    LONG            RefCount;
#endif

    PAGED_CODE();
    //
    // see if Logger is running properly first. Error checking will be done
    // in WmiQueryTrace
    //

    if (LoggerInfo == NULL)
        return STATUS_INVALID_PARAMETER;

    TraceDebug((1, "WmiFlushTrace: %d\n",
                    LoggerInfo->Wnode.HistoricalContext));
#if DBG
    Status = WmipVerifyLoggerInfo(LoggerInfo, &LoggerContext, "WmiFlushTrace");
#else
    Status = WmipVerifyLoggerInfo(LoggerInfo, &LoggerContext);
#endif
    if (!NT_SUCCESS(Status) || (LoggerContext == NULL))
        return Status;

    LoggerId = LoggerContext->LoggerId;

    LoggerMode = LoggerContext->LoggerMode;
    if (LoggerMode & EVENT_TRACE_REAL_TIME_MODE) {
        DesiredAccess |= TRACELOG_CREATE_REALTIME;
    } 
    if (LoggerInfo->LogFileHandle != NULL) {
        DesiredAccess |= TRACELOG_CREATE_ONDISK;
    }
    if (LoggerContext->KernelTraceOn) {
        DesiredAccess |= TRACELOG_ACCESS_KERNEL_LOGGER;
    }
    Status = WmipCheckGuidAccess(
                &LoggerContext->InstanceGuid,
                DesiredAccess,
                EtwpDefaultTraceSecurityDescriptor
                );
    if (!NT_SUCCESS(Status)) {
        InterlockedDecrement(&LoggerContext->MutexCount);
        TraceDebug((1, "WmiFlushTrace: Release mutex1 %d %d\n",
            LoggerContext->LoggerId, LoggerContext->MutexCount));
        WmipReleaseMutex(&LoggerContext->LoggerMutex);
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmiFlushTrace: Status2=%X %d %d->%d\n",
                        Status, LoggerId, RefCount+1, RefCount));
        return Status;
    }

    Status = WmipFlushLogger(LoggerContext, TRUE);
    if (NT_SUCCESS(Status)) {
        Status = WmipQueryLogger(LoggerInfo, LoggerContext);
    }
    InterlockedDecrement(&LoggerContext->MutexCount);
    TraceDebug((1, "WmiFlushTrace: Release mutex %d %d\n",
        LoggerContext->LoggerId, LoggerContext->MutexCount));
    WmipReleaseMutex(&LoggerContext->LoggerMutex);
#if DBG
    RefCount =
#endif
    WmipDereferenceLogger(LoggerId);
    TraceDebug((1, "WmiFlushTrace: %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));

    return Status;
}

//
// Trace Provider APIs
//
NTKERNELAPI
NTSTATUS
FASTCALL
WmiGetClockType(
    IN TRACEHANDLE LoggerHandle,
    OUT WMI_CLOCK_TYPE  *ClockType
    )
/*++

Routine Description:

    This is called by anyone internal to find the clock type 
    that is in use with a logger specified by the LoggerHandle

Arguments:

    LoggerHandle         Handle to a tracelog session

Return Value:

    The clock type

--*/

{
    ULONG   LoggerId;
#if DBG
    LONG    RefCount;
#endif
    PWMI_LOGGER_CONTEXT LoggerContext;

    LoggerId = WmiGetLoggerId(LoggerHandle);
    if (LoggerId < 1 || LoggerId >= MAXLOGGERS)
       return STATUS_INVALID_HANDLE;
#if DBG
 RefCount =
#endif
    WmipReferenceLogger(LoggerId);
    TraceDebug((4, "WmiGetClockType: %d %d->%d\n",
                 LoggerId, RefCount-1, RefCount));

    LoggerContext = WmipGetLoggerContext( LoggerId );
    if (!WmipIsValidLogger(LoggerContext)) {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((4, "WmiGetClockType: Status=%X %d %d->%d\n",
                        STATUS_WMI_INSTANCE_NOT_FOUND,
                        LoggerId, RefCount+1, RefCount));
        return STATUS_WMI_INSTANCE_NOT_FOUND;
    }

    *ClockType = WMICT_SYSTEMTIME;    // Default Clock Type

    if (LoggerContext->UsePerfClock & EVENT_TRACE_CLOCK_PERFCOUNTER) {
        *ClockType = WMICT_PERFCOUNTER;
    }
    else if (LoggerContext->UsePerfClock & EVENT_TRACE_CLOCK_CPUCYCLE) {
        *ClockType = WMICT_CPUCYCLE;
    }

#if DBG
    RefCount =
#endif
    WmipDereferenceLogger(LoggerId);

    return STATUS_SUCCESS;

}


NTKERNELAPI
LONG64
FASTCALL
WmiGetClock(
    IN WMI_CLOCK_TYPE ClockType,
    IN PVOID Context
    )
/*++

Routine Description:

    This is called anyone internal to use a particular clock for
    sequencing events.

Arguments:

    ClockType       Should use WMICT_DEFAULT most of the time.
                    Other clock types are for perf group.
    Context         Only used for process/thread times

Return Value:

    The clock value

--*/

{
    LARGE_INTEGER Clock;
    ULONG TotalKernel;
    ULONG TotalUser;

    switch (ClockType) {
        case WMICT_DEFAULT :
            Clock.QuadPart = (*WmiGetCpuClock)();
            break;
        case WMICT_SYSTEMTIME:
            Clock.QuadPart = WmipGetSystemTime();
            break;
        case WMICT_CPUCYCLE:
            Clock.QuadPart = PerfGetCycleCount();
            break;
        case WMICT_PERFCOUNTER:
            Clock.QuadPart = WmipGetPerfCounter();
            break;
        case WMICT_PROCESS :  // defaults to Process times for now
        {
            PEPROCESS Process = (PEPROCESS) Context;
            if (Process == NULL)
                Process = PsGetCurrentProcess();
            else {
                ObReferenceObject(Process);
            }

            TotalKernel = KeQueryRuntimeProcess(&Process->Pcb, &TotalUser);
            Clock.HighPart = TotalKernel;
            Clock.LowPart  = TotalUser;
            if (Context) {
                ObDereferenceObject(Process);
            }
            break;
        }
        case WMICT_THREAD  :  // defaults to Thread times for now
        {
            PETHREAD Thread = (PETHREAD) Context;
            if (Thread == NULL)
                Thread = PsGetCurrentThread();
            else {
                ObReferenceObject(Thread);
            }
            Clock.HighPart = Thread->Tcb.KernelTime;
            Clock.LowPart  = Thread->Tcb.UserTime;
            if (Context) {
                ObDereferenceObject(Thread);
            }
            break;
        }
        default :
            KeQuerySystemTime(&Clock);
    }
    return ((LONG64) Clock.QuadPart);
}

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTraceEvent (
    __in HANDLE TraceHandle,
    __in ULONG Flags,
    __in ULONG FieldSize,
    __in PVOID Fields
    )

/*++
Routine Description:

    This routine is used by WMI data providers to trace events.
    It calls different tracing functions depending on the Flags.

Arguments:

    TraceHandle     LoggerId
    Flags           Flags that indicate the type of the data being passed
    FieldSize       Size of the Fields
    Fields          Pointer to actual data (events)

Return Value:

    STATUS_SUCCESS  if the event trace is recorded successfully

--*/
{
    NTSTATUS Status;
    if (Flags & ETW_NT_FLAGS_TRACE_HEADER) {

retry:
        Status = WmiTraceEvent((PWNODE_HEADER)Fields, KeGetPreviousMode());

        if (Status == STATUS_NO_MEMORY) {
            //
            // This logging is from user mode, try to allocate more buffer.
            //
            PWNODE_HEADER Wnode=(PWNODE_HEADER) Fields;
            ULONG LoggerId=0;
            PWMI_LOGGER_CONTEXT LoggerContext;

            try {
                LoggerId = WmiGetLoggerId(Wnode->HistoricalContext);
            } except  (EXCEPTION_EXECUTE_HANDLER) {
                TraceDebug((1, "NtTraceEvent: Status=EXCEPTION\n"));
                return GetExceptionCode();
            }


            if (LoggerId < 1 || LoggerId >= MAXLOGGERS) {
                Status = STATUS_INVALID_HANDLE;
            } else {
                WmipReferenceLogger(LoggerId);

                LoggerContext = WmipGetLoggerContext(LoggerId);

                //
                // Make sure collection is still on before allocate more
                // free buffers.  This makes sure that logger thread
                // can free all allocated buffers.
                //
                if (WmipIsValidLogger(LoggerContext) && 
                                LoggerContext->CollectionOn) 
                {
                    if (WmipAllocateFreeBuffers (LoggerContext, 1) == 1) {
                        WmipDereferenceLogger(LoggerId);
                        InterlockedDecrement((PLONG)&LoggerContext->EventsLost);
                        goto retry;
                    } else {
                        Status = STATUS_NO_MEMORY;
                    }
                }
                WmipDereferenceLogger(LoggerId);
            }
        }
    }
    else if (Flags & ETW_NT_FLAGS_TRACE_MESSAGE) {
        if (FieldSize < sizeof(MESSAGE_TRACE_USER)) {
            return (STATUS_UNSUCCESSFUL);
        }
        try {
            ProbeForRead(
                    Fields,
                    FieldSize,
                    sizeof (UCHAR)
                    );

            if (((PMESSAGE_TRACE_USER)Fields)->DataSize > FieldSize - FIELD_OFFSET(MESSAGE_TRACE_USER, Data)) {
                
                //
                // The embedded 'Data' is suppose to be within the Field (FieldSize), if exceeded,
                // we are likely trying to read others buffer.
                //      Fail It.
                //
                return STATUS_INVALID_BUFFER_SIZE;
            }

            return (WmiTraceMessage((TRACEHANDLE)TraceHandle,
                                    ((PMESSAGE_TRACE_USER)Fields)->MessageFlags,
                                    &((PMESSAGE_TRACE_USER)Fields)->MessageGuid,
                                    ((PMESSAGE_TRACE_USER)Fields)->MessageHeader.Packet.MessageNumber,
                                    &((PMESSAGE_TRACE_USER)Fields)->Data,
                                    (SIZE_T)((PMESSAGE_TRACE_USER)Fields)->DataSize,
                                    NULL,
                                    (SIZE_T)0));

        } except  (EXCEPTION_EXECUTE_HANDLER) {
            TraceDebug((1, "NtTraceEvent: (ETW_NT_FLAGS_TRACE_MESSAGE) Status=EXCEPTION\n"));
            return GetExceptionCode();
        }
    }
    else {
        Status = STATUS_INVALID_PARAMETER;
    }
    return Status;
}


NTKERNELAPI
NTSTATUS
FASTCALL
WmiTraceEvent(
    IN PWNODE_HEADER Wnode,
    IN KPROCESSOR_MODE RequestorMode
    )
/*++

Routine Description:

    This routine is used by WMI data providers to trace events.
    It expects the user to pass in the handle to the logger.
    Also, the user cannot ask to log something that is larger than
    the buffer size (minus buffer header).

    This routine works at IRQL <= DISPATCH_LEVEL

Arguments:

    Wnode           The WMI node header that will be overloaded


Return Value:

    STATUS_SUCCESS  if the event trace is recorded successfully

--*/
{
    PEVENT_TRACE_HEADER TraceRecord = (PEVENT_TRACE_HEADER) Wnode;
    ULONG WnodeSize, Size, LoggerId = 0, Flags, HeaderSize;
    PWMI_BUFFER_HEADER BufferResource = NULL;
    NTSTATUS Status;
    PETHREAD Thread;
    PWMI_LOGGER_CONTEXT LoggerContext = NULL;
    ULONG Marker;
    MOF_FIELD MofFields[MAX_MOF_FIELDS];
    long MofCount = 0;
    LONG LoggerLocked = 0;
    LARGE_INTEGER TimeStamp;
#if DBG
    LONG RefCount = 0;
#endif

    if (TraceRecord == NULL)
        return STATUS_SEVERITY_WARNING;

    HeaderSize = sizeof(WNODE_HEADER);  // same size as EVENT_TRACE_HEADER

    try {

        if (RequestorMode != KernelMode) {
            ProbeForRead(
                TraceRecord,
                sizeof (EVENT_TRACE_HEADER),
                sizeof (UCHAR)
                );

            Marker = Wnode->BufferSize;     // check the first DWORD flags
            Size = Marker;

            if (Marker & TRACE_HEADER_FLAG) {
                if ( ((Marker & TRACE_HEADER_ENUM_MASK) >> 16)
                        == TRACE_HEADER_TYPE_INSTANCE )
                    HeaderSize = sizeof(EVENT_INSTANCE_GUID_HEADER);
                Size = TraceRecord->Size;
            }
        }
        else {
            Size = Wnode->BufferSize;     // take the first DWORD flags
            Marker = Size;
            if (Marker & TRACE_HEADER_FLAG) {
                if ( ((Marker & TRACE_HEADER_ENUM_MASK) >> 16)
                        == TRACE_HEADER_TYPE_INSTANCE )
                    HeaderSize = sizeof(EVENT_INSTANCE_GUID_HEADER);
                Size = TraceRecord->Size;
            }
        }
        WnodeSize = Size;           // WnodeSize is for the contiguous block
                                    // Size is for what we want in buffer

        Flags = Wnode->Flags;
        if (!(Flags & WNODE_FLAG_LOG_WNODE) &&
            !(Flags & WNODE_FLAG_TRACED_GUID)) {
            return STATUS_UNSUCCESSFUL;
        }

        LoggerId = WmiGetLoggerId(Wnode->HistoricalContext);
        if (LoggerId < 1 || LoggerId >= MAXLOGGERS) {
            return STATUS_INVALID_HANDLE;
        }

        LoggerLocked = WmipReferenceLogger(LoggerId);
#if DBG
        RefCount = LoggerLocked;
#endif
        TraceDebug((4, "WmiTraceEvent: %d %d->%d\n",
                        LoggerId, RefCount-1, RefCount));
        LoggerContext = WmipGetLoggerContext(LoggerId);
        if (!WmipIsValidLogger(LoggerContext)) {
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceEvent: Status1=%X %d %d->%d\n",
                            STATUS_INVALID_HANDLE, LoggerId,
                            RefCount+1, RefCount));
            return STATUS_INVALID_HANDLE;
        }

        if ((RequestorMode == KernelMode) &&
            (LoggerContext->LoggerMode & EVENT_TRACE_USE_PAGED_MEMORY)) {
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceEvent: Status1=%X %d %d->%d\n",
                            STATUS_UNSUCCESSFUL, LoggerId,
                            RefCount+1, RefCount));
            return STATUS_UNSUCCESSFUL;
        }

        if (Flags & WNODE_FLAG_USE_MOF_PTR) {
        //
        // Need to compute the total size required, since the MOF fields
        // in Wnode merely contains pointers
        //
            long i;
            PCHAR Offset = ((PCHAR)Wnode) + HeaderSize;
            ULONG MofSize, MaxSize;

            MaxSize = LoggerContext->BufferSize - sizeof(WMI_BUFFER_HEADER);
            MofSize = WnodeSize - HeaderSize;
            // allow only the maximum
            if (MofSize > (sizeof(MOF_FIELD) * MAX_MOF_FIELDS)) {
                WmipDereferenceLogger(LoggerId);
                return STATUS_ARRAY_BOUNDS_EXCEEDED;
            }
            if (MofSize > 0) {               // Make sure we can read the rest
                if (RequestorMode != KernelMode) {
                    ProbeForRead( Offset, MofSize, sizeof (UCHAR) );
                }
                RtlCopyMemory(MofFields, Offset, MofSize);
            }
            Size = HeaderSize;

            MofCount = MofSize / sizeof(MOF_FIELD);
            for (i=0; i<MofCount; i++) {
                MofSize = MofFields[i].Length;
                if (MofSize >= (MaxSize - Size)) {  // check for overflow first
#if DBG
                    RefCount =
#endif
                    WmipDereferenceLogger(LoggerId);
                    TraceDebug((4, "WmiTraceEvent: Status2=%X %d %d->%d\n",
                                    STATUS_BUFFER_OVERFLOW, LoggerId,
                                    RefCount+1, RefCount));
                    return STATUS_BUFFER_OVERFLOW;
                }

                Size += MofSize;
            }
        }

        if ((LoggerContext->RequestFlag & REQUEST_FLAG_CIRCULAR_PERSIST) &&
            (LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_CIRCULAR)) {
            if (! (Flags & WNODE_FLAG_PERSIST_EVENT) ) {
                ULONG RequestFlag = LoggerContext->RequestFlag
                                  & (~ (  REQUEST_FLAG_CIRCULAR_PERSIST
                                        | REQUEST_FLAG_CIRCULAR_TRANSITION));

                if (InterlockedCompareExchange(
                              (PLONG) &LoggerContext->RequestFlag,
                              RequestFlag | REQUEST_FLAG_CIRCULAR_TRANSITION,
                              RequestFlag | REQUEST_FLAG_CIRCULAR_PERSIST)) {

                    // All persistence events are fired in circular
                    // logfile, flush out all active buffers and flushlist
                    // buffers. Also mark the end of persistence event
                    // collection in circular logger.
                    //
                    // It is the provider's responsibility to ensure that 
                    // no persist event fires after this point. If it did,
                    // that event may be  overwritten during wrap around.
                    //
                    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
                        Status = WmipFlushLogger(LoggerContext, TRUE);
                    }
                }
            }
        }

// So, now reserve some space in logger buffer and set that to TraceRecord

        TraceRecord = (PEVENT_TRACE_HEADER)
            WmipReserveTraceBuffer( LoggerContext,
                                    Size,
                                    &BufferResource,
                                    &TimeStamp);

        if (TraceRecord == NULL) {
#if DBG
        RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceEvent: Status4=%X %d %d->%d\n",
                            STATUS_NO_MEMORY, LoggerId,
                            RefCount+1, RefCount));
            return STATUS_NO_MEMORY;
        }

        if (Flags & WNODE_FLAG_USE_MOF_PTR) {
        //
        // Now we need to probe and copy all the MOF data fields
        //
            PVOID MofPtr;
            ULONG MofLen;
            long i;
            PCHAR TraceOffset = (PCHAR) TraceRecord + HeaderSize;

            if (RequestorMode != KernelMode) {
                ProbeForRead(Wnode, HeaderSize, sizeof(UCHAR));
            }
            RtlCopyMemory(TraceRecord, Wnode, HeaderSize);
            TraceRecord->Size = (USHORT)Size;           // reset to Total Size
            for (i=0; i<MofCount; i++) {
                MofPtr = (PVOID) (ULONG_PTR) MofFields[i].DataPtr;
                MofLen = MofFields[i].Length;

                if (MofPtr == NULL || MofLen == 0)
                    continue;

                if (RequestorMode != KernelMode) {
                    ProbeForRead(MofPtr, MofLen, sizeof(UCHAR));
                }
                RtlCopyMemory(TraceOffset, MofPtr, MofLen);
                TraceOffset += MofLen;
            }
        }
        else {
            if (RequestorMode != KernelMode) {
                ProbeForRead(Wnode, Size, sizeof(UCHAR));
            }
            RtlCopyMemory(TraceRecord, Wnode, Size);
        }
        if (Flags & WNODE_FLAG_USE_GUID_PTR) {
            PVOID GuidPtr = (PVOID) (ULONG_PTR) ((PEVENT_TRACE_HEADER)Wnode)->GuidPtr;

            if (RequestorMode != KernelMode) {
                ProbeForReadSmallStructure(GuidPtr, sizeof(GUID), sizeof(UCHAR));
            }
            RtlCopyMemory(&TraceRecord->Guid, GuidPtr, sizeof(GUID));
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        if (BufferResource != NULL) {
            WmipReleaseTraceBuffer ( BufferResource, LoggerContext );
        }
        else {
            if (LoggerLocked) {
#if DBG
                RefCount =
#endif
                WmipDereferenceLogger(LoggerId);
            }
        }
        TraceDebug((4, "WmiTraceEvent: Status5=EXCEPTION %d %d->%d\n",
                        LoggerId, RefCount+1, RefCount));
        return GetExceptionCode();
    }

    //
    // By now, we have reserved space in the trace buffer
    //

    if (Marker & TRACE_HEADER_FLAG) {
        if (! (WNODE_FLAG_USE_TIMESTAMP & TraceRecord->Flags) ) {
            TraceRecord->TimeStamp = TimeStamp;
        }
        Thread = PsGetCurrentThread();
        if (Thread != NULL) {
            TraceRecord->KernelTime = Thread->Tcb.KernelTime;
            TraceRecord->UserTime   = Thread->Tcb.UserTime;
            TraceRecord->ThreadId   = HandleToUlong(Thread->Cid.UniqueThread);
            TraceRecord->ProcessId  = HandleToUlong(Thread->Cid.UniqueProcess);
        }
    }

    WmipReleaseTraceBuffer( BufferResource, LoggerContext );
    TraceDebug((4, "WmiTraceEvent: %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));

    return STATUS_SUCCESS;
}


NTKERNELAPI
NTSTATUS
WmiTraceKernelEvent(
    IN ULONG GroupType,         // Group/type code for kernel event
    IN PVOID EventInfo,         // Event data as defined in MOF
    IN ULONG EventInfoLen,      // Length of the event data
    IN PETHREAD Thread )        // use NULL for current caller thread
/*++

Routine Description:

    This routine is used by trace kernel events only. These events can
    be charged to the given thread instead of the running thread. Because
    it can be called by I/O events at DPC level, this routine cannot be
    pageable when tracing is on.

    This routine works at IRQL <= DISPATCH_LEVEL

Arguments:

    GroupType       a ULONG key to indicate the action to be taken

    EventInfo       a pointer to contiguous memory containing information
                    to be attached to event trace

    EventInfoLen    length of EventInfo

    Thread          Pointer to thread where event is to be charged.
                    Currently used by disk IO and thread events.

Return Value:

    The status of performing the action requested

--*/
{
    PSYSTEM_TRACE_HEADER Header;
    ULONG Size;
    PWMI_BUFFER_HEADER BufferResource = NULL;
    PWMI_LOGGER_CONTEXT LoggerContext = WmipLoggerContext[WmipKernelLogger];
    LARGE_INTEGER TimeStamp;
#if DBG
    LONG    RefCount;
#endif

#if DBG
    RefCount =
#endif
    WmipReferenceLogger(WmipKernelLogger);
    TraceDebug((4, "WmiTraceKernelEvent: 0 %d->%d\n", RefCount-1, RefCount));
// Make sure that kernel logger is enabled first
    if (!WmipIsValidLogger(LoggerContext)) {
        WmipDereferenceLogger(WmipKernelLogger);
        return STATUS_ALREADY_DISCONNECTED;
    }

// Compute total size of event trace record
    Size = sizeof(SYSTEM_TRACE_HEADER) + EventInfoLen;

    Header = (PSYSTEM_TRACE_HEADER)
            WmipReserveTraceBuffer( LoggerContext,
                                    Size,
                                    &BufferResource,
                                    &TimeStamp);

    if (Header == NULL) {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(WmipKernelLogger);
        TraceDebug((4, "WmiTraceKernelEvent: Status1=%X 0 %d->%d\n",
                        STATUS_NO_MEMORY, RefCount+1, RefCount));
        return STATUS_NO_MEMORY;
    }

    // Get the current system time as time stamp for trace record
    Header->SystemTime = TimeStamp;

    if (Thread == NULL) {
        Thread = PsGetCurrentThread();
    }

//
// Now copy the necessary information into the buffer
//

    Header->Marker       = SYSTEM_TRACE_MARKER;
    Header->ThreadId     = HandleToUlong(Thread->Cid.UniqueThread);
    Header->ProcessId    = HandleToUlong(Thread->Cid.UniqueProcess);
    Header->KernelTime   = Thread->Tcb.KernelTime;
    Header->UserTime     = Thread->Tcb.UserTime;

    Header->Header       = (GroupType << 16) + Size;

    if (EventInfoLen > 0) {
        RtlCopyMemory (
            (UCHAR*) Header + sizeof(SYSTEM_TRACE_HEADER),
            EventInfo, EventInfoLen);
    }

#if DBG
    RefCount = WmipRefCount[LoggerContext->LoggerId] - 1;
#endif
    WmipReleaseTraceBuffer( BufferResource, LoggerContext );
    TraceDebug((4, "WmiTraceKernelEvent: 0 %d->%d\n",
                    RefCount+1, RefCount));

    return STATUS_SUCCESS;
}



NTKERNELAPI
NTSTATUS
FASTCALL
WmiTraceFastEvent(
    IN PWNODE_HEADER Wnode
    )
/*++

Routine Description:

    This routine is used by short events using abbreviated header.

    This routine should work at any IRQL.

Arguments:

    Wnode           Header of event to record


Return Value:

    The status of performing the action requested

--*/
{
    ULONG Size;
    PTIMED_TRACE_HEADER Buffer;
    PTIMED_TRACE_HEADER Header = (PTIMED_TRACE_HEADER) Wnode;
    PWMI_BUFFER_HEADER BufferResource;
    ULONG LoggerId = (ULONG) Header->LoggerId; // get the lower ULONG!!
    PULONG Marker;
    PWMI_LOGGER_CONTEXT LoggerContext;
    LARGE_INTEGER TimeStamp;
#if DBG
    LONG RefCount;
#endif

    Marker = (PULONG) Wnode;
    if ((LoggerId == WmipKernelLogger) || (LoggerId >= MAXLOGGERS))
        return STATUS_INVALID_HANDLE;

    if ((*Marker & 0xF0000000) == TRACE_HEADER_ULONG32_TIME) {
        Size = Header->Size;
        if (Size == 0)
            return STATUS_INVALID_BUFFER_SIZE;
#if DBG
        RefCount =
#endif
        WmipReferenceLogger(LoggerId);
        LoggerContext = WmipGetLoggerContext(LoggerId);
        if (!WmipIsValidLogger(LoggerContext)) {
#if DBG
        RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            return STATUS_INVALID_HANDLE;
        }
        Buffer = WmipReserveTraceBuffer(LoggerContext, 
                                        Size, 
                                        &BufferResource,
                                        &TimeStamp);
        if (Buffer == NULL) {
#if DBG
        RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            return STATUS_NO_MEMORY;
        }
        (* (PULONG) Buffer) = *Marker;
        Buffer->EventId = Header->EventId;
        Buffer->TimeStamp = TimeStamp;

        RtlCopyMemory(Buffer+1, Header+1, Size-(sizeof(TIMED_TRACE_HEADER)));
        WmipReleaseTraceBuffer(BufferResource, LoggerContext);
        return STATUS_SUCCESS;
    }
    TraceDebug((4, "WmiTraceFastEvent: Invalid header %X\n", *Marker));
    return STATUS_INVALID_PARAMETER;
}

NTKERNELAPI
NTSTATUS
WmiTraceMessage(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    ...
)

/*++
Routine Description:
This routine is used by WMI data providers to trace Messages.
It expects the user to pass in the handle to the logger.
Also, the user cannot ask to log something that is larger than
the buffer size (minus buffer header).

Arguments:
//    IN TRACEHANDLE LoggerHandle   - LoggerHandle obtained earlier
//    IN ULONG MessageFlags,        - Flags which both control what standard values are logged and
//                                    the lower 16-bits are also included in the message header
//                                    to control decoding
//    IN PGUID MessageGuid,         - Pointer to the message GUID of this set of messages or if
//                                    TRACE_COMPONENTID is set the actual compnent ID
//    IN USHORT MessageNumber,      - The type of message being logged, associates it with the 
//                                    appropriate format string  
//    ...                           - List of arguments to be processed with the format string
//                                    these are stored as pairs of
//                                      PVOID - ptr to argument
//                                      ULONG - size of argument
//                                    and terminated by a pointer to NULL, length of zero pair.


Return Value:
STATUS_SUCCESS if the event trace is recorded successfully

NOTE:
        this routine is called from WmiTraceUserMessage path via an IOCTL so the probes and
        try/excepts have to be carefully managed
--*/
{
    va_list MessageArgList ;

    va_start(MessageArgList,MessageNumber);

    return (WmiTraceMessageVa(LoggerHandle,
                              MessageFlags,
                              MessageGuid,
                              MessageNumber,
                              MessageArgList));
}


NTSTATUS
WmiTraceMessageVa(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    va_list         MessageArgList
)
/*++ WmiTraceMessageVa
         The VA version of WmiTraceMessage
NOTE:
        this routine is called from WmiTraceUserMessage path via an IOCTL so the probes and
        try/excepts have to be carefully managed
--*/
{
    SIZE_T dataBytes;
    PMESSAGE_TRACE_HEADER Header;
    PUCHAR pMessageData ;
    PWMI_BUFFER_HEADER BufferResource = NULL ;
    USHORT size ;
    ULONG  LoggerId = (ULONG)-1 ; // initialize so we don't unlock it if not set
    ULONG SequenceNumber ;
    PWMI_LOGGER_CONTEXT LoggerContext = NULL;
    LARGE_INTEGER TimeStamp;
#if DBG
    LONG    RefCount;
#endif

    // Set the LoggerId up here, and lock it.
    // if we AV in the WmiUserTraceMessagePath we will
    // be caught by the try/except in that routine
    LoggerId = WmiGetLoggerId(LoggerHandle);
    if (LoggerId < 1 || LoggerId >= MAXLOGGERS)
       return STATUS_INVALID_HANDLE;

#if DBG
 RefCount =
#endif
    WmipReferenceLogger(LoggerId);
    TraceDebug((4, "WmiTraceMessage: %d %d->%d\n",
                 LoggerId, RefCount-1, RefCount));
    
    try {
        //
        // Determine the number bytes to follow header
        //
        dataBytes = 0;
        { // Allocation Block
            va_list ap;
            PCHAR source;
            ap = MessageArgList ;
            while ((source = va_arg (ap, PVOID)) != NULL) {
                SIZE_T elemBytes;
                if ((elemBytes = va_arg (ap, SIZE_T)) > 0) {
                    if (elemBytes > (TRACE_MESSAGE_MAXIMUM_SIZE - sizeof(MESSAGE_TRACE_USER))) {
#if DBG
     RefCount =
#endif
                         WmipDereferenceLogger(LoggerId);
                         TraceDebug((4, "WmiTraceMessage: elemBytes too big %x %d %d->%d\n",
                                   STATUS_INVALID_BUFFER_SIZE,
                                   LoggerId,
                                   RefCount + 1,
                                   RefCount));
                         return STATUS_INVALID_BUFFER_SIZE;
                    }

                   dataBytes += elemBytes;
                }      
            }

            if (dataBytes > (TRACE_MESSAGE_MAXIMUM_SIZE - sizeof(MESSAGE_TRACE_USER))) {
#if DBG
     RefCount =
#endif
                 WmipDereferenceLogger(LoggerId);
                 TraceDebug((4, "WmiTraceMessage: dataBytes too big %x %d %d->%d\n",
                           STATUS_INVALID_BUFFER_SIZE,
                           LoggerId,
                           RefCount + 1,
                           RefCount));
                 return STATUS_INVALID_BUFFER_SIZE;
            }

         } // end of allocation block

        // Figure the size of the message including the header
        size  = (USHORT) ((MessageFlags&TRACE_MESSAGE_SEQUENCE ? sizeof(ULONG):0) +
                (MessageFlags&TRACE_MESSAGE_GUID ? sizeof(GUID):0) +
                (MessageFlags&TRACE_MESSAGE_COMPONENTID ? sizeof(ULONG):0) +
        	    (MessageFlags&(TRACE_MESSAGE_TIMESTAMP | TRACE_MESSAGE_PERFORMANCE_TIMESTAMP) ? sizeof(LARGE_INTEGER):0) +
         	    (MessageFlags&TRACE_MESSAGE_SYSTEMINFO ? 2 * sizeof(ULONG):0) +
                sizeof (MESSAGE_TRACE_HEADER) +
                dataBytes);

        if (dataBytes > size) {

            //
            // We can ONLY log 64K (USHORT) data for a message. If the message is going
            // to be larger than we could log, fail it. 
            //
#if DBG
     RefCount =
#endif
                 WmipDereferenceLogger(LoggerId);
                 TraceDebug((4, "WmiTraceMessage: size overflow %x %d %d->%d\n",
                           STATUS_INVALID_BUFFER_SIZE,
                           LoggerId,
                           RefCount + 1,
                           RefCount));
                 return STATUS_INVALID_BUFFER_SIZE;            
        }

        //
        // Allocate Space in the Trace Buffer
        //
        // NOTE: we do not check for size here for reduce overhead, and because
        //       we trust ourselves to use WmiTraceLongEvent for large event traces (???)

        LoggerContext = WmipGetLoggerContext(LoggerId);
        if (!WmipIsValidLogger(LoggerContext)) {
#if DBG
     RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceMessage: Status1=%X %d %d->%d\n",
                        STATUS_INVALID_HANDLE, LoggerId,
                        RefCount+1, RefCount));
            return STATUS_INVALID_HANDLE;
        }

        if ((LoggerContext->RequestFlag & REQUEST_FLAG_CIRCULAR_PERSIST) &&
            (LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_CIRCULAR)) {
            // Reset REQUEST_FLAG_CIRCULAR_PERSIST flag
            // Since persistent events will never be mixed with TraceMessage(), 
            // we'll just reset it once and for all without flushing.
            LoggerContext->RequestFlag &= (~( REQUEST_FLAG_CIRCULAR_PERSIST
                                            | REQUEST_FLAG_CIRCULAR_TRANSITION));
        }

        if ((KeGetPreviousMode() == KernelMode) &&
            (LoggerContext->LoggerMode & EVENT_TRACE_USE_PAGED_MEMORY)) {
#if DBG
     RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceMessage: Status1=%X %d %d->%d\n",
                        STATUS_UNSUCCESSFUL, LoggerId,
                        RefCount+1, RefCount));
            return STATUS_UNSUCCESSFUL;
        }

        Header = (PMESSAGE_TRACE_HEADER) WmipReserveTraceBuffer(LoggerContext,
                                                                size,
                                                                &BufferResource,
                                                                &TimeStamp);
        if (Header == NULL) {
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceMessage: %d %d->%d\n",
                            LoggerId, RefCount+1, RefCount));

            return STATUS_NO_MEMORY;
        }
        //
        // Sequence Number is returned in the Marker field of the buffer
        //
        SequenceNumber = Header->Marker ;

        //
        // Now copy the necessary information into the buffer
        //

        Header->Marker = TRACE_MESSAGE | TRACE_HEADER_FLAG ;
        //
        // Fill in Header.
        //
        Header->Size = size ;
        Header->Packet.OptionFlags = ((USHORT)MessageFlags &
                                      (TRACE_MESSAGE_SEQUENCE |
                                      TRACE_MESSAGE_GUID |
                                      TRACE_MESSAGE_COMPONENTID |
                                      TRACE_MESSAGE_TIMESTAMP |
                                      TRACE_MESSAGE_PERFORMANCE_TIMESTAMP |
                                      TRACE_MESSAGE_SYSTEMINFO)) &
                                      TRACE_MESSAGE_FLAG_MASK ;
        // Message Number
        Header->Packet.MessageNumber =  MessageNumber ;

        //
        // Now add in the header options we counted.
        //
        pMessageData = &(((PMESSAGE_TRACE)Header)->Data);


        //
        // Note that the order in which these are added is critical New entries must
        // be added at the end!
        //
        // [First Entry] Sequence Number
        if (MessageFlags&TRACE_MESSAGE_SEQUENCE) {
            *((PULONG)pMessageData) = SequenceNumber;
        	pMessageData += sizeof(ULONG) ;
        }

        // [Second Entry] GUID ? or CompnentID ?
        if (MessageFlags&TRACE_MESSAGE_COMPONENTID) {
            *((PULONG)pMessageData) = *((PULONG) MessageGuid);
            pMessageData += sizeof(ULONG) ;
        } else if (MessageFlags&TRACE_MESSAGE_GUID) { // Can't have both
            *((LPGUID)pMessageData) = *MessageGuid;
        	pMessageData += sizeof(GUID) ;
        }
        
        // [Third Entry] Timestamp?
        if (MessageFlags&TRACE_MESSAGE_TIMESTAMP) {
            ((PLARGE_INTEGER)pMessageData)->HighPart = TimeStamp.HighPart;
            ((PLARGE_INTEGER)pMessageData)->LowPart = TimeStamp.LowPart;
            pMessageData += sizeof(LARGE_INTEGER);

        }


        // [Fourth Entry] System Information?
        // Note that some of this may NOT be valid depending on the current processing level
        // however we assume that the post-processing may still find it useful
        if (MessageFlags&TRACE_MESSAGE_SYSTEMINFO) {
            PCLIENT_ID Cid;        // avoid additional function calls

            Cid = &(PsGetCurrentThread()->Cid);
            // Executive Handles may be truncated
            *((PULONG)pMessageData) = HandleToUlong(Cid->UniqueThread);
            pMessageData += sizeof(ULONG) ;  

            *((PULONG)pMessageData) = HandleToUlong(Cid->UniqueProcess);   
            pMessageData += sizeof(ULONG) ;
        }
        //
        // Add New Header Entries immediately before this comment!
        //

        //
        // Now Copy in the Data.
        //
        { // Allocation Block
            va_list ap;
            PUCHAR source;
            ap = MessageArgList ;
            while ((source = va_arg (ap, PVOID)) != NULL) {
                SIZE_T elemBytes, copiedBytes = 0 ;
                if ((elemBytes = va_arg (ap, SIZE_T)) > 0 ) {
                    if (dataBytes < copiedBytes + elemBytes) {  // defend against bytes having changed
                        TraceDebug((1, "WmiTraceMessage: Invalid message - argument length changed"));
                        break;                                  // So we don't overrun
                    }
                    RtlCopyMemory (pMessageData, source, elemBytes);
                    copiedBytes += elemBytes ;
                    pMessageData += elemBytes;
                }
            }
        } // Allocation Block

    } except  (EXCEPTION_EXECUTE_HANDLER) {
        if (BufferResource != NULL) {
               WmipReleaseTraceBuffer ( BufferResource, LoggerContext );   // also unlocks the logger
        } else {
#if DBG
     RefCount =
#endif
             WmipDereferenceLogger(LoggerId);
        }
        TraceDebug((4, "WmiTraceMessage: Status6=EXCEPTION %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));
        return GetExceptionCode();
    }

    //
    // Buffer Complete, Release
    //
    WmipReleaseTraceBuffer( BufferResource, LoggerContext );  // Also unlocks the logger
        
    TraceDebug((4, "WmiTraceMessage: %d %d->%d\n",
                        LoggerId, RefCount+1, RefCount));

    //
    // Return Success
    //
    return (STATUS_SUCCESS);
}

NTKERNELAPI
NTSTATUS
FASTCALL
WmiTraceUserMessage(
    IN PMESSAGE_TRACE_USER pMessage,
    IN ULONG    MessageSize
    )
/*++

Routine Description:

    This routine is used by trace User messages only. it is called via an IOCTL
    on the WMI Device.

Arguments:

    pMessage    a pointer to a Marshalled Message.
    MessageSize size of that message.

Return Value:

    The status of performing the action requested

--*/
{

    if (MessageSize < sizeof(MESSAGE_TRACE_USER)) {
        return (STATUS_UNSUCCESSFUL);
    }
    try {
        ProbeForRead(
                pMessage,
                MessageSize,
                sizeof (UCHAR)
                );
        return (WmiTraceMessage(pMessage->LoggerHandle,
                                pMessage->MessageFlags,
                                &pMessage->MessageGuid,
                                pMessage->MessageHeader.Packet.MessageNumber,
                                &pMessage->Data,pMessage->DataSize,
                                NULL,0));

    } except  (EXCEPTION_EXECUTE_HANDLER) {
         
         TraceDebug((1, "WmiTraceUserMessage: Status=EXCEPTION\n"));
         return GetExceptionCode();

    }
}


NTKERNELAPI
NTSTATUS
WmiSetMark(
    IN PWMI_SET_MARK_INFORMATION MarkInfo,
    IN ULONG InBufferLen
    )
/*++

Routine Description:

    This routine sets a mark in the kernel logger.

Arguments:

    MarkInfo - a pointer to a WMI_SET_MARK_INFORMATION strcture.

    InBufferLen - Buffer Size.

Return Value:

    status

--*/
{

    NTSTATUS Status;
    PERFINFO_HOOK_HANDLE Hook;
    ULONG TotalBytes;
    ULONG CopyBytes;
    USHORT HookId;

    if (PERFINFO_IS_ANY_GROUP_ON()) {
        if (MarkInfo->Flag & WMI_SET_MARK_WITH_FLUSH) {
            if (PERFINFO_IS_GROUP_ON(PERF_FOOTPRINT)) {
                MmEmptyAllWorkingSets();
                Status = MmPerfSnapShotValidPhysicalMemory();
            }
        }
        HookId = PERFINFO_LOG_TYPE_MARK;

        CopyBytes = InBufferLen - FIELD_OFFSET(WMI_SET_MARK_INFORMATION, Mark);
        TotalBytes = CopyBytes + sizeof(WCHAR);

        Status = PerfInfoReserveBytes(&Hook, HookId, TotalBytes);

        if (NT_SUCCESS(Status)){ 
            PWCHAR Mark = PERFINFO_HOOK_HANDLE_TO_DATA(Hook, PWCHAR); 

            RtlCopyMemory(Mark, &MarkInfo->Mark[0], CopyBytes);

            Mark[CopyBytes / sizeof(WCHAR)] = UNICODE_NULL;

            PERF_FINISH_HOOK(Hook);
        }
    } else {
        Status = STATUS_WMI_SET_FAILURE;
    }

    return Status;
}

NTKERNELAPI
NTSTATUS
WmiSetTraceBufferCallback(
    IN TRACEHANDLE  TraceHandle,
    IN WMI_TRACE_BUFFER_CALLBACK Callback,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine sets a Buffer Callback function for a kernel mode logger.

Arguments:

    TraceHandle - a handle to a logger.

    Callback - a pointer to a callback function.

    Context - Callback context.

Return Value:

    status

--*/
{
    ULONG   LoggerId;
#if DBG
    LONG    RefCount;
#endif
    PWMI_LOGGER_CONTEXT LoggerContext;

    PAGED_CODE();

    if (TraceHandle == (TRACEHANDLE) 0) {
        WmipGlobalBufferCallback = Callback;
        return STATUS_SUCCESS;
    }
    LoggerId = WmiGetLoggerId(TraceHandle);
    if (LoggerId == KERNEL_LOGGER_ID) {
        LoggerId = WmipKernelLogger;
    }
    else if (LoggerId < 1 || LoggerId >= MAXLOGGERS)
       return STATUS_INVALID_HANDLE;
#if DBG
 RefCount =
#endif
    WmipReferenceLogger(LoggerId);
    TraceDebug((4, "WmiSetTraceBufferCallback: %d %d->%d\n",
                 LoggerId, RefCount-1, RefCount));

    LoggerContext = WmipGetLoggerContext( LoggerId );
    if (!WmipIsValidLogger(LoggerContext)) {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((4, "WmiSetTraceBufferCallback: Status=%X %d %d->%d\n",
                        STATUS_WMI_INSTANCE_NOT_FOUND,
                        LoggerId, RefCount+1, RefCount));
        return STATUS_WMI_INSTANCE_NOT_FOUND;
    }

    LoggerContext->BufferCallback = Callback;
    LoggerContext->CallbackContext = Context;
#if DBG
    RefCount =
#endif
    WmipDereferenceLogger(LoggerId);
    return STATUS_SUCCESS;
}


NTKERNELAPI
NTSTATUS
WmiQueryTraceInformation(
    IN TRACE_INFORMATION_CLASS TraceInformationClass,
    OUT PVOID TraceInformation,
    IN ULONG TraceInformationLength,
    OUT PULONG RequiredLength OPTIONAL,
    IN PVOID Buffer OPTIONAL
    )
/*++

Routine Description:

    This routine copies user-requested information to a user-provided buffer.
    If RequiredLength is given, the needed size for the requested information
    is returned.

Arguments:

    TraceInformationClass   Type of information requested
    TraceInformation        Output buffer for the information
    TraceInformationLength  The size of the TraceInformation
    RequiredLength          The size needed for the information
    Buffer                  Buffer used for use input. Depending on
                            TraceInformationClass, this may be required.

    NOTE: we do not consider NULL TraceInformation an error, In this case, we 
    only update RequiredLength, if that is given.

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG LoggerId;
    ULONG EnableFlags;
    ULONG EnableLevel;
    ULONG LoggersLength;
    TRACEHANDLE TraceHandle;
    TRACEHANDLE AllHandles[MAXLOGGERS];
    NTSTATUS Status = STATUS_SUCCESS;
    PWNODE_HEADER Wnode = (PWNODE_HEADER) Buffer; // For most classes, but not all

    PAGED_CODE();

    try {
        if (ARGUMENT_PRESENT(RequiredLength)) {
            *RequiredLength = 0;
        }

        switch (TraceInformationClass) {

        case TraceIdClass:

            if (TraceInformationLength != sizeof( ULONG )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }
            if (Wnode == NULL) {
                return STATUS_INVALID_PARAMETER_MIX;
            }
            TraceHandle = Wnode->HistoricalContext;
            if ((TraceHandle == 0) || (TraceHandle == (ULONG) -1)) {
                return STATUS_INVALID_HANDLE;
            }

            LoggerId = WmiGetLoggerId(TraceHandle);

            if (LoggerId > MAXLOGGERS) {
                return STATUS_INVALID_HANDLE;
            }

            if (TraceInformation) {
                *((PULONG)TraceInformation) = LoggerId;
            }
            if (ARGUMENT_PRESENT( RequiredLength )) {
                *RequiredLength = sizeof( ULONG );
            }
            break;

        case TraceHandleClass:
            if (TraceInformationLength != sizeof(TRACEHANDLE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }
            if (Buffer == NULL) {
                return STATUS_INVALID_PARAMETER_MIX;
            }
            LoggerId = *((PULONG) Buffer);
            TraceHandle = 0;
            TraceHandle = WmiSetLoggerId(LoggerId, &TraceHandle);

            if (TraceInformation) {
                *((PTRACEHANDLE)TraceInformation) = TraceHandle;
            }
            if (ARGUMENT_PRESENT( RequiredLength )) {
                *RequiredLength = sizeof( TRACEHANDLE );
            }
            break;

        case TraceEnableFlagsClass:
            if (TraceInformationLength < sizeof(ULONG)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }
            if (Wnode == NULL) {
                return STATUS_INVALID_PARAMETER_MIX;
            }
            TraceHandle = Wnode->HistoricalContext;
            if ((TraceHandle == 0) || (TraceHandle == (ULONG) -1)) {
                return STATUS_INVALID_HANDLE;
            }

            EnableFlags = WmiGetLoggerEnableFlags(TraceHandle);

            if (TraceInformation) {
                *((PULONG)TraceInformation) = EnableFlags;
            }
            if (ARGUMENT_PRESENT( RequiredLength )) {
                *RequiredLength = sizeof( ULONG );
            }
            break;

        case TraceEnableLevelClass:
            if (TraceInformationLength < sizeof(ULONG)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }
            if (Wnode == NULL) {
                return STATUS_INVALID_PARAMETER_MIX;
            }
            TraceHandle = Wnode->HistoricalContext;
            if ((TraceHandle == 0) || (TraceHandle == (ULONG) -1)) {
                return STATUS_INVALID_HANDLE;
            }

            EnableLevel = WmiGetLoggerEnableLevel(TraceHandle);

            if (TraceInformation) {
                *((PULONG)TraceInformation) = EnableLevel;
            }
            if (ARGUMENT_PRESENT( RequiredLength )) {
                *RequiredLength = sizeof( ULONG );
            }
            break;

        case GlobalLoggerHandleClass:
            if (TraceInformationLength != sizeof(TRACEHANDLE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }
            WmipReferenceLogger(WMI_GLOBAL_LOGGER_ID);
            if (WmipLoggerContext[WMI_GLOBAL_LOGGER_ID] == NULL) {
                TraceHandle = 0;
                Status = STATUS_NOT_FOUND;
            }
            else {
                TraceHandle = WmipLoggerContext[WMI_GLOBAL_LOGGER_ID]->LoggerId;
            }

            WmipDereferenceLogger(WMI_GLOBAL_LOGGER_ID);
            if (TraceInformation) {
                *((PTRACEHANDLE)TraceInformation) = TraceHandle;
            }
            if (ARGUMENT_PRESENT( RequiredLength )) {
                *RequiredLength = sizeof( TRACEHANDLE );
            }
            break;

        case EventLoggerHandleClass:
            if (TraceInformationLength != sizeof(TRACEHANDLE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }
            LoggerId = WmipEventLogger;
            if (WmipEventLogger == (ULONG) -1) {
                TraceHandle = 0;
                Status = STATUS_NOT_FOUND;
            }
            else {
                TraceHandle = LoggerId;
            }
            if (TraceInformation) {
                *((PTRACEHANDLE)TraceInformation) = TraceHandle;
            }
            if (ARGUMENT_PRESENT( RequiredLength )) {
                *RequiredLength = sizeof( TRACEHANDLE );
            }
            break;

        case AllLoggerHandlesClass:
            // Returns all logger handles, except for kernel logger
            if (TraceInformationLength < sizeof(TRACEHANDLE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            LoggersLength = 0;
            for (LoggerId=1; LoggerId<MAXLOGGERS; LoggerId++) {
                WmipReferenceLogger(LoggerId);
                if (!WmipIsValidLogger(WmipLoggerContext[LoggerId])) {
                    AllHandles[LoggersLength] = 0;
                }
                else {
                    AllHandles[LoggersLength++] = LoggerId;
                }
                WmipDereferenceLogger(LoggerId);
            }
            LoggersLength *= sizeof(TRACEHANDLE);
            if (TraceInformation && (LoggersLength > 0)) {
                if (TraceInformationLength >= LoggersLength) {
                    RtlCopyMemory(TraceInformation, AllHandles, LoggersLength);
                }
                else {
                    RtlCopyMemory(TraceInformation, AllHandles, TraceInformationLength);
                    Status = STATUS_MORE_ENTRIES;
                }
            }
            if (ARGUMENT_PRESENT( RequiredLength )) {
                *RequiredLength = LoggersLength;
            }
            break;

        case TraceHandleByNameClass:
            // Returns a Trace Handle Given a Logger name as a UNICODE_STRING in buffer.
            {
                WMI_LOGGER_INFORMATION LoggerInfo;
                PUNICODE_STRING uString = Buffer;


                if (TraceInformationLength != sizeof(TraceHandle) ) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }
	            if (uString == NULL) {
		            return STATUS_INVALID_PARAMETER;
	            }
	            if (uString->Buffer == NULL || uString->Length == 0) {
		            return STATUS_INVALID_PARAMETER;
	            }

                RtlZeroMemory(&LoggerInfo, sizeof(LoggerInfo));
                LoggerInfo.Wnode.BufferSize = sizeof(LoggerInfo);
                LoggerInfo.Wnode.Flags = WNODE_FLAG_TRACED_GUID;

                RtlInitUnicodeString(&LoggerInfo.LoggerName, uString->Buffer);

                Status = WmiQueryTrace(&LoggerInfo);
                if (!NT_SUCCESS(Status)) {
                    return STATUS_NOT_FOUND;
                }

                TraceHandle = (TRACEHANDLE)LoggerInfo.Wnode.HistoricalContext;

                if (TraceInformation) {
                    *((PTRACEHANDLE)TraceInformation) = TraceHandle;
                }
                if (ARGUMENT_PRESENT( RequiredLength )) {
                    *RequiredLength = sizeof( TRACEHANDLE );
                }
            }
            break;


        default :
            return STATUS_INVALID_INFO_CLASS;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\tracep.h ===
#ifndef _TRACEP_H
#define _TRACEP_H
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    tracep.h

Abstract:

    Private header for trace component

--*/
#pragma warning(disable:4127)   // condition expression is constant

#include <strsafe.h>

#define MAX_WMI_BUFFER_SIZE     1024    // in KBytes
#define MAX_FILE_TABLE_SIZE     64
#define KERNEL_LOGGER           (0)

// NOTE: Consider allowing user to change the two values below
#define TRACE_MAXIMUM_NP_POOL_USAGE     10  // maximum per cent of NP used
#define BYTES_PER_MB            1048576     // Conversion for FileSizeLimit

#define REQUEST_FLAG_NEW_FILE            0x00000001  // request for new file
#define REQUEST_FLAG_FLUSH_BUFFERS       0x00000002  // request for flush
#define REQUEST_FLAG_CIRCULAR_PERSIST    0x00010000
#define REQUEST_FLAG_CIRCULAR_TRANSITION 0x00020000
#define TRACEPOOLTAG            'timW'

//
// Time constants
//

extern LARGE_INTEGER WmiOneSecond;
extern LARGE_INTEGER WmiShortTime; //10 Milliseconds


//
// Increase refcount on a logger context
#define WmipReferenceLogger(Id) InterlockedIncrement(&WmipRefCount[Id])

// Decrease refcount on a logger context
#define WmipDereferenceLogger(Id) InterlockedDecrement(&WmipRefCount[Id])

// Macro to retrieve Logger Context from LoggerId as index
//
#define WmipGetLoggerContext(LoggerId) \
        (LoggerId < MAXLOGGERS) ? \
            WmipLoggerContext[LoggerId] : NULL

#define WmipIsValidLogger(L) \
        (((L) != NULL) && ((L) != (PWMI_LOGGER_CONTEXT) &WmipLoggerContext[0])\
        ? TRUE : FALSE)

#define WmipInitializeMutex(x) KeInitializeMutex((x), 0)
#define WmipAcquireMutex(x) KeWaitForSingleObject((x), Executive, KernelMode,\
                            FALSE, NULL)
#define WmipReleaseMutex(x) KeReleaseMutex((x), FALSE)

//
// Context Swap Trace Constants
//
#define WMI_CTXSWAP_EVENTSIZE_ALIGNMENT         8


//
// Buffer management
//
#define WMI_FREE_TRACE_BUFFER(Buffer) ASSERT(Buffer->ReferenceCount == 0);\
                                      ExFreePool(Buffer); 

//
// Private local data structures used
//
__inline
__int64
WmipGetSystemTime(
    )
{
    LARGE_INTEGER Time;
    KiQuerySystemTime((PLARGE_INTEGER)&Time);
    return Time.QuadPart;
}

__inline
__int64
WmipGetPerfCounter(
    )
{
    LARGE_INTEGER Time;
    Time = KeQueryPerformanceCounter(NULL);
    return Time.QuadPart;
}

#if _MSC_VER >= 1200
#pragma warning( push )
#endif
#pragma warning( disable:4214 )
#pragma warning( disable:4201 )

//
// Perf logging states
//
#define PERF_LOG_NO_TRANSITION      0               // No Perf Logging transition
#define PERF_LOG_START_TRANSITION   1               // Perf Logging is starting 
#define PERF_LOG_STOP_TRANSITION    2               // Perf Logging is ending

typedef struct _WMI_LOGGER_MODE {
   ULONG               SequentialFile:1;
   ULONG               CircularFile:1;
   ULONG               AppendFile:1;
   ULONG               Unused1:5;
   ULONG               RealTime:1;
   ULONG               DelayOpenFile:1;
   ULONG               BufferOnly:1;
   ULONG               PrivateLogger:1;
   ULONG               AddHeader:1;
   ULONG               UseExisting:1;
   ULONG               UseGlobalSequence:1;
   ULONG               UseLocalSequence:1;
   ULONG               Unused2:16;
} WMI_LOGGER_MODE, *PWMI_LOGGER_MODE;

typedef struct _WMI_LOGGER_CONTEXT {
//
// the following are private context used by the buffer manager
//
    KSPIN_LOCK                  BufferSpinLock;
    LARGE_INTEGER               StartTime;
    HANDLE                      LogFileHandle;
    KSEMAPHORE                  LoggerSemaphore;
    PETHREAD                    LoggerThread;
    KEVENT                      LoggerEvent;
    KEVENT                      FlushEvent;
    NTSTATUS                    LoggerStatus;
    ULONG                       LoggerId;

    LONG                        BuffersAvailable;
    ULONG                       UsePerfClock;
    ULONG                       WriteFailureLimit;
    LONG                        BuffersDirty;
    LONG                        BuffersInUse;
    ULONG                       SwitchingInProgress;
    SLIST_HEADER                FreeList;
    SLIST_HEADER                FlushList;
    SLIST_HEADER                WaitList;
    SLIST_HEADER                GlobalList;
    PWMI_BUFFER_HEADER*         ProcessorBuffers;   // Per Processor Buffer
    UNICODE_STRING              LoggerName;         // points to paged pool
    UNICODE_STRING              LogFileName;
    UNICODE_STRING              LogFilePattern;
    UNICODE_STRING              NewLogFileName;     // for updating log file name
    PUCHAR                      EndPageMarker;

    LONG                        CollectionOn;
    ULONG                       KernelTraceOn;
    LONG                        PerfLogInTransition;    // Perf Logging transition status
    ULONG                       RequestFlag;
    ULONG                       EnableFlags;
    ULONG                       MaximumFileSize;
    union {
        ULONG                   LoggerMode;
        WMI_LOGGER_MODE         LoggerModeFlags;
    };
    ULONG                       Wow;                // TRUE if the logger started under Wow64
                                                    // Set by the kernel once and never changed.
    ULONG                       LastFlushedBuffer;
    ULONG                       RefCount;
    ULONG                       FlushTimer;
    LARGE_INTEGER               FirstBufferOffset;
    LARGE_INTEGER               ByteOffset;
    LARGE_INTEGER               BufferAgeLimit;

// the following are attributes available for query
    ULONG                       MaximumBuffers;
    ULONG                       MinimumBuffers;
    ULONG                       EventsLost;
    ULONG                       BuffersWritten;
    ULONG                       LogBuffersLost;
    ULONG                       RealTimeBuffersLost;
    ULONG                       BufferSize;
    LONG                        NumberOfBuffers;
    PLONG                       SequencePtr;

    GUID                        InstanceGuid;
    PVOID                       LoggerHeader;
    WMI_GET_CPUCLOCK_ROUTINE    GetCpuClock;
    SECURITY_CLIENT_CONTEXT     ClientSecurityContext;
// logger specific extension to context
    PVOID                       LoggerExtension;
    LONG                        ReleaseQueue;
    TRACE_ENABLE_FLAG_EXTENSION EnableFlagExtension;
    ULONG                       LocalSequence;
    ULONG                       MaximumIrql;
    PULONG                      EnableFlagArray;
    KMUTEX                      LoggerMutex;
    LONG                        MutexCount;
    LONG                        FileCounter;
    WMI_TRACE_BUFFER_CALLBACK   BufferCallback;
    PVOID                       CallbackContext;
    POOL_TYPE                   PoolType;
    LARGE_INTEGER               ReferenceSystemTime;  // always in SystemTime
    LARGE_INTEGER               ReferenceTimeStamp;   // by specified clocktype
} WMI_LOGGER_CONTEXT, *PWMI_LOGGER_CONTEXT;

#if _MSC_VER >= 1200
#pragma warning( pop )
#endif

extern LONG WmipRefCount[MAXLOGGERS];      // Global refcount on loggercontext
extern PWMI_LOGGER_CONTEXT WmipLoggerContext[MAXLOGGERS];
extern PWMI_BUFFER_HEADER WmipContextSwapProcessorBuffers[MAXIMUM_PROCESSORS];
extern PFILE_OBJECT* WmipFileTable;         // Filename hashing table

extern ULONG WmipGlobalSequence;
extern ULONG WmipPtrSize;       // temporary for wmikd to work
extern ULONG WmipKernelLogger;
extern ULONG WmipEventLogger;

extern ULONG WmiUsePerfClock;
extern ULONG WmiTraceAlignment;
extern ULONG WmiWriteFailureLimit;
extern KGUARDED_MUTEX WmipTraceGuardedMutex;
extern WMI_TRACE_BUFFER_CALLBACK WmipGlobalBufferCallback;
extern PSECURITY_DESCRIPTOR EtwpDefaultTraceSecurityDescriptor;

//
// Private routines for tracing support
//

//
// from tracelog.c
//

NTSTATUS
WmipFlushBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER Buffer,
    IN USHORT BufferFlag
    );

NTSTATUS
WmipStartLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

NTSTATUS
WmipQueryLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

#if DBG
NTSTATUS
WmipVerifyLoggerInfo(
    IN PWMI_LOGGER_INFORMATION LoggerInfo,
    OUT PWMI_LOGGER_CONTEXT *LoggerContext,
    LPSTR Caller
    );
#else
NTSTATUS
WmipVerifyLoggerInfo(
    IN PWMI_LOGGER_INFORMATION LoggerInfo,
    OUT PWMI_LOGGER_CONTEXT *LoggerContext
    );
#endif

VOID
WmipFreeLoggerContext(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

NTSTATUS
WmipStopLoggerInstance(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

NTSTATUS
WmipFlushActiveBuffers(
    IN PWMI_LOGGER_CONTEXT,
    IN ULONG FlushAll
    );

PSYSTEM_TRACE_HEADER
FASTCALL
WmiReserveWithSystemHeader(
    IN ULONG LoggerId,
    IN ULONG AuxSize,
    IN PETHREAD Thread,
    OUT PVOID *BufferResource
    );

PVOID
FASTCALL
WmipReserveTraceBuffer(
    IN  PWMI_LOGGER_CONTEXT LoggerContext,
    IN  ULONG RequiredSize,
    OUT PWMI_BUFFER_HEADER *BufferResource,
    OUT PLARGE_INTEGER TimeStamp
    );

ULONG
FASTCALL
WmipReleaseTraceBuffer(
    IN PWMI_BUFFER_HEADER Buffer,
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

PWMI_BUFFER_HEADER
WmipGetFreeBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext
);

ULONG
WmipAllocateFreeBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN ULONG NumberOfBuffers
    );

NTSTATUS
WmipAdjustFreeBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

NTSTATUS
WmipShutdown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
WmipLogger(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

NTSTATUS
WmipSendNotification(
    PWMI_LOGGER_CONTEXT LoggerContext,
    NTSTATUS            Status,
    ULONG               Flag
	);

#if DBG
VOID
TraceDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define TraceDebug(x) TraceDebugPrint x
#else
#define TraceDebug(x)
#endif

PWMI_BUFFER_HEADER
FASTCALL
WmipPopFreeContextSwapBuffer
    (UCHAR CurrentProcessor
    );

VOID
FASTCALL
WmipPushDirtyContextSwapBuffer
    (UCHAR CurrentProcessor,
     PWMI_BUFFER_HEADER Buffer
    );

VOID
FASTCALL
WmipResetBufferHeader (
    PWMI_LOGGER_CONTEXT     LoggerContext,
    PWMI_BUFFER_HEADER      Buffer,
    USHORT                  BufferType
    );

// from callouts.c

VOID
WmipSetTraceNotify(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG TraceClass,
    IN ULONG Enable
    );

VOID
FASTCALL
WmipEnableKernelTrace(
    IN ULONG EnableFlags
    );

VOID
FASTCALL
WmipDisableKernelTrace(
    IN ULONG EnableFlags
    );

NTSTATUS
WmipDelayCreate(
    OUT PHANDLE FileHandle,
    IN OUT PUNICODE_STRING FileName,
    IN ULONG Append
    );


PWMI_LOGGER_CONTEXT
FASTCALL
WmipIsLoggerOn(IN ULONG LoggerId);

// from globalog.c

VOID
WmipStartGlobalLogger();

NTSTATUS
WmipQueryGLRegistryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
WmipAddLogHeader(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN OUT PWMI_BUFFER_HEADER Buffer
    );

NTSTATUS
WmipCreateDirectoryFile(
    IN PWCHAR DirFileName,
    IN BOOLEAN IsDirectory,
    OUT PHANDLE FileHandle,
    ULONG Append
    );

NTSTATUS
WmipCreateNtFileName(
    IN  PWCHAR   strFileName,
    OUT PWCHAR * strNtFileName
    );

NTSTATUS
WmipFlushLogger(
    IN OUT PWMI_LOGGER_CONTEXT LoggerContext,
    IN ULONG Wait
    );

NTSTATUS
FASTCALL
WmipNotifyLogger(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

PVOID
WmipExtendBase(
    IN PWMI_LOGGER_CONTEXT Base,
    IN ULONG Size
    );

NTSTATUS
WmipGenerateFileName(
    IN PUNICODE_STRING FilePattern,
    IN OUT PLONG FileCounter,
    OUT PUNICODE_STRING FileName
    );

VOID
WmipValidateClockType(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

NTSTATUS
WmipNtDllLoggerInfo(
    PWMINTDLLLOGGERINFO Buffer
    );

#endif // _TRACEP_H
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\register.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    register.c

Abstract:

    Kernel mode registration cache

--*/

#include "wmikmp.h"

void WmipWaitForIrpCompletion(
    PREGENTRY RegEntry
    );

NTSTATUS WmipUpdateDS(
    PREGENTRY RegEntry
    );

NTSTATUS WmipRegisterDS(
    PREGENTRY RegEntry
);

void WmipRemoveDS(
    PREGENTRY RegEntry
);

NTSTATUS WmipValidateWmiRegInfoString(
    PWMIREGINFO WmiRegInfo,
    ULONG BufferSize,
    ULONG Offset,
    PWCHAR *String
);


NTSTATUS WmipRegisterOrUpdateDS(
    PREGENTRY RegEntry,
    BOOLEAN Update
    );

void WmipRegistrationWorker(
    PVOID Context
   );

NTSTATUS WmipQueueRegWork(
    REGOPERATION RegOperation,
    PREGENTRY RegEntry
    );


#if defined(_WIN64)
PREGENTRY WmipFindRegEntryByProviderId(
    ULONG ProviderId,
    BOOLEAN ReferenceIrp
    );

ULONG WmipAllocProviderId(
    PDEVICE_OBJECT DeviceObject
    );

#endif
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,WmipInitializeRegistration)

#pragma alloc_text(PAGE,WmipRegisterDevice)
#pragma alloc_text(PAGE,WmipDeregisterDevice)
#pragma alloc_text(PAGE,WmipUpdateRegistration)
#pragma alloc_text(PAGE,WmipDoUnreferenceRegEntry)
#pragma alloc_text(PAGE,WmipWaitForIrpCompletion)
#pragma alloc_text(PAGE,WmipFindRegEntryByDevice)
#pragma alloc_text(PAGE,WmipTranslatePDOInstanceNames)
#pragma alloc_text(PAGE,WmipPDOToDeviceInstanceName)
#pragma alloc_text(PAGE,WmipRemoveDS)
#pragma alloc_text(PAGE,WmipRegisterDS)
#pragma alloc_text(PAGE,WmipUpdateDS)
#pragma alloc_text(PAGE,WmipValidateWmiRegInfoString)
#pragma alloc_text(PAGE,WmipProcessWmiRegInfo)
#pragma alloc_text(PAGE,WmipRegisterOrUpdateDS)
#pragma alloc_text(PAGE,WmipQueueRegWork)
#pragma alloc_text(PAGE,WmipRegistrationWorker)
#pragma alloc_text(PAGE,WmipAllocRegEntry)

#if defined(_WIN64)
#pragma alloc_text(PAGE,WmipFindRegEntryByProviderId)
#pragma alloc_text(PAGE,WmipAllocProviderId)
#endif
#endif

LIST_ENTRY WmipInUseRegEntryHead = {&WmipInUseRegEntryHead,&WmipInUseRegEntryHead};
LONG WmipInUseRegEntryCount = 0;

KSPIN_LOCK WmipRegistrationSpinLock;

NPAGED_LOOKASIDE_LIST WmipRegLookaside;
KMUTEX WmipRegistrationMutex;

const GUID WmipDataProviderPnpidGuid = DATA_PROVIDER_PNPID_GUID;
const GUID WmipDataProviderPnPIdInstanceNamesGuid = DATA_PROVIDER_PNPID_INSTANCE_NAMES_GUID;

WORK_QUEUE_ITEM WmipRegWorkQueue;

//
// WmipRegWorkItemCount starts at 1 so that all drivers who register
// before phase 1 of WMI initialization won't kick off the reg work
// item. In phase 1 we decrement the count and if it is not zero then
// we kick it off since it is now same to send the drivers reg info
// irps
//
LONG WmipRegWorkItemCount = 1;
LIST_ENTRY WmipRegWorkList = {&WmipRegWorkList, &WmipRegWorkList};

void WmipInitializeRegistration(
    ULONG Phase
    )
{
    PAGED_CODE();

    if (Phase == 0)
    {
        //
        //  Initialize lookaside lists
        //
        ExInitializeNPagedLookasideList(&WmipRegLookaside,
                                   NULL,
                                   NULL,
                                   0,
                                   sizeof(REGENTRY),
                                   WMIREGPOOLTAG,
                                   0);

        //
        // Initialize Registration Spin Lock
        //
        KeInitializeSpinLock(&WmipRegistrationSpinLock);
        
    } else {
        //
        // Kick off work item that will send reg irps to all of the
        // drivers that have registered. We are sure there is at least
        // one device that needs this since there is the internal wmi
        // data device
        //
        ExInitializeWorkItem( &WmipRegWorkQueue,
                          WmipRegistrationWorker,
                          NULL );

        if (InterlockedDecrement(&WmipRegWorkItemCount) != 0)
        {
            ExQueueWorkItem(&WmipRegWorkQueue, DelayedWorkQueue);
        }
    }
}

#if defined(_WIN64)
LONG WmipProviderIdCounter = 1;
ULONG WmipAllocProviderId(
    PDEVICE_OBJECT DeviceObject
    )
{
    PAGED_CODE();
    
    UNREFERENCED_PARAMETER (DeviceObject);

    return(InterlockedIncrement(&WmipProviderIdCounter));
}
#else
#define WmipAllocProviderId(DeviceObject) ((ULONG)(DeviceObject))
#endif

PREGENTRY WmipAllocRegEntry(
    PDEVICE_OBJECT DeviceObject,
    ULONG Flags
    )
/*++

Routine Description:

    Allocate a REGENTRY structure. If successful the RegEntry returns with
    a ref count of 1.

    NOTE: This routine assumes that the registration critical section is held

Arguments:

    DeviceObject is the value to fill in the DeviceObject field of the
        RegEntry.

Return Value:

    pointer to a REGENTRY or NULL if no memory is available

--*/
{
    PREGENTRY RegEntry;

    PAGED_CODE();
    
    RegEntry = ExAllocateFromNPagedLookasideList(&WmipRegLookaside);

    if (RegEntry != NULL)
    {
        //
        // Initialize the RegEntry. Note that the regentry will start out with
        // a ref count of 1
        KeInitializeEvent(&RegEntry->Event,
                          SynchronizationEvent,
                          FALSE);


        RegEntry->Flags = Flags;
        RegEntry->DeviceObject = DeviceObject;
        RegEntry->RefCount = 1;
        RegEntry->IrpCount = 0;
        RegEntry->PDO = NULL;
        RegEntry->DataSource = NULL;

        RegEntry->ProviderId = WmipAllocProviderId(DeviceObject);

        //
        //  Now place the RegEntry on the in use list
        InterlockedIncrement(&WmipInUseRegEntryCount);

        ExInterlockedInsertTailList(&WmipInUseRegEntryHead,
                                    &RegEntry->InUseEntryList,
                                    &WmipRegistrationSpinLock);
    }
    return(RegEntry);
}

BOOLEAN WmipDoUnreferenceRegEntry(
    PREGENTRY RegEntry
    )
/*++

Routine Description:

    Remove a reference on a REGENTRY. If the last reference is removed
    then mark the RegEntry as available and put it on the free list;

Arguments:

    RegEntry is pointer to entry to free

Return Value:

    On checked builds returns TRUE if last ref count was removed from REGENTRY
    and it was placed back on free list.

--*/
{
    BOOLEAN Freed;
    ULONG ProviderId;

    PAGED_CODE();

    WmipEnterSMCritSection();
    Freed = (InterlockedDecrement(&RegEntry->RefCount) == 0 ? TRUE : FALSE);
    if (Freed)
    {
        //
        // We should only ever free this after the driver has released it
        WmipAssert(RegEntry->Flags & REGENTRY_FLAG_RUNDOWN);
        WmipAssert(RegEntry->Flags & REGENTRY_FLAG_NOT_ACCEPTING_IRPS);

        //
        // Make sure the ref to the PDO is removed
        //
        if (RegEntry->PDO != NULL)
        {
            ObDereferenceObject(RegEntry->PDO);
            RegEntry->PDO = NULL;
        }
        
        //
        // Remove entry from in use list
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_REGISTRATION_LEVEL, \
                      "WMI: RegEntry %p removed from list\n", \
                      RegEntry, __FILE__, __LINE__)); \
        ProviderId = RegEntry->ProviderId;
        ExInterlockedRemoveHeadList(RegEntry->InUseEntryList.Blink,
                                   &WmipRegistrationSpinLock);
        InterlockedDecrement(&WmipInUseRegEntryCount);
        WmipLeaveSMCritSection();

        WmipRemoveDS(RegEntry);

        ExFreeToNPagedLookasideList(&WmipRegLookaside,
                                   RegEntry);
    } else {
        WmipLeaveSMCritSection();
    }
    return(Freed);
}

void WmipWaitForIrpCompletion(
    PREGENTRY RegEntry
    )
/*++

Routine Description:

    Stall here until all WMI irps for this device are completed.

Arguments:

    RegEntry is pointer to entry for the device to stall

Return Value:


--*/
{
    PAGED_CODE();

    WmipAssert(RegEntry->Flags & REGENTRY_FLAG_RUNDOWN);
    WmipAssert(RegEntry->Flags & REGENTRY_FLAG_NOT_ACCEPTING_IRPS);

    if (RegEntry->IrpCount != 0)
    {
        //
        // CONSIDER: If irp is marked pending do we need to cancel it ???
        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                          DPFLTR_REGISTRATION_LEVEL,
                          "WMI: Waiting for %x to complete all irps\n",
                  RegEntry->DeviceObject));

        KeWaitForSingleObject(&RegEntry->Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              (PLARGE_INTEGER)NULL);
        WmipAssert(RegEntry->IrpCount == 0);
    }
}

NTSTATUS WmipRegisterDevice(
    PDEVICE_OBJECT DeviceObject,
    ULONG RegistrationFlag
    )
/*++

Routine Description:

    Remember information about a new device being registered and
    then go and get the registration information.

Arguments:

    DeviceObject is a pointer to the device object being registered
        or the callback entry point

    RegistrationFlag is either WMIREG_FLAG_CALLBACK if DeviceObject is
        a callback pointer, or WMIREG_FLAG_TRACE_PROVIDER is DeviceObject
        can also generate event traces.

Return Value:

    NT status code

--*/
{
    PREGENTRY RegEntry;
    NTSTATUS Status;
    ULONG Flags;
    ULONG IsCallback = RegistrationFlag & WMIREG_FLAG_CALLBACK;
    BOOLEAN UpdateDeviceStackSize = FALSE;

    PAGED_CODE();

    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                       DPFLTR_REGISTRATION_LEVEL,
                       "WMI: Registering device %p flags %x\n",
                       DeviceObject,
                       RegistrationFlag
                      ));
    
    WmipEnterSMCritSection();
    RegEntry = WmipFindRegEntryByDevice(DeviceObject, FALSE);
    if (RegEntry == NULL)
    {
        if (! IsCallback)
        {
            //
            // Data providers that register with a device object and not a
            // callback have their device object referenced so that it will
            // stick around while WMI needs it. This reference is removed
            // when the device unregisters with WMI and all WMI irps are
            // completed.
            Status = ObReferenceObjectByPointer(DeviceObject,
                                        0,
                                        NULL,    /* *IoDeviceObjectType */
                                        KernelMode);
            if (NT_SUCCESS(Status))
            {
                UpdateDeviceStackSize = TRUE;
            }
        } else {
            //
            // No reference counting is done for callbacks. It is the data
            // provider's responsibility to synchronize any unloading and
            // deregistration issues.
            Status = STATUS_SUCCESS;
        }

        if (NT_SUCCESS(Status))
        {
            //
            // Allocate, initialize and place on active list
            Flags = REGENTRY_FLAG_NEWREGINFO | REGENTRY_FLAG_INUSE |
                            (IsCallback ? REGENTRY_FLAG_CALLBACK : 0);

            if (RegistrationFlag & WMIREG_FLAG_TRACE_PROVIDER) {
                Flags |= REGENTRY_FLAG_TRACED;
                Flags |= (RegistrationFlag & WMIREG_FLAG_TRACE_NOTIFY_MASK);
            }

            Flags |= REGENTRY_FLAG_REG_IN_PROGRESS;
            RegEntry = WmipAllocRegEntry(DeviceObject, Flags);

            if (RegEntry != NULL)
            {               
                // We need to take an extra ref count before
                // releasing the critical section.  One class of drivers
                // (kmixer) will register and unregister multiple times 
                // in different threads and this can lead to a race where
                // the regentry is removed from the list twice
                //
                WmipReferenceRegEntry(RegEntry);
                WmipLeaveSMCritSection();
                
                WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                   DPFLTR_REGISTRATION_LEVEL,
                                   "WMI: Register allocated REGENTRY %p for %p\n",
                                   RegEntry,
                                   DeviceObject
                                  ));
                //
                // Go and get registration information from the driver
                //
                if (IsCallback)
                {
                    //
                    // We can perform registration callback now since
                    // we do not need to worry about deadlocks
                    //
                    Status = WmipRegisterDS(RegEntry);
                    if (NT_SUCCESS(Status))
                    {
                        //
                        // Mark regentry as fully registered so now we can start
                        // accepting unregister calls
                        //
                        RegEntry->Flags &= ~REGENTRY_FLAG_REG_IN_PROGRESS;
                        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                          DPFLTR_REGISTRATION_LEVEL,
                                          "WMI: WmipRegisterDS(%p) succeeded for callback %p\n",
                                          RegEntry, RegEntry->DeviceObject));
                    } else {
                        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                          DPFLTR_REGISTRATION_LEVEL,
                                          "WMI: WmipRegisterDS(%p) failed %x for device %p\n",
                                          RegEntry, Status, RegEntry->DeviceObject));

                        //
                        // Remove ref so regentry goes away
                        //
                        WmipUnreferenceRegEntry(RegEntry);
                    }
                    
                } else {
                    //
                    // We need to send the registration irp from within
                    // a work item and not in the context of this
                    // routine. This is because some drivers will not
                    // process irps while in the StartDevice/AddDevice
                    // context, so we'd get deadlock
                    //
                    Status = WmipQueueRegWork(RegisterSingleDriver, RegEntry);
                    if (! NT_SUCCESS(Status))
                    {
                        //
                        // If failed then remove regentry from list
                        //                      
                        RegEntry->Flags |= (REGENTRY_FLAG_RUNDOWN |
                                            REGENTRY_FLAG_NOT_ACCEPTING_IRPS);
                        WmipUnreferenceRegEntry(RegEntry);
                    }
                }

                //
                // Remove extra regentry ref count taken above
                //
                WmipUnreferenceRegEntry(RegEntry);

            } else {
                WmipLeaveSMCritSection();
                Status = STATUS_INSUFFICIENT_RESOURCES;
                WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                   DPFLTR_REGISTRATION_LEVEL,
                                   "WMI: Register could not alloc REGENTRY for %p\n",
                                   DeviceObject
                                  ));
            }
        } else {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                               DPFLTR_REGISTRATION_LEVEL,
                               "WMI: Register could not ObRef %p status  %x\n",
                               DeviceObject,
                               Status
                              ));
            WmipLeaveSMCritSection();
        }
    } else {
        //
        // A device object may only register once
        WmipLeaveSMCritSection();
        Status = STATUS_OBJECT_NAME_EXISTS;
        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                          DPFLTR_REGISTRATION_LEVEL,
                          "WMI: Device Object %x attempting to register twice\n",
                 DeviceObject));
        WmipUnreferenceRegEntry(RegEntry);
    }

    if (UpdateDeviceStackSize)
    {
        //
        // Since WMI will be forwarding irps to this device the WMI irp
        // stack size must be at least one larger than that of the device
        WmipUpdateDeviceStackSize(
                                  (CCHAR)(DeviceObject->StackSize+1));
    }

    return(Status);
}

NTSTATUS WmipDeregisterDevice(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Remove registration entry for a device

Arguments:

    DeviceObject is a pointer to the device object being deregistered


Return Value:

    NT status code

--*/
{
    NTSTATUS Status;
    PREGENTRY RegEntry;
    ULONG Flags;

    PAGED_CODE();

    WmipEnterSMCritSection();
    RegEntry = WmipFindRegEntryByDevice(DeviceObject, FALSE);
    if (RegEntry != NULL)
    {

        //
        // Mark the regentry as invalid so that no more irps are sent to the
        // device and the event will set when the last irp completes.
        Flags = InterlockedExchange(&RegEntry->Flags,
                        (REGENTRY_FLAG_RUNDOWN |
                         REGENTRY_FLAG_NOT_ACCEPTING_IRPS) );

        //
        // Once the regentry is marked as RUNDOWN then it will not be found
        // later so it is safe to release the lock.
        WmipLeaveSMCritSection();
        WmipUnreferenceRegEntry(RegEntry);

        //
        // Now if there are any outstanding irps for the device then we need
        // to wait here until they complete.
        WmipWaitForIrpCompletion(RegEntry);
        if (! (Flags & REGENTRY_FLAG_CALLBACK))
        {
            ObDereferenceObject(DeviceObject);
        }

        //
        // Release last reference to REGENTRY after KMREGINFO is set
        WmipUnreferenceRegEntry(RegEntry);

        Status = STATUS_SUCCESS;
    } else {
        WmipLeaveSMCritSection();
        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                          DPFLTR_REGISTRATION_LEVEL,
                          "WMI: WmipDeregisterDevice called with invalid Device Object %x\n",
                 DeviceObject));
        Status = STATUS_INVALID_PARAMETER;
    }


    return(Status);
}

NTSTATUS WmipUpdateRegistration(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Flags that device has updated registration information

Arguments:

    DeviceObject is a pointer to the device object that wants to update
        its information


Return Value:

    NT status code

--*/
{
    NTSTATUS Status;
    PREGENTRY RegEntry;

    PAGED_CODE();

    RegEntry = WmipFindRegEntryByDevice(DeviceObject, FALSE);
    if (RegEntry != NULL)
    {
        Status = WmipQueueRegWork(RegisterUpdateSingleDriver,
                                  RegEntry);
        WmipUnreferenceRegEntry(RegEntry);
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return(Status);
}

#if defined(_WIN64)

PREGENTRY WmipDoFindRegEntryByProviderId(
    ULONG ProviderId,
    ULONG InvalidFlags
    )
{
    //
    // This routine assumes that any synchronization mechanism has
    // been taken. This routine can be called at dispatch level
    //
    
    PREGENTRY RegEntry;
    PLIST_ENTRY RegEntryList;
    
    RegEntryList = WmipInUseRegEntryHead.Flink;
    while (RegEntryList != &WmipInUseRegEntryHead)
    {
        RegEntry = CONTAINING_RECORD(RegEntryList,
                                     REGENTRY,
                                     InUseEntryList);

        if ((RegEntry->ProviderId == ProviderId) &&
            (! (RegEntry->Flags & InvalidFlags)))

        {
            return(RegEntry);
        }
        RegEntryList = RegEntryList->Flink;
    }
    return(NULL);
}

PREGENTRY WmipFindRegEntryByProviderId(
    ULONG ProviderId,
    BOOLEAN ReferenceIrp
    )
/*++

Routine Description:

    This routine will find a RegEntry that corresponds to the DeviceObject
    passed.

Arguments:

    DeviceObject is the device object that is the key for the RegEntry to find

    ReferenceIrp is TRUE then the Irp refcount will be incremented if a
        RegEntry is found for the device

Return Value:

    pointer to entry if available else NULL

--*/
{
    PREGENTRY RegEntry;

    PAGED_CODE();

    WmipEnterSMCritSection();

    RegEntry = WmipDoFindRegEntryByProviderId(ProviderId,
                                              REGENTRY_FLAG_RUNDOWN);
    if (RegEntry != NULL)
    {
        WmipReferenceRegEntry(RegEntry);
        if (ReferenceIrp)
        {
            InterlockedIncrement(&RegEntry->IrpCount);
        }
    }
    
    WmipLeaveSMCritSection();
    return(RegEntry);
}
#endif

PREGENTRY WmipDoFindRegEntryByDevice(
    PDEVICE_OBJECT DeviceObject,
    ULONG InvalidFlags
    )
{
    //
    // This routine assumes that any synchronization mechanism has
    // been taken. This routine can be called at dispatch level
    //
    
    PREGENTRY RegEntry;
    PLIST_ENTRY RegEntryList;
    
    RegEntryList = WmipInUseRegEntryHead.Flink;
    while (RegEntryList != &WmipInUseRegEntryHead)
    {
        RegEntry = CONTAINING_RECORD(RegEntryList,
                                     REGENTRY,
                                     InUseEntryList);

        if ((RegEntry->DeviceObject == DeviceObject) &&
            (! (RegEntry->Flags & InvalidFlags)))

        {
            return(RegEntry);
        }
        RegEntryList = RegEntryList->Flink;
    }
    return(NULL);
}

PREGENTRY WmipFindRegEntryByDevice(
    PDEVICE_OBJECT DeviceObject,
    BOOLEAN ReferenceIrp
    )
/*++

Routine Description:

    This routine will find a RegEntry that corresponds to the DeviceObject
    passed.

Arguments:

    DeviceObject is the device object that is the key for the RegEntry to find

    ReferenceIrp is TRUE then the Irp refcount will be incremented if a
        RegEntry is found for the device

Return Value:

    pointer to entry if available else NULL

--*/
{
    PREGENTRY RegEntry;

    PAGED_CODE();

    WmipEnterSMCritSection();

    RegEntry = WmipDoFindRegEntryByDevice(DeviceObject, REGENTRY_FLAG_RUNDOWN);
    if (RegEntry != NULL)
    {
        WmipReferenceRegEntry(RegEntry);
        if (ReferenceIrp)
        {
            InterlockedIncrement(&RegEntry->IrpCount);
        }
    }

    WmipLeaveSMCritSection();
    return(RegEntry);
}


void WmipDecrementIrpCount(
    IN PREGENTRY RegEntry
    )
/*++

Routine Description:

    This routine will decrement one from the active irp count for the
    regentry. If the active irp count reaches 0 and the flag is set that
    the device is waiting to be unloaded then the unload event is signaled
    so that the device can be unloaded.

Arguments:

    RegEntry is the registration entry for the device

Return Value:


--*/
{
    ULONG IrpCount;

    IrpCount = InterlockedDecrement(&RegEntry->IrpCount);
    if ((RegEntry->Flags & REGENTRY_FLAG_RUNDOWN) &&
        (IrpCount == 0))
    {
        //
        // If this is the last outstanding irp for the device and
        // the device is trying to unregister then set the event to
        // allow the deregister thread to continue.

        WmipAssert(RegEntry->Flags & REGENTRY_FLAG_NOT_ACCEPTING_IRPS);

        KeSetEvent(&RegEntry->Event,
                   0,
                   FALSE);

    }
}

NTSTATUS WmipPDOToDeviceInstanceName(
    IN PDEVICE_OBJECT PDO,
    OUT PUNICODE_STRING DeviceInstanceName
    )
/*++

Routine Description:

    This routine will return the device instance name that is associated with
    the PDO passed.

Arguments:

    PDO is the PDO whose device instance name is to be returned

    *DeviceInstanceName returns with the device instance name for the PDO.
        Note the string buffer must be freed.

Return Value:

    NT status ccode

--*/
{
    ULONG Status;

    PAGED_CODE();

    WmipAssert(PDO != NULL);
    Status = IoGetDeviceInstanceName(PDO, DeviceInstanceName);
    return(Status);
}

void WmipTranslatePDOInstanceNames(
    IN OUT PIRP Irp,
    IN UCHAR MinorFunction,
    IN ULONG MaxBufferSize,
    IN OUT PREGENTRY RegEntry
    )
/*++

Routine Description:

    This routine will check all REGGUID structures being returned from the
    data provider and convert any PDO instance name references to a
    static instance name reference.

Arguments:

    Irp points at the registration query irp

    MaxBufferSize is the maximum size that will fit into buffer

    RegEntry is registration structure for device being registered

Return Value:

--*/
{
    PUCHAR WmiRegInfoBase;
    PWMIREGINFO WmiRegInfo, WmiRegInfo2;
    PWMIREGGUID WmiRegGuid;
    PUCHAR FreeSpacePtr;
    ULONG FreeSpaceLeft = 0;
    ULONG i;
    BOOLEAN WmiRegInfoTooSmall = FALSE;
    PIO_STACK_LOCATION IrpStack;
    ULONG SizeNeeded;
    PDEVICE_OBJECT PDO = NULL, LastPDO = NULL, PnPIdPDO = NULL;
    UNICODE_STRING InstancePath;
    ULONG InstancePathLength;
    PVOID Buffer = Irp->AssociatedIrp.SystemBuffer;
    ULONG NextWmiRegInfo;
    ULONG Status;
    ULONG LastBaseNameOffset = 0;
    BOOLEAN AllowPnPIdMap = TRUE;
    ULONG ExtraRoom, MaxInstanceNames;
    PUCHAR FreeSpacePadPtr;
    ULONG PadSpace, FreeSpaceOffset;

    PAGED_CODE();

    WmiRegInfoBase = (PUCHAR)Buffer;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    FreeSpacePtr = NULL;
    SizeNeeded = (ULONG)((Irp->IoStatus.Information + 1) & 0xfffffffe);

    MaxInstanceNames = 0;

    WmiRegInfo = (PWMIREGINFO)WmiRegInfoBase;
    do
    {
        for (i = 0; i < WmiRegInfo->GuidCount;  i++)
        {
            WmiRegGuid = &WmiRegInfo->WmiRegGuid[i];

            //
            // If data provider already registers this guid then it overrides
            // any default mapping done here.
            if ((IsEqualGUID(&WmiRegGuid->Guid,
                             &WmipDataProviderPnpidGuid)) ||
                (IsEqualGUID(&WmiRegGuid->Guid,
                             &WmipDataProviderPnPIdInstanceNamesGuid)))
            {
                AllowPnPIdMap = FALSE;

                //
                // If we had remembered any PDO that is slated to be
                // used for PnPID mapping then make sure to deref it
                //
                if (PnPIdPDO != NULL)
                {
                    ObDereferenceObject(PnPIdPDO);
                    PnPIdPDO = NULL;
                }
            }

            if (WmiRegGuid->Flags & WMIREG_FLAG_INSTANCE_PDO)
            {               
                //
                // This instance name must be translated from PDO to
                // device instance name
                if (FreeSpacePtr == NULL)
                {
                    //
                    // Determine where any free space is in output buffer by
                    // figuring out where the last WmiRegInfo ends
                    WmiRegInfo2 = (PWMIREGINFO)WmiRegInfoBase;
                    while (WmiRegInfo2->NextWmiRegInfo != 0)
                    {
                        WmiRegInfo2 = (PWMIREGINFO)((PUCHAR)WmiRegInfo2 +
                                                 WmiRegInfo2->NextWmiRegInfo);
                    }
                    FreeSpacePtr = (PUCHAR)WmiRegInfo2 +
                                 ((WmiRegInfo2->BufferSize + 1) & 0xfffffffe);
                    FreeSpaceLeft = MaxBufferSize - (ULONG)(FreeSpacePtr - WmiRegInfoBase);

                }

                //
                // Keep track of the max number of instances for the PDO name
                MaxInstanceNames = MaxInstanceNames < WmiRegGuid->InstanceCount ?
                                            WmiRegGuid->InstanceCount :
                                            MaxInstanceNames;

                //
                // Get device instance name for the PDO
                PDO = (PDEVICE_OBJECT)WmiRegGuid->Pdo;
                if (PDO == LastPDO)
                {
                    WmiRegGuid->Flags |= WMIREG_FLAG_INSTANCE_BASENAME;
                    WmiRegGuid->BaseNameOffset = LastBaseNameOffset;
                } else {

                    Status = WmipPDOToDeviceInstanceName(PDO, &InstancePath);
                    if (NT_SUCCESS(Status))
                    {
                        if (AllowPnPIdMap &&
                            ((PnPIdPDO == NULL) || (PnPIdPDO == PDO)))
                        {
                            if (PnPIdPDO == NULL)
                            {
                                PnPIdPDO = PDO;
                                ObReferenceObject(PnPIdPDO);
                            }
                        } else {
                            //
                            // If the PDO value changes then we don't
                            // do any instance name stuff. In this case
                            // make sure we remove any ref on the PDO
                            //
                            AllowPnPIdMap = FALSE;
                            
                            if (PnPIdPDO != NULL)
                            {
                                ObDereferenceObject(PnPIdPDO);
                                PnPIdPDO = NULL;
                            }
                        }

                        InstancePathLength = InstancePath.Length +
                                              sizeof(USHORT) + sizeof(WCHAR);

                        SizeNeeded += InstancePathLength;
                        if ((WmiRegInfoTooSmall) ||
                            (InstancePathLength > FreeSpaceLeft))
                        {
                            WmiRegInfoTooSmall = TRUE;
                        } else {
                            WmiRegGuid->Flags |= WMIREG_FLAG_INSTANCE_BASENAME;

                            LastBaseNameOffset = (ULONG)(FreeSpacePtr - (PUCHAR)WmiRegInfo);
                            LastPDO = PDO;

                            WmiRegGuid->BaseNameOffset = LastBaseNameOffset;
                            (*(PUSHORT)FreeSpacePtr) = InstancePath.Length +
                                                          sizeof(WCHAR);
                            FreeSpacePtr +=  sizeof(USHORT);
                            RtlCopyMemory(FreeSpacePtr,
                                      InstancePath.Buffer,
                                      InstancePath.Length);
                             FreeSpacePtr += InstancePath.Length;
                             *((PWCHAR)FreeSpacePtr) = L'_';
                             FreeSpacePtr += sizeof(WCHAR);
                             FreeSpaceLeft -= InstancePathLength;
                        }
                    }

                    if (NT_SUCCESS(Status))
                    {
                        RtlFreeUnicodeString(&InstancePath);
                    }
                }

                if (MinorFunction == IRP_MN_REGINFO_EX)
                {
                    ObDereferenceObject(PDO);
                }
            }
        }
        LastPDO = NULL;
        NextWmiRegInfo = WmiRegInfo->NextWmiRegInfo;
        WmiRegInfo = (PWMIREGINFO)((PUCHAR)WmiRegInfo + NextWmiRegInfo);

    } while (NextWmiRegInfo != 0);

    //
    // If we can do automatic support for device information guid so add
    // registration for this guid to the registration information
    if (AllowPnPIdMap && (PnPIdPDO != NULL))
    {
        Status = WmipPDOToDeviceInstanceName(PDO, &InstancePath);
        if (NT_SUCCESS(Status))
        {
            //
            // Pad so that new WmiRegInfo starts on 8 byte boundary and
            // adjust free buffer size
            FreeSpacePadPtr = (PUCHAR)(((ULONG_PTR)FreeSpacePtr+7) & ~7);
            PadSpace = (ULONG)(FreeSpacePadPtr - FreeSpacePtr);
            FreeSpaceLeft -= PadSpace;
            FreeSpacePtr = FreeSpacePadPtr;

            //
            // Figure out how much space we will need to include extra guid
            InstancePathLength = InstancePath.Length +
                                 sizeof(USHORT) + sizeof(WCHAR);

            ExtraRoom = 2 * (InstancePathLength + sizeof(WMIREGGUID)) +
                          sizeof(WMIREGINFO);

            SizeNeeded += ExtraRoom + PadSpace;

            if ((WmiRegInfoTooSmall) ||
                (ExtraRoom > FreeSpaceLeft))
            {
                WmiRegInfoTooSmall = TRUE;
            } else {
                if (RegEntry->PDO == NULL)
                {
                    //
                    // If we haven't already established a PDO for this
                    // data provider then remember PDO and count of
                    // instance names for this device
                    // so we can get device properties
                    //
                    ObReferenceObject(PnPIdPDO);
                    RegEntry->PDO = PnPIdPDO;
                    RegEntry->MaxInstanceNames = MaxInstanceNames;

                    WmiRegInfo->NextWmiRegInfo = (ULONG)(FreeSpacePtr -
                                                         (PUCHAR)WmiRegInfo);

                    WmiRegInfo = (PWMIREGINFO)FreeSpacePtr;
                    FreeSpaceOffset = sizeof(WMIREGINFO) + 2*sizeof(WMIREGGUID);
                    FreeSpacePtr += FreeSpaceOffset;

                    RtlZeroMemory(WmiRegInfo, FreeSpaceOffset);
                    WmiRegInfo->BufferSize = ExtraRoom;
                    WmiRegInfo->GuidCount = 2;

                    WmiRegGuid = &WmiRegInfo->WmiRegGuid[0];
                    WmiRegGuid->Flags = WMIREG_FLAG_INSTANCE_BASENAME |
                                        WMIREG_FLAG_INSTANCE_PDO;
                    WmiRegGuid->InstanceCount = MaxInstanceNames;
                    WmiRegGuid->Guid = WmipDataProviderPnpidGuid;
                    WmiRegGuid->BaseNameOffset = FreeSpaceOffset;

                    (*(PUSHORT)FreeSpacePtr) = InstancePath.Length + sizeof(WCHAR);
                    FreeSpacePtr +=  sizeof(USHORT);
                    RtlCopyMemory(FreeSpacePtr,
                                  InstancePath.Buffer,
                                  InstancePath.Length);
                    FreeSpacePtr += InstancePath.Length;
                    *((PWCHAR)FreeSpacePtr) = L'_';
                    FreeSpacePtr += sizeof(WCHAR);
                    FreeSpaceOffset += sizeof(USHORT) +
                                       InstancePath.Length + sizeof(WCHAR);


                    WmiRegGuid = &WmiRegInfo->WmiRegGuid[1];
                    WmiRegGuid->Flags = WMIREG_FLAG_INSTANCE_LIST;
                    WmiRegGuid->InstanceCount = 1;
                    WmiRegGuid->Guid = WmipDataProviderPnPIdInstanceNamesGuid;
                    WmiRegGuid->BaseNameOffset = FreeSpaceOffset;

                    (*(PUSHORT)FreeSpacePtr) = InstancePath.Length;
                    FreeSpacePtr +=  sizeof(USHORT);
                    RtlCopyMemory(FreeSpacePtr,
                                  InstancePath.Buffer,
                                  InstancePath.Length);
                    FreeSpacePtr += InstancePath.Length;
                }

            }

            RtlFreeUnicodeString(&InstancePath);
        }

        ObDereferenceObject(PnPIdPDO);
    } else {
        WmipAssert(PnPIdPDO == NULL);
    }

    if (WmiRegInfoTooSmall)
    {
        *((PULONG)Buffer) = SizeNeeded;
        Irp->IoStatus.Information = sizeof(ULONG);
    } else {
        WmiRegInfo = (PWMIREGINFO)WmiRegInfoBase;
        WmiRegInfo->BufferSize = SizeNeeded;
        Irp->IoStatus.Information = SizeNeeded;
    }
}

NTSTATUS WmipValidateWmiRegInfoString(
    PWMIREGINFO WmiRegInfo,
    ULONG BufferSize,
    ULONG Offset,
    PWCHAR *String
)
{
    PWCHAR s;

    PAGED_CODE();

    if ((Offset > BufferSize) || ((Offset & 1) != 0))
    {
        //
        // Offset is beyond bounds of buffer or is misaligned
        //
        return(STATUS_INVALID_PARAMETER);
    }

    if (Offset != 0)
    {
        s = (PWCHAR)OffsetToPtr(WmiRegInfo, Offset);
           if (*s + Offset > BufferSize)
        {
            //
               // string extends beyond end of buffer
            //
            return(STATUS_INVALID_PARAMETER);
        }
        *String = s;
    } else {
        //
        // Offset of 0 implies null string
        //
        *String = NULL;
    }

    return(STATUS_SUCCESS);
}

NTSTATUS WmipProcessWmiRegInfo(
    IN PREGENTRY RegEntry,
    IN PWMIREGINFO WmiRegInfo,
    IN ULONG BufferSize,
    IN PWMIGUIDOBJECT RequestObject,
    IN BOOLEAN Update,
    IN BOOLEAN IsUserMode
    )
/*+++

Routine Description:

    This routine will loop through all WMIREGINFO passed and verify the
    sizes and offsets are not out of bounds of the buffer. It will register
    the guids for each one. Note that if at least one of the WMIREGINFOs does
    register successfully then STATUS_SUCCESS is returned, but all
    WMIREGINFOs following the bad one are not registered.

Arguments:

    RegEntry is the RegEntry for the device or user mode object

    WmiRegInfo is the registration information to register

    BufferSize is the size of WmiRegInfo in bytes

    RequestObject is the request object associated with the UM provider.
        If this is NULL then the registration is for a driver

    Update is TRUE if this is a registration update

Return Value:

    STATUS_SUCCESS or an error code

---*/
{
    ULONG Linkage;
    NTSTATUS Status, FinalStatus;
    PWCHAR RegPath, ResourceName;
    ULONG GuidBufferSize;

    PAGED_CODE();

    FinalStatus = STATUS_INVALID_PARAMETER;

    do {
        //
        // First we validate that the WMIREGINFO looks correct
        //
        if (WmiRegInfo->BufferSize > BufferSize)
        {
            //
            // BufferSize specified in WmiRegInfo is beyond bounds of buffer
            //
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Validate registry path string
        //
        Status = WmipValidateWmiRegInfoString(WmiRegInfo,
                                              BufferSize,
                                              WmiRegInfo->RegistryPath,
                                              &RegPath);
        if (! NT_SUCCESS(Status))
        {
            break;
        }

        //
        // Validate resource name string
        //
        Status = WmipValidateWmiRegInfoString(WmiRegInfo,
                                              BufferSize,
                                              WmiRegInfo->MofResourceName,
                                              &ResourceName);
        if (! NT_SUCCESS(Status))
        {
            break;
        }

        //
        // Validate that the guid list fits within the bounds of the
        // buffer. Note that WmipAddDataSource verifies that the instance
        // names within each guid is within bounds.
        //
        GuidBufferSize = sizeof(WMIREGINFO) +
                          WmiRegInfo->GuidCount * sizeof(WMIREGGUID);
        if (GuidBufferSize > BufferSize)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Now call the core to parse the registration info and build
        // the data structures
        //
        if (Update)
        {
            //
            // CONSIDER: UM Code had held the critsect over all
            // WMIREGINFOs linked together
            //
            Status = WmipUpdateDataSource(RegEntry,
                                              WmiRegInfo,
                                              BufferSize);
#if DBG
            if (! NT_SUCCESS(Status))
            {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                  DPFLTR_REGISTRATION_LEVEL,
                                  "WMI: WmipUpdateDataSourceFailed %x for RegEntry %p\n",
                         Status, RegEntry));
            }
#endif
        } else {
            Status = WmipAddDataSource(RegEntry,
                                           WmiRegInfo,
                                           BufferSize,
                                           RegPath,
                                           ResourceName,
                                           RequestObject,
                                           IsUserMode);
        }

        if (NT_SUCCESS(Status))
        {
            //
            // if at least one of the registrations was added
            // successfully then the final status is success
            //
            FinalStatus = STATUS_SUCCESS;

        } else {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                              DPFLTR_REGISTRATION_LEVEL,
                              "WMI: WmipAddDataSourceFailed %x for RegEntry %p\n",
                          Status, RegEntry));
        }

        Linkage = WmiRegInfo->NextWmiRegInfo;
        if (BufferSize >= (Linkage + sizeof(WMIREGINFO)))
        {
            //
            // There is enough room in the buffer for the next WMIREGINFO
            //
            WmiRegInfo = (PWMIREGINFO)((PUCHAR)WmiRegInfo + Linkage);
            BufferSize -= Linkage;
        } else {
            //
            // There is not enough room in buffer for next WMIREGINFO
            //
            break;
        }

    } while (Linkage != 0);

    return(FinalStatus);
}

//
// This defines the initial value of the buffer passed to each data provider
// to retrieve the registration information
#if DBG
#define INITIALREGINFOSIZE sizeof(WNODE_TOO_SMALL)
#else
#define INITIALREGINFOSIZE 8192
#endif

NTSTATUS WmipRegisterOrUpdateDS(
    PREGENTRY RegEntry,
    BOOLEAN Update
    )
{
    PUCHAR Buffer;
    IO_STATUS_BLOCK IoStatus;
    ULONG SizeNeeded;
    NTSTATUS Status;

    PAGED_CODE();

    IoStatus.Information = 0;

    //
    // Call the driver to get the registration information
    //
    SizeNeeded = INITIALREGINFOSIZE;
    do
    {
        Buffer = ExAllocatePoolWithTag(NonPagedPool, SizeNeeded,
                                       WmipRegisterDSPoolTag);
        if (Buffer != NULL)
        {
            //
            // First send IRP_MN_REGINFO_EX to see if we've got
            // a sophisticated client
            //
            Status = WmipSendWmiIrp(IRP_MN_REGINFO_EX,
                                    RegEntry->ProviderId,
                                    UlongToPtr(Update ?
                                                  WMIUPDATE :
                                                  WMIREGISTER),
                                    SizeNeeded,
                                    Buffer,
                                    &IoStatus);
                                                  
            if ((! NT_SUCCESS(Status)) &&
                (Status != STATUS_BUFFER_TOO_SMALL))
            {
                //
                // If IRP_MN_REGINFO_EX doesn't work then try our old
                // reliable IRP_MN_REGINFO
                //
                Status = WmipSendWmiIrp(IRP_MN_REGINFO,
                                        RegEntry->ProviderId,
                                        UlongToPtr(Update ?
                                                      WMIUPDATE :
                                                      WMIREGISTER),
                                        SizeNeeded,
                                        Buffer,
                                        &IoStatus);
            }

            if ((Status == STATUS_BUFFER_TOO_SMALL) ||
                (IoStatus.Information == sizeof(ULONG)))
            {
                //
                // if the buffer was too small then get the size we need
                // for the registration info and try again
                //
                SizeNeeded = *((PULONG)Buffer);
                ExFreePool(Buffer);
                Status = STATUS_BUFFER_TOO_SMALL;
            }

        } else {
            //
            // CONSIDER: retry this later to see if we can get more memory
            //
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } while (Status == STATUS_BUFFER_TOO_SMALL);

    //
    // If registration info irp was successful then go process registration
    // information
    //
    if (NT_SUCCESS(Status))
    {
        Status = WmipProcessWmiRegInfo(RegEntry,
                                       (PWMIREGINFO)Buffer,
                                       (ULONG)IoStatus.Information,
                                       NULL,
                                       Update,
                                       FALSE);
    }

    if (Buffer != NULL)
    {
        ExFreePool(Buffer);
    }

    return(Status);
}


NTSTATUS WmipUpdateDS(
    PREGENTRY RegEntry
    )
{
    PAGED_CODE();

    return(WmipRegisterOrUpdateDS(RegEntry,
                                  TRUE));
}

NTSTATUS WmipRegisterDS(
    PREGENTRY RegEntry
)
{
    PAGED_CODE();

    return(WmipRegisterOrUpdateDS(RegEntry,
                                  FALSE));
}

void WmipRemoveDS(
    PREGENTRY RegEntry
)
{
    PAGED_CODE();

    WmipRemoveDataSource(RegEntry);
}


void WmipRegistrationWorker(
    PVOID Context
   )
{
    PREGISTRATIONWORKITEM RegWork;
    ULONG RegWorkCount;
    NTSTATUS Status;
    PLIST_ENTRY RegWorkList;
    PREGENTRY RegEntry;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (Context);

    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                       DPFLTR_REGISTRATION_LEVEL,
                       "WMI: Registration Worker active, WmipRegWorkItemCount %d\n",
                       WmipRegWorkItemCount
                      ));
    
    WmipAssert(WmipRegWorkItemCount > 0);

    //
    // Synchronize with PnP.
    //
    IoControlPnpDeviceActionQueue(TRUE);

    do
    {
        WmipEnterSMCritSection();
        WmipAssert(! IsListEmpty(&WmipRegWorkList));
        RegWorkList = RemoveHeadList(&WmipRegWorkList);
        WmipLeaveSMCritSection();
        RegWork = CONTAINING_RECORD(RegWorkList,
                                    REGISTRATIONWORKITEM,
                                    ListEntry);

        RegEntry = RegWork->RegEntry;

        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                           DPFLTR_REGISTRATION_LEVEL,
                           "WMI: RegWorker %p for RegEntry %p active, RegOperation %d\n",
                           RegWork,
                           RegEntry,
                           RegWork->RegOperation
                          ));
        
        switch(RegWork->RegOperation)
        {
            case RegisterSingleDriver:
            {
                Status = WmipRegisterDS(RegEntry);
                if (NT_SUCCESS(Status))
                {
                    //
                    // Mark regentry as fully registered so now we can start
                    // accepting unregister calls
                    //
                    RegEntry->Flags &= ~REGENTRY_FLAG_REG_IN_PROGRESS;
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                      DPFLTR_REGISTRATION_LEVEL,
                                      "WMI: WmipRegisterDS(%p) succeeded for device %p\n",
                                      RegEntry,
                                      RegEntry->DeviceObject));
                } else {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                      DPFLTR_REGISTRATION_LEVEL,
                                      "WMI: WmipRegisterDS(%p) failed %x for device %p\n",
                                      RegEntry,
                                      Status,
                                      RegEntry->DeviceObject));
                    // CONSIDER: Do we remove regentry ??
                }
                //
                // Remove ref when work item was queued
                //
                WmipUnreferenceRegEntry(RegEntry);

                break;
            }

            case RegisterUpdateSingleDriver:
            {
                Status = WmipUpdateDS(RegEntry);
                if (! NT_SUCCESS(Status))
                {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                      DPFLTR_REGISTRATION_LEVEL,
                                      "WMI: WmipUpdateDS(%p) failed %x for device %p\n",
                                      RegEntry, Status, RegEntry->DeviceObject));
                } else {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                      DPFLTR_REGISTRATION_LEVEL,
                                      "WMI: WmipUpdateDS(%p) succeeded for device %p\n",
                                      RegEntry,
                                      RegEntry->DeviceObject));
                }

                //
                // Remove ref when work item was queued
                //
                WmipUnreferenceRegEntry(RegEntry);
                break;
            }

            default:
            {
                WmipAssert(FALSE);
            }
        }
        WmipFree(RegWork);

        RegWorkCount = InterlockedDecrement(&WmipRegWorkItemCount);
    } while (RegWorkCount != 0);
    
    IoControlPnpDeviceActionQueue(FALSE);

    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                      DPFLTR_REGISTRATION_LEVEL,
                      "WMI: RegWork completed WmipRegWorkItemCount %d\n",
                      WmipRegWorkItemCount
                     ));
}

NTSTATUS WmipQueueRegWork(
    REGOPERATION RegOperation,
    PREGENTRY RegEntry
    )
{
    PREGISTRATIONWORKITEM RegWork;
    NTSTATUS Status;

    PAGED_CODE();

    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                       DPFLTR_REGISTRATION_LEVEL,
                       "WMI: WmipQueueRegWork RegEntry %p REGOPERATION %x\n",
                       RegEntry,
                       RegOperation
                      ));
    
    RegWork = (PREGISTRATIONWORKITEM)WmipAlloc(sizeof(REGISTRATIONWORKITEM));
    if (RegWork != NULL)
    {
        //
        // Take an extra ref on the RegEntry which will be freed
        // after the work item is processed
        //
        WmipReferenceRegEntry(RegEntry);
        RegWork->RegOperation = RegOperation;
        RegWork->RegEntry = RegEntry;

        WmipEnterSMCritSection();
        InsertTailList(&WmipRegWorkList,
                       &RegWork->ListEntry);
        WmipLeaveSMCritSection();

        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                           DPFLTR_REGISTRATION_LEVEL,
                           "WMI: REGWORK %p for RegEntry %p inserted in list\n",
                           RegWork,
                           RegEntry
                          ));
        
        if (InterlockedIncrement(&WmipRegWorkItemCount) == 1)
        {
            //
            // If the list is transitioning from empty to non empty
            // then we need to fire up the worker thread to process
            //
            ExQueueWorkItem(&WmipRegWorkQueue, DelayedWorkQueue);
            
            WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                               DPFLTR_REGISTRATION_LEVEL,
                               "WMI: ReQorkQueue %p kicked off WmipRegWorkItemCount %d\n",
                               WmipRegWorkQueue,
                               WmipRegWorkItemCount
                              ));
        } else {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                               DPFLTR_REGISTRATION_LEVEL,
                               "WMI: ReQorkQueue %p already active WmipRegWorkItemCount %d\n",
                               WmipRegWorkQueue,
                               WmipRegWorkItemCount
                              ));
        }
        Status = STATUS_SUCCESS;

        //
        // RegWork will be freed by the work item processing
        //
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                           DPFLTR_REGISTRATION_LEVEL,
                           "WMI: Couldn not alloc REGWORK for RegEntry %p\n",
                           RegEntry
                          ));
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return(Status);
}

#if defined(_WIN64)
ULONG IoWMIDeviceObjectToProviderId(
    __in PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine will lookup the provider id that corresponds with the
    device object passed.

Arguments:

Return Value:

    Returns provider id for device object

--*/
{
    PREGENTRY RegEntry;
    ULONG ProviderId;
    KIRQL OldIrql;

    KeAcquireSpinLock(&WmipRegistrationSpinLock,
                     &OldIrql);
    
    RegEntry = WmipDoFindRegEntryByDevice(DeviceObject,
                                         REGENTRY_FLAG_RUNDOWN);
    
    if (RegEntry != NULL)
    {
        ProviderId = RegEntry->ProviderId;
    } else {
        ProviderId = 0;
    }
    
    KeReleaseSpinLock(&WmipRegistrationSpinLock,
                      OldIrql);
    
    return(ProviderId);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\tracesup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    tracesup.c

Abstract:

    This is the source file that implements the private routines of
    the performance event tracing and logging facility. These routines
    work on manipulating the LoggerContext table and synchronization
    across event tracing sessions.

--*/

#include "wmikmp.h"
#include <ntos.h>
#include <evntrace.h>

#include <wmi.h>
#include "tracep.h"

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define KERNEL_LOGGER_CAPTION   L"NT Kernel Logger"
#define DEFAULT_BUFFERS         2
#define DEFAULT_AGE_LIMIT       15          // 15 minutes
#define SEMAPHORE_LIMIT         1024
#define CONTEXT_SIZE            PAGE_SIZE
#define DEFAULT_MAX_IRQL        DISPATCH_LEVEL
#define DEFAULT_MAX_BUFFERS     20

ULONG WmipKernelLogger = KERNEL_LOGGER;
ULONG WmipEventLogger = 0XFFFFFFFF;
KGUARDED_MUTEX WmipTraceGuardedMutex;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
ULONG   WmipLoggerCount = 0;
HANDLE  EtwpPageLockHandle = NULL;
PSECURITY_DESCRIPTOR EtwpDefaultTraceSecurityDescriptor;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

extern SIZE_T MmMaximumNonPagedPoolInBytes;
extern SIZE_T MmSizeOfPagedPoolInBytes;

WMI_GET_CPUCLOCK_ROUTINE WmiGetCpuClock = &WmipGetSystemTime;

//
// Function prototypes for routines used locally
//

NTSTATUS
WmipLookupLoggerIdByName(
    IN PUNICODE_STRING Name,
    OUT PULONG LoggerId
    );

PWMI_LOGGER_CONTEXT
WmipInitContext(
    );

NTSTATUS
WmipAllocateTraceBufferPool(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

NTSTATUS
WmipFreeTraceBufferPool(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, WmipStartLogger)
#pragma alloc_text(PAGE, WmipQueryLogger)
#pragma alloc_text(PAGE, WmipStopLoggerInstance)
#pragma alloc_text(PAGE, WmipVerifyLoggerInfo)
#pragma alloc_text(PAGE, WmipExtendBase)
#pragma alloc_text(PAGE, WmipFreeLoggerContext)
#pragma alloc_text(PAGE, WmipInitContext)
#pragma alloc_text(PAGE, WmipAllocateTraceBufferPool)
#pragma alloc_text(PAGE, WmipFreeTraceBufferPool)
#pragma alloc_text(PAGE, WmipLookupLoggerIdByName)
#pragma alloc_text(PAGE, WmipShutdown)
#pragma alloc_text(PAGE, WmipFlushLogger)
#pragma alloc_text(PAGE, WmipNtDllLoggerInfo)
#pragma alloc_text(PAGE, WmipValidateClockType)
/* Look at the comments in the function body
#pragma alloc_text(PAGE, WmipDumpGuidMaps)
#pragma alloc_text(PAGE, WmipGetTraceBuffer)
*/
#pragma alloc_text(PAGEWMI, WmipNotifyLogger)
#endif


NTSTATUS
WmipStartLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    It is called by WmipIoControl in wmi.c, with IOCTL_WMI_START_LOGGER
    to start up an instance of the logger. It basically creates and
    initializes the logger instance context, and starts up a system
    thread for the logger (WmipLogger()). If the user has requested to
    turn on kernel tracing, it will also lock in the necessary routines
    after the logger has started.
    NOTE: A special instance (KERNEL_LOGGER) is reserved exclusively for
    logging kernel tracing.

    To turn on KERNEL_LOGGER, LoggerInfo->Wnode.Guid should be set to
    SystemTraceControlGuid, and sufficient space must be provided in
    LoggerInfo->LoggerName.

    To turn on other loggers, simply provide a name in LoggerName. The
    logger id will be returned.

Arguments:

    LoggerInfo     a pointer to the structure for the logger's control
                    and status information

Return Value:

    The status of performing the action requested.

--*/

{
    NTSTATUS Status;
    ULONG               LoggerId, EnableKernel, EnableFlags;
    HANDLE              ThreadHandle;
    PWMI_LOGGER_CONTEXT LoggerContext;
    LARGE_INTEGER       TimeOut = {(ULONG)(-20 * 1000 * 1000 * 10), -1};
    ACCESS_MASK         DesiredAccess = TRACELOG_GUID_ENABLE;
    PWMI_LOGGER_CONTEXT *ContextTable;
    PFILE_OBJECT        FileObject;
    GUID                InstanceGuid;
    KPROCESSOR_MODE     RequestorMode;
    SECURITY_QUALITY_OF_SERVICE ServiceQos;
    PTRACE_ENABLE_FLAG_EXTENSION FlagExt = NULL;
    PERFINFO_GROUPMASK *PerfGroupMasks=NULL;
    BOOLEAN             IsGlobalForKernel = FALSE;
    BOOLEAN             IsKernelRealTimeNoFile = FALSE;
    ULONG               GroupMaskSize;
    UNICODE_STRING      FileName, LoggerName;
    ULONG               LogFileMode;
#if DBG
    LONG                RefCount;
#endif

    PAGED_CODE();
    if (LoggerInfo == NULL)
        return STATUS_SEVERITY_ERROR;

    //
    // try and check for bogus parameter
    // if the size is at least what we want, we have to assume it's valid
    //
    if (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        return STATUS_INVALID_BUFFER_SIZE;

    if (! (LoggerInfo->Wnode.Flags & WNODE_FLAG_TRACED_GUID) )
        return STATUS_INVALID_PARAMETER;

    LogFileMode = LoggerInfo->LogFileMode;
    if ( (LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) &&
         (LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) ) {
        return STATUS_INVALID_PARAMETER;
    }

    if ( (LogFileMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE) &&
         (LogFileMode & EVENT_TRACE_USE_LOCAL_SEQUENCE) ) {
        return STATUS_INVALID_PARAMETER;
    }

/*    if (LogFileMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE) {
        if ((LoggerInfo->LogFileName.Length == 0) ||
            (LoggerInfo->LogFileName.Buffer == NULL) )
            return STATUS_INVALID_PARAMETER;
    }*/
    if ( !(LogFileMode & EVENT_TRACE_REAL_TIME_MODE) ) {
        if ( !(LogFileMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE) )
            if (LoggerInfo->LogFileHandle == NULL)
                return STATUS_INVALID_PARAMETER;
    }

    // Cannot support append to circular
    if ( (LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) &&
         (LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) ) {
        return STATUS_INVALID_PARAMETER;
    }


    if (LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
        DesiredAccess |= TRACELOG_CREATE_REALTIME;
    }

    if ((LoggerInfo->LogFileHandle != NULL) ||
        (LogFileMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE)) {
        DesiredAccess |= TRACELOG_CREATE_ONDISK;
    }

    EnableFlags = LoggerInfo->EnableFlags;
    if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
        FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &EnableFlags;

        if ((FlagExt->Length == 0) || 
            (FlagExt->Offset == 0) ||
            (LoggerInfo->Wnode.BufferSize < FlagExt->Offset)) {
            return STATUS_INVALID_PARAMETER;
        }
        if ((FlagExt->Length * sizeof(ULONG)) >
            (LoggerInfo->Wnode.BufferSize - FlagExt->Offset))
            return STATUS_INVALID_PARAMETER;
    }

    if (LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE) {
        if ((LoggerInfo->LogFileName.Buffer == NULL) ||
            (LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) ||
            (LoggerInfo->MaximumFileSize == 0) ||
            IsEqualGUID(&LoggerInfo->Wnode.Guid, &SystemTraceControlGuid))
            return STATUS_INVALID_PARAMETER;
    }

    if (LogFileMode & EVENT_TRACE_USE_KBYTES_FOR_SIZE) {
        // Default Minimum Buffers and default Buffer Size are computed
        // later in the Context initialization after Context allocation.
        // To avoid having to allocate memory for this error checking,
        // we compute local parameters. 
        ULONG LocalMinBuffers = (ULONG)KeNumberProcessors + DEFAULT_BUFFERS;
        ULONG LocalBufferSize = PAGE_SIZE / 1024;
        ULONG LocalMaxBuffers; 
        SIZE_T WmiMaximumPoolInBytes;

        if (LoggerInfo->BufferSize > 0) {
            if (LoggerInfo->BufferSize > MAX_WMI_BUFFER_SIZE) {
                LocalBufferSize = MAX_WMI_BUFFER_SIZE;
            }
            else {
                LocalBufferSize = LoggerInfo->BufferSize;
            }
        }
        if (LogFileMode & EVENT_TRACE_USE_PAGED_MEMORY) {
            WmiMaximumPoolInBytes = MmSizeOfPagedPoolInBytes;
        }
        else {
            WmiMaximumPoolInBytes = MmMaximumNonPagedPoolInBytes;
        }
        LocalMaxBuffers = (ULONG) (WmiMaximumPoolInBytes
                            / TRACE_MAXIMUM_NP_POOL_USAGE
                            / LocalBufferSize);
        if (LoggerInfo->MaximumBuffers != 0 && 
            LoggerInfo->MaximumBuffers < LocalMaxBuffers) {
            LocalMaxBuffers = LoggerInfo->MaximumBuffers;
        }
        if (LocalMinBuffers < LoggerInfo->MinimumBuffers && 
            LoggerInfo->MinimumBuffers < LocalMaxBuffers) {
            LocalMinBuffers = LoggerInfo->MinimumBuffers;
        }
        // MaximumFileSize must be multiples of buffer size
        if ((LoggerInfo->LogFileName.Buffer == NULL) ||
            (LoggerInfo->MaximumFileSize == 0) || 
            ((LoggerInfo->MaximumFileSize % LocalBufferSize) != 0) ||
            (LoggerInfo->MaximumFileSize < (LocalMinBuffers * LocalBufferSize))) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    RequestorMode = KeGetPreviousMode();

    LoggerName.Buffer = NULL;

    if (LoggerInfo->LoggerName.Length > 0) {
        try {
            if (RequestorMode != KernelMode) {
                ProbeForRead(
                    LoggerInfo->LoggerName.Buffer,
                    LoggerInfo->LoggerName.Length,
                    sizeof (UCHAR) );
            }
            if (! RtlCreateUnicodeString(
                    &LoggerName,
                    LoggerInfo->LoggerName.Buffer) ) {
                return STATUS_NO_MEMORY;
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            if (LoggerName.Buffer) {
                RtlFreeUnicodeString(&LoggerName);
            }
            return GetExceptionCode();
        }
        Status = WmipLookupLoggerIdByName(&LoggerName, &LoggerId);
        if (NT_SUCCESS(Status)) {
            RtlFreeUnicodeString(&LoggerName);
            return STATUS_OBJECT_NAME_COLLISION;
        }
    }

    ContextTable = (PWMI_LOGGER_CONTEXT *) &WmipLoggerContext[0];

    // If NULL GUID is given, generate a random GUID.
    RtlZeroMemory(&InstanceGuid, sizeof(GUID));
    if (IsEqualGUID(&LoggerInfo->Wnode.Guid, &InstanceGuid)) {
        Status = ExUuidCreate(&LoggerInfo->Wnode.Guid);
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }
    else {
        InstanceGuid = LoggerInfo->Wnode.Guid;
    }

    EnableKernel = IsEqualGUID(&InstanceGuid, &SystemTraceControlGuid);

    if (EnableKernel) {
        //
        // Check if this is the Real-Time No LogFile case.
        //
        if ((LogFileMode & EVENT_TRACE_REAL_TIME_MODE) &&
            !(LogFileMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE)){

            IsKernelRealTimeNoFile = TRUE;

        }
        //
        // This prevents multiple threads from continuing beyond this
        // point in the code.  Only the first thread will progress.
        //
        if (InterlockedCompareExchangePointer(  // if already running
                &ContextTable[WmipKernelLogger], ContextTable, NULL) != NULL)
            return STATUS_OBJECT_NAME_COLLISION;

        LoggerId = WmipKernelLogger;
        DesiredAccess |= TRACELOG_ACCESS_KERNEL_LOGGER;
    }
    else if (IsEqualGUID(&InstanceGuid, &GlobalLoggerGuid)) {
        LoggerId = WMI_GLOBAL_LOGGER_ID;
        if (InterlockedCompareExchangePointer(  // if already running
                &ContextTable[LoggerId], ContextTable, NULL) != NULL)
            return STATUS_OBJECT_NAME_COLLISION;
        if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            ULONG lFlag;
            //
            // To avoid alignment woes, copy the flags 
            //
            RtlCopyMemory(&lFlag, ((PCHAR)LoggerInfo + FlagExt->Offset), sizeof(ULONG));
            if (lFlag != 0) {
                EnableKernel = TRUE;
                IsGlobalForKernel = TRUE;
                WmipKernelLogger = LoggerId;
            }
        }
        // everyone has access to send to this
    }
    else {   // other loggers requested
        for (LoggerId = 2; LoggerId < MAXLOGGERS; LoggerId++) {
            if ( InterlockedCompareExchangePointer(
                    &ContextTable[LoggerId],
                    ContextTable,
                    NULL ) == NULL )
                break;      // mark the slot as busy by putting in ServiceInfo
        }

        if (LoggerId >=  MAXLOGGERS) {    // could not find any more slots
            return STATUS_UNSUCCESSFUL;
        }
    }
#if DBG
    RefCount =
#endif
    WmipReferenceLogger(LoggerId);
    TraceDebug((1, "WmipStartLogger: %d %d->%d\n", LoggerId,
                    RefCount-1, RefCount));
    //
    // first, check to see if caller has access to proper Guids.
    //
    Status = WmipCheckGuidAccess(
                &InstanceGuid,
                DesiredAccess,
                EtwpDefaultTraceSecurityDescriptor
                );
    if (!NT_SUCCESS(Status)) {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmipStartLogger: Status1=%X %d %d->%d\n",
                    Status, LoggerId, RefCount+1, RefCount));
        ContextTable[LoggerId] = NULL;
        return Status;
    }

    // Next, try and see if we need to get the logfile object first
    //
    FileObject = NULL;
    if (LoggerInfo->LogFileHandle != NULL) {
        OBJECT_HANDLE_INFORMATION handleInformation;
        ACCESS_MASK grantedAccess;

        Status = ObReferenceObjectByHandle(
                    LoggerInfo->LogFileHandle,
                    0L,
                    IoFileObjectType,
                    RequestorMode,
                    (PVOID *) &FileObject,
                    &handleInformation);

        if (NT_SUCCESS(Status)) {
            TraceDebug((1, "WmipStartLogger: Referenced FDO %X %X %d\n",
                        FileObject, LoggerInfo->LogFileHandle,
                        ((POBJECT_HEADER)FileObject)->PointerCount));
            if (RequestorMode != KernelMode) {
                grantedAccess = handleInformation.GrantedAccess;
                if (!SeComputeGrantedAccesses(grantedAccess, FILE_WRITE_DATA)) {
                    TraceDebug((1, "WmipStartLogger: Deref FDO %x %d\n",
                                FileObject,
                                ((POBJECT_HEADER)FileObject)->PointerCount));
                    Status = STATUS_ACCESS_DENIED;
                }
            }
            ObDereferenceObject(FileObject);
        }

        if (!NT_SUCCESS(Status)) {
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((1, "WmipStartLogger: Status2=%X %d %d->%d\n",
                            Status, LoggerId, RefCount+1, RefCount));
            ContextTable[LoggerId] = NULL;
            return Status;
        }
    }

    LoggerContext = WmipInitContext();
    if (LoggerContext == NULL) {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        Status = STATUS_NO_MEMORY;
        TraceDebug((1, "WmipStartLogger: Status5=%X %d %d->%d\n",
                        Status, LoggerId, RefCount+1, RefCount));
        ContextTable[LoggerId] = NULL;
        return Status;
    }
    WmipInitializeMutex(&LoggerContext->LoggerMutex);

    if (LogFileMode & EVENT_TRACE_USE_PAGED_MEMORY) {
        LoggerContext->PoolType = PagedPool;
        LoggerContext->LoggerMode |= EVENT_TRACE_USE_PAGED_MEMORY;
    }
    else {
        LoggerContext->PoolType = NonPagedPool;
    }

    if (LogFileMode & EVENT_TRACE_KD_FILTER_MODE) {
        LoggerContext->LoggerMode |= EVENT_TRACE_KD_FILTER_MODE;
        LoggerContext->BufferCallback = &KdReportTraceData;
    }
    LoggerContext->InstanceGuid = InstanceGuid;
    // By now, the slot will be allocated properly

    LoggerContext->MaximumFileSize = LoggerInfo->MaximumFileSize;
    LoggerContext->BuffersWritten  = LoggerInfo->BuffersWritten;

    LoggerContext->LoggerMode |= LoggerInfo->LogFileMode & 0x0000FFFF;

    // For circular logging with persistent events.
    if (!EnableKernel && LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_CIRCULAR_PERSIST) {
        LoggerContext->RequestFlag |= REQUEST_FLAG_CIRCULAR_PERSIST;
    }

    // LoggerInfo->Wow is set by the kernel in IOCTL
    LoggerContext->Wow = LoggerInfo->Wow;

    WmipValidateClockType(LoggerInfo);

    LoggerContext->UsePerfClock = LoggerInfo->Wnode.ClientContext;

    if (LoggerInfo->FlushTimer > 0)
        LoggerContext->FlushTimer = LoggerInfo->FlushTimer;

    if (LoggerInfo->AgeLimit >= 0) { // minimum is 15 minutes
        LoggerContext->BufferAgeLimit.QuadPart
            = max (DEFAULT_AGE_LIMIT, LoggerInfo->AgeLimit)
                     * WmiOneSecond.QuadPart * 60;
    }
    else if (LoggerInfo->AgeLimit < 0) {
        LoggerContext->BufferAgeLimit.QuadPart = 0;
    }

    LoggerContext->LoggerId = LoggerId;
    LoggerContext->EnableFlags = EnableFlags;
    LoggerContext->KernelTraceOn = EnableKernel;
    LoggerContext->MaximumIrql = DEFAULT_MAX_IRQL;

    if (EnableKernel) {
        //
        // Always reserve space for FileTable to allow file trace
        // to be turn on/off dynamically
        //
        WmipFileTable
            = (PFILE_OBJECT*) WmipExtendBase(
                 LoggerContext, MAX_FILE_TABLE_SIZE * sizeof(PVOID));

        Status = (WmipFileTable == NULL) ? STATUS_NO_MEMORY : STATUS_SUCCESS;
        if (NT_SUCCESS(Status)) {
            if (! RtlCreateUnicodeString(
                    &LoggerContext->LoggerName, KERNEL_LOGGER_CAPTION)) {
                Status = STATUS_NO_MEMORY;
            }
        }

        if (!NT_SUCCESS(Status)) {
            ExFreePool(LoggerContext);      // free the partial context
#if DBG
        RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((1, "WmipStartLogger: Status6=%X %d %d->%d\n",
                           Status, LoggerId, RefCount+1, RefCount));
            ContextTable[LoggerId] = NULL;
            return Status;
        }
    }

//
// Next, if user provided acceptable default buffer parameters, use them.
// Otherwise,  set them to predetermined default values.
//
    if (LoggerInfo->BufferSize > 0) {
        if (LoggerInfo->BufferSize > MAX_WMI_BUFFER_SIZE) {
            LoggerInfo->BufferSize = MAX_WMI_BUFFER_SIZE;
        }
        LoggerContext->BufferSize = LoggerInfo->BufferSize * 1024;
    }

    LoggerInfo->BufferSize = LoggerContext->BufferSize / 1024;
    if (LoggerInfo->MaximumBuffers >= 2) {
        LoggerContext->MaximumBuffers = LoggerInfo->MaximumBuffers;
    }

    if (LoggerInfo->MinimumBuffers >= 2 &&
        LoggerInfo->MinimumBuffers <= LoggerContext->MaximumBuffers) {
        LoggerContext->MinimumBuffers = LoggerInfo->MinimumBuffers;
    }

    RtlInitUnicodeString(&FileName, NULL);
    if (LoggerName.Buffer != NULL) {
        if (LoggerContext->KernelTraceOn) {
            RtlFreeUnicodeString(&LoggerName);
            LoggerName.Buffer = NULL;
        }
        else {
            RtlInitUnicodeString(&LoggerContext->LoggerName, LoggerName.Buffer);
        }
    }

    try {
        if (LoggerInfo->Checksum != NULL) {
            ULONG SizeNeeded = sizeof(WNODE_HEADER)
                             + sizeof(TRACE_LOGFILE_HEADER);
            if (RequestorMode != KernelMode) {
                ProbeForRead(LoggerInfo->Checksum, SizeNeeded, sizeof(UCHAR));
            }
            LoggerContext->LoggerHeader =
                    ExAllocatePoolWithTag(PagedPool, SizeNeeded, TRACEPOOLTAG);
            if (LoggerContext->LoggerHeader != NULL) {
                RtlCopyMemory(LoggerContext->LoggerHeader,
                              LoggerInfo->Checksum,
                              SizeNeeded);
            }
        }
        if (LoggerContext->KernelTraceOn) {
            if (RequestorMode != KernelMode) {
                ProbeForWrite(
                    LoggerInfo->LoggerName.Buffer,
                    LoggerContext->LoggerName.Length + sizeof(WCHAR),
                    sizeof (UCHAR) );
            }
            RtlCopyUnicodeString(
                &LoggerInfo->LoggerName, &LoggerContext->LoggerName);
        }
        if (LoggerInfo->LogFileName.Length > 0) {
            if (RequestorMode != KernelMode) {
                ProbeForRead(
                    LoggerInfo->LogFileName.Buffer,
                    LoggerInfo->LogFileName.Length,
                    sizeof (UCHAR) );
            }
            if (! RtlCreateUnicodeString(
                    &FileName,
                    LoggerInfo->LogFileName.Buffer) ) {
                Status = STATUS_NO_MEMORY;
            }
        }

        //
        // Set up the Global mask for Perf traces
        //
        if (IsGlobalForKernel || IsKernelRealTimeNoFile) {
            if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
                GroupMaskSize = FlagExt->Length * sizeof(ULONG);
                if (GroupMaskSize < sizeof(PERFINFO_GROUPMASK)) {
                    GroupMaskSize = sizeof(PERFINFO_GROUPMASK);
                }
            } else {
                GroupMaskSize = sizeof(PERFINFO_GROUPMASK);
            }
    
            LoggerContext->EnableFlagArray = (PULONG) WmipExtendBase(LoggerContext, GroupMaskSize);
    
            if (LoggerContext->EnableFlagArray) {
                PCHAR FlagArray;

                RtlZeroMemory(LoggerContext->EnableFlagArray, GroupMaskSize);
                if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
                    FlagArray = (PCHAR) (FlagExt->Offset + (PCHAR) LoggerInfo);
    
                    //
                    // Copy only the bytes actually supplied
                    //
                    RtlCopyMemory(LoggerContext->EnableFlagArray, FlagArray, FlagExt->Length * sizeof(ULONG));

                    LoggerContext->EnableFlags = LoggerContext->EnableFlagArray[0];
    
                } else {
                    LoggerContext->EnableFlagArray[0] = EnableFlags;
                }
    
                PerfGroupMasks = (PERFINFO_GROUPMASK *) &LoggerContext->EnableFlagArray[0];
            } else {
                Status = STATUS_NO_MEMORY;
            }
        } else {
            ASSERT((EnableFlags & EVENT_TRACE_FLAG_EXTENSION) ==0);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
    //
    // The context is partially set up by now, so have to clean up
    //
        if (LoggerContext->LoggerName.Buffer != NULL) {
            RtlFreeUnicodeString(&LoggerContext->LoggerName);
        }
        if (FileName.Buffer != NULL) {
            RtlFreeUnicodeString(&FileName);
        }

        if (LoggerContext->LoggerHeader != NULL) {
            ExFreePool(LoggerContext->LoggerHeader);
        }
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmipStartLogger: Status7=EXCEPTION %d %d->%d\n",
                       LoggerId, RefCount+1, RefCount));
        ContextTable[LoggerId] = NULL;
        ExFreePool(LoggerContext);      // free the partial context
        return GetExceptionCode();
    }

    if (LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_NEWFILE) {
        RtlInitUnicodeString(&LoggerContext->LogFilePattern, FileName.Buffer);
        Status = WmipGenerateFileName(
                    &LoggerContext->LogFilePattern,
                    &LoggerContext->FileCounter,
                    &LoggerContext->LogFileName);
        if (!NT_SUCCESS(Status)) {
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((1, "WmipStartLogger: Status8=%X %d %d->%d\n",
                            Status, LoggerId, RefCount+1, RefCount));
            ContextTable[LoggerId] = NULL;
            if (LoggerContext->LoggerHeader != NULL) {
                ExFreePool(LoggerContext->LoggerHeader);
            }
            if (LoggerContext->LoggerName.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LoggerName);
            }
            if (LoggerContext->LogFileName.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LogFileName);
            }
            if (LoggerContext->LogFilePattern.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LogFilePattern);
            }
            ExFreePool(LoggerContext);
            return(Status);
        }
    }
    else {
        RtlInitUnicodeString(&LoggerContext->LogFileName, FileName.Buffer);
    }

    if (NT_SUCCESS(Status)) {
        // Obtain the security context here so we can use it
        // later to impersonate the user, which we will do
        // if we cannot access the file as SYSTEM.  This
        // usually occurs if the file is on a remote machine.
        //
        ServiceQos.Length  = sizeof(SECURITY_QUALITY_OF_SERVICE);
        ServiceQos.ImpersonationLevel = SecurityImpersonation;
        ServiceQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        ServiceQos.EffectiveOnly = TRUE;
        Status = SeCreateClientSecurity(
                    CONTAINING_RECORD(KeGetCurrentThread(), ETHREAD, Tcb),
                    &ServiceQos,
                    FALSE,
                    &LoggerContext->ClientSecurityContext);
    }
    if (!NT_SUCCESS(Status)) {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmipStartLogger: Status8=%X %d %d->%d\n",
                        Status, LoggerId, RefCount+1, RefCount));
        ContextTable[LoggerId] = NULL;
        if (LoggerContext != NULL) {
            if (LoggerContext->LoggerHeader != NULL) {
                ExFreePool(LoggerContext->LoggerHeader);
            }
            if (LoggerContext->LoggerName.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LoggerName);
            }
            if (LoggerContext->LogFileName.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LogFileName);
            }
            if (LoggerContext->LogFilePattern.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LogFilePattern);
            }
            ExFreePool(LoggerContext);
        }
        return(Status);
    }

    //
    // Now, allocate the buffer pool and associated buffers.
    // Note that buffer allocation routine will also set NumberOfBuffers and
    // MaximumBuffers.
    //

    InitializeSListHead (&LoggerContext->FreeList);
    InitializeSListHead (&LoggerContext->FlushList);
    InitializeSListHead (&LoggerContext->WaitList);
    InitializeSListHead (&LoggerContext->GlobalList);

    Status = WmipAllocateTraceBufferPool(LoggerContext);
    if (!NT_SUCCESS(Status)) {
        if (LoggerContext != NULL) {
            if (LoggerContext->LoggerHeader != NULL) {
                ExFreePool(LoggerContext->LoggerHeader);
            }
            if (LoggerContext->LoggerName.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LoggerName);
            }
            if (LoggerContext->LogFileName.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LogFileName);
            }
            if (LoggerContext->LogFilePattern.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LogFilePattern);
            }
            ExFreePool(LoggerContext);
        }
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmipStartLogger: Status9=%X %d %d->%d\n",
                        Status, LoggerId, RefCount+1, RefCount));
        ContextTable[LoggerId] = NULL;
        return Status;
    }

    //
    // From this point on, LoggerContext is a valid structure
    //
    LoggerInfo->NumberOfBuffers = (ULONG) LoggerContext->NumberOfBuffers;
    LoggerInfo->MaximumBuffers  = LoggerContext->MaximumBuffers;
    LoggerInfo->MinimumBuffers  = LoggerContext->MinimumBuffers;
    LoggerInfo->FreeBuffers     = (ULONG) LoggerContext->BuffersAvailable;
    LoggerInfo->EnableFlags     = LoggerContext->EnableFlags;
    LoggerInfo->AgeLimit        = (ULONG) (LoggerContext->BufferAgeLimit.QuadPart
                                    / WmiOneSecond.QuadPart / 60);
    LoggerInfo->BufferSize = LoggerContext->BufferSize / 1024;

    WmiSetLoggerId(LoggerId,
                (PTRACE_ENABLE_CONTEXT)&LoggerInfo->Wnode.HistoricalContext);

    if (LoggerContext->LoggerMode & EVENT_TRACE_USE_LOCAL_SEQUENCE)
        LoggerContext->SequencePtr = (PLONG) &LoggerContext->LocalSequence;
    else if (LoggerContext->LoggerMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE)
        LoggerContext->SequencePtr = (PLONG) &WmipGlobalSequence;

// Initialize synchronization event with logger
    KeInitializeEvent(
        &LoggerContext->LoggerEvent,
        NotificationEvent,
        FALSE
        );
    KeInitializeEvent(
        &LoggerContext->FlushEvent,
        NotificationEvent,
        FALSE
        );

//
// Close file handle here so that it can be opened by system thread
//
    if (LoggerInfo->LogFileHandle != NULL) {
        ZwClose(LoggerInfo->LogFileHandle);
        LoggerInfo->LogFileHandle = NULL;
    }

    //
    // User Mode call always gets APPEND mode
    // 
    LogFileMode = LoggerContext->LoggerMode;

    if (RequestorMode != KernelMode) {
        LoggerContext->LoggerMode |= EVENT_TRACE_FILE_MODE_APPEND;
    }

    //
    // Lock down the routines that need to be non-pageable
    //
    KeAcquireGuardedMutex(&WmipTraceGuardedMutex);
    if (++WmipLoggerCount == 1) {

        ASSERT(EtwpPageLockHandle);
        MmLockPageableSectionByHandle(EtwpPageLockHandle);
        WmipGlobalSequence = 0;
    }
    KeReleaseGuardedMutex(&WmipTraceGuardedMutex);

    //
    // Set the clock function and 
    // start up the logger as a system thread
    //
    if (NT_SUCCESS(Status)) {
        LoggerContext->WriteFailureLimit = 100;
        switch (LoggerContext->UsePerfClock) {
            case EVENT_TRACE_CLOCK_CPUCYCLE:
                    if (EnableKernel) {
                        WmiGetCpuClock = &PerfGetCycleCount;
                    }
                    LoggerContext->GetCpuClock = &PerfGetCycleCount;
                    break;
            case EVENT_TRACE_CLOCK_PERFCOUNTER: 
                    if (EnableKernel) {
                        WmiGetCpuClock = &WmipGetPerfCounter; 
                    }
                    LoggerContext->GetCpuClock = &WmipGetPerfCounter;
                    break;
            case EVENT_TRACE_CLOCK_SYSTEMTIME: 
            default : 
                    if (EnableKernel) {
                        WmiGetCpuClock = &WmipGetSystemTime;
                    }
                    LoggerContext->GetCpuClock = &WmipGetSystemTime;
                    break;
        }

        //
        // At this point, the clock type should be set and we take a
        // reference timesamp, which should be the earliest timestamp 
        // for the logger.  The order is this way since SystemTime
        // is typically cheaper to obtain. 
        // 

        LoggerContext->ReferenceTimeStamp.QuadPart = (*LoggerContext->GetCpuClock)();
        KeQuerySystemTime(&LoggerContext->ReferenceSystemTime);

        //
        // Start up the logger as a system thread
        //
        LoggerContext->LoggerStatus = STATUS_UNSUCCESSFUL;

        WmipReferenceLogger(LoggerId);

        Status = PsCreateSystemThread(
                    &ThreadHandle,
                    THREAD_ALL_ACCESS,
                    NULL,
                    NULL,
                    NULL,
                    WmipLogger,
                    LoggerContext );

        if (NT_SUCCESS(Status)) {  // if SystemThread is started
            ZwClose (ThreadHandle);

            Status = STATUS_UNSUCCESSFUL;
            do {
                //
                // Wait for Logger to start up properly before proceeding
                //
                KeWaitForSingleObject(
                            &LoggerContext->LoggerEvent,
                            Executive,
                            KernelMode,
                            FALSE,
                            &TimeOut
                            );

                KeResetEvent(&LoggerContext->LoggerEvent);

                if (Status == STATUS_UNSUCCESSFUL) {
                    //
                    // If the logger thread hasn't responded yet, replace the LoggerStatus
                    // to STATUS_CANCELLED so that if it ever comes up, it will terminate.
                    // We clean up the logger cointext if that is the case.
                    //
                    Status = InterlockedCompareExchange(&LoggerContext->LoggerStatus,
                                            STATUS_CANCELLED,
                                            STATUS_UNSUCCESSFUL);
                }
                else {
                    Status = LoggerContext->LoggerStatus;
                }
            }
            while (Status == STATUS_PENDING); 

            //
            // If the logger is up and running properly, we can now turn on
            // event tracing if kernel tracing is requested
            //
            if (NT_SUCCESS(Status)) {
                LoggerContext->LoggerMode = LogFileMode;

                //
                // After we release this mutex, any other thread can acquire
                // the valid logger context and call the shutdown path for 
                // this logger.  Until this, no other thread can call the enable
                // or disable code for this logger.
                //
                WmipAcquireMutex( &LoggerContext->LoggerMutex );
                InterlockedIncrement(&LoggerContext->MutexCount);

                LoggerInfo->BuffersWritten = LoggerContext->BuffersWritten;

                WmipLoggerContext[LoggerId] = LoggerContext;
                TraceDebug((1, "WmipStartLogger: Started %X %d\n",
                            LoggerContext, LoggerContext->LoggerId));
                if (LoggerContext->KernelTraceOn) {
                    EnableFlags = LoggerContext->EnableFlags;
                    if (EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
                        EnableFlags |= EVENT_TRACE_FLAG_DISK_IO;
                    WmipEnableKernelTrace(EnableFlags);
                }

                if (IsEqualGUID(&InstanceGuid, &WmiEventLoggerGuid)) {
                    WmipEventLogger = LoggerId;
                    EnableFlags = EVENT_TRACE_FLAG_PROCESS |
                                  EVENT_TRACE_FLAG_THREAD |
                                  EVENT_TRACE_FLAG_IMAGE_LOAD;
                    WmipEnableKernelTrace(EnableFlags);
                    LoggerContext->EnableFlags = EnableFlags;
                }

                if (LoggerContext->LoggerThread) {
                    LoggerInfo->LoggerThreadId
                        = LoggerContext->LoggerThread->Cid.UniqueThread;
                }

                //
                // Logger is started properly, now turn on perf trace
                //
                if (IsGlobalForKernel) {
                    ASSERT(LoggerContext->KernelTraceOn);
                    ASSERT(EnableKernel);
                    Status = PerfInfoStartLog(PerfGroupMasks, 
                                              PERFINFO_START_LOG_FROM_GLOBAL_LOGGER);
                    if (!NT_SUCCESS(Status)) {
                        //
                        // Turning on tracing failed, needs to clean up.
                        // Logger Thread has been created at this point.
                        // Just do WmipStopLoggerInstance and let Logger Thread
                        // handle all the cleanup work.
                        //
                        LoggerContext->LoggerStatus = Status;
                        WmipStopLoggerInstance(LoggerContext);
                    }
                } else if (IsKernelRealTimeNoFile) {
                    //
                    // We need to protect PerfInfoStartLog from stopping thread.
                    //
                    LONG PerfLogInTransition;

                    ASSERT(LoggerContext->KernelTraceOn);
                    ASSERT(EnableKernel);
                    PerfLogInTransition = InterlockedCompareExchange(
                                                &LoggerContext->PerfLogInTransition,
                                                PERF_LOG_START_TRANSITION,
                                                PERF_LOG_NO_TRANSITION);

                    if (PerfLogInTransition != PERF_LOG_NO_TRANSITION) {
                        Status = STATUS_ALREADY_DISCONNECTED;
                        LoggerContext->LoggerStatus = Status;
                    } else {
                        Status = PerfInfoStartLog(PerfGroupMasks, 
                                                  PERFINFO_START_LOG_POST_BOOT);
                        PerfLogInTransition =
                                InterlockedExchange(&LoggerContext->PerfLogInTransition,
                                                    PERF_LOG_NO_TRANSITION);
                        ASSERT(PerfLogInTransition == PERF_LOG_START_TRANSITION);
                        if (!NT_SUCCESS(Status)) {
                            //
                            // Turning on tracing failed, needs to clean up.
                            // Logger Thread has been created at this point.
                            // Just do WmipStopLoggerInstance and let Logger Thread
                            // handle all the cleanup work.
                            //
                            LoggerContext->LoggerStatus = Status;
                            WmipStopLoggerInstance(LoggerContext);
                        }
                    }
                }

                InterlockedDecrement(&LoggerContext->MutexCount);
                WmipReleaseMutex(&LoggerContext->LoggerMutex);

                WmipDereferenceLogger(LoggerId);
                // LoggerContext refcount is now >= 1 until it is stopped
                return Status;
            }
            else {
                //
                // The logger thread did not notify the starting thread, or
                // the logger thread started OK, but something failed during
                // file creation. The logger thread will clean up the logger
                // context. Just return.
                // 

                WmipDereferenceLogger(LoggerId);
                return Status;
            }
        }
        WmipDereferenceLogger(LoggerId);

    }
    TraceDebug((2, "WmipStartLogger: %d %X failed with status=%X ref %d\n",
                    LoggerId, LoggerContext, Status, WmipRefCount[LoggerId]));
    //
    // Will get here if Status has failed earlier.
    //
    if (LoggerContext != NULL) { // should not be NULL
        WmipFreeLoggerContext(LoggerContext);
    }
    else {
        WmipDereferenceLogger(LoggerId);
        ContextTable[LoggerId] = NULL;
    }
    return STATUS_UNSUCCESSFUL;
}


NTSTATUS
WmipQueryLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
/*++

Routine Description:

    This routine is called to control the data collection and logger.
    It is called by WmipIoControl in wmi.c, with IOCTL_WMI_QUERY_LOGGER.
    Caller must pass in either the Logger Name or a valid Logger Id/Handle.

Arguments:

    LoggerInfo     a pointer to the structure for the logger's control
                    and status information

    LoggerContext  if this is provided, it assumes it is a valid one

Return Value:

    The status of performing the action requested.

--*/

{
    NTSTATUS            Status;
    ULONG               LoggerId, NoContext;
    ACCESS_MASK         DesiredAccess = WMIGUID_QUERY;
    KPROCESSOR_MODE     RequestorMode;
#if DBG
    LONG                RefCount;
#endif

    PAGED_CODE();

    NoContext = (LoggerContext == NULL);
    if (NoContext) {
    
if ((LoggerInfo->Wnode.HistoricalContext == 0XFFFF) || (LoggerInfo->Wnode.HistoricalContext < 1))
        TraceDebug((2, "WmipQueryLogger: %d\n",
                        LoggerInfo->Wnode.HistoricalContext));
#if DBG
        Status = WmipVerifyLoggerInfo(
                    LoggerInfo, &LoggerContext, "WmipQueryLogger");
#else
        Status = WmipVerifyLoggerInfo( LoggerInfo, &LoggerContext );
#endif

        if (!NT_SUCCESS(Status) || (LoggerContext == NULL))
            return Status;        // cannot find by name nor logger id

        LoggerInfo->Wnode.Flags = 0;
        LoggerInfo->EnableFlags = 0;
        LoggerId = (ULONG) LoggerContext->LoggerId;

        if (LoggerContext->KernelTraceOn) {
            DesiredAccess |= TRACELOG_ACCESS_KERNEL_LOGGER;
        }

        Status = WmipCheckGuidAccess(
                    &LoggerContext->InstanceGuid,
                    DesiredAccess,
                    EtwpDefaultTraceSecurityDescriptor
                    );
        if (!NT_SUCCESS(Status)) {
            InterlockedDecrement(&LoggerContext->MutexCount);
            TraceDebug((1, "WmipQueryLogger: Release mutex1 %d %d\n",
                LoggerId, LoggerContext->MutexCount));
            WmipReleaseMutex(&LoggerContext->LoggerMutex);
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((1, "WmipQueryLogger: Status1=%X %d %d->%d\n",
                            Status, LoggerId, RefCount+1, RefCount));
            return Status;
        }
    }
    else {
        LoggerId = LoggerContext->LoggerId;
    }

    if (LoggerContext->KernelTraceOn) {
        LoggerInfo->Wnode.Guid = SystemTraceControlGuid;
        LoggerInfo->EnableFlags = LoggerContext->EnableFlags;
    }
    else
        LoggerInfo->Wnode.Guid = LoggerContext->InstanceGuid;

    LoggerInfo->LogFileMode     = LoggerContext->LoggerMode;
    LoggerInfo->MaximumFileSize = LoggerContext->MaximumFileSize;
    LoggerInfo->FlushTimer      = LoggerContext->FlushTimer;

    LoggerInfo->BufferSize      = LoggerContext->BufferSize / 1024;
    LoggerInfo->NumberOfBuffers = (ULONG) LoggerContext->NumberOfBuffers;
    LoggerInfo->MinimumBuffers  = LoggerContext->MinimumBuffers;
    LoggerInfo->MaximumBuffers  = LoggerContext->MaximumBuffers;
    LoggerInfo->EventsLost      = LoggerContext->EventsLost;
    LoggerInfo->FreeBuffers     = (ULONG) LoggerContext->BuffersAvailable;
    LoggerInfo->BuffersWritten  = LoggerContext->BuffersWritten;
    LoggerInfo->Wow             = LoggerContext->Wow;
    LoggerInfo->LogBuffersLost  = LoggerContext->LogBuffersLost;
    LoggerInfo->RealTimeBuffersLost = LoggerContext->RealTimeBuffersLost;
    LoggerInfo->AgeLimit        = (ULONG)
                                  (LoggerContext->BufferAgeLimit.QuadPart
                                    / WmiOneSecond.QuadPart / 60);
    WmiSetLoggerId(LoggerId,
                (PTRACE_ENABLE_CONTEXT)&LoggerInfo->Wnode.HistoricalContext);

    if (LoggerContext->LoggerThread) {
        LoggerInfo->LoggerThreadId
            = LoggerContext->LoggerThread->Cid.UniqueThread;
    }

    LoggerInfo->Wnode.ClientContext = LoggerContext->UsePerfClock;

//
// Return LogFileName and Logger Caption here
//
    RequestorMode = KeGetPreviousMode();
    try {
        if (LoggerContext->LogFileName.Length > 0 &&
            LoggerInfo->LogFileName.MaximumLength > 0) {
            if (RequestorMode != KernelMode) {
                ProbeForWrite(
                    LoggerInfo->LogFileName.Buffer,
                    LoggerContext->LogFileName.Length + sizeof(WCHAR),
                    sizeof (UCHAR) );
            }
            RtlCopyUnicodeString(
                &LoggerInfo->LogFileName,
                &LoggerContext->LogFileName);
        }
        if (LoggerContext->LoggerName.Length > 0 &&
            LoggerInfo->LoggerName.MaximumLength > 0) {
            if (RequestorMode != KernelMode) {
                ProbeForWrite(
                    LoggerInfo->LoggerName.Buffer,
                    LoggerContext->LoggerName.Length + sizeof(WCHAR),
                    sizeof(UCHAR));
            }
            RtlCopyUnicodeString(
                &LoggerInfo->LoggerName,
                &LoggerContext->LoggerName);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        if (NoContext) {
            InterlockedDecrement(&LoggerContext->MutexCount);
            TraceDebug((1, "WmipQueryLogger: Release mutex3 %d %d\n",
                LoggerId, LoggerContext->MutexCount));
            WmipReleaseMutex(&LoggerContext->LoggerMutex);
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((1, "WmipQueryLogger: Status3=EXCEPTION %d %d->%d\n",
                            LoggerId, RefCount+1, RefCount));
        }
        return GetExceptionCode();
    }

    if (NoContext) {
        InterlockedDecrement(&LoggerContext->MutexCount);
        TraceDebug((1, "WmipQueryLogger: Release mutex %d %d\n",
            LoggerId, LoggerContext->MutexCount));
        WmipReleaseMutex(&LoggerContext->LoggerMutex);
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmipQueryLogger: %d %d->%d\n",
                        LoggerId, RefCount+1, RefCount));
    }
    return STATUS_SUCCESS;
}


NTSTATUS
WmipStopLoggerInstance(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    LONG               LoggerOn;

    PAGED_CODE();
    if (LoggerContext == NULL) {    // just in case
        return STATUS_INVALID_HANDLE;
    }

    if (LoggerContext->KernelTraceOn) {
        // PerfInfoStopLog should not be executed when perf logging is starting
        // or stopping by other thread. PerfLogInTransition flag in the logger
        // context should only be used here and UpdateTrace and NO WHERE ELSE.
        LONG PerfLogInTransition = 
            InterlockedCompareExchange(&LoggerContext->PerfLogInTransition,
                                    PERF_LOG_STOP_TRANSITION,
                                    PERF_LOG_NO_TRANSITION);
        if (PerfLogInTransition == PERF_LOG_START_TRANSITION) {
            // This is the logger thread, and it is terminating. 
            // UpdateTrace call is enabling perf logging at the moment. 
            // Come back later.
            return STATUS_UNSUCCESSFUL;
        }
        else if (PerfLogInTransition == PERF_LOG_STOP_TRANSITION) {
            return STATUS_ALREADY_DISCONNECTED;
        }
        //
        // Time to turn off trace in perf tools
        //
        PerfInfoStopLog();
    }

    //
    // turn off data tracing first
    //
    LoggerOn = InterlockedExchange(&LoggerContext->CollectionOn, FALSE);
    if (LoggerOn == FALSE) {
        // This happens if another stoplogger already in progress
        return STATUS_ALREADY_DISCONNECTED;
    }
    if (LoggerContext->KernelTraceOn) {
        //
        // Turn off everything, just to be on the safe side
        // NOTE: If we start sharing callouts, the argument should be
        // LoggerContext->EnableFlags
        //
        WmipDisableKernelTrace(LoggerContext->EnableFlags);
    }
    if (LoggerContext->LoggerId == WmipEventLogger) {
        WmipDisableKernelTrace(EVENT_TRACE_FLAG_PROCESS |
                               EVENT_TRACE_FLAG_THREAD |
                               EVENT_TRACE_FLAG_IMAGE_LOAD);
        WmipEventLogger = 0xFFFFFFFF;
    }

    //
    // Mark the table entry as in-transition
    // From here on, the stop operation will not fail
    //
    WmipLoggerContext[LoggerContext->LoggerId] = (PWMI_LOGGER_CONTEXT)
                                                 &WmipLoggerContext[0];

    WmipNotifyLogger(LoggerContext);

    WmipSendNotification(LoggerContext, STATUS_THREAD_IS_TERMINATING, 0);
    return STATUS_SUCCESS;
}


NTSTATUS
WmipVerifyLoggerInfo(
    IN PWMI_LOGGER_INFORMATION LoggerInfo,
#if DBG
    OUT PWMI_LOGGER_CONTEXT *pLoggerContext,
    IN  LPSTR Caller
#else
    OUT PWMI_LOGGER_CONTEXT *pLoggerContext
#endif
    )
{
    NTSTATUS Status = STATUS_SEVERITY_ERROR;
    ULONG LoggerId;
    UNICODE_STRING LoggerName;
    KPROCESSOR_MODE     RequestorMode;
    PWMI_LOGGER_CONTEXT LoggerContext, CurrentContext;
    LONG            MutexCount = 0;
#if DBG
    LONG            RefCount;
#endif

    PAGED_CODE();

    *pLoggerContext = NULL;

    if (LoggerInfo == NULL)
        return STATUS_SEVERITY_ERROR;

    //
    // try and check for bogus parameter
    // if the size is at least what we want, we have to assume it's valid
    //

    if (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        return STATUS_INVALID_BUFFER_SIZE;

    if (! (LoggerInfo->Wnode.Flags & WNODE_FLAG_TRACED_GUID) )
        return STATUS_INVALID_PARAMETER;

    RtlInitUnicodeString(&LoggerName, NULL);

    RequestorMode = KeGetPreviousMode();
    try {
        if (LoggerInfo->LoggerName.Length > 0) {
            if (RequestorMode != KernelMode) {
                ProbeForRead(
                    LoggerInfo->LoggerName.Buffer,
                    LoggerInfo->LoggerName.Length,
                    sizeof (UCHAR) );
            }
            RtlCreateUnicodeString(
                &LoggerName,
                LoggerInfo->LoggerName.Buffer);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        if (LoggerName.Buffer != NULL) {
            RtlFreeUnicodeString(&LoggerName);
        }
        return GetExceptionCode();
    }
    Status = STATUS_SUCCESS;
    if (IsEqualGUID(&LoggerInfo->Wnode.Guid, &SystemTraceControlGuid)) {
        LoggerId = WmipKernelLogger;
    }
    else if (LoggerName.Length > 0) { // Logger Name is passed
        Status =  WmipLookupLoggerIdByName(&LoggerName, &LoggerId);
    }
    else {
        LoggerId = WmiGetLoggerId(LoggerInfo->Wnode.HistoricalContext);
        if (LoggerId == KERNEL_LOGGER_ID) {
            LoggerId = WmipKernelLogger;
        }
        else if (LoggerId < 1 || LoggerId >= MAXLOGGERS) {
            Status  = STATUS_INVALID_HANDLE;
        }
    }
    if (LoggerName.Buffer != NULL) {
        RtlFreeUnicodeString(&LoggerName);
    }
    if (!NT_SUCCESS(Status)) { // cannot find by name nor logger id
        return Status;
    }

#if DBG
    RefCount =
#endif
    WmipReferenceLogger(LoggerId);
    TraceDebug((2, "WmipVerifyLoggerInfo(%s): %d %d->%d\n",
                    Caller, LoggerId, RefCount-1, RefCount));

    LoggerContext = WmipGetLoggerContext( LoggerId );
    if (!WmipIsValidLogger(LoggerContext)) {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((2, "WmipVerifyLoggerInfo(%s): Status=%X %d %d->%d\n",
                        Caller, STATUS_WMI_INSTANCE_NOT_FOUND,
                        LoggerId, RefCount+1, RefCount));
        return STATUS_WMI_INSTANCE_NOT_FOUND;
    }

    InterlockedIncrement(&LoggerContext->MutexCount);
    TraceDebug((1, "WmipVerifyLoggerInfo: Acquiring mutex... %d %d\n",
                    LoggerId, LoggerContext->MutexCount));
    WmipAcquireMutex (&LoggerContext->LoggerMutex);
    TraceDebug((1, "WmipVerifyLoggerInfo: Acquired mutex %d %d %X\n",
                    LoggerId, LoggerContext->MutexCount, LoggerContext));

    // Need to check for validity of LoggerContext in mutex
    CurrentContext = WmipGetLoggerContext( LoggerId );
    if (!WmipIsValidLogger(CurrentContext) ||
        !LoggerContext->CollectionOn ) {
        TraceDebug((1, "WmipVerifyLoggerInfo: Released mutex %d %d\n",
            LoggerId, LoggerContext->MutexCount-1));
        WmipReleaseMutex(&LoggerContext->LoggerMutex);
        MutexCount = InterlockedDecrement(&LoggerContext->MutexCount);
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((2, "WmipVerifyLoggerInfo(%s): Status2=%X %d %d->%d\n",
                        Caller, STATUS_WMI_INSTANCE_NOT_FOUND,
                        LoggerId, RefCount+1, RefCount));

        return STATUS_WMI_INSTANCE_NOT_FOUND;
    }
    *pLoggerContext = LoggerContext;
    return STATUS_SUCCESS;
}

PVOID
WmipExtendBase(
    IN PWMI_LOGGER_CONTEXT Base,
    IN ULONG Size
    )
{
//
// This private routine only return space from the Base by extending its
// offset. It does not actually try and allocate memory from the system
//
// It rounds the size to a ULONGLONG alignment and expects EndPageMarker
// to already be aligned.
//
    PVOID Space = NULL;
    ULONG SpaceLeft;

    PAGED_CODE();

    ASSERT(((ULONGLONG) Base->EndPageMarker % sizeof(ULONGLONG)) == 0);

    //
    // Round up to pointer boundary
    //
#ifdef _WIN64
    Size = ALIGN_TO_POWER2(Size, 16);
#else
    Size = ALIGN_TO_POWER2(Size, DEFAULT_TRACE_ALIGNMENT);
#endif

    SpaceLeft = CONTEXT_SIZE - (ULONG) (Base->EndPageMarker - (PUCHAR)Base);

    if ( SpaceLeft > Size ) {
        Space = Base->EndPageMarker;
        Base->EndPageMarker += Size;
    }

    return Space;
}

VOID
WmipFreeLoggerContext(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    ULONG LoggerId;
    LONG  RefCount;
    LARGE_INTEGER Timeout = {(ULONG)(-50 * 1000 * 10), -1}; // 50 ms
    NTSTATUS Status = STATUS_TIMEOUT;

    PAGED_CODE();

    if (LoggerContext == NULL)
        return;             // should not happen

    if (LoggerContext->LoggerHeader != NULL) {
        ExFreePool(LoggerContext->LoggerHeader);
    }

    LoggerId = LoggerContext->LoggerId;

    //
    // The RefCount must be at least 2 at this point.
    // One was set by WmipStartLogger() in the beginning, and the
    // second must be done normally by WmiStopTrace() or anybody who
    // needs to call this routine to free the logger context
    //
    //  RefCount = WmipDereferenceLogger(LoggerId);

    KeResetEvent(&LoggerContext->LoggerEvent);
    RefCount = WmipRefCount[LoggerId];
    WmipAssert(RefCount >= 1);
    TraceDebug((1, "WmipFreeLoggerContext: %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));

    while (RefCount > 1) {
        Status = KeWaitForSingleObject(
                    &LoggerContext->LoggerEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    &Timeout);
        KeResetEvent(&LoggerContext->LoggerEvent);
        KeSetEvent(&LoggerContext->FlushEvent, 0, FALSE);     // Just to be sure

        if (LoggerContext->MutexCount >= 1) {
            KeResetEvent(&LoggerContext->LoggerEvent);
            Status = STATUS_TIMEOUT;
            continue;
        }

        if (WmipRefCount[LoggerId] <= 1)
            break;
        RefCount = WmipRefCount[LoggerId];
    }

    KeAcquireGuardedMutex(&WmipTraceGuardedMutex);
    if (--WmipLoggerCount == 0) {
        if (EtwpPageLockHandle) {
            MmUnlockPageableImageSection(EtwpPageLockHandle);
        }
#if DBG
        else {
            ASSERT(EtwpPageLockHandle);
        }
#endif
    }
    KeReleaseGuardedMutex(&WmipTraceGuardedMutex);

    WmipFreeTraceBufferPool(LoggerContext);

    if (LoggerContext->LoggerName.Buffer != NULL) {
        RtlFreeUnicodeString(&LoggerContext->LoggerName);
    }
    if (LoggerContext->LogFileName.Buffer != NULL) {
        RtlFreeUnicodeString(&LoggerContext->LogFileName);
    }
    if (LoggerContext->LogFilePattern.Buffer != NULL) {
        RtlFreeUnicodeString(&LoggerContext->LogFilePattern);
    }
    if (LoggerContext->NewLogFileName.Buffer != NULL) {
        RtlFreeUnicodeString(&LoggerContext->NewLogFileName);
    }
#if DBG
        RefCount =
#endif
    //
    // Finally, decrement the refcount incremented by WmipStartLogger()
    //
    WmipDereferenceLogger(LoggerId);

#if DBG
    TraceDebug((2, "WmipFreeLoggerContext: Freeing pool %X %d %d->%d\n",
                    LoggerContext, LoggerId, RefCount+1, RefCount));
    if (LoggerContext->CollectionOn) {
        TraceDebug((1,
            "WmipFreeLoggerContext: %X %d still active\n", LoggerContext,
            LoggerId));
    }

    if (LoggerContext->MutexCount >= 1) {
        TraceDebug((0, "****ERROR**** Mutex count is %d for %d\n", LoggerId,
            LoggerContext->MutexCount));
    }
#endif // DBG
    ExFreePool(LoggerContext);
    WmipLoggerContext[LoggerId] = NULL;
}


PWMI_LOGGER_CONTEXT
WmipInitContext(
    )

/*++

Routine Description:

    This routine is called to initialize the context of LoggerContext

Arguments:

    None

Returned Value:

    Status of STATUS_SUCCESS if the allocation was successful

--*/

{
    PWMI_LOGGER_CONTEXT LoggerContext;

    PAGED_CODE();

    LoggerContext = (PWMI_LOGGER_CONTEXT)
                    ExAllocatePoolWithTag(NonPagedPool,
                         CONTEXT_SIZE, TRACEPOOLTAG);

// One page is reserved to store the buffer pool pointers plus anything
// else that we need. Should experiment a little more to reduce it further

    if (LoggerContext == NULL) {
        return NULL;
    }

    RtlZeroMemory(LoggerContext, CONTEXT_SIZE);

    LoggerContext->EndPageMarker =
        (PUCHAR) LoggerContext + 
                 ALIGN_TO_POWER2(sizeof(WMI_LOGGER_CONTEXT), DEFAULT_TRACE_ALIGNMENT);

    LoggerContext->BufferSize     = PAGE_SIZE;
    LoggerContext->MinimumBuffers = (ULONG)KeNumberProcessors + DEFAULT_BUFFERS;
    // 20 additional buffers for MaximumBuffers
    LoggerContext->MaximumBuffers
       = LoggerContext->MinimumBuffers + DEFAULT_BUFFERS + 20;

    KeQuerySystemTime(&LoggerContext->StartTime);

    KeInitializeSemaphore( &LoggerContext->LoggerSemaphore,
                           0,
                           SEMAPHORE_LIMIT  );

    KeInitializeSpinLock(&LoggerContext->BufferSpinLock);

    return LoggerContext;
}


NTSTATUS
WmipAllocateTraceBufferPool(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )

/*++

Routine Description:
    This routine is used to set up the circular trace buffers

Arguments:

    LoggerContext       Context of the logger to own the buffers.

Returned Value:

    STATUS_SUCCESS if the initialization is successful

--*/

{
    ULONG NumberProcessors, SysMax_Buffers, SysMin_Buffers;
    LONG i;
    PWMI_BUFFER_HEADER Buffer;
    ULONG AllocatedBuffers, NumberOfBuffers;
    SIZE_T WmiMaximumPoolInBytes;

    PAGED_CODE();
//
// Allocate the pointers the each buffer here by sharing the same page
//    with LoggerContext context pointer
//
    NumberProcessors = (ULONG) KeNumberProcessors;

    // This does not keep track of the amount already used by other sessions
    if (LoggerContext->LoggerMode & EVENT_TRACE_USE_PAGED_MEMORY) {
        WmiMaximumPoolInBytes = MmSizeOfPagedPoolInBytes;
    }
    else {
        WmiMaximumPoolInBytes = MmMaximumNonPagedPoolInBytes;
    }

    // Compute System limits for min and max

    // This is the absolute maximum that ANYONE can use
    SysMax_Buffers = (ULONG) (WmiMaximumPoolInBytes
                            / TRACE_MAXIMUM_NP_POOL_USAGE
                            / LoggerContext->BufferSize);

    // This is the absolute minimum that ANYONE MUST have
    SysMin_Buffers = NumberProcessors + DEFAULT_BUFFERS;

    // Sanity check to ensure that we have at least the minimum available
    if (SysMin_Buffers > SysMax_Buffers) {
        return STATUS_NO_MEMORY;
    }


    // Cover the case if the caller did not specify any values
    LoggerContext->MaximumBuffers = max(LoggerContext->MaximumBuffers,
                                    NumberProcessors + DEFAULT_BUFFERS +
                                    DEFAULT_MAX_BUFFERS);

    LoggerContext->MinimumBuffers = max(LoggerContext->MinimumBuffers,
                                        SysMin_Buffers);


    // Ensure each parameter is in range of SysMin and SysMax

    LoggerContext->MaximumBuffers = max (LoggerContext->MaximumBuffers, 
                                         SysMin_Buffers);
    LoggerContext->MaximumBuffers = min (LoggerContext->MaximumBuffers, 
                                         SysMax_Buffers);

    LoggerContext->MinimumBuffers = max (LoggerContext->MinimumBuffers, 
                                         SysMin_Buffers);
    LoggerContext->MinimumBuffers = min (LoggerContext->MinimumBuffers, 
                                         SysMax_Buffers);

    // In case the MaximumBuffers and MinimumBuffers got reversed pick the 
    // larger value

    if (LoggerContext->MinimumBuffers > LoggerContext->MaximumBuffers) {
        LoggerContext->MaximumBuffers = LoggerContext->MinimumBuffers;
    }

    // NOTE: We do not return anything if we reset MaximumBuffers or MinimumBuffers
    // provided by the caller.

    LoggerContext->NumberOfBuffers = (LONG) LoggerContext->MinimumBuffers;
    LoggerContext->BuffersAvailable = LoggerContext->NumberOfBuffers;

    //
    // Allocate the buffers now
    //
    //
    // Now determine the initial number of buffers
    //
    NumberOfBuffers = LoggerContext->NumberOfBuffers;
    LoggerContext->NumberOfBuffers = 0;
    LoggerContext->BuffersAvailable = 0;

    AllocatedBuffers = WmipAllocateFreeBuffers(LoggerContext,
                                              NumberOfBuffers);

    if (AllocatedBuffers < NumberOfBuffers) {
        //
        // No enough buffer is allocated.
        //
        WmipFreeTraceBufferPool(LoggerContext);
        return STATUS_NO_MEMORY;
    }

//
// Allocate Per Processor Buffer pointers
//

    LoggerContext->ProcessorBuffers
        = (PWMI_BUFFER_HEADER *)
          WmipExtendBase(LoggerContext,
                         sizeof(PWMI_BUFFER_HEADER)*NumberProcessors);


    if (LoggerContext->ProcessorBuffers == NULL) {
        WmipFreeTraceBufferPool(LoggerContext);
        return STATUS_NO_MEMORY;
    }

    //
    // NOTE: We already know that we have allocated > number of processors
    // buffers
    //
    for (i=0; i<(LONG)NumberProcessors; i++) {
        Buffer = (PWMI_BUFFER_HEADER) WmipGetFreeBuffer(LoggerContext);
        LoggerContext->ProcessorBuffers[i] = Buffer;
        Buffer->ClientContext.ProcessorNumber = (UCHAR)i;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
WmipFreeTraceBufferPool(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    ULONG i;
    PSLIST_ENTRY Entry;
    PWMI_BUFFER_HEADER* ProcessorBuffers;
    PWMI_BUFFER_HEADER Buffer;

    PAGED_CODE();

    TraceDebug((2, "Free Buffer Pool: %2d, Free: %d, InUse: %d, Dirty: %d, Total: %d\n",
                    LoggerContext->LoggerId,
                    LoggerContext->BuffersAvailable,
                    LoggerContext->BuffersInUse,
                    LoggerContext->BuffersDirty,
                    LoggerContext->NumberOfBuffers));

    while (Entry = InterlockedPopEntrySList(&LoggerContext->FreeList)) {

        Buffer = CONTAINING_RECORD(Entry,
                                   WMI_BUFFER_HEADER,
                                   SlistEntry);

        InterlockedDecrement(&LoggerContext->NumberOfBuffers);
        InterlockedDecrement(&LoggerContext->BuffersAvailable);

        TraceDebug((2, "WmipFreeTraceBufferPool (Free): %2d, %p, Free: %d, InUse: %d, Dirty: %d, Total: %d\n",
                        LoggerContext->LoggerId,
                        Buffer,
                        LoggerContext->BuffersAvailable,
                        LoggerContext->BuffersInUse,
                        LoggerContext->BuffersDirty,
                        LoggerContext->NumberOfBuffers));

        WMI_FREE_TRACE_BUFFER(Buffer);
    }

    while (Entry = InterlockedPopEntrySList(&LoggerContext->FlushList)) {

        Buffer = CONTAINING_RECORD(Entry,
                                   WMI_BUFFER_HEADER,
                                   SlistEntry);

        InterlockedDecrement(&LoggerContext->NumberOfBuffers);
        InterlockedDecrement(&LoggerContext->BuffersDirty);

        TraceDebug((2, "WmipFreeTraceBufferPool (Flush): %2d, %p, Free: %d, InUse: %d, Dirty: %d, Total: %d\n",
                        LoggerContext->LoggerId,
                        Buffer,
                        LoggerContext->BuffersAvailable,
                        LoggerContext->BuffersInUse,
                        LoggerContext->BuffersDirty,
                        LoggerContext->NumberOfBuffers));

         WMI_FREE_TRACE_BUFFER(Buffer);
    }

    while (Entry = InterlockedPopEntrySList(&LoggerContext->WaitList)) {

        Buffer = CONTAINING_RECORD(Entry,
                                   WMI_BUFFER_HEADER,
                                   SlistEntry);

        InterlockedDecrement(&LoggerContext->NumberOfBuffers);
        InterlockedDecrement(&LoggerContext->BuffersDirty);

        TraceDebug((2, "WmipFreeTraceBufferPool (Wait): %2d, %p, Free: %d, InUse: %d, Dirty: %d, Total: %d\n",
                        LoggerContext->LoggerId,
                        Buffer,
                        LoggerContext->BuffersAvailable,
                        LoggerContext->BuffersInUse,
                        LoggerContext->BuffersDirty,
                        LoggerContext->NumberOfBuffers));

         WMI_FREE_TRACE_BUFFER(Buffer);
    }

    ProcessorBuffers = LoggerContext->ProcessorBuffers;
    if (ProcessorBuffers != NULL) {
        for (i=0; i<(ULONG)KeNumberProcessors; i++) {
            Buffer = InterlockedExchangePointer(&ProcessorBuffers[i], NULL);
            if (Buffer) {
                InterlockedDecrement(&LoggerContext->NumberOfBuffers);
                InterlockedDecrement(&LoggerContext->BuffersInUse);

                TraceDebug((2, "WmipFreeTraceBufferPool (CPU %2d): %2d, %p, Free: %d, InUse: %d, Dirty: %d, Total: %d\n",
                                i,
                                LoggerContext->LoggerId,
                                Buffer,
                                LoggerContext->BuffersAvailable,
                                LoggerContext->BuffersInUse,
                                LoggerContext->BuffersDirty,
                                LoggerContext->NumberOfBuffers));

                WMI_FREE_TRACE_BUFFER(Buffer);
            }
        }
    }

    ASSERT(LoggerContext->BuffersAvailable == 0);
    ASSERT(LoggerContext->BuffersInUse == 0);
    ASSERT(LoggerContext->BuffersDirty == 0);
    ASSERT(LoggerContext->NumberOfBuffers == 0);

    return STATUS_SUCCESS;
}


NTSTATUS
WmipLookupLoggerIdByName(
    IN PUNICODE_STRING Name,
    OUT PULONG LoggerId
    )
{
    ULONG i;
    PWMI_LOGGER_CONTEXT *ContextTable;

    PAGED_CODE();
    if (Name == NULL) {
        *LoggerId = (ULONG) -1;
        return STATUS_WMI_INSTANCE_NOT_FOUND;
    }
    ContextTable = (PWMI_LOGGER_CONTEXT *) &WmipLoggerContext[0];
    for (i=0; i<MAXLOGGERS; i++) {
        if (ContextTable[i] == NULL ||
            ContextTable[i] == (PWMI_LOGGER_CONTEXT) ContextTable)
            continue;
        if (RtlEqualUnicodeString(&ContextTable[i]->LoggerName, Name, TRUE) ) {
            *LoggerId = i;
            return STATUS_SUCCESS;
        }
    }
    *LoggerId = (ULONG) -1;
    return STATUS_WMI_INSTANCE_NOT_FOUND;
}

NTSTATUS
WmipShutdown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
//
// Shutdown all loggers cleanly. If a logger is in transition, it may
// not be stopped properly.
//
{
    ULONG LoggerCount;
    USHORT i;
    PWMI_LOGGER_CONTEXT LoggerContext;
    WMI_LOGGER_INFORMATION LoggerInfo;

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    PAGED_CODE();

    TraceDebug((2, "WmipShutdown called\n"));
    if (WmipLoggerCount > 0) {
        RtlZeroMemory(&LoggerInfo, sizeof(LoggerInfo));
        LoggerInfo.Wnode.BufferSize = sizeof(LoggerInfo);
        LoggerInfo.Wnode.Flags = WNODE_FLAG_TRACED_GUID;

        LoggerCount = 0;
        for (i=0; i<MAXLOGGERS; i++) {
            LoggerContext = WmipLoggerContext[i];
            if ((LoggerContext != NULL) &&
                (LoggerContext != (PWMI_LOGGER_CONTEXT)&WmipLoggerContext[0])) {
                WmiSetLoggerId(i, &LoggerInfo.Wnode.HistoricalContext);
                LoggerInfo.Wnode.Guid = LoggerContext->InstanceGuid;
                WmiStopTrace(&LoggerInfo);
                if (++LoggerCount == WmipLoggerCount)
                    break;
            }
#if DBG
            else if (LoggerContext
                        == (PWMI_LOGGER_CONTEXT)&WmipLoggerContext[0]) {
                TraceDebug((4, "WmipShutdown: Logger %d in transition\n", i));
            }
#endif
        }
    }
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
}

NTSTATUS
WmipFlushLogger(
    IN OUT PWMI_LOGGER_CONTEXT LoggerContext,
    IN ULONG Wait
    )
{
    LARGE_INTEGER TimeOut = {(ULONG)(-20 * 1000 * 1000 * 10), -1};
    NTSTATUS Status;

    PAGED_CODE();

    KeResetEvent(&LoggerContext->FlushEvent);

    LoggerContext->RequestFlag |= REQUEST_FLAG_FLUSH_BUFFERS;
    Status = WmipNotifyLogger(LoggerContext);
    if (!NT_SUCCESS(Status))
        return Status;
    if (Wait) {
        Status = KeWaitForSingleObject(
                    &LoggerContext->FlushEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    & TimeOut
                    );
#if DBG
        if (Status == STATUS_TIMEOUT) {
            TraceDebug((1, "WmiFlushLogger: Wait status=%X\n",Status));
        }
#endif 
        KeResetEvent(&LoggerContext->FlushEvent);
        Status = LoggerContext->LoggerStatus;
    }
    return Status;
}

NTSTATUS
FASTCALL
WmipNotifyLogger(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
// Routine can be called at DISPATCH_LEVEL
{
    LONG SemCount = KeReadStateSemaphore(&LoggerContext->LoggerSemaphore);
    if (SemCount >= SEMAPHORE_LIMIT/2) {
        return STATUS_SEMAPHORE_LIMIT_EXCEEDED;
    }
    {
        KeReleaseSemaphore(&LoggerContext->LoggerSemaphore, 0, 1, FALSE);
        return STATUS_SUCCESS;
    }
}


NTSTATUS
WmipNtDllLoggerInfo(
    IN OUT PWMINTDLLLOGGERINFO Buffer
    )
{

    NTSTATUS            Status = STATUS_SUCCESS;

    KPROCESSOR_MODE     RequestorMode;
    PBGUIDENTRY         GuidEntry;    
    ULONG               SizeNeeded;
    GUID                Guid;
    ACCESS_MASK         DesiredAccess = TRACELOG_GUID_ENABLE;

    PAGED_CODE();

    RequestorMode = KeGetPreviousMode();

    SizeNeeded = sizeof(WMI_LOGGER_INFORMATION);

    __try {

        if (RequestorMode != KernelMode){
            ProbeForRead(Buffer->LoggerInfo, SizeNeeded, sizeof(ULONGLONG));
        }

        RtlCopyMemory(&Guid, &Buffer->LoggerInfo->Wnode.Guid, sizeof(GUID));

        if(!IsEqualGUID(&Guid, &NtdllTraceGuid)){

            return STATUS_UNSUCCESSFUL;

        }

        SizeNeeded = Buffer->LoggerInfo->Wnode.BufferSize;

    }  __except(EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    WmipEnterTLCritSection();
    WmipEnterSMCritSection();

    GuidEntry = WmipFindGEByGuid(&Guid, FALSE);

    if(Buffer->IsGet){

        if( GuidEntry ){

            if(GuidEntry->LoggerInfo){

                SizeNeeded = GuidEntry->LoggerInfo->Wnode.BufferSize;

                __try {

                    if (RequestorMode != KernelMode){
                        ProbeForWrite(Buffer->LoggerInfo, SizeNeeded, sizeof(ULONGLONG));
                    }

                    RtlCopyMemory(Buffer->LoggerInfo,GuidEntry->LoggerInfo,SizeNeeded);

                } __except(EXCEPTION_EXECUTE_HANDLER) {

                    WmipUnreferenceGE(GuidEntry);
                    WmipLeaveSMCritSection();
                    WmipLeaveTLCritSection();
                    return GetExceptionCode();
                } 
            }

            WmipUnreferenceGE(GuidEntry);

        }  else {

            Status = STATUS_UNSUCCESSFUL;
        }

    } else {

        //
        // This must be a control operation.
        // Check to see if heap/critsec controller has access 
        // to proper Guids.
        //
        Status = WmipCheckGuidAccess(
                    &Guid,
                    DesiredAccess,
                    EtwpDefaultTraceSecurityDescriptor
                    );
        if (!NT_SUCCESS(Status)) {
            if( GuidEntry ){
                WmipUnreferenceGE(GuidEntry);
            }
            WmipLeaveSMCritSection();
            WmipLeaveTLCritSection();
            return Status;
        }

        if(SizeNeeded){

            if(GuidEntry == NULL){

                GuidEntry = WmipAllocGuidEntry();

                if (GuidEntry){

                    //
                    // Initialize the guid entry and keep the ref count
                    // from creation. When tracelog enables we take a ref
                    // count and when it disables we release it
                    //
                    GuidEntry->Guid = Guid;
                    GuidEntry->EventRefCount = 1;
                    GuidEntry->Flags |= GE_NOTIFICATION_TRACE_FLAG;
                    InsertHeadList(WmipGEHeadPtr, &GuidEntry->MainGEList);

                    //
                    // Take Extra Refcount so that we release it at stoplogger call
                    //

                    WmipReferenceGE(GuidEntry); 

                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            if(NT_SUCCESS(Status)){

                if(GuidEntry->LoggerInfo) {
                    Status = STATUS_UNSUCCESSFUL;
                } else {

                    GuidEntry->LoggerInfo = WmipAlloc(SizeNeeded);

                    if(GuidEntry->LoggerInfo){

                        WMITRACEENABLEDISABLEINFO TraceEnableInfo;
                        PTRACE_ENABLE_CONTEXT pContext;

                        __try {

                            pContext = (PTRACE_ENABLE_CONTEXT)&Buffer->LoggerInfo->Wnode.HistoricalContext;

                            pContext->InternalFlag |= EVENT_TRACE_INTERNAL_FLAG_PRIVATE;
                            pContext->LoggerId = 1;

                            RtlCopyMemory(GuidEntry->LoggerInfo,Buffer->LoggerInfo,SizeNeeded);

                        } __except(EXCEPTION_EXECUTE_HANDLER) {

                            WmipUnreferenceGE(GuidEntry);
                            WmipLeaveSMCritSection();
                            WmipLeaveTLCritSection();
                            return GetExceptionCode();
                        }

                        TraceEnableInfo.Guid = GuidEntry->Guid;
                        TraceEnableInfo.Enable = TRUE;
                        TraceEnableInfo.LoggerContext = 0;
                        Status = WmipEnableDisableTrace(IOCTL_WMI_ENABLE_DISABLE_TRACELOG, &TraceEnableInfo);

                    } else {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                WmipUnreferenceGE(GuidEntry);
            }
        } else {

            //
            // This is stop logger call.
            //

            if(GuidEntry){

                WMITRACEENABLEDISABLEINFO TraceEnableInfo;

                if(GuidEntry->LoggerInfo) {

                    __try{

                        if (RequestorMode != KernelMode){
                            ProbeForWrite(Buffer->LoggerInfo, sizeof(WMI_LOGGER_INFORMATION), sizeof(ULONGLONG));
                        }

                        Buffer->LoggerInfo->BufferSize     = GuidEntry->LoggerInfo->BufferSize;
                        Buffer->LoggerInfo->MinimumBuffers = GuidEntry->LoggerInfo->MinimumBuffers;
                        Buffer->LoggerInfo->MaximumBuffers = GuidEntry->LoggerInfo->MaximumBuffers;

                        WmipFree(GuidEntry->LoggerInfo);
                        GuidEntry->LoggerInfo = NULL;

                    } __except(EXCEPTION_EXECUTE_HANDLER) {

                            WmipUnreferenceGE(GuidEntry);
                            WmipLeaveSMCritSection();
                            WmipLeaveTLCritSection();
                            return GetExceptionCode();
                    }
                }

                TraceEnableInfo.Guid = GuidEntry->Guid;
                TraceEnableInfo.Enable = FALSE;
                TraceEnableInfo.LoggerContext = 0;

                //
                //  The Extra Refcount taken at logger start is released by calling
                //  Disable trace. 
                //
    
                Status = WmipEnableDisableTrace(IOCTL_WMI_ENABLE_DISABLE_TRACELOG, &TraceEnableInfo);
                WmipUnreferenceGE(GuidEntry); 
            } 
        }
    }
    
    WmipLeaveSMCritSection();
    WmipLeaveTLCritSection();

    return Status;
}

VOID
WmipValidateClockType(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This routine is called to validate the requested clock type in the
    LoggerInfo. If the requested type can not be handled, we will override
    to a type that this system will support. 

    This routine assumes that LoggerInfo pointer is a valid one. 

Arguments:

    LoggerInfo - a pointer to the structure for the logger's control
                 and status information

Returned Value:

    Status of STATUS_SUCCESS 

--*/
{
    UNREFERENCED_PARAMETER (LoggerInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\smbios.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    smbios.c.c

Abstract:

    SMBIOS interface for WMI

--*/

#if defined(_AMD64_) || defined(i386)

#include "wmikmp.h"
#include "arc.h"
#include "smbios.h"

void WmipGetSMBiosFromLoaderBlock(
    PVOID LoaderBlockPtr
    );

NTSTATUS WmipSMBiosDataRegQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

BOOLEAN WmipIsSMBiosKey(
    HANDLE ParentKeyHandle,
    PWCHAR KeyName,
    PUCHAR *SMBiosTableVirtualAddress,
    PULONG SMBiosTableLength
    );

NTSTATUS WmipSMBiosIdentifierRegQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

BOOLEAN WmipFindSMBiosEPSHeader(
    PUCHAR SMBiosVirtualAddress,
    ULONG BiosSize,
    PSMBIOS_EPS_HEADER EPSHeader
    );

NTSTATUS WmipFindSMBiosStructure(
    IN UCHAR Type,
    OUT PVOID *StructPtr,
    OUT PVOID *MapPtr,
    OUT PULONG MapSize
    );

NTSTATUS WmipFindSysIdTable(
    PPHYSICAL_ADDRESS SysidTablePhysicalAddress,
    PUCHAR SysIdBiosRevision,
    PULONG NumberEntries
    );

NTSTATUS WmipParseSysIdTable(
    PHYSICAL_ADDRESS PhysicalAddress,
    ULONG NumberEntries,
    PSYSID_UUID SysIdUuid,
    ULONG *SysIdUuidCount,
    PSYSID_1394 SysId1394,
    ULONG *SysId1394Count
    );

NTSTATUS WmipGetSysIds(
    PSYSID_UUID *SysIdUuid,
    ULONG *SysIdUuidCount,
    PSYSID_1394 *SysId1394,
    ULONG *SysId1394Count
    );

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
//
// These hold pointers to the SMBIOS data. If SMBIOS data is in the table
// format then WmipSMBiosTablePhysicalAddress holds the physical address of
// the table. If the SMBIOS was gathered at boot time by NTDETECT then
// WmipSMBiosTableVirtualAddress holds a pointer to a paged pool buffer that
// contains the SMBIOS data. In both cases WmipSMBiosTableLength holds the
// actual length of the SMBIOS table. If both the physical and virtual
// addresses are 0 then SMBIOS data is not available.
PHYSICAL_ADDRESS WmipSMBiosTablePhysicalAddress = {0};
PUCHAR WmipSMBiosTableVirtualAddress = NULL;
ULONG WmipSMBiosTableLength = 0;
SMBIOSVERSIONINFO WmipSMBiosVersionInfo = {0};
BOOLEAN WmipSMBiosChecked = FALSE;

//
// Have we tried to get SYSID yet and if so what was the ultimate status
BOOLEAN WmipSysIdRead;
NTSTATUS WmipSysIdStatus;

//
// Count and arrays of UUIDs and 1394 ids
PSYSID_UUID WmipSysIdUuid;
ULONG WmipSysIdUuidCount;

PSYSID_1394 WmipSysId1394;
ULONG WmipSysId1394Count;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,WmipGetSMBiosFromLoaderBlock)

#pragma alloc_text(PAGE,WmipFindSMBiosEPSHeader)
#pragma alloc_text(PAGE,WmipFindSMBiosTable)
#pragma alloc_text(PAGE,WmipFindSMBiosStructure)
#pragma alloc_text(PAGE,WmipFindSysIdTable)
#pragma alloc_text(PAGE,WmipParseSysIdTable)
#pragma alloc_text(PAGE,WmipGetSysIds)
#pragma alloc_text(PAGE,WmipGetSMBiosTableData)
#pragma alloc_text(PAGE,WmipGetSMBiosEventlog)
#pragma alloc_text(PAGE,WmipDockUndockEventCallback)

#pragma alloc_text(PAGE,WmipSMBiosDataRegQueryRoutine)
#pragma alloc_text(PAGE,WmipSMBiosIdentifierRegQueryRoutine)
#pragma alloc_text(PAGE,WmipIsSMBiosKey)


#endif


BOOLEAN WmipFindSMBiosEPSHeader(
    PUCHAR SMBiosVirtualAddress,
    ULONG BiosSize,
    PSMBIOS_EPS_HEADER EPSHeader
    )
/*++

Routine Description:

    Search for the SMBIOS 2.1 EPS structure and copy it.

Arguments:

    SMBiosVirtualAddress is the beginning virtual address to start searching
        for the SMBIOS 2.1 EPS anchor string.

    BiosSize is the number of bytes to search for the anchor string

    EPSHeader is the memory into which the EPS header is copied
Return Value:

    Pointer to SMBIOS 2.1 EPS or NULL if EPS not found

--*/
{
    PUCHAR SearchEnd;
    UCHAR CheckSum;
    PSMBIOS_EPS_HEADER SMBiosEPSHeader;
    PDMIBIOS_EPS_HEADER DMIBiosEPSHeader;
    ULONG i;
    ULONG CheckLength;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (BiosSize);

    RtlZeroMemory(EPSHeader, sizeof(SMBIOS_EPS_HEADER));
    
    //
    // Scan the bios for the two anchor strings that that signal the SMBIOS
    // table.
    SearchEnd = SMBiosVirtualAddress + SMBIOS_EPS_SEARCH_SIZE -
                                             2 * SMBIOS_EPS_SEARCH_INCREMENT;

    while (SMBiosVirtualAddress < SearchEnd)
    {
       SMBiosEPSHeader = (PSMBIOS_EPS_HEADER)SMBiosVirtualAddress;
       DMIBiosEPSHeader = (PDMIBIOS_EPS_HEADER)SMBiosVirtualAddress;

       //
       // First check for _DMI_ anchor string
       if ((*((PULONG)DMIBiosEPSHeader->Signature2) == DMI_EPS_SIGNATURE) &&
           (DMIBiosEPSHeader->Signature2[4] == '_'))
       {
           WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Found possible DMIBIOS EPS Header at %x\n", SMBiosEPSHeader));
           CheckLength = sizeof(DMIBIOS_EPS_HEADER);
       }

       //
       // Then check for full _SM_ anchor string
       else if ((*((PULONG)SMBiosEPSHeader->Signature) == SMBIOS_EPS_SIGNATURE) &&
                (SMBiosEPSHeader->Length >= sizeof(SMBIOS_EPS_HEADER)) &&
                (*((PULONG)SMBiosEPSHeader->Signature2) == DMI_EPS_SIGNATURE) &&
                (SMBiosEPSHeader->Signature2[4] == '_' ))
       {
           WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Found possible SMBIOS EPS Header at %p\n", SMBiosEPSHeader));
           CheckLength = SMBiosEPSHeader->Length;
       } else {
           //
           // Did not find anchor string, go search next paragraph
           SMBiosVirtualAddress += SMBIOS_EPS_SEARCH_INCREMENT;
           continue;
       }

       //
       // Verify anchor string with checksum
       CheckSum = 0;
       for (i = 0; i < CheckLength ; i++)
       {
           CheckSum = (UCHAR)(CheckSum + SMBiosVirtualAddress[i]);
       }

       if (CheckSum == 0)
       {
           WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Found SMBIOS EPS Header at %p\n", SMBiosEPSHeader));
           if (CheckLength == sizeof(DMIBIOS_EPS_HEADER))
           {
               //
               // We only had got a DMI header so copy that
               //
               RtlCopyMemory(&EPSHeader->Signature2[0],
                             DMIBiosEPSHeader,
                             sizeof(DMIBIOS_EPS_HEADER));
           } else {
               //
               // We got the full SMBIOS header so copy that
               //
               RtlCopyMemory(EPSHeader,
                             SMBiosEPSHeader,
                             sizeof(SMBIOS_EPS_HEADER));
           }
           return(TRUE);
       }
       SMBiosVirtualAddress += SMBIOS_EPS_SEARCH_INCREMENT;

    }

    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SMBIOS EPS Header not found\n"));
    return(FALSE);
}

//
// On X86 we look at the hardware device description keys to find the
// one that contains the SMBIOS data. The key is created by NTDETECT in
// the case that the machine only supports the 2.0 calling mechanism
//

//
// For x86 and ia64 the key is Someplace like
// HKLM\Hardware\System\MultiFunctionAdapter\<some number>
//
NTSTATUS WmipSMBiosIdentifierRegQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    Registry query values callback routine for reading SMBIOS data from
    registry.

Arguments:

    ValueName - the name of the value

    ValueType - the type of the value

    ValueData - the data in the value (unicode string data)

    ValueLength - the number of bytes in the value data

    Context - Not used

    EntryContext - Pointer to PUCHAR to store a pointer to
        store the SMBIOS data read from the registry value. If this is NULL
        then the caller is not interested in the SMBIOS data

Return Value:

    NT Status code -
        STATUS_SUCCESS - Identifier is valid for SMBIOS key
        STATUS_UNSUCCESSFUL - Identifier is not valid for SMBIOS key

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (ValueName);
    UNREFERENCED_PARAMETER (ValueLength);
    UNREFERENCED_PARAMETER (Context);
    UNREFERENCED_PARAMETER (EntryContext);

    Status =  ((ValueType == REG_SZ) &&
               (ValueData != NULL) &&
               (wcscmp(ValueData, SMBIOSIDENTIFIERVALUEDATA) == 0)) ?
                       STATUS_SUCCESS :
                       STATUS_UNSUCCESSFUL;

    return(Status);
}

NTSTATUS WmipSMBiosDataRegQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    Registry query values callback routine for reading SMBIOS data from
    registry.

Arguments:

    ValueName - the name of the value

    ValueType - the type of the value

    ValueData - the data in the value (unicode string data)

    ValueLength - the number of bytes in the value data

    Context - Not used

    EntryContext - Pointer to PUCHAR to store a pointer to
        store the SMBIOS data read from the registry value. If this is NULL
        then the caller is not interested in the SMBIOS data

Return Value:

    NT Status code -
        STATUS_SUCCESS - SMBIOS data is present in the value
        STATUS_INSUFFICIENT_RESOURCES - Not enough memory to keep SMBIOS data
        STATUS_UNSUCCESSFUL - SMBios data is not present in the value

--*/
{
    NTSTATUS Status;
    PCM_PARTIAL_RESOURCE_LIST PartialResourceList;
    PUCHAR Buffer;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptor;
    ULONG BufferSize;
    PREGQUERYBUFFERXFER RegQueryBufferXfer;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (ValueName);
    UNREFERENCED_PARAMETER (ValueLength);
    UNREFERENCED_PARAMETER (Context);

    WmipAssert(EntryContext != NULL);

    if ((ValueType == REG_FULL_RESOURCE_DESCRIPTOR) &&
        (ValueData != NULL))
    {
        //
        // On x86 get the actual SMBIOS data out of the registry and
        // place it into a buffer
        //
        RegQueryBufferXfer = (PREGQUERYBUFFERXFER)EntryContext;

        PartialResourceList = &(((PCM_FULL_RESOURCE_DESCRIPTOR)ValueData)->PartialResourceList);
        if (PartialResourceList->Count > 1)
        {
            //
            // Second partial resource descriptor contains SMBIOS data. There
            // should ALWAYS be a second partial resource descriptor and it
            // may have 0 bytes in the case that SMBIOS data was not collected
            // by NTDETECT.

            PartialDescriptor = &PartialResourceList->PartialDescriptors[0];
            Buffer = (PUCHAR)PartialDescriptor +
                             sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) +
                             PartialDescriptor->u.DeviceSpecificData.DataSize;
            PartialDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)Buffer;
            BufferSize = PartialDescriptor->u.DeviceSpecificData.DataSize;
            RegQueryBufferXfer->BufferSize = BufferSize;
            Status = STATUS_SUCCESS;
            if (BufferSize > 0)
            {
                RegQueryBufferXfer->Buffer = (PUCHAR)ExAllocatePoolWithTag(
                                                                  PagedPool,
                                                                  BufferSize,
                                                                  WMIPOOLTAG);
                if (RegQueryBufferXfer->Buffer != NULL)
                {
                    Buffer += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
                    RtlCopyMemory(RegQueryBufferXfer->Buffer,
                                  Buffer,
                                  BufferSize);
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        } else {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Old NTDETECT.COM - No SMBIOS partial resource descriptor\n"));
            Status = STATUS_SUCCESS;
            RegQueryBufferXfer->BufferSize = 0;
        }
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }
    return(Status);
}

BOOLEAN WmipIsSMBiosKey(
    HANDLE ParentKeyHandle,
    PWCHAR KeyName,
    PUCHAR *SMBiosTableVirtualAddress,
    PULONG SMBiosTableLength
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING BaseKeyName;
    HANDLE KeyHandle;
    RTL_QUERY_REGISTRY_TABLE QueryTable[3];
    REGQUERYBUFFERXFER RegQueryBufferXfer = {0, NULL};

    PAGED_CODE();

    RtlInitUnicodeString(&BaseKeyName,
                         KeyName);

    InitializeObjectAttributes(&ObjectAttributes,
                               &BaseKeyName,
                               OBJ_CASE_INSENSITIVE,
                               ParentKeyHandle,
                               NULL);

    Status = ZwOpenKey(&KeyHandle,
                       KEY_READ,
                       &ObjectAttributes);
    if (NT_SUCCESS(Status))
    {
        RtlZeroMemory(QueryTable, sizeof(QueryTable));
        QueryTable[0].Name = SMBIOSIDENTIFIERVALUENAME;
        QueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
        QueryTable[0].DefaultType = REG_SZ;
        QueryTable[0].QueryRoutine = WmipSMBiosIdentifierRegQueryRoutine;

        QueryTable[1].Name = SMBIOSDATAVALUENAME;
        QueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED;
        QueryTable[1].EntryContext = &RegQueryBufferXfer;
        QueryTable[1].DefaultType = REG_FULL_RESOURCE_DESCRIPTOR;
        QueryTable[1].QueryRoutine = WmipSMBiosDataRegQueryRoutine;

        Status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE | RTL_REGISTRY_ABSOLUTE,
                                        (PWCHAR)KeyHandle,
                                        QueryTable,
                                        NULL,
                                        NULL);
        if (NT_SUCCESS(Status))
        {
            *SMBiosTableVirtualAddress = RegQueryBufferXfer.Buffer;
            *SMBiosTableLength = RegQueryBufferXfer.BufferSize;
        }

        ZwClose(KeyHandle);
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: H/D/S/MultifunctionAdapter subkey open error %x\n",
                 Status));
    }

    return(NT_SUCCESS(Status) ? TRUE : FALSE);
}

BOOLEAN WmipFindSMBiosTable(
    PPHYSICAL_ADDRESS SMBiosTablePhysicalAddress,
    PUCHAR *SMBiosTableVirtualAddress,
    PULONG SMBiosTableLength,
    PSMBIOSVERSIONINFO SMBiosVersionInfo
    )
/*++

Routine Description:

    Determines if the SMBIOS data is available

Arguments:

    SMBiosTablePhysicalAddress points to a variable to return the physical
        address of the SMBIOS 2.1 table. If table is not available then
        it returns with 0.

    SMBiosTableVirtualAddress points to a variable to return the virtual
        address of the SMBIOS 2.0 table as collected by NTDETECT. If the
        SMBIOS 2.0 data was not collected by NTDETECT it returns with 0.

    SMBiosTableLength points to a variable to return the length of the
        SMBIOS table data.

    SMBiosVersionInfo returns with the version information for SMBIOS

Return Value:

    TRUE if SMBIOS data is available, else FALSE

--*/
{
    PHYSICAL_ADDRESS BiosPhysicalAddress;
    PUCHAR BiosVirtualAddress;
    PDMIBIOS_EPS_HEADER DMIBiosEPSHeader;

    NTSTATUS Status;
    UNICODE_STRING BaseKeyName;
    HANDLE KeyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG KeyIndex;
    ULONG KeyInformationLength;
    
    union {
        KEY_BASIC_INFORMATION Info;
        UCHAR Buffer[sizeof(KEY_BASIC_INFORMATION) + (MAXSMBIOSKEYNAMESIZE * sizeof(WCHAR))];
    } KeyBasic;

    SMBIOS_EPS_HEADER SMBiosEPSHeader;
    BOOLEAN HaveEPSHeader = FALSE;
    BOOLEAN SearchForHeader = TRUE;

    PAGED_CODE();

    SMBiosTablePhysicalAddress->QuadPart = 0;
    *SMBiosTableVirtualAddress = NULL;
    *SMBiosTableLength = 0;

    //
    // First check registry to see if we captured SMBIOS 2.0 data in
    // NTDETECT. Search the keys under
    // MultiFunctionAdapter for the one
    // with the "PnP Bios" (x86)
    //
    RtlInitUnicodeString(&BaseKeyName,
                         SMBIOSPARENTKEYNAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &BaseKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&KeyHandle,
                       KEY_READ,
                       &ObjectAttributes);

    if (NT_SUCCESS(Status))
    {

        KeyIndex = 0;
        
        while (NT_SUCCESS(Status))
        {

            Status = ZwEnumerateKey(KeyHandle,
                                    KeyIndex++,
                                    KeyBasicInformation,
                                    &KeyBasic.Info,
                                    sizeof(KeyBasic.Buffer) - sizeof(WCHAR),
                                    &KeyInformationLength);
            if (NT_SUCCESS(Status))
            {
                KeyBasic.Info.Name[KeyBasic.Info.NameLength / sizeof(WCHAR)] = UNICODE_NULL;
                if (WmipIsSMBiosKey(KeyHandle,
                                    KeyBasic.Info.Name,
                                    SMBiosTableVirtualAddress,
                                    SMBiosTableLength))
                {
                    if (*SMBiosTableLength != 0)
                    {
                        SMBiosVersionInfo->Used20CallingMethod = TRUE;
                        SearchForHeader = FALSE;
                    }
                    break;
                }
            } else {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Status %x enum H\\D\\S\\MultiFunctionAdapter key, index %d\n",
                 Status, KeyIndex-1));
            }
        }
        ZwClose(KeyHandle);
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Status %x opening H\\D\\S\\MultiFunctionAdapter key\n",
                 Status));
    }
    
    if (SearchForHeader)
    {
        //
        // If not in registry then check for EPS in the BIOS
        BiosPhysicalAddress.QuadPart = SMBIOS_EPS_SEARCH_START;
        BiosVirtualAddress = MmMapIoSpace(BiosPhysicalAddress,
                                          SMBIOS_EPS_SEARCH_SIZE,
                                          MmNonCached);

        if (BiosVirtualAddress != NULL)
        {
            HaveEPSHeader = WmipFindSMBiosEPSHeader(BiosVirtualAddress,
                                                    SMBIOS_EPS_SEARCH_SIZE,
                                                    &SMBiosEPSHeader);
            MmUnmapIoSpace(BiosVirtualAddress, SMBIOS_EPS_SEARCH_SIZE);
        }
    } else {
         WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SMBIOS data recovered from loader\n"));
    }
        
    if (HaveEPSHeader)
    {
        //
        // We found the EPS so just extract the physical
        // address of the table
        //
        DMIBiosEPSHeader = (PDMIBIOS_EPS_HEADER)&SMBiosEPSHeader.Signature2[0];

        //
        // Ignore tables with invalid length sizes
        //
        if (DMIBiosEPSHeader->StructureTableLength)
        {
            SMBiosVersionInfo->Used20CallingMethod = FALSE;

            SMBiosTablePhysicalAddress->HighPart = 0;
            SMBiosTablePhysicalAddress->LowPart = DMIBiosEPSHeader->StructureTableAddress;

            *SMBiosTableLength = DMIBiosEPSHeader->StructureTableLength;

            SMBiosVersionInfo->SMBiosMajorVersion = SMBiosEPSHeader.MajorVersion;
            SMBiosVersionInfo->SMBiosMinorVersion = SMBiosEPSHeader.MinorVersion;

            SMBiosVersionInfo->DMIBiosRevision = DMIBiosEPSHeader->Revision;
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SMBIOS 2.1 data at (%x%x) size %x \n",
                          SMBiosTablePhysicalAddress->HighPart,
                          SMBiosTablePhysicalAddress->LowPart,
                          *SMBiosTableLength));
        }
    }

    return(*SMBiosTableLength > 0 ? TRUE : FALSE);
}

NTSTATUS WmipGetSMBiosTableData(
    OUT PUCHAR Buffer,
    IN OUT PULONG BufferSize,
    OUT PSMBIOSVERSIONINFO SMBiosVersionInfo
    )
/*++

Routine Description:

    Registry query values callback routine for reading SMBIOS data from
    registry.

Arguments:

    Buffer is a pointer to a buffer in which to write the SMBIOS data

    *BufferSize has the maximum number of bytes available to write into
        Buffer. On return it has the actual size of the SMBIOS data.

Return Value:

    NT Status code -
        STATUS_SUCCESS - Buffer filled with SMBIOS data
        STATUS_BUFFER_TOO_SMALL - Buffer not filled with SMBIOS data,
                                  *BufferSize returns with buffer size neeeded

--*/
{
    NTSTATUS status;
    PUCHAR SMBiosDataVirtualAddress;

    PAGED_CODE();

    WmipEnterSMCritSection();
    if (! WmipSMBiosChecked)
    {
        //
        // See if there is any SMBIOS information and if so register
        WmipFindSMBiosTable(&WmipSMBiosTablePhysicalAddress,
                            &WmipSMBiosTableVirtualAddress,
                            &WmipSMBiosTableLength,
                            &WmipSMBiosVersionInfo);
        WmipSMBiosChecked = TRUE;
    }
    WmipLeaveSMCritSection();

    if (SMBiosVersionInfo != NULL)
    {
        *SMBiosVersionInfo = WmipSMBiosVersionInfo;
    }
    if (*BufferSize >= WmipSMBiosTableLength)
    {
        if (WmipSMBiosTableLength == 0)
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
        } 
        else if (WmipSMBiosTablePhysicalAddress.QuadPart != 0)
        {
            //
            // 2.1 table format - map in table and copy
            SMBiosDataVirtualAddress = MmMapIoSpace(WmipSMBiosTablePhysicalAddress,
                                                    WmipSMBiosTableLength,
                                                    MmNonCached);
            if (SMBiosDataVirtualAddress != NULL)
            {
                RtlCopyMemory(Buffer,
                          SMBiosDataVirtualAddress,
                          WmipSMBiosTableLength);

                MmUnmapIoSpace(SMBiosDataVirtualAddress,
                               WmipSMBiosTableLength);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else if (WmipSMBiosTableVirtualAddress != NULL) {
            RtlCopyMemory(Buffer,
                          WmipSMBiosTableVirtualAddress,
                          WmipSMBiosTableLength);
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
    } else {
        status = STATUS_BUFFER_TOO_SMALL;
    }

    *BufferSize = WmipSMBiosTableLength;

    return(status);
}


#define WmipUnmapSMBiosStructure(Address, Size) \
    if ((Address) != NULL) MmUnmapIoSpace((Address), (Size));

NTSTATUS WmipFindSMBiosStructure(
    IN UCHAR Type,
    OUT PVOID *StructPtr,
    OUT PVOID *MapPtr,
    OUT PULONG MapSize
    )
/*++

Routine Description:

    Find a specific SMBIOS structure in the SMBIOS information.
    WmipUnmapSNVuisStructure should be called if this function returns
    successfully.

Arguments:

    Type is structure type to find

    *StructPtr returns with pointer to beginning of structure

    *MapPtr returns with pointer to address SMBIOS data was mapped.

    *MapSize returns with size mapped
Return Value:

    STATUS

--*/
{
    NTSTATUS Status;
    BOOLEAN Found;
    PUCHAR Ptr;
    PUCHAR PtrEnd;
    PSMBIOS_STRUCT_HEADER StructHeader;

    PAGED_CODE();

    //
    // Make sure SMBIOS table has been obtained. Note we already hold
    // the critical section
    if (! WmipSMBiosChecked)
    {
        //
        // See if there is any SMBIOS information and if so register
        Found = WmipFindSMBiosTable(&WmipSMBiosTablePhysicalAddress,
                            &WmipSMBiosTableVirtualAddress,
                            &WmipSMBiosTableLength,
                            &WmipSMBiosVersionInfo);
        WmipSMBiosChecked = TRUE;
    } else {
        Found = (WmipSMBiosTableLength > 0  ? TRUE : FALSE);
    }

    if (Found)
    {
        Status = STATUS_SUCCESS;
        if (WmipSMBiosTablePhysicalAddress.QuadPart != 0)
        {
            //
            // SMBIOS is available in physical memory
            *MapPtr = MmMapIoSpace(WmipSMBiosTablePhysicalAddress,
                                   WmipSMBiosTableLength,
                                   MmCached);
            if (*MapPtr != NULL)
            {
                *MapSize = WmipSMBiosTableLength;
                Ptr = *MapPtr;
            } else {
                //
                // Lets hope this is a temporary problem
                Status = STATUS_INSUFFICIENT_RESOURCES;
                Ptr = NULL;
            }
        } else if (WmipSMBiosTableVirtualAddress != NULL) {
            *MapPtr = NULL;
            Ptr = WmipSMBiosTableVirtualAddress;
        } else {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SMBIOS table was found, but is not in physical or virtual memory\n"));
            WmipAssert(FALSE);
            Status = STATUS_UNSUCCESSFUL;
            Ptr = NULL;
        }

        if (NT_SUCCESS(Status))
        {
            //
            // Now scan the SMBIOS table to find our structure
            *StructPtr = NULL;
            PtrEnd = (PVOID)((PUCHAR)Ptr + WmipSMBiosTableLength);
            Status = STATUS_UNSUCCESSFUL;
            StructHeader = NULL;
            try
            {
                while (Ptr < PtrEnd)
                {
                    StructHeader = (PSMBIOS_STRUCT_HEADER)Ptr;

                    if (StructHeader->Type == Type)
                    {
                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SMBIOS struct for type %d found at %p\n",
                             Type, Ptr));
                        *StructPtr = Ptr;
                        Status = STATUS_SUCCESS;
                        break;
                    }

                    Ptr+= StructHeader->Length;
                    while ( (*((USHORT UNALIGNED *)Ptr) != 0)  &&
                            (Ptr < PtrEnd) )
                    {
                        Ptr++;
                    }
                    Ptr += 2;
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Invalid SMBIOS data table %p at %p\n",
                         *MapPtr, StructHeader));
                WmipAssert(FALSE);
            }

            if (! NT_SUCCESS(Status) )
            {
                WmipUnmapSMBiosStructure(*MapPtr, *MapSize);
            }
        }
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }
    return(Status);
}

NTSTATUS WmipFindSysIdTable(
    PPHYSICAL_ADDRESS SysidTablePhysicalAddress,
    PUCHAR SysIdBiosRevision,
    PULONG NumberEntries
    )
/*++

Routine Description:

    Scan the system bios to search for the SYSID table

Arguments:

    *SysidTablePhysicalAddress returns with the physical address of the
        sysid table

    *SysIdBiosRevision returns with the bios revision of the sysid table

    *NumberEntries returns the number of SYSID entries in the table

Return Value:

    STATUS

--*/
{
    UCHAR Checksum;
    PUCHAR p;
    PSYSID_EPS_HEADER SysIdEps, SearchEnd;
    PHYSICAL_ADDRESS BiosPhysicalAddress;
    PUCHAR BiosVirtualAddress;
    ULONG i;
    NTSTATUS Status;

    PAGED_CODE();

    BiosPhysicalAddress.QuadPart = SYSID_EPS_SEARCH_START;
    BiosVirtualAddress = MmMapIoSpace(BiosPhysicalAddress,
                                      SYSID_EPS_SEARCH_SIZE,
                                      MmCached);

    SearchEnd = (PSYSID_EPS_HEADER)(BiosVirtualAddress + SYSID_EPS_SEARCH_SIZE);
    SysIdEps = (PSYSID_EPS_HEADER)BiosVirtualAddress;

    if (BiosVirtualAddress != NULL)
    {
        try
        {
            while (SysIdEps < SearchEnd)
            {
                if (((*(PULONG)SysIdEps->Signature) == SYSID_EPS_SIGNATURE) &&
                     (*(PUSHORT)(&SysIdEps->Signature[4]) == SYSID_EPS_SIGNATURE2) &&
                     (SysIdEps->Signature[6] == '_') )
                {
                    //
                    // This may be the SYSID table, check the checksum
                    Checksum = 0;
                    p = (PUCHAR)SysIdEps;
                    for (i = 0; i < sizeof(SYSID_EPS_HEADER); i++)
                    {
                        Checksum = (UCHAR)(Checksum + p[i]);
                    }

                    if (Checksum == 0)
                    {
                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SYSID EPS found at %p\n",
                                     SysIdEps));
                        break;
                    } else {
                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Invalis SYSID EPS checksum at %p\n",
                                  SysIdEps));
                    }
                }

                SysIdEps = (PSYSID_EPS_HEADER)( ((PUCHAR)SysIdEps) +
                                     SYSID_EPS_SEARCH_INCREMENT);
            }

            if (SysIdEps != SearchEnd)
            {
                SysidTablePhysicalAddress->HighPart = 0;
                SysidTablePhysicalAddress->LowPart = SysIdEps->SysIdTableAddress;
                *SysIdBiosRevision = SysIdEps->BiosRev;
                *NumberEntries = SysIdEps->SysIdCount;
                Status = STATUS_SUCCESS;
            } else {
                //
                // Not finding the SYSID EPS is a terminal error
                Status = STATUS_UNSUCCESSFUL;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Invalid SYSID EPS Table at %p\n", SysIdEps));
            Status = STATUS_UNSUCCESSFUL;
        }

        MmUnmapIoSpace(BiosVirtualAddress, SYSID_EPS_SEARCH_SIZE);
    } else {
        //
        // Lets hope that failure to map memory is a temporary problem
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return(Status);
}

typedef enum
{
	SYSID_UNKNOWN_TYPE,
	SYSID_UUID_TYPE,
	SYSID_1394_TYPE
} SYSID_ENTRY_TYPE, *PSYSID_ENTRY_TYPE;

NTSTATUS WmipParseSysIdTable(
    PHYSICAL_ADDRESS PhysicalAddress,
    ULONG NumberEntries,
    PSYSID_UUID SysIdUuid,
    ULONG *SysIdUuidCount,
    PSYSID_1394 SysId1394,
    ULONG *SysId1394Count
    )
/*++

Routine Description:

    Determine the set of UUIDs and 1394 Ids that are in the sysid table

Arguments:

    PhysicalAddress is the physical address of the SysId table

    NumberEntries is the number of entries in the SysId table

    SysIdUuid returns filled with an array of UUIDs. If NULL then no
        UUIDs are returned.

    *SysIdUuidCount returns with the number of UUIDs in the table

    SysId1394 returns filled with an array of 1394 ids. If NULL then no
        1394 ids are returned.

    *SysId1394Count returns with the number of 1394 ids in the table


Return Value:

    STATUS

--*/
{
    NTSTATUS Status;
    ULONG TableSize = NumberEntries * LARGEST_SYSID_TABLE_ENTRY;
    ULONG i;
    ULONG  j;
    PUCHAR VirtualAddress;
    PSYSID_TABLE_ENTRY SysId;
    PUCHAR p;
    UCHAR Checksum;
    ULONG Length;
    ULONG x1394Count, UuidCount;
    ULONG BytesLeft;
	SYSID_ENTRY_TYPE SysidType;

    PAGED_CODE();

    VirtualAddress = MmMapIoSpace(PhysicalAddress,
                                  TableSize,
                                  MmCached);

    if (VirtualAddress != NULL)
    {
        UuidCount = 0;
        x1394Count = 0;
        SysId = (PSYSID_TABLE_ENTRY)VirtualAddress;
        BytesLeft = TableSize;
        Status = STATUS_SUCCESS;

        for (i = 0; i < NumberEntries; i++)
        {
            //
            // Make sure we have not moved beyond the end of the mapped
            // memory.
            if (BytesLeft >= sizeof(SYSID_TABLE_ENTRY))
            {

                Length = SysId->Length;
				
				//
				// Determine what kind of sysid we have
				//
				if ((RtlCompareMemory(&SysId->Type,
									  SYSID_TYPE_UUID, 6) == 6) &&
					(Length == sizeof(SYSID_UUID_ENTRY)))
				{
					SysidType = SYSID_UUID_TYPE;
				} else if ((RtlCompareMemory(&SysId->Type,
											SYSID_TYPE_1394, 6) == 6) &&
						   (Length == sizeof(SYSID_1394_ENTRY))) {

					SysidType = SYSID_1394_TYPE;
				} else {
					//
					// unknown type SYSID
					//
					WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Unknown SYSID type %c%c%c%c%c%c found at %p\n",
								 SysId->Type[0],
								 SysId->Type[1],
								 SysId->Type[2],
								 SysId->Type[3],
								 SysId->Type[4],
								 SysId->Type[5],
								 SysId
							 ));
					Status = STATUS_UNSUCCESSFUL;
					break;
				}
				
                //
                // Validate checksum for this table entry

                if (BytesLeft >= Length)
                {
                    Checksum = 0;
                    p = (PUCHAR)SysId;
                    for (j = 0; j < Length; j++)
                    {
                        Checksum = (UCHAR)(Checksum + p[j]);
                    }

                    if (Checksum != 0)
                    {
                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SYSID Table checksum is not valid at %p\n",
                                 SysId));
                        Status = STATUS_UNSUCCESSFUL;
                        break;
                    }

                    //
                    // Determine what kind of SYSID we have
                    if (SysidType == SYSID_UUID_TYPE)
                    {
                        if (BytesLeft >= sizeof(SYSID_UUID_ENTRY))
                        {
                            //
                            // _UUID_ type SYSID
                            UuidCount++;
                            if (SysIdUuid != NULL)
                            {
                                RtlCopyMemory(SysIdUuid,
                                              SysId->Data,
                                              sizeof(SYSID_UUID));
                                SysIdUuid++;
                            }
                         } else {
                            Status = STATUS_UNSUCCESSFUL;
                            break;
                         }
                    } else if (SysidType == SYSID_1394_TYPE) {
                        if (BytesLeft >= sizeof(SYSID_1394_ENTRY))
                        {
                            //
                            // _1394_ type SYSID
                            x1394Count++;
                            if (SysId1394 != NULL)
                            {
                                RtlCopyMemory(SysId1394,
                                              SysId->Data,
                                              sizeof(SYSID_1394));
                                SysId1394++;
                            }
                        } else {
                            Status = STATUS_UNSUCCESSFUL;
                            break;
                        }
                    } else {
						WmipAssert(FALSE);
						Status = STATUS_UNSUCCESSFUL;
						break;
					}
                    
                    //
                    // Advance to next sysid in table
                    SysId = (PSYSID_TABLE_ENTRY)(((PUCHAR)SysId) + Length);
                    BytesLeft -= Length;
                } else {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SYSID Table at %p is larger at %p than expected",
                             VirtualAddress, SysId));
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }
            } else {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SYSID Table at %p is larger at %p than expected",
                         VirtualAddress, SysId));
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
        }

        *SysIdUuidCount = UuidCount;
        *SysId1394Count = x1394Count;

        MmUnmapIoSpace(VirtualAddress, TableSize);
    } else {
        //
        // Lets hope that the failure to map is a temporary condition
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(Status);
}

NTSTATUS WmipGetSysIds(
    PSYSID_UUID *SysIdUuid,
    ULONG *SysIdUuidCount,
    PSYSID_1394 *SysId1394,
    ULONG *SysId1394Count
    )
/*++

Routine Description:

    This routine will obtain the 1394 and UUID sysids from the bios. First
    we look for a specific memory signature that contains a list of 1394 and
    UUID sysids. If we do not find that we then look at the SMBIOS information
    structure SYSTEM INFORMATION (type 1) which may have it embedded within
    it. If not then we give up.

Arguments:

    *SysIdUuid returns pointing to an array of UUID Sysids

    *SysIdUuidCount returns with the number of UUID Sysids in *SysIdUuid

    *SysId1394 returns pointing to an array of 1394 Sysids

    *SysId1394Count returns with the number of 1394 Sysids in *SysIdUuid


Return Value:

    NT Status code

--*/
{
    NTSTATUS Status;
    PHYSICAL_ADDRESS PhysicalAddress;
    UCHAR BiosRevision;
    ULONG NumberEntries;
    ULONG UuidCount, x1394Count;
    PSYSID_UUID Uuid;
    PSYSID_1394 x1394;
    ULONG TotalSize, x1394Size, UuidSize;

    PAGED_CODE();

    WmipEnterSMCritSection();

    //
    // First See if we have already obtained the SYSIDS
    if (! WmipSysIdRead)
    {
        //
        // First see if the sysids are maintained in a separate SYSID table
        Status = WmipFindSysIdTable(&PhysicalAddress,
                                    &BiosRevision,
                                    &NumberEntries);

        if (NT_SUCCESS(Status))
        {
            //
            // Get the count of entries in each table
            Status = WmipParseSysIdTable(PhysicalAddress,
                                         NumberEntries,
                                         NULL,
                                         &UuidCount,
                                         NULL,
                                         &x1394Count);

            if (NT_SUCCESS(Status))
            {
                 //
                // Get the entire SYSID table

                UuidSize = UuidCount * sizeof(SYSID_UUID);
                x1394Size = x1394Count * sizeof(SYSID_1394);
                TotalSize = UuidSize+x1394Size;

                if (TotalSize > 0)
                {
                    Uuid = ExAllocatePoolWithTag(PagedPool,
                                                 TotalSize,
                                                 WMISYSIDPOOLTAG);

                    if (Uuid == NULL)
                    {
                        WmipLeaveSMCritSection();
                        return(STATUS_INSUFFICIENT_RESOURCES);
                    }

                    x1394 = (PSYSID_1394)( ((PUCHAR)Uuid) + UuidSize );

                    //
                    // Now get the SYSIDs
                    Status = WmipParseSysIdTable(PhysicalAddress,
                                         NumberEntries,
                                         Uuid,
                                         &UuidCount,
                                         x1394,
                                         &x1394Count);

                    if (NT_SUCCESS(Status))
                    {
                        WmipSysIdUuid = Uuid;
                        WmipSysIdUuidCount = UuidCount;
                        WmipSysId1394 = x1394;
                        WmipSysId1394Count = x1394Count;
                    } else {
                        ExFreePool(Uuid);
                    }

                }

            }
        } else {
            //
            // Get SYSID information from SMBIOS
            PVOID MapAddress;
            PSMBIOS_SYSTEM_INFORMATION_STRUCT Info;
            ULONG MapSize;

            Status = WmipFindSMBiosStructure(SMBIOS_SYSTEM_INFORMATION,
                                             (PVOID *)&Info,
                                             &MapAddress,
                                             &MapSize);

            if (NT_SUCCESS(Status))
            {
                Uuid = NULL;
                WmipSysId1394 = NULL;
                WmipSysId1394Count = 0;
                try
                {
                    if (Info->Length > SMBIOS_SYSTEM_INFORMATION_LENGTH_20)
                    {
                        Uuid = ExAllocatePoolWithTag(PagedPool,
                                                           sizeof(SYSID_UUID),
                                                           WMISYSIDPOOLTAG);
                        if (Uuid != NULL)
                        {
                            RtlCopyMemory(Uuid,
                                          Info->Uuid,
                                          sizeof(SYSID_UUID));
                            WmipSysIdUuidCount = 1;
                            WmipSysIdUuid = Uuid;
                            Status = STATUS_SUCCESS;
                        } else {
                            ExFreePool(Uuid);
                            Status = STATUS_UNSUCCESSFUL;
                        }
                    } else {
                        WmipSysIdUuid = NULL;
                        WmipSysIdUuidCount = 0;
                    }
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Invalid SMBIOS SYSTEM INFO structure %p\n",
                              Info));
                    WmipAssert(FALSE);
                    Status = STATUS_UNSUCCESSFUL;
                }

                WmipUnmapSMBiosStructure(MapAddress, MapSize);
            }
        }

        //
        // Mark that we were not able to obtain SysId Information
        WmipSysIdRead = (Status != STATUS_INSUFFICIENT_RESOURCES) ? TRUE : FALSE;
        WmipSysIdStatus = Status;
    }

    WmipLeaveSMCritSection();

    if (NT_SUCCESS(WmipSysIdStatus))
    {
        *SysIdUuid = WmipSysIdUuid;
        *SysIdUuidCount = WmipSysIdUuidCount;
        *SysId1394 = WmipSysId1394;
        *SysId1394Count = WmipSysId1394Count;
    }

    return(WmipSysIdStatus);
}

NTSTATUS WmipGetSMBiosEventlog(
    PUCHAR Buffer,
    PULONG BufferSize
    )
/*++

Routine Description:

    Return the contents of the SMBios eventlog

Arguments:

    Buffer is a pointer to a buffer that receives the eventlog

    *BufferSize on entry has the size of the buffer that can receive
        the eventlog data, on return it has the number of bytes used
        by the smbios eventlog data or the number of bytes needed for
        the smbios eventlog data.

Return Value:

    NT Status code -
        STATUS_SUCCESS - Buffer filled with SMBIOS eventlog data
        STATUS_BUFFER_TOO_SMALL - Buffer not filled with SMBIOS eventlog data,
                                  *BufferSize returns with buffer size neeeded

--*/
{
    PVOID MapAddress;
    PSMBIOS_SYSTEM_EVENTLOG_STRUCT SystemEventlog;
    ULONG MapSize;
    USHORT LogAreaLength;
    UCHAR AccessMethod;
    ACCESS_METHOD_ADDRESS AccessMethodAddress;
    PSMBIOS_EVENTLOG_INFO EventlogInfo;
    UCHAR LogHeaderDescExists;
    PUCHAR EventlogArea;
    NTSTATUS Status;
    USHORT LogTypeDescLength;
    ULONG SizeNeeded;

    PAGED_CODE();
    Status = WmipFindSMBiosStructure(SMBIOS_SYSTEM_EVENTLOG,
                                     (PVOID *)&SystemEventlog,
                                     &MapAddress,
                                     &MapSize);

    if (NT_SUCCESS(Status))
    {
        //
        // Copy data out of SMBIOS eventlog header so we can unmap quickly
        //
        LogAreaLength = SystemEventlog->LogAreaLength;
        AccessMethod = SystemEventlog->AccessMethod;
        AccessMethodAddress = SystemEventlog->AccessMethodAddress;

        if (SystemEventlog->Length >= SMBIOS_SYSTEM_EVENTLOG_LENGTH)
        {
            LogTypeDescLength = SystemEventlog->NumLogTypeDescriptors *
                                SystemEventlog->LenLogTypeDescriptors;
            LogHeaderDescExists = 1;
            if (SystemEventlog->Length != (LogTypeDescLength +
                                  FIELD_OFFSET(SMBIOS_SYSTEM_EVENTLOG_STRUCT,
                                               LogTypeDescriptor)))
            {
                //
                // The SMBIOS spec says that the Length of the structure
                // is the length of the base part of the structures plus
                // the length of the type descriptors. Since this is not
                // the case we may have run into a buggy bios
                //
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SMBIOS System Eventlog structure %p size is %x, but expecting %x\n",
                           SystemEventlog,
                           SystemEventlog->Length,
                           (LogTypeDescLength +
                            FIELD_OFFSET(SMBIOS_SYSTEM_EVENTLOG_STRUCT,
                                         LogTypeDescriptor)) ));
                WmipAssert(FALSE);
                WmipUnmapSMBiosStructure(MapAddress, MapSize);
                Status = STATUS_UNSUCCESSFUL;
                return(Status);
            }
        } else {
            LogTypeDescLength = 0;
            LogHeaderDescExists = 0;
        }

        SizeNeeded = FIELD_OFFSET(SMBIOS_EVENTLOG_INFO, VariableData) +
                                         LogTypeDescLength +
                                         LogAreaLength;
        if (*BufferSize >= SizeNeeded)
        {
            EventlogInfo = (PSMBIOS_EVENTLOG_INFO)Buffer;
            EventlogInfo->LogTypeDescLength = LogTypeDescLength;
            EventlogInfo->LogHeaderDescExists = LogHeaderDescExists;
            EventlogInfo->Reserved = 0;

            EventlogArea = &EventlogInfo->VariableData[LogTypeDescLength];

            if (LogHeaderDescExists == 1)
            {
                //
                // if log header descriptors exist (smbios 2.1+) then copy
                // rest of smbios header plus log type descriptors
                //
                RtlCopyMemory(&EventlogInfo->LogAreaLength,
                              &SystemEventlog->LogAreaLength,
                              (SystemEventlog->Length -
                                  FIELD_OFFSET(SMBIOS_SYSTEM_EVENTLOG_STRUCT,
                                               LogAreaLength)));
            } else {
                //
                // if no log header descriptors then just copy smbios 2.0
                // defined fields and zero out rest of structure
                //
                RtlCopyMemory(&EventlogInfo->LogAreaLength,
                              &SystemEventlog->LogAreaLength,
                        FIELD_OFFSET(SMBIOS_EVENTLOG_INFO, LogHeaderFormat) -
                        FIELD_OFFSET(SMBIOS_EVENTLOG_INFO, LogAreaLength));

                *((PUSHORT)&EventlogInfo->LogHeaderFormat) = 0;
                EventlogInfo->LengthEachLogTypeDesc = 0;
            }

            WmipUnmapSMBiosStructure(MapAddress, MapSize);

            switch(AccessMethod)
            {
                case ACCESS_METHOD_MEMMAP:
                {
                    //
                    // Eventlog is maintained in physical memory
                    //
                    PHYSICAL_ADDRESS PhysicalAddress;
                    PUCHAR EventlogVirtualAddress;

                    PhysicalAddress.HighPart = 0;
                    PhysicalAddress.LowPart = AccessMethodAddress.AccessMethodAddress.PhysicalAddress32;
                    EventlogVirtualAddress = MmMapIoSpace(PhysicalAddress,
                                                LogAreaLength,
                                                MmCached);

                    if ((EventlogArea != NULL) &&
                        (EventlogVirtualAddress != NULL))
                    {
                        RtlCopyMemory(EventlogArea,
                                      EventlogVirtualAddress,
                                      LogAreaLength);
                        MmUnmapIoSpace(EventlogVirtualAddress,
                                       LogAreaLength);
                        Status = STATUS_SUCCESS;
                    } else {
                        Status = STATUS_UNSUCCESSFUL;
                    }
                    break;
                };

                case ACCESS_METHOD_INDEXIO_1:
                case ACCESS_METHOD_INDEXIO_2:
                case ACCESS_METHOD_INDEXIO_3:
                // falls through to ACCESS_METHOD_GPNV

                case ACCESS_METHOD_GPNV:
                {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SMBIOS Eventlog access method GPNV %x\n",
                                     AccessMethod));
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                };

                default:
                {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SMBIOS Eventlog access method %x\n",
                                     AccessMethod));
                    WmipAssert(FALSE);
                    Status = STATUS_UNSUCCESSFUL;
                }
            };

        } else {
            WmipUnmapSMBiosStructure(MapAddress, MapSize);
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        *BufferSize = SizeNeeded;
    }
    return(Status);
}

NTSTATUS
WmipDockUndockEventCallback(
    IN PVOID NotificationStructure,
    IN PVOID Context
    )
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER (NotificationStructure);
    UNREFERENCED_PARAMETER (Context);

    //
    // if SMBIOS data is obtained via the table in the bios, then reset
    // the flag to indicate that we need to rescan for the table. It is
    // possible that a dock or undock could have changed the data. If we
    // obtained the data from ntdetect then there is nothing we can do
    // since we cannot call the bios.
    if (WmipSMBiosTablePhysicalAddress.QuadPart != 0)
    {
        WmipEnterSMCritSection();
        WmipSMBiosChecked = FALSE;
        WmipLeaveSMCritSection();
    }

    return(STATUS_SUCCESS);
}

#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\wmi\tracelog.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    tracelog.c

Abstract:

    This is the source file that implements the private routines for 
    the performance event tracing and logging facility.
    The routines here work on a single event tracing session, the logging
    thread, and buffer synchronization within a session.

--*/

// NOTE: In future, may need to align buffer size to larger of disk alignment or 1024.

#pragma warning(disable:4214)
#pragma warning(disable:4115)
#pragma warning(disable:4201)
#pragma warning(disable:4127)
#include "ntos.h"
#include "wmikmp.h"
#include <zwapi.h>
#pragma warning(default:4214)
#pragma warning(default:4115)
#pragma warning(default:4201)
#pragma warning(default:4127)

#ifndef _WMIKM_
#define _WMIKM_
#endif

#include "evntrace.h"

//
// Constants and Types used locally
//
#if DBG
ULONG WmipTraceDebugLevel=0;
// 5 All messages
// 4 Messages up to event operations
// 3 Messages up to buffer operations
// 2 Flush operations
// 1 Common operations and debugging statements
// 0 Always on - use for real error
#endif

#define ERROR_RETRY_COUNT       100

#include "tracep.h"

// Non-paged global variables
//
ULONG WmiTraceAlignment = DEFAULT_TRACE_ALIGNMENT;
ULONG WmiUsePerfClock = EVENT_TRACE_CLOCK_SYSTEMTIME;      // Global clock switch
LONG  WmipRefCount[MAXLOGGERS];
ULONG WmipGlobalSequence = 0;
PWMI_LOGGER_CONTEXT WmipLoggerContext[MAXLOGGERS];
PWMI_BUFFER_HEADER WmipContextSwapProcessorBuffers[MAXIMUM_PROCESSORS];

//
// Paged global variables
//
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
ULONG WmiWriteFailureLimit = ERROR_RETRY_COUNT;
ULONG WmipFileSystemReady  = FALSE;
WMI_TRACE_BUFFER_CALLBACK WmipGlobalBufferCallback = NULL;
PVOID WmipGlobalCallbackContext = NULL;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

//
// Function prototypes for routines used locally
//

NTSTATUS
WmipSwitchBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER *BufferPointer,
    IN PVOID BufferPointerLocation,
    IN ULONG ProcessorNumber
    );

NTSTATUS
WmipPrepareHeader(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN OUT PWMI_BUFFER_HEADER Buffer,
    IN USHORT BufferFlag
    );

VOID
FASTCALL
WmipPushDirtyBuffer (
    PWMI_LOGGER_CONTEXT     LoggerContext,
    PWMI_BUFFER_HEADER      Buffer
    );

VOID
FASTCALL
WmipPushFreeBuffer (
    PWMI_LOGGER_CONTEXT     LoggerContext,
    PWMI_BUFFER_HEADER      Buffer
    );

//
// Logger functions
//

NTSTATUS
WmipCreateLogFile(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN ULONG SwitchFile,
    IN ULONG Append
    );

NTSTATUS
WmipSwitchToNewFile(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

NTSTATUS
WmipRequestLogFile(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

NTSTATUS
WmipFinalizeHeader(
    IN HANDLE FileHandle,
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

NTSTATUS
WmipFlushBuffersWithMarker (
    IN PWMI_LOGGER_CONTEXT  LoggerContext,
    IN PSLIST_ENTRY         List,
    IN USHORT               BufferFlag
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,    WmipLogger)
#pragma alloc_text(PAGE,    WmipSendNotification)
#pragma alloc_text(PAGE,    WmipCreateLogFile)
#pragma alloc_text(PAGE,    WmipFlushActiveBuffers)
#pragma alloc_text(PAGE,    WmipGenerateFileName)
#pragma alloc_text(PAGE,    WmipPrepareHeader)
#pragma alloc_text(PAGE,    WmiBootPhase1)
#pragma alloc_text(PAGE,    WmipFinalizeHeader)
#pragma alloc_text(PAGE,    WmipSwitchToNewFile)
#pragma alloc_text(PAGE,    WmipRequestLogFile)
#pragma alloc_text(PAGE,    WmipAdjustFreeBuffers)
#pragma alloc_text(PAGEWMI, WmipFlushBuffer)
#pragma alloc_text(PAGEWMI, WmipReserveTraceBuffer)
#pragma alloc_text(PAGEWMI, WmipGetFreeBuffer)
#pragma alloc_text(PAGEWMI, WmiReserveWithPerfHeader)
#pragma alloc_text(PAGEWMI, WmiReserveWithSystemHeader)
#pragma alloc_text(PAGEWMI, WmipAllocateFreeBuffers)
#pragma alloc_text(PAGEWMI, WmipSwitchBuffer)
#pragma alloc_text(PAGEWMI, WmipReleaseTraceBuffer)
#pragma alloc_text(PAGEWMI, WmiReleaseKernelBuffer)
#pragma alloc_text(PAGEWMI, WmipResetBufferHeader)
#pragma alloc_text(PAGEWMI, WmipPushDirtyBuffer)
#pragma alloc_text(PAGEWMI, WmipPushFreeBuffer)
#pragma alloc_text(PAGEWMI, WmipPopFreeContextSwapBuffer)
#pragma alloc_text(PAGEWMI, WmipPushDirtyContextSwapBuffer)
#pragma alloc_text(PAGEWMI, WmipFlushBuffersWithMarker)
#endif

//
// Actual code starts here
//

PWMI_BUFFER_HEADER
WmipGetFreeBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
//
// This routine works at any IRQL
//
{
    PWMI_BUFFER_HEADER Buffer;
    PSLIST_ENTRY Entry;
    if (LoggerContext->SwitchingInProgress == 0) {
        //
        // Not in the middle of switching.
        //

        Entry = InterlockedPopEntrySList(&LoggerContext->FreeList);

        if (Entry != NULL) {
            Buffer = CONTAINING_RECORD (Entry,
                                        WMI_BUFFER_HEADER,
                                        SlistEntry);
    
            //
            // Reset the buffer. 
            // For circular persist mode, we want to write the buffers as
            // RunDown buffers so that post processing would work properly. 
            //

            if (LoggerContext->RequestFlag & REQUEST_FLAG_CIRCULAR_PERSIST) {
                WmipResetBufferHeader( LoggerContext, Buffer, WMI_BUFFER_TYPE_RUNDOWN);
            }
            else {
                WmipResetBufferHeader( LoggerContext, Buffer, WMI_BUFFER_TYPE_GENERIC);
            }

            //
            // Maintain some Wmi logger context buffer counts
            //
            InterlockedDecrement((PLONG) &LoggerContext->BuffersAvailable);
            InterlockedIncrement((PLONG) &LoggerContext->BuffersInUse);

            TraceDebug((2, "WmipGetFreeBuffer: %2d, %p, Free: %d, InUse: %d, Dirty: %d, Total: %d\n", 
                            LoggerContext->LoggerId,
                            Buffer,
                            LoggerContext->BuffersAvailable,
                            LoggerContext->BuffersInUse,
                            LoggerContext->BuffersDirty,
                            LoggerContext->NumberOfBuffers));

            return Buffer;
        } else {
            if (LoggerContext->LoggerMode & EVENT_TRACE_BUFFERING_MODE) {
                //
                // If we are in BUFFERING Mode, put all buffers from
                // Flushlist into FreeList.
                //
            
                if (InterlockedIncrement((PLONG) &LoggerContext->SwitchingInProgress) == 1) {
                    while (Entry = InterlockedPopEntrySList(&LoggerContext->FlushList)) {
                        Buffer = CONTAINING_RECORD (Entry,
                                                    WMI_BUFFER_HEADER,
                                                    SlistEntry);
                
                        WmipPushFreeBuffer (LoggerContext, Buffer);
                    }
                }
                InterlockedDecrement((PLONG) &LoggerContext->SwitchingInProgress);
            }
            return NULL;
        }
    } else {
        return NULL;
    }
}


ULONG
WmipAllocateFreeBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN ULONG NumberOfBuffers
    )                

/*++

Routine Description:

    This routine allocate addition buffers into the free buffer list.
    Logger can allocate more buffer to handle bursty logging behavior.
    This routine can be called by multiple places and counters must be
    manipulated using interlocked operations.

Arguments:

    LoggerContext - Logger Context
    NumberOfBuffers - Number of buffers to be allocated.

Return Value:

    The total number of buffers actually allocated.  When it is fewer than the requested number:
    If this is called when trace is turned on, we fail to turn on trace.
    If this is called by walker thread to get more buffer, it is OK.

Environment:

    Kernel mode.

--*/
{
    ULONG i;
    PWMI_BUFFER_HEADER Buffer;
    ULONG TotalBuffers;

    for (i=0; i<NumberOfBuffers; i++) {
        //
        // Multiple threads can ask for more buffers, make sure
        // we do not go over the maximum.
        //
        TotalBuffers = InterlockedIncrement(&LoggerContext->NumberOfBuffers);
        if (TotalBuffers <= LoggerContext->MaximumBuffers) {

            Buffer = (PWMI_BUFFER_HEADER)
                        ExAllocatePoolWithTag(LoggerContext->PoolType,
                                              LoggerContext->BufferSize, 
                                              TRACEPOOLTAG);
            if (Buffer != NULL) {
    
                TraceDebug((3,
                    "WmipAllocateFreeBuffers: Allocated buffer size %d type %d\n",
                    LoggerContext->BufferSize, LoggerContext->PoolType));
                InterlockedIncrement(&LoggerContext->BuffersAvailable);
                //
                // Initialize newly created buffer
                //
                RtlZeroMemory(Buffer, sizeof(WMI_BUFFER_HEADER));
                Buffer->CurrentOffset = sizeof(WMI_BUFFER_HEADER);
                KeQuerySystemTime(&Buffer->TimeStamp);
                Buffer->State.Free = 1;
    
                //
                // Insert it into the free List
                //
                InterlockedPushEntrySList(&LoggerContext->FreeList,
                                          (PSLIST_ENTRY) &Buffer->SlistEntry);
    
                InterlockedPushEntrySList(&LoggerContext->GlobalList,
                                          (PSLIST_ENTRY) &Buffer->GlobalEntry);
            } else {
                //
                // Allocation failed, decrement the NumberOfBuffers
                // we increment earlier.
                //
                InterlockedDecrement(&LoggerContext->NumberOfBuffers);
                break;
            } 
        } else {
            //
            // Maximum is reached, decrement the NumberOfBuffers
            // we increment earlier.
            //
            InterlockedDecrement(&LoggerContext->NumberOfBuffers);
            break;
        }
    }

    TraceDebug((2, "WmipAllocateFreeBuffers %3d (%3d): Free: %d, InUse: %d, Dirty: %d, Total: %d\n", 
                    NumberOfBuffers,
                    i,
                    LoggerContext->BuffersAvailable,
                    LoggerContext->BuffersInUse,
                    LoggerContext->BuffersDirty,
                    LoggerContext->NumberOfBuffers));

    return i;
}

NTSTATUS
WmipAdjustFreeBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
/*++

Routine Description:

    This routine does buffer management.  It checks the number of free buffers and
    will allocate additonal or free some based on the situation.

Arguments:

    LoggerContext - Logger Context

Return Value:

    Status

Environment:

    Kernel mode.

--*/
{
    ULONG FreeBuffers;
    ULONG AdditionalBuffers;
    NTSTATUS Status = STATUS_SUCCESS;
    //
    //  Check if we need to allocate more buffers
    //

    FreeBuffers = ExQueryDepthSList(&LoggerContext->FreeList);
    if (FreeBuffers <  LoggerContext->MinimumBuffers) {
        AdditionalBuffers = LoggerContext->MinimumBuffers - FreeBuffers;
        if (AdditionalBuffers != WmipAllocateFreeBuffers(LoggerContext, AdditionalBuffers)) {
            Status = STATUS_NO_MEMORY;
        }
    }
    return Status;
}


//
// Event trace/record and buffer related routines
//

PSYSTEM_TRACE_HEADER
FASTCALL
WmiReserveWithSystemHeader(
    IN ULONG LoggerId,
    IN ULONG AuxSize,
    IN PETHREAD Thread,
    OUT PWMI_BUFFER_HEADER *BufferResource
    )
//
// It returns with LoggerContext locked, so caller must explicitly call
// WmipDereferenceLogger() after call WmipReleaseTraceBuffer()
//
{
    PSYSTEM_TRACE_HEADER Header;
    PWMI_LOGGER_CONTEXT LoggerContext;
    LARGE_INTEGER TimeStamp;
#if DBG
    LONG RefCount;
#endif

#if DBG
    RefCount =
#endif
    WmipReferenceLogger(LoggerId);
    TraceDebug((4, "WmiReserveWithSystemHeader: %d %d->%d\n",
                    LoggerId, RefCount-1, RefCount));

    LoggerContext = WmipGetLoggerContext(LoggerId);

    AuxSize += sizeof(SYSTEM_TRACE_HEADER);    // add header size first
    Header = WmipReserveTraceBuffer( LoggerContext, 
                                     AuxSize, 
                                     BufferResource,
                                     &TimeStamp);
    if (Header != NULL) {

        //
        // Now copy the necessary information into the buffer
        //

        Header->SystemTime = TimeStamp;
        if (Thread == NULL) {
            Thread = PsGetCurrentThread();
        }

        Header->Marker       = SYSTEM_TRACE_MARKER;
        Header->ThreadId     = HandleToUlong(Thread->Cid.UniqueThread);
        Header->ProcessId    = HandleToUlong(Thread->Cid.UniqueProcess);
        Header->KernelTime   = Thread->Tcb.KernelTime;
        Header->UserTime     = Thread->Tcb.UserTime;
        Header->Packet.Size  = (USHORT) AuxSize;
    }
    else {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);                             //Interlocked decrement
        TraceDebug((4, "WmiReserveWithSystemHeader: %d %d->%d\n",
                        LoggerId, RefCount+1, RefCount));
    }
// NOTE: Caller must still put in a proper MARKER
    return Header;
}


PPERFINFO_TRACE_HEADER
FASTCALL
WmiReserveWithPerfHeader(
    IN ULONG AuxSize,
    OUT PWMI_BUFFER_HEADER *BufferResource
    )
//
// It returns with LoggerContext locked, so caller must explicitly call
// WmipDereferenceLogger() after call WmipReleaseTraceBuffer()
//
{
    PPERFINFO_TRACE_HEADER Header;
    ULONG LoggerId = WmipKernelLogger;
    LARGE_INTEGER TimeStamp;
#if DBG
    LONG RefCount;
#endif
//
// We must have this check here to see the logger is still running
// before calling ReserveTraceBuffer.
// The stopping thread may have cleaned up the logger context at this 
// point, which will cause AV.
// For all other kernel events, this check is made in callouts.c.
//
    if (WmipIsLoggerOn(LoggerId) == NULL) {
        return NULL;
    }

#if DBG
    RefCount =
#endif
    WmipReferenceLogger(LoggerId);
    TraceDebug((4, "WmiReserveWithPerfHeader: %d %d->%d\n",
                    LoggerId, RefCount-1, RefCount));

    AuxSize += FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);    // add header size first
    Header = WmipReserveTraceBuffer( WmipGetLoggerContext(LoggerId), 
                                     AuxSize, 
                                     BufferResource,
                                     &TimeStamp);
    if (Header != NULL) {
        //
        // Now copy the necessary information into the buffer
        //
        Header->SystemTime = TimeStamp;
        Header->Marker = PERFINFO_TRACE_MARKER;
        Header->Packet.Size = (USHORT) AuxSize;
    } else {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((4, "WmiWmiReserveWithPerfHeader: %d %d->%d\n",
                        LoggerId, RefCount+1, RefCount));
    }
// NOTE: Caller must still put in a proper MARKER
    return Header;
}


PVOID
FASTCALL
WmipReserveTraceBuffer(
    IN  PWMI_LOGGER_CONTEXT LoggerContext,
    IN  ULONG RequiredSize,
    OUT PWMI_BUFFER_HEADER *BufferResource,
    OUT PLARGE_INTEGER TimeStamp
    )
/*++

Routine Description:
    This function is the main logging function that reserves spaces for any events.
    The algorithm is as follows:

    Every time a space is needed, we InterlockedExchangeAdd CurrentOffset.
    A local variable Offset is used to track the initial value when 
    InterlockedExchangeAdd is taken.  If there is enough space for this
    event (i.e., (Offset + RequiredSize) <= BufferSize), then we have successfully
    reserved the space.
    
    If there is not enough space left on this buffer, we will call WmipSwitchBuffer 
    for a new buffer.  In this case, CurrentOffset should be larger than the buffersize.
    Since other thread can still be trying to reserve space using their buffer, we
    saved the offset on SavedOffset the the logger thread knows the real offset to be
    written to disk.

    Note that, since the CurrentOffset if growing monotonically, only one thread is
    advancing the CurrentOffset from below BufferSize to beyond BufferSize.  
    It is this thread's responsibility to set the SavedOffset properly.

Arguments:

    LoggerContext - Logger context from current logging session.

    RequiredSize  - The space needed for logging the data.

    Buffer        - Pointer to a buffer header

    TimeStamp     - TimeStamp of the event

Return Value:

    The status of running the buffer manager

Environment:

    Kernel mode.  This routine should work at any IRQL.

--*/
{
    PVOID       ReservedSpace;
    PWMI_BUFFER_HEADER Buffer = NULL;
    ULONG       Offset;

    //
    // Mark it volatile to work around compiler bug.
    //
    volatile ULONG Processor;
    NTSTATUS    Status;

    if (!WmipIsValidLogger(LoggerContext)) {
        return NULL;
    }
    if (!LoggerContext->CollectionOn) {
        return NULL;
    }

    *BufferResource = NULL;

    RequiredSize = (ULONG) ALIGN_TO_POWER2(RequiredSize, WmiTraceAlignment);

    if (RequiredSize > LoggerContext->BufferSize - sizeof (WMI_BUFFER_HEADER)) {
        goto LostEvent;
    }

    //
    // Get processor number again here due to possible context switch
    //
    Processor = KeGetCurrentProcessorNumber();

    //
    // Get the processor specific buffer pool
    //
    Buffer = LoggerContext->ProcessorBuffers[Processor];

    if (Buffer == NULL) {
        //
        // Nothing in per process list, ask to get a new buffer
        //
        Status = WmipSwitchBuffer(LoggerContext, 
                                  &Buffer,
                                  &LoggerContext->ProcessorBuffers[Processor],
                                  Processor);

        if (!NT_SUCCESS(Status)) {
            //
            // Nothing available
            //
            goto LostEvent;
        }

        ASSERT(Buffer != NULL);
    }

TryFindSpace:

    //
    // Increment refcount to buffer first to prevent it from going away
    //
    InterlockedIncrement(&Buffer->ReferenceCount);
    
    //
    // Check if there is enough space in this buffer.
    //
    Offset = (ULONG) InterlockedExchangeAdd(
                     (PLONG) &Buffer->CurrentOffset, RequiredSize);

    //
    // If many threads concurrently hit this line, the Offset+RequiredSize
    // might arithmetically overflow. Therefore we need to add an extra 
    // check to make sure the Offset is in range.
    //

    if ( (Offset+RequiredSize <= LoggerContext->BufferSize) && 
         (Offset < LoggerContext->BufferSize) ) {
    
        //
        // Successfully reserved the space
        // Get the timestamp of the event
        //
        if (TimeStamp) {
            TimeStamp->QuadPart = (*LoggerContext->GetCpuClock)();
        }

        //
        // Set up the space pointer
        //
        ReservedSpace = (PVOID) (Offset +  (char*)Buffer);
    
        if (LoggerContext->SequencePtr) {
            *((PULONG) ReservedSpace) =
                (ULONG)InterlockedIncrement(LoggerContext->SequencePtr);
        }
        goto FoundSpace;
    } else {
        //
        // There is not enough space left to log this event,
        // Ask for buffer switch.  The WmipSwitchBuffer()
        // will push this current buffer into Dirty list.
        //
        // Before asking for buffer switch, 
        // check if I am the one that got overboard.  
        // If yes, put the correct offset back.
        //
        if (Offset <= LoggerContext->BufferSize) {
            Buffer->SavedOffset = Offset;
        }

        //
        // Also, dereference the buffer, so it can be freed.
        //
        InterlockedDecrement((PLONG) &Buffer->ReferenceCount);

        //
        // Nothing in per process list, ask to get a new buffer
        //
        Status = WmipSwitchBuffer(LoggerContext, 
                                  &Buffer,
                                  &LoggerContext->ProcessorBuffers[Processor],
                                  Processor);

        if (!NT_SUCCESS(Status)) {
            //
            // Nothing available
            //
            goto LostEvent;
        }

        ASSERT (Buffer != NULL);
        goto TryFindSpace;
    }

LostEvent:
    //
    // Will get here it we are throwing away the event
    //
    ASSERT(Buffer == NULL);
    LoggerContext->EventsLost++;    // best attempt to be accurate
    ReservedSpace = NULL;
    if (LoggerContext->SequencePtr) {
        InterlockedIncrement(LoggerContext->SequencePtr);
    }

FoundSpace:
    //
    // notify the logger after critical section
    //
    *BufferResource = Buffer;

    return ReservedSpace;
}

NTSTATUS
WmipSwitchToNewFile(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
/*++

Routine Description:

    This routine is called to get a LogFileHandle for GlobalLogger or
    when a fileswitch is needed for NEWFILE mode. It will create the file
    and add logfileheader to it. It closes the oldfile by properly
    finalizing its header.  

Arguments:

    LoggerContext - Logger Context

Return Value:

    Status

Environment:

    Kernel mode.

--*/
{
    IO_STATUS_BLOCK IoStatus;
    HANDLE OldHandle, NewHandle;
    UNICODE_STRING NewFileName, OldFileName;
    ULONG BufferSize = LoggerContext->BufferSize;
    PWMI_BUFFER_HEADER NewHeaderBuffer;
    NTSTATUS Status=STATUS_SUCCESS;

    PAGED_CODE();

    NewFileName.Buffer = NULL;

    if (LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_NEWFILE) {

        Status = WmipGenerateFileName(
                                      &LoggerContext->LogFilePattern,
                                      (PLONG) &LoggerContext->FileCounter,
                                      &NewFileName
                                     );

        if (!NT_SUCCESS(Status)) {
            TraceDebug((1, "WmipSwitchToNewFile: Error %x generating filename\n", Status));
            return Status;
        }

    }
    else {
        //
        // GlobalLogger path. It is executed only once to set up 
        // the logfile. 
        //
        if (LoggerContext->LogFileHandle != NULL) {
            LoggerContext->RequestFlag &= ~REQUEST_FLAG_NEW_FILE;
            return STATUS_SUCCESS;
        }
        if (LoggerContext->LogFileName.Buffer == NULL) {
            TraceDebug((1, "WmipSwitchToNewFile: No LogFileName\n"));
            return STATUS_INVALID_PARAMETER;
        }
        if (! RtlCreateUnicodeString( &NewFileName, 
                                      LoggerContext->LogFileName.Buffer) ) {
            TraceDebug((1, "WmipSwitchToNewFile: No Memory for NewFileName\n"));
            return STATUS_NO_MEMORY;
        }
    }

    //
    // We have a NewFileName. Create the File 
    //
    Status = WmipDelayCreate(&NewHandle, &NewFileName, FALSE);

    if (NT_SUCCESS(Status)) {
        NewHeaderBuffer = (PWMI_BUFFER_HEADER)
                           ExAllocatePoolWithTag(LoggerContext->PoolType,
                                              LoggerContext->BufferSize,
                                              TRACEPOOLTAG);
        if (NewHeaderBuffer != NULL) {
        //
        // Now we have all the resources we need for the new file. 
        // Let's close out the old file, if necessary and switch
        //
            OldFileName = LoggerContext->LogFileName;
            OldHandle = LoggerContext->LogFileHandle;
            if (OldHandle) {
                WmipFinalizeHeader(OldHandle, LoggerContext);
                ZwClose(OldHandle);
            }

            // NOTE: Assumes LogFileName cannot be changed
            //  for NEWFILE mode!!!
            if (OldFileName.Buffer != NULL) {
                RtlFreeUnicodeString(&OldFileName);
            }

            LoggerContext->BuffersWritten = 1;
            LoggerContext->LogFileHandle = NewHandle;
            LoggerContext->LogFileName = NewFileName;

            NewFileName.Buffer = NULL;

            RtlZeroMemory( NewHeaderBuffer, LoggerContext->BufferSize );
            WmipResetBufferHeader(LoggerContext, 
                                  NewHeaderBuffer, 
                                  WMI_BUFFER_TYPE_RUNDOWN);

            WmipAddLogHeader(LoggerContext, NewHeaderBuffer);

            LoggerContext->LastFlushedBuffer = 1;
            LoggerContext->ByteOffset.QuadPart = BufferSize;
            LoggerContext->RequestFlag &= ~REQUEST_FLAG_NEW_FILE;
            LoggerContext->LoggerMode &= ~EVENT_TRACE_DELAY_OPEN_FILE_MODE;
            LoggerContext->LoggerMode &= ~EVENT_TRACE_ADD_HEADER_MODE;

            Status = WmipPrepareHeader(LoggerContext,  
                                       NewHeaderBuffer, 
                                       WMI_BUFFER_TYPE_RUNDOWN);
            if (NT_SUCCESS(Status)) {
                Status = ZwWriteFile(
                                     NewHandle,
                                     NULL, NULL, NULL,
                                     &IoStatus,
                                     NewHeaderBuffer,
                                     BufferSize,
                                     NULL, NULL);
            }
            if (!NT_SUCCESS(Status) ) {
                TraceDebug((1, "WmipSwitchToNewFile: Write Failed\n", Status));
            }

            WmipSendNotification(LoggerContext, 
                                 STATUS_MEDIA_CHANGED, 
                                 STATUS_SEVERITY_INFORMATIONAL);

            ExFreePool(NewHeaderBuffer);
        }
    }
    
    if (NewFileName.Buffer != NULL) {
        ExFreePool(NewFileName.Buffer);
    }

    return Status;
}


NTSTATUS
WmipRequestLogFile(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
/*++

Routine Description:

    This routine switches logfiles for an active logger. This routine must   
    be called only by the Logger Thread. It will close the previous logfile,
    if any, properly by terminating it with FLUSH_MARKER and Finalizing the
    LogHeader. 

    Two different cases to consider here are: 
        1. The newfile was created in user mode with headers and rundown data
        2. The newfile is created in kernel (need to add LogFileHeader)

    The callers of this function are
        1. UpdateLogger: Sets the REQUEST_FLAG_NEW_FILE after presenting
           a user mode created logfile in NewLogFile.
        2. NT Kernel Logger session: Switches from DELAY_OPEN mode with 
           a user mode created logfile 
        3. FILE_MODE_NEWFILE: When current logfile reaches the FileLimit
           FlushBuffer requests a newfile. 
        4. GlobalLogger: Started in DELAY_OPEN && ADD_HEADER mode needs
           to create the logfile when the FileSystem is ready. 

    In all cases, when the switch is made the old logfile needs to be 
    properly closed after Finalizing its header. 



Arguments:

    LoggerContext - Logger Context

Return Value:

    Status

Environment:

    Kernel mode.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if (!WmipFileSystemReady) {
    //
    // FileSystem is not ready yet, so return for now.
    //
        return Status;
    }

    //
    // In order for us to act on this request we need something to create
    // a file with, such as FileName, Pattern etc., 
    //

    if ((LoggerContext->LogFileName.Buffer == NULL ) &&
        (LoggerContext->LogFilePattern.Buffer == NULL)  &&
        (LoggerContext->NewLogFileName.Buffer == NULL) ) {

        return Status;
    }
        
    //
    // With the REQUEST_FLAG_NEW_FILE set, flush all active buffers. 
    //

    if (LoggerContext->LogFileHandle != NULL ) {
        Status = WmipFlushActiveBuffers(LoggerContext, TRUE);
    }

    if (NT_SUCCESS(Status)) {
        if ( (LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_NEWFILE) ||
             ( (LoggerContext->LoggerMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE) &&
               (LoggerContext->LoggerMode & EVENT_TRACE_ADD_HEADER_MODE))) {  

            Status = WmipSwitchToNewFile(LoggerContext);
        }
        else {
            //
            // UpdateTrace case
            //
            TraceDebug((3, "WmipLogger: New File\n"));
            Status = WmipCreateLogFile(LoggerContext,
                                       TRUE,
                                       EVENT_TRACE_FILE_MODE_APPEND);
            if (NT_SUCCESS(Status)) {
                LoggerContext->LoggerMode &= ~EVENT_TRACE_DELAY_OPEN_FILE_MODE;
            }
            //
            // This is to release the Update thread from the wait
            //
            KeSetEvent(&LoggerContext->FlushEvent, 0, FALSE);
        }
    }

    if (! NT_SUCCESS(Status)) {
        LoggerContext->LoggerStatus = Status;
    }
    return Status;
}


//
// Actual Logger code starts here
//


VOID
WmipLogger(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )

/*++

Routine Description:
    This function is the logger itself. It is started as a system thread.
    It will not return until someone has stopped data collection or it
    is not successful is flushing out a buffer (e.g. disk is full).

Arguments:

    None.

Return Value:

    The status of running the buffer manager

--*/

{
    NTSTATUS Status, InitialStatus;
    ULONG ErrorCount;
    ULONG FlushTimeOut;
    ULONG64 LastFlushTime=0;

    PAGED_CODE();

    //
    // Set the logger status to PENDING before touching logger context.
    // If the starting threads times out and sees STATUS_PENDING, it will wait
    // until we notify.
    //
    InitialStatus = InterlockedExchange(&LoggerContext->LoggerStatus,
                                        STATUS_PENDING);

    if (STATUS_CANCELLED == InitialStatus) {
        // 
        // The logger thread was too late to notify the starting thread.
        //
        // Clean up the LoggerContext, and go away here. 
        //
        WmipFreeLoggerContext(LoggerContext);
        PsTerminateSystemThread(InitialStatus);
        return;
    }

    LoggerContext->LoggerThread = PsGetCurrentThread();

    if ((LoggerContext->LoggerMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE)
        || (LoggerContext->LogFileName.Length == 0)) {

        // If EVENT_TRACE_DELAY_OPEN_FILE_MODE is specified, WMI does not
        // need to create logfile now.
        //
        // If there is no LogFileName specified, WMI does not need to create
        // logfile either. WmipStartLogger() already checks all possible
        // combination of LoggerMode and LogFileName, so we don't need to
        // perform the same check again.
        //
        Status = STATUS_SUCCESS;
    } else {
        Status = WmipCreateLogFile(LoggerContext, 
                                   FALSE,
                                   LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_APPEND);
    }


    //
    // Set the logger status to let the starting thread know what happened.
    //
    InitialStatus = InterlockedExchange(&LoggerContext->LoggerStatus,
                                        Status);
    ASSERT(InitialStatus != STATUS_CANCELLED);

    if (!NT_SUCCESS(Status)){
        //
        // Logger thread failed to open the file. We will notify the starting 
        // thread, but we will clean up the logger context here.
        //
        if (LoggerContext->LogFileHandle != NULL) {
            Status = ZwClose(LoggerContext->LogFileHandle);
            LoggerContext->LogFileHandle = NULL;
        }
        KeSetEvent(&LoggerContext->LoggerEvent, 0, FALSE);
        WmipFreeLoggerContext(LoggerContext);
        PsTerminateSystemThread(Status);
        return;
    }
    else { // All succeeded.
        //
        // It is safe to go.
        // This is the only place where CollectionOn will be turn on!!!
        //
        LoggerContext->CollectionOn = TRUE;
        KeSetEvent(&LoggerContext->LoggerEvent, 0, FALSE);
    }

    ErrorCount = 0;
    // by now, the caller has been notified that the logger is running

    //
    // Loop and wait for buffers to be filled until someone turns off CollectionOn
    //
    KeSetBasePriorityThread(KeGetCurrentThread(), LOW_REALTIME_PRIORITY-1);

    while (LoggerContext->CollectionOn) {

        if (LoggerContext->LoggerMode & EVENT_TRACE_BUFFERING_MODE) {
            //
            // Wait forever until signaled by when logging is terminated.
            //
            Status = KeWaitForSingleObject(
                        &LoggerContext->LoggerSemaphore,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL);
            LoggerContext->LoggerStatus = STATUS_SUCCESS;
        } else {
            ULONG FlushAll = 0;
            ULONG FlushFlag;

            FlushTimeOut = LoggerContext->FlushTimer;
            //
            // Wake up every second to see if there are any buffers in
            // flush list.
            //
            Status = KeWaitForSingleObject(
                        &LoggerContext->LoggerSemaphore,
                        Executive,
                        KernelMode,
                        FALSE,
                        &WmiOneSecond);
    
            //
            //  Check if number of buffers need to be adjusted.
            //
            WmipAdjustFreeBuffers(LoggerContext);

            LoggerContext->LoggerStatus = STATUS_SUCCESS;

            if ((LoggerContext->RequestFlag & REQUEST_FLAG_NEW_FILE)  ||
                ((LoggerContext->LoggerMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE)
                && (LoggerContext->LoggerMode & EVENT_TRACE_ADD_HEADER_MODE)) ) {
                Status = WmipRequestLogFile( LoggerContext);
            }

            //
            // Check to see if we need to FlushAll 
            //
            if (FlushTimeOut) {
                ULONG64 Now;
                KeQuerySystemTime((PLARGE_INTEGER) &Now);
                if ( ((Now - LastFlushTime) / 10000000) >= FlushTimeOut) { 
                    FlushAll = 1;
                    LastFlushTime = Now;
                }
                else {
                    FlushAll = 0;
                }
            }

            FlushFlag = (LoggerContext->RequestFlag & REQUEST_FLAG_FLUSH_BUFFERS);
            if (  FlushFlag ) 
                FlushAll = TRUE;

                Status = WmipFlushActiveBuffers(LoggerContext, FlushAll);
                //
                // Should check the status, and if failed to write a log file
                // header, should clean up.  As the log file is bad anyway.
                //
                if (  FlushFlag )  {
                    LoggerContext->RequestFlag &= ~REQUEST_FLAG_FLUSH_BUFFERS;
                    //
                    // If this was a flush for persistent events, this request 
                    // flag must be reset here.
                    //
                    if (LoggerContext->RequestFlag & 
                                       REQUEST_FLAG_CIRCULAR_TRANSITION) {
                        if (LoggerContext->LogFileHandle != NULL) {
                            WmipFinalizeHeader(LoggerContext->LogFileHandle, 
                                               LoggerContext);
                        }

                        LoggerContext->RequestFlag &= ~REQUEST_FLAG_CIRCULAR_TRANSITION;
                    }

                    LoggerContext->LoggerStatus = Status;
                    KeSetEvent(&LoggerContext->FlushEvent, 0, FALSE);

                }
                if (!NT_SUCCESS(Status)) {
                    LoggerContext->LoggerStatus = Status;
                    WmipStopLoggerInstance(LoggerContext);
                }
        }
    } // while loop

    if (Status == STATUS_TIMEOUT) {
        Status = STATUS_SUCCESS;
    }
//
// if a normal collection end, flush out all the buffers before stopping
//

    TraceDebug((2, "WmipLogger: Flush all buffers before stopping...\n"));
//
// First, move the per processor buffer out to FlushList
//
    // This is to force buffers to be written
    // in FlushBuffer without snapping back to this routine to create a file. 
    LoggerContext->RequestFlag |= REQUEST_FLAG_NEW_FILE;

    while ((LoggerContext->NumberOfBuffers > 0) &&
           (LoggerContext->NumberOfBuffers > LoggerContext->BuffersAvailable)) {
        Status = KeWaitForSingleObject(
                    &LoggerContext->LoggerSemaphore,
                    Executive,
                    KernelMode,
                    FALSE,
                    &WmiOneSecond);
        WmipFlushActiveBuffers(LoggerContext, 1);
        TraceDebug((2, "WmipLogger: Stop %d %d %d %d %d\n",
                        LoggerContext->LoggerId,
                        LoggerContext->BuffersAvailable,
                        LoggerContext->BuffersInUse,
                        LoggerContext->BuffersDirty,
                        LoggerContext->NumberOfBuffers));
    }

    //
    // Note that LoggerContext->LogFileObject needs to remain set
    //    for QueryLogger to work after close
    //
    if (LoggerContext->LogFileHandle != NULL) {
        ZwClose(LoggerContext->LogFileHandle);
        TraceDebug((1, "WmipLogger: Close logfile with status=%X\n", Status));
    }
    LoggerContext->LogFileHandle = NULL;
    KeSetEvent(&LoggerContext->FlushEvent, 0, FALSE);
    KeSetEvent(&LoggerContext->LoggerEvent, 0, FALSE);
#if DBG
    if (!NT_SUCCESS(Status)) {
        TraceDebug((1, "WmipLogger: Aborting %d %X\n",
                        LoggerContext->LoggerId, LoggerContext->LoggerStatus));
    }
#endif

    WmipFreeLoggerContext(LoggerContext);
    PsTerminateSystemThread(Status);
}

NTSTATUS
WmipSendNotification(
    PWMI_LOGGER_CONTEXT LoggerContext,
    NTSTATUS            Status,
    ULONG               Flag
    )
{
    WMI_TRACE_EVENT WmiEvent;

    RtlZeroMemory(& WmiEvent, sizeof(WmiEvent));
    WmiEvent.Status = Status;
    KeQuerySystemTime(& WmiEvent.Wnode.TimeStamp);

    WmiEvent.Wnode.BufferSize = sizeof(WmiEvent);
    WmiEvent.Wnode.Guid       = TraceErrorGuid;
    WmiSetLoggerId(
          LoggerContext->LoggerId,
          (PTRACE_ENABLE_CONTEXT) & WmiEvent.Wnode.HistoricalContext);

    WmiEvent.Wnode.ClientContext = 0XFFFFFFFF;
    WmiEvent.TraceErrorFlag = Flag;

    WmipProcessEvent(&WmiEvent.Wnode,
                     FALSE,
                     FALSE);
    

    return STATUS_SUCCESS;
}

//
// convenience routine to flush the current buffer by the logger above
//

NTSTATUS
WmipFlushBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER Buffer,
    IN USHORT BufferFlag
    )
/*++

Routine Description:
    This function is responsible for flushing a filled buffer out to
    disk, or to a real time consumer.

Arguments:

    LoggerContext -      Context of the logger

    Buffer - 

    BufferFlag -

Return Value:

    The status of flushing the buffer

--*/
{
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS Status;
    ULONG BufferSize;
    ULONG BufferPersistenceData = LoggerContext->RequestFlag
                                & (  REQUEST_FLAG_CIRCULAR_PERSIST
                                   | REQUEST_FLAG_CIRCULAR_TRANSITION);

    ASSERT(LoggerContext != NULL);
    ASSERT(Buffer != NULL);

    if (LoggerContext == NULL || Buffer == NULL) {
        return STATUS_SEVERITY_ERROR;
    }

    //
    // Grab the buffer to be flushed
    //
    BufferSize = LoggerContext->BufferSize;

    //
    // Put end of record marker in buffer if available space
    //

    TraceDebug((2, "WmipFlushBuffer: %p, Flushed %X %8x %8x %5d\n",
                Buffer,
                Buffer->ClientContext, Buffer->SavedOffset,
                Buffer->CurrentOffset, LoggerContext->BuffersWritten));

    Status = WmipPrepareHeader(LoggerContext, Buffer, BufferFlag);

    if (Status == STATUS_SUCCESS) {

        //
        // Buffering mode is mutually exclusive with REAL_TIME_MODE
        //
        if (!(LoggerContext->LoggerMode & EVENT_TRACE_BUFFERING_MODE)) {
            if (LoggerContext->LoggerMode & EVENT_TRACE_REAL_TIME_MODE) {

                if (LoggerContext->UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
                    Buffer->Wnode.Flags |= WNODE_FLAG_USE_TIMESTAMP;
                }

                // need to see if we can send anymore
                // check for queue length
                if (! NT_SUCCESS(WmipProcessEvent((PWNODE_HEADER)Buffer,
                                                  FALSE,
                                                  FALSE))) {
                    LoggerContext->RealTimeBuffersLost++;
                }
            }
        }

        if (LoggerContext->LogFileHandle != NULL) {

            if (LoggerContext->MaximumFileSize > 0) { // if quota given
                ULONG64 FileSize = (ULONG64)(LoggerContext->LastFlushedBuffer) * BufferSize;
                ULONG64 FileLimit = (ULONG64)(LoggerContext->MaximumFileSize) * BYTES_PER_MB;
                if (LoggerContext->LoggerMode & EVENT_TRACE_USE_KBYTES_FOR_SIZE) {
                    FileLimit = LoggerContext->MaximumFileSize * 1024;
                }

                if ( FileSize >= FileLimit ) {

                    ULONG LoggerMode = LoggerContext->LoggerMode & 0X000000FF;
                    //
                    // Files from user mode always have the APPEND flag. 
                    // We mask it out here to simplify the testing below.
                    //
                    LoggerMode &= ~EVENT_TRACE_FILE_MODE_APPEND;
                    //
                    // PREALLOCATE flag has to go, too. 
                    //
                    LoggerMode &= ~EVENT_TRACE_FILE_MODE_PREALLOCATE;

                    if (LoggerMode == EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
                        // do not write to logfile anymore

                        Status = STATUS_LOG_FILE_FULL; // control needs to stop logging
                        // need to fire up a Wmi Event to control console
                        WmipSendNotification(LoggerContext,
                            Status, STATUS_SEVERITY_ERROR);
                    }
                    else if (LoggerMode == EVENT_TRACE_FILE_MODE_CIRCULAR ||
                             LoggerMode == EVENT_TRACE_FILE_MODE_CIRCULAR_PERSIST) {
                        if (BufferPersistenceData > 0) {
                            // treat circular logfile as sequential logfile if
                            // logger still processes Persistence events (events
                            // that cannot be overwritten in circular manner).
                            //
                            Status = STATUS_LOG_FILE_FULL;
                            WmipSendNotification(LoggerContext,
                                Status, STATUS_SEVERITY_ERROR);
                        }
                        else {
                            // reposition file

                            LoggerContext->ByteOffset
                                    = LoggerContext->FirstBufferOffset;
                            LoggerContext->LastFlushedBuffer = (ULONG)
                                      (LoggerContext->FirstBufferOffset.QuadPart
                                    / LoggerContext->BufferSize);
                        }
                    }
                    else if (LoggerMode & EVENT_TRACE_FILE_MODE_NEWFILE) {

                        //
                        // We will set the RequestFlag to initiate a file switch. 
                        // If that flag is already set, then we continue to flush
                        // past the FileLimit.  
                        //
                        // There should be no race condition with an UpdateTrace
                        // setting the RequestFlag since we do not allow change of
                        // filename for NEWFILE mode. 
                        //

                        if ( (LoggerContext->RequestFlag & REQUEST_FLAG_NEW_FILE) != 
                             REQUEST_FLAG_NEW_FILE) 
                        {
                            LoggerContext->RequestFlag |= REQUEST_FLAG_NEW_FILE;
                        }
                    }
                }
            }

            if (NT_SUCCESS(Status)) {
                Status = ZwWriteFile(
                            LoggerContext->LogFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatus,
                            Buffer,
                            BufferSize,
                            &LoggerContext->ByteOffset,
                            NULL);

                if (NT_SUCCESS(Status)) {
                    LoggerContext->ByteOffset.QuadPart += BufferSize;
                    
                    //
                    // update FirstBufferOffset so that persistence event will
                    // not be overwritten in circular logfile. We need to check that
                    // buffer type is RUNDOWN because if persistent --> non persistent
                    // transition happens at high IRQL we will not be able to flush logger
                    // and might end up with non RUNDOWN buffers in the rundown stream
                    //
                    if ((BufferPersistenceData > 0)  && 
                        (Buffer->BufferType == WMI_BUFFER_TYPE_RUNDOWN)) {

                        LoggerContext->FirstBufferOffset.QuadPart += BufferSize;
                    }
                }
                else if (Status == STATUS_LOG_FILE_FULL ||
                         Status == STATUS_DISK_FULL) {
                    // need to fire up a Wmi Event to control console
                    WmipSendNotification(LoggerContext,
                        STATUS_LOG_FILE_FULL, STATUS_SEVERITY_ERROR);
                }
                else {
                    TraceDebug((2, "WmipFlushBuffer: Unknown WriteFile Failure with status=%X\n", Status));
                }
            }
        }

        // Now do callbacks. This happens whether a file exists or not.
        if (WmipGlobalBufferCallback) {
            (WmipGlobalBufferCallback) (Buffer, WmipGlobalCallbackContext);
        }
        if (LoggerContext->BufferCallback) {
            (LoggerContext->BufferCallback) (Buffer, LoggerContext->CallbackContext);
        }
    }

    if (NT_SUCCESS(Status)) {
        LoggerContext->BuffersWritten++;
        LoggerContext->LastFlushedBuffer++;
    }
    else {
#if DBG
        if (Status == STATUS_NO_DATA_DETECTED) {
            TraceDebug((2, "WmipFlushBuffer: Empty buffer detected\n"));
        }
        else if (Status == STATUS_SEVERITY_WARNING) {
            TraceDebug((2, "WmipFlushBuffer: Buffer could be corrupted\n"));
        }
        else {
            TraceDebug((2,
                "WmipFlushBuffer: Unable to write buffer: status=%X\n",
                Status));
        }
#endif
        if ((Status != STATUS_NO_DATA_DETECTED) &&
            (Status != STATUS_SEVERITY_WARNING))
            LoggerContext->LogBuffersLost++;
    }

    return Status;
}

NTSTATUS
WmipCreateLogFile(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN ULONG SwitchFile,
    IN ULONG Append
    )
{
    NTSTATUS Status;
    HANDLE newHandle = NULL;
    IO_STATUS_BLOCK IoStatus;
    FILE_STANDARD_INFORMATION FileSize = {0};
    LARGE_INTEGER ByteOffset;
    BOOLEAN FileSwitched = FALSE;
    UNICODE_STRING OldLogFileName;

    PWCHAR            strLogFileName = NULL;
    PUCHAR            pFirstBuffer = NULL;

    PAGED_CODE();

    RtlZeroMemory(&OldLogFileName, sizeof(UNICODE_STRING));
    LoggerContext->RequestFlag &= ~REQUEST_FLAG_NEW_FILE;

    pFirstBuffer = (PUCHAR) ExAllocatePoolWithTag(
            PagedPool, LoggerContext->BufferSize, TRACEPOOLTAG);
    if(pFirstBuffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(pFirstBuffer, LoggerContext->BufferSize);

    if (SwitchFile) {
        Status = WmipCreateNtFileName(
                        LoggerContext->NewLogFileName.Buffer,
                        & strLogFileName);
    }
    else {
        Status = WmipCreateNtFileName(
                        LoggerContext->LogFileName.Buffer,
                        & strLogFileName);
    }
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    if (LoggerContext->ClientSecurityContext.ClientToken != NULL) {
        Status = SeImpersonateClientEx(
                        &LoggerContext->ClientSecurityContext, NULL);
    }
    if (NT_SUCCESS(Status)) {
        // first open logfile using user security context
        //
        Status = WmipCreateDirectoryFile(strLogFileName, FALSE, & newHandle, Append);
        PsRevertToSelf();
    }
    if (!NT_SUCCESS(Status)) {
        // if using user security context fails to open logfile,
        // then try open logfile again using local system security context
        //
        Status = WmipCreateDirectoryFile(strLogFileName, FALSE, & newHandle, Append);
    }

    if (NT_SUCCESS(Status)) {
        HANDLE tempHandle = LoggerContext->LogFileHandle;
        PWMI_BUFFER_HEADER    BufferChecksum;
        PTRACE_LOGFILE_HEADER LogfileHeaderChecksum;
        ULONG BuffersWritten = 0;

        BufferChecksum = (PWMI_BUFFER_HEADER) LoggerContext->LoggerHeader;
        LogfileHeaderChecksum = (PTRACE_LOGFILE_HEADER)
                (((PUCHAR) BufferChecksum) + sizeof(WNODE_HEADER));
        if (LogfileHeaderChecksum) {
            BuffersWritten = LogfileHeaderChecksum->BuffersWritten;
        }

        ByteOffset.QuadPart = 0;
        Status = ZwReadFile(
                    newHandle,
                    NULL,
                    NULL,
                    NULL,
                    & IoStatus,
                    pFirstBuffer,
                    LoggerContext->BufferSize,
                    & ByteOffset,
                    NULL);
        if (NT_SUCCESS(Status)) {
            PWMI_BUFFER_HEADER    BufferFile;
            PTRACE_LOGFILE_HEADER LogfileHeaderFile;
            ULONG Size;

            BufferFile =
                    (PWMI_BUFFER_HEADER) pFirstBuffer;

            if (BufferFile->Wnode.BufferSize != LoggerContext->BufferSize) {
                TraceDebug((1,
                        "WmipCreateLogFile::BufferSize check fails (%d,%d)\n",
                        BufferFile->Wnode.BufferSize,
                        LoggerContext->BufferSize));
                Status = STATUS_FAIL_CHECK;
                ZwClose(newHandle);
                goto Cleanup;
            }

            if (RtlCompareMemory(BufferFile,
                                 BufferChecksum,
                                 sizeof(WNODE_HEADER))
                        != sizeof(WNODE_HEADER)) {
                TraceDebug((1,"WmipCreateLogFile::WNODE_HEAD check fails\n"));
                Status = STATUS_FAIL_CHECK;
                ZwClose(newHandle);
                goto Cleanup;
            }

            LogfileHeaderFile = (PTRACE_LOGFILE_HEADER)
                    (((PUCHAR) BufferFile) + sizeof(WMI_BUFFER_HEADER)
                                          + sizeof(SYSTEM_TRACE_HEADER));

            // We can only validate part of the header because a 32-bit
            // DLL will be passing in 32-bit pointers
            Size = FIELD_OFFSET(TRACE_LOGFILE_HEADER, LoggerName);
            if (RtlCompareMemory(LogfileHeaderFile,
                                  LogfileHeaderChecksum,
                                  Size)
                        != Size) {
                TraceDebug((1,
                    "WmipCreateLogFile::TRACE_LOGFILE_HEAD check fails\n"));
                Status = STATUS_FAIL_CHECK;
                ZwClose(newHandle);
                goto Cleanup;
            }
        }
        else {
            ZwClose(newHandle);
            goto Cleanup;
        }

        if (LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_PREALLOCATE) {
            ByteOffset.QuadPart = ((LONGLONG) LoggerContext->BufferSize) * BuffersWritten;
        }
        else {
            Status = ZwQueryInformationFile(
                            newHandle,
                            &IoStatus,
                            &FileSize,
                            sizeof (FILE_STANDARD_INFORMATION),
                            FileStandardInformation
                            );
            if (!NT_SUCCESS(Status)) {
                ZwClose(newHandle);
                goto Cleanup;
            }

            ByteOffset = FileSize.EndOfFile;
        }

        //
        // Force to 1K alignment. In future, if disk alignment exceeds this,
        // then use that
        //
        if ((ByteOffset.QuadPart % 1024) != 0) {
            ByteOffset.QuadPart = ((ByteOffset.QuadPart / 1024) + 1) * 1024;
        }

        if (!(LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_PREALLOCATE)) {
            // NOTE: Should also validate BuffersWritten from logfile header with
            // the end of file to make sure that no one else has written garbage
            // to it
            //
            if (ByteOffset.QuadPart !=
                        (  ((LONGLONG) LoggerContext->BufferSize)
                         * BuffersWritten)) {
                TraceDebug((1,
                        "WmipCreateLogFile::FileSize check fails (%I64d,%I64d)\n",
                        ByteOffset.QuadPart,
                        (  ((LONGLONG) LoggerContext->BufferSize)
                         * BuffersWritten)));
                Status = STATUS_FAIL_CHECK;
                ZwClose(newHandle);
                goto Cleanup;
            }
        }

        //
        // Before Switching to the newfile, let's finalize the old file
        //

        if ( SwitchFile && (tempHandle != NULL) ) {
            WmipFinalizeHeader(tempHandle, LoggerContext);
        }

        LoggerContext->FirstBufferOffset = ByteOffset;
        LoggerContext->ByteOffset        = ByteOffset;

        if (LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_PREALLOCATE) {
            LoggerContext->BuffersWritten = BuffersWritten;
        }
        else {
            LoggerContext->BuffersWritten = (ULONG) (FileSize.EndOfFile.QuadPart / LoggerContext->BufferSize);
        }

        LoggerContext->LastFlushedBuffer = LoggerContext->BuffersWritten;

        // Update the log file handle and log file name in the LoggerContext
        LoggerContext->LogFileHandle = newHandle;

        if (SwitchFile) {

            OldLogFileName = LoggerContext->LogFileName;
            LoggerContext->LogFileName = LoggerContext->NewLogFileName;
            FileSwitched = TRUE;

            if ( tempHandle != NULL) {
                //
                // just to be safe, close old file after the switch
                //
                TraceDebug((1, "WmipCreateLogFile: Closing handle %X\n",
                    tempHandle));
                ZwClose(tempHandle);
            }
        }
    }

#if DBG
    else {
        TraceDebug((1,
            "WmipCreateLogFile: ZwCreateFile(%ws) failed with status=%X\n",
            LoggerContext->LogFileName.Buffer, Status));
    }
#endif

Cleanup:
    if (LoggerContext->ClientSecurityContext.ClientToken != NULL) {
        SeDeleteClientSecurity(& LoggerContext->ClientSecurityContext);
        LoggerContext->ClientSecurityContext.ClientToken = NULL;
    }

    // Clean up unicode strings.
    if (SwitchFile) {
        if (!FileSwitched) {
            RtlFreeUnicodeString(&LoggerContext->NewLogFileName);
        }
        else if (OldLogFileName.Buffer != NULL) {
            // OldLogFileName.Buffer can still be NULL if it is the first update
            // for the Kernel Logger.
            RtlFreeUnicodeString(&OldLogFileName);
        }
        // Must do this for the next file switch.
        RtlZeroMemory(&LoggerContext->NewLogFileName, sizeof(UNICODE_STRING));
    }

    if (strLogFileName != NULL) {
        ExFreePool(strLogFileName);
    }
    if (pFirstBuffer != NULL) {
        ExFreePool(pFirstBuffer);
    }
    LoggerContext->LoggerStatus = Status;
    return Status;
}

ULONG
FASTCALL
WmipReleaseTraceBuffer(
    IN PWMI_BUFFER_HEADER BufferResource,
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    ULONG BufRefCount;
    LONG  ReleaseQueue;

    ASSERT(LoggerContext);
    ASSERT(BufferResource);

    BufRefCount = InterlockedDecrement((PLONG) &BufferResource->ReferenceCount);

    //
    // Check if there are buffers to be flushed.
    //
    if (LoggerContext->ReleaseQueue) {
        if (KeGetCurrentIrql() <= DISPATCH_LEVEL) {
            WmipNotifyLogger(LoggerContext);
            LoggerContext->ReleaseQueue = 0;
        }
    }

    ReleaseQueue = LoggerContext->ReleaseQueue;
    WmipDereferenceLogger(LoggerContext->LoggerId);
    return (ReleaseQueue);
}

NTKERNELAPI
ULONG
FASTCALL
WmiReleaseKernelBuffer(
    IN PWMI_BUFFER_HEADER BufferResource
    )
{
    PWMI_LOGGER_CONTEXT LoggerContext = WmipLoggerContext[WmipKernelLogger];
    if (LoggerContext == (PWMI_LOGGER_CONTEXT) &WmipLoggerContext[0]) {
        LoggerContext = BufferResource->LoggerContext;
    }
    WmipAssert(LoggerContext != NULL);
    WmipAssert(LoggerContext != (PWMI_LOGGER_CONTEXT) &WmipLoggerContext[0]);
    return WmipReleaseTraceBuffer(BufferResource, LoggerContext);
}

NTSTATUS
WmipFlushBuffersWithMarker (
    IN PWMI_LOGGER_CONTEXT  LoggerContext,
    IN PSLIST_ENTRY         List,
    IN USHORT               BufferFlag
    ) 
{
    PSLIST_ENTRY  LocalList, Entry;
    PWMI_BUFFER_HEADER Buffer;
    PWMI_BUFFER_HEADER TmpBuffer=NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Retry;
    ULONG BufferCounts = 0;
    USHORT Flag = WMI_BUFFER_FLAG_NORMAL;
    ULONG ErrorCount = 0;

    LocalList = List;

    //
    // Reverse the list to preserve the FIFO order
    //
    Entry = NULL;
    while (LocalList!=NULL) {
        PSLIST_ENTRY  Next;
        Next = LocalList->Next;
        LocalList->Next = Entry;
        Entry = LocalList;
        LocalList = Next;
        BufferCounts++;
    }
    LocalList = Entry;

    //
    // Write all buffers into disk
    //
    while (LocalList != NULL){
        BufferCounts--;
        if (BufferCounts == 0) {
            //
            // Only set the flag at the last buffer.
            //
            Flag = BufferFlag;
        }

        Entry = LocalList;
        LocalList = LocalList->Next;

        Buffer = CONTAINING_RECORD(Entry,
                                   WMI_BUFFER_HEADER,
                                   SlistEntry);

        if (!(LoggerContext->LoggerMode & EVENT_TRACE_BUFFERING_MODE)) {
            //
            // When there is a bursty logging, we can be stuck in this loop.
            // Check if we need to allocate more buffers
            //
            // Only do buffer adjustment if we are not in buffering mode
            //
            WmipAdjustFreeBuffers(LoggerContext);
        }
    

        //
        //
        // Wait until no one else is using the buffer before
        // writing it out.
        //
             
        Retry = 0;
        TmpBuffer = Buffer;
        while (Buffer->ReferenceCount) {
            TraceDebug((1,"Waiting for reference count %3d, retry: %3d\n", 
                        Buffer->ReferenceCount, Retry));
            //
            //
            //
            KeDelayExecutionThread (KernelMode,
                                    FALSE, 
                                    (PLARGE_INTEGER)&WmiShortTime);
            Retry++;
            if (Retry > 10) {
                //
                // The buffer is still in use, we cannot overwite the header.
                // Otherwise it will cause buffer corruption.
                // Use a tempamory buffer instead.
                //
                ULONG BufferSize = LoggerContext->BufferSize;
                TmpBuffer = ExAllocatePoolWithTag(NonPagedPool, 
                                                  BufferSize,
                                                  TRACEPOOLTAG);
    
                if (TmpBuffer) {
                    TraceDebug((1,"Buffer %p has ref count %3d, Tmporary buffer %p Allocated\n", 
                                   Buffer,
                                   Buffer->ReferenceCount,
                                   TmpBuffer));

                    RtlCopyMemory(TmpBuffer, Buffer, BufferSize);
                } else {
                    Status = STATUS_NO_MEMORY;
                }
                break;
            }
        }

        if (TmpBuffer) {
            Status = WmipFlushBuffer(LoggerContext, TmpBuffer, Flag);
        } else {
            //
            // The buffer still in use but allocation of temporary
            // buffer failed.
            // Cannot write this buffer out, claim it as buffer lost
            //

            // If this were the last buffer on file, post processing can
            // fail due to marker buffer failing.  

            LoggerContext->LogBuffersLost++;
        }

        if (TmpBuffer != Buffer) {
            if (TmpBuffer != NULL) {
                ExFreePool(TmpBuffer);
            }
            InterlockedPushEntrySList(&LoggerContext->WaitList,
                                      (PSLIST_ENTRY) &Buffer->SlistEntry);
        } else {
            //
            // Reference count is overwritten during the flush,
            // Set it back.
            //
            Buffer->ReferenceCount = 0;
            WmipPushFreeBuffer (LoggerContext, Buffer);
        }

        if ((Status == STATUS_LOG_FILE_FULL) ||
            (Status == STATUS_DISK_FULL) ||
            (Status == STATUS_NO_DATA_DETECTED) ||
            (Status == STATUS_SEVERITY_WARNING)) {
 
            TraceDebug((1,
                "WmipFlushActiveBuffers: Buffer flushed with status=%X\n",
                Status));
            if ((Status == STATUS_LOG_FILE_FULL) ||
                (Status == STATUS_DISK_FULL)) {
                ErrorCount ++;
            } else {
                ErrorCount = 0; // reset to zero otherwise
            }

            if (ErrorCount <= WmiWriteFailureLimit) {
                Status = STATUS_SUCCESS;     // Let tracing continue
                continue;       // for now. Should raise WMI event
            }
        }
    }

    if (!NT_SUCCESS(Status)) {
        TraceDebug((1,
            "WmipLogger: Flush failed, status=%X LoggerContext=%X\n",
                 Status, LoggerContext));
        if (LoggerContext->LogFileHandle != NULL) {
#if DBG
            NTSTATUS CloseStatus = 
#endif
            ZwClose(LoggerContext->LogFileHandle);
            TraceDebug((1,
                "WmipLogger: Close logfile with status=%X\n", CloseStatus));
        }
        LoggerContext->LogFileHandle = NULL;

        WmipSendNotification(LoggerContext,
            Status, (Status & 0xC0000000) >> 30);

    }

    return Status;
}

NTSTATUS
WmipFlushActiveBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN ULONG FlushAll
    )
{
    PWMI_BUFFER_HEADER Buffer;
    ULONG i;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG LoggerMode;
    PSLIST_ENTRY  LocalList, Entry;


    PAGED_CODE();

    //
    // If we have no LogFileHandle or RealTime mode, and the collection
    // is still on, we simply return and let the buffers back up potentially
    // losing events. If the Collection is Off under these conditions
    // we will simply move the FlushList to FreeList as in Buffering mode. 
    //

    LoggerMode = LoggerContext->LoggerMode;

    if ( (LoggerContext->LogFileHandle == NULL)       &&
         (!(LoggerMode & EVENT_TRACE_REAL_TIME_MODE)) &&
         (LoggerContext->CollectionOn) ) 
    {
        return Status;
    }


    LocalList = NULL;
    if (FlushAll) {
        PWMI_BUFFER_HEADER Buffers[MAXIMUM_PROCESSORS];
        //
        // First switch all in-used buffers.
        // Put them in a tighter loop to minimize the chance of
        // events out of order.
        //
        for (i=0; i<(ULONG)KeNumberProcessors; i++) {
            Buffers[i] = InterlockedExchangePointer(&LoggerContext->ProcessorBuffers[i], NULL);
        }

        //
        // Put all in-used buffers into flush list
        //
        for (i=0; i<(ULONG)KeNumberProcessors; i++) {
            if (Buffers[i]) {
                WmipPushDirtyBuffer ( LoggerContext, Buffers[i] );
            }
        }

        if (LoggerContext->LoggerId == WmipKernelLogger) {
            if ( PERFINFO_IS_GROUP_ON(PERF_CONTEXT_SWITCH) ) {
                for (i=0; i<(ULONG)KeNumberProcessors; i++) {
                    //
                    // Flush all Buffers used for Context swaps
                    //
                    Buffer = InterlockedExchangePointer(&WmipContextSwapProcessorBuffers[i], NULL);
                    if (Buffer) {
                        WmipPushDirtyBuffer ( LoggerContext, Buffer);
                    }
                }
            }
        }

        //
        //  Now push all dirty buffers in the local list.
        //  This almost guarantees that the flush marker will work.
        //
        if (ExQueryDepthSList(&LoggerContext->FlushList) != 0) {
            LocalList = ExInterlockedFlushSList (&LoggerContext->FlushList);
            WmipFlushBuffersWithMarker (LoggerContext, LocalList, WMI_BUFFER_FLAG_FLUSH_MARKER);
        }

    } else if (ExQueryDepthSList(&LoggerContext->FlushList) != 0) {
        LocalList = ExInterlockedFlushSList (&LoggerContext->FlushList);
        WmipFlushBuffersWithMarker (LoggerContext, LocalList, WMI_BUFFER_FLAG_NORMAL);
    }

    //
    // Now check if any of the in-used buffer is freed.
    //
    if (ExQueryDepthSList(&LoggerContext->WaitList) != 0) {
        LocalList = ExInterlockedFlushSList (&LoggerContext->WaitList);
        while (LocalList != NULL){
            Entry = LocalList;
            LocalList = LocalList->Next;

            Buffer = CONTAINING_RECORD(Entry,
                                       WMI_BUFFER_HEADER,
                                       SlistEntry);

            TraceDebug((1,"Wait List Buffer %p RefCount: %3d\n", 
                           Buffer,
                           Buffer->ReferenceCount));

            if (Buffer->ReferenceCount) {

                //
                // Still in use, put it back to WaitList
                //
                InterlockedPushEntrySList(&LoggerContext->WaitList,
                                          (PSLIST_ENTRY) &Buffer->SlistEntry);

            } else {
                //
                // Push it to free list
                //
                WmipPushFreeBuffer (LoggerContext, Buffer);
            }
        }

    }
    return Status;
}

NTSTATUS
WmipGenerateFileName(
    IN PUNICODE_STRING FilePattern,
    IN OUT PLONG FileCounter,
    OUT PUNICODE_STRING FileName
    )
{
    LONG FileCount, Size;
    PWCHAR Buffer = NULL;
    HRESULT hr;
    PWCHAR wcptr;

    PAGED_CODE();

    if (FilePattern->Buffer == NULL)
        return STATUS_INVALID_PARAMETER_MIX;

    // Check for valid format string
    wcptr = wcschr(FilePattern->Buffer, L'%');
    if (NULL == wcptr || wcptr != wcsrchr(FilePattern->Buffer, L'%')) {
        return STATUS_OBJECT_NAME_INVALID;
    }
    else if (NULL == wcsstr(FilePattern->Buffer, L"%d")) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    FileCount = InterlockedIncrement(FileCounter);
    Size = FilePattern->MaximumLength + 64; // 32 digits: plenty for ULONG

    Buffer = ExAllocatePoolWithTag(PagedPool, Size, TRACEPOOLTAG);
    if (Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    hr = StringCbPrintfW(Buffer, Size, FilePattern->Buffer, FileCount);

    if (FAILED(hr) || RtlEqualMemory(FilePattern->Buffer, Buffer, FilePattern->Length)) {
        ExFreePool(Buffer);
        return STATUS_INVALID_PARAMETER_MIX;
    }
    RtlInitUnicodeString(FileName, Buffer);
    return STATUS_SUCCESS;
}

NTSTATUS
WmipPrepareHeader(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN OUT PWMI_BUFFER_HEADER Buffer,
    IN USHORT BufferFlag
    )
/*++

Routine Description:
    This routine prepares the buffer header before writing the
    buffer out to Disk.

    If (SavedOffset > 0), it must be the case the we have overflown
    CurrentOffset during WmipReserveTraceBuffer.  SavedOffset should
    be the real offset of dirty buffer area.

    If SavedOffset is not set, it is either a ContextSwap buffer
    or a buffer flushed due to flush timer.  CurrentOffset should
    be used for writting it out.


Calling Functions:
    - WmipFlushBuffer

Arguments:

    LoggerContext - Logger context

    Buffer        - Pointer to a buffer header that we wish to write to disk

Return Value:

    NtStatus.

--*/
{
    ULONG BufferSize;
    PAGED_CODE();

    BufferSize = LoggerContext->BufferSize;

    if (Buffer->SavedOffset > 0) {
        Buffer->Offset = Buffer->SavedOffset;
    }
    else {
        if (Buffer->CurrentOffset > BufferSize) {
            //
            // Some thread has incremented CurrentOffset but was swapped out 
            // and did not come back until the buffer is about to be flushed.
            // We will correct the CurrentOffset here and hope that post
            // processing will handle this correctly.
            //
            TraceDebug((3, "WmipPrepareHeader: correcting Buffer Offset %d, RefCount: %d\n",
                        Buffer->CurrentOffset, Buffer->ReferenceCount));
            Buffer->Offset = BufferSize;
        }
        else {
            Buffer->Offset = Buffer->CurrentOffset;
        }
    }

    ASSERT (Buffer->Offset >= sizeof(WMI_BUFFER_HEADER));
    ASSERT (Buffer->Offset <= LoggerContext->BufferSize);


    //
    // We write empty buffers if they have FLUSH_MARKER to facilitate 
    // post processing
    //

    if ( (BufferFlag != WMI_BUFFER_FLAG_FLUSH_MARKER) && (Buffer->Offset == sizeof(WMI_BUFFER_HEADER)) ) { // empty buffer
        return STATUS_NO_DATA_DETECTED;
    }

    //
    // Fill the rest of buffer with 0XFF
    //
    if ( Buffer->Offset < BufferSize ) {
        RtlFillMemory(
            (char *) Buffer + Buffer->Offset,
            BufferSize - Buffer->Offset,
            0XFF);
    }

    Buffer->Wnode.BufferSize = BufferSize;
    Buffer->ClientContext.LoggerId = (USHORT) LoggerContext->LoggerId;
    if (Buffer->ClientContext.LoggerId == 0)
        Buffer->ClientContext.LoggerId = (USHORT) KERNEL_LOGGER_ID;

    Buffer->ClientContext.Alignment = (UCHAR) WmiTraceAlignment;
    Buffer->Wnode.Guid = LoggerContext->InstanceGuid;
    Buffer->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    Buffer->Wnode.ProviderId = LoggerContext->BuffersWritten+1;
    Buffer->BufferFlag = BufferFlag;

    KeQuerySystemTime(&Buffer->Wnode.TimeStamp);
    return STATUS_SUCCESS;
}

NTKERNELAPI
VOID
WmiBootPhase1(
    )                
/*++

Routine Description:

    NtInitializeRegistry to inform WMI that autochk is performed
    and it is OK now to write to disk.

Arguments:

    None

Return Value:

    None

--*/

{
    PAGED_CODE();

    WmipFileSystemReady = TRUE;
}


NTSTATUS
WmipFinalizeHeader(
    IN HANDLE FileHandle,
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    LARGE_INTEGER ByteOffset;
    NTSTATUS Status;
    PTRACE_LOGFILE_HEADER FileHeader;
    IO_STATUS_BLOCK IoStatus;
    CHAR Buffer[PAGE_SIZE];     // Assumes Headers less than PAGE_SIZE

    PAGED_CODE();

    ByteOffset.QuadPart = 0;
    Status = ZwReadFile(
                FileHandle,
                NULL,
                NULL,
                NULL,
                & IoStatus,
                &Buffer[0],
                PAGE_SIZE,
                & ByteOffset,
                NULL);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    FileHeader = (PTRACE_LOGFILE_HEADER)
                 &Buffer[sizeof(WMI_BUFFER_HEADER) + sizeof(SYSTEM_TRACE_HEADER)];
    FileHeader->BuffersWritten = LoggerContext->BuffersWritten;

    if (LoggerContext->RequestFlag & REQUEST_FLAG_CIRCULAR_TRANSITION) {
        FileHeader->StartBuffers = (ULONG) 
                                   (LoggerContext->FirstBufferOffset.QuadPart
                                   / LoggerContext->BufferSize);
    }

    KeQuerySystemTime(&FileHeader->EndTime);
    if (LoggerContext->Wow && !LoggerContext->KernelTraceOn) {
        // We need to adjust a log file header for a non-kernel WOW64 logger.
        *((PULONG)((PUCHAR)(&FileHeader->BuffersLost) - 8)) 
                                            = LoggerContext->LogBuffersLost;
    }
    else {
        FileHeader->BuffersLost = LoggerContext->LogBuffersLost;
    }
    FileHeader->EventsLost = LoggerContext->EventsLost;
    Status = ZwWriteFile(
                FileHandle,
                NULL,
                NULL,
                NULL,
                &IoStatus,
                &Buffer[0],
                PAGE_SIZE,
                &ByteOffset,
                NULL);
    return Status;
}

#if DBG

#define DEBUG_BUFFER_LENGTH 1024
UCHAR TraceDebugBuffer[DEBUG_BUFFER_LENGTH];

VOID
TraceDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all DiskPerf

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    LARGE_INTEGER Clock;
    ULONG Tid;
    va_list ap;

    va_start(ap, DebugMessage);


    if  (WmipTraceDebugLevel >= DebugPrintLevel) {

        StringCbVPrintfA((PCHAR)TraceDebugBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);

        Clock = KeQueryPerformanceCounter(NULL);
        Tid = HandleToUlong(PsGetCurrentThreadId());
        DbgPrintEx(DPFLTR_WMILIB_ID, DPFLTR_INFO_LEVEL,
                   "%u (%5u): %s", Clock.LowPart, Tid, TraceDebugBuffer);
    }

    va_end(ap);

}
#endif //DBG


VOID
FASTCALL
WmipResetBufferHeader (
    PWMI_LOGGER_CONTEXT     LoggerContext,
    PWMI_BUFFER_HEADER      Buffer,
    USHORT                  BufferType
    )
/*++

Routine Description:
    This is a function which initializes a few buffer header values
    that are used by both WmipGetFreeBuffer and WmipPopFreeContextSwapBuffer

    Note that this function increments a few logger context reference counts

Calling Functions:
    - WmipGetFreeBuffer
    - WmipPopFreeContextSwapBuffer

Arguments:

    LoggerContext - Logger context from where we have acquired a free buffer

    Buffer        - Pointer to a buffer header that we wish to reset

    BufferType    - Buffer type (e.g., Generic, ContextSwap, etc.).
                    This is to make postprocessing easier.

Return Value:

    None

--*/
{
    ASSERT (BufferType < WMI_BUFFER_TYPE_MAXIMUM);
    Buffer->SavedOffset = 0;
    Buffer->CurrentOffset = sizeof(WMI_BUFFER_HEADER);
    Buffer->Wnode.ClientContext = 0;
    Buffer->LoggerContext = LoggerContext;
    Buffer->BufferType = BufferType;
       
    Buffer->State.Free = 0;
    Buffer->State.InUse = 1;

}


VOID
FASTCALL
WmipPushDirtyBuffer (
    PWMI_LOGGER_CONTEXT     LoggerContext,
    PWMI_BUFFER_HEADER      Buffer
)
/*++

Routine Description:
    This is a function which prepares a buffer's header and places it on a
    logger's flush list.  

    Note that this function manages a few logger context reference counts

Calling Functions:
    - WmipFlushActiveBuffers
    - WmipPushDirtyContextSwapBuffer

Arguments:

    LoggerContext - Logger context from which we originally acquired a buffer

    Buffer        - Pointer to a buffer that we wish to flush

Return Value:

    None

--*/
{
    ASSERT(Buffer->State.Flush == 0);
    ASSERT(Buffer->State.Free == 0);
    ASSERT(Buffer->State.InUse == 1);
    //
    // Set the buffer flags to "flush" state
    //
    Buffer->State.InUse = 0;
    Buffer->State.Flush = 1;

    //
    // Push the buffer onto the flushlist.  This could only
    // fail if the Wmi kernel logger shut down without notifying us.
    // If this happens, there is nothing we can do about it anyway.
    // If Wmi is well behaved, this will never fail.
    //
    InterlockedPushEntrySList(
        &LoggerContext->FlushList,
        (PSLIST_ENTRY) &Buffer->SlistEntry);

    //
    // Maintain some reference counts
    //
    InterlockedDecrement((PLONG) &LoggerContext->BuffersInUse);
    InterlockedIncrement((PLONG) &LoggerContext->BuffersDirty);


    TraceDebug((2, "Flush Dirty Buffer: %p, Free: %d, InUse: %d, %Dirty: %d, Total: %d, (Thread: %p)\n",
                    Buffer,
                    LoggerContext->BuffersAvailable,
                    LoggerContext->BuffersInUse,
                    LoggerContext->BuffersDirty,
                    LoggerCon